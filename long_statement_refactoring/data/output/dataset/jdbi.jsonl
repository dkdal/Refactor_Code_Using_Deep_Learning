{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.transaction;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Jdbi;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.InOrder;\n\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.calls;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.when;\n\npublic class TestTransactionsAutoCommit {\n\n    public static final String SAMPLE_SQL = \"insert into something (id, name) values (?, ?)\";\n\n    @Test\n    public void restoreAutoCommitInitialStateOnUnexpectedError() throws Exception {\n\n        final Connection connection = mock(Connection.class);\n        final PreparedStatement statement = mock(PreparedStatement.class);\n\n        when(connection.getAutoCommit()).thenReturn(true);\n        when(connection.prepareStatement(anyString(), anyInt(), anyInt())).thenReturn(statement);\n        when(statement.execute()).thenReturn(true);\n        when(statement.getUpdateCount()).thenReturn(1);\n        // throw e.g some underlying database error\n        doThrow(new SQLException(\"infrastructure error\")).when(connection).commit();\n\n        try (Handle h = Jdbi.create(() -> connection).open()) {\n            h.begin();\n\n            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {\n                h.execute(SAMPLE_SQL, 1L, \"Tom\");\n\n                // throws exception on commit\n                h.commit();\n            });\n        }\n\n        InOrder inOrder = inOrder(connection, statement);\n\n        // expected behaviour chain:\n        // 1. store initial auto-commit state\n        inOrder.verify(connection, calls(1)).getAutoCommit();\n\n        // 2. turn off auto-commit\n        inOrder.verify(connection).setAutoCommit(false);\n\n        // 3. execute statement (without commit)\n        inOrder.verify(connection).prepareStatement(\"insert into something (id, name) values (?, ?)\", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n        inOrder.verify(statement).execute();\n        inOrder.verify(statement).getUpdateCount();\n\n        // 4. commit transaction\n        inOrder.verify(connection).commit();\n\n        // 5. set auto-commit back to initial state\n        inOrder.verify(connection).setAutoCommit(true);\n\n        inOrder.verify(connection, times(1)).close();\n\n        inOrder.verifyNoMoreInteractions();\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.transaction;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Jdbi;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.InOrder;\n\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.calls;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.when;\n\npublic class TestTransactionsAutoCommit {\n\n    public static final String SAMPLE_SQL = \"insert into something (id, name) values (?, ?)\";\n\n    @Test\n    public void restoreAutoCommitInitialStateOnUnexpectedError() throws Exception {\n\n        final Connection connection = mock(Connection.class);\n        final PreparedStatement statement = mock(PreparedStatement.class);\n\n        when(connection.getAutoCommit()).thenReturn(true);\n        when(connection.prepareStatement(anyString(), anyInt(), anyInt())).thenReturn(statement);\n        when(statement.execute()).thenReturn(true);\n        when(statement.getUpdateCount()).thenReturn(1);\n        // throw e.g some underlying database error\n        var exception = new SQLException(\"infrastructure error\");\n        doThrow(exception).when(connection).commit();\n\n        try (Handle h = Jdbi.create(() -> connection).open()) {\n            h.begin();\n\n            assertThatThrownBy(() -> {\n                h.execute(SAMPLE_SQL, 1L, \"Tom\");\n\n                // throws exception on commit\n                h.commit();\n            }).hasCause(exception);\n        }\n\n        InOrder inOrder = inOrder(connection, statement);\n\n        // expected behaviour chain:\n        // 1. store initial auto-commit state\n        inOrder.verify(connection, calls(1)).getAutoCommit();\n\n        // 2. turn off auto-commit\n        inOrder.verify(connection).setAutoCommit(false);\n\n        // 3. execute statement (without commit)\n        inOrder.verify(connection).prepareStatement(\"insert into something (id, name) values (?, ?)\", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n        inOrder.verify(statement).execute();\n        inOrder.verify(statement).getUpdateCount();\n\n        // 4. commit transaction, which explodes\n        inOrder.verify(connection).commit();\n\n        // 5. rollback transaction\n        inOrder.verify(connection).rollback();\n\n        // 6. set auto-commit back to initial state\n        inOrder.verify(connection).setAutoCommit(true);\n\n        inOrder.verify(connection, times(1)).close();\n\n        inOrder.verifyNoMoreInteractions();\n    }\n\n}\n","lineNo":51}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.util.List;\n\nimport org.antlr.v4.runtime.CharStreams;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.internal.SqlScriptParser;\nimport org.jdbi.v3.core.internal.SqlScriptParser.ScriptTokenHandler;\n\n/**\n * Represents a number of SQL statements delimited by semicolon which will be executed in order in a batch statement.\n */\npublic class Script extends SqlStatement<Script> {\n    public Script(Handle handle, CharSequence sql) {\n        super(handle, sql);\n    }\n\n    /**\n     * Backwards compatible constructor that takes an explicit string argument.\n     *\n     * @see Script#Script(Handle, CharSequence)\n     */\n    public Script(Handle handle, String sql) {\n        super(handle, sql);\n    }\n\n    /**\n     * Execute this script in a batch statement\n     *\n     * @return an array of ints which are the results of each statement in the script\n     */\n    public int[] execute() {\n        final List<String> statements = getStatements();\n        try (Batch b = getHandle().createBatch()) {\n            statements.forEach(b::add);\n            return b.execute();\n        }\n    }\n\n    /**\n     * Execute this script as a set of separate statements\n     */\n    public void executeAsSeparateStatements() {\n        for (String s : getStatements()) {\n            getHandle().execute(s);\n        }\n    }\n\n    /**\n     * Locate the Script and split it into statements.\n     * @return the split statements\n     */\n    public List<String> getStatements() {\n        return splitToStatements(getConfig(SqlStatements.class).getTemplateEngine().render(getSql(), getContext()));\n    }\n\n    private List<String> splitToStatements(String script) {\n        ScriptTokenHandler scriptTokenHandler = new ScriptTokenHandler();\n        String lastStatement = new SqlScriptParser(scriptTokenHandler)\n            .parse(CharStreams.fromString(script));\n\n        return scriptTokenHandler.addStatement(lastStatement);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.util.List;\n\nimport org.antlr.v4.runtime.CharStreams;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.internal.SqlScriptParser;\nimport org.jdbi.v3.core.internal.SqlScriptParser.ScriptTokenHandler;\n\n/**\n * Represents a number of SQL statements delimited by semicolon which will be executed in order in a batch statement.\n */\npublic class Script extends SqlStatement<Script> {\n    private final boolean requireSemicolon;\n\n    public Script(Handle handle, CharSequence sql) {\n        super(handle, sql);\n        this.requireSemicolon = handle.getConfig(SqlStatements.class).isScriptStatementsNeedSemicolon();\n    }\n\n    /**\n     * Backwards compatible constructor that takes an explicit string argument.\n     *\n     * @see Script#Script(Handle, CharSequence)\n     */\n    public Script(Handle handle, String sql) {\n        super(handle, sql);\n        this.requireSemicolon = handle.getConfig(SqlStatements.class).isScriptStatementsNeedSemicolon();\n    }\n\n    /**\n     * Execute this script in a batch statement\n     *\n     * @return an array of ints which are the results of each statement in the script\n     */\n    public int[] execute() {\n        final List<String> statements = getStatements();\n        try (Batch b = getHandle().createBatch()) {\n            statements.forEach(b::add);\n            return b.execute();\n        }\n    }\n\n    /**\n     * Execute this script as a set of separate statements\n     */\n    public void executeAsSeparateStatements() {\n        for (String s : getStatements()) {\n            getHandle().execute(s);\n        }\n    }\n\n    /**\n     * Locate the Script and split it into statements.\n     * @return the split statements\n     */\n    public List<String> getStatements() {\n        var templateEngine = getConfig(SqlStatements.class).getTemplateEngine();\n        return splitToStatements(templateEngine.render(getSql(), getContext()));\n    }\n\n    private List<String> splitToStatements(String script) {\n        ScriptTokenHandler scriptTokenHandler = new ScriptTokenHandler(this.requireSemicolon);\n        String lastStatement = new SqlScriptParser(scriptTokenHandler)\n            .parse(CharStreams.fromString(script));\n\n        return scriptTokenHandler.addStatement(lastStatement);\n    }\n}\n","lineNo":71}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.spring5;\n\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;\nimport org.springframework.context.annotation.ImportBeanDefinitionRegistrar;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.filter.AnnotationTypeFilter;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * This bean registers the bean definitions of all repositories.\n * Interfaces found using the configuration of {@link EnableJdbiRepositories}\n * and annotated with {@link JdbiRepository} will be registered.\n */\npublic class JdbiRepositoryRegistrar implements ImportBeanDefinitionRegistrar {\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n        Iterable<BeanDefinition> repositoryBeanDefinitions = resolveRepositoryBeanDefinitions(metadata);\n        for (BeanDefinition repositoryBeanDefinition : repositoryBeanDefinitions) {\n            AnnotationMetadata annotationMetadata = ((AnnotatedBeanDefinition) repositoryBeanDefinition).getMetadata();\n            registerJdbiRepositoryFactoryBean(registry, annotationMetadata);\n        }\n    }\n\n    private void registerJdbiRepositoryFactoryBean(BeanDefinitionRegistry registry, AnnotationMetadata annotationMetadata) {\n        String className = annotationMetadata.getClassName();\n        @SuppressWarnings(\"rawtypes\")\n        Class clazz = ClassUtils.resolveClassName(className, null);\n\n        Map<String, Object> attributes = getAnnotationAttributes(JdbiRepository.class, annotationMetadata);\n        String jdbiQualifier = (String) attributes.get(\"jdbiQualifier\");\n        String value = (String) attributes.get(\"value\");\n\n        JdbiRepositoryFactoryBean factoryBean = new JdbiRepositoryFactoryBean();\n        factoryBean.setObjectType(clazz);\n        factoryBean.setBeanFactory((BeanFactory) registry);\n        if (StringUtils.hasText(jdbiQualifier)) {\n            factoryBean.setJdbiQualifier(jdbiQualifier);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(clazz, factoryBean::getObject);\n        String beanName = StringUtils.hasText(value) ? value : className;\n        registry.registerBeanDefinition(beanName, builder.getBeanDefinition());\n    }\n\n    private Iterable<BeanDefinition> resolveRepositoryBeanDefinitions(AnnotationMetadata metadata) {\n        LinkedHashSet<BeanDefinition> repositoryDefinitions = new LinkedHashSet<>();\n        Map<String, Object> attrs = getAnnotationAttributes(EnableJdbiRepositories.class, metadata);\n        final Class<?>[] clients = (Class<?>[]) attrs.get(\"repositories\");\n        if (clients.length > 0) {\n            for (Class<?> clazz : clients) {\n                repositoryDefinitions.add(new AnnotatedGenericBeanDefinition(clazz));\n            }\n        } else {\n            ClassPathScanningCandidateComponentProvider scanner = createScanner();\n            Set<String> basePackages = resolveBasePackages(metadata);\n            for (String basePackage : basePackages) {\n                repositoryDefinitions.addAll(scanner.findCandidateComponents(basePackage));\n            }\n        }\n        return repositoryDefinitions;\n    }\n\n    private Set<String> resolveBasePackages(AnnotationMetadata metadata) {\n        Map<String, Object> attributes = getAnnotationAttributes(EnableJdbiRepositories.class, metadata);\n        Set<String> basePackages = new HashSet<>();\n        for (String pkg : (String[]) attributes.get(\"value\")) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        for (String pkg : (String[]) attributes.get(\"basePackages\")) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        for (Class<?> clazz : (Class<?>[]) attributes.get(\"basePackageClasses\")) {\n            basePackages.add(ClassUtils.getPackageName(clazz));\n        }\n\n        if (basePackages.isEmpty()) {\n            basePackages.add(ClassUtils.getPackageName(metadata.getClassName()));\n        }\n        return basePackages;\n    }\n\n    private ClassPathScanningCandidateComponentProvider createScanner() {\n        var scanner = new ClassPathScanningCandidateComponentProvider() {\n            @Override\n            protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n                return beanDefinition.getMetadata().isInterface();\n            }\n        };\n        scanner.addIncludeFilter(new AnnotationTypeFilter(JdbiRepository.class));\n        return scanner;\n    }\n\n    private Map<String, Object> getAnnotationAttributes(Class<?> annotationClass, AnnotationMetadata metadata) {\n        Map<String, Object> attributes = metadata.getAnnotationAttributes(annotationClass.getCanonicalName());\n        if (attributes == null) {\n            throw new IllegalStateException(\"Annotation for \" + annotationClass + \" not found in metadata?!\");\n        }\n        return attributes;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.spring5;\n\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;\nimport org.springframework.context.annotation.ImportBeanDefinitionRegistrar;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.filter.AnnotationTypeFilter;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * This bean registers the bean definitions of all repositories.\n * Interfaces found using the configuration of {@link EnableJdbiRepositories}\n * and annotated with {@link JdbiRepository} will be registered.\n */\npublic class JdbiRepositoryRegistrar implements ImportBeanDefinitionRegistrar {\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n        EnableJdbiRepositories annotation = metadata.getAnnotations().get(EnableJdbiRepositories.class).synthesize();\n        String annotatedClass = metadata.getClassName();\n        Iterable<BeanDefinition> repositoryBeanDefinitions = resolveRepositoryBeanDefinitions(annotation, annotatedClass);\n        for (BeanDefinition repositoryBeanDefinition : repositoryBeanDefinitions) {\n            AnnotationMetadata annotationMetadata = ((AnnotatedBeanDefinition) repositoryBeanDefinition).getMetadata();\n            String repositoryClass = annotationMetadata.getClassName();\n            JdbiRepository repositoryAnnotation = annotationMetadata.getAnnotations().get(JdbiRepository.class).synthesize();\n            registerJdbiRepositoryFactoryBean(registry, repositoryAnnotation, repositoryClass);\n        }\n    }\n\n    private void registerJdbiRepositoryFactoryBean(BeanDefinitionRegistry registry, JdbiRepository annotation, String annotatedClass) {\n        @SuppressWarnings(\"rawtypes\")\n        Class clazz = ClassUtils.resolveClassName(annotatedClass, null);\n        String jdbiQualifier = annotation.jdbiQualifier();\n        String value = annotation.value();\n\n        JdbiRepositoryFactoryBean factoryBean = new JdbiRepositoryFactoryBean();\n        factoryBean.setObjectType(clazz);\n        factoryBean.setBeanFactory((BeanFactory) registry);\n        if (StringUtils.hasText(jdbiQualifier)) {\n            factoryBean.setJdbiQualifier(jdbiQualifier);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(clazz, factoryBean::getObject);\n        String beanName = StringUtils.hasText(value) ? value : annotatedClass;\n        registry.registerBeanDefinition(beanName, builder.getBeanDefinition());\n    }\n\n    private Iterable<BeanDefinition> resolveRepositoryBeanDefinitions(EnableJdbiRepositories annotation, String annotatedClass) {\n        LinkedHashSet<BeanDefinition> repositoryDefinitions = new LinkedHashSet<>();\n        if (annotation.repositories().length > 0) {\n            for (Class<?> clazz : annotation.repositories()) {\n                repositoryDefinitions.add(new AnnotatedGenericBeanDefinition(clazz));\n            }\n        } else {\n            ClassPathScanningCandidateComponentProvider scanner = createScanner();\n            Set<String> basePackages = resolveBasePackages(annotation, annotatedClass);\n            for (String basePackage : basePackages) {\n                repositoryDefinitions.addAll(scanner.findCandidateComponents(basePackage));\n            }\n        }\n        return repositoryDefinitions;\n    }\n\n    private Set<String> resolveBasePackages(EnableJdbiRepositories annotation, String annotatedClass) {\n        Set<String> basePackages = new HashSet<>();\n        for (String pkg : annotation.value()) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        for (String pkg : annotation.basePackages()) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        for (Class<?> clazz : annotation.basePackageClasses()) {\n            basePackages.add(ClassUtils.getPackageName(clazz));\n        }\n\n        if (basePackages.isEmpty()) {\n            basePackages.add(ClassUtils.getPackageName(annotatedClass));\n        }\n        return basePackages;\n    }\n\n    private ClassPathScanningCandidateComponentProvider createScanner() {\n        var scanner = new ClassPathScanningCandidateComponentProvider() {\n            @Override\n            protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n                return beanDefinition.getMetadata().isInterface();\n            }\n        };\n        scanner.addIncludeFilter(new AnnotationTypeFilter(JdbiRepository.class));\n        return scanner;\n    }\n}\n","lineNo":43}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.spring5;\n\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;\nimport org.springframework.context.annotation.ImportBeanDefinitionRegistrar;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.filter.AnnotationTypeFilter;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * This bean registers the bean definitions of all repositories.\n * Interfaces found using the configuration of {@link EnableJdbiRepositories}\n * and annotated with {@link JdbiRepository} will be registered.\n */\npublic class JdbiRepositoryRegistrar implements ImportBeanDefinitionRegistrar {\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n        Iterable<BeanDefinition> repositoryBeanDefinitions = resolveRepositoryBeanDefinitions(metadata);\n        for (BeanDefinition repositoryBeanDefinition : repositoryBeanDefinitions) {\n            AnnotationMetadata annotationMetadata = ((AnnotatedBeanDefinition) repositoryBeanDefinition).getMetadata();\n            registerJdbiRepositoryFactoryBean(registry, annotationMetadata);\n        }\n    }\n\n    private void registerJdbiRepositoryFactoryBean(BeanDefinitionRegistry registry, AnnotationMetadata annotationMetadata) {\n        String className = annotationMetadata.getClassName();\n        @SuppressWarnings(\"rawtypes\")\n        Class clazz = ClassUtils.resolveClassName(className, null);\n\n        Map<String, Object> attributes = getAnnotationAttributes(JdbiRepository.class, annotationMetadata);\n        String jdbiQualifier = (String) attributes.get(\"jdbiQualifier\");\n        String value = (String) attributes.get(\"value\");\n\n        JdbiRepositoryFactoryBean factoryBean = new JdbiRepositoryFactoryBean();\n        factoryBean.setObjectType(clazz);\n        factoryBean.setBeanFactory((BeanFactory) registry);\n        if (StringUtils.hasText(jdbiQualifier)) {\n            factoryBean.setJdbiQualifier(jdbiQualifier);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(clazz, factoryBean::getObject);\n        String beanName = StringUtils.hasText(value) ? value : className;\n        registry.registerBeanDefinition(beanName, builder.getBeanDefinition());\n    }\n\n    private Iterable<BeanDefinition> resolveRepositoryBeanDefinitions(AnnotationMetadata metadata) {\n        LinkedHashSet<BeanDefinition> repositoryDefinitions = new LinkedHashSet<>();\n        Map<String, Object> attrs = getAnnotationAttributes(EnableJdbiRepositories.class, metadata);\n        final Class<?>[] clients = (Class<?>[]) attrs.get(\"repositories\");\n        if (clients.length > 0) {\n            for (Class<?> clazz : clients) {\n                repositoryDefinitions.add(new AnnotatedGenericBeanDefinition(clazz));\n            }\n        } else {\n            ClassPathScanningCandidateComponentProvider scanner = createScanner();\n            Set<String> basePackages = resolveBasePackages(metadata);\n            for (String basePackage : basePackages) {\n                repositoryDefinitions.addAll(scanner.findCandidateComponents(basePackage));\n            }\n        }\n        return repositoryDefinitions;\n    }\n\n    private Set<String> resolveBasePackages(AnnotationMetadata metadata) {\n        Map<String, Object> attributes = getAnnotationAttributes(EnableJdbiRepositories.class, metadata);\n        Set<String> basePackages = new HashSet<>();\n        for (String pkg : (String[]) attributes.get(\"value\")) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        for (String pkg : (String[]) attributes.get(\"basePackages\")) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        for (Class<?> clazz : (Class<?>[]) attributes.get(\"basePackageClasses\")) {\n            basePackages.add(ClassUtils.getPackageName(clazz));\n        }\n\n        if (basePackages.isEmpty()) {\n            basePackages.add(ClassUtils.getPackageName(metadata.getClassName()));\n        }\n        return basePackages;\n    }\n\n    private ClassPathScanningCandidateComponentProvider createScanner() {\n        var scanner = new ClassPathScanningCandidateComponentProvider() {\n            @Override\n            protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n                return beanDefinition.getMetadata().isInterface();\n            }\n        };\n        scanner.addIncludeFilter(new AnnotationTypeFilter(JdbiRepository.class));\n        return scanner;\n    }\n\n    private Map<String, Object> getAnnotationAttributes(Class<?> annotationClass, AnnotationMetadata metadata) {\n        Map<String, Object> attributes = metadata.getAnnotationAttributes(annotationClass.getCanonicalName());\n        if (attributes == null) {\n            throw new IllegalStateException(\"Annotation for \" + annotationClass + \" not found in metadata?!\");\n        }\n        return attributes;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.spring5;\n\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;\nimport org.springframework.context.annotation.ImportBeanDefinitionRegistrar;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.filter.AnnotationTypeFilter;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * This bean registers the bean definitions of all repositories.\n * Interfaces found using the configuration of {@link EnableJdbiRepositories}\n * and annotated with {@link JdbiRepository} will be registered.\n */\npublic class JdbiRepositoryRegistrar implements ImportBeanDefinitionRegistrar {\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n        EnableJdbiRepositories annotation = metadata.getAnnotations().get(EnableJdbiRepositories.class).synthesize();\n        String annotatedClass = metadata.getClassName();\n        Iterable<BeanDefinition> repositoryBeanDefinitions = resolveRepositoryBeanDefinitions(annotation, annotatedClass);\n        for (BeanDefinition repositoryBeanDefinition : repositoryBeanDefinitions) {\n            AnnotationMetadata annotationMetadata = ((AnnotatedBeanDefinition) repositoryBeanDefinition).getMetadata();\n            String repositoryClass = annotationMetadata.getClassName();\n            JdbiRepository repositoryAnnotation = annotationMetadata.getAnnotations().get(JdbiRepository.class).synthesize();\n            registerJdbiRepositoryFactoryBean(registry, repositoryAnnotation, repositoryClass);\n        }\n    }\n\n    private void registerJdbiRepositoryFactoryBean(BeanDefinitionRegistry registry, JdbiRepository annotation, String annotatedClass) {\n        @SuppressWarnings(\"rawtypes\")\n        Class clazz = ClassUtils.resolveClassName(annotatedClass, null);\n        String jdbiQualifier = annotation.jdbiQualifier();\n        String value = annotation.value();\n\n        JdbiRepositoryFactoryBean factoryBean = new JdbiRepositoryFactoryBean();\n        factoryBean.setObjectType(clazz);\n        factoryBean.setBeanFactory((BeanFactory) registry);\n        if (StringUtils.hasText(jdbiQualifier)) {\n            factoryBean.setJdbiQualifier(jdbiQualifier);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(clazz, factoryBean::getObject);\n        String beanName = StringUtils.hasText(value) ? value : annotatedClass;\n        registry.registerBeanDefinition(beanName, builder.getBeanDefinition());\n    }\n\n    private Iterable<BeanDefinition> resolveRepositoryBeanDefinitions(EnableJdbiRepositories annotation, String annotatedClass) {\n        LinkedHashSet<BeanDefinition> repositoryDefinitions = new LinkedHashSet<>();\n        if (annotation.repositories().length > 0) {\n            for (Class<?> clazz : annotation.repositories()) {\n                repositoryDefinitions.add(new AnnotatedGenericBeanDefinition(clazz));\n            }\n        } else {\n            ClassPathScanningCandidateComponentProvider scanner = createScanner();\n            Set<String> basePackages = resolveBasePackages(annotation, annotatedClass);\n            for (String basePackage : basePackages) {\n                repositoryDefinitions.addAll(scanner.findCandidateComponents(basePackage));\n            }\n        }\n        return repositoryDefinitions;\n    }\n\n    private Set<String> resolveBasePackages(EnableJdbiRepositories annotation, String annotatedClass) {\n        Set<String> basePackages = new HashSet<>();\n        for (String pkg : annotation.value()) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        for (String pkg : annotation.basePackages()) {\n            if (StringUtils.hasText(pkg)) {\n                basePackages.add(pkg);\n            }\n        }\n        for (Class<?> clazz : annotation.basePackageClasses()) {\n            basePackages.add(ClassUtils.getPackageName(clazz));\n        }\n\n        if (basePackages.isEmpty()) {\n            basePackages.add(ClassUtils.getPackageName(annotatedClass));\n        }\n        return basePackages;\n    }\n\n    private ClassPathScanningCandidateComponentProvider createScanner() {\n        var scanner = new ClassPathScanningCandidateComponentProvider() {\n            @Override\n            protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n                return beanDefinition.getMetadata().isInterface();\n            }\n        };\n        scanner.addIncludeFilter(new AnnotationTypeFilter(JdbiRepository.class));\n        return scanner;\n    }\n}\n","lineNo":48}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.junit5;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.util.LinkedHashSet;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.UUID;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Handles;\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.core.statement.SqlStatements;\nimport org.junit.jupiter.api.extension.AfterEachCallback;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\n\n/**\n * H2 Test Support for core tests. Do NOT use this outside the core tests (or tests that use core tests), use the JdbiExtension from the\n * jdbi3-testing module instead!\n */\npublic final class H2DatabaseExtension implements DatabaseExtension<H2DatabaseExtension>, BeforeEachCallback, AfterEachCallback {\n\n    public static final DatabaseInitializer SOMETHING_INITIALIZER =\n        h -> h.execute(\"create table something (id identity primary key, name varchar(50), integerValue integer, intValue integer)\");\n\n    public static final DatabaseInitializer USERS_INITIALIZER = h -> {\n        h.execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name VARCHAR)\");\n        h.execute(\"INSERT INTO users VALUES (1, 'Alice')\");\n        h.execute(\"INSERT INTO users VALUES (2, 'Bob')\");\n    };\n\n    private final String uri = \"jdbc:h2:mem:\" + UUID.randomUUID();\n    private final Set<JdbiPlugin> plugins = new LinkedHashSet<>();\n    private final JdbiLeakChecker leakChecker = new JdbiLeakChecker();\n\n    private final boolean installPlugins;\n    private Optional<DatabaseInitializer> initializerMaybe = Optional.empty();\n\n    private volatile Connection lastConnection = null;\n\n    private Jdbi jdbi = null;\n    private Handle sharedHandle = null;\n    private boolean enableLeakchecker = true;\n\n    public static H2DatabaseExtension instance() {\n        return new H2DatabaseExtension(false);\n    }\n\n    public static H2DatabaseExtension withPlugins() {\n        return new H2DatabaseExtension(true);\n    }\n\n    @Deprecated\n    public static H2DatabaseExtension withSomething() {\n        return instance().withInitializer(SOMETHING_INITIALIZER);\n    }\n\n    private H2DatabaseExtension(boolean installPlugins) {\n        this.installPlugins = installPlugins;\n    }\n\n    @Override\n    public Jdbi getJdbi() {\n        if (jdbi == null) {\n            throw new IllegalStateException(\"jdbi is null!\");\n        }\n        return jdbi;\n    }\n\n    @Override\n    public String getUri() {\n        return uri;\n    }\n\n    @Override\n    public Handle getSharedHandle() {\n        if (sharedHandle == null) {\n            throw new IllegalStateException(\"sharedHandle is null!\");\n        }\n        return sharedHandle;\n    }\n\n    public Connection getLastConnection() {\n        return lastConnection;\n    }\n\n    public void clearLastConnection() {\n        this.lastConnection = null;\n    }\n\n    @Override\n    public H2DatabaseExtension withPlugin(JdbiPlugin plugin) {\n        plugins.add(plugin);\n\n        return this;\n    }\n\n    @Override\n    public H2DatabaseExtension withInitializer(DatabaseInitializer initializer) {\n        if (this.initializerMaybe.isPresent()) {\n            throw new IllegalStateException(\"Initializer already set!\");\n        }\n        this.initializerMaybe = Optional.of(initializer);\n\n        return this;\n    }\n\n    @Override\n    public H2DatabaseExtension withoutLeakChecker() {\n        this.enableLeakchecker = false;\n        return this;\n    }\n\n    @Override\n    public void beforeEach(ExtensionContext context) throws Exception {\n        if (jdbi != null) {\n            throw new IllegalStateException(\"jdbi is not null!\");\n        }\n        jdbi = Jdbi.create(() -> {\n            this.lastConnection = DriverManager.getConnection(uri);\n            return lastConnection;\n        });\n\n        installTestPlugins(jdbi);\n\n        if (enableLeakchecker) {\n            jdbi.getConfig(Handles.class).addListener(leakChecker);\n            jdbi.getConfig(SqlStatements.class).addContextListener(leakChecker);\n        }\n\n        if (installPlugins) {\n            jdbi.installPlugins();\n        }\n\n        plugins.forEach(jdbi::installPlugin);\n        sharedHandle = jdbi.open();\n\n        initializerMaybe.ifPresent(i -> i.initialize(sharedHandle));\n    }\n\n    @Override\n    public void afterEach(ExtensionContext context) throws Exception {\n        if (sharedHandle == null) {\n            throw new IllegalStateException(\"shared handle was not initialized!\");\n        }\n\n        this.jdbi = null;\n        this.sharedHandle.close();\n\n        if (enableLeakchecker) {\n            leakChecker.checkForLeaks();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.junit5;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.util.LinkedHashSet;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.UUID;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Handles;\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.core.statement.SqlStatements;\nimport org.junit.jupiter.api.extension.AfterEachCallback;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\n\n/**\n * H2 Test Support for core tests. Do NOT use this outside the core tests (or tests that use core tests), use the JdbiExtension from the\n * jdbi3-testing module instead!\n */\npublic final class H2DatabaseExtension implements DatabaseExtension<H2DatabaseExtension>, BeforeEachCallback, AfterEachCallback {\n\n    public static final DatabaseInitializer SOMETHING_INITIALIZER =\n        h -> h.execute(\"create table something (id identity primary key, name varchar(50), integerValue integer, intValue integer)\");\n\n    public static final DatabaseInitializer USERS_INITIALIZER = h -> {\n        h.execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name VARCHAR)\");\n        h.execute(\"INSERT INTO users VALUES (1, 'Alice')\");\n        h.execute(\"INSERT INTO users VALUES (2, 'Bob')\");\n    };\n\n    private final String uri = \"jdbc:h2:mem:\" + UUID.randomUUID();\n    private final Set<JdbiPlugin> plugins = new LinkedHashSet<>();\n    private final JdbiLeakChecker leakChecker = new JdbiLeakChecker();\n\n    private final boolean installPlugins;\n    private Optional<DatabaseInitializer> initializerMaybe = Optional.empty();\n\n    private volatile Connection lastConnection = null;\n\n    private Jdbi jdbi = null;\n    private Handle sharedHandle = null;\n    private boolean enableLeakchecker = true;\n\n    public static H2DatabaseExtension instance() {\n        return new H2DatabaseExtension(false);\n    }\n\n    public static H2DatabaseExtension withPlugins() {\n        return new H2DatabaseExtension(true);\n    }\n\n    @Deprecated\n    public static H2DatabaseExtension withSomething() {\n        return instance().withInitializer(SOMETHING_INITIALIZER);\n    }\n\n    private H2DatabaseExtension(boolean installPlugins) {\n        this.installPlugins = installPlugins;\n    }\n\n    @Override\n    public Jdbi getJdbi() {\n        if (jdbi == null) {\n            throw new IllegalStateException(\"jdbi is null!\");\n        }\n        return jdbi;\n    }\n\n    @Override\n    public String getUri() {\n        return uri;\n    }\n\n    @Override\n    public Handle getSharedHandle() {\n        if (sharedHandle == null) {\n            throw new IllegalStateException(\"sharedHandle is null!\");\n        }\n        return sharedHandle;\n    }\n\n    /**\n     * Returns the last connection handed out by this extension. This is <b>not<\/b> a general\n     * purpose API but is intended for tests that need to compare connection objects between a\n     * handle and what the extension has handed out.\n     * <br>\n     * This API is <b>not multi-thread safe<\/b> and will not work if the extension is shared between\n     * multiple threads.\n     * @return A connection object. Can be null if no connection had been handed out.\n     */\n    public Connection getLastConnection() {\n        return this.lastConnection;\n    }\n\n    public void clearLastConnection() {\n        this.lastConnection = null;\n    }\n\n    @Override\n    public H2DatabaseExtension withPlugin(JdbiPlugin plugin) {\n        plugins.add(plugin);\n\n        return this;\n    }\n\n    @Override\n    public H2DatabaseExtension withInitializer(DatabaseInitializer initializer) {\n        if (this.initializerMaybe.isPresent()) {\n            throw new IllegalStateException(\"Initializer already set!\");\n        }\n        this.initializerMaybe = Optional.of(initializer);\n\n        return this;\n    }\n\n    @Override\n    public H2DatabaseExtension withoutLeakChecker() {\n        this.enableLeakchecker = false;\n        return this;\n    }\n\n    @Override\n    public void beforeEach(ExtensionContext context) throws Exception {\n        if (jdbi != null) {\n            throw new IllegalStateException(\"jdbi is not null!\");\n        }\n        jdbi = Jdbi.create(() -> {\n            final Connection connection = DriverManager.getConnection(uri);\n            // this will only work reliably in single-threaded tests. Any multi-threaded\n            // test will hand out the last connection used by the last thread calling this\n            // method.\n            this.lastConnection = connection;\n            return connection;\n        });\n\n        installTestPlugins(jdbi);\n\n        if (enableLeakchecker) {\n            jdbi.getConfig(Handles.class).addListener(leakChecker);\n            jdbi.getConfig(SqlStatements.class).addContextListener(leakChecker);\n        }\n\n        if (installPlugins) {\n            jdbi.installPlugins();\n        }\n\n        plugins.forEach(jdbi::installPlugin);\n        sharedHandle = jdbi.open();\n\n        initializerMaybe.ifPresent(i -> i.initialize(sharedHandle));\n    }\n\n    @Override\n    public void afterEach(ExtensionContext context) {\n        if (sharedHandle == null) {\n            throw new IllegalStateException(\"shared handle was not initialized!\");\n        }\n\n        this.jdbi = null;\n        this.sharedHandle.close();\n\n        if (enableLeakchecker) {\n            leakChecker.checkForLeaks();\n        }\n    }\n}\n","lineNo":144}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceLoader;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.sql.DataSource;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionCallback;\nimport org.jdbi.v3.core.extension.ExtensionConsumer;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.core.statement.DefaultStatementBuilder;\nimport org.jdbi.v3.core.statement.SqlStatements;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilderFactory;\nimport org.jdbi.v3.core.transaction.LocalTransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * Main entry point; configurable wrapper around a JDBC {@link DataSource}.\n * Use it to obtain Handle instances and provide configuration\n * for all handles obtained from it.\n */\npublic class Jdbi implements Configurable<Jdbi> {\n    private static final Logger LOG = LoggerFactory.getLogger(Jdbi.class);\n\n    private final ConfigRegistry config = new ConfigRegistry();\n\n    private final ConnectionFactory connectionFactory;\n    private final AtomicReference<TransactionHandler> transactionhandler = new AtomicReference<>(LocalTransactionHandler.binding());\n    private final AtomicReference<StatementBuilderFactory> statementBuilderFactory = new AtomicReference<>(DefaultStatementBuilder.FACTORY);\n    private final AtomicReference<Handler> handler = new AtomicReference<>(Handler.STANDARD_HANDLER);\n\n    private final CopyOnWriteArrayList<JdbiPlugin> plugins = new CopyOnWriteArrayList<>();\n\n    @SuppressWarnings(\"ThreadLocalUsage\")\n    private final ThreadLocal<HandleSupplier> threadHandleSupplier = new ThreadLocal<>();\n\n    private Jdbi(ConnectionFactory connectionFactory) {\n        Objects.requireNonNull(connectionFactory, \"null connectionFactory\");\n        this.connectionFactory = connectionFactory;\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link Connection}.\n     *\n     * @param connection A {@link Connection} object.\n     *\n     * @return A {@link Jdbi} instance that uses a single database connection.\n     */\n    public static Jdbi create(Connection connection) {\n        return create(new SingleConnectionFactory(connection));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link DataSource}.\n     *\n     * @param dataSource the data source.\n     *\n     * @return a Jdbi which uses the given data source as a connection factory.\n     */\n    public static Jdbi create(DataSource dataSource) {\n        return create(dataSource::getConnection);\n    }\n\n    /**\n     * Factory used to allow for obtaining a Connection in a customized manner.\n     *\n     * <p>\n     * The {@link ConnectionFactory#openConnection()} method will be invoked to obtain a connection instance\n     * whenever a Handle is opened.\n     * <\/p>\n     *\n     * @param connectionFactory Provides JDBC connections to Handle instances\n     *\n     * @return a Jdbi which uses the given connection factory.\n     */\n    public static Jdbi create(ConnectionFactory connectionFactory) {\n        return new Jdbi(connectionFactory);\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url A JDBC URL for connections.\n     *\n     * @return a Jdbi which uses{@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url) {\n        Objects.requireNonNull(url, \"null url\");\n        return create(() -> DriverManager.getConnection(url));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url   JDBC URL for connections\n     * @param properties Properties to pass to DriverManager.getConnection(url, props) for each new handle\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final Properties properties) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(properties, \"null properties\");\n        return create(() -> DriverManager.getConnection(url, properties));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url      JDBC URL for connections\n     * @param username User name for connection authentication\n     * @param password Password for connection authentication\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final String username, final String password) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(username, \"null username\");\n        Objects.requireNonNull(password, \"null password\");\n        return create(() -> DriverManager.getConnection(url, username, password));\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a specific data source\n     *\n     * @param dataSource the JDBC data source.\n     *\n     * @return Handle using a Connection obtained from the provided DataSource\n     */\n    public static Handle open(DataSource dataSource) {\n        return create(dataSource).open();\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a {@link ConnectionFactory}.\n     *\n     * @param connectionFactory the connection factory\n     *\n     * @return Handle using a Connection obtained from the provided connection factory\n     */\n    public static Handle open(ConnectionFactory connectionFactory) {\n        return create(connectionFactory).open();\n    }\n\n    /**\n     * Create a Handle wrapping a particular JDBC Connection\n     *\n     * @param connection the JDBC connection\n     *\n     * @return Handle bound to connection\n     */\n    public static Handle open(final Connection connection) {\n        Objects.requireNonNull(connection, \"null connection\");\n        return create(() -> connection).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url JDBC Url\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url) {\n        return create(url).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url      JDBC Url\n     * @param username JDBC username for authentication\n     * @param password JDBC password for authentication\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final String username, final String password) {\n        return create(url, username, password).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url   JDBC Url\n     * @param props JDBC properties\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final Properties props) {\n        return create(url, props).open();\n    }\n\n    /**\n     * Use the {@link ServiceLoader} API to detect and install plugins automagically.\n     * Some people consider this feature dangerous; some consider it essential --\n     * use at your own risk.\n     * @return this\n     */\n    public Jdbi installPlugins() {\n        ServiceLoader.load(JdbiPlugin.class).forEach(this::installPlugin);\n        LOG.debug(\"Automatically installed plugins {}\", plugins);\n        return this;\n    }\n\n    /**\n     * Install a given {@link JdbiPlugin} instance that will configure any\n     * provided {@link Handle} instances.\n     * @param plugin the plugin to install\n     * @return this\n     */\n    public Jdbi installPlugin(JdbiPlugin plugin) {\n        if (plugins.addIfAbsent(plugin)) {\n            Unchecked.consumer(plugin::customizeJdbi).accept(this);\n        }\n        return this;\n    }\n\n    /**\n     * Allows customization of how prepared statements are created. When a Handle is created\n     * against this Jdbi instance the factory will be used to create a StatementBuilder for\n     * that specific handle. When the handle is closed, the StatementBuilder's close method\n     * will be invoked.\n     *\n     * @param factory the new statement builder factory.\n     * @return this\n     */\n    public Jdbi setStatementBuilderFactory(StatementBuilderFactory factory) {\n        this.statementBuilderFactory.set(factory);\n        return this;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilderFactory}.\n     *\n     * @return the current {@link StatementBuilderFactory}\n     */\n    public StatementBuilderFactory getStatementBuilderFactory() {\n        return this.statementBuilderFactory.get();\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return config;\n    }\n\n    /**\n     * Specify the TransactionHandler instance to use. This allows overriding\n     * transaction semantics, or mapping into different transaction\n     * management systems.\n     * <p>\n     * The default version uses local transactions on the database Connection\n     * instances obtained.\n     * <\/p>\n     *\n     * @param handler The TransactionHandler to use for all Handle instances obtained\n     *                from this Jdbi\n     * @return this\n     */\n    public Jdbi setTransactionHandler(TransactionHandler handler) {\n        Objects.requireNonNull(handler, \"null transaction handler\");\n        this.transactionhandler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link TransactionHandler}.\n     *\n     * @return the {@link TransactionHandler}\n     */\n    public TransactionHandler getTransactionHandler() {\n        return this.transactionhandler.get();\n    }\n\n    /**\n     * Specify the {@link Handler} instance to use. This allows overriding\n     * callbacks for {@link #useHandle}, {@link #withHandle}, {@link #useTransaction} and\n     * {@link #inTransaction}. The default version is a pass-through that returns the callback unchanged.\n     *\n     * @param handler The {@link Handler} to use for all {@link #useHandle}, {@link #withHandle},\n     *                {@link #useTransaction} and {@link #inTransaction} from this Jdbi\n     * @return this\n     */\n    public Jdbi setHandler(Handler handler) {\n        Objects.requireNonNull(handler, \"null handler\");\n        this.handler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link Handler}.\n     *\n     * @return the {@link Handler}\n     */\n    public Handler getHandler() {\n        return this.handler.get();\n    }\n\n    /**\n     * Obtain a Handle to the data source wrapped by this Jdbi instance.\n     * You own this expensive resource and are required to close it or\n     * risk leaks.  Using a {@code try-with-resources} block is recommended.\n     *\n     * @return an open Handle instance\n     * @see #useHandle(HandleConsumer)\n     * @see #withHandle(HandleCallback)\n     */\n    public Handle open() {\n        try {\n            final long start = System.nanoTime();\n            @SuppressWarnings(\"PMD.CloseResource\")\n            Connection conn = Objects.requireNonNull(connectionFactory.openConnection(),\n                    () -> \"Connection factory \" + connectionFactory + \" returned a null connection\");\n            final long stop = System.nanoTime();\n\n            for (JdbiPlugin p : plugins) {\n                conn = p.customizeConnection(conn);\n            }\n\n            StatementBuilder cache = statementBuilderFactory.get().createStatementBuilder(conn);\n\n            Handle h = Handle.createHandle(this,\n                connectionFactory.getCleanableFor(conn), // don't use conn::close, the cleanup must be done by the connection factory!\n                transactionhandler.get(),\n                cache,\n                conn);\n\n            for (JdbiPlugin p : plugins) {\n                h = p.customizeHandle(h);\n            }\n            LOG.trace(\"Jdbi [{}] obtain handle [{}] in {}ms\", this, h, MILLISECONDS.convert(stop - start, NANOSECONDS));\n            return h;\n        } catch (SQLException e) {\n            throw new ConnectionException(e);\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param callback A callback which will receive an open Handle\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {\n\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n\n        HandleCallback<R, X> decoratedCallback = handler.get().decorate(callback);\n\n        if (handleSupplier != null) {\n            return decoratedCallback.withHandle(handleSupplier.getHandle());\n        }\n\n        try (Handle h = this.open()) {\n            SqlStatements sqlStatements = h.getConfig(SqlStatements.class);\n            sqlStatements.setAttachAllStatementsForCleanup(sqlStatements.isAttachCallbackStatementsForCleanup());\n\n            handleSupplier = ConstantHandleSupplier.of(h);\n            threadHandleSupplier.set(handleSupplier);\n            return decoratedCallback.withHandle(h);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param consumer A callback which will receive an open Handle\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useHandle(final HandleConsumer<X> consumer) throws X {\n        withHandle(consumer.asCallback());\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final TransactionIsolationLevel level, final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(level, callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final TransactionIsolationLevel level, final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(level, callback));\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, yields it to a callback, and returns the result\n     * of the callback. A handle is opened if needed by the extension, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension.\n     * @param callback      a callback which will receive the extension.\n     * @param <R> the return type\n     * @param <E> the extension type\n     * @param <X> the exception type optionally thrown by the callback\n     * @return the value returned by the callback.\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension\n     *                                  type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <R, E, X extends Exception> R withExtension(Class<E> extensionType, ExtensionCallback<R, E, X> callback)\n            throws X {\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n        if (handleSupplier != null) {\n            return callWithExtension(extensionType, callback, handleSupplier);\n        }\n\n        try (LazyHandleSupplier lazyHandleSupplier = new LazyHandleSupplier(this)) {\n            threadHandleSupplier.set(lazyHandleSupplier);\n            return callWithExtension(extensionType, callback, lazyHandleSupplier);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    private <R, E, X extends Exception> R callWithExtension(Class<E> extensionType,\n                                                            ExtensionCallback<R, E, X> callback,\n                                                            HandleSupplier handleSupplier) throws X {\n        E extension = getConfig(Extensions.class)\n            .findFor(extensionType, handleSupplier)\n            .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n\n        return callback.withExtension(extension);\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, and yields it to a callback. A handle is opened\n     * if needed by the extention, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension\n     * @param callback      a callback which will receive the extension\n     * @param <E>           the extension type\n     * @param <X>           the exception type optionally thrown by the callback\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <E, X extends Exception> void useExtension(Class<E> extensionType, ExtensionConsumer<E, X> callback)\n            throws X {\n        withExtension(extensionType, extension -> {\n            callback.useExtension(extension);\n            return null;\n        });\n    }\n\n    /**\n     * Creates an extension instance that uses the current {@link Jdbi} instance for database operations.\n     *\n     * @param extensionType the type of extension. Must be a public interface type.\n     * @param <E> the extension type\n     *\n     * @return an extension which opens and closes handles (as needed) for individual method calls. Only public\n     * interface types may be used as on-demand extensions.\n     */\n    public <E> E onDemand(Class<E> extensionType) {\n        if (!extensionType.isInterface()) {\n            throw new IllegalArgumentException(\"On-demand extensions are only supported for interfaces.\");\n        }\n        if (!getConfig(Extensions.class).hasExtensionFor(extensionType)) {\n            throw new NoSuchExtensionException(extensionType, \"Extension not found: %s\");\n        }\n\n        return getConfig(OnDemandExtensions.class).create(this, extensionType);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceLoader;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.sql.DataSource;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionCallback;\nimport org.jdbi.v3.core.extension.ExtensionConsumer;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.core.statement.Cleanable;\nimport org.jdbi.v3.core.statement.DefaultStatementBuilder;\nimport org.jdbi.v3.core.statement.SqlStatements;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilderFactory;\nimport org.jdbi.v3.core.transaction.LocalTransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * Main entry point; configurable wrapper around a JDBC {@link DataSource}.\n * Use it to obtain Handle instances and provide configuration\n * for all handles obtained from it.\n */\npublic class Jdbi implements Configurable<Jdbi> {\n    private static final Logger LOG = LoggerFactory.getLogger(Jdbi.class);\n\n    private final ConfigRegistry config = new ConfigRegistry();\n\n    private final ConnectionFactory connectionFactory;\n    private final AtomicReference<TransactionHandler> transactionhandler = new AtomicReference<>(LocalTransactionHandler.binding());\n    private final AtomicReference<StatementBuilderFactory> statementBuilderFactory = new AtomicReference<>(DefaultStatementBuilder.FACTORY);\n    private final AtomicReference<Handler> handler = new AtomicReference<>(Handler.STANDARD_HANDLER);\n\n    private final CopyOnWriteArrayList<JdbiPlugin> plugins = new CopyOnWriteArrayList<>();\n\n    @SuppressWarnings(\"ThreadLocalUsage\")\n    private final ThreadLocal<HandleSupplier> threadHandleSupplier = new ThreadLocal<>();\n\n    private Jdbi(ConnectionFactory connectionFactory) {\n        Objects.requireNonNull(connectionFactory, \"null connectionFactory\");\n        this.connectionFactory = connectionFactory;\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link Connection}.\n     *\n     * @param connection A {@link Connection} object.\n     *\n     * @return A {@link Jdbi} instance that uses a single database connection.\n     */\n    public static Jdbi create(Connection connection) {\n        return create(new SingleConnectionFactory(connection));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link DataSource}.\n     *\n     * @param dataSource the data source.\n     *\n     * @return a Jdbi which uses the given data source as a connection factory.\n     */\n    public static Jdbi create(DataSource dataSource) {\n        return create(dataSource::getConnection);\n    }\n\n    /**\n     * Factory used to allow for obtaining a Connection in a customized manner.\n     *\n     * <p>\n     * The {@link ConnectionFactory#openConnection()} method will be invoked to obtain a connection instance\n     * whenever a Handle is opened.\n     * <\/p>\n     *\n     * @param connectionFactory Provides JDBC connections to Handle instances\n     *\n     * @return a Jdbi which uses the given connection factory.\n     */\n    public static Jdbi create(ConnectionFactory connectionFactory) {\n        return new Jdbi(connectionFactory);\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url A JDBC URL for connections.\n     *\n     * @return a Jdbi which uses{@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url) {\n        Objects.requireNonNull(url, \"null url\");\n        return create(() -> DriverManager.getConnection(url));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url   JDBC URL for connections\n     * @param properties Properties to pass to DriverManager.getConnection(url, props) for each new handle\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final Properties properties) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(properties, \"null properties\");\n        return create(() -> DriverManager.getConnection(url, properties));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url      JDBC URL for connections\n     * @param username User name for connection authentication\n     * @param password Password for connection authentication\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final String username, final String password) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(username, \"null username\");\n        Objects.requireNonNull(password, \"null password\");\n        return create(() -> DriverManager.getConnection(url, username, password));\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a specific data source\n     *\n     * @param dataSource the JDBC data source.\n     *\n     * @return Handle using a Connection obtained from the provided DataSource\n     */\n    public static Handle open(DataSource dataSource) {\n        return create(dataSource).open();\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a {@link ConnectionFactory}.\n     *\n     * @param connectionFactory the connection factory\n     *\n     * @return Handle using a Connection obtained from the provided connection factory\n     */\n    public static Handle open(ConnectionFactory connectionFactory) {\n        return create(connectionFactory).open();\n    }\n\n    /**\n     * Create a Handle wrapping a particular JDBC Connection\n     *\n     * @param connection the JDBC connection\n     *\n     * @return Handle bound to connection\n     */\n    public static Handle open(final Connection connection) {\n        Objects.requireNonNull(connection, \"null connection\");\n        return create(() -> connection).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url JDBC Url\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url) {\n        return create(url).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url      JDBC Url\n     * @param username JDBC username for authentication\n     * @param password JDBC password for authentication\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final String username, final String password) {\n        return create(url, username, password).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url   JDBC Url\n     * @param props JDBC properties\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final Properties props) {\n        return create(url, props).open();\n    }\n\n    /**\n     * Use the {@link ServiceLoader} API to detect and install plugins automagically.\n     * Some people consider this feature dangerous; some consider it essential --\n     * use at your own risk.\n     * @return this\n     */\n    public Jdbi installPlugins() {\n        ServiceLoader.load(JdbiPlugin.class).forEach(this::installPlugin);\n        LOG.debug(\"Automatically installed plugins {}\", plugins);\n        return this;\n    }\n\n    /**\n     * Install a given {@link JdbiPlugin} instance that will configure any\n     * provided {@link Handle} instances.\n     * @param plugin the plugin to install\n     * @return this\n     */\n    public Jdbi installPlugin(JdbiPlugin plugin) {\n        if (plugins.addIfAbsent(plugin)) {\n            Unchecked.consumer(plugin::customizeJdbi).accept(this);\n        }\n        return this;\n    }\n\n    /**\n     * Allows customization of how prepared statements are created. When a Handle is created\n     * against this Jdbi instance the factory will be used to create a StatementBuilder for\n     * that specific handle. When the handle is closed, the StatementBuilder's close method\n     * will be invoked.\n     *\n     * @param factory the new statement builder factory.\n     * @return this\n     */\n    public Jdbi setStatementBuilderFactory(StatementBuilderFactory factory) {\n        this.statementBuilderFactory.set(factory);\n        return this;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilderFactory}.\n     *\n     * @return the current {@link StatementBuilderFactory}\n     */\n    public StatementBuilderFactory getStatementBuilderFactory() {\n        return this.statementBuilderFactory.get();\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return config;\n    }\n\n    /**\n     * Specify the TransactionHandler instance to use. This allows overriding\n     * transaction semantics, or mapping into different transaction\n     * management systems.\n     * <p>\n     * The default version uses local transactions on the database Connection\n     * instances obtained.\n     * <\/p>\n     *\n     * @param handler The TransactionHandler to use for all Handle instances obtained\n     *                from this Jdbi\n     * @return this\n     */\n    public Jdbi setTransactionHandler(TransactionHandler handler) {\n        Objects.requireNonNull(handler, \"null transaction handler\");\n        this.transactionhandler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link TransactionHandler}.\n     *\n     * @return the {@link TransactionHandler}\n     */\n    public TransactionHandler getTransactionHandler() {\n        return this.transactionhandler.get();\n    }\n\n    /**\n     * Specify the {@link Handler} instance to use. This allows overriding\n     * callbacks for {@link #useHandle}, {@link #withHandle}, {@link #useTransaction} and\n     * {@link #inTransaction}. The default version is a pass-through that returns the callback unchanged.\n     *\n     * @param handler The {@link Handler} to use for all {@link #useHandle}, {@link #withHandle},\n     *                {@link #useTransaction} and {@link #inTransaction} from this Jdbi\n     * @return this\n     */\n    public Jdbi setHandler(Handler handler) {\n        Objects.requireNonNull(handler, \"null handler\");\n        this.handler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link Handler}.\n     *\n     * @return the {@link Handler}\n     */\n    public Handler getHandler() {\n        return this.handler.get();\n    }\n\n    /**\n     * Obtain a Handle to the data source wrapped by this Jdbi instance.\n     * You own this expensive resource and are required to close it or\n     * risk leaks.  Using a {@code try-with-resources} block is recommended.\n     *\n     * @return an open Handle instance\n     * @see #useHandle(HandleConsumer)\n     * @see #withHandle(HandleCallback)\n     */\n    public Handle open() {\n        try {\n            final long start = System.nanoTime();\n            @SuppressWarnings(\"PMD.CloseResource\")\n            Connection conn = Objects.requireNonNull(connectionFactory.openConnection(),\n                    () -> \"Connection factory \" + connectionFactory + \" returned a null connection\");\n            final long stop = System.nanoTime();\n\n            // this looks like a t-w-r but it is not. The connection is only closed in the error case.\n            final Cleanable connectionCleaner = connectionFactory.getCleanableFor(conn);\n            try {\n                for (JdbiPlugin p : plugins) {\n                    conn = p.customizeConnection(conn);\n                }\n\n                StatementBuilder cache = statementBuilderFactory.get().createStatementBuilder(conn);\n\n                Handle h = Handle.createHandle(this,\n                        connectionCleaner, // don't use conn::close, the cleanup must be done by the connection factory!\n                        transactionhandler.get(),\n                        cache,\n                        conn);\n\n                for (JdbiPlugin p : plugins) {\n                    h = p.customizeHandle(h);\n                }\n                LOG.trace(\"Jdbi [{}] obtain handle [{}] in {}ms\", this, h, MILLISECONDS.convert(stop - start, NANOSECONDS));\n                return h;\n            } catch (Throwable t) {\n                connectionCleaner.closeAndSuppress(t);\n                throw t;\n            }\n        } catch (SQLException e) {\n            throw new ConnectionException(e);\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param callback A callback which will receive an open Handle\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {\n\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n\n        HandleCallback<R, X> decoratedCallback = handler.get().decorate(callback);\n\n        if (handleSupplier != null) {\n            return decoratedCallback.withHandle(handleSupplier.getHandle());\n        }\n\n        try (Handle h = this.open()) {\n            SqlStatements sqlStatements = h.getConfig(SqlStatements.class);\n            sqlStatements.setAttachAllStatementsForCleanup(sqlStatements.isAttachCallbackStatementsForCleanup());\n\n            handleSupplier = ConstantHandleSupplier.of(h);\n            threadHandleSupplier.set(handleSupplier);\n            return decoratedCallback.withHandle(h);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param consumer A callback which will receive an open Handle\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useHandle(final HandleConsumer<X> consumer) throws X {\n        withHandle(consumer.asCallback());\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final TransactionIsolationLevel level, final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(level, callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final TransactionIsolationLevel level, final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(level, callback));\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, yields it to a callback, and returns the result\n     * of the callback. A handle is opened if needed by the extension, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension.\n     * @param callback      a callback which will receive the extension.\n     * @param <R> the return type\n     * @param <E> the extension type\n     * @param <X> the exception type optionally thrown by the callback\n     * @return the value returned by the callback.\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension\n     *                                  type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <R, E, X extends Exception> R withExtension(Class<E> extensionType, ExtensionCallback<R, E, X> callback)\n            throws X {\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n        if (handleSupplier != null) {\n            return callWithExtension(extensionType, callback, handleSupplier);\n        }\n\n        try (LazyHandleSupplier lazyHandleSupplier = new LazyHandleSupplier(this)) {\n            threadHandleSupplier.set(lazyHandleSupplier);\n            return callWithExtension(extensionType, callback, lazyHandleSupplier);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    private <R, E, X extends Exception> R callWithExtension(Class<E> extensionType,\n                                                            ExtensionCallback<R, E, X> callback,\n                                                            HandleSupplier handleSupplier) throws X {\n        E extension = getConfig(Extensions.class)\n            .findFor(extensionType, handleSupplier)\n            .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n\n        return callback.withExtension(extension);\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, and yields it to a callback. A handle is opened\n     * if needed by the extention, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension\n     * @param callback      a callback which will receive the extension\n     * @param <E>           the extension type\n     * @param <X>           the exception type optionally thrown by the callback\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <E, X extends Exception> void useExtension(Class<E> extensionType, ExtensionConsumer<E, X> callback)\n            throws X {\n        withExtension(extensionType, extension -> {\n            callback.useExtension(extension);\n            return null;\n        });\n    }\n\n    /**\n     * Creates an extension instance that uses the current {@link Jdbi} instance for database operations.\n     *\n     * @param extensionType the type of extension. Must be a public interface type.\n     * @param <E> the extension type\n     *\n     * @return an extension which opens and closes handles (as needed) for individual method calls. Only public\n     * interface types may be used as on-demand extensions.\n     */\n    public <E> E onDemand(Class<E> extensionType) {\n        if (!extensionType.isInterface()) {\n            throw new IllegalArgumentException(\"On-demand extensions are only supported for interfaces.\");\n        }\n        if (!getConfig(Extensions.class).hasExtensionFor(extensionType)) {\n            throw new NoSuchExtensionException(extensionType, \"Extension not found: %s\");\n        }\n\n        return getConfig(OnDemandExtensions.class).create(this, extensionType);\n    }\n}\n","lineNo":350}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceLoader;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.sql.DataSource;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionCallback;\nimport org.jdbi.v3.core.extension.ExtensionConsumer;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.core.statement.DefaultStatementBuilder;\nimport org.jdbi.v3.core.statement.SqlStatements;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilderFactory;\nimport org.jdbi.v3.core.transaction.LocalTransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * Main entry point; configurable wrapper around a JDBC {@link DataSource}.\n * Use it to obtain Handle instances and provide configuration\n * for all handles obtained from it.\n */\npublic class Jdbi implements Configurable<Jdbi> {\n    private static final Logger LOG = LoggerFactory.getLogger(Jdbi.class);\n\n    private final ConfigRegistry config = new ConfigRegistry();\n\n    private final ConnectionFactory connectionFactory;\n    private final AtomicReference<TransactionHandler> transactionhandler = new AtomicReference<>(LocalTransactionHandler.binding());\n    private final AtomicReference<StatementBuilderFactory> statementBuilderFactory = new AtomicReference<>(DefaultStatementBuilder.FACTORY);\n\n    private final CopyOnWriteArrayList<JdbiPlugin> plugins = new CopyOnWriteArrayList<>();\n\n    @SuppressWarnings(\"ThreadLocalUsage\")\n    private final ThreadLocal<HandleSupplier> threadHandleSupplier = new ThreadLocal<>();\n\n    private Jdbi(ConnectionFactory connectionFactory) {\n        Objects.requireNonNull(connectionFactory, \"null connectionFactory\");\n        this.connectionFactory = connectionFactory;\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link Connection}.\n     *\n     * @param connection A {@link Connection} object.\n     *\n     * @return A {@link Jdbi} instance that uses a single database connection.\n     */\n    public static Jdbi create(Connection connection) {\n        return create(new SingleConnectionFactory(connection));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link DataSource}.\n     *\n     * @param dataSource the data source.\n     *\n     * @return a Jdbi which uses the given data source as a connection factory.\n     */\n    public static Jdbi create(DataSource dataSource) {\n        return create(dataSource::getConnection);\n    }\n\n    /**\n     * Factory used to allow for obtaining a Connection in a customized manner.\n     *\n     * <p>\n     * The {@link ConnectionFactory#openConnection()} method will be invoked to obtain a connection instance\n     * whenever a Handle is opened.\n     * <\/p>\n     *\n     * @param connectionFactory Provides JDBC connections to Handle instances\n     *\n     * @return a Jdbi which uses the given connection factory.\n     */\n    public static Jdbi create(ConnectionFactory connectionFactory) {\n        return new Jdbi(connectionFactory);\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url A JDBC URL for connections.\n     *\n     * @return a Jdbi which uses{@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url) {\n        Objects.requireNonNull(url, \"null url\");\n        return create(() -> DriverManager.getConnection(url));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url   JDBC URL for connections\n     * @param properties Properties to pass to DriverManager.getConnection(url, props) for each new handle\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final Properties properties) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(properties, \"null properties\");\n        return create(() -> DriverManager.getConnection(url, properties));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url      JDBC URL for connections\n     * @param username User name for connection authentication\n     * @param password Password for connection authentication\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final String username, final String password) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(username, \"null username\");\n        Objects.requireNonNull(password, \"null password\");\n        return create(() -> DriverManager.getConnection(url, username, password));\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a specific data source\n     *\n     * @param dataSource the JDBC data source.\n     *\n     * @return Handle using a Connection obtained from the provided DataSource\n     */\n    public static Handle open(DataSource dataSource) {\n        return create(dataSource).open();\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a {@link ConnectionFactory}.\n     *\n     * @param connectionFactory the connection factory\n     *\n     * @return Handle using a Connection obtained from the provided connection factory\n     */\n    public static Handle open(ConnectionFactory connectionFactory) {\n        return create(connectionFactory).open();\n    }\n\n    /**\n     * Create a Handle wrapping a particular JDBC Connection\n     *\n     * @param connection the JDBC connection\n     *\n     * @return Handle bound to connection\n     */\n    public static Handle open(final Connection connection) {\n        Objects.requireNonNull(connection, \"null connection\");\n        return create(() -> connection).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url JDBC Url\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url) {\n        return create(url).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url      JDBC Url\n     * @param username JDBC username for authentication\n     * @param password JDBC password for authentication\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final String username, final String password) {\n        return create(url, username, password).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url   JDBC Url\n     * @param props JDBC properties\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final Properties props) {\n        return create(url, props).open();\n    }\n\n    /**\n     * Use the {@link ServiceLoader} API to detect and install plugins automagically.\n     * Some people consider this feature dangerous; some consider it essential --\n     * use at your own risk.\n     * @return this\n     */\n    public Jdbi installPlugins() {\n        ServiceLoader.load(JdbiPlugin.class).forEach(this::installPlugin);\n        LOG.debug(\"Automatically installed plugins {}\", plugins);\n        return this;\n    }\n\n    /**\n     * Install a given {@link JdbiPlugin} instance that will configure any\n     * provided {@link Handle} instances.\n     * @param plugin the plugin to install\n     * @return this\n     */\n    public Jdbi installPlugin(JdbiPlugin plugin) {\n        if (plugins.addIfAbsent(plugin)) {\n            Unchecked.consumer(plugin::customizeJdbi).accept(this);\n        }\n        return this;\n    }\n\n    /**\n     * Allows customization of how prepared statements are created. When a Handle is created\n     * against this Jdbi instance the factory will be used to create a StatementBuilder for\n     * that specific handle. When the handle is closed, the StatementBuilder's close method\n     * will be invoked.\n     *\n     * @param factory the new statement builder factory.\n     * @return this\n     */\n    public Jdbi setStatementBuilderFactory(StatementBuilderFactory factory) {\n        this.statementBuilderFactory.set(factory);\n        return this;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilderFactory}.\n     *\n     * @return the current {@link StatementBuilderFactory}\n     */\n    public StatementBuilderFactory getStatementBuilderFactory() {\n        return this.statementBuilderFactory.get();\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return config;\n    }\n\n    /**\n     * Specify the TransactionHandler instance to use. This allows overriding\n     * transaction semantics, or mapping into different transaction\n     * management systems.\n     * <p>\n     * The default version uses local transactions on the database Connection\n     * instances obtained.\n     * <\/p>\n     *\n     * @param handler The TransactionHandler to use for all Handle instances obtained\n     *                from this Jdbi\n     * @return this\n     */\n    public Jdbi setTransactionHandler(TransactionHandler handler) {\n        Objects.requireNonNull(handler, \"null transaction handler\");\n        this.transactionhandler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link TransactionHandler}.\n     *\n     * @return the {@link TransactionHandler}\n     */\n    public TransactionHandler getTransactionHandler() {\n        return this.transactionhandler.get();\n    }\n\n    /**\n     * Obtain a Handle to the data source wrapped by this Jdbi instance.\n     * You own this expensive resource and are required to close it or\n     * risk leaks.  Using a {@code try-with-resources} block is recommended.\n     *\n     * @return an open Handle instance\n     * @see #useHandle(HandleConsumer)\n     * @see #withHandle(HandleCallback)\n     */\n    public Handle open() {\n        try {\n            final long start = System.nanoTime();\n            @SuppressWarnings(\"PMD.CloseResource\")\n            Connection conn = Objects.requireNonNull(connectionFactory.openConnection(),\n                    () -> \"Connection factory \" + connectionFactory + \" returned a null connection\");\n            final long stop = System.nanoTime();\n\n            for (JdbiPlugin p : plugins) {\n                conn = p.customizeConnection(conn);\n            }\n\n            StatementBuilder cache = statementBuilderFactory.get().createStatementBuilder(conn);\n\n            Handle h = Handle.createHandle(this,\n                connectionFactory.getCleanableFor(conn), // don't use conn::close, the cleanup must be done by the connection factory!\n                transactionhandler.get(),\n                cache,\n                conn);\n\n            for (JdbiPlugin p : plugins) {\n                h = p.customizeHandle(h);\n            }\n            LOG.trace(\"Jdbi [{}] obtain handle [{}] in {}ms\", this, h, MILLISECONDS.convert(stop - start, NANOSECONDS));\n            return h;\n        } catch (SQLException e) {\n            throw new ConnectionException(e);\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param callback A callback which will receive an open Handle\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {\n\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n\n        if (handleSupplier != null) {\n            return callback.withHandle(handleSupplier.getHandle());\n        }\n\n        try (Handle h = this.open()) {\n            SqlStatements sqlStatements = h.getConfig(SqlStatements.class);\n            sqlStatements.setAttachAllStatementsForCleanup(sqlStatements.isAttachCallbackStatementsForCleanup());\n\n            handleSupplier = ConstantHandleSupplier.of(h);\n            threadHandleSupplier.set(handleSupplier);\n            return callback.withHandle(h);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param consumer A callback which will receive an open Handle\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useHandle(final HandleConsumer<X> consumer) throws X {\n        withHandle(consumer.asCallback());\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final TransactionIsolationLevel level, final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(level, callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final TransactionIsolationLevel level, final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(level, callback));\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, yields it to a callback, and returns the result\n     * of the callback. A handle is opened if needed by the extension, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension.\n     * @param callback      a callback which will receive the extension.\n     * @param <R> the return type\n     * @param <E> the extension type\n     * @param <X> the exception type optionally thrown by the callback\n     * @return the value returned by the callback.\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension\n     *                                  type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <R, E, X extends Exception> R withExtension(Class<E> extensionType, ExtensionCallback<R, E, X> callback)\n            throws X {\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n        if (handleSupplier != null) {\n            return callWithExtension(extensionType, callback, handleSupplier);\n        }\n\n        try (LazyHandleSupplier lazyHandleSupplier = new LazyHandleSupplier(this)) {\n            threadHandleSupplier.set(lazyHandleSupplier);\n            return callWithExtension(extensionType, callback, lazyHandleSupplier);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    private <R, E, X extends Exception> R callWithExtension(Class<E> extensionType,\n                                                            ExtensionCallback<R, E, X> callback,\n                                                            HandleSupplier handleSupplier) throws X {\n        E extension = getConfig(Extensions.class)\n            .findFor(extensionType, handleSupplier)\n            .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n\n        return callback.withExtension(extension);\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, and yields it to a callback. A handle is opened\n     * if needed by the extention, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension\n     * @param callback      a callback which will receive the extension\n     * @param <E>           the extension type\n     * @param <X>           the exception type optionally thrown by the callback\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <E, X extends Exception> void useExtension(Class<E> extensionType, ExtensionConsumer<E, X> callback)\n            throws X {\n        withExtension(extensionType, extension -> {\n            callback.useExtension(extension);\n            return null;\n        });\n    }\n\n    /**\n     * Creates an extension instance that uses the current {@link Jdbi} instance for database operations.\n     *\n     * @param extensionType the type of extension. Must be a public interface type.\n     * @param <E> the extension type\n     *\n     * @return an extension which opens and closes handles (as needed) for individual method calls. Only public\n     * interface types may be used as on-demand extensions.\n     */\n    public <E> E onDemand(Class<E> extensionType) {\n        if (!extensionType.isInterface()) {\n            throw new IllegalArgumentException(\"On-demand extensions are only supported for interfaces.\");\n        }\n        if (!getConfig(Extensions.class).hasExtensionFor(extensionType)) {\n            throw new NoSuchExtensionException(extensionType, \"Extension not found: %s\");\n        }\n\n        return getConfig(OnDemandExtensions.class).create(this, extensionType);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceLoader;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.sql.DataSource;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionCallback;\nimport org.jdbi.v3.core.extension.ExtensionConsumer;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.core.statement.DefaultStatementBuilder;\nimport org.jdbi.v3.core.statement.SqlStatements;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilderFactory;\nimport org.jdbi.v3.core.transaction.LocalTransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * Main entry point; configurable wrapper around a JDBC {@link DataSource}.\n * Use it to obtain Handle instances and provide configuration\n * for all handles obtained from it.\n */\npublic class Jdbi implements Configurable<Jdbi> {\n    private static final Logger LOG = LoggerFactory.getLogger(Jdbi.class);\n\n    private final ConfigRegistry config = new ConfigRegistry();\n\n    private final ConnectionFactory connectionFactory;\n    private final AtomicReference<TransactionHandler> transactionhandler = new AtomicReference<>(LocalTransactionHandler.binding());\n    private final AtomicReference<StatementBuilderFactory> statementBuilderFactory = new AtomicReference<>(DefaultStatementBuilder.FACTORY);\n    private final AtomicReference<Handler> handler = new AtomicReference<>(Handler.STANDARD_HANDLER);\n\n    private final CopyOnWriteArrayList<JdbiPlugin> plugins = new CopyOnWriteArrayList<>();\n\n    @SuppressWarnings(\"ThreadLocalUsage\")\n    private final ThreadLocal<HandleSupplier> threadHandleSupplier = new ThreadLocal<>();\n\n    private Jdbi(ConnectionFactory connectionFactory) {\n        Objects.requireNonNull(connectionFactory, \"null connectionFactory\");\n        this.connectionFactory = connectionFactory;\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link Connection}.\n     *\n     * @param connection A {@link Connection} object.\n     *\n     * @return A {@link Jdbi} instance that uses a single database connection.\n     */\n    public static Jdbi create(Connection connection) {\n        return create(new SingleConnectionFactory(connection));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link DataSource}.\n     *\n     * @param dataSource the data source.\n     *\n     * @return a Jdbi which uses the given data source as a connection factory.\n     */\n    public static Jdbi create(DataSource dataSource) {\n        return create(dataSource::getConnection);\n    }\n\n    /**\n     * Factory used to allow for obtaining a Connection in a customized manner.\n     *\n     * <p>\n     * The {@link ConnectionFactory#openConnection()} method will be invoked to obtain a connection instance\n     * whenever a Handle is opened.\n     * <\/p>\n     *\n     * @param connectionFactory Provides JDBC connections to Handle instances\n     *\n     * @return a Jdbi which uses the given connection factory.\n     */\n    public static Jdbi create(ConnectionFactory connectionFactory) {\n        return new Jdbi(connectionFactory);\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url A JDBC URL for connections.\n     *\n     * @return a Jdbi which uses{@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url) {\n        Objects.requireNonNull(url, \"null url\");\n        return create(() -> DriverManager.getConnection(url));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url   JDBC URL for connections\n     * @param properties Properties to pass to DriverManager.getConnection(url, props) for each new handle\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final Properties properties) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(properties, \"null properties\");\n        return create(() -> DriverManager.getConnection(url, properties));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url      JDBC URL for connections\n     * @param username User name for connection authentication\n     * @param password Password for connection authentication\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final String username, final String password) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(username, \"null username\");\n        Objects.requireNonNull(password, \"null password\");\n        return create(() -> DriverManager.getConnection(url, username, password));\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a specific data source\n     *\n     * @param dataSource the JDBC data source.\n     *\n     * @return Handle using a Connection obtained from the provided DataSource\n     */\n    public static Handle open(DataSource dataSource) {\n        return create(dataSource).open();\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a {@link ConnectionFactory}.\n     *\n     * @param connectionFactory the connection factory\n     *\n     * @return Handle using a Connection obtained from the provided connection factory\n     */\n    public static Handle open(ConnectionFactory connectionFactory) {\n        return create(connectionFactory).open();\n    }\n\n    /**\n     * Create a Handle wrapping a particular JDBC Connection\n     *\n     * @param connection the JDBC connection\n     *\n     * @return Handle bound to connection\n     */\n    public static Handle open(final Connection connection) {\n        Objects.requireNonNull(connection, \"null connection\");\n        return create(() -> connection).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url JDBC Url\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url) {\n        return create(url).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url      JDBC Url\n     * @param username JDBC username for authentication\n     * @param password JDBC password for authentication\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final String username, final String password) {\n        return create(url, username, password).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url   JDBC Url\n     * @param props JDBC properties\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final Properties props) {\n        return create(url, props).open();\n    }\n\n    /**\n     * Use the {@link ServiceLoader} API to detect and install plugins automagically.\n     * Some people consider this feature dangerous; some consider it essential --\n     * use at your own risk.\n     * @return this\n     */\n    public Jdbi installPlugins() {\n        ServiceLoader.load(JdbiPlugin.class).forEach(this::installPlugin);\n        LOG.debug(\"Automatically installed plugins {}\", plugins);\n        return this;\n    }\n\n    /**\n     * Install a given {@link JdbiPlugin} instance that will configure any\n     * provided {@link Handle} instances.\n     * @param plugin the plugin to install\n     * @return this\n     */\n    public Jdbi installPlugin(JdbiPlugin plugin) {\n        if (plugins.addIfAbsent(plugin)) {\n            Unchecked.consumer(plugin::customizeJdbi).accept(this);\n        }\n        return this;\n    }\n\n    /**\n     * Allows customization of how prepared statements are created. When a Handle is created\n     * against this Jdbi instance the factory will be used to create a StatementBuilder for\n     * that specific handle. When the handle is closed, the StatementBuilder's close method\n     * will be invoked.\n     *\n     * @param factory the new statement builder factory.\n     * @return this\n     */\n    public Jdbi setStatementBuilderFactory(StatementBuilderFactory factory) {\n        this.statementBuilderFactory.set(factory);\n        return this;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilderFactory}.\n     *\n     * @return the current {@link StatementBuilderFactory}\n     */\n    public StatementBuilderFactory getStatementBuilderFactory() {\n        return this.statementBuilderFactory.get();\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return config;\n    }\n\n    /**\n     * Specify the TransactionHandler instance to use. This allows overriding\n     * transaction semantics, or mapping into different transaction\n     * management systems.\n     * <p>\n     * The default version uses local transactions on the database Connection\n     * instances obtained.\n     * <\/p>\n     *\n     * @param handler The TransactionHandler to use for all Handle instances obtained\n     *                from this Jdbi\n     * @return this\n     */\n    public Jdbi setTransactionHandler(TransactionHandler handler) {\n        Objects.requireNonNull(handler, \"null transaction handler\");\n        this.transactionhandler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link TransactionHandler}.\n     *\n     * @return the {@link TransactionHandler}\n     */\n    public TransactionHandler getTransactionHandler() {\n        return this.transactionhandler.get();\n    }\n\n    /**\n     * Specify the {@link Handler} instance to use. This allows overriding\n     * callbacks for {@link #useHandle}, {@link #withHandle}, {@link #useTransaction} and\n     * {@link #inTransaction}. The default version is a pass-through that returns the callback unchanged.\n     *\n     * @param handler The {@link Handler} to use for all {@link #useHandle}, {@link #withHandle},\n     *                {@link #useTransaction} and {@link #inTransaction} from this Jdbi\n     * @return this\n     */\n    public Jdbi setHandler(Handler handler) {\n        Objects.requireNonNull(handler, \"null handler\");\n        this.handler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link Handler}.\n     *\n     * @return the {@link Handler}\n     */\n    public Handler getHandler() {\n        return this.handler.get();\n    }\n\n    /**\n     * Obtain a Handle to the data source wrapped by this Jdbi instance.\n     * You own this expensive resource and are required to close it or\n     * risk leaks.  Using a {@code try-with-resources} block is recommended.\n     *\n     * @return an open Handle instance\n     * @see #useHandle(HandleConsumer)\n     * @see #withHandle(HandleCallback)\n     */\n    public Handle open() {\n        try {\n            final long start = System.nanoTime();\n            @SuppressWarnings(\"PMD.CloseResource\")\n            Connection conn = Objects.requireNonNull(connectionFactory.openConnection(),\n                    () -> \"Connection factory \" + connectionFactory + \" returned a null connection\");\n            final long stop = System.nanoTime();\n\n            for (JdbiPlugin p : plugins) {\n                conn = p.customizeConnection(conn);\n            }\n\n            StatementBuilder cache = statementBuilderFactory.get().createStatementBuilder(conn);\n\n            Handle h = Handle.createHandle(this,\n                connectionFactory.getCleanableFor(conn), // don't use conn::close, the cleanup must be done by the connection factory!\n                transactionhandler.get(),\n                cache,\n                conn);\n\n            for (JdbiPlugin p : plugins) {\n                h = p.customizeHandle(h);\n            }\n            LOG.trace(\"Jdbi [{}] obtain handle [{}] in {}ms\", this, h, MILLISECONDS.convert(stop - start, NANOSECONDS));\n            return h;\n        } catch (SQLException e) {\n            throw new ConnectionException(e);\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param callback A callback which will receive an open Handle\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {\n\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n\n        HandleCallback<R, X> decoratedCallback = handler.get().decorate(callback);\n\n        if (handleSupplier != null) {\n            return decoratedCallback.withHandle(handleSupplier.getHandle());\n        }\n\n        try (Handle h = this.open()) {\n            SqlStatements sqlStatements = h.getConfig(SqlStatements.class);\n            sqlStatements.setAttachAllStatementsForCleanup(sqlStatements.isAttachCallbackStatementsForCleanup());\n\n            handleSupplier = ConstantHandleSupplier.of(h);\n            threadHandleSupplier.set(handleSupplier);\n            return decoratedCallback.withHandle(h);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param consumer A callback which will receive an open Handle\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useHandle(final HandleConsumer<X> consumer) throws X {\n        withHandle(consumer.asCallback());\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final TransactionIsolationLevel level, final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(level, callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final TransactionIsolationLevel level, final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(level, callback));\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, yields it to a callback, and returns the result\n     * of the callback. A handle is opened if needed by the extension, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension.\n     * @param callback      a callback which will receive the extension.\n     * @param <R> the return type\n     * @param <E> the extension type\n     * @param <X> the exception type optionally thrown by the callback\n     * @return the value returned by the callback.\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension\n     *                                  type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <R, E, X extends Exception> R withExtension(Class<E> extensionType, ExtensionCallback<R, E, X> callback)\n            throws X {\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n        if (handleSupplier != null) {\n            return callWithExtension(extensionType, callback, handleSupplier);\n        }\n\n        try (LazyHandleSupplier lazyHandleSupplier = new LazyHandleSupplier(this)) {\n            threadHandleSupplier.set(lazyHandleSupplier);\n            return callWithExtension(extensionType, callback, lazyHandleSupplier);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    private <R, E, X extends Exception> R callWithExtension(Class<E> extensionType,\n                                                            ExtensionCallback<R, E, X> callback,\n                                                            HandleSupplier handleSupplier) throws X {\n        E extension = getConfig(Extensions.class)\n            .findFor(extensionType, handleSupplier)\n            .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n\n        return callback.withExtension(extension);\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, and yields it to a callback. A handle is opened\n     * if needed by the extention, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension\n     * @param callback      a callback which will receive the extension\n     * @param <E>           the extension type\n     * @param <X>           the exception type optionally thrown by the callback\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <E, X extends Exception> void useExtension(Class<E> extensionType, ExtensionConsumer<E, X> callback)\n            throws X {\n        withExtension(extensionType, extension -> {\n            callback.useExtension(extension);\n            return null;\n        });\n    }\n\n    /**\n     * Creates an extension instance that uses the current {@link Jdbi} instance for database operations.\n     *\n     * @param extensionType the type of extension. Must be a public interface type.\n     * @param <E> the extension type\n     *\n     * @return an extension which opens and closes handles (as needed) for individual method calls. Only public\n     * interface types may be used as on-demand extensions.\n     */\n    public <E> E onDemand(Class<E> extensionType) {\n        if (!extensionType.isInterface()) {\n            throw new IllegalArgumentException(\"On-demand extensions are only supported for interfaces.\");\n        }\n        if (!getConfig(Extensions.class).hasExtensionFor(extensionType)) {\n            throw new NoSuchExtensionException(extensionType, \"Extension not found: %s\");\n        }\n\n        return getConfig(OnDemandExtensions.class).create(this, extensionType);\n    }\n}\n","lineNo":386}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.jackson2;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectReader;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.jdbi.v3.json.JsonMapper;\n\nclass JacksonJsonMapper implements JsonMapper {\n    @Override\n    public String toJson(Type type, Object value, ConfigRegistry config) {\n        try {\n            Jackson2Config cfg = config.get(Jackson2Config.class);\n            ObjectWriter writer = cfg.getMapper().writerFor(cfg.getMapper().constructType(type));\n            Class<?> view = cfg.getSerializationView();\n            if (view != null) {\n                writer = writer.withView(view);\n            }\n            return writer.writeValueAsString(value);\n        } catch (JsonProcessingException e) {\n            throw new UnableToProduceResultException(e);\n        }\n    }\n\n    @Override\n    public Object fromJson(Type type, String json, ConfigRegistry config) {\n        try {\n            Jackson2Config cfg = config.get(Jackson2Config.class);\n            ObjectReader reader = cfg.getMapper().readerFor(cfg.getMapper().constructType(type));\n            Class<?> view = cfg.getDeserializationView();\n            if (view != null) {\n                reader = reader.withView(view);\n            }\n            return reader.readValue(json);\n        } catch (IOException e) {\n            throw new UnableToProduceResultException(e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.jackson2;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ObjectReader;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.jdbi.v3.json.JsonMapper;\n\nclass JacksonJsonMapper implements JsonMapper {\n    @Override\n    public TypedJsonMapper forType(Type type, ConfigRegistry config) {\n        return new TypedJsonMapper() {\n            private final ObjectMapper mapper = config.get(Jackson2Config.class).getMapper();\n            private final JavaType mappedType = mapper.constructType(type);\n            private final ObjectReader reader = mapper.readerFor(mappedType);\n            private final ObjectWriter writer = mapper.writerFor(mappedType);\n\n            @Override\n            public String toJson(Object value, ConfigRegistry config) {\n                final Class<?> view = config.get(Jackson2Config.class).getSerializationView();\n                final ObjectWriter viewWriter =\n                          view == null\n                        ? writer\n                        : writer.withView(view);\n                try {\n                    return viewWriter.writeValueAsString(value);\n                } catch (JsonProcessingException e) {\n                    throw new UnableToProduceResultException(e);\n                }\n            }\n\n            @Override\n            public Object fromJson(String json, ConfigRegistry config) {\n                final Class<?> view = config.get(Jackson2Config.class).getDeserializationView();\n                final ObjectReader viewReader =\n                          view == null\n                        ? reader\n                        : reader.withView(view);\n                try {\n                    return viewReader.readValue(json);\n                } catch (IOException e) {\n                    throw new UnableToProduceResultException(e);\n                }\n            }\n        };\n    }\n}\n","lineNo":54}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.ExtensionHandler;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.result.RowReducer;\nimport org.jdbi.v3.core.statement.SqlStatement;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\nimport org.jdbi.v3.sqlobject.SqlObjects;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizer;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizingAnnotation;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\nimport org.jdbi.v3.sqlobject.statement.ParameterCustomizerFactory;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.sqlobject.statement.UseRowReducer;\n\nimport static java.util.stream.Stream.concat;\n\n/**\n * Base handler for annotations' implementation classes.\n */\nabstract class CustomizingStatementHandler<StatementType extends SqlStatement<StatementType>> implements ExtensionHandler {\n\n    private final List<BoundCustomizer> statementCustomizers;\n    private final Class<?> sqlObjectType;\n    private final Method method;\n\n    CustomizingStatementHandler(Class<?> type, Method method) {\n        this.sqlObjectType = type;\n        this.method = method;\n        this.statementCustomizers = new ArrayList<>();\n\n        // type customizers, including annotations on the interface's supertypes\n        concat(JdbiClassUtils.superTypes(type), Stream.of(type))\n                .flatMap(CustomizingStatementHandler::annotationsFor)\n                .map(a -> instantiateFactory(a).createForType(a, type))\n                .map(BoundCustomizer::of)\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n\n        // method customizers\n        annotationsFor(method)\n                .map(a -> instantiateFactory(a).createForMethod(a, type, method))\n                .map(BoundCustomizer::of)\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n\n        // parameter customizers\n        parameterCustomizers()\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n    }\n\n    @Override\n    public void warm(ConfigRegistry config) {\n        statementCustomizers.forEach(s -> s.warm(config));\n    }\n\n    private static Stream<Annotation> annotationsFor(AnnotatedElement... elements) {\n        return Stream.of(elements)\n                .map(AnnotatedElement::getAnnotations)\n                .flatMap(Stream::of)\n                .filter(a -> a.annotationType().isAnnotationPresent(SqlStatementCustomizingAnnotation.class));\n    }\n\n    private Stream<BoundCustomizer> parameterCustomizers() {\n        final Parameter[] parameters = method.getParameters();\n\n        return IntStream.range(0, parameters.length)\n                .boxed()\n                .flatMap(i -> eachParameterCustomizers(parameters[i], i));\n    }\n\n    private Stream<BoundCustomizer> eachParameterCustomizers(Parameter parameter,\n            Integer i) {\n\n        List<BoundCustomizer> customizers = annotationsFor(parameter)\n                .map(a -> instantiateFactory(a).createForParameter(a, sqlObjectType, method, parameter, i, getParameterType(parameter)))\n                .<BoundCustomizer>map(c -> new BoundCustomizer() {\n                    @Override\n                    public void warm(ConfigRegistry config) {\n                        c.warm(config);\n                    }\n\n                    @Override\n                    public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                        c.apply(stmt, args[i]);\n                    }\n                })\n                .collect(Collectors.toList());\n\n        if (!customizers.isEmpty()) {\n            return customizers.stream();\n        }\n\n        if (parameter.getType() == Consumer.class) {\n            if (method.getReturnType() != Void.TYPE) {\n                throw new IllegalStateException(\n                        \"SQL Object methods with a Consumer parameter must have void return type.\");\n            }\n            return Stream.empty();\n        }\n        if (parameter.getType() == Function.class && this instanceof SqlCallHandler) {\n            return Stream.empty();\n        }\n\n        return Stream.of(defaultParameterCustomizer(parameter, i));\n    }\n\n    /**\n     * Default parameter customizer for parameters with no annotations.\n     */\n    private BoundCustomizer defaultParameterCustomizer(Parameter parameter,\n            Integer i) {\n        return new BoundCustomizer() {\n            @Override\n            public void warm(ConfigRegistry config) {\n                create(config).warm(config);\n            }\n\n            @Override\n            public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                create(stmt.getConfig()).apply(stmt, args[i]);\n            }\n\n            private SqlStatementParameterCustomizer create(ConfigRegistry config) {\n                return getDefaultParameterCustomizerFactory(config)\n                        .createForParameter(sqlObjectType, method, parameter, i, getParameterType(parameter));\n            }\n        };\n    }\n\n    Type getParameterType(Parameter parameter) {\n        return GenericTypes.resolveType(parameter.getParameterizedType(), sqlObjectType);\n    }\n\n    private static ParameterCustomizerFactory getDefaultParameterCustomizerFactory(ConfigRegistry config) {\n        return config.get(SqlObjects.class).getDefaultParameterCustomizerFactory();\n    }\n\n    private static SqlStatementCustomizerFactory instantiateFactory(Annotation annotation) {\n        SqlStatementCustomizingAnnotation sqlStatementCustomizingAnnotation = annotation.annotationType()\n                .getAnnotation(SqlStatementCustomizingAnnotation.class);\n        try {\n            return sqlStatementCustomizingAnnotation.value().getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new IllegalStateException(\"Unable to instantiate sql statement customizer factory class \" + sqlStatementCustomizingAnnotation.value(), e);\n        }\n    }\n\n    @Override\n    public Object invoke(HandleSupplier handleSupplier, Object target, Object... args) {\n        final Handle h = handleSupplier.getHandle();\n        final String locatedSql = locateSql(h);\n        final StatementType stmt = createStatement(h, locatedSql);\n\n        // clean the statement when the handle closes\n        stmt.attachToHandleForCleanup();\n\n        final SqlObjectStatementConfiguration cfg = stmt.getConfig(SqlObjectStatementConfiguration.class);\n        cfg.setArgs(args);\n        configureReturner(stmt, cfg);\n        applyCustomizers(stmt, JdbiClassUtils.safeVarargs(args));\n        return cfg.getReturner().get();\n    }\n\n    void applyCustomizers(final StatementType stmt, Object[] args) {\n        statementCustomizers.forEach(b -> {\n            try {\n                b.apply(stmt, args);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, stmt.getContext());\n            }\n        });\n    }\n\n    abstract void configureReturner(StatementType stmt, SqlObjectStatementConfiguration cfg);\n\n    abstract StatementType createStatement(Handle handle, String locatedSql);\n\n    String locateSql(final Handle h) {\n        return h.getConfig(SqlObjects.class).getSqlLocator().locate(sqlObjectType, method, h.getConfig());\n    }\n\n    Method getMethod() {\n        return method;\n    }\n\n    static RowMapper<?> rowMapperFor(UseRowMapper annotation) {\n        Class<? extends RowMapper<?>> mapperClass = annotation.value();\n        try {\n            return mapperClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new UnableToCreateStatementException(\"Could not create mapper \" + mapperClass.getName(), e, null);\n        }\n    }\n\n    static RowReducer<?, ?> rowReducerFor(UseRowReducer annotation) {\n        Class<? extends RowReducer<?, ?>> reducerClass = annotation.value();\n        try {\n            return reducerClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new UnableToCreateStatementException(\"Could not create reducer \" + reducerClass.getName(), e, null);\n        }\n    }\n\n    /**\n     * A {@link SqlStatementCustomizer} or {@link SqlStatementParameterCustomizer} that\n     * is ready to apply.\n     */\n    private interface BoundCustomizer {\n        void apply(SqlStatement<?> stmt, Object[] args) throws SQLException;\n        void warm(ConfigRegistry config);\n\n        static BoundCustomizer of(SqlStatementCustomizer inner) {\n            return new BoundCustomizer() {\n                @Override\n                public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                    inner.apply(stmt);\n                }\n\n                @Override\n                public void warm(ConfigRegistry config) {\n                    inner.warm(config);\n                }\n            };\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.ExtensionHandler;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.result.RowReducer;\nimport org.jdbi.v3.core.statement.SqlStatement;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\nimport org.jdbi.v3.sqlobject.SqlObjects;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizer;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizingAnnotation;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\nimport org.jdbi.v3.sqlobject.statement.ParameterCustomizerFactory;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.sqlobject.statement.UseRowReducer;\n\nimport static java.util.stream.Stream.concat;\n\n/**\n * Base handler for annotations' implementation classes.\n */\nabstract class CustomizingStatementHandler<StatementType extends SqlStatement<StatementType>> implements ExtensionHandler {\n\n    private final List<BoundCustomizer> statementCustomizers;\n    private final Class<?> sqlObjectType;\n    private final Method method;\n\n    CustomizingStatementHandler(Class<?> type, Method method) {\n        this.sqlObjectType = type;\n        this.method = method;\n        this.statementCustomizers = new ArrayList<>();\n\n        // type customizers, including annotations on the interface's supertypes\n        concat(JdbiClassUtils.superTypes(type), Stream.of(type))\n                .flatMap(CustomizingStatementHandler::annotationsFor)\n                .map(a -> instantiateFactory(a).createForType(a, type))\n                .map(BoundCustomizer::of)\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n\n        // method customizers\n        annotationsFor(method)\n                .map(a -> instantiateFactory(a).createForMethod(a, type, method))\n                .map(BoundCustomizer::of)\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n\n        // parameter customizers\n        parameterCustomizers()\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n    }\n\n    @Override\n    public void warm(ConfigRegistry config) {\n        statementCustomizers.forEach(s -> s.warm(config));\n    }\n\n    private static Stream<Annotation> annotationsFor(AnnotatedElement... elements) {\n        return Stream.of(elements)\n                .map(AnnotatedElement::getAnnotations)\n                .flatMap(Stream::of)\n                .filter(a -> a.annotationType().isAnnotationPresent(SqlStatementCustomizingAnnotation.class));\n    }\n\n    private Stream<BoundCustomizer> parameterCustomizers() {\n        final Parameter[] parameters = method.getParameters();\n\n        return IntStream.range(0, parameters.length)\n                .boxed()\n                .flatMap(i -> eachParameterCustomizers(parameters[i], i));\n    }\n\n    private Stream<BoundCustomizer> eachParameterCustomizers(Parameter parameter, Integer i) {\n        final Type parameterType = getParameterType(parameter);\n        List<BoundCustomizer> customizers = annotationsFor(parameter)\n                .map(a -> instantiateFactory(a).createForParameter(a, sqlObjectType, method, parameter, i, parameterType))\n                .<BoundCustomizer>map(c -> new BoundCustomizer() {\n                    @Override\n                    public void warm(ConfigRegistry config) {\n                        c.warm(config);\n                    }\n\n                    @Override\n                    public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                        c.apply(stmt, args[i]);\n                    }\n                })\n                .collect(Collectors.toList());\n\n        if (!customizers.isEmpty()) {\n            return customizers.stream();\n        }\n\n        if (parameter.getType() == Consumer.class) {\n            if (method.getReturnType() != Void.TYPE) {\n                throw new IllegalStateException(\n                        \"SQL Object methods with a Consumer parameter must have void return type.\");\n            }\n            return Stream.empty();\n        }\n        if (parameter.getType() == Function.class && this instanceof SqlCallHandler) {\n            return Stream.empty();\n        }\n\n        return Stream.of(defaultParameterCustomizer(parameter, i));\n    }\n\n    /**\n     * Default parameter customizer for parameters with no annotations.\n     */\n    private BoundCustomizer defaultParameterCustomizer(Parameter parameter, Integer i) {\n        final Type parameterType = getParameterType(parameter);\n        return new BoundCustomizer() {\n            @Override\n            public void warm(ConfigRegistry config) {\n                create(config).warm(config);\n            }\n\n            @Override\n            public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                create(stmt.getConfig()).apply(stmt, args[i]);\n            }\n\n            private SqlStatementParameterCustomizer create(ConfigRegistry config) {\n                return getDefaultParameterCustomizerFactory(config)\n                        .createForParameter(sqlObjectType, method, parameter, i, parameterType);\n            }\n        };\n    }\n\n    Type getParameterType(Parameter parameter) {\n        return GenericTypes.resolveType(parameter.getParameterizedType(), sqlObjectType);\n    }\n\n    private static ParameterCustomizerFactory getDefaultParameterCustomizerFactory(ConfigRegistry config) {\n        return config.get(SqlObjects.class).getDefaultParameterCustomizerFactory();\n    }\n\n    private static SqlStatementCustomizerFactory instantiateFactory(Annotation annotation) {\n        SqlStatementCustomizingAnnotation sqlStatementCustomizingAnnotation = annotation.annotationType()\n                .getAnnotation(SqlStatementCustomizingAnnotation.class);\n        try {\n            return sqlStatementCustomizingAnnotation.value().getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new IllegalStateException(\"Unable to instantiate sql statement customizer factory class \" + sqlStatementCustomizingAnnotation.value(), e);\n        }\n    }\n\n    @Override\n    public Object invoke(HandleSupplier handleSupplier, Object target, Object... args) {\n        final Handle h = handleSupplier.getHandle();\n        final String locatedSql = locateSql(h);\n        final StatementType stmt = createStatement(h, locatedSql);\n\n        // clean the statement when the handle closes\n        stmt.attachToHandleForCleanup();\n\n        final SqlObjectStatementConfiguration cfg = stmt.getConfig(SqlObjectStatementConfiguration.class);\n        cfg.setArgs(args);\n        configureReturner(stmt, cfg);\n        applyCustomizers(stmt, JdbiClassUtils.safeVarargs(args));\n        return cfg.getReturner().get();\n    }\n\n    void applyCustomizers(final StatementType stmt, Object[] args) {\n        statementCustomizers.forEach(b -> {\n            try {\n                b.apply(stmt, args);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, stmt.getContext());\n            }\n        });\n    }\n\n    abstract void configureReturner(StatementType stmt, SqlObjectStatementConfiguration cfg);\n\n    abstract StatementType createStatement(Handle handle, String locatedSql);\n\n    String locateSql(final Handle h) {\n        return h.getConfig(SqlObjects.class).getSqlLocator().locate(sqlObjectType, method, h.getConfig());\n    }\n\n    Method getMethod() {\n        return method;\n    }\n\n    static RowMapper<?> rowMapperFor(UseRowMapper annotation) {\n        Class<? extends RowMapper<?>> mapperClass = annotation.value();\n        try {\n            return mapperClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new UnableToCreateStatementException(\"Could not create mapper \" + mapperClass.getName(), e, null);\n        }\n    }\n\n    static RowReducer<?, ?> rowReducerFor(UseRowReducer annotation) {\n        Class<? extends RowReducer<?, ?>> reducerClass = annotation.value();\n        try {\n            return reducerClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new UnableToCreateStatementException(\"Could not create reducer \" + reducerClass.getName(), e, null);\n        }\n    }\n\n    /**\n     * A {@link SqlStatementCustomizer} or {@link SqlStatementParameterCustomizer} that\n     * is ready to apply.\n     */\n    private interface BoundCustomizer {\n        void apply(SqlStatement<?> stmt, Object[] args) throws SQLException;\n        void warm(ConfigRegistry config);\n\n        static BoundCustomizer of(SqlStatementCustomizer inner) {\n            return new BoundCustomizer() {\n                @Override\n                public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                    inner.apply(stmt);\n                }\n\n                @Override\n                public void warm(ConfigRegistry config) {\n                    inner.warm(config);\n                }\n            };\n        }\n    }\n}\n","lineNo":105}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.ExtensionHandler;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.result.RowReducer;\nimport org.jdbi.v3.core.statement.SqlStatement;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\nimport org.jdbi.v3.sqlobject.SqlObjects;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizer;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizingAnnotation;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\nimport org.jdbi.v3.sqlobject.statement.ParameterCustomizerFactory;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.sqlobject.statement.UseRowReducer;\n\nimport static java.util.stream.Stream.concat;\n\n/**\n * Base handler for annotations' implementation classes.\n */\nabstract class CustomizingStatementHandler<StatementType extends SqlStatement<StatementType>> implements ExtensionHandler {\n\n    private final List<BoundCustomizer> statementCustomizers;\n    private final Class<?> sqlObjectType;\n    private final Method method;\n\n    CustomizingStatementHandler(Class<?> type, Method method) {\n        this.sqlObjectType = type;\n        this.method = method;\n        this.statementCustomizers = new ArrayList<>();\n\n        // type customizers, including annotations on the interface's supertypes\n        concat(JdbiClassUtils.superTypes(type), Stream.of(type))\n                .flatMap(CustomizingStatementHandler::annotationsFor)\n                .map(a -> instantiateFactory(a).createForType(a, type))\n                .map(BoundCustomizer::of)\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n\n        // method customizers\n        annotationsFor(method)\n                .map(a -> instantiateFactory(a).createForMethod(a, type, method))\n                .map(BoundCustomizer::of)\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n\n        // parameter customizers\n        parameterCustomizers()\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n    }\n\n    @Override\n    public void warm(ConfigRegistry config) {\n        statementCustomizers.forEach(s -> s.warm(config));\n    }\n\n    private static Stream<Annotation> annotationsFor(AnnotatedElement... elements) {\n        return Stream.of(elements)\n                .map(AnnotatedElement::getAnnotations)\n                .flatMap(Stream::of)\n                .filter(a -> a.annotationType().isAnnotationPresent(SqlStatementCustomizingAnnotation.class));\n    }\n\n    private Stream<BoundCustomizer> parameterCustomizers() {\n        final Parameter[] parameters = method.getParameters();\n\n        return IntStream.range(0, parameters.length)\n                .boxed()\n                .flatMap(i -> eachParameterCustomizers(parameters[i], i));\n    }\n\n    private Stream<BoundCustomizer> eachParameterCustomizers(Parameter parameter,\n            Integer i) {\n\n        List<BoundCustomizer> customizers = annotationsFor(parameter)\n                .map(a -> instantiateFactory(a).createForParameter(a, sqlObjectType, method, parameter, i, getParameterType(parameter)))\n                .<BoundCustomizer>map(c -> new BoundCustomizer() {\n                    @Override\n                    public void warm(ConfigRegistry config) {\n                        c.warm(config);\n                    }\n\n                    @Override\n                    public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                        c.apply(stmt, args[i]);\n                    }\n                })\n                .collect(Collectors.toList());\n\n        if (!customizers.isEmpty()) {\n            return customizers.stream();\n        }\n\n        if (parameter.getType() == Consumer.class) {\n            if (method.getReturnType() != Void.TYPE) {\n                throw new IllegalStateException(\n                        \"SQL Object methods with a Consumer parameter must have void return type.\");\n            }\n            return Stream.empty();\n        }\n        if (parameter.getType() == Function.class && this instanceof SqlCallHandler) {\n            return Stream.empty();\n        }\n\n        return Stream.of(defaultParameterCustomizer(parameter, i));\n    }\n\n    /**\n     * Default parameter customizer for parameters with no annotations.\n     */\n    private BoundCustomizer defaultParameterCustomizer(Parameter parameter,\n            Integer i) {\n        return new BoundCustomizer() {\n            @Override\n            public void warm(ConfigRegistry config) {\n                create(config).warm(config);\n            }\n\n            @Override\n            public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                create(stmt.getConfig()).apply(stmt, args[i]);\n            }\n\n            private SqlStatementParameterCustomizer create(ConfigRegistry config) {\n                return getDefaultParameterCustomizerFactory(config)\n                        .createForParameter(sqlObjectType, method, parameter, i, getParameterType(parameter));\n            }\n        };\n    }\n\n    Type getParameterType(Parameter parameter) {\n        return GenericTypes.resolveType(parameter.getParameterizedType(), sqlObjectType);\n    }\n\n    private static ParameterCustomizerFactory getDefaultParameterCustomizerFactory(ConfigRegistry config) {\n        return config.get(SqlObjects.class).getDefaultParameterCustomizerFactory();\n    }\n\n    private static SqlStatementCustomizerFactory instantiateFactory(Annotation annotation) {\n        SqlStatementCustomizingAnnotation sqlStatementCustomizingAnnotation = annotation.annotationType()\n                .getAnnotation(SqlStatementCustomizingAnnotation.class);\n        try {\n            return sqlStatementCustomizingAnnotation.value().getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new IllegalStateException(\"Unable to instantiate sql statement customizer factory class \" + sqlStatementCustomizingAnnotation.value(), e);\n        }\n    }\n\n    @Override\n    public Object invoke(HandleSupplier handleSupplier, Object target, Object... args) {\n        final Handle h = handleSupplier.getHandle();\n        final String locatedSql = locateSql(h);\n        final StatementType stmt = createStatement(h, locatedSql);\n\n        // clean the statement when the handle closes\n        stmt.attachToHandleForCleanup();\n\n        final SqlObjectStatementConfiguration cfg = stmt.getConfig(SqlObjectStatementConfiguration.class);\n        cfg.setArgs(args);\n        configureReturner(stmt, cfg);\n        applyCustomizers(stmt, JdbiClassUtils.safeVarargs(args));\n        return cfg.getReturner().get();\n    }\n\n    void applyCustomizers(final StatementType stmt, Object[] args) {\n        statementCustomizers.forEach(b -> {\n            try {\n                b.apply(stmt, args);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, stmt.getContext());\n            }\n        });\n    }\n\n    abstract void configureReturner(StatementType stmt, SqlObjectStatementConfiguration cfg);\n\n    abstract StatementType createStatement(Handle handle, String locatedSql);\n\n    String locateSql(final Handle h) {\n        return h.getConfig(SqlObjects.class).getSqlLocator().locate(sqlObjectType, method, h.getConfig());\n    }\n\n    Method getMethod() {\n        return method;\n    }\n\n    static RowMapper<?> rowMapperFor(UseRowMapper annotation) {\n        Class<? extends RowMapper<?>> mapperClass = annotation.value();\n        try {\n            return mapperClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new UnableToCreateStatementException(\"Could not create mapper \" + mapperClass.getName(), e, null);\n        }\n    }\n\n    static RowReducer<?, ?> rowReducerFor(UseRowReducer annotation) {\n        Class<? extends RowReducer<?, ?>> reducerClass = annotation.value();\n        try {\n            return reducerClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new UnableToCreateStatementException(\"Could not create reducer \" + reducerClass.getName(), e, null);\n        }\n    }\n\n    /**\n     * A {@link SqlStatementCustomizer} or {@link SqlStatementParameterCustomizer} that\n     * is ready to apply.\n     */\n    private interface BoundCustomizer {\n        void apply(SqlStatement<?> stmt, Object[] args) throws SQLException;\n        void warm(ConfigRegistry config);\n\n        static BoundCustomizer of(SqlStatementCustomizer inner) {\n            return new BoundCustomizer() {\n                @Override\n                public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                    inner.apply(stmt);\n                }\n\n                @Override\n                public void warm(ConfigRegistry config) {\n                    inner.warm(config);\n                }\n            };\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.ExtensionHandler;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.result.RowReducer;\nimport org.jdbi.v3.core.statement.SqlStatement;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\nimport org.jdbi.v3.sqlobject.SqlObjects;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizer;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizingAnnotation;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\nimport org.jdbi.v3.sqlobject.statement.ParameterCustomizerFactory;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.sqlobject.statement.UseRowReducer;\n\nimport static java.util.stream.Stream.concat;\n\n/**\n * Base handler for annotations' implementation classes.\n */\nabstract class CustomizingStatementHandler<StatementType extends SqlStatement<StatementType>> implements ExtensionHandler {\n\n    private final List<BoundCustomizer> statementCustomizers;\n    private final Class<?> sqlObjectType;\n    private final Method method;\n\n    CustomizingStatementHandler(Class<?> type, Method method) {\n        this.sqlObjectType = type;\n        this.method = method;\n        this.statementCustomizers = new ArrayList<>();\n\n        // type customizers, including annotations on the interface's supertypes\n        concat(JdbiClassUtils.superTypes(type), Stream.of(type))\n                .flatMap(CustomizingStatementHandler::annotationsFor)\n                .map(a -> instantiateFactory(a).createForType(a, type))\n                .map(BoundCustomizer::of)\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n\n        // method customizers\n        annotationsFor(method)\n                .map(a -> instantiateFactory(a).createForMethod(a, type, method))\n                .map(BoundCustomizer::of)\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n\n        // parameter customizers\n        parameterCustomizers()\n                .collect(Collectors.toCollection(() -> statementCustomizers));\n    }\n\n    @Override\n    public void warm(ConfigRegistry config) {\n        statementCustomizers.forEach(s -> s.warm(config));\n    }\n\n    private static Stream<Annotation> annotationsFor(AnnotatedElement... elements) {\n        return Stream.of(elements)\n                .map(AnnotatedElement::getAnnotations)\n                .flatMap(Stream::of)\n                .filter(a -> a.annotationType().isAnnotationPresent(SqlStatementCustomizingAnnotation.class));\n    }\n\n    private Stream<BoundCustomizer> parameterCustomizers() {\n        final Parameter[] parameters = method.getParameters();\n\n        return IntStream.range(0, parameters.length)\n                .boxed()\n                .flatMap(i -> eachParameterCustomizers(parameters[i], i));\n    }\n\n    private Stream<BoundCustomizer> eachParameterCustomizers(Parameter parameter, Integer i) {\n        final Type parameterType = getParameterType(parameter);\n        List<BoundCustomizer> customizers = annotationsFor(parameter)\n                .map(a -> instantiateFactory(a).createForParameter(a, sqlObjectType, method, parameter, i, parameterType))\n                .<BoundCustomizer>map(c -> new BoundCustomizer() {\n                    @Override\n                    public void warm(ConfigRegistry config) {\n                        c.warm(config);\n                    }\n\n                    @Override\n                    public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                        c.apply(stmt, args[i]);\n                    }\n                })\n                .collect(Collectors.toList());\n\n        if (!customizers.isEmpty()) {\n            return customizers.stream();\n        }\n\n        if (parameter.getType() == Consumer.class) {\n            if (method.getReturnType() != Void.TYPE) {\n                throw new IllegalStateException(\n                        \"SQL Object methods with a Consumer parameter must have void return type.\");\n            }\n            return Stream.empty();\n        }\n        if (parameter.getType() == Function.class && this instanceof SqlCallHandler) {\n            return Stream.empty();\n        }\n\n        return Stream.of(defaultParameterCustomizer(parameter, i));\n    }\n\n    /**\n     * Default parameter customizer for parameters with no annotations.\n     */\n    private BoundCustomizer defaultParameterCustomizer(Parameter parameter, Integer i) {\n        final Type parameterType = getParameterType(parameter);\n        return new BoundCustomizer() {\n            @Override\n            public void warm(ConfigRegistry config) {\n                create(config).warm(config);\n            }\n\n            @Override\n            public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                create(stmt.getConfig()).apply(stmt, args[i]);\n            }\n\n            private SqlStatementParameterCustomizer create(ConfigRegistry config) {\n                return getDefaultParameterCustomizerFactory(config)\n                        .createForParameter(sqlObjectType, method, parameter, i, parameterType);\n            }\n        };\n    }\n\n    Type getParameterType(Parameter parameter) {\n        return GenericTypes.resolveType(parameter.getParameterizedType(), sqlObjectType);\n    }\n\n    private static ParameterCustomizerFactory getDefaultParameterCustomizerFactory(ConfigRegistry config) {\n        return config.get(SqlObjects.class).getDefaultParameterCustomizerFactory();\n    }\n\n    private static SqlStatementCustomizerFactory instantiateFactory(Annotation annotation) {\n        SqlStatementCustomizingAnnotation sqlStatementCustomizingAnnotation = annotation.annotationType()\n                .getAnnotation(SqlStatementCustomizingAnnotation.class);\n        try {\n            return sqlStatementCustomizingAnnotation.value().getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new IllegalStateException(\"Unable to instantiate sql statement customizer factory class \" + sqlStatementCustomizingAnnotation.value(), e);\n        }\n    }\n\n    @Override\n    public Object invoke(HandleSupplier handleSupplier, Object target, Object... args) {\n        final Handle h = handleSupplier.getHandle();\n        final String locatedSql = locateSql(h);\n        final StatementType stmt = createStatement(h, locatedSql);\n\n        // clean the statement when the handle closes\n        stmt.attachToHandleForCleanup();\n\n        final SqlObjectStatementConfiguration cfg = stmt.getConfig(SqlObjectStatementConfiguration.class);\n        cfg.setArgs(args);\n        configureReturner(stmt, cfg);\n        applyCustomizers(stmt, JdbiClassUtils.safeVarargs(args));\n        return cfg.getReturner().get();\n    }\n\n    void applyCustomizers(final StatementType stmt, Object[] args) {\n        statementCustomizers.forEach(b -> {\n            try {\n                b.apply(stmt, args);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, stmt.getContext());\n            }\n        });\n    }\n\n    abstract void configureReturner(StatementType stmt, SqlObjectStatementConfiguration cfg);\n\n    abstract StatementType createStatement(Handle handle, String locatedSql);\n\n    String locateSql(final Handle h) {\n        return h.getConfig(SqlObjects.class).getSqlLocator().locate(sqlObjectType, method, h.getConfig());\n    }\n\n    Method getMethod() {\n        return method;\n    }\n\n    static RowMapper<?> rowMapperFor(UseRowMapper annotation) {\n        Class<? extends RowMapper<?>> mapperClass = annotation.value();\n        try {\n            return mapperClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new UnableToCreateStatementException(\"Could not create mapper \" + mapperClass.getName(), e, null);\n        }\n    }\n\n    static RowReducer<?, ?> rowReducerFor(UseRowReducer annotation) {\n        Class<? extends RowReducer<?, ?>> reducerClass = annotation.value();\n        try {\n            return reducerClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException | SecurityException e) {\n            throw new UnableToCreateStatementException(\"Could not create reducer \" + reducerClass.getName(), e, null);\n        }\n    }\n\n    /**\n     * A {@link SqlStatementCustomizer} or {@link SqlStatementParameterCustomizer} that\n     * is ready to apply.\n     */\n    private interface BoundCustomizer {\n        void apply(SqlStatement<?> stmt, Object[] args) throws SQLException;\n        void warm(ConfigRegistry config);\n\n        static BoundCustomizer of(SqlStatementCustomizer inner) {\n            return new BoundCustomizer() {\n                @Override\n                public void apply(SqlStatement<?> stmt, Object[] args) throws SQLException {\n                    inner.apply(stmt);\n                }\n\n                @Override\n                public void warm(ConfigRegistry config) {\n                    inner.warm(config);\n                }\n            };\n        }\n    }\n}\n","lineNo":143}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper;\n\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.JdbiConfig;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.interceptor.JdbiInterceptionChainHolder;\nimport org.jdbi.v3.core.internal.CopyOnWriteHashMap;\nimport org.jdbi.v3.core.internal.JdbiOptionals;\nimport org.jdbi.v3.core.mapper.reflect.internal.PojoMapperFactory;\nimport org.jdbi.v3.core.statement.Query;\nimport org.jdbi.v3.meta.Alpha;\n\n/**\n * Configuration registry for {@link RowMapperFactory} instances.\n */\npublic class RowMappers implements JdbiConfig<RowMappers> {\n\n    private final JdbiInterceptionChainHolder<RowMapper<?>, RowMapperFactory> inferenceInterceptors;\n\n    private final List<RowMapperFactory> factories;\n    private final Map<Type, Optional<RowMapper<?>>> cache;\n\n    private ConfigRegistry registry;\n\n    public RowMappers() {\n        inferenceInterceptors = new JdbiInterceptionChainHolder<>(InferredRowMapperFactory::new);\n        factories = new CopyOnWriteArrayList<>();\n        cache = new CopyOnWriteHashMap<>();\n        register(MapEntryMapper.factory());\n        register(new PojoMapperFactory());\n    }\n\n    private RowMappers(RowMappers that) {\n        factories = new CopyOnWriteArrayList<>(that.factories);\n        cache = new CopyOnWriteHashMap<>(that.cache);\n        inferenceInterceptors = new JdbiInterceptionChainHolder<>(that.inferenceInterceptors);\n    }\n\n    @Override\n    public void setRegistry(ConfigRegistry registry) {\n        this.registry = registry;\n    }\n\n    /**\n     * Returns the {@link JdbiInterceptionChainHolder} for the RowMapper inference. This chain allows registration of custom interceptors to change the standard type\n     * inference for the {@link RowMappers#register(RowMapper)} method.\n     */\n    @Alpha\n    public JdbiInterceptionChainHolder<RowMapper<?>, RowMapperFactory> getInferenceInterceptors() {\n        return inferenceInterceptors;\n    }\n\n    /**\n     * Register a row mapper which will have its parameterized type inspected to determine what it maps to.\n     * Will be used with {@link Query#mapTo(Class)} for registered mappings.\n     * <p>\n     * The parameter must be concretely parameterized, we use the type argument T to\n     * determine if it applies to a given type.\n     * <p>\n     * {@link java.lang.Object} is not supported as a concrete parameter type.\n     *\n     * @param mapper the row mapper\n     * @return this\n     * @throws UnsupportedOperationException if the RowMapper is not a concretely parameterized type\n     */\n    public RowMappers register(RowMapper<?> mapper) {\n        RowMapperFactory factory = inferenceInterceptors.process(mapper);\n\n        return this.register(factory);\n    }\n\n    /**\n     * Register a row mapper for a given type.\n     *\n     * @param <T> the type\n     * @param type the type to match with equals.\n     * @param mapper the row mapper\n     * @return this\n     */\n    public <T> RowMappers register(GenericType<T> type, RowMapper<T> mapper) {\n        return this.register(RowMapperFactory.of(type.getType(), mapper));\n    }\n\n    /**\n     * Register a row mapper for a given type.\n     *\n     * @param type the type to match with equals.\n     * @param mapper the row mapper\n     * @return this\n     */\n    public RowMappers register(Type type, RowMapper<?> mapper) {\n        return this.register(RowMapperFactory.of(type, mapper));\n    }\n\n    /**\n     * Register a row mapper factory.\n     * <p>\n     * Will be used with {@link Query#mapTo(Class)} for registered mappings.\n     *\n     * @param factory the row mapper factory\n     * @return this\n     */\n    public RowMappers register(RowMapperFactory factory) {\n        factories.add(0, factory);\n        cache.clear();\n        return this;\n    }\n\n    /**\n     * Obtain a row mapper for the given type in the given context.\n     *\n     * @param <T> the type of the mapper to find\n     * @param type the target type to map to\n     * @return a RowMapper for the given type, or empty if no row mapper is registered for the given type.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> Optional<RowMapper<T>> findFor(Class<T> type) {\n        RowMapper<T> mapper = (RowMapper<T>) findFor((Type) type).orElse(null);\n        return Optional.ofNullable(mapper);\n    }\n\n    /**\n     * Obtain a row mapper for the given type in the given context.\n     *\n     * @param <T> the type of the mapper to find\n     * @param type the target type to map to\n     * @return a RowMapper for the given type, or empty if no row mapper is registered for the given type.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> Optional<RowMapper<T>> findFor(GenericType<T> type) {\n        RowMapper<T> mapper = (RowMapper<T>) findFor(type.getType()).orElse(null);\n        return Optional.ofNullable(mapper);\n    }\n\n    /**\n     * Obtain a row mapper for the given type in the given context.\n     *\n     * @param type the target type to map to\n     * @return a RowMapper for the given type, or empty if no row mapper is registered for the given type.\n     */\n    public Optional<RowMapper<?>> findFor(Type type) {\n        // ConcurrentHashMap can enter an infinite loop on nested computeIfAbsent calls.\n        // Since row mappers can decorate other row mappers, we have to populate the cache the old fashioned way.\n        // See https://bugs.openjdk.java.net/browse/JDK-8062841, https://bugs.openjdk.java.net/browse/JDK-8142175\n        Optional<RowMapper<?>> cached = cache.get(type);\n\n        if (cached != null) {\n            return cached;\n        }\n\n        Optional<RowMapper<?>> mapper = factories.stream()\n                .flatMap(factory -> JdbiOptionals.stream(factory.build(type, registry)))\n                .findFirst();\n\n        mapper.ifPresent(m -> m.init(registry));\n\n        cache.put(type, mapper);\n\n        return mapper;\n    }\n\n    @Override\n    public RowMappers createCopy() {\n        return new RowMappers(this);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper;\n\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.JdbiConfig;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.interceptor.JdbiInterceptionChainHolder;\nimport org.jdbi.v3.core.internal.CopyOnWriteHashMap;\nimport org.jdbi.v3.core.mapper.reflect.internal.PojoMapperFactory;\nimport org.jdbi.v3.core.statement.Query;\nimport org.jdbi.v3.meta.Alpha;\n\n/**\n * Configuration registry for {@link RowMapperFactory} instances.\n */\npublic class RowMappers implements JdbiConfig<RowMappers> {\n\n    private final JdbiInterceptionChainHolder<RowMapper<?>, RowMapperFactory> inferenceInterceptors;\n\n    private final List<RowMapperFactory> factories;\n    private final Map<Type, Optional<RowMapper<?>>> cache;\n\n    private ConfigRegistry registry;\n\n    public RowMappers() {\n        inferenceInterceptors = new JdbiInterceptionChainHolder<>(InferredRowMapperFactory::new);\n        factories = new CopyOnWriteArrayList<>();\n        cache = new CopyOnWriteHashMap<>();\n        register(MapEntryMapper.factory());\n        register(new PojoMapperFactory());\n    }\n\n    private RowMappers(RowMappers that) {\n        factories = new CopyOnWriteArrayList<>(that.factories);\n        cache = new CopyOnWriteHashMap<>(that.cache);\n        inferenceInterceptors = new JdbiInterceptionChainHolder<>(that.inferenceInterceptors);\n    }\n\n    @Override\n    public void setRegistry(ConfigRegistry registry) {\n        this.registry = registry;\n    }\n\n    /**\n     * Returns the {@link JdbiInterceptionChainHolder} for the RowMapper inference. This chain allows registration of custom interceptors to change the standard type\n     * inference for the {@link RowMappers#register(RowMapper)} method.\n     */\n    @Alpha\n    public JdbiInterceptionChainHolder<RowMapper<?>, RowMapperFactory> getInferenceInterceptors() {\n        return inferenceInterceptors;\n    }\n\n    /**\n     * Register a row mapper which will have its parameterized type inspected to determine what it maps to.\n     * Will be used with {@link Query#mapTo(Class)} for registered mappings.\n     * <p>\n     * The parameter must be concretely parameterized, we use the type argument T to\n     * determine if it applies to a given type.\n     * <p>\n     * {@link java.lang.Object} is not supported as a concrete parameter type.\n     *\n     * @param mapper the row mapper\n     * @return this\n     * @throws UnsupportedOperationException if the RowMapper is not a concretely parameterized type\n     */\n    public RowMappers register(RowMapper<?> mapper) {\n        RowMapperFactory factory = inferenceInterceptors.process(mapper);\n\n        return this.register(factory);\n    }\n\n    /**\n     * Register a row mapper for a given type.\n     *\n     * @param <T> the type\n     * @param type the type to match with equals.\n     * @param mapper the row mapper\n     * @return this\n     */\n    public <T> RowMappers register(GenericType<T> type, RowMapper<T> mapper) {\n        return this.register(RowMapperFactory.of(type.getType(), mapper));\n    }\n\n    /**\n     * Register a row mapper for a given type.\n     *\n     * @param type the type to match with equals.\n     * @param mapper the row mapper\n     * @return this\n     */\n    public RowMappers register(Type type, RowMapper<?> mapper) {\n        return this.register(RowMapperFactory.of(type, mapper));\n    }\n\n    /**\n     * Register a row mapper factory.\n     * <p>\n     * Will be used with {@link Query#mapTo(Class)} for registered mappings.\n     *\n     * @param factory the row mapper factory\n     * @return this\n     */\n    public RowMappers register(RowMapperFactory factory) {\n        factories.add(0, factory);\n        cache.clear();\n        return this;\n    }\n\n    /**\n     * Obtain a row mapper for the given type in the given context.\n     *\n     * @param <T> the type of the mapper to find\n     * @param type the target type to map to\n     * @return a RowMapper for the given type, or empty if no row mapper is registered for the given type.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> Optional<RowMapper<T>> findFor(Class<T> type) {\n        RowMapper<T> mapper = (RowMapper<T>) findFor((Type) type).orElse(null);\n        return Optional.ofNullable(mapper);\n    }\n\n    /**\n     * Obtain a row mapper for the given type in the given context.\n     *\n     * @param <T> the type of the mapper to find\n     * @param type the target type to map to\n     * @return a RowMapper for the given type, or empty if no row mapper is registered for the given type.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> Optional<RowMapper<T>> findFor(GenericType<T> type) {\n        RowMapper<T> mapper = (RowMapper<T>) findFor(type.getType()).orElse(null);\n        return Optional.ofNullable(mapper);\n    }\n\n    /**\n     * Obtain a row mapper for the given type in the given context.\n     *\n     * @param type the target type to map to\n     * @return a RowMapper for the given type, or empty if no row mapper is registered for the given type.\n     */\n    public Optional<RowMapper<?>> findFor(Type type) {\n        // ConcurrentHashMap can enter an infinite loop on nested computeIfAbsent calls.\n        // Since row mappers can decorate other row mappers, we have to populate the cache the old fashioned way.\n        // See https://bugs.openjdk.java.net/browse/JDK-8062841, https://bugs.openjdk.java.net/browse/JDK-8142175\n        Optional<RowMapper<?>> cached = cache.get(type);\n\n        if (cached != null) {\n            return cached;\n        }\n\n        for (RowMapperFactory factory : factories) {\n            Optional<RowMapper<?>> maybeMapper = factory.build(type, registry);\n            RowMapper<?> mapper = maybeMapper.orElse(null);\n            if (mapper != null) {\n                mapper.init(registry);\n                cache.put(type, maybeMapper);\n                return maybeMapper;\n            }\n        }\n\n        cache.put(type, Optional.empty());\n        return Optional.empty();\n    }\n\n    @Override\n    public RowMappers createCopy() {\n        return new RowMappers(this);\n    }\n}\n","lineNo":170}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.extension;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.ExtensionHandler.ExtensionHandlerFactory;\nimport org.jdbi.v3.core.extension.ExtensionMetadata.Builder;\nimport org.jdbi.v3.core.extension.ExtensionMetadata.ExtensionHandlerInvoker;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\n\nimport static java.lang.String.format;\n\nimport static org.jdbi.v3.core.extension.ExtensionFactory.FactoryFlag.CLASSES_ARE_SUPPORTED;\nimport static org.jdbi.v3.core.extension.ExtensionFactory.FactoryFlag.VIRTUAL_FACTORY;\nimport static org.jdbi.v3.core.extension.ExtensionHandler.EQUALS_HANDLER;\nimport static org.jdbi.v3.core.extension.ExtensionHandler.HASHCODE_HANDLER;\nimport static org.jdbi.v3.core.extension.ExtensionHandler.NULL_HANDLER;\n\nfinal class ExtensionFactoryDelegate implements ExtensionFactory {\n\n    private final ExtensionFactory delegatedFactory;\n\n    ExtensionFactoryDelegate(ExtensionFactory delegatedFactory) {\n        this.delegatedFactory = delegatedFactory;\n    }\n\n    @Override\n    public boolean accepts(Class<?> extensionType) {\n        return delegatedFactory.accepts(extensionType);\n    }\n\n    ExtensionFactory getDelegatedFactory() {\n        return delegatedFactory;\n    }\n\n    @Override\n    public Collection<ExtensionHandlerFactory> getExtensionHandlerFactories(ConfigRegistry config) {\n        return delegatedFactory.getExtensionHandlerFactories(config);\n    }\n\n    @Override\n    public Collection<ExtensionHandlerCustomizer> getExtensionHandlerCustomizers(ConfigRegistry config) {\n        return delegatedFactory.getExtensionHandlerCustomizers(config);\n    }\n\n    @Override\n    public Collection<ConfigCustomizerFactory> getConfigCustomizerFactories(ConfigRegistry config) {\n        return delegatedFactory.getConfigCustomizerFactories(config);\n    }\n\n    @Override\n    public void buildExtensionInitData(Builder builder) {\n        delegatedFactory.buildExtensionInitData(builder);\n    }\n\n    @Override\n    public Set<FactoryFlag> getFactoryFlags() {\n        return delegatedFactory.getFactoryFlags();\n    }\n\n    @Override\n    public <E> E attach(Class<E> extensionType, HandleSupplier handleSupplier) {\n\n        Set<FactoryFlag> factoryFlags = getFactoryFlags();\n\n        // If the extension declares that it supports classes, then the proxy logic\n        // in the delegate is bypassed. This code uses the Java proxy class which does not\n        // work for Classes (when extending a class, the assumption is that the returned\n        // object can be cast to the class itself, something that can not be done with a\n        // java proxy object).\n        //\n        // The extension factory is now responsible for managing the method invocations itself.\n        //\n        if (factoryFlags.contains(CLASSES_ARE_SUPPORTED)) {\n            return delegatedFactory.attach(extensionType, handleSupplier);\n        }\n\n        if (extensionType == null || !extensionType.isInterface()) {\n            throw new IllegalArgumentException(format(\"Can not attach %s as an extension with %s\",\n                    extensionType, delegatedFactory.getClass().getSimpleName()));\n        }\n\n        final ConfigRegistry config = handleSupplier.getConfig();\n        final Extensions extensions = config.get(Extensions.class);\n\n        extensions.onCreateProxy();\n\n        final ExtensionMetadata extensionMetaData = extensions.findMetadata(extensionType, config, delegatedFactory);\n        final ConfigRegistry instanceConfig = extensionMetaData.createInstanceConfiguration(config);\n\n        Map<Method, ExtensionHandlerInvoker> handlers = new HashMap<>();\n        final Object proxy = Proxy.newProxyInstance(\n                extensionType.getClassLoader(),\n                new Class[] {extensionType},\n                (proxyInstance, method, args) -> handlers.get(method).invoke(args));\n\n        // if the object created by the delegated factory has actual methods (it is not delegating), attach the\n        // delegate and pass it to the handlers. Otherwise assume that there is no backing object and do not call\n        // attach.\n        final Object delegatedInstance = factoryFlags.contains(VIRTUAL_FACTORY) ? proxy : delegatedFactory.attach(extensionType, handleSupplier);\n\n        // add proxy specific methods (toString, equals, hashCode, finalize)\n        // those will only be added if they don't already exist in the method handler map.\n\n        // If these methods are added, they are special because they operate on the proxy object itself, not the underlying object\n        checkMethodPresent(extensionType, Object.class, \"toString\").ifPresent(method -> {\n            ExtensionHandler toStringHandler = (h, target, args) ->\n                    \"Jdbi extension proxy for \" + extensionType.getName() + \"@\" + Integer.toHexString(proxy.hashCode());\n            handlers.put(method, extensionMetaData.new ExtensionHandlerInvoker(proxy, method, toStringHandler, handleSupplier, instanceConfig));\n        });\n\n        checkMethodPresent(extensionType, Object.class, \"equals\", Object.class).ifPresent(method -> handlers.put(method,\n                extensionMetaData.new ExtensionHandlerInvoker(proxy, method, EQUALS_HANDLER, handleSupplier, instanceConfig)));\n        checkMethodPresent(extensionType, Object.class, \"hashCode\").ifPresent(method -> handlers.put(method,\n                extensionMetaData.new ExtensionHandlerInvoker(proxy, method, HASHCODE_HANDLER, handleSupplier, instanceConfig)));\n\n        // add all methods that are delegated to the underlying object / existing handlers\n        extensionMetaData.getExtensionMethods().forEach(method ->\n                handlers.put(method, extensionMetaData.createExtensionHandlerInvoker(delegatedInstance, method, handleSupplier, instanceConfig)));\n\n        // finalize is double special. Add this unconditionally, even if subclasses try to override it.\n        JdbiClassUtils.safeMethodLookup(extensionType, \"finalize\").ifPresent(method -> handlers.put(method,\n                extensionMetaData.new ExtensionHandlerInvoker(proxy, method, NULL_HANDLER, handleSupplier, instanceConfig)));\n\n\n        return extensionType.cast(proxy);\n    }\n\n    /** returns Optional.empty() if the method exists in the extension type, otherwise a fallback method. */\n    private Optional<Method> checkMethodPresent(Class<?> extensionType, Class<?> klass, String methodName, Class<?>... parameterTypes) {\n        Optional<Method> method = JdbiClassUtils.safeMethodLookup(extensionType, methodName, parameterTypes);\n        if (method.isPresent()) {\n            // does the method actually exist in the type itself (e.g. overridden by the implementation class?)\n            // if yes, return absent, so the default hander is not added.\n            return Optional.empty();\n        } else {\n            return JdbiClassUtils.safeMethodLookup(klass, methodName, parameterTypes);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"ExtensionFactoryDelegate for \" + delegatedFactory.toString();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.extension;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.ExtensionMetadata.Builder;\nimport org.jdbi.v3.core.extension.ExtensionMetadata.ExtensionHandlerInvoker;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\n\nimport static java.lang.String.format;\n\nimport static org.jdbi.v3.core.extension.ExtensionFactory.FactoryFlag.DONT_USE_PROXY;\nimport static org.jdbi.v3.core.extension.ExtensionFactory.FactoryFlag.NON_VIRTUAL_FACTORY;\nimport static org.jdbi.v3.core.extension.ExtensionHandler.EQUALS_HANDLER;\nimport static org.jdbi.v3.core.extension.ExtensionHandler.HASHCODE_HANDLER;\nimport static org.jdbi.v3.core.extension.ExtensionHandler.NULL_HANDLER;\n\nfinal class ExtensionFactoryDelegate implements ExtensionFactory {\n\n    private final ExtensionFactory delegatedFactory;\n\n    ExtensionFactoryDelegate(ExtensionFactory delegatedFactory) {\n        this.delegatedFactory = delegatedFactory;\n    }\n\n    @Override\n    public boolean accepts(Class<?> extensionType) {\n        return delegatedFactory.accepts(extensionType);\n    }\n\n    ExtensionFactory getDelegatedFactory() {\n        return delegatedFactory;\n    }\n\n    @Override\n    public Collection<ExtensionHandlerFactory> getExtensionHandlerFactories(ConfigRegistry config) {\n        return Collections.unmodifiableCollection(delegatedFactory.getExtensionHandlerFactories(config).stream()\n                .map(FilteringExtensionHandlerFactory::forDelegate)\n                .collect(Collectors.toList()));\n    }\n\n    @Override\n    public Collection<ExtensionHandlerCustomizer> getExtensionHandlerCustomizers(ConfigRegistry config) {\n        return delegatedFactory.getExtensionHandlerCustomizers(config);\n    }\n\n    @Override\n    public Collection<ConfigCustomizerFactory> getConfigCustomizerFactories(ConfigRegistry config) {\n        return delegatedFactory.getConfigCustomizerFactories(config);\n    }\n\n    @Override\n    public void buildExtensionMetadata(Builder builder) {\n        delegatedFactory.buildExtensionMetadata(builder);\n    }\n\n    @Override\n    public Set<FactoryFlag> getFactoryFlags() {\n        return delegatedFactory.getFactoryFlags();\n    }\n\n    @Override\n    public <E> E attach(Class<E> extensionType, HandleSupplier handleSupplier) {\n\n        Set<FactoryFlag> factoryFlags = getFactoryFlags();\n\n        // If the extension declares that it supports classes, then the proxy logic\n        // in the delegate is bypassed. This code uses the Java proxy class which does not\n        // work for Classes (when extending a class, the assumption is that the returned\n        // object can be cast to the class itself, something that can not be done with a\n        // java proxy object).\n        //\n        // The extension factory is now responsible for managing the method invocations itself.\n        //\n        if (factoryFlags.contains(DONT_USE_PROXY)) {\n            return delegatedFactory.attach(extensionType, handleSupplier);\n        }\n\n        if (extensionType == null || !extensionType.isInterface()) {\n            throw new IllegalArgumentException(format(\"Can not attach %s as an extension with %s\",\n                    extensionType, delegatedFactory.getClass().getSimpleName()));\n        }\n\n        final ConfigRegistry config = handleSupplier.getConfig();\n        final Extensions extensions = config.get(Extensions.class);\n\n        extensions.onCreateProxy();\n\n        final ExtensionMetadata extensionMetaData = extensions.findMetadata(extensionType, delegatedFactory);\n        final ConfigRegistry instanceConfig = extensionMetaData.createInstanceConfiguration(config);\n\n        Map<Method, ExtensionHandlerInvoker> handlers = new HashMap<>();\n        final Object proxy = Proxy.newProxyInstance(\n                extensionType.getClassLoader(),\n                new Class[] {extensionType},\n                (proxyInstance, method, args) -> handlers.get(method).invoke(args));\n\n        // if the object created by the delegated factory has actual methods (it is not delegating), attach the\n        // delegate and pass it to the handlers. Otherwise assume that there is no backing object and do not call\n        // attach.\n        final Object delegatedInstance = factoryFlags.contains(NON_VIRTUAL_FACTORY) ? delegatedFactory.attach(extensionType, handleSupplier) : proxy;\n\n        // add proxy specific methods (toString, equals, hashCode, finalize)\n        // those will only be added if they don't already exist in the method handler map.\n\n        // If these methods are added, they are special because they operate on the proxy object itself, not the underlying object\n        checkMethodPresent(extensionType, Object.class, \"toString\").ifPresent(method -> {\n            ExtensionHandler toStringHandler = (h, target, args) ->\n                    \"Jdbi extension proxy for \" + extensionType.getName() + \"@\" + Integer.toHexString(proxy.hashCode());\n            handlers.put(method, extensionMetaData.new ExtensionHandlerInvoker(proxy, method, toStringHandler, handleSupplier, instanceConfig));\n        });\n\n        checkMethodPresent(extensionType, Object.class, \"equals\", Object.class).ifPresent(method -> handlers.put(method,\n                extensionMetaData.new ExtensionHandlerInvoker(proxy, method, EQUALS_HANDLER, handleSupplier, instanceConfig)));\n        checkMethodPresent(extensionType, Object.class, \"hashCode\").ifPresent(method -> handlers.put(method,\n                extensionMetaData.new ExtensionHandlerInvoker(proxy, method, HASHCODE_HANDLER, handleSupplier, instanceConfig)));\n\n        // add all methods that are delegated to the underlying object / existing handlers\n        extensionMetaData.getExtensionMethods().forEach(method ->\n                handlers.put(method, extensionMetaData.createExtensionHandlerInvoker(delegatedInstance, method, handleSupplier, instanceConfig)));\n\n        // finalize is double special. Add this unconditionally, even if subclasses try to override it.\n        JdbiClassUtils.safeMethodLookup(extensionType, \"finalize\").ifPresent(method -> handlers.put(method,\n                extensionMetaData.new ExtensionHandlerInvoker(proxy, method, NULL_HANDLER, handleSupplier, instanceConfig)));\n\n\n        return extensionType.cast(proxy);\n    }\n\n    /** returns Optional.empty() if the method exists in the extension type, otherwise a fallback method. */\n    private Optional<Method> checkMethodPresent(Class<?> extensionType, Class<?> klass, String methodName, Class<?>... parameterTypes) {\n        Optional<Method> method = JdbiClassUtils.safeMethodLookup(extensionType, methodName, parameterTypes);\n        if (method.isPresent()) {\n            // does the method actually exist in the type itself (e.g. overridden by the implementation class?)\n            // if yes, return absent, so the default hander is not added.\n            return Optional.empty();\n        } else {\n            return JdbiClassUtils.safeMethodLookup(klass, methodName, parameterTypes);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"ExtensionFactoryDelegate for \" + delegatedFactory.toString();\n    }\n}\n","lineNo":122}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.stringtemplate4;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.TemplateEngine;\nimport org.stringtemplate.v4.ST;\nimport org.stringtemplate.v4.STGroup;\n\n/**\n * Rewrites a StringTemplate template, using the attributes on the {@link StatementContext} as template parameters.\n */\npublic class StringTemplateEngine implements TemplateEngine {\n    @Override\n    public String render(String sql, StatementContext ctx) {\n        ST template = new ST(new STGroup(), sql);\n\n        ctx.getAttributes().forEach(template::add);\n\n        return template.render();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.stringtemplate4;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.TemplateEngine;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\nimport org.stringtemplate.v4.ST;\nimport org.stringtemplate.v4.STErrorListener;\nimport org.stringtemplate.v4.STGroup;\nimport org.stringtemplate.v4.misc.STMessage;\n\n/**\n * Rewrites a StringTemplate template, using the attributes on the {@link StatementContext} as template parameters.\n * For configuration, see {@link StringTemplates}.\n */\npublic class StringTemplateEngine implements TemplateEngine {\n    @Override\n    public String render(String sql, StatementContext ctx) {\n        STGroup group = new STGroup();\n        group.setListener(new ErrorListener(ctx));\n        ST template = new ST(group, sql);\n\n        ctx.getAttributes().forEach(template::add);\n\n        return template.render();\n    }\n\n    static class ErrorListener implements STErrorListener {\n        private final StatementContext ctx;\n\n        ErrorListener(StatementContext ctx) {\n            this.ctx = ctx;\n        }\n\n        @Override\n        public void compileTimeError(STMessage msg) {\n            throw new UnableToCreateStatementException(\"Compiling StringTemplate failed: \" + msg, msg.cause, ctx);\n        }\n\n        @Override\n        public void runTimeError(STMessage msg) {\n            switch (msg.error) {\n                case NO_SUCH_PROPERTY:\n                    break;\n                case NO_SUCH_ATTRIBUTE:\n                    if (!ctx.getConfig(StringTemplates.class).isFailOnMissingAttribute()) {\n                        break;\n                    }\n                default:\n                    throw new UnableToExecuteStatementException(\"Executing StringTemplate failed: \" + msg, msg.cause, ctx);\n            }\n        }\n\n        @Override\n        public void IOError(STMessage msg) {\n            runTimeError(msg);\n        }\n\n        @Override\n        public void internalError(STMessage msg) {\n            runTimeError(msg);\n        }\n    }\n}\n","lineNo":32}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.io.Closeable;\nimport java.sql.SQLException;\nimport java.util.Collection;\n\nimport org.jdbi.v3.core.CloseException;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.meta.Alpha;\n\nabstract class BaseStatement<This> implements Closeable, Configurable<This> {\n    @SuppressWarnings(\"unchecked\")\n    final This typedThis = (This) this;\n\n    private final Handle handle;\n    private final StatementContext ctx;\n\n    BaseStatement(Handle handle) {\n        this.handle = handle;\n        this.ctx = StatementContext.create(handle.getConfig().createCopy(), handle.getExtensionMethod());\n    }\n\n    public final Handle getHandle() {\n        return handle;\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return ctx.getConfig();\n    }\n\n    /**\n     * Returns the statement context associated with this statement.\n     *\n     * @return the statement context associated with this statement.\n     */\n    public final StatementContext getContext() {\n        return ctx;\n    }\n\n    /**\n     * Registers with the handle for cleaning when the handle is closed.\n     * <br>\n     * There are some situations where Statements need to be cleaned up to avoid resource leaks. This method registers the current Statement it with the\n     * Handle. If the statement or the context are cleaned by themselves, it will automatically unregister, so in normal operations, resources should not pool for cleanup with the Handle.\n     * <br>\n     *\n     * @since 3.35.0\n     */\n    @Alpha\n    public final This attachToHandleForCleanup() {\n        attachToHandleForCleanup(this.handle, this.ctx);\n\n        return typedThis;\n    }\n\n    private static void attachToHandleForCleanup(Handle handle, StatementContext context) {\n        final Cleanable statementCleanable = context::close;\n        // make handle clean up this context if necessary\n        handle.addCleanable(statementCleanable);\n        // if context gets cleaned, remove the cleanable from the handle again.\n        context.addCleanable(() -> handle.removeCleanable(statementCleanable));\n    }\n\n    protected final void cleanUpForException(SQLException e) {\n        try {\n            close();\n        } catch (CloseException ce) {\n            e.addSuppressed(ce.getCause());\n        } catch (Exception e1) {\n            e.addSuppressed(e1);\n        }\n    }\n\n    void addCustomizers(final Collection<StatementCustomizer> customizers) {\n        customizers.forEach(this::addCustomizer);\n    }\n\n    final void callCustomizers(StatementCustomizerInvocation invocation) {\n        for (StatementCustomizer customizer : getCustomizers()) {\n            try {\n                invocation.call(customizer);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e, ctx);\n            }\n        }\n    }\n\n    private Collection<StatementCustomizer> getCustomizers() {\n        return this.getConfig(SqlStatements.class).getCustomizers();\n    }\n\n    @Override\n    public void close() {\n        getContext().close();\n    }\n\n    @Override\n    public final boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public final int hashCode() {\n        return super.hashCode() * 11;\n    }\n\n    @FunctionalInterface\n    interface StatementCustomizerInvocation {\n        void call(StatementCustomizer t) throws SQLException;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.io.Closeable;\nimport java.sql.SQLException;\nimport java.util.Collection;\n\nimport org.jdbi.v3.core.CloseException;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.meta.Alpha;\n\nabstract class BaseStatement<This> implements Closeable, Configurable<This> {\n    @SuppressWarnings(\"unchecked\")\n    final This typedThis = (This) this;\n\n    private final Handle handle;\n    private final StatementContext ctx;\n\n    BaseStatement(Handle handle) {\n        this.handle = handle;\n        final ConfigRegistry config = handle.getConfig().createCopy();\n        this.ctx = StatementContext.create(config, handle.getExtensionMethod());\n\n        if (config.get(SqlStatements.class).isAttachAllStatementsForCleanup()) {\n            attachToHandleForCleanup(this.handle, this.ctx);\n        }\n    }\n\n    public final Handle getHandle() {\n        return handle;\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return ctx.getConfig();\n    }\n\n    /**\n     * Returns the statement context associated with this statement.\n     *\n     * @return the statement context associated with this statement.\n     */\n    public final StatementContext getContext() {\n        return ctx;\n    }\n\n    /**\n     * Registers with the handle for cleaning when the handle is closed.\n     * <br>\n     * There are some situations where Statements need to be cleaned up to avoid resource leaks. This method registers the current Statement it with the\n     * Handle. If the statement or the context are cleaned by themselves, it will automatically unregister, so in normal operations, resources should not pool for cleanup with the Handle.\n     * <br>\n     *\n     * @since 3.35.0\n     */\n    @Alpha\n    public final This attachToHandleForCleanup() {\n        attachToHandleForCleanup(this.handle, this.ctx);\n\n        return typedThis;\n    }\n\n    private static void attachToHandleForCleanup(Handle handle, StatementContext context) {\n        final Cleanable statementCleanable = context::close;\n        // make handle clean up this context if necessary\n        handle.addCleanable(statementCleanable);\n        // if context gets cleaned, remove the cleanable from the handle again.\n        context.addCleanable(() -> handle.removeCleanable(statementCleanable));\n    }\n\n    protected final void cleanUpForException(SQLException e) {\n        try {\n            close();\n        } catch (CloseException ce) {\n            e.addSuppressed(ce.getCause());\n        } catch (Exception e1) {\n            e.addSuppressed(e1);\n        }\n    }\n\n    void addCustomizers(final Collection<StatementCustomizer> customizers) {\n        customizers.forEach(this::addCustomizer);\n    }\n\n    final void callCustomizers(StatementCustomizerInvocation invocation) {\n        for (StatementCustomizer customizer : getCustomizers()) {\n            try {\n                invocation.call(customizer);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e, ctx);\n            }\n        }\n    }\n\n    private Collection<StatementCustomizer> getCustomizers() {\n        return this.getConfig(SqlStatements.class).getCustomizers();\n    }\n\n    @Override\n    public void close() {\n        getContext().close();\n    }\n\n    @Override\n    public final boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public final int hashCode() {\n        return super.hashCode() * 11;\n    }\n\n    @FunctionalInterface\n    interface StatementCustomizerInvocation {\n        void call(StatementCustomizer t) throws SQLException;\n    }\n}\n","lineNo":35}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.internal.IterableLike;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.SingleValue;\nimport org.jdbi.v3.sqlobject.UnableToCreateSqlObjectException;\nimport org.jdbi.v3.sqlobject.statement.BatchChunkSize;\nimport org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;\nimport org.jdbi.v3.sqlobject.statement.SqlBatch;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.sqlobject.statement.UseRowReducer;\n\npublic class SqlBatchHandler extends CustomizingStatementHandler<PreparedBatch> {\n    private final SqlBatch sqlBatch;\n    private final SqlBatchHandler.ChunkSizeFunction batchChunkSize;\n    private final Function<PreparedBatch, ResultIterator<?>> batchIntermediate;\n    private final ResultReturner magic;\n\n    public SqlBatchHandler(Class<?> sqlObjectType, Method method) {\n        super(sqlObjectType, method);\n\n        if (method.isAnnotationPresent(UseRowReducer.class)) {\n            throw new UnsupportedOperationException(\"Cannot declare @UseRowReducer on a @SqlUpdate method.\");\n        }\n\n        this.sqlBatch = method.getAnnotation(SqlBatch.class);\n        this.batchChunkSize = determineBatchChunkSize(sqlObjectType, method);\n        final GetGeneratedKeys getGeneratedKeys = method.getAnnotation(GetGeneratedKeys.class);\n\n        if (getGeneratedKeys == null) {\n            if (!returnTypeIsValid(method.getReturnType())) {\n                throw new UnableToCreateSqlObjectException(invalidReturnTypeMessage(method));\n            }\n            Function<PreparedBatch, ResultIterator<?>> modCounts = PreparedBatch::executeAndGetModCount;\n            batchIntermediate = method.getReturnType().equals(boolean[].class)\n                    ? mapToBoolean(modCounts)\n                    : modCounts;\n            magic = ResultReturner.forOptionalReturn(sqlObjectType, method);\n        } else {\n            String[] columnNames = getGeneratedKeys.value();\n            magic = ResultReturner.forMethod(sqlObjectType, method);\n\n            if (method.isAnnotationPresent(UseRowMapper.class)) {\n                RowMapper<?> mapper = rowMapperFor(method.getAnnotation(UseRowMapper.class));\n                batchIntermediate = batch -> batch.executeAndReturnGeneratedKeys(columnNames)\n                        .map(mapper)\n                        .iterator();\n            } else {\n                batchIntermediate = batch -> batch.executeAndReturnGeneratedKeys(columnNames)\n                        .mapTo(magic.elementType(batch.getConfig()))\n                        .iterator();\n            }\n        }\n    }\n\n    @Override\n    public void warm(ConfigRegistry config) {\n        super.warm(config);\n        magic.warm(config);\n    }\n\n    private Function<PreparedBatch, ResultIterator<?>> mapToBoolean(Function<PreparedBatch, ResultIterator<?>> modCounts) {\n        return modCounts.andThen(iterator -> new ResultIterator<Boolean>() {\n            @Override\n            public boolean hasNext() {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public Boolean next() {\n                return ((Integer) iterator.next()) > 0;\n            }\n\n            @Override\n            public void close() {\n                iterator.close();\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return iterator.getContext();\n            }\n        });\n    }\n\n    private SqlBatchHandler.ChunkSizeFunction determineBatchChunkSize(Class<?> sqlObjectType, Method method) {\n        // this next big if chain determines the batch chunk size. It looks from most specific\n        // scope to least, that is: as an argument, then on the method, then on the class,\n        // then default to Integer.MAX_VALUE\n\n        int batchChunkSizeParameterIndex = indexOfBatchChunkSizeParameter(method);\n        if (batchChunkSizeParameterIndex >= 0) {\n            return new ParamBasedChunkSizeFunction(batchChunkSizeParameterIndex);\n        } else if (method.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = method.getAnnotation(BatchChunkSize.class).value();\n            if (size <= 0) {\n                throw new IllegalArgumentException(\"Batch chunk size must be >= 0\");\n            }\n            return new ConstantChunkSizeFunction(size);\n        } else if (sqlObjectType.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = sqlObjectType.getAnnotation(BatchChunkSize.class).value();\n            return new ConstantChunkSizeFunction(size);\n        } else {\n            return new ConstantChunkSizeFunction(Integer.MAX_VALUE);\n        }\n    }\n\n    private int indexOfBatchChunkSizeParameter(Method method) {\n        Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n        return IntStream.range(0, parameterAnnotations.length)\n                .filter(i -> Stream.of(parameterAnnotations[i]).anyMatch(BatchChunkSize.class::isInstance))\n                .findFirst()\n                .orElse(-1);\n    }\n\n    @Override\n    PreparedBatch createStatement(Handle handle, String locatedSql) {\n        return handle.prepareBatch(locatedSql);\n    }\n\n    @Override\n    void configureReturner(PreparedBatch stmt, SqlObjectStatementConfiguration cfg) {}\n\n    @Override\n    Type getParameterType(Parameter parameter) {\n        Type type = super.getParameterType(parameter);\n\n        if (!parameter.isAnnotationPresent(SingleValue.class)) {\n            Class<?> erasedType = GenericTypes.getErasedType(type);\n            if (Iterable.class.isAssignableFrom(erasedType)) {\n                return GenericTypes.findGenericParameter(type, Iterable.class).get();\n            } else if (Iterator.class.isAssignableFrom(erasedType)) {\n                return GenericTypes.findGenericParameter(type, Iterator.class).get();\n            } else if (GenericTypes.isArray(type)) {\n                return ((Class<?>) type).getComponentType();\n            }\n        }\n\n        return type;\n    }\n\n    @Override\n    @SuppressWarnings(\"PMD.ExcessiveMethodLength\")\n    public Object invoke(Object target, Object[] args, HandleSupplier handleSupplier) {\n        final Handle handle = handleSupplier.getHandle();\n        final String sql = locateSql(handle);\n        final int chunkSize = batchChunkSize.call(args);\n        final Iterator<Object[]> batchArgs = zipArgs(getMethod(), args);\n\n        final class BatchChunkIterator implements ResultIterator<Object> {\n            private ResultIterator<?> batchResult = null;\n            private boolean closed = false;\n\n            BatchChunkIterator() {\n                if (batchArgs.hasNext()) {\n                    // if arguments are present, preload the next result chunk\n                    batchResult = loadChunk();\n                }\n            }\n\n            private ResultIterator<?> loadChunk() {\n                // execute a single chunk and buffer\n                List<Object[]> currArgs = new ArrayList<>();\n                for (int i = 0; i < chunkSize && batchArgs.hasNext(); i++) {\n                    currArgs.add(batchArgs.next());\n                }\n                Supplier<PreparedBatch> preparedBatchSupplier = () -> createPreparedBatch(handle, sql, currArgs);\n                return executeBatch(handle, preparedBatchSupplier);\n            }\n\n            private PreparedBatch createPreparedBatch(Handle handle, String sql, List<Object[]> currArgs) {\n                PreparedBatch batch = handle.prepareBatch(sql);\n                for (Object[] currArg : currArgs) {\n                    applyCustomizers(batch, currArg);\n                    batch.add();\n                }\n                return batch;\n            }\n\n            @Override\n            public boolean hasNext() {\n                if (closed) {\n                    throw new IllegalStateException(\"closed\");\n                }\n                // first, any elements already buffered?\n                if (batchResult != null) {\n                    if (batchResult.hasNext()) {\n                        return true;\n                    }\n                    // no more in this chunk, release resources\n                    batchResult.close();\n                }\n                // more chunks?\n                if (batchArgs.hasNext()) {\n                    // preload the next result chunk\n                    batchResult = loadChunk();\n\n                    // recurse to ensure we actually got elements\n                    return hasNext();\n                }\n\n                return false;\n            }\n\n            @Override\n            public Object next() {\n                if (closed) {\n                    throw new IllegalStateException(\"closed\");\n                }\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return batchResult.next();\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return batchResult.getContext();\n            }\n\n            @Override\n            public void close() {\n                closed = true;\n                batchResult.close();\n            }\n        }\n\n        ResultIterator<Object> result;\n\n        if (batchArgs.hasNext()) {\n            result = new BatchChunkIterator();\n        } else {\n            // only created to get access to the context.\n            PreparedBatch dummy = handle.prepareBatch(sql);\n            result = new ResultIterator<Object>() {\n                @Override\n                public void close() {\n                    // no op\n                }\n\n                @Override\n                public StatementContext getContext() {\n                    return dummy.getContext();\n                }\n\n                @Override\n                public boolean hasNext() {\n                    return false;\n                }\n\n                @Override\n                public Object next() {\n                    throw new NoSuchElementException();\n                }\n            };\n        }\n\n        ResultIterable<Object> iterable = ResultIterable.of(result);\n\n        return magic.mappedResult(iterable, result.getContext());\n    }\n\n    private Iterator<Object[]> zipArgs(Method method, Object[] args) {\n        boolean foundIterator = false;\n        List<Iterator<?>> extras = new ArrayList<>();\n        for (int paramIdx = 0; paramIdx < method.getParameterCount(); paramIdx++) {\n            final boolean singleValue = method.getParameters()[paramIdx].isAnnotationPresent(SingleValue.class);\n            final Object arg = args[paramIdx];\n            if (!singleValue && IterableLike.isIterable(arg)) {\n                extras.add(IterableLike.of(arg));\n                foundIterator = true;\n            } else {\n                extras.add(Stream.generate(() -> arg).iterator());\n            }\n        }\n\n        if (!foundIterator) {\n            throw new UnableToCreateStatementException(\"@SqlBatch method has no Iterable or array parameters,\"\n                    + \" did you mean @SqlQuery?\", null, null);\n        }\n\n        return new Iterator<Object[]>() {\n            @Override\n            public boolean hasNext() {\n                for (Iterator<?> extra : extras) {\n                    if (!extra.hasNext()) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            @Override\n            public Object[] next() {\n                final Object[] argsArray = new Object[args.length];\n                for (int i = 0; i < extras.size(); i++) {\n                    argsArray[i] = extras.get(i).next();\n                }\n                return argsArray;\n            }\n        };\n    }\n\n    private ResultIterator<?> executeBatch(final Handle handle, final Supplier<PreparedBatch> preparedBatchSupplier) {\n        if (!handle.isInTransaction() && sqlBatch.transactional()) {\n            // it is safe to use same prepared preparedBatchSupplier as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction(c -> batchIntermediate.apply(preparedBatchSupplier.get()));\n        } else {\n            return batchIntermediate.apply(preparedBatchSupplier.get());\n        }\n    }\n\n    private static boolean returnTypeIsValid(Class<?> type) {\n        if (type.equals(Void.TYPE)) {\n            return true;\n        }\n\n        if (type.isArray()) {\n            Class<?> componentType = type.getComponentType();\n            return componentType.equals(Integer.TYPE) || componentType.equals(Boolean.TYPE);\n        }\n\n        return false;\n    }\n\n    private static String invalidReturnTypeMessage(Method method) {\n        return method.getDeclaringClass() + \".\" + method.getName()\n                + \" method is annotated with @SqlBatch so should return void, int[], or boolean[] but is returning: \"\n                + method.getReturnType();\n    }\n\n    private interface ChunkSizeFunction {\n        int call(Object[] args);\n    }\n\n    private static class ConstantChunkSizeFunction implements SqlBatchHandler.ChunkSizeFunction {\n        private final int value;\n\n        ConstantChunkSizeFunction(int value) {\n            this.value = value;\n        }\n\n        @Override\n        public int call(Object[] args) {\n            return value;\n        }\n    }\n\n    private static class ParamBasedChunkSizeFunction implements SqlBatchHandler.ChunkSizeFunction {\n        private final int index;\n\n        ParamBasedChunkSizeFunction(int index) {\n            this.index = index;\n        }\n\n        @Override\n        public int call(Object[] args) {\n            return (Integer) args[index];\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.internal.IterableLike;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.SingleValue;\nimport org.jdbi.v3.sqlobject.UnableToCreateSqlObjectException;\nimport org.jdbi.v3.sqlobject.statement.BatchChunkSize;\nimport org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;\nimport org.jdbi.v3.sqlobject.statement.SqlBatch;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.sqlobject.statement.UseRowReducer;\n\npublic class SqlBatchHandler extends CustomizingStatementHandler<PreparedBatch> {\n    private final SqlBatch sqlBatch;\n    private final SqlBatchHandler.ChunkSizeFunction batchChunkSize;\n    private final Function<PreparedBatch, ResultIterator<?>> batchIntermediate;\n    private final ResultReturner magic;\n\n    public SqlBatchHandler(Class<?> sqlObjectType, Method method) {\n        super(sqlObjectType, method);\n\n        if (method.isAnnotationPresent(UseRowReducer.class)) {\n            throw new UnsupportedOperationException(\"Cannot declare @UseRowReducer on a @SqlUpdate method.\");\n        }\n\n        this.sqlBatch = method.getAnnotation(SqlBatch.class);\n        this.batchChunkSize = determineBatchChunkSize(sqlObjectType, method);\n        final GetGeneratedKeys getGeneratedKeys = method.getAnnotation(GetGeneratedKeys.class);\n\n        if (getGeneratedKeys == null) {\n            if (!returnTypeIsValid(method.getReturnType())) {\n                throw new UnableToCreateSqlObjectException(invalidReturnTypeMessage(method));\n            }\n            Function<PreparedBatch, ResultIterator<?>> modCounts = PreparedBatch::executeAndGetModCount;\n            batchIntermediate = method.getReturnType().equals(boolean[].class)\n                    ? mapToBoolean(modCounts)\n                    : modCounts;\n            magic = ResultReturner.forOptionalReturn(sqlObjectType, method);\n        } else {\n            String[] columnNames = getGeneratedKeys.value();\n            magic = ResultReturner.forMethod(sqlObjectType, method);\n\n            if (method.isAnnotationPresent(UseRowMapper.class)) {\n                RowMapper<?> mapper = rowMapperFor(method.getAnnotation(UseRowMapper.class));\n                batchIntermediate = batch -> batch.executeAndReturnGeneratedKeys(columnNames)\n                        .map(mapper)\n                        .iterator();\n            } else {\n                batchIntermediate = batch -> batch.executeAndReturnGeneratedKeys(columnNames)\n                        .mapTo(magic.elementType(batch.getConfig()))\n                        .iterator();\n            }\n        }\n    }\n\n    @Override\n    public void warm(ConfigRegistry config) {\n        super.warm(config);\n        magic.warm(config);\n    }\n\n    private Function<PreparedBatch, ResultIterator<?>> mapToBoolean(Function<PreparedBatch, ResultIterator<?>> modCounts) {\n        return modCounts.andThen(iterator -> new ResultIterator<Boolean>() {\n            @Override\n            public boolean hasNext() {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public Boolean next() {\n                return ((Integer) iterator.next()) > 0;\n            }\n\n            @Override\n            public void close() {\n                iterator.close();\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return iterator.getContext();\n            }\n        });\n    }\n\n    private SqlBatchHandler.ChunkSizeFunction determineBatchChunkSize(Class<?> sqlObjectType, Method method) {\n        // this next big if chain determines the batch chunk size. It looks from most specific\n        // scope to least, that is: as an argument, then on the method, then on the class,\n        // then default to Integer.MAX_VALUE\n\n        int batchChunkSizeParameterIndex = indexOfBatchChunkSizeParameter(method);\n        if (batchChunkSizeParameterIndex >= 0) {\n            return new ParamBasedChunkSizeFunction(batchChunkSizeParameterIndex);\n        } else if (method.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = method.getAnnotation(BatchChunkSize.class).value();\n            if (size <= 0) {\n                throw new IllegalArgumentException(\"Batch chunk size must be >= 0\");\n            }\n            return new ConstantChunkSizeFunction(size);\n        } else if (sqlObjectType.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = sqlObjectType.getAnnotation(BatchChunkSize.class).value();\n            return new ConstantChunkSizeFunction(size);\n        } else {\n            return new ConstantChunkSizeFunction(Integer.MAX_VALUE);\n        }\n    }\n\n    private int indexOfBatchChunkSizeParameter(Method method) {\n        Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n        return IntStream.range(0, parameterAnnotations.length)\n                .filter(i -> Stream.of(parameterAnnotations[i]).anyMatch(BatchChunkSize.class::isInstance))\n                .findFirst()\n                .orElse(-1);\n    }\n\n    @Override\n    PreparedBatch createStatement(Handle handle, String locatedSql) {\n        return handle.prepareBatch(locatedSql);\n    }\n\n    @Override\n    void configureReturner(PreparedBatch stmt, SqlObjectStatementConfiguration cfg) {}\n\n    @Override\n    Type getParameterType(Parameter parameter) {\n        Type type = super.getParameterType(parameter);\n\n        if (!parameter.isAnnotationPresent(SingleValue.class)) {\n            Class<?> erasedType = GenericTypes.getErasedType(type);\n            if (Iterable.class.isAssignableFrom(erasedType)) {\n                return GenericTypes.findGenericParameter(type, Iterable.class).get();\n            } else if (Iterator.class.isAssignableFrom(erasedType)) {\n                return GenericTypes.findGenericParameter(type, Iterator.class).get();\n            } else if (GenericTypes.isArray(type)) {\n                return ((Class<?>) type).getComponentType();\n            }\n        }\n\n        return type;\n    }\n\n    @Override\n    @SuppressWarnings(\"PMD.ExcessiveMethodLength\")\n    public Object invoke(HandleSupplier handleSupplier, Object target, Object... args) {\n        final Object[] safeArgs = JdbiClassUtils.safeVarargs(args);\n        final Handle handle = handleSupplier.getHandle();\n        final String sql = locateSql(handle);\n        final int chunkSize = batchChunkSize.call(safeArgs);\n        final Iterator<Object[]> batchArgs = zipArgs(getMethod(), safeArgs);\n\n        final class BatchChunkIterator implements ResultIterator<Object> {\n            private ResultIterator<?> batchResult = null;\n            private boolean closed = false;\n\n            BatchChunkIterator() {\n                if (batchArgs.hasNext()) {\n                    // if arguments are present, preload the next result chunk\n                    batchResult = loadChunk();\n                }\n            }\n\n            private ResultIterator<?> loadChunk() {\n                // execute a single chunk and buffer\n                List<Object[]> currArgs = new ArrayList<>();\n                for (int i = 0; i < chunkSize && batchArgs.hasNext(); i++) {\n                    currArgs.add(batchArgs.next());\n                }\n                Supplier<PreparedBatch> preparedBatchSupplier = () -> createPreparedBatch(handle, sql, currArgs);\n                return executeBatch(handle, preparedBatchSupplier);\n            }\n\n            private PreparedBatch createPreparedBatch(Handle handle, String sql, List<Object[]> currArgs) {\n                PreparedBatch batch = handle.prepareBatch(sql);\n                for (Object[] currArg : currArgs) {\n                    applyCustomizers(batch, currArg);\n                    batch.add();\n                }\n                return batch;\n            }\n\n            @Override\n            public boolean hasNext() {\n                if (closed) {\n                    throw new IllegalStateException(\"closed\");\n                }\n                // first, any elements already buffered?\n                if (batchResult != null) {\n                    if (batchResult.hasNext()) {\n                        return true;\n                    }\n                    // no more in this chunk, release resources\n                    batchResult.close();\n                }\n                // more chunks?\n                if (batchArgs.hasNext()) {\n                    // preload the next result chunk\n                    batchResult = loadChunk();\n\n                    // recurse to ensure we actually got elements\n                    return hasNext();\n                }\n\n                return false;\n            }\n\n            @Override\n            public Object next() {\n                if (closed) {\n                    throw new IllegalStateException(\"closed\");\n                }\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return batchResult.next();\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return batchResult.getContext();\n            }\n\n            @Override\n            public void close() {\n                closed = true;\n                batchResult.close();\n            }\n        }\n\n        ResultIterator<Object> result;\n\n        if (batchArgs.hasNext()) {\n            result = new BatchChunkIterator();\n        } else {\n            // only created to get access to the context.\n            PreparedBatch dummy = handle.prepareBatch(sql);\n            result = new ResultIterator<Object>() {\n                @Override\n                public void close() {\n                    // no op\n                }\n\n                @Override\n                public StatementContext getContext() {\n                    return dummy.getContext();\n                }\n\n                @Override\n                public boolean hasNext() {\n                    return false;\n                }\n\n                @Override\n                public Object next() {\n                    throw new NoSuchElementException();\n                }\n            };\n        }\n\n        ResultIterable<Object> iterable = ResultIterable.of(result);\n\n        return magic.mappedResult(iterable, result.getContext());\n    }\n\n    private Iterator<Object[]> zipArgs(Method method, Object[] args) {\n        boolean foundIterator = false;\n        List<Iterator<?>> extras = new ArrayList<>();\n        for (int paramIdx = 0; paramIdx < method.getParameterCount(); paramIdx++) {\n            final boolean singleValue = method.getParameters()[paramIdx].isAnnotationPresent(SingleValue.class);\n            final Object arg = args[paramIdx];\n            if (!singleValue && IterableLike.isIterable(arg)) {\n                extras.add(IterableLike.of(arg));\n                foundIterator = true;\n            } else {\n                extras.add(Stream.generate(() -> arg).iterator());\n            }\n        }\n\n        if (!foundIterator) {\n            throw new UnableToCreateStatementException(\"@SqlBatch method has no Iterable or array parameters,\"\n                    + \" did you mean @SqlQuery?\", null, null);\n        }\n\n        return new Iterator<Object[]>() {\n            @Override\n            public boolean hasNext() {\n                for (Iterator<?> extra : extras) {\n                    if (!extra.hasNext()) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            @Override\n            public Object[] next() {\n                final Object[] argsArray = new Object[args.length];\n                for (int i = 0; i < extras.size(); i++) {\n                    argsArray[i] = extras.get(i).next();\n                }\n                return argsArray;\n            }\n        };\n    }\n\n    private ResultIterator<?> executeBatch(final Handle handle, final Supplier<PreparedBatch> preparedBatchSupplier) {\n        if (!handle.isInTransaction() && sqlBatch.transactional()) {\n            // it is safe to use same prepared preparedBatchSupplier as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction(c -> batchIntermediate.apply(preparedBatchSupplier.get()));\n        } else {\n            return batchIntermediate.apply(preparedBatchSupplier.get());\n        }\n    }\n\n    private static boolean returnTypeIsValid(Class<?> type) {\n        if (type.equals(Void.TYPE)) {\n            return true;\n        }\n\n        if (type.isArray()) {\n            Class<?> componentType = type.getComponentType();\n            return componentType.equals(Integer.TYPE) || componentType.equals(Boolean.TYPE);\n        }\n\n        return false;\n    }\n\n    private static String invalidReturnTypeMessage(Method method) {\n        return method.getDeclaringClass() + \".\" + method.getName()\n                + \" method is annotated with @SqlBatch so should return void, int[], or boolean[] but is returning: \"\n                + method.getReturnType();\n    }\n\n    private interface ChunkSizeFunction {\n        int call(Object[] args);\n    }\n\n    private static class ConstantChunkSizeFunction implements SqlBatchHandler.ChunkSizeFunction {\n        private final int value;\n\n        ConstantChunkSizeFunction(int value) {\n            this.value = value;\n        }\n\n        @Override\n        public int call(Object[] args) {\n            return value;\n        }\n    }\n\n    private static class ParamBasedChunkSizeFunction implements SqlBatchHandler.ChunkSizeFunction {\n        private final int index;\n\n        ParamBasedChunkSizeFunction(int index) {\n            this.index = index;\n        }\n\n        @Override\n        public int call(Object[] args) {\n            return (Integer) args[index];\n        }\n    }\n}\n","lineNo":181}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.internal;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.function.BiConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.ExtensionContext;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.internal.MemoizingSupplier;\nimport org.jdbi.v3.core.internal.exceptions.Sneaky;\nimport org.jdbi.v3.sqlobject.GenerateSqlObject;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.SqlObject;\nimport org.jdbi.v3.sqlobject.UnableToCreateSqlObjectException;\n\npublic final class SqlObjectInitData {\n\n    private static final Object[] NO_ARGS = new Object[0];\n    public static final ThreadLocal<SqlObjectInitData> INIT_DATA = new ThreadLocal<>();\n\n    private final Class<?> extensionType;\n    private final UnaryOperator<ConfigRegistry> instanceConfigurer;\n    private final Map<Method, UnaryOperator<ConfigRegistry>> methodConfigurers;\n    private final Map<Method, Handler> methodHandlers;\n\n    public SqlObjectInitData(\n            Class<?> extensionType,\n            UnaryOperator<ConfigRegistry> instanceConfigurer,\n            Map<Method, UnaryOperator<ConfigRegistry>> methodConfigurers,\n            Map<Method, Handler> methodHandlers) {\n        this.extensionType = extensionType;\n        this.instanceConfigurer = instanceConfigurer;\n        this.methodConfigurers = methodConfigurers;\n        this.methodHandlers = methodHandlers;\n    }\n\n    public static boolean isConcrete(Class<?> extensionType) {\n        return extensionType.getAnnotation(GenerateSqlObject.class) != null;\n    }\n\n    public static SqlObjectInitData initData() {\n        final SqlObjectInitData result = INIT_DATA.get();\n        if (result == null) {\n            throw new IllegalStateException(\"Implemented SqlObject types must be initialized by SqlObjectFactory\");\n        }\n        return result;\n    }\n\n    public static Method lookupMethod(String methodName, Class<?>... parameterTypes) {\n        return lookupMethod(initData().extensionType, methodName, parameterTypes);\n    }\n\n    private static Method lookupMethod(Class<?> klass, String methodName, Class<?>... parameterTypes) {\n        try {\n            return klass.getMethod(methodName, parameterTypes);\n        } catch (NoSuchMethodException | SecurityException e) {\n            try {\n                return klass.getDeclaredMethod(methodName, parameterTypes);\n            } catch (Exception x) {\n                e.addSuppressed(x);\n                try {\n                    return SqlObject.class.getMethod(methodName, parameterTypes);\n                } catch (Exception x2) {\n                    e.addSuppressed(x2);\n                }\n            }\n            throw new IllegalStateException(\n                    String.format(\"can't find %s#%s%s\", klass.getName(), methodName, Arrays.asList(parameterTypes)), e);\n        }\n    }\n\n    public Class<?> extensionType() {\n        return extensionType;\n    }\n\n    public <E> E instantiate(Class<E> passExtensionType, HandleSupplier handleSupplier, ConfigRegistry instanceConfig) {\n        if (!extensionType.equals(passExtensionType)) {\n            throw new IllegalArgumentException(\"mismatch extension type\");\n        }\n\n        try {\n            SqlObjectInitData.INIT_DATA.set(this);\n            return passExtensionType.cast(\n                Class.forName(extensionType.getPackage().getName() + \".\" + extensionType.getSimpleName() + \"Impl\")\n                    .getConstructor(HandleSupplier.class, ConfigRegistry.class)\n                    .newInstance(handleSupplier, instanceConfig));\n        } catch (Exception | ExceptionInInitializerError e) {\n            throw new UnableToCreateSqlObjectException(e);\n        } finally {\n            SqlObjectInitData.INIT_DATA.remove();\n        }\n    }\n\n    public ConfigRegistry configureInstance(ConfigRegistry config) {\n        return instanceConfigurer.apply(config);\n    }\n\n    public void forEachMethodHandler(BiConsumer<Method, Handler> action) {\n        methodHandlers.forEach(action);\n    }\n\n    public Supplier<InContextInvoker> lazyInvoker(Object target, Method method, HandleSupplier handleSupplier, ConfigRegistry instanceConfig) {\n        return MemoizingSupplier.of(() -> new InContextInvoker(target, method, handleSupplier, instanceConfig));\n    }\n\n    public final class InContextInvoker {\n        private final Object target;\n        private final HandleSupplier handleSupplier;\n        private final ExtensionContext extensionContext;\n        private final Handler methodHandler;\n\n        InContextInvoker(Object target, Method method, HandleSupplier handleSupplier, ConfigRegistry config) {\n            this.target = target;\n            this.handleSupplier = handleSupplier;\n            ConfigRegistry methodConfig = methodConfigurers.get(method).apply(config.createCopy());\n            this.extensionContext = ExtensionContext.forExtensionMethod(methodConfig, extensionType, method);\n            this.methodHandler = methodHandlers.get(method);\n\n            methodHandler.warm(methodConfig);\n        }\n\n        public Object invoke(Object[] args) {\n            final Callable<Object> callable = () -> methodHandler.invoke(target, args == null ? NO_ARGS : args, handleSupplier);\n            return call(callable);\n        }\n\n        public Object call(Callable<?> callable) {\n            try {\n                return handleSupplier.invokeInContext(extensionContext, callable);\n            } catch (Exception x) {\n                throw Sneaky.throwAnyway(x);\n            }\n        }\n\n        public Object call(Runnable runnable) {\n            return call(() -> {\n                runnable.run();\n                return null;\n            });\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.internal.ConfigCache;\nimport org.jdbi.v3.core.config.internal.ConfigCaches;\nimport org.jdbi.v3.core.extension.ExtensionContext;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\nimport org.jdbi.v3.core.internal.MemoizingSupplier;\nimport org.jdbi.v3.core.internal.exceptions.Sneaky;\nimport org.jdbi.v3.sqlobject.GenerateSqlObject;\nimport org.jdbi.v3.sqlobject.GeneratorSqlObjectFactory;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.HandlerDecorators;\nimport org.jdbi.v3.sqlobject.Handlers;\nimport org.jdbi.v3.sqlobject.SqlObject;\nimport org.jdbi.v3.sqlobject.UnableToCreateSqlObjectException;\nimport org.jdbi.v3.sqlobject.config.Configurer;\nimport org.jdbi.v3.sqlobject.config.ConfiguringAnnotation;\n\nimport static org.jdbi.v3.sqlobject.Handler.EQUALS_HANDLER;\nimport static org.jdbi.v3.sqlobject.Handler.GET_HANDLE_HANDLER;\nimport static org.jdbi.v3.sqlobject.Handler.HASHCODE_HANDLER;\nimport static org.jdbi.v3.sqlobject.Handler.NULL_HANDLER;\n\npublic final class SqlObjectInitData {\n\n    // This should be a field in InContextInvoker but static fields are not allowed in inner classes in Java 8\n    private static final Object[] NO_ARGS = new Object[0];\n    private static final ConfigCache<Class<?>, SqlObjectInitData> INIT_DATA_CACHE =\n            ConfigCaches.declare(SqlObjectInitData::initDataFor);\n    private final Class<?> extensionType;\n    private final UnaryOperator<ConfigRegistry> instanceConfigurer;\n    private final Map<Method, UnaryOperator<ConfigRegistry>> methodConfigurers;\n    private final Map<Method, Handler> methodHandlers;\n\n    private SqlObjectInitData(\n            Class<?> extensionType,\n            UnaryOperator<ConfigRegistry> instanceConfigurer,\n            Map<Method, UnaryOperator<ConfigRegistry>> methodConfigurers,\n            Map<Method, Handler> methodHandlers) {\n        this.extensionType = extensionType;\n        this.instanceConfigurer = instanceConfigurer;\n        this.methodConfigurers = methodConfigurers;\n        this.methodHandlers = methodHandlers;\n    }\n\n    public static boolean isConcrete(Class<?> extensionTypeClass) {\n        return extensionTypeClass.getAnnotation(GenerateSqlObject.class) != null;\n    }\n\n    public static SqlObjectInitData lookup(Class<?> key, ConfigRegistry config) {\n        return INIT_DATA_CACHE.get(key, config);\n    }\n\n    public Class<?> extensionType() {\n        return extensionType;\n    }\n\n    public ConfigRegistry configureInstance(ConfigRegistry config) {\n        return instanceConfigurer.apply(config);\n    }\n\n    public void forEachMethodHandler(BiConsumer<Method, Handler> action) {\n        methodHandlers.forEach(action);\n    }\n\n    public Supplier<InContextInvoker> lazyInvoker(Object target, Method method, HandleSupplier handleSupplier, ConfigRegistry instanceConfig) {\n        return MemoizingSupplier.of(() -> new InContextInvoker(target, method, handleSupplier, instanceConfig));\n    }\n\n    /**\n     * Legacy generator classes that refer to this method directly. Do not use in new code.\n     * @deprecated\n     */\n    @Deprecated\n    SqlObjectInitData initData() {\n        return GeneratorSqlObjectFactory.initData();\n    }\n\n    /**\n     * Legacy generator classes that refer to this method directly. Do not use in new code.\n     * @deprecated\n     */\n    @Deprecated\n    public static Method lookupMethod(String methodName, Class<?>... parameterTypes) {\n        return GeneratorSqlObjectFactory.lookupMethod(methodName, parameterTypes);\n    }\n\n    private static SqlObjectInitData initDataFor(ConfigRegistry handlersConfig, Class<?> sqlObjectType) {\n        Map<Method, Handler> methodHandlers = buildMethodHandlers(handlersConfig, sqlObjectType);\n\n        // process all annotations on the type.\n        final ConfigurerMethod forType = (configurer, config, annotation) -> configurer.configureForType(config, annotation, sqlObjectType);\n\n        // build a configurer for the type and all supertypes. This processes all annotations on classes and interfaces\n        UnaryOperator<ConfigRegistry> instanceConfigurer = buildConfigurers(\n                Stream.concat(JdbiClassUtils.superTypes(sqlObjectType), Stream.of(sqlObjectType)), forType);\n\n        // A map for all methods that contains the annotations for each method on the type\n        Map<Method, UnaryOperator<ConfigRegistry>> methodConfigurers = methodHandlers.keySet().stream().collect(Collectors.toMap(\n                        Function.identity(),\n                        method -> {\n                            // process all annotations on a single method.\n                            final ConfigurerMethod forMethod = (configurer, config, annotation) ->\n                                    configurer.configureForMethod(config, annotation, sqlObjectType, method);\n                            // build a configurer that processes all annotations on the method itself.\n                            return buildConfigurers(Stream.of(method), forMethod);\n                        }));\n\n        return new SqlObjectInitData(\n                sqlObjectType,\n                instanceConfigurer,\n                methodConfigurers,\n                methodHandlers);\n    }\n\n    private static Map<Method, Handler> buildMethodHandlers(\n            ConfigRegistry config,\n            Class<?> sqlObjectType) {\n\n        final Handlers handlers = config.get(Handlers.class);\n        final HandlerDecorators handlerDecorators = config.get(HandlerDecorators.class);\n        final Map<Method, Handler> handlerMap = new HashMap<>();\n\n        // tostring can not be constant, different for every object\n        Handler toStringHandler = (target, args, handleSupplier) ->\n                \"Jdbi sqlobject proxy for \" + sqlObjectType.getName() + \"@\" + Integer.toHexString(target.hashCode());\n\n        addMethodHandler(handlerMap, toStringHandler, Object.class, \"toString\");\n        addMethodHandler(handlerMap, EQUALS_HANDLER, Object.class, \"equals\", Object.class);\n        addMethodHandler(handlerMap, HASHCODE_HANDLER, Object.class, \"hashCode\");\n\n        // SQL Object methods\n        addMethodHandler(handlerMap, GET_HANDLE_HANDLER, SqlObject.class, \"getHandle\");\n\n        addMethodHandler(handlerMap, NULL_HANDLER, sqlObjectType, \"finalize\");\n\n        final Set<Method> methods = new LinkedHashSet<>();\n        methods.addAll(Arrays.asList(sqlObjectType.getMethods()));\n        methods.addAll(Arrays.asList(sqlObjectType.getDeclaredMethods()));\n\n        final Set<Method> seen = new HashSet<>(handlerMap.keySet());\n        for (Method method : methods) {\n            if (Modifier.isStatic(method.getModifiers()) || !seen.add(method)) {\n                continue;\n            }\n            handlerMap.put(method, handlerDecorators.applyDecorators(\n                        handlers.findFor(sqlObjectType, method)\n                            .orElseGet(() -> {\n                                Supplier<IllegalStateException> x = () -> new IllegalStateException(String.format(\n                                        \"Method %s.%s must have an implementation or be annotated with a SQL method annotation.\",\n                                        method.getDeclaringClass().getSimpleName(),\n                                        method.getName()));\n                                if (!SqlObjectInitData.isConcrete(sqlObjectType) && !method.isSynthetic() && !Modifier.isPrivate(method.getModifiers())) {\n                                    throw x.get();\n                                }\n                                return (target, args, handleSupplier) -> {\n                                    throw x.get();\n                                };\n                            }),\n                        sqlObjectType,\n                        method));\n        }\n\n        methods.stream()\n            .filter(m -> !m.isSynthetic())\n            .collect(Collectors.groupingBy(m -> Arrays.asList(m.getName(), Arrays.asList(m.getParameterTypes()))))\n            .values()\n            .stream()\n            .filter(l -> l.size() > 1)\n            .findAny()\n            .ifPresent(ms -> {\n                throw new UnableToCreateSqlObjectException(sqlObjectType + \" has ambiguous methods \" + ms + \", please resolve with an explicit override\");\n            });\n\n        return handlerMap;\n    }\n\n    private static void addMethodHandler(Map<Method, Handler> handlerMap, Handler handler, Class<?> klass, String methodName, Class<?>... parameterTypes) {\n        JdbiClassUtils.safeMethodLookup(klass, methodName, parameterTypes)\n                .ifPresent(method -> handlerMap.put(method, handler));\n    }\n\n    private static UnaryOperator<ConfigRegistry> buildConfigurers(Stream<AnnotatedElement> elements, ConfigurerMethod consumer) {\n        List<Consumer<ConfigRegistry>> myConfigurers = elements\n                .flatMap(ae -> Arrays.stream(ae.getAnnotations()))\n                .filter(a -> a.annotationType().isAnnotationPresent(ConfiguringAnnotation.class))\n                .map(a -> {\n                    ConfiguringAnnotation meta = a.annotationType().getAnnotation(ConfiguringAnnotation.class);\n                    Configurer configurer = JdbiClassUtils.createInstance(meta.value());\n                    return (Consumer<ConfigRegistry>) config -> consumer.configure(configurer, config, a);\n                })\n                .collect(Collectors.toList());\n        return config -> {\n            myConfigurers.forEach(configurer -> configurer.accept(config));\n            return config;\n        };\n    }\n\n    private interface ConfigurerMethod {\n        void configure(Configurer configurer, ConfigRegistry config, Annotation annotation);\n    }\n\n    public final class InContextInvoker {\n        private final Object target;\n        private final HandleSupplier handleSupplier;\n        private final ExtensionContext extensionContext;\n        private final Handler methodHandler;\n\n        InContextInvoker(Object target, Method method, HandleSupplier handleSupplier, ConfigRegistry config) {\n            this.target = target;\n            this.handleSupplier = handleSupplier;\n            ConfigRegistry methodConfig = methodConfigurers.get(method).apply(config.createCopy());\n            this.extensionContext = ExtensionContext.forExtensionMethod(methodConfig, extensionType, method);\n            this.methodHandler = methodHandlers.get(method);\n\n            methodHandler.warm(methodConfig);\n        }\n\n        public Object invoke(Object[] args) {\n            final Callable<Object> callable = () -> methodHandler.invoke(target, args == null ? NO_ARGS : args, handleSupplier);\n            return call(callable);\n        }\n\n        public Object call(Callable<?> callable) {\n            try {\n                return handleSupplier.invokeInContext(extensionContext, callable);\n            } catch (Exception x) {\n                throw Sneaky.throwAnyway(x);\n            }\n        }\n\n        public Object call(Runnable runnable) {\n            return call(() -> {\n                runnable.run();\n                return null;\n            });\n        }\n    }\n}\n","lineNo":127}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.internal;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.function.BiConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.ExtensionContext;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.internal.MemoizingSupplier;\nimport org.jdbi.v3.core.internal.exceptions.Sneaky;\nimport org.jdbi.v3.sqlobject.GenerateSqlObject;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.SqlObject;\nimport org.jdbi.v3.sqlobject.UnableToCreateSqlObjectException;\n\npublic final class SqlObjectInitData {\n\n    private static final Object[] NO_ARGS = new Object[0];\n    public static final ThreadLocal<SqlObjectInitData> INIT_DATA = new ThreadLocal<>();\n\n    private final Class<?> extensionType;\n    private final UnaryOperator<ConfigRegistry> instanceConfigurer;\n    private final Map<Method, UnaryOperator<ConfigRegistry>> methodConfigurers;\n    private final Map<Method, Handler> methodHandlers;\n\n    public SqlObjectInitData(\n            Class<?> extensionType,\n            UnaryOperator<ConfigRegistry> instanceConfigurer,\n            Map<Method, UnaryOperator<ConfigRegistry>> methodConfigurers,\n            Map<Method, Handler> methodHandlers) {\n        this.extensionType = extensionType;\n        this.instanceConfigurer = instanceConfigurer;\n        this.methodConfigurers = methodConfigurers;\n        this.methodHandlers = methodHandlers;\n    }\n\n    public static boolean isConcrete(Class<?> extensionType) {\n        return extensionType.getAnnotation(GenerateSqlObject.class) != null;\n    }\n\n    public static SqlObjectInitData initData() {\n        final SqlObjectInitData result = INIT_DATA.get();\n        if (result == null) {\n            throw new IllegalStateException(\"Implemented SqlObject types must be initialized by SqlObjectFactory\");\n        }\n        return result;\n    }\n\n    public static Method lookupMethod(String methodName, Class<?>... parameterTypes) {\n        return lookupMethod(initData().extensionType, methodName, parameterTypes);\n    }\n\n    private static Method lookupMethod(Class<?> klass, String methodName, Class<?>... parameterTypes) {\n        try {\n            return klass.getMethod(methodName, parameterTypes);\n        } catch (NoSuchMethodException | SecurityException e) {\n            try {\n                return klass.getDeclaredMethod(methodName, parameterTypes);\n            } catch (Exception x) {\n                e.addSuppressed(x);\n                try {\n                    return SqlObject.class.getMethod(methodName, parameterTypes);\n                } catch (Exception x2) {\n                    e.addSuppressed(x2);\n                }\n            }\n            throw new IllegalStateException(\n                    String.format(\"can't find %s#%s%s\", klass.getName(), methodName, Arrays.asList(parameterTypes)), e);\n        }\n    }\n\n    public Class<?> extensionType() {\n        return extensionType;\n    }\n\n    public <E> E instantiate(Class<E> passExtensionType, HandleSupplier handleSupplier, ConfigRegistry instanceConfig) {\n        if (!extensionType.equals(passExtensionType)) {\n            throw new IllegalArgumentException(\"mismatch extension type\");\n        }\n\n        try {\n            SqlObjectInitData.INIT_DATA.set(this);\n            return passExtensionType.cast(\n                Class.forName(extensionType.getPackage().getName() + \".\" + extensionType.getSimpleName() + \"Impl\")\n                    .getConstructor(HandleSupplier.class, ConfigRegistry.class)\n                    .newInstance(handleSupplier, instanceConfig));\n        } catch (Exception | ExceptionInInitializerError e) {\n            throw new UnableToCreateSqlObjectException(e);\n        } finally {\n            SqlObjectInitData.INIT_DATA.remove();\n        }\n    }\n\n    public ConfigRegistry configureInstance(ConfigRegistry config) {\n        return instanceConfigurer.apply(config);\n    }\n\n    public void forEachMethodHandler(BiConsumer<Method, Handler> action) {\n        methodHandlers.forEach(action);\n    }\n\n    public Supplier<InContextInvoker> lazyInvoker(Object target, Method method, HandleSupplier handleSupplier, ConfigRegistry instanceConfig) {\n        return MemoizingSupplier.of(() -> new InContextInvoker(target, method, handleSupplier, instanceConfig));\n    }\n\n    public final class InContextInvoker {\n        private final Object target;\n        private final HandleSupplier handleSupplier;\n        private final ExtensionContext extensionContext;\n        private final Handler methodHandler;\n\n        InContextInvoker(Object target, Method method, HandleSupplier handleSupplier, ConfigRegistry config) {\n            this.target = target;\n            this.handleSupplier = handleSupplier;\n            ConfigRegistry methodConfig = methodConfigurers.get(method).apply(config.createCopy());\n            this.extensionContext = ExtensionContext.forExtensionMethod(methodConfig, extensionType, method);\n            this.methodHandler = methodHandlers.get(method);\n\n            methodHandler.warm(methodConfig);\n        }\n\n        public Object invoke(Object[] args) {\n            final Callable<Object> callable = () -> methodHandler.invoke(target, args == null ? NO_ARGS : args, handleSupplier);\n            return call(callable);\n        }\n\n        public Object call(Callable<?> callable) {\n            try {\n                return handleSupplier.invokeInContext(extensionContext, callable);\n            } catch (Exception x) {\n                throw Sneaky.throwAnyway(x);\n            }\n        }\n\n        public Object call(Runnable runnable) {\n            return call(() -> {\n                runnable.run();\n                return null;\n            });\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.internal.ConfigCache;\nimport org.jdbi.v3.core.config.internal.ConfigCaches;\nimport org.jdbi.v3.core.extension.ExtensionContext;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\nimport org.jdbi.v3.core.internal.MemoizingSupplier;\nimport org.jdbi.v3.core.internal.exceptions.Sneaky;\nimport org.jdbi.v3.sqlobject.GenerateSqlObject;\nimport org.jdbi.v3.sqlobject.GeneratorSqlObjectFactory;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.HandlerDecorators;\nimport org.jdbi.v3.sqlobject.Handlers;\nimport org.jdbi.v3.sqlobject.SqlObject;\nimport org.jdbi.v3.sqlobject.UnableToCreateSqlObjectException;\nimport org.jdbi.v3.sqlobject.config.Configurer;\nimport org.jdbi.v3.sqlobject.config.ConfiguringAnnotation;\n\nimport static org.jdbi.v3.sqlobject.Handler.EQUALS_HANDLER;\nimport static org.jdbi.v3.sqlobject.Handler.GET_HANDLE_HANDLER;\nimport static org.jdbi.v3.sqlobject.Handler.HASHCODE_HANDLER;\nimport static org.jdbi.v3.sqlobject.Handler.NULL_HANDLER;\n\npublic final class SqlObjectInitData {\n\n    // This should be a field in InContextInvoker but static fields are not allowed in inner classes in Java 8\n    private static final Object[] NO_ARGS = new Object[0];\n    private static final ConfigCache<Class<?>, SqlObjectInitData> INIT_DATA_CACHE =\n            ConfigCaches.declare(SqlObjectInitData::initDataFor);\n    private final Class<?> extensionType;\n    private final UnaryOperator<ConfigRegistry> instanceConfigurer;\n    private final Map<Method, UnaryOperator<ConfigRegistry>> methodConfigurers;\n    private final Map<Method, Handler> methodHandlers;\n\n    private SqlObjectInitData(\n            Class<?> extensionType,\n            UnaryOperator<ConfigRegistry> instanceConfigurer,\n            Map<Method, UnaryOperator<ConfigRegistry>> methodConfigurers,\n            Map<Method, Handler> methodHandlers) {\n        this.extensionType = extensionType;\n        this.instanceConfigurer = instanceConfigurer;\n        this.methodConfigurers = methodConfigurers;\n        this.methodHandlers = methodHandlers;\n    }\n\n    public static boolean isConcrete(Class<?> extensionTypeClass) {\n        return extensionTypeClass.getAnnotation(GenerateSqlObject.class) != null;\n    }\n\n    public static SqlObjectInitData lookup(Class<?> key, ConfigRegistry config) {\n        return INIT_DATA_CACHE.get(key, config);\n    }\n\n    public Class<?> extensionType() {\n        return extensionType;\n    }\n\n    public ConfigRegistry configureInstance(ConfigRegistry config) {\n        return instanceConfigurer.apply(config);\n    }\n\n    public void forEachMethodHandler(BiConsumer<Method, Handler> action) {\n        methodHandlers.forEach(action);\n    }\n\n    public Supplier<InContextInvoker> lazyInvoker(Object target, Method method, HandleSupplier handleSupplier, ConfigRegistry instanceConfig) {\n        return MemoizingSupplier.of(() -> new InContextInvoker(target, method, handleSupplier, instanceConfig));\n    }\n\n    /**\n     * Legacy generator classes that refer to this method directly. Do not use in new code.\n     * @deprecated\n     */\n    @Deprecated\n    SqlObjectInitData initData() {\n        return GeneratorSqlObjectFactory.initData();\n    }\n\n    /**\n     * Legacy generator classes that refer to this method directly. Do not use in new code.\n     * @deprecated\n     */\n    @Deprecated\n    public static Method lookupMethod(String methodName, Class<?>... parameterTypes) {\n        return GeneratorSqlObjectFactory.lookupMethod(methodName, parameterTypes);\n    }\n\n    private static SqlObjectInitData initDataFor(ConfigRegistry handlersConfig, Class<?> sqlObjectType) {\n        Map<Method, Handler> methodHandlers = buildMethodHandlers(handlersConfig, sqlObjectType);\n\n        // process all annotations on the type.\n        final ConfigurerMethod forType = (configurer, config, annotation) -> configurer.configureForType(config, annotation, sqlObjectType);\n\n        // build a configurer for the type and all supertypes. This processes all annotations on classes and interfaces\n        UnaryOperator<ConfigRegistry> instanceConfigurer = buildConfigurers(\n                Stream.concat(JdbiClassUtils.superTypes(sqlObjectType), Stream.of(sqlObjectType)), forType);\n\n        // A map for all methods that contains the annotations for each method on the type\n        Map<Method, UnaryOperator<ConfigRegistry>> methodConfigurers = methodHandlers.keySet().stream().collect(Collectors.toMap(\n                        Function.identity(),\n                        method -> {\n                            // process all annotations on a single method.\n                            final ConfigurerMethod forMethod = (configurer, config, annotation) ->\n                                    configurer.configureForMethod(config, annotation, sqlObjectType, method);\n                            // build a configurer that processes all annotations on the method itself.\n                            return buildConfigurers(Stream.of(method), forMethod);\n                        }));\n\n        return new SqlObjectInitData(\n                sqlObjectType,\n                instanceConfigurer,\n                methodConfigurers,\n                methodHandlers);\n    }\n\n    private static Map<Method, Handler> buildMethodHandlers(\n            ConfigRegistry config,\n            Class<?> sqlObjectType) {\n\n        final Handlers handlers = config.get(Handlers.class);\n        final HandlerDecorators handlerDecorators = config.get(HandlerDecorators.class);\n        final Map<Method, Handler> handlerMap = new HashMap<>();\n\n        // tostring can not be constant, different for every object\n        Handler toStringHandler = (target, args, handleSupplier) ->\n                \"Jdbi sqlobject proxy for \" + sqlObjectType.getName() + \"@\" + Integer.toHexString(target.hashCode());\n\n        addMethodHandler(handlerMap, toStringHandler, Object.class, \"toString\");\n        addMethodHandler(handlerMap, EQUALS_HANDLER, Object.class, \"equals\", Object.class);\n        addMethodHandler(handlerMap, HASHCODE_HANDLER, Object.class, \"hashCode\");\n\n        // SQL Object methods\n        addMethodHandler(handlerMap, GET_HANDLE_HANDLER, SqlObject.class, \"getHandle\");\n\n        addMethodHandler(handlerMap, NULL_HANDLER, sqlObjectType, \"finalize\");\n\n        final Set<Method> methods = new LinkedHashSet<>();\n        methods.addAll(Arrays.asList(sqlObjectType.getMethods()));\n        methods.addAll(Arrays.asList(sqlObjectType.getDeclaredMethods()));\n\n        final Set<Method> seen = new HashSet<>(handlerMap.keySet());\n        for (Method method : methods) {\n            if (Modifier.isStatic(method.getModifiers()) || !seen.add(method)) {\n                continue;\n            }\n            handlerMap.put(method, handlerDecorators.applyDecorators(\n                        handlers.findFor(sqlObjectType, method)\n                            .orElseGet(() -> {\n                                Supplier<IllegalStateException> x = () -> new IllegalStateException(String.format(\n                                        \"Method %s.%s must have an implementation or be annotated with a SQL method annotation.\",\n                                        method.getDeclaringClass().getSimpleName(),\n                                        method.getName()));\n                                if (!SqlObjectInitData.isConcrete(sqlObjectType) && !method.isSynthetic() && !Modifier.isPrivate(method.getModifiers())) {\n                                    throw x.get();\n                                }\n                                return (target, args, handleSupplier) -> {\n                                    throw x.get();\n                                };\n                            }),\n                        sqlObjectType,\n                        method));\n        }\n\n        methods.stream()\n            .filter(m -> !m.isSynthetic())\n            .collect(Collectors.groupingBy(m -> Arrays.asList(m.getName(), Arrays.asList(m.getParameterTypes()))))\n            .values()\n            .stream()\n            .filter(l -> l.size() > 1)\n            .findAny()\n            .ifPresent(ms -> {\n                throw new UnableToCreateSqlObjectException(sqlObjectType + \" has ambiguous methods \" + ms + \", please resolve with an explicit override\");\n            });\n\n        return handlerMap;\n    }\n\n    private static void addMethodHandler(Map<Method, Handler> handlerMap, Handler handler, Class<?> klass, String methodName, Class<?>... parameterTypes) {\n        JdbiClassUtils.safeMethodLookup(klass, methodName, parameterTypes)\n                .ifPresent(method -> handlerMap.put(method, handler));\n    }\n\n    private static UnaryOperator<ConfigRegistry> buildConfigurers(Stream<AnnotatedElement> elements, ConfigurerMethod consumer) {\n        List<Consumer<ConfigRegistry>> myConfigurers = elements\n                .flatMap(ae -> Arrays.stream(ae.getAnnotations()))\n                .filter(a -> a.annotationType().isAnnotationPresent(ConfiguringAnnotation.class))\n                .map(a -> {\n                    ConfiguringAnnotation meta = a.annotationType().getAnnotation(ConfiguringAnnotation.class);\n                    Configurer configurer = JdbiClassUtils.createInstance(meta.value());\n                    return (Consumer<ConfigRegistry>) config -> consumer.configure(configurer, config, a);\n                })\n                .collect(Collectors.toList());\n        return config -> {\n            myConfigurers.forEach(configurer -> configurer.accept(config));\n            return config;\n        };\n    }\n\n    private interface ConfigurerMethod {\n        void configure(Configurer configurer, ConfigRegistry config, Annotation annotation);\n    }\n\n    public final class InContextInvoker {\n        private final Object target;\n        private final HandleSupplier handleSupplier;\n        private final ExtensionContext extensionContext;\n        private final Handler methodHandler;\n\n        InContextInvoker(Object target, Method method, HandleSupplier handleSupplier, ConfigRegistry config) {\n            this.target = target;\n            this.handleSupplier = handleSupplier;\n            ConfigRegistry methodConfig = methodConfigurers.get(method).apply(config.createCopy());\n            this.extensionContext = ExtensionContext.forExtensionMethod(methodConfig, extensionType, method);\n            this.methodHandler = methodHandlers.get(method);\n\n            methodHandler.warm(methodConfig);\n        }\n\n        public Object invoke(Object[] args) {\n            final Callable<Object> callable = () -> methodHandler.invoke(target, args == null ? NO_ARGS : args, handleSupplier);\n            return call(callable);\n        }\n\n        public Object call(Callable<?> callable) {\n            try {\n                return handleSupplier.invokeInContext(extensionContext, callable);\n            } catch (Exception x) {\n                throw Sneaky.throwAnyway(x);\n            }\n        }\n\n        public Object call(Runnable runnable) {\n            return call(() -> {\n                runnable.run();\n                return null;\n            });\n        }\n    }\n}\n","lineNo":160}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.internal;\n\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.internal.OnDemandHandleSupplier;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.SqlObject;\nimport org.jdbi.v3.sqlobject.SqlObjectFactory;\n\npublic class CreateSqlObjectHandler implements Handler {\n    private final Method method;\n\n    public CreateSqlObjectHandler(Method method) {\n        this.method = method;\n    }\n\n    @Override\n    public Object invoke(Object target, Object[] args, HandleSupplier handleSupplier) throws Exception {\n        if (handleSupplier instanceof OnDemandHandleSupplier) {\n            return handleSupplier.getConfig(OnDemandExtensions.class).create(handleSupplier.getJdbi(), method.getReturnType(), SqlObject.class);\n        }\n        return handleSupplier.getConfig(Extensions.class)\n                .findFactory(SqlObjectFactory.class)\n                .orElseThrow(() -> new IllegalStateException(\"Can't locate SqlObject factory\"))\n                .attach(method.getReturnType(), handleSupplier);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.internal;\n\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.internal.OnDemandHandleSupplier;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.SqlObject;\nimport org.jdbi.v3.sqlobject.SqlObjectFactory;\n\npublic class CreateSqlObjectHandler implements Handler {\n    private final Method method;\n\n    public CreateSqlObjectHandler(Method method) {\n        this.method = method;\n    }\n\n    @Override\n    public Object invoke(Object target, Object[] args, HandleSupplier handleSupplier) throws Exception {\n        ConfigRegistry config = handleSupplier.getConfig();\n\n        if (handleSupplier instanceof OnDemandHandleSupplier) {\n            return config.get(OnDemandExtensions.class).create(handleSupplier.getJdbi(), method.getReturnType(), SqlObject.class);\n        }\n        return config.get(Extensions.class)\n                .findFactory(SqlObjectFactory.class)\n                .orElseThrow(() -> new IllegalStateException(\"Can't locate SqlObject factory\"))\n                .attach(method.getReturnType(), handleSupplier);\n    }\n}\n","lineNo":36}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Iterator;\nimport java.util.Optional;\nimport java.util.function.Consumer;\nimport java.util.stream.Collector;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.collector.JdbiCollectors;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.mapper.Mappers;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.qualifier.Qualifiers;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.sqlobject.SingleValue;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\n/**\n * Helper class used by the {@link CustomizingStatementHandler}s to assemble\n * the result Collection, Iterable, etc.\n */\nabstract class ResultReturner {\n    /**\n     * If the return type is {@code void}, swallow results.\n     * @param extensionType The extension type to use.\n     * @param method The method to use.\n     * @see ResultReturner#forMethod(Class, Method) if the return type is not void\n     * @return A {@link ResultReturner}\n     */\n    static ResultReturner forOptionalReturn(Class<?> extensionType, Method method) {\n        if (method.getReturnType() == void.class) {\n            return new VoidReturner();\n        }\n        return forMethod(extensionType, method);\n    }\n\n    /**\n     * Inspect a Method for its return type, and choose a ResultReturner subclass\n     * that handles any container that might wrap the results.\n     * @param extensionType the type that owns the Method\n     * @param method the method whose return type chooses the ResultReturner\n     * @return an instance that takes a ResultIterable and constructs the return value\n     */\n    static ResultReturner forMethod(Class<?> extensionType, Method method) {\n        Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), extensionType);\n        QualifiedType<?> qualifiedReturnType = QualifiedType.of(returnType).withAnnotations(new Qualifiers().findFor(method));\n        Class<?> returnClass = getErasedType(returnType);\n        if (Void.TYPE.equals(returnClass)) {\n            return findConsumer(method)\n                .orElseThrow(() -> new IllegalStateException(String.format(\n                    \"Method %s#%s is annotated as if it should return a value, but the method is void.\",\n                    method.getDeclaringClass().getName(),\n                    method.getName())));\n        } else if (ResultIterable.class.equals(returnClass)) {\n            return new ResultIterableReturner(qualifiedReturnType);\n        } else if (Stream.class.equals(returnClass)) {\n            return new StreamReturner(qualifiedReturnType);\n        } else if (ResultIterator.class.equals(returnClass)) {\n            return new ResultIteratorReturner(qualifiedReturnType);\n        } else if (Iterator.class.equals(returnClass)) {\n            return new IteratorReturner(qualifiedReturnType);\n        } else if (method.isAnnotationPresent(SingleValue.class)) {\n            return new SingleValueReturner<>(qualifiedReturnType);\n        } else {\n            return new CollectedResultReturner<>(qualifiedReturnType);\n        }\n    }\n\n    /**\n     * Inspect a Method for a {@link Consumer} to execute for each produced row.\n     * @param method the method called\n     * @return a ResultReturner that invokes the consumer and does not return a value\n     */\n    static Optional<ResultReturner> findConsumer(Method method) {\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        for (int i = 0; i < paramTypes.length; i++) {\n            if (paramTypes[i] == Consumer.class) {\n                return Optional.of(ConsumerResultReturner.of(method, i));\n            }\n        }\n        return Optional.empty();\n    }\n\n    protected abstract Object mappedResult(ResultIterable<?> iterable, StatementContext ctx);\n    protected abstract Object reducedResult(Stream<?> stream, StatementContext ctx);\n\n    protected abstract QualifiedType<?> elementType(ConfigRegistry config);\n\n    protected void warm(ConfigRegistry config) {\n        Optional.ofNullable(elementType(config))\n                .ifPresent(config.get(Mappers.class)::findFor);\n    }\n\n    private static Object checkResult(Object result, QualifiedType<?> type) {\n        if (result == null && getErasedType(type.getType()).isPrimitive()) {\n            throw new IllegalStateException(\"SQL method returns primitive \" + type + \", but statement returned no results\");\n        }\n        return result;\n    }\n\n    static class VoidReturner extends ResultReturner {\n        @Override\n        protected Void mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            iterable.stream().forEach(i -> {}); // Make sure to consume the result\n            return null;\n        }\n\n        @Override\n        protected Void reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return void from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return null;\n        }\n    }\n\n    static class ResultIterableReturner extends ResultReturner {\n\n        private final QualifiedType<?> elementType;\n\n        ResultIterableReturner(QualifiedType<?> returnType) {\n            // extract T from Query<T>\n            elementType = returnType.flatMapType(type -> GenericTypes.findGenericParameter(type, ResultIterable.class))\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect ResultIterable<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected ResultIterable<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable;\n        }\n\n        @Override\n        protected ResultIterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return ResultIterable from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return elementType;\n        }\n    }\n\n    static class StreamReturner extends ResultReturner {\n        private final QualifiedType<?> elementType;\n\n        StreamReturner(QualifiedType<?> returnType) {\n            elementType = returnType.flatMapType(type -> GenericTypes.findGenericParameter(type, Stream.class))\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect Stream<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Stream<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.stream();\n        }\n\n        @Override\n        protected Stream<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            return stream;\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return elementType;\n        }\n    }\n\n    static class ResultIteratorReturner extends ResultReturner {\n        private final QualifiedType<?> elementType;\n\n        ResultIteratorReturner(QualifiedType<?> returnType) {\n            this.elementType = returnType.flatMapType(type -> GenericTypes.findGenericParameter(type, Iterator.class))\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect ResultIterator<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected ResultIterator<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.iterator();\n        }\n\n        @Override\n        protected ResultIterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return ResultIterator from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return elementType;\n        }\n    }\n\n    static class IteratorReturner extends ResultReturner {\n        private final QualifiedType<?> elementType;\n\n        IteratorReturner(QualifiedType<?> returnType) {\n            this.elementType = returnType.flatMapType(type -> GenericTypes.findGenericParameter(type, Iterator.class))\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect Iterator<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Iterator<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.iterator();\n        }\n\n        @Override\n        protected Iterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            return stream.iterator();\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return elementType;\n        }\n    }\n\n    static class SingleValueReturner<T> extends ResultReturner {\n        private final QualifiedType<T> returnType;\n\n        SingleValueReturner(QualifiedType<T> returnType) {\n            this.returnType = returnType;\n        }\n\n        @Override\n        protected Object mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return checkResult(iterable.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected Object reducedResult(Stream<?> stream, StatementContext ctx) {\n            return checkResult(stream.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected QualifiedType<T> elementType(ConfigRegistry config) {\n            return returnType;\n        }\n    }\n\n    static class CollectedResultReturner<T> extends ResultReturner {\n        private final QualifiedType<T> returnType;\n\n        CollectedResultReturner(QualifiedType<T> returnType) {\n            this.returnType = returnType;\n        }\n\n        @Override\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        protected Object mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            Collector collector = ctx.findCollectorFor(returnType.getType()).orElse(null);\n            if (collector != null) {\n                return iterable.collect(collector);\n            }\n            return checkResult(iterable.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected Object reducedResult(Stream<?> stream, StatementContext ctx) {\n            Collector collector = ctx.findCollectorFor(returnType.getType()).orElse(null);\n            if (collector != null) {\n                return stream.collect(collector);\n            }\n            return checkResult(stream.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected void warm(ConfigRegistry config) {\n            super.warm(config);\n            config.get(JdbiCollectors.class).findFor(returnType.getType());\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            // if returnType is not supported by a collector factory, assume it to be a single-value return type.\n            return returnType.flatMapType(type -> config.get(JdbiCollectors.class).findElementTypeFor(type))\n                .orElse(returnType);\n        }\n    }\n\n    abstract static class ConsumerResultReturner extends ResultReturner {\n        private final int consumerIndex;\n        private final QualifiedType<?> elementType;\n\n        ConsumerResultReturner(int consumerIndex, QualifiedType<?> elementType) {\n            this.consumerIndex = consumerIndex;\n            this.elementType = elementType;\n        }\n\n        static ConsumerResultReturner of(Method method, int consumerIndex) {\n            Type parameterType = method.getGenericParameterTypes()[consumerIndex];\n            QualifiedType<?> elementType = QualifiedType.of(\n                GenericTypes.findGenericParameter(parameterType, Consumer.class)\n                    .orElseThrow(() -> new IllegalStateException(\n                        \"Cannot reflect Consumer<T> element type T in method consumer parameter \"\n                            + parameterType)))\n                .withAnnotations(new Qualifiers().findFor(method.getParameters()[consumerIndex]));\n            if (GenericTypes.isSuperType(Iterator.class, elementType.getType())) {\n                return new ConsumeIteratorResultReturner(consumerIndex, elementType.mapType(t -> GenericTypes.findGenericParameter(t, Iterator.class)\n                        .orElseThrow(() -> new IllegalStateException(\"Couldn't find Iterator type on \" + elementType))));\n            } else if (GenericTypes.isSuperType(Stream.class, elementType.getType())) {\n                return new ConsumeStreamResultReturner(consumerIndex, elementType.mapType(t -> GenericTypes.findGenericParameter(t, Stream.class)\n                        .orElseThrow(() -> new IllegalStateException(\"Couldn't find Stream type on \" + elementType))));\n            } else {\n                return new ConsumeEachResultReturner(consumerIndex, elementType);\n            }\n        }\n\n        @Override\n        protected Void mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            accept(iterable.stream(), findConsumer(ctx));\n            return null;\n        }\n\n        @Override\n        protected Void reducedResult(Stream<?> stream, StatementContext ctx) {\n            accept(stream, findConsumer(ctx));\n            return null;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Consumer<Object> findConsumer(StatementContext ctx) {\n            return (Consumer<Object>) ctx.getConfig(SqlObjectStatementConfiguration.class)\n                    .getArgs()[consumerIndex];\n        }\n\n        protected abstract void accept(Stream<?> stream, @SuppressWarnings(\"rawtypes\") Consumer consumer);\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return elementType;\n        }\n    }\n\n    static class ConsumeEachResultReturner extends ConsumerResultReturner {\n        ConsumeEachResultReturner(int consumerIndex, QualifiedType<?> elementType) {\n            super(consumerIndex, elementType);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        protected void accept(Stream<?> stream, @SuppressWarnings(\"rawtypes\") Consumer consumer) {\n            stream.forEach(consumer);\n        }\n    }\n\n    static class ConsumeIteratorResultReturner extends ConsumerResultReturner {\n        ConsumeIteratorResultReturner(int consumerIndex, QualifiedType<?> elementType) {\n            super(consumerIndex, elementType);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        protected void accept(Stream<?> stream, @SuppressWarnings(\"rawtypes\") Consumer consumer) {\n            consumer.accept(stream.iterator());\n        }\n    }\n\n    static class ConsumeStreamResultReturner extends ConsumerResultReturner {\n        ConsumeStreamResultReturner(int consumerIndex, QualifiedType<?> elementType) {\n            super(consumerIndex, elementType);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        protected void accept(Stream<?> stream, @SuppressWarnings(\"rawtypes\") Consumer consumer) {\n            consumer.accept(stream);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Iterator;\nimport java.util.Optional;\nimport java.util.function.Consumer;\nimport java.util.stream.Collector;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.collector.JdbiCollectors;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.mapper.Mappers;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.qualifier.Qualifiers;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.sqlobject.SingleValue;\n\nimport static java.lang.String.format;\n\n/**\n * Helper class used by the {@link CustomizingStatementHandler}s to assemble\n * the result Collection, Iterable, etc.\n */\nabstract class ResultReturner {\n\n    /**\n     * If the return type is {@code void}, swallow results.\n     *\n     * @param extensionType The extension type to use.\n     * @param method        The method to use.\n     * @return A {@link ResultReturner}\n     * @see ResultReturner#forMethod(Class, Method) if the return type is not void\n     */\n    static ResultReturner forOptionalReturn(Class<?> extensionType, Method method) {\n        if (method.getReturnType() == void.class) {\n            return new VoidReturner();\n        }\n        return forMethod(extensionType, method);\n    }\n\n    /**\n     * Inspect a Method for its return type, and choose a ResultReturner subclass\n     * that handles any container that might wrap the results.\n     *\n     * @param extensionType the type that owns the Method\n     * @param method        the method whose return type chooses the ResultReturner\n     * @return an instance that takes a ResultIterable and constructs the return value\n     */\n    static ResultReturner forMethod(Class<?> extensionType, Method method) {\n        Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), extensionType);\n        QualifiedType<?> qualifiedReturnType = QualifiedType.of(returnType).withAnnotations(new Qualifiers().findFor(method));\n        Class<?> returnClass = GenericTypes.getErasedType(returnType);\n        if (Void.TYPE.equals(returnClass)) {\n            return findConsumer(method)\n                    .orElseThrow(() -> new IllegalStateException(format(\n                            \"Method %s#%s is annotated as if it should return a value, but the method is void.\",\n                            method.getDeclaringClass().getName(),\n                            method.getName())));\n        } else if (ResultIterable.class.equals(returnClass)) {\n            return new ResultIterableReturner(qualifiedReturnType);\n        } else if (Stream.class.equals(returnClass)) {\n            return new StreamReturner(qualifiedReturnType);\n        } else if (ResultIterator.class.equals(returnClass)) {\n            return new ResultIteratorReturner(qualifiedReturnType);\n        } else if (Iterator.class.equals(returnClass)) {\n            return new IteratorReturner(qualifiedReturnType);\n        } else if (method.isAnnotationPresent(SingleValue.class)) {\n            return new SingleValueReturner<>(qualifiedReturnType);\n        } else {\n            return new CollectedResultReturner<>(qualifiedReturnType);\n        }\n    }\n\n    /**\n     * Inspect a Method for a {@link Consumer} to execute for each produced row.\n     *\n     * @param method the method called\n     * @return a ResultReturner that invokes the consumer and does not return a value\n     */\n    static Optional<ResultReturner> findConsumer(Method method) {\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        for (int i = 0; i < paramTypes.length; i++) {\n            if (paramTypes[i] == Consumer.class) {\n                return Optional.of(ConsumerResultReturner.of(method, i));\n            }\n        }\n        return Optional.empty();\n    }\n\n    protected abstract Object mappedResult(ResultIterable<?> iterable, StatementContext ctx);\n\n    protected abstract Object reducedResult(Stream<?> stream, StatementContext ctx);\n\n    protected abstract QualifiedType<?> elementType(ConfigRegistry config);\n\n    protected void warm(ConfigRegistry config) {\n        Optional.ofNullable(elementType(config))\n                .ifPresent(config.get(Mappers.class)::findFor);\n    }\n\n    private static Object checkResult(Object result, QualifiedType<?> type) {\n        if (result == null && GenericTypes.getErasedType(type.getType()).isPrimitive()) {\n            throw new IllegalStateException(\"SQL method returns primitive \" + type + \", but statement returned no results\");\n        }\n        return result;\n    }\n\n    static class VoidReturner extends ResultReturner {\n\n        @Override\n        protected Void mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            iterable.stream().forEach(i -> {}); // Make sure to consume the result\n            return null;\n        }\n\n        @Override\n        protected Void reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return void from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return null;\n        }\n    }\n\n    static class ResultIterableReturner extends ResultReturner {\n\n        private final QualifiedType<?> elementType;\n\n        ResultIterableReturner(QualifiedType<?> returnType) {\n            // extract T from Query<T>\n            elementType = returnType.flatMapType(type -> GenericTypes.findGenericParameter(type, ResultIterable.class))\n                    .orElseThrow(() -> new IllegalStateException(\n                            \"Cannot reflect ResultIterable<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected ResultIterable<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable;\n        }\n\n        @Override\n        protected ResultIterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return ResultIterable from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return elementType;\n        }\n    }\n\n    static class StreamReturner extends ResultReturner {\n\n        private final QualifiedType<?> elementType;\n\n        StreamReturner(QualifiedType<?> returnType) {\n            elementType = returnType.flatMapType(type -> GenericTypes.findGenericParameter(type, Stream.class))\n                    .orElseThrow(() -> new IllegalStateException(\n                            \"Cannot reflect Stream<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Stream<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.stream();\n        }\n\n        @Override\n        protected Stream<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            return stream;\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return elementType;\n        }\n    }\n\n    static class ResultIteratorReturner extends ResultReturner {\n\n        private final QualifiedType<?> elementType;\n\n        ResultIteratorReturner(QualifiedType<?> returnType) {\n            this.elementType = returnType.flatMapType(type -> GenericTypes.findGenericParameter(type, Iterator.class))\n                    .orElseThrow(() -> new IllegalStateException(\n                            \"Cannot reflect ResultIterator<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected ResultIterator<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.iterator();\n        }\n\n        @Override\n        protected ResultIterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return ResultIterator from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return elementType;\n        }\n    }\n\n    static class IteratorReturner extends ResultReturner {\n\n        private final QualifiedType<?> elementType;\n\n        IteratorReturner(QualifiedType<?> returnType) {\n            this.elementType = returnType.flatMapType(type -> GenericTypes.findGenericParameter(type, Iterator.class))\n                    .orElseThrow(() -> new IllegalStateException(\n                            \"Cannot reflect Iterator<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Iterator<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.iterator();\n        }\n\n        @Override\n        protected Iterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            return stream.iterator();\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return elementType;\n        }\n    }\n\n    static class SingleValueReturner<T> extends ResultReturner {\n\n        private final QualifiedType<T> returnType;\n\n        SingleValueReturner(QualifiedType<T> returnType) {\n            this.returnType = returnType;\n        }\n\n        @Override\n        protected Object mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return checkResult(iterable.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected Object reducedResult(Stream<?> stream, StatementContext ctx) {\n            return checkResult(stream.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected QualifiedType<T> elementType(ConfigRegistry config) {\n            return returnType;\n        }\n    }\n\n    static class CollectedResultReturner<T> extends ResultReturner {\n\n        private final QualifiedType<T> returnType;\n\n        CollectedResultReturner(QualifiedType<T> returnType) {\n            this.returnType = returnType;\n        }\n\n        @Override\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        protected Object mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            Collector collector = ctx.findCollectorFor(returnType.getType()).orElse(null);\n            if (collector != null) {\n                return iterable.collect(collector);\n            }\n            return checkResult(iterable.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected Object reducedResult(Stream<?> stream, StatementContext ctx) {\n            Collector collector = ctx.findCollectorFor(returnType.getType()).orElse(null);\n            if (collector != null) {\n                return stream.collect(collector);\n            }\n            return checkResult(stream.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected void warm(ConfigRegistry config) {\n            super.warm(config);\n            config.get(JdbiCollectors.class).findFor(returnType.getType());\n        }\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            // if returnType is not supported by a collector factory, assume it to be a single-value return type.\n            return returnType.flatMapType(type -> config.get(JdbiCollectors.class).findElementTypeFor(type))\n                    .orElse(returnType);\n        }\n    }\n\n    abstract static class ConsumerResultReturner extends ResultReturner {\n\n        private final int consumerIndex;\n        private final QualifiedType<?> elementType;\n\n        ConsumerResultReturner(int consumerIndex, QualifiedType<?> elementType) {\n            this.consumerIndex = consumerIndex;\n            this.elementType = elementType;\n        }\n\n        static ConsumerResultReturner of(Method method, int consumerIndex) {\n            Type parameterType = method.getGenericParameterTypes()[consumerIndex];\n            QualifiedType<?> elementType = QualifiedType.of(\n                            GenericTypes.findGenericParameter(parameterType, Consumer.class)\n                                    .orElseThrow(() -> new IllegalStateException(\n                                            \"Cannot reflect Consumer<T> element type T in method consumer parameter \"\n                                                    + parameterType)))\n                    .withAnnotations(new Qualifiers().findFor(method.getParameters()[consumerIndex]));\n\n            Type type = elementType.getType();\n\n            // special case: Consumer<Iterator<T>>\n            if (GenericTypes.isSuperType(Iterator.class, type)) {\n                if (GenericTypes.getErasedType(type) == Iterator.class) {\n                    return new ConsumeIteratorResultReturner(consumerIndex, elementType.mapType(t -> GenericTypes.findGenericParameter(t, Iterator.class)\n                            .orElseThrow(() -> new IllegalStateException(\"Couldn't find Iterator type on \" + elementType))));\n                }\n                throw new IllegalArgumentException(format(\"Consumer argument for %s can not use a subtype of Iterator (found %s)!\", method, type));\n                // special case: Stream<Iterator<T>>\n            } else if (GenericTypes.isSuperType(Stream.class, type)) {\n                if (GenericTypes.getErasedType(type) == Stream.class) {\n                    return new ConsumeStreamResultReturner(consumerIndex, elementType.mapType(t -> GenericTypes.findGenericParameter(t, Stream.class)\n                            .orElseThrow(() -> new IllegalStateException(\"Couldn't find Stream type on \" + elementType))));\n                }\n                throw new IllegalArgumentException(format(\"Consumer argument for %s can not use a subtype of Stream (found %s)!\", method, type));\n            } else {\n                // everything else is per-row Consumer<T>\n                return new ConsumeEachResultReturner(consumerIndex, elementType);\n            }\n        }\n\n        @Override\n        protected Void mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            accept(iterable.stream(), findConsumer(ctx));\n            return null;\n        }\n\n        @Override\n        protected Void reducedResult(Stream<?> stream, StatementContext ctx) {\n            accept(stream, findConsumer(ctx));\n            return null;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Consumer<Object> findConsumer(StatementContext ctx) {\n            return (Consumer<Object>) ctx.getConfig(SqlObjectStatementConfiguration.class)\n                    .getArgs()[consumerIndex];\n        }\n\n        protected abstract void accept(Stream<?> stream, @SuppressWarnings(\"rawtypes\") Consumer consumer);\n\n        @Override\n        protected QualifiedType<?> elementType(ConfigRegistry config) {\n            return elementType;\n        }\n    }\n\n    static class ConsumeEachResultReturner extends ConsumerResultReturner {\n\n        ConsumeEachResultReturner(int consumerIndex, QualifiedType<?> elementType) {\n            super(consumerIndex, elementType);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        protected void accept(Stream<?> stream, @SuppressWarnings(\"rawtypes\") Consumer consumer) {\n            stream.forEach(consumer);\n        }\n    }\n\n    static class ConsumeIteratorResultReturner extends ConsumerResultReturner {\n\n        ConsumeIteratorResultReturner(int consumerIndex, QualifiedType<?> elementType) {\n            super(consumerIndex, elementType);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        protected void accept(Stream<?> stream, @SuppressWarnings(\"rawtypes\") Consumer consumer) {\n            try {\n                consumer.accept(stream.iterator());\n            } finally {\n                stream.close();\n            }\n        }\n    }\n\n    static class ConsumeStreamResultReturner extends ConsumerResultReturner {\n\n        ConsumeStreamResultReturner(int consumerIndex, QualifiedType<?> elementType) {\n            super(consumerIndex, elementType);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        protected void accept(Stream<?> stream, @SuppressWarnings(\"rawtypes\") Consumer consumer) {\n            try {\n                consumer.accept(stream);\n            } finally {\n                stream.close();\n            }\n        }\n    }\n}\n","lineNo":333}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceLoader;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.sql.DataSource;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionCallback;\nimport org.jdbi.v3.core.extension.ExtensionConsumer;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.core.statement.DefaultStatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilderFactory;\nimport org.jdbi.v3.core.transaction.LocalTransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * Main entry point; configurable wrapper around a JDBC {@link DataSource}.\n * Use it to obtain Handle instances and provide configuration\n * for all handles obtained from it.\n */\npublic class Jdbi implements Configurable<Jdbi> {\n    private static final Logger LOG = LoggerFactory.getLogger(Jdbi.class);\n\n    private final ConfigRegistry config = new ConfigRegistry();\n\n    private final ConnectionFactory connectionFactory;\n    private final AtomicReference<TransactionHandler> transactionhandler = new AtomicReference<>(LocalTransactionHandler.binding());\n    private final AtomicReference<StatementBuilderFactory> statementBuilderFactory = new AtomicReference<>(DefaultStatementBuilder.FACTORY);\n\n    private final CopyOnWriteArrayList<JdbiPlugin> plugins = new CopyOnWriteArrayList<>();\n\n    @SuppressWarnings(\"ThreadLocalUsage\")\n    private final ThreadLocal<HandleSupplier> threadHandleSupplier = new ThreadLocal<>();\n\n    private Jdbi(ConnectionFactory connectionFactory) {\n        Objects.requireNonNull(connectionFactory, \"null connectionFactory\");\n        this.connectionFactory = connectionFactory;\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link Connection}.\n     *\n     * @param connection A {@link Connection} object.\n     *\n     * @return A {@link Jdbi} instance that uses a single database connection.\n     */\n    public static Jdbi create(Connection connection) {\n        return create(new SingleConnectionFactory(connection));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link DataSource}.\n     *\n     * @param dataSource the data source.\n     *\n     * @return a Jdbi which uses the given data source as a connection factory.\n     */\n    public static Jdbi create(DataSource dataSource) {\n        return create(dataSource::getConnection);\n    }\n\n    /**\n     * Factory used to allow for obtaining a Connection in a customized manner.\n     *\n     * <p>\n     * The {@link ConnectionFactory#openConnection()} method will be invoked to obtain a connection instance\n     * whenever a Handle is opened.\n     * <\/p>\n     *\n     * @param connectionFactory Provides JDBC connections to Handle instances\n     *\n     * @return a Jdbi which uses the given connection factory.\n     */\n    public static Jdbi create(ConnectionFactory connectionFactory) {\n        return new Jdbi(connectionFactory);\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url A JDBC URL for connections.\n     *\n     * @return a Jdbi which uses{@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url) {\n        Objects.requireNonNull(url, \"null url\");\n        return create(() -> DriverManager.getConnection(url));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url   JDBC URL for connections\n     * @param properties Properties to pass to DriverManager.getConnection(url, props) for each new handle\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final Properties properties) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(properties, \"null properties\");\n        return create(() -> DriverManager.getConnection(url, properties));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url      JDBC URL for connections\n     * @param username User name for connection authentication\n     * @param password Password for connection authentication\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final String username, final String password) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(username, \"null username\");\n        Objects.requireNonNull(password, \"null password\");\n        return create(() -> DriverManager.getConnection(url, username, password));\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a specific data source\n     *\n     * @param dataSource the JDBC data source.\n     *\n     * @return Handle using a Connection obtained from the provided DataSource\n     */\n    public static Handle open(DataSource dataSource) {\n        return create(dataSource).open();\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a {@link ConnectionFactory}.\n     *\n     * @param connectionFactory the connection factory\n     *\n     * @return Handle using a Connection obtained from the provided connection factory\n     */\n    public static Handle open(ConnectionFactory connectionFactory) {\n        return create(connectionFactory).open();\n    }\n\n    /**\n     * Create a Handle wrapping a particular JDBC Connection\n     *\n     * @param connection the JDBC connection\n     *\n     * @return Handle bound to connection\n     */\n    public static Handle open(final Connection connection) {\n        Objects.requireNonNull(connection, \"null connection\");\n        return create(() -> connection).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url JDBC Url\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url) {\n        return create(url).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url      JDBC Url\n     * @param username JDBC username for authentication\n     * @param password JDBC password for authentication\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final String username, final String password) {\n        return create(url, username, password).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url   JDBC Url\n     * @param props JDBC properties\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final Properties props) {\n        return create(url, props).open();\n    }\n\n    /**\n     * Use the {@link ServiceLoader} API to detect and install plugins automagically.\n     * Some people consider this feature dangerous; some consider it essential --\n     * use at your own risk.\n     * @return this\n     */\n    public Jdbi installPlugins() {\n        ServiceLoader.load(JdbiPlugin.class).forEach(this::installPlugin);\n        LOG.debug(\"Automatically installed plugins {}\", plugins);\n        return this;\n    }\n\n    /**\n     * Install a given {@link JdbiPlugin} instance that will configure any\n     * provided {@link Handle} instances.\n     * @param plugin the plugin to install\n     * @return this\n     */\n    public Jdbi installPlugin(JdbiPlugin plugin) {\n        if (plugins.addIfAbsent(plugin)) {\n            Unchecked.consumer(plugin::customizeJdbi).accept(this);\n        }\n        return this;\n    }\n\n    /**\n     * Allows customization of how prepared statements are created. When a Handle is created\n     * against this Jdbi instance the factory will be used to create a StatementBuilder for\n     * that specific handle. When the handle is closed, the StatementBuilder's close method\n     * will be invoked.\n     *\n     * @param factory the new statement builder factory.\n     * @return this\n     */\n    public Jdbi setStatementBuilderFactory(StatementBuilderFactory factory) {\n        this.statementBuilderFactory.set(factory);\n        return this;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilderFactory}.\n     *\n     * @return the current {@link StatementBuilderFactory}\n     */\n    public StatementBuilderFactory getStatementBuilderFactory() {\n        return this.statementBuilderFactory.get();\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return config;\n    }\n\n    /**\n     * Specify the TransactionHandler instance to use. This allows overriding\n     * transaction semantics, or mapping into different transaction\n     * management systems.\n     * <p>\n     * The default version uses local transactions on the database Connection\n     * instances obtained.\n     * <\/p>\n     *\n     * @param handler The TransactionHandler to use for all Handle instances obtained\n     *                from this Jdbi\n     * @return this\n     */\n    public Jdbi setTransactionHandler(TransactionHandler handler) {\n        Objects.requireNonNull(handler, \"null transaction handler\");\n        this.transactionhandler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link TransactionHandler}.\n     *\n     * @return the {@link TransactionHandler}\n     */\n    public TransactionHandler getTransactionHandler() {\n        return this.transactionhandler.get();\n    }\n\n    /**\n     * Obtain a Handle to the data source wrapped by this Jdbi instance.\n     * You own this expensive resource and are required to close it or\n     * risk leaks.  Using a {@code try-with-resources} block is recommended.\n     *\n     * @return an open Handle instance\n     * @see #useHandle(HandleConsumer)\n     * @see #withHandle(HandleCallback)\n     */\n    public Handle open() {\n        try {\n            final long start = System.nanoTime();\n            @SuppressWarnings(\"PMD.CloseResource\")\n            Connection conn = Objects.requireNonNull(connectionFactory.openConnection(),\n                    () -> \"Connection factory \" + connectionFactory + \" returned a null connection\");\n            final long stop = System.nanoTime();\n\n            for (JdbiPlugin p : plugins) {\n                conn = p.customizeConnection(conn);\n            }\n\n            StatementBuilder cache = statementBuilderFactory.get().createStatementBuilder(conn);\n\n            Handle h = Handle.createHandle(this,\n                connectionFactory.getCleanableFor(conn), // don't use conn::close, the cleanup must be done by the connection factory!\n                transactionhandler.get(),\n                cache,\n                conn);\n\n            for (JdbiPlugin p : plugins) {\n                h = p.customizeHandle(h);\n            }\n            LOG.trace(\"Jdbi [{}] obtain handle [{}] in {}ms\", this, h, MILLISECONDS.convert(stop - start, NANOSECONDS));\n            return h;\n        } catch (SQLException e) {\n            throw new ConnectionException(e);\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param callback A callback which will receive an open Handle\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {\n        if (threadHandleSupplier.get() != null) {\n            return callback.withHandle(threadHandleSupplier.get().getHandle());\n        }\n\n        try (Handle h = this.open()) {\n            threadHandleSupplier.set(new ConstantHandleSupplier(h));\n            return callback.withHandle(h);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param consumer A callback which will receive an open Handle\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useHandle(final HandleConsumer<X> consumer) throws X {\n        withHandle(consumer.asCallback());\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.<R, X>inTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final TransactionIsolationLevel level, final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(level, callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final TransactionIsolationLevel level, final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(level, callback));\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, yields it to a callback, and returns the result\n     * of the callback. A handle is opened if needed by the extension, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension.\n     * @param callback      a callback which will receive the extension.\n     * @param <R> the return type\n     * @param <E> the extension type\n     * @param <X> the exception type optionally thrown by the callback\n     * @return the value returned by the callback.\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension\n     *                                  type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <R, E, X extends Exception> R withExtension(Class<E> extensionType, ExtensionCallback<R, E, X> callback)\n            throws X {\n        if (threadHandleSupplier.get() != null) {\n            return callWithExtension(extensionType, callback, threadHandleSupplier.get());\n        }\n\n        try (LazyHandleSupplier handleSupplier = new LazyHandleSupplier(this, config)) {\n            threadHandleSupplier.set(handleSupplier);\n            return callWithExtension(extensionType, callback, handleSupplier);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    private <R, E, X extends Exception> R callWithExtension(Class<E> extensionType,\n                                                            ExtensionCallback<R, E, X> callback,\n                                                            HandleSupplier handle) throws X {\n        E extension = getConfig(Extensions.class)\n            .findFor(extensionType, handle)\n            .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n\n        return callback.withExtension(extension);\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, and yields it to a callback. A handle is opened\n     * if needed by the extention, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension\n     * @param callback      a callback which will receive the extension\n     * @param <E>           the extension type\n     * @param <X>           the exception type optionally thrown by the callback\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <E, X extends Exception> void useExtension(Class<E> extensionType, ExtensionConsumer<E, X> callback)\n            throws X {\n        withExtension(extensionType, extension -> {\n            callback.useExtension(extension);\n            return null;\n        });\n    }\n\n    /**\n     * Creates an extension instance that uses the current {@link Jdbi} instance for database operations.\n     *\n     * @param extensionType the type of extension. Must be a public interface type.\n     * @param <E> the extension type\n     *\n     * @return an extension which opens and closes handles (as needed) for individual method calls. Only public\n     * interface types may be used as on-demand extensions.\n     */\n    public <E> E onDemand(Class<E> extensionType) {\n        if (!extensionType.isInterface()) {\n            throw new IllegalArgumentException(\"On-demand extensions are only supported for interfaces.\");\n        }\n        if (!getConfig(Extensions.class).hasExtensionFor(extensionType)) {\n            throw new NoSuchExtensionException(\"Extension not found: \" + extensionType);\n        }\n\n        return getConfig(OnDemandExtensions.class).create(this, extensionType);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceLoader;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.sql.DataSource;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionCallback;\nimport org.jdbi.v3.core.extension.ExtensionConsumer;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.core.statement.DefaultStatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilderFactory;\nimport org.jdbi.v3.core.transaction.LocalTransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * Main entry point; configurable wrapper around a JDBC {@link DataSource}.\n * Use it to obtain Handle instances and provide configuration\n * for all handles obtained from it.\n */\npublic class Jdbi implements Configurable<Jdbi> {\n    private static final Logger LOG = LoggerFactory.getLogger(Jdbi.class);\n\n    private final ConfigRegistry config = new ConfigRegistry();\n\n    private final ConnectionFactory connectionFactory;\n    private final AtomicReference<TransactionHandler> transactionhandler = new AtomicReference<>(LocalTransactionHandler.binding());\n    private final AtomicReference<StatementBuilderFactory> statementBuilderFactory = new AtomicReference<>(DefaultStatementBuilder.FACTORY);\n\n    private final CopyOnWriteArrayList<JdbiPlugin> plugins = new CopyOnWriteArrayList<>();\n\n    @SuppressWarnings(\"ThreadLocalUsage\")\n    private final ThreadLocal<HandleSupplier> threadHandleSupplier = new ThreadLocal<>();\n\n    private Jdbi(ConnectionFactory connectionFactory) {\n        Objects.requireNonNull(connectionFactory, \"null connectionFactory\");\n        this.connectionFactory = connectionFactory;\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link Connection}.\n     *\n     * @param connection A {@link Connection} object.\n     *\n     * @return A {@link Jdbi} instance that uses a single database connection.\n     */\n    public static Jdbi create(Connection connection) {\n        return create(new SingleConnectionFactory(connection));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link DataSource}.\n     *\n     * @param dataSource the data source.\n     *\n     * @return a Jdbi which uses the given data source as a connection factory.\n     */\n    public static Jdbi create(DataSource dataSource) {\n        return create(dataSource::getConnection);\n    }\n\n    /**\n     * Factory used to allow for obtaining a Connection in a customized manner.\n     *\n     * <p>\n     * The {@link ConnectionFactory#openConnection()} method will be invoked to obtain a connection instance\n     * whenever a Handle is opened.\n     * <\/p>\n     *\n     * @param connectionFactory Provides JDBC connections to Handle instances\n     *\n     * @return a Jdbi which uses the given connection factory.\n     */\n    public static Jdbi create(ConnectionFactory connectionFactory) {\n        return new Jdbi(connectionFactory);\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url A JDBC URL for connections.\n     *\n     * @return a Jdbi which uses{@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url) {\n        Objects.requireNonNull(url, \"null url\");\n        return create(() -> DriverManager.getConnection(url));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url   JDBC URL for connections\n     * @param properties Properties to pass to DriverManager.getConnection(url, props) for each new handle\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final Properties properties) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(properties, \"null properties\");\n        return create(() -> DriverManager.getConnection(url, properties));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url      JDBC URL for connections\n     * @param username User name for connection authentication\n     * @param password Password for connection authentication\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final String username, final String password) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(username, \"null username\");\n        Objects.requireNonNull(password, \"null password\");\n        return create(() -> DriverManager.getConnection(url, username, password));\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a specific data source\n     *\n     * @param dataSource the JDBC data source.\n     *\n     * @return Handle using a Connection obtained from the provided DataSource\n     */\n    public static Handle open(DataSource dataSource) {\n        return create(dataSource).open();\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a {@link ConnectionFactory}.\n     *\n     * @param connectionFactory the connection factory\n     *\n     * @return Handle using a Connection obtained from the provided connection factory\n     */\n    public static Handle open(ConnectionFactory connectionFactory) {\n        return create(connectionFactory).open();\n    }\n\n    /**\n     * Create a Handle wrapping a particular JDBC Connection\n     *\n     * @param connection the JDBC connection\n     *\n     * @return Handle bound to connection\n     */\n    public static Handle open(final Connection connection) {\n        Objects.requireNonNull(connection, \"null connection\");\n        return create(() -> connection).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url JDBC Url\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url) {\n        return create(url).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url      JDBC Url\n     * @param username JDBC username for authentication\n     * @param password JDBC password for authentication\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final String username, final String password) {\n        return create(url, username, password).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url   JDBC Url\n     * @param props JDBC properties\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final Properties props) {\n        return create(url, props).open();\n    }\n\n    /**\n     * Use the {@link ServiceLoader} API to detect and install plugins automagically.\n     * Some people consider this feature dangerous; some consider it essential --\n     * use at your own risk.\n     * @return this\n     */\n    public Jdbi installPlugins() {\n        ServiceLoader.load(JdbiPlugin.class).forEach(this::installPlugin);\n        LOG.debug(\"Automatically installed plugins {}\", plugins);\n        return this;\n    }\n\n    /**\n     * Install a given {@link JdbiPlugin} instance that will configure any\n     * provided {@link Handle} instances.\n     * @param plugin the plugin to install\n     * @return this\n     */\n    public Jdbi installPlugin(JdbiPlugin plugin) {\n        if (plugins.addIfAbsent(plugin)) {\n            Unchecked.consumer(plugin::customizeJdbi).accept(this);\n        }\n        return this;\n    }\n\n    /**\n     * Allows customization of how prepared statements are created. When a Handle is created\n     * against this Jdbi instance the factory will be used to create a StatementBuilder for\n     * that specific handle. When the handle is closed, the StatementBuilder's close method\n     * will be invoked.\n     *\n     * @param factory the new statement builder factory.\n     * @return this\n     */\n    public Jdbi setStatementBuilderFactory(StatementBuilderFactory factory) {\n        this.statementBuilderFactory.set(factory);\n        return this;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilderFactory}.\n     *\n     * @return the current {@link StatementBuilderFactory}\n     */\n    public StatementBuilderFactory getStatementBuilderFactory() {\n        return this.statementBuilderFactory.get();\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return config;\n    }\n\n    /**\n     * Specify the TransactionHandler instance to use. This allows overriding\n     * transaction semantics, or mapping into different transaction\n     * management systems.\n     * <p>\n     * The default version uses local transactions on the database Connection\n     * instances obtained.\n     * <\/p>\n     *\n     * @param handler The TransactionHandler to use for all Handle instances obtained\n     *                from this Jdbi\n     * @return this\n     */\n    public Jdbi setTransactionHandler(TransactionHandler handler) {\n        Objects.requireNonNull(handler, \"null transaction handler\");\n        this.transactionhandler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link TransactionHandler}.\n     *\n     * @return the {@link TransactionHandler}\n     */\n    public TransactionHandler getTransactionHandler() {\n        return this.transactionhandler.get();\n    }\n\n    /**\n     * Obtain a Handle to the data source wrapped by this Jdbi instance.\n     * You own this expensive resource and are required to close it or\n     * risk leaks.  Using a {@code try-with-resources} block is recommended.\n     *\n     * @return an open Handle instance\n     * @see #useHandle(HandleConsumer)\n     * @see #withHandle(HandleCallback)\n     */\n    public Handle open() {\n        try {\n            final long start = System.nanoTime();\n            @SuppressWarnings(\"PMD.CloseResource\")\n            Connection conn = Objects.requireNonNull(connectionFactory.openConnection(),\n                    () -> \"Connection factory \" + connectionFactory + \" returned a null connection\");\n            final long stop = System.nanoTime();\n\n            for (JdbiPlugin p : plugins) {\n                conn = p.customizeConnection(conn);\n            }\n\n            StatementBuilder cache = statementBuilderFactory.get().createStatementBuilder(conn);\n\n            Handle h = Handle.createHandle(this,\n                connectionFactory.getCleanableFor(conn), // don't use conn::close, the cleanup must be done by the connection factory!\n                transactionhandler.get(),\n                cache,\n                conn);\n\n            for (JdbiPlugin p : plugins) {\n                h = p.customizeHandle(h);\n            }\n            LOG.trace(\"Jdbi [{}] obtain handle [{}] in {}ms\", this, h, MILLISECONDS.convert(stop - start, NANOSECONDS));\n            return h;\n        } catch (SQLException e) {\n            throw new ConnectionException(e);\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param callback A callback which will receive an open Handle\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {\n\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n\n        if (handleSupplier != null) {\n            return callback.withHandle(handleSupplier.getHandle());\n        }\n\n        try (Handle h = this.open()) {\n            handleSupplier = ConstantHandleSupplier.of(h);\n            threadHandleSupplier.set(handleSupplier);\n            return callback.withHandle(h);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param consumer A callback which will receive an open Handle\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useHandle(final HandleConsumer<X> consumer) throws X {\n        withHandle(consumer.asCallback());\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.<R, X>inTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final TransactionIsolationLevel level, final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(level, callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final TransactionIsolationLevel level, final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(level, callback));\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, yields it to a callback, and returns the result\n     * of the callback. A handle is opened if needed by the extension, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension.\n     * @param callback      a callback which will receive the extension.\n     * @param <R> the return type\n     * @param <E> the extension type\n     * @param <X> the exception type optionally thrown by the callback\n     * @return the value returned by the callback.\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension\n     *                                  type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <R, E, X extends Exception> R withExtension(Class<E> extensionType, ExtensionCallback<R, E, X> callback)\n            throws X {\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n        if (handleSupplier != null) {\n            return callWithExtension(extensionType, callback, handleSupplier);\n        }\n\n        try (LazyHandleSupplier lazyHandleSupplier = new LazyHandleSupplier(this)) {\n            threadHandleSupplier.set(lazyHandleSupplier);\n            return callWithExtension(extensionType, callback, lazyHandleSupplier);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    private <R, E, X extends Exception> R callWithExtension(Class<E> extensionType,\n                                                            ExtensionCallback<R, E, X> callback,\n                                                            HandleSupplier handle) throws X {\n        E extension = getConfig(Extensions.class)\n            .findFor(extensionType, handle)\n            .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n\n        return callback.withExtension(extension);\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, and yields it to a callback. A handle is opened\n     * if needed by the extention, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension\n     * @param callback      a callback which will receive the extension\n     * @param <E>           the extension type\n     * @param <X>           the exception type optionally thrown by the callback\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <E, X extends Exception> void useExtension(Class<E> extensionType, ExtensionConsumer<E, X> callback)\n            throws X {\n        withExtension(extensionType, extension -> {\n            callback.useExtension(extension);\n            return null;\n        });\n    }\n\n    /**\n     * Creates an extension instance that uses the current {@link Jdbi} instance for database operations.\n     *\n     * @param extensionType the type of extension. Must be a public interface type.\n     * @param <E> the extension type\n     *\n     * @return an extension which opens and closes handles (as needed) for individual method calls. Only public\n     * interface types may be used as on-demand extensions.\n     */\n    public <E> E onDemand(Class<E> extensionType) {\n        if (!extensionType.isInterface()) {\n            throw new IllegalArgumentException(\"On-demand extensions are only supported for interfaces.\");\n        }\n        if (!getConfig(Extensions.class).hasExtensionFor(extensionType)) {\n            throw new NoSuchExtensionException(\"Extension not found: \" + extensionType);\n        }\n\n        return getConfig(OnDemandExtensions.class).create(this, extensionType);\n    }\n}\n","lineNo":358}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceLoader;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.sql.DataSource;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionCallback;\nimport org.jdbi.v3.core.extension.ExtensionConsumer;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.core.statement.DefaultStatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilderFactory;\nimport org.jdbi.v3.core.transaction.LocalTransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * Main entry point; configurable wrapper around a JDBC {@link DataSource}.\n * Use it to obtain Handle instances and provide configuration\n * for all handles obtained from it.\n */\npublic class Jdbi implements Configurable<Jdbi> {\n    private static final Logger LOG = LoggerFactory.getLogger(Jdbi.class);\n\n    private final ConfigRegistry config = new ConfigRegistry();\n\n    private final ConnectionFactory connectionFactory;\n    private final AtomicReference<TransactionHandler> transactionhandler = new AtomicReference<>(LocalTransactionHandler.binding());\n    private final AtomicReference<StatementBuilderFactory> statementBuilderFactory = new AtomicReference<>(DefaultStatementBuilder.FACTORY);\n\n    private final CopyOnWriteArrayList<JdbiPlugin> plugins = new CopyOnWriteArrayList<>();\n\n    @SuppressWarnings(\"ThreadLocalUsage\")\n    private final ThreadLocal<HandleSupplier> threadHandleSupplier = new ThreadLocal<>();\n\n    private Jdbi(ConnectionFactory connectionFactory) {\n        Objects.requireNonNull(connectionFactory, \"null connectionFactory\");\n        this.connectionFactory = connectionFactory;\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link Connection}.\n     *\n     * @param connection A {@link Connection} object.\n     *\n     * @return A {@link Jdbi} instance that uses a single database connection.\n     */\n    public static Jdbi create(Connection connection) {\n        return create(new SingleConnectionFactory(connection));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link DataSource}.\n     *\n     * @param dataSource the data source.\n     *\n     * @return a Jdbi which uses the given data source as a connection factory.\n     */\n    public static Jdbi create(DataSource dataSource) {\n        return create(dataSource::getConnection);\n    }\n\n    /**\n     * Factory used to allow for obtaining a Connection in a customized manner.\n     *\n     * <p>\n     * The {@link ConnectionFactory#openConnection()} method will be invoked to obtain a connection instance\n     * whenever a Handle is opened.\n     * <\/p>\n     *\n     * @param connectionFactory Provides JDBC connections to Handle instances\n     *\n     * @return a Jdbi which uses the given connection factory.\n     */\n    public static Jdbi create(ConnectionFactory connectionFactory) {\n        return new Jdbi(connectionFactory);\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url A JDBC URL for connections.\n     *\n     * @return a Jdbi which uses{@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url) {\n        Objects.requireNonNull(url, \"null url\");\n        return create(() -> DriverManager.getConnection(url));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url   JDBC URL for connections\n     * @param properties Properties to pass to DriverManager.getConnection(url, props) for each new handle\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final Properties properties) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(properties, \"null properties\");\n        return create(() -> DriverManager.getConnection(url, properties));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url      JDBC URL for connections\n     * @param username User name for connection authentication\n     * @param password Password for connection authentication\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final String username, final String password) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(username, \"null username\");\n        Objects.requireNonNull(password, \"null password\");\n        return create(() -> DriverManager.getConnection(url, username, password));\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a specific data source\n     *\n     * @param dataSource the JDBC data source.\n     *\n     * @return Handle using a Connection obtained from the provided DataSource\n     */\n    public static Handle open(DataSource dataSource) {\n        return create(dataSource).open();\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a {@link ConnectionFactory}.\n     *\n     * @param connectionFactory the connection factory\n     *\n     * @return Handle using a Connection obtained from the provided connection factory\n     */\n    public static Handle open(ConnectionFactory connectionFactory) {\n        return create(connectionFactory).open();\n    }\n\n    /**\n     * Create a Handle wrapping a particular JDBC Connection\n     *\n     * @param connection the JDBC connection\n     *\n     * @return Handle bound to connection\n     */\n    public static Handle open(final Connection connection) {\n        Objects.requireNonNull(connection, \"null connection\");\n        return create(() -> connection).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url JDBC Url\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url) {\n        return create(url).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url      JDBC Url\n     * @param username JDBC username for authentication\n     * @param password JDBC password for authentication\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final String username, final String password) {\n        return create(url, username, password).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url   JDBC Url\n     * @param props JDBC properties\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final Properties props) {\n        return create(url, props).open();\n    }\n\n    /**\n     * Use the {@link ServiceLoader} API to detect and install plugins automagically.\n     * Some people consider this feature dangerous; some consider it essential --\n     * use at your own risk.\n     * @return this\n     */\n    public Jdbi installPlugins() {\n        ServiceLoader.load(JdbiPlugin.class).forEach(this::installPlugin);\n        LOG.debug(\"Automatically installed plugins {}\", plugins);\n        return this;\n    }\n\n    /**\n     * Install a given {@link JdbiPlugin} instance that will configure any\n     * provided {@link Handle} instances.\n     * @param plugin the plugin to install\n     * @return this\n     */\n    public Jdbi installPlugin(JdbiPlugin plugin) {\n        if (plugins.addIfAbsent(plugin)) {\n            Unchecked.consumer(plugin::customizeJdbi).accept(this);\n        }\n        return this;\n    }\n\n    /**\n     * Allows customization of how prepared statements are created. When a Handle is created\n     * against this Jdbi instance the factory will be used to create a StatementBuilder for\n     * that specific handle. When the handle is closed, the StatementBuilder's close method\n     * will be invoked.\n     *\n     * @param factory the new statement builder factory.\n     * @return this\n     */\n    public Jdbi setStatementBuilderFactory(StatementBuilderFactory factory) {\n        this.statementBuilderFactory.set(factory);\n        return this;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilderFactory}.\n     *\n     * @return the current {@link StatementBuilderFactory}\n     */\n    public StatementBuilderFactory getStatementBuilderFactory() {\n        return this.statementBuilderFactory.get();\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return config;\n    }\n\n    /**\n     * Specify the TransactionHandler instance to use. This allows overriding\n     * transaction semantics, or mapping into different transaction\n     * management systems.\n     * <p>\n     * The default version uses local transactions on the database Connection\n     * instances obtained.\n     * <\/p>\n     *\n     * @param handler The TransactionHandler to use for all Handle instances obtained\n     *                from this Jdbi\n     * @return this\n     */\n    public Jdbi setTransactionHandler(TransactionHandler handler) {\n        Objects.requireNonNull(handler, \"null transaction handler\");\n        this.transactionhandler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link TransactionHandler}.\n     *\n     * @return the {@link TransactionHandler}\n     */\n    public TransactionHandler getTransactionHandler() {\n        return this.transactionhandler.get();\n    }\n\n    /**\n     * Obtain a Handle to the data source wrapped by this Jdbi instance.\n     * You own this expensive resource and are required to close it or\n     * risk leaks.  Using a {@code try-with-resources} block is recommended.\n     *\n     * @return an open Handle instance\n     * @see #useHandle(HandleConsumer)\n     * @see #withHandle(HandleCallback)\n     */\n    public Handle open() {\n        try {\n            final long start = System.nanoTime();\n            @SuppressWarnings(\"PMD.CloseResource\")\n            Connection conn = Objects.requireNonNull(connectionFactory.openConnection(),\n                    () -> \"Connection factory \" + connectionFactory + \" returned a null connection\");\n            final long stop = System.nanoTime();\n\n            for (JdbiPlugin p : plugins) {\n                conn = p.customizeConnection(conn);\n            }\n\n            StatementBuilder cache = statementBuilderFactory.get().createStatementBuilder(conn);\n\n            Handle h = Handle.createHandle(this,\n                connectionFactory.getCleanableFor(conn), // don't use conn::close, the cleanup must be done by the connection factory!\n                transactionhandler.get(),\n                cache,\n                conn);\n\n            for (JdbiPlugin p : plugins) {\n                h = p.customizeHandle(h);\n            }\n            LOG.trace(\"Jdbi [{}] obtain handle [{}] in {}ms\", this, h, MILLISECONDS.convert(stop - start, NANOSECONDS));\n            return h;\n        } catch (SQLException e) {\n            throw new ConnectionException(e);\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param callback A callback which will receive an open Handle\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {\n        if (threadHandleSupplier.get() != null) {\n            return callback.withHandle(threadHandleSupplier.get().getHandle());\n        }\n\n        try (Handle h = this.open()) {\n            threadHandleSupplier.set(new ConstantHandleSupplier(h));\n            return callback.withHandle(h);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param consumer A callback which will receive an open Handle\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useHandle(final HandleConsumer<X> consumer) throws X {\n        withHandle(consumer.asCallback());\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.<R, X>inTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final TransactionIsolationLevel level, final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(level, callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final TransactionIsolationLevel level, final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(level, callback));\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, yields it to a callback, and returns the result\n     * of the callback. A handle is opened if needed by the extension, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension.\n     * @param callback      a callback which will receive the extension.\n     * @param <R> the return type\n     * @param <E> the extension type\n     * @param <X> the exception type optionally thrown by the callback\n     * @return the value returned by the callback.\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension\n     *                                  type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <R, E, X extends Exception> R withExtension(Class<E> extensionType, ExtensionCallback<R, E, X> callback)\n            throws X {\n        if (threadHandleSupplier.get() != null) {\n            return callWithExtension(extensionType, callback, threadHandleSupplier.get());\n        }\n\n        try (LazyHandleSupplier handleSupplier = new LazyHandleSupplier(this, config)) {\n            threadHandleSupplier.set(handleSupplier);\n            return callWithExtension(extensionType, callback, handleSupplier);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    private <R, E, X extends Exception> R callWithExtension(Class<E> extensionType,\n                                                            ExtensionCallback<R, E, X> callback,\n                                                            HandleSupplier handle) throws X {\n        E extension = getConfig(Extensions.class)\n            .findFor(extensionType, handle)\n            .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n\n        return callback.withExtension(extension);\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, and yields it to a callback. A handle is opened\n     * if needed by the extention, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension\n     * @param callback      a callback which will receive the extension\n     * @param <E>           the extension type\n     * @param <X>           the exception type optionally thrown by the callback\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <E, X extends Exception> void useExtension(Class<E> extensionType, ExtensionConsumer<E, X> callback)\n            throws X {\n        withExtension(extensionType, extension -> {\n            callback.useExtension(extension);\n            return null;\n        });\n    }\n\n    /**\n     * Creates an extension instance that uses the current {@link Jdbi} instance for database operations.\n     *\n     * @param extensionType the type of extension. Must be a public interface type.\n     * @param <E> the extension type\n     *\n     * @return an extension which opens and closes handles (as needed) for individual method calls. Only public\n     * interface types may be used as on-demand extensions.\n     */\n    public <E> E onDemand(Class<E> extensionType) {\n        if (!extensionType.isInterface()) {\n            throw new IllegalArgumentException(\"On-demand extensions are only supported for interfaces.\");\n        }\n        if (!getConfig(Extensions.class).hasExtensionFor(extensionType)) {\n            throw new NoSuchExtensionException(\"Extension not found: \" + extensionType);\n        }\n\n        return getConfig(OnDemandExtensions.class).create(this, extensionType);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceLoader;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.sql.DataSource;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionCallback;\nimport org.jdbi.v3.core.extension.ExtensionConsumer;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.core.statement.DefaultStatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.StatementBuilderFactory;\nimport org.jdbi.v3.core.transaction.LocalTransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * Main entry point; configurable wrapper around a JDBC {@link DataSource}.\n * Use it to obtain Handle instances and provide configuration\n * for all handles obtained from it.\n */\npublic class Jdbi implements Configurable<Jdbi> {\n    private static final Logger LOG = LoggerFactory.getLogger(Jdbi.class);\n\n    private final ConfigRegistry config = new ConfigRegistry();\n\n    private final ConnectionFactory connectionFactory;\n    private final AtomicReference<TransactionHandler> transactionhandler = new AtomicReference<>(LocalTransactionHandler.binding());\n    private final AtomicReference<StatementBuilderFactory> statementBuilderFactory = new AtomicReference<>(DefaultStatementBuilder.FACTORY);\n\n    private final CopyOnWriteArrayList<JdbiPlugin> plugins = new CopyOnWriteArrayList<>();\n\n    @SuppressWarnings(\"ThreadLocalUsage\")\n    private final ThreadLocal<HandleSupplier> threadHandleSupplier = new ThreadLocal<>();\n\n    private Jdbi(ConnectionFactory connectionFactory) {\n        Objects.requireNonNull(connectionFactory, \"null connectionFactory\");\n        this.connectionFactory = connectionFactory;\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link Connection}.\n     *\n     * @param connection A {@link Connection} object.\n     *\n     * @return A {@link Jdbi} instance that uses a single database connection.\n     */\n    public static Jdbi create(Connection connection) {\n        return create(new SingleConnectionFactory(connection));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} object from a {@link DataSource}.\n     *\n     * @param dataSource the data source.\n     *\n     * @return a Jdbi which uses the given data source as a connection factory.\n     */\n    public static Jdbi create(DataSource dataSource) {\n        return create(dataSource::getConnection);\n    }\n\n    /**\n     * Factory used to allow for obtaining a Connection in a customized manner.\n     *\n     * <p>\n     * The {@link ConnectionFactory#openConnection()} method will be invoked to obtain a connection instance\n     * whenever a Handle is opened.\n     * <\/p>\n     *\n     * @param connectionFactory Provides JDBC connections to Handle instances\n     *\n     * @return a Jdbi which uses the given connection factory.\n     */\n    public static Jdbi create(ConnectionFactory connectionFactory) {\n        return new Jdbi(connectionFactory);\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url A JDBC URL for connections.\n     *\n     * @return a Jdbi which uses{@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url) {\n        Objects.requireNonNull(url, \"null url\");\n        return create(() -> DriverManager.getConnection(url));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url   JDBC URL for connections\n     * @param properties Properties to pass to DriverManager.getConnection(url, props) for each new handle\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final Properties properties) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(properties, \"null properties\");\n        return create(() -> DriverManager.getConnection(url, properties));\n    }\n\n    /**\n     * Creates a new {@link Jdbi} instance from a database URL.\n     *\n     * @param url      JDBC URL for connections\n     * @param username User name for connection authentication\n     * @param password Password for connection authentication\n     *\n     * @return a Jdbi which uses {@link DriverManager} as a connection factory.\n     */\n    public static Jdbi create(final String url, final String username, final String password) {\n        Objects.requireNonNull(url, \"null url\");\n        Objects.requireNonNull(username, \"null username\");\n        Objects.requireNonNull(password, \"null password\");\n        return create(() -> DriverManager.getConnection(url, username, password));\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a specific data source\n     *\n     * @param dataSource the JDBC data source.\n     *\n     * @return Handle using a Connection obtained from the provided DataSource\n     */\n    public static Handle open(DataSource dataSource) {\n        return create(dataSource).open();\n    }\n\n    /**\n     * Convenience method used to obtain a handle from a {@link ConnectionFactory}.\n     *\n     * @param connectionFactory the connection factory\n     *\n     * @return Handle using a Connection obtained from the provided connection factory\n     */\n    public static Handle open(ConnectionFactory connectionFactory) {\n        return create(connectionFactory).open();\n    }\n\n    /**\n     * Create a Handle wrapping a particular JDBC Connection\n     *\n     * @param connection the JDBC connection\n     *\n     * @return Handle bound to connection\n     */\n    public static Handle open(final Connection connection) {\n        Objects.requireNonNull(connection, \"null connection\");\n        return create(() -> connection).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url JDBC Url\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url) {\n        return create(url).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url      JDBC Url\n     * @param username JDBC username for authentication\n     * @param password JDBC password for authentication\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final String username, final String password) {\n        return create(url, username, password).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url   JDBC Url\n     * @param props JDBC properties\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final Properties props) {\n        return create(url, props).open();\n    }\n\n    /**\n     * Use the {@link ServiceLoader} API to detect and install plugins automagically.\n     * Some people consider this feature dangerous; some consider it essential --\n     * use at your own risk.\n     * @return this\n     */\n    public Jdbi installPlugins() {\n        ServiceLoader.load(JdbiPlugin.class).forEach(this::installPlugin);\n        LOG.debug(\"Automatically installed plugins {}\", plugins);\n        return this;\n    }\n\n    /**\n     * Install a given {@link JdbiPlugin} instance that will configure any\n     * provided {@link Handle} instances.\n     * @param plugin the plugin to install\n     * @return this\n     */\n    public Jdbi installPlugin(JdbiPlugin plugin) {\n        if (plugins.addIfAbsent(plugin)) {\n            Unchecked.consumer(plugin::customizeJdbi).accept(this);\n        }\n        return this;\n    }\n\n    /**\n     * Allows customization of how prepared statements are created. When a Handle is created\n     * against this Jdbi instance the factory will be used to create a StatementBuilder for\n     * that specific handle. When the handle is closed, the StatementBuilder's close method\n     * will be invoked.\n     *\n     * @param factory the new statement builder factory.\n     * @return this\n     */\n    public Jdbi setStatementBuilderFactory(StatementBuilderFactory factory) {\n        this.statementBuilderFactory.set(factory);\n        return this;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilderFactory}.\n     *\n     * @return the current {@link StatementBuilderFactory}\n     */\n    public StatementBuilderFactory getStatementBuilderFactory() {\n        return this.statementBuilderFactory.get();\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return config;\n    }\n\n    /**\n     * Specify the TransactionHandler instance to use. This allows overriding\n     * transaction semantics, or mapping into different transaction\n     * management systems.\n     * <p>\n     * The default version uses local transactions on the database Connection\n     * instances obtained.\n     * <\/p>\n     *\n     * @param handler The TransactionHandler to use for all Handle instances obtained\n     *                from this Jdbi\n     * @return this\n     */\n    public Jdbi setTransactionHandler(TransactionHandler handler) {\n        Objects.requireNonNull(handler, \"null transaction handler\");\n        this.transactionhandler.set(handler);\n        return this;\n    }\n\n    /**\n     * Returns the {@link TransactionHandler}.\n     *\n     * @return the {@link TransactionHandler}\n     */\n    public TransactionHandler getTransactionHandler() {\n        return this.transactionhandler.get();\n    }\n\n    /**\n     * Obtain a Handle to the data source wrapped by this Jdbi instance.\n     * You own this expensive resource and are required to close it or\n     * risk leaks.  Using a {@code try-with-resources} block is recommended.\n     *\n     * @return an open Handle instance\n     * @see #useHandle(HandleConsumer)\n     * @see #withHandle(HandleCallback)\n     */\n    public Handle open() {\n        try {\n            final long start = System.nanoTime();\n            @SuppressWarnings(\"PMD.CloseResource\")\n            Connection conn = Objects.requireNonNull(connectionFactory.openConnection(),\n                    () -> \"Connection factory \" + connectionFactory + \" returned a null connection\");\n            final long stop = System.nanoTime();\n\n            for (JdbiPlugin p : plugins) {\n                conn = p.customizeConnection(conn);\n            }\n\n            StatementBuilder cache = statementBuilderFactory.get().createStatementBuilder(conn);\n\n            Handle h = Handle.createHandle(this,\n                connectionFactory.getCleanableFor(conn), // don't use conn::close, the cleanup must be done by the connection factory!\n                transactionhandler.get(),\n                cache,\n                conn);\n\n            for (JdbiPlugin p : plugins) {\n                h = p.customizeHandle(h);\n            }\n            LOG.trace(\"Jdbi [{}] obtain handle [{}] in {}ms\", this, h, MILLISECONDS.convert(stop - start, NANOSECONDS));\n            return h;\n        } catch (SQLException e) {\n            throw new ConnectionException(e);\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param callback A callback which will receive an open Handle\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {\n\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n\n        if (handleSupplier != null) {\n            return callback.withHandle(handleSupplier.getHandle());\n        }\n\n        try (Handle h = this.open()) {\n            handleSupplier = ConstantHandleSupplier.of(h);\n            threadHandleSupplier.set(handleSupplier);\n            return callback.withHandle(h);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param consumer A callback which will receive an open Handle\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useHandle(final HandleConsumer<X> consumer) throws X {\n        withHandle(consumer.asCallback());\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.<R, X>inTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <R> type returned by the callback\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @return the value returned by callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(final TransactionIsolationLevel level, final HandleCallback<R, X> callback) throws X {\n        return withHandle(handle -> handle.inTransaction(level, callback));\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients. The handle will be in a transaction when the callback is invoked, and\n     * that transaction will be committed if the callback finishes normally, or rolled back if the\n     * callback raises an exception.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     *\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback A callback which will receive an open Handle, in a transaction\n     * @param <X> exception type thrown by the callback, if any.\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final TransactionIsolationLevel level, final HandleConsumer<X> callback) throws X {\n        useHandle(handle -> handle.useTransaction(level, callback));\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, yields it to a callback, and returns the result\n     * of the callback. A handle is opened if needed by the extension, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension.\n     * @param callback      a callback which will receive the extension.\n     * @param <R> the return type\n     * @param <E> the extension type\n     * @param <X> the exception type optionally thrown by the callback\n     * @return the value returned by the callback.\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension\n     *                                  type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <R, E, X extends Exception> R withExtension(Class<E> extensionType, ExtensionCallback<R, E, X> callback)\n            throws X {\n        HandleSupplier handleSupplier = threadHandleSupplier.get();\n        if (handleSupplier != null) {\n            return callWithExtension(extensionType, callback, handleSupplier);\n        }\n\n        try (LazyHandleSupplier lazyHandleSupplier = new LazyHandleSupplier(this)) {\n            threadHandleSupplier.set(lazyHandleSupplier);\n            return callWithExtension(extensionType, callback, lazyHandleSupplier);\n        } finally {\n            threadHandleSupplier.remove();\n        }\n    }\n\n    private <R, E, X extends Exception> R callWithExtension(Class<E> extensionType,\n                                                            ExtensionCallback<R, E, X> callback,\n                                                            HandleSupplier handle) throws X {\n        E extension = getConfig(Extensions.class)\n            .findFor(extensionType, handle)\n            .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n\n        return callback.withExtension(extension);\n    }\n\n    /**\n     * A convenience method which opens an extension of the given type, and yields it to a callback. A handle is opened\n     * if needed by the extention, and closed before returning to the caller.\n     *\n     * @param extensionType the type of extension\n     * @param callback      a callback which will receive the extension\n     * @param <E>           the extension type\n     * @param <X>           the exception type optionally thrown by the callback\n     * @throws NoSuchExtensionException if no {@link ExtensionFactory} is registered which supports the given extension type.\n     * @throws X                        if thrown by the callback.\n     */\n    public <E, X extends Exception> void useExtension(Class<E> extensionType, ExtensionConsumer<E, X> callback)\n            throws X {\n        withExtension(extensionType, extension -> {\n            callback.useExtension(extension);\n            return null;\n        });\n    }\n\n    /**\n     * Creates an extension instance that uses the current {@link Jdbi} instance for database operations.\n     *\n     * @param extensionType the type of extension. Must be a public interface type.\n     * @param <E> the extension type\n     *\n     * @return an extension which opens and closes handles (as needed) for individual method calls. Only public\n     * interface types may be used as on-demand extensions.\n     */\n    public <E> E onDemand(Class<E> extensionType) {\n        if (!extensionType.isInterface()) {\n            throw new IllegalArgumentException(\"On-demand extensions are only supported for interfaces.\");\n        }\n        if (!getConfig(Extensions.class).hasExtensionFor(extensionType)) {\n            throw new NoSuchExtensionException(\"Extension not found: \" + extensionType);\n        }\n\n        return getConfig(OnDemandExtensions.class).create(this, extensionType);\n    }\n}\n","lineNo":482}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.io.Closeable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\nimport javax.annotation.concurrent.GuardedBy;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionMethod;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.statement.Batch;\nimport org.jdbi.v3.core.statement.Call;\nimport org.jdbi.v3.core.statement.Cleanable;\nimport org.jdbi.v3.core.statement.MetaData;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.jdbi.v3.core.statement.Query;\nimport org.jdbi.v3.core.statement.Script;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.Update;\nimport org.jdbi.v3.core.transaction.TransactionException;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.jdbi.v3.core.transaction.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.meta.Beta;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * This represents a connection to the database system. It is a wrapper around\n * a JDBC Connection object.  Handle provides essential methods for transaction\n * management, statement creation, and other operations tied to the database session.\n */\npublic class Handle implements Closeable, Configurable<Handle> {\n    private static final Logger LOG = LoggerFactory.getLogger(Handle.class);\n\n    private final Jdbi jdbi;\n    private final Cleanable closer;\n    private final TransactionHandler transactions;\n    private final Connection connection;\n    private final boolean forceEndTransactions;\n\n    private ThreadLocal<ConfigRegistry> localConfig;\n    private ThreadLocal<ExtensionMethod> localExtensionMethod;\n    private StatementBuilder statementBuilder;\n\n    @GuardedBy(\"transactionCallbacks\")\n    private final List<TransactionCallback> transactionCallbacks = new ArrayList<>();\n\n    private final Set<HandleListener> handleListeners;\n\n    private boolean closed = false;\n\n    static Handle createHandle(Jdbi jdbi,\n        ConfigRegistry localConfig,\n        Cleanable closer,\n        TransactionHandler transactions,\n        StatementBuilder statementBuilder,\n        Connection connection) throws SQLException {\n        Handle handle = new Handle(jdbi, localConfig, closer, transactions, statementBuilder, connection);\n\n        handle.notifyHandleCreated();\n        return handle;\n    }\n\n    private Handle(Jdbi jdbi,\n           ConfigRegistry localConfig,\n           Cleanable closer,\n           TransactionHandler transactions,\n           StatementBuilder statementBuilder,\n           Connection connection) throws SQLException {\n        this.jdbi = jdbi;\n        this.closer = closer;\n        this.connection = connection;\n\n        this.localConfig = ThreadLocal.withInitial(() -> localConfig);\n        this.localExtensionMethod = new ThreadLocal<>();\n        this.statementBuilder = statementBuilder;\n        this.transactions = transactions.specialize(this);\n        this.forceEndTransactions = !transactions.isInTransaction(this);\n\n        this.handleListeners = new CopyOnWriteArraySet<>(localConfig.get(Handles.class).getListeners());\n    }\n\n    public Jdbi getJdbi() {\n        return jdbi;\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return localConfig.get();\n    }\n\n    void setConfig(ConfigRegistry config) {\n        this.localConfig.set(config);\n    }\n\n    void setLocalConfig(ThreadLocal<ConfigRegistry> configThreadLocal) {\n        // Without explicit remove the Tomcats thread-local leak detector gives superfluous warnings\n        this.localConfig.remove();\n        this.localConfig = configThreadLocal;\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses.\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    public Connection getConnection() {\n        return this.connection;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilder}.\n     *\n     * @return the current {@link StatementBuilder}\n     */\n    public StatementBuilder getStatementBuilder() {\n        return statementBuilder;\n    }\n\n    /**\n     * Specify the statement builder to use for this handle.\n     *\n     * @param builder StatementBuilder to be used\n     * @return this\n     */\n    public Handle setStatementBuilder(StatementBuilder builder) {\n        this.statementBuilder = builder;\n        return this;\n    }\n\n    /**\n     * Add a specific {@link HandleListener} which is called for specific events for this Handle. Note that\n     * it is not possible to add a listener that wants to implement {@link HandleListener#handleCreated} this way\n     * as the handle has already been created. Use {@link Handles#addListener} in this case.\n     * <br>\n     * A listener added through this call is specific to the handle and not shared with other handles.\n     *\n     * @param handleListener A {@link HandleListener} object.\n     *\n     * @return The handle itself.\n     */\n    public Handle addHandleListener(HandleListener handleListener) {\n        handleListeners.add(handleListener);\n\n        return this;\n    }\n\n    /**\n     * Remove a {@link HandleListener} from this handle.\n     * <br>\n     * Removing the listener only affects the current handle. To remove a listener for all future handles, use {@link Handles#removeListener}.\n     *\n     * @param handleListener A {@link HandleListener} object.\n     *\n     * @return The handle itself.\n     */\n    public Handle removeHandleListener(HandleListener handleListener) {\n        handleListeners.remove(handleListener);\n\n        return this;\n    }\n\n    /**\n     * Closes the handle, its connection, and any other database resources it is holding.\n     *\n     * @throws CloseException if any resources throw exception while closing\n     * @throws TransactionException if called while the handle has a transaction open. The open transaction will be\n     * rolled back.\n     */\n    @Override\n    public void close() {\n        final List<Throwable> suppressed = new ArrayList<>();\n        if (closed) {\n            return;\n        }\n\n        boolean connectionIsLive;\n\n        try {\n            connectionIsLive = !connection.isClosed();\n        } catch (SQLException e) {\n            // if the connection state can not be determined, assume that the\n            // connection is closed and ignore the exception\n            connectionIsLive = false;\n        }\n\n        boolean wasInTransaction = false;\n\n        if (connectionIsLive && forceEndTransactions && localConfig.get().get(Handles.class).isForceEndTransactions()) {\n            try {\n                wasInTransaction = isInTransaction();\n            } catch (Exception e) {\n                suppressed.add(e);\n            }\n        }\n\n        localExtensionMethod.remove();\n        localConfig.remove();\n\n        if (wasInTransaction) {\n            try {\n                rollback();\n            } catch (Exception e) {\n                suppressed.add(e);\n            }\n        }\n\n        if (connectionIsLive) {\n            try {\n                statementBuilder.close(getConnection());\n            } catch (Exception e) {\n                suppressed.add(e);\n            }\n        }\n\n        try {\n            if (connectionIsLive) {\n                closer.close();\n            }\n\n            if (!suppressed.isEmpty()) {\n                final Throwable original = suppressed.remove(0);\n                suppressed.forEach(original::addSuppressed);\n                throw new CloseException(\"Failed to clear transaction status on close\", original);\n            }\n            if (wasInTransaction) {\n                throw new TransactionException(\"Improper transaction handling detected: A Handle with an open \"\n                    + \"transaction was closed. Transactions must be explicitly committed or rolled back \"\n                    + \"before closing the Handle. \"\n                    + \"Jdbi has rolled back this transaction automatically. \"\n                    + \"This check may be disabled by calling getConfig(Handles.class).setForceEndTransactions(false).\");\n            }\n        } catch (SQLException e) {\n            CloseException ce = new CloseException(\"Unable to close Connection\", e);\n            suppressed.forEach(ce::addSuppressed);\n            throw ce;\n        } finally {\n            LOG.trace(\"Handle [{}] released\", this);\n            closed = true;\n\n            notifyHandleClosed();\n        }\n    }\n\n    /**\n     * Returns true if the {@link Handle} has been closed.\n     *\n     * @return True if the Handle is closed.\n     */\n    public boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Convenience method which creates a query with the given positional arguments.\n     *\n     * @param sql SQL or named statement\n     * @param args arguments to bind positionally\n     * @return query object\n     */\n    public Query select(CharSequence sql, Object... args) {\n        Query query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query;\n    }\n\n    /**\n     * Convenience method which creates a query with the given positional arguments. Takes a string argument for backwards compatibility reasons.\n     * @param sql SQL or named statement\n     * @param args arguments to bind positionally\n     * @return query object\n     * @see Handle#select(CharSequence, Object...)\n     */\n    public Query select(String sql, Object... args) {\n        return select((CharSequence) sql, args);\n    }\n\n    /**\n     * Execute a SQL statement, and return the number of rows affected by the statement.\n     *\n     * @param sql the SQL statement to execute, using positional parameters (if any).\n     * @param args positional arguments.\n     *\n     * @return the number of rows affected.\n     */\n    public int execute(CharSequence sql, Object... args) {\n        try (Update stmt = createUpdate(sql)) {\n            int position = 0;\n            for (Object arg : args) {\n                stmt.bind(position++, arg);\n            }\n            return stmt.execute();\n        }\n    }\n\n    /**\n     * Execute a SQL statement, and return the number of rows affected by the statement. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the SQL statement to execute, using positional parameters (if any).\n     * @param args positional arguments.\n     *\n     * @return the number of rows affected.\n     * @see Handle#execute(CharSequence, Object...)\n     */\n    public int execute(String sql, Object... args) {\n        return execute((CharSequence) sql, args);\n    }\n\n    /**\n     * Create a non-prepared (no bound parameters, but different SQL) batch statement.\n     * @return empty batch\n     * @see Handle#prepareBatch(String)\n     */\n    public Batch createBatch() {\n        return new Batch(this);\n    }\n\n    /**\n     * Prepare a batch to execute. This is for efficiently executing more than one\n     * of the same statements with different parameters bound.\n     *\n     * @param sql the batch SQL.\n     * @return a batch which can have \"statements\" added.\n     */\n    public PreparedBatch prepareBatch(CharSequence sql) {\n        return new PreparedBatch(this, sql);\n    }\n\n    /**\n     * Prepare a batch to execute. This is for efficiently executing more than one\n     * of the same statements with different parameters bound. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the batch SQL.\n     * @return a batch which can have \"statements\" added.\n     * @see Handle#prepareBatch(CharSequence)\n     */\n    public PreparedBatch prepareBatch(String sql) {\n        return prepareBatch((CharSequence) sql);\n    }\n\n    /**\n     * Create a call to a stored procedure.\n     *\n     * @param sql the stored procedure sql.\n     *\n     * @return the Call.\n     */\n    public Call createCall(CharSequence sql) {\n        return new Call(this, sql);\n    }\n\n    /**\n     * Create a call to a stored procedure. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the stored procedure sql.\n     *\n     * @return the Call.\n     * @see Handle#createCall(CharSequence)\n     */\n    public Call createCall(String sql) {\n        return createCall((CharSequence) sql);\n    }\n\n    /**\n     * Return a Query instance that executes a statement\n     * with bound parameters and maps the result set into Java types.\n     * @param sql SQL that may return results.\n     * @return a Query builder.\n     */\n    public Query createQuery(CharSequence sql) {\n        return new Query(this, sql);\n    }\n\n    /**\n     * Return a Query instance that executes a statement\n     * with bound parameters and maps the result set into Java types. Takes a string argument for backwards compatibility reasons.\n     * @param sql SQL that may return results.\n     * @return a Query builder.\n     * @see Handle#createQuery(CharSequence)\n     */\n    public Query createQuery(String sql) {\n        return createQuery((CharSequence) sql);\n    }\n\n    /**\n     * Creates a Script from the given SQL script.\n     *\n     * @param sql the SQL script.\n     *\n     * @return the created Script.\n     */\n    public Script createScript(CharSequence sql) {\n        return new Script(this, sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     *\n     * @see Handle#createScript(CharSequence)\n     */\n    public Script createScript(String sql) {\n        return createScript((CharSequence) sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     */\n    public Update createUpdate(CharSequence sql) {\n        return new Update(this, sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     *\n     * @see Handle#createUpdate(CharSequence)\n     */\n    public Update createUpdate(String sql) {\n        return createUpdate((CharSequence) sql);\n    }\n\n    /**\n     * Access database metadata that returns a {@link java.sql.ResultSet}. All methods of {@link org.jdbi.v3.core.result.ResultBearing} can be used to format\n     * and map the returned results.\n     *\n     * <pre>\n     *     List&lt;String&gt; catalogs = h.queryMetadata(DatabaseMetaData::getCatalogs)\n     *                                      .mapTo(String.class)\n     *                                      .list();\n     * <\/pre>\n     * <p>\n     * returns the list of catalogs from the current database.\n     *\n     * @param metadataFunction Maps the provided {@link java.sql.DatabaseMetaData} object onto a {@link java.sql.ResultSet} object.\n     * @return The metadata builder.\n     */\n    public ResultBearing queryMetadata(MetaData.MetaDataResultSetProvider metadataFunction) {\n        return new MetaData(this, metadataFunction);\n    }\n\n    /**\n     * Access all database metadata that returns simple values.\n     *\n     * <pre>\n     *     boolean supportsTransactions = handle.queryMetadata(DatabaseMetaData::supportsTransactions);\n     * <\/pre>\n     *\n     * @param metadataFunction Maps the provided {@link java.sql.DatabaseMetaData} object to a response object.\n     * @return The response object.\n     */\n    public <T> T queryMetadata(MetaData.MetaDataValueProvider<T> metadataFunction) {\n        try (MetaData metadata = new MetaData(this, metadataFunction)) {\n            return metadata.execute();\n        }\n    }\n\n    /**\n     * Returns whether the handle is in a transaction. Delegates to the underlying {@link TransactionHandler}.\n     *\n     * @return True if the handle is in a transaction.\n     */\n    public boolean isInTransaction() {\n        return transactions.isInTransaction(this);\n    }\n\n    /**\n     * Start a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle begin() {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle commit() {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, msSince(start));\n        drainCallbacks()\n                .forEach(TransactionCallback::afterCommit);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle rollback() {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, msSince(start));\n        drainCallbacks()\n                .forEach(TransactionCallback::afterRollback);\n        return this;\n    }\n\n    /**\n     * Execute an action the next time this Handle commits, unless it is rolled back first.\n     * @param afterCommit the action to execute after commit\n     * @return this Handle\n     */\n    @Beta\n    public Handle afterCommit(Runnable afterCommit) {\n        return addTransactionCallback(new TransactionCallback() {\n            @Override\n            public void afterCommit() {\n                afterCommit.run();\n            }\n        });\n    }\n\n    /**\n     * Execute an action the next time this Handle rolls back, unless it is committed first.\n     * @param afterRollback the action to execute after rollback\n     * @return this Handle\n     */\n    @Beta\n    public Handle afterRollback(Runnable afterRollback) {\n       return addTransactionCallback(new TransactionCallback() {\n            @Override\n            public void afterRollback() {\n                afterRollback.run();\n            }\n        });\n    }\n\n    List<TransactionCallback> drainCallbacks() {\n        synchronized (transactionCallbacks) {\n            List<TransactionCallback> result = new ArrayList<>(transactionCallbacks);\n            transactionCallbacks.clear();\n            return result;\n        }\n    }\n\n    Handle addTransactionCallback(TransactionCallback cb) {\n        if (!isInTransaction()) {\n            throw new IllegalStateException(\"Handle must be in transaction\");\n        }\n        synchronized (transactionCallbacks) {\n            transactionCallbacks.add(cb);\n        }\n        return this;\n    }\n\n    /**\n     * Rollback a transaction to a named savepoint.\n     *\n     * @param savepointName the name of the savepoint, previously declared with {@link Handle#savepoint}\n     *\n     * @return the same handle\n     */\n    public Handle rollbackToSavepoint(String savepointName) {\n        final long start = System.nanoTime();\n        transactions.rollbackToSavepoint(this, savepointName);\n        LOG.trace(\"Handle [{}] rollback to savepoint \\\"{}\\\" in {}ms\", this, savepointName, msSince(start));\n        return this;\n    }\n\n    private static long msSince(final long start) {\n        return MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS);\n    }\n\n    /**\n     * Create a transaction savepoint with the name provided.\n     *\n     * @param name The name of the savepoint\n     * @return The same handle\n     */\n    public Handle savepoint(String name) {\n        transactions.savepoint(this, name);\n        LOG.trace(\"Handle [{}] savepoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release a previously created savepoint.\n     *\n     * @param savepointName the name of the savepoint to release\n     * @return the same handle\n     */\n    public Handle release(String savepointName) {\n        transactions.releaseSavepoint(this, savepointName);\n        LOG.trace(\"Handle [{}] release savepoint \\\"{}\\\"\", this, savepointName);\n        return this;\n    }\n\n    /**\n     * Whether the connection is in read-only mode.\n     *\n     * @return True if the connection is in read-only mode.\n     * @see Connection#isReadOnly()\n     */\n    public boolean isReadOnly() {\n        try {\n            return connection.isReadOnly();\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"Could not getReadOnly\", e);\n        }\n    }\n\n    /**\n     * Set the Handle readOnly.\n     * This acts as a hint to the database to improve performance or concurrency.\n     *\n     * May not be called in an active transaction!\n     *\n     * @see Connection#setReadOnly(boolean)\n     * @param readOnly whether the Handle is readOnly\n     * @return this Handle\n     */\n    public Handle setReadOnly(boolean readOnly) {\n        try {\n            connection.setReadOnly(readOnly);\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"Could not setReadOnly\", e);\n        }\n        return this;\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction, and returns the result of the callback.\n     *\n     * @param callback a callback which will receive an open handle, in a transaction.\n     * @param <R> type returned by callback\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @return value returned from the callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(HandleCallback<R, X> callback) throws X {\n        return isInTransaction()\n            ? callback.withHandle(this)\n            : transactions.inTransaction(this, callback);\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction.\n     *\n     * @param consumer a callback which will receive an open handle, in a transaction.\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> consumer) throws X {\n        inTransaction(consumer.asCallback());\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction, and returns the result of the callback.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback a callback which will receive an open handle, in a transaction.\n     * @param <R> type returned by callback\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @return value returned from the callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(TransactionIsolationLevel level, HandleCallback<R, X> callback) throws X {\n        if (isInTransaction()) {\n            TransactionIsolationLevel currentLevel = getTransactionIsolationLevel();\n            if (currentLevel != level && level != TransactionIsolationLevel.UNKNOWN) {\n                throw new TransactionException(\n                    \"Tried to execute nested transaction with isolation level \" + level + \", \"\n                    + \"but already running in a transaction with isolation level \" + currentLevel + \".\");\n            }\n            return callback.withHandle(this);\n        }\n\n        try (TransactionResetter tr = new TransactionResetter(getTransactionIsolationLevel())) {\n            setTransactionIsolation(level);\n            return transactions.inTransaction(this, level, callback);\n        }\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param consumer a callback which will receive an open handle, in a transaction.\n     * @param <X> exception type thrown by the callback, if any\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(TransactionIsolationLevel level, HandleConsumer<X> consumer) throws X {\n        inTransaction(level, consumer.asCallback());\n    }\n\n    /**\n     * Set the transaction isolation level on the underlying connection.\n     *\n     * @throws UnableToManipulateTransactionIsolationLevelException if isolation level is not supported by the underlying connection or JDBC driver\n     *\n     * @param level the isolation level to use\n     */\n    public void setTransactionIsolation(TransactionIsolationLevel level) {\n        if (level != TransactionIsolationLevel.UNKNOWN) {\n            setTransactionIsolation(level.intValue());\n        }\n    }\n\n    /**\n     * Set the transaction isolation level on the underlying connection.\n     *\n     * @param level the isolation level to use\n     */\n    public void setTransactionIsolation(int level) {\n        try {\n            if (connection.getTransactionIsolation() != level) {\n                connection.setTransactionIsolation(level);\n            }\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    /**\n     * Obtain the current transaction isolation level.\n     *\n     * @return the current isolation level on the underlying connection\n     */\n    public TransactionIsolationLevel getTransactionIsolationLevel() {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    /**\n     * Create a Jdbi extension object of the specified type bound to this handle. The returned extension's lifecycle is\n     * coupled to the lifecycle of this handle. Closing the handle will render the extension unusable.\n     *\n     * @param extensionType the extension class\n     * @param <T> the extension type\n     * @return the new extension object bound to this handle\n     */\n    public <T> T attach(Class<T> extensionType) {\n        return getConfig(Extensions.class)\n                .findFor(extensionType, ConstantHandleSupplier.of(this))\n                .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n    }\n\n    /**\n     * Returns the extension method currently bound to the handle's context.\n     *\n     * @return the extension method currently bound to the handle's context\n     */\n    public ExtensionMethod getExtensionMethod() {\n        return localExtensionMethod.get();\n    }\n\n    void setExtensionMethod(ExtensionMethod extensionMethod) {\n        this.localExtensionMethod.set(extensionMethod);\n    }\n\n    void setExtensionMethodThreadLocal(ThreadLocal<ExtensionMethod> extensionMethodThreadLocal) {\n        this.localExtensionMethod = requireNonNull(extensionMethodThreadLocal);\n    }\n\n    private void notifyHandleCreated() {\n        handleListeners.forEach(listener -> listener.handleCreated(this));\n    }\n\n    private void notifyHandleClosed() {\n        handleListeners.forEach(listener -> listener.handleClosed(this));\n    }\n\n    private class TransactionResetter implements Closeable {\n\n        private final TransactionIsolationLevel initial;\n\n        TransactionResetter(TransactionIsolationLevel initial) {\n            this.initial = initial;\n        }\n\n        @Override\n        public void close() {\n            setTransactionIsolation(initial);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.io.Closeable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport javax.annotation.concurrent.GuardedBy;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionMethod;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.internal.exceptions.ThrowableSuppressor;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.statement.Batch;\nimport org.jdbi.v3.core.statement.Call;\nimport org.jdbi.v3.core.statement.Cleanable;\nimport org.jdbi.v3.core.statement.MetaData;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.jdbi.v3.core.statement.Query;\nimport org.jdbi.v3.core.statement.Script;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.Update;\nimport org.jdbi.v3.core.transaction.TransactionException;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.jdbi.v3.core.transaction.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.meta.Beta;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * This represents a connection to the database system. It is a wrapper around\n * a JDBC Connection object.  Handle provides essential methods for transaction\n * management, statement creation, and other operations tied to the database session.\n */\npublic class Handle implements Closeable, Configurable<Handle> {\n    private static final Logger LOG = LoggerFactory.getLogger(Handle.class);\n\n    private final Jdbi jdbi;\n    private final Cleanable connectionCleaner;\n    private final TransactionHandler transactions;\n    private final Connection connection;\n    private final boolean forceEndTransactions;\n\n    private ThreadLocal<ConfigRegistry> localConfig;\n    private ThreadLocal<ExtensionMethod> localExtensionMethod;\n    private StatementBuilder statementBuilder;\n\n    @GuardedBy(\"transactionCallbacks\")\n    private final List<TransactionCallback> transactionCallbacks = new ArrayList<>();\n\n    private final Set<Cleanable> cleanables = new LinkedHashSet<>();\n\n    private final Set<HandleListener> handleListeners = new CopyOnWriteArraySet<>();\n\n    private final AtomicBoolean closed = new AtomicBoolean();\n\n    static Handle createHandle(Jdbi jdbi,\n        ConfigRegistry config,\n        Cleanable connectionCleaner,\n        TransactionHandler transactions,\n        StatementBuilder statementBuilder,\n        Connection connection) throws SQLException {\n        Handle handle = new Handle(jdbi, config, connectionCleaner, transactions, statementBuilder, connection);\n\n        handle.notifyHandleCreated();\n        return handle;\n    }\n\n    private Handle(Jdbi jdbi,\n        ConfigRegistry config,\n        Cleanable connectionCleaner,\n        TransactionHandler transactions,\n        StatementBuilder statementBuilder,\n        Connection connection) throws SQLException {\n        this.jdbi = jdbi;\n        this.connectionCleaner = connectionCleaner;\n        this.connection = connection;\n\n        // this piece is probably related to the comments in LazyHandleSupplier\n        // about tomcat leak checker false positives. This needs revisiting.\n        this.localConfig = ThreadLocal.withInitial(() -> config);\n        this.localExtensionMethod = new ThreadLocal<>();\n\n        this.statementBuilder = statementBuilder;\n        this.handleListeners.addAll(config.get(Handles.class).getListeners());\n\n        // both of these methods are bad because they leak a reference to this handle before the c'tor finished.\n        this.transactions = transactions.specialize(this);\n        this.forceEndTransactions = !transactions.isInTransaction(this);\n\n        addCleanable(() -> {\n            // shut down statement builder\n            if (checkConnectionIsLive()) {\n                statementBuilder.close(connection);\n            }\n            // clean up the local state when the handle is closed.\n            localExtensionMethod.remove();\n            localConfig.remove();\n        });\n    }\n\n    public Jdbi getJdbi() {\n        return jdbi;\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return localConfig.get();\n    }\n\n    void setConfig(ConfigRegistry config) {\n        this.localConfig.set(config);\n    }\n\n    void setLocalConfig(ThreadLocal<ConfigRegistry> configThreadLocal) {\n        // Without explicit remove the Tomcats thread-local leak detector gives superfluous warnings\n        this.localConfig.remove();\n        this.localConfig = configThreadLocal;\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses.\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    public Connection getConnection() {\n        return this.connection;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilder}.\n     *\n     * @return the current {@link StatementBuilder}\n     */\n    public StatementBuilder getStatementBuilder() {\n        return statementBuilder;\n    }\n\n    /**\n     * Specify the statement builder to use for this handle.\n     *\n     * @param builder StatementBuilder to be used\n     * @return this\n     */\n    public Handle setStatementBuilder(StatementBuilder builder) {\n        this.statementBuilder = builder;\n        return this;\n    }\n\n    /**\n     * Add a specific {@link HandleListener} which is called for specific events for this Handle. Note that\n     * it is not possible to add a listener that wants to implement {@link HandleListener#handleCreated} this way\n     * as the handle has already been created. Use {@link Handles#addListener} in this case.\n     * <br>\n     * A listener added through this call is specific to the handle and not shared with other handles.\n     *\n     * @param handleListener A {@link HandleListener} object.\n     *\n     * @return The handle itself.\n     */\n    public Handle addHandleListener(HandleListener handleListener) {\n        handleListeners.add(handleListener);\n\n        return this;\n    }\n\n    /**\n     * Remove a {@link HandleListener} from this handle.\n     * <br>\n     * Removing the listener only affects the current handle. To remove a listener for all future handles, use {@link Handles#removeListener}.\n     *\n     * @param handleListener A {@link HandleListener} object.\n     *\n     * @return The handle itself.\n     */\n    public Handle removeHandleListener(HandleListener handleListener) {\n        handleListeners.remove(handleListener);\n\n        return this;\n    }\n\n    /**\n     * Registers a {@code Cleanable} to be invoked when the handle is closed. Any cleanable registered here will only be cleaned once.\n     * <p>\n     * Resources cleaned up by Jdbi include {@link java.sql.ResultSet}, {@link java.sql.Statement}, {@link java.sql.Array}, and {@link StatementBuilder}.\n     *\n     * @param cleanable the Cleanable to clean on close\n     */\n    public final void addCleanable(Cleanable cleanable) {\n\n        synchronized (cleanables) {\n            cleanables.add(cleanable);\n        }\n    }\n\n    /**\n     * Unegister a {@code Cleanable} from the Handle.\n     *\n     * @param cleanable the Cleanable to be unregistered.\n     */\n    public final void removeCleanable(Cleanable cleanable) {\n\n        synchronized (cleanables) {\n            cleanables.remove(cleanable);\n        }\n    }\n\n    /**\n     * Closes the handle, its connection, and any other database resources it is holding.\n     *\n     * @throws CloseException if any resources throw exception while closing\n     * @throws TransactionException if called while the handle has a transaction open. The open transaction will be\n     * rolled back.\n     */\n    @Override\n    public void close() {\n\n        if (closed.getAndSet(true)) {\n            return;\n        }\n\n        // do this at call time, otherwise running the cleanables may affect the state of the other handle objects (e.g. the config)\n        final boolean doForceEndTransactions = this.forceEndTransactions && localConfig.get().get(Handles.class).isForceEndTransactions();\n\n        try {\n            ThrowableSuppressor throwableSuppressor = new ThrowableSuppressor();\n\n            doClean(throwableSuppressor);\n\n            try {\n                cleanConnection(doForceEndTransactions);\n            } catch (Throwable t) {\n                throwableSuppressor.attachToThrowable(t);\n                throw t;\n            }\n\n            throwableSuppressor.throwIfNecessary(t -> new CloseException(\"While closing handle\", t));\n        } finally {\n            LOG.trace(\"Handle [{}] released\", this);\n\n            notifyHandleClosed();\n        }\n    }\n\n    /**\n     * Release any database resource that may be held by the handle. This affects\n     * any statement that was created from the Handle.\n     */\n    public void clean() {\n        ThrowableSuppressor throwableSuppressor = new ThrowableSuppressor();\n\n        doClean(throwableSuppressor);\n\n        throwableSuppressor.throwIfNecessary();\n    }\n\n    /**\n     * Returns true if the Handle currently holds no database resources.\n     * <br>\n     * Note that this method will return <code>false<\/code> right after statement creation\n     * as every statement registers its statement context with the handle. Once\n     *\n     * @return True if the handle holds no database resources.\n     */\n    public boolean isClean() {\n        synchronized (cleanables) {\n            return cleanables.isEmpty();\n        }\n    }\n\n    private void doClean(ThrowableSuppressor throwableSuppressor) {\n        List<Cleanable> cleanablesCopy;\n\n        synchronized (cleanables) {\n            cleanablesCopy = new ArrayList<>(cleanables);\n            cleanables.clear();\n        }\n\n        Collections.reverse(cleanablesCopy);\n\n        for (Cleanable cleanable : cleanablesCopy) {\n            throwableSuppressor.suppressAppend(cleanable::close);\n        }\n    }\n\n    /**\n     * Returns true if the {@link Handle} has been closed.\n     *\n     * @return True if the Handle is closed.\n     */\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    /**\n     * Convenience method which creates a query with the given positional arguments.\n     *\n     * @param sql SQL or named statement\n     * @param args arguments to bind positionally\n     * @return query object\n     */\n    public Query select(CharSequence sql, Object... args) {\n        Query query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query;\n    }\n\n    /**\n     * Convenience method which creates a query with the given positional arguments. Takes a string argument for backwards compatibility reasons.\n     * @param sql SQL or named statement\n     * @param args arguments to bind positionally\n     * @return query object\n     * @see Handle#select(CharSequence, Object...)\n     */\n    public Query select(String sql, Object... args) {\n        return select((CharSequence) sql, args);\n    }\n\n    /**\n     * Execute a SQL statement, and return the number of rows affected by the statement.\n     *\n     * @param sql the SQL statement to execute, using positional parameters (if any).\n     * @param args positional arguments.\n     *\n     * @return the number of rows affected.\n     */\n    public int execute(CharSequence sql, Object... args) {\n        try (Update stmt = createUpdate(sql)) {\n            int position = 0;\n            for (Object arg : args) {\n                stmt.bind(position++, arg);\n            }\n            return stmt.execute();\n        }\n    }\n\n    /**\n     * Execute a SQL statement, and return the number of rows affected by the statement. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the SQL statement to execute, using positional parameters (if any).\n     * @param args positional arguments.\n     *\n     * @return the number of rows affected.\n     * @see Handle#execute(CharSequence, Object...)\n     */\n    public int execute(String sql, Object... args) {\n        return execute((CharSequence) sql, args);\n    }\n\n    /**\n     * Create a non-prepared (no bound parameters, but different SQL) batch statement.\n     * @return empty batch\n     * @see Handle#prepareBatch(String)\n     */\n    public Batch createBatch() {\n        return new Batch(this);\n    }\n\n    /**\n     * Prepare a batch to execute. This is for efficiently executing more than one\n     * of the same statements with different parameters bound.\n     *\n     * @param sql the batch SQL.\n     * @return a batch which can have \"statements\" added.\n     */\n    public PreparedBatch prepareBatch(CharSequence sql) {\n        return new PreparedBatch(this, sql);\n    }\n\n    /**\n     * Prepare a batch to execute. This is for efficiently executing more than one\n     * of the same statements with different parameters bound. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the batch SQL.\n     * @return a batch which can have \"statements\" added.\n     * @see Handle#prepareBatch(CharSequence)\n     */\n    public PreparedBatch prepareBatch(String sql) {\n        return prepareBatch((CharSequence) sql);\n    }\n\n    /**\n     * Create a call to a stored procedure.\n     *\n     * @param sql the stored procedure sql.\n     *\n     * @return the Call.\n     */\n    public Call createCall(CharSequence sql) {\n        return new Call(this, sql);\n    }\n\n    /**\n     * Create a call to a stored procedure. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the stored procedure sql.\n     *\n     * @return the Call.\n     * @see Handle#createCall(CharSequence)\n     */\n    public Call createCall(String sql) {\n        return createCall((CharSequence) sql);\n    }\n\n    /**\n     * Return a Query instance that executes a statement\n     * with bound parameters and maps the result set into Java types.\n     * @param sql SQL that may return results.\n     * @return a Query builder.\n     */\n    public Query createQuery(CharSequence sql) {\n        return new Query(this, sql);\n    }\n\n    /**\n     * Return a Query instance that executes a statement\n     * with bound parameters and maps the result set into Java types. Takes a string argument for backwards compatibility reasons.\n     * @param sql SQL that may return results.\n     * @return a Query builder.\n     * @see Handle#createQuery(CharSequence)\n     */\n    public Query createQuery(String sql) {\n        return createQuery((CharSequence) sql);\n    }\n\n    /**\n     * Creates a Script from the given SQL script.\n     *\n     * @param sql the SQL script.\n     *\n     * @return the created Script.\n     */\n    public Script createScript(CharSequence sql) {\n        return new Script(this, sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     *\n     * @see Handle#createScript(CharSequence)\n     */\n    public Script createScript(String sql) {\n        return createScript((CharSequence) sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     */\n    public Update createUpdate(CharSequence sql) {\n        return new Update(this, sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     *\n     * @see Handle#createUpdate(CharSequence)\n     */\n    public Update createUpdate(String sql) {\n        return createUpdate((CharSequence) sql);\n    }\n\n    /**\n     * Access database metadata that returns a {@link java.sql.ResultSet}. All methods of {@link org.jdbi.v3.core.result.ResultBearing} can be used to format\n     * and map the returned results.\n     *\n     * <pre>\n     *     List&lt;String&gt; catalogs = h.queryMetadata(DatabaseMetaData::getCatalogs)\n     *                                      .mapTo(String.class)\n     *                                      .list();\n     * <\/pre>\n     * <p>\n     * returns the list of catalogs from the current database.\n     *\n     * @param metadataFunction Maps the provided {@link java.sql.DatabaseMetaData} object onto a {@link java.sql.ResultSet} object.\n     * @return The metadata builder.\n     */\n    public ResultBearing queryMetadata(MetaData.MetaDataResultSetProvider metadataFunction) {\n        return new MetaData(this, metadataFunction);\n    }\n\n    /**\n     * Access all database metadata that returns simple values.\n     *\n     * <pre>\n     *     boolean supportsTransactions = handle.queryMetadata(DatabaseMetaData::supportsTransactions);\n     * <\/pre>\n     *\n     * @param metadataFunction Maps the provided {@link java.sql.DatabaseMetaData} object to a response object.\n     * @return The response object.\n     */\n    public <T> T queryMetadata(MetaData.MetaDataValueProvider<T> metadataFunction) {\n        try (MetaData metadata = new MetaData(this, metadataFunction)) {\n            return metadata.execute();\n        }\n    }\n\n    /**\n     * Returns whether the handle is in a transaction. Delegates to the underlying {@link TransactionHandler}.\n     *\n     * @return True if the handle is in a transaction.\n     */\n    public boolean isInTransaction() {\n        return transactions.isInTransaction(this);\n    }\n\n    /**\n     * Start a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle begin() {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle commit() {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, msSince(start));\n        drainCallbacks()\n                .forEach(TransactionCallback::afterCommit);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle rollback() {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, msSince(start));\n        drainCallbacks()\n                .forEach(TransactionCallback::afterRollback);\n        return this;\n    }\n\n    /**\n     * Execute an action the next time this Handle commits, unless it is rolled back first.\n     * @param afterCommit the action to execute after commit\n     * @return this Handle\n     */\n    @Beta\n    public Handle afterCommit(Runnable afterCommit) {\n        return addTransactionCallback(new TransactionCallback() {\n            @Override\n            public void afterCommit() {\n                afterCommit.run();\n            }\n        });\n    }\n\n    /**\n     * Execute an action the next time this Handle rolls back, unless it is committed first.\n     * @param afterRollback the action to execute after rollback\n     * @return this Handle\n     */\n    @Beta\n    public Handle afterRollback(Runnable afterRollback) {\n       return addTransactionCallback(new TransactionCallback() {\n            @Override\n            public void afterRollback() {\n                afterRollback.run();\n            }\n        });\n    }\n\n    List<TransactionCallback> drainCallbacks() {\n        synchronized (transactionCallbacks) {\n            List<TransactionCallback> result = new ArrayList<>(transactionCallbacks);\n            transactionCallbacks.clear();\n            return result;\n        }\n    }\n\n    Handle addTransactionCallback(TransactionCallback cb) {\n        if (!isInTransaction()) {\n            throw new IllegalStateException(\"Handle must be in transaction\");\n        }\n        synchronized (transactionCallbacks) {\n            transactionCallbacks.add(cb);\n        }\n        return this;\n    }\n\n    /**\n     * Rollback a transaction to a named savepoint.\n     *\n     * @param savepointName the name of the savepoint, previously declared with {@link Handle#savepoint}\n     *\n     * @return the same handle\n     */\n    public Handle rollbackToSavepoint(String savepointName) {\n        final long start = System.nanoTime();\n        transactions.rollbackToSavepoint(this, savepointName);\n        LOG.trace(\"Handle [{}] rollback to savepoint \\\"{}\\\" in {}ms\", this, savepointName, msSince(start));\n        return this;\n    }\n\n    private static long msSince(final long start) {\n        return MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS);\n    }\n\n    /**\n     * Create a transaction savepoint with the name provided.\n     *\n     * @param name The name of the savepoint\n     * @return The same handle\n     */\n    public Handle savepoint(String name) {\n        transactions.savepoint(this, name);\n        LOG.trace(\"Handle [{}] savepoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release a previously created savepoint.\n     *\n     * @param savepointName the name of the savepoint to release\n     * @return the same handle\n     */\n    public Handle release(String savepointName) {\n        transactions.releaseSavepoint(this, savepointName);\n        LOG.trace(\"Handle [{}] release savepoint \\\"{}\\\"\", this, savepointName);\n        return this;\n    }\n\n    /**\n     * Whether the connection is in read-only mode.\n     *\n     * @return True if the connection is in read-only mode.\n     * @see Connection#isReadOnly()\n     */\n    public boolean isReadOnly() {\n        try {\n            return connection.isReadOnly();\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"Could not getReadOnly\", e);\n        }\n    }\n\n    /**\n     * Set the Handle readOnly.\n     * This acts as a hint to the database to improve performance or concurrency.\n     *\n     * May not be called in an active transaction!\n     *\n     * @see Connection#setReadOnly(boolean)\n     * @param readOnly whether the Handle is readOnly\n     * @return this Handle\n     */\n    public Handle setReadOnly(boolean readOnly) {\n        try {\n            connection.setReadOnly(readOnly);\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"Could not setReadOnly\", e);\n        }\n        return this;\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction, and returns the result of the callback.\n     *\n     * @param callback a callback which will receive an open handle, in a transaction.\n     * @param <R> type returned by callback\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @return value returned from the callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(HandleCallback<R, X> callback) throws X {\n        return isInTransaction()\n            ? callback.withHandle(this)\n            : transactions.inTransaction(this, callback);\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction.\n     *\n     * @param consumer a callback which will receive an open handle, in a transaction.\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> consumer) throws X {\n        inTransaction(consumer.asCallback());\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction, and returns the result of the callback.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback a callback which will receive an open handle, in a transaction.\n     * @param <R> type returned by callback\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @return value returned from the callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(TransactionIsolationLevel level, HandleCallback<R, X> callback) throws X {\n        if (isInTransaction()) {\n            TransactionIsolationLevel currentLevel = getTransactionIsolationLevel();\n            if (currentLevel != level && level != TransactionIsolationLevel.UNKNOWN) {\n                throw new TransactionException(\n                    \"Tried to execute nested transaction with isolation level \" + level + \", \"\n                    + \"but already running in a transaction with isolation level \" + currentLevel + \".\");\n            }\n            return callback.withHandle(this);\n        }\n\n        try (TransactionResetter tr = new TransactionResetter(getTransactionIsolationLevel())) {\n            setTransactionIsolation(level);\n            return transactions.inTransaction(this, level, callback);\n        }\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param consumer a callback which will receive an open handle, in a transaction.\n     * @param <X> exception type thrown by the callback, if any\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(TransactionIsolationLevel level, HandleConsumer<X> consumer) throws X {\n        inTransaction(level, consumer.asCallback());\n    }\n\n    /**\n     * Set the transaction isolation level on the underlying connection.\n     *\n     * @throws UnableToManipulateTransactionIsolationLevelException if isolation level is not supported by the underlying connection or JDBC driver\n     *\n     * @param level the isolation level to use\n     */\n    public void setTransactionIsolation(TransactionIsolationLevel level) {\n        if (level != TransactionIsolationLevel.UNKNOWN) {\n            setTransactionIsolation(level.intValue());\n        }\n    }\n\n    /**\n     * Set the transaction isolation level on the underlying connection.\n     *\n     * @param level the isolation level to use\n     */\n    public void setTransactionIsolation(int level) {\n        try {\n            if (connection.getTransactionIsolation() != level) {\n                connection.setTransactionIsolation(level);\n            }\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    /**\n     * Obtain the current transaction isolation level.\n     *\n     * @return the current isolation level on the underlying connection\n     */\n    public TransactionIsolationLevel getTransactionIsolationLevel() {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    /**\n     * Create a Jdbi extension object of the specified type bound to this handle. The returned extension's lifecycle is\n     * coupled to the lifecycle of this handle. Closing the handle will render the extension unusable.\n     *\n     * @param extensionType the extension class\n     * @param <T> the extension type\n     * @return the new extension object bound to this handle\n     */\n    public <T> T attach(Class<T> extensionType) {\n        return getConfig(Extensions.class)\n                .findFor(extensionType, ConstantHandleSupplier.of(this))\n                .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n    }\n\n    /**\n     * Returns the extension method currently bound to the handle's context.\n     *\n     * @return the extension method currently bound to the handle's context\n     */\n    public ExtensionMethod getExtensionMethod() {\n        return localExtensionMethod.get();\n    }\n\n    void setExtensionMethod(ExtensionMethod extensionMethod) {\n        this.localExtensionMethod.set(extensionMethod);\n    }\n\n    void setExtensionMethodThreadLocal(ThreadLocal<ExtensionMethod> extensionMethodThreadLocal) {\n        this.localExtensionMethod = requireNonNull(extensionMethodThreadLocal);\n    }\n\n    private void notifyHandleCreated() {\n        handleListeners.forEach(listener -> listener.handleCreated(this));\n    }\n\n    private void notifyHandleClosed() {\n        handleListeners.forEach(listener -> listener.handleClosed(this));\n    }\n\n    private void cleanConnection(boolean doForceEndTransactions) {\n\n        final ThrowableSuppressor throwableSuppressor = new ThrowableSuppressor();\n        final boolean connectionIsLive = checkConnectionIsLive();\n\n        boolean wasInTransaction = false;\n\n        if (connectionIsLive && doForceEndTransactions) {\n            wasInTransaction = throwableSuppressor.suppressAppend(this::isInTransaction, false);\n        }\n\n        if (wasInTransaction) {\n            throwableSuppressor.suppressAppend(this::rollback);\n        }\n\n        if (connectionIsLive) {\n            try {\n                connectionCleaner.close();\n            } catch (SQLException e) {\n                CloseException ce = new CloseException(\"Unable to close Connection\", e);\n                throwableSuppressor.attachToThrowable(ce);\n                throw ce;\n            }\n\n            throwableSuppressor.throwIfNecessary(t -> new CloseException(\"Failed to clear transaction status on close\", t));\n\n            if (wasInTransaction) {\n                TransactionException te = new TransactionException(\"Improper transaction handling detected: A Handle with an open \"\n                    + \"transaction was closed. Transactions must be explicitly committed or rolled back \"\n                    + \"before closing the Handle. \"\n                    + \"Jdbi has rolled back this transaction automatically. \"\n                    + \"This check may be disabled by calling getConfig(Handles.class).setForceEndTransactions(false).\");\n\n                throwableSuppressor.attachToThrowable(te); // any exception present is not the cause but just collateral.\n                throw te;\n            }\n        } else {\n            throwableSuppressor.throwIfNecessary(t -> new CloseException(\"Failed to clear transaction status on close\", t));\n        }\n    }\n\n    private boolean checkConnectionIsLive() {\n        try {\n            return !connection.isClosed();\n        } catch (SQLException e) {\n            // if the connection state can not be determined, assume that the\n            // connection is closed and ignore the exception\n            return false;\n        }\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Handle handle = (Handle) o;\n        return jdbi.equals(handle.jdbi) && connection.equals(handle.connection);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(jdbi, connection);\n    }\n\n    private class TransactionResetter implements Closeable {\n\n        private final TransactionIsolationLevel initial;\n\n        TransactionResetter(TransactionIsolationLevel initial) {\n            this.initial = initial;\n        }\n\n        @Override\n        public void close() {\n            setTransactionIsolation(initial);\n        }\n    }\n}\n","lineNo":251}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.io.Closeable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\nimport javax.annotation.concurrent.GuardedBy;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionMethod;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.statement.Batch;\nimport org.jdbi.v3.core.statement.Call;\nimport org.jdbi.v3.core.statement.Cleanable;\nimport org.jdbi.v3.core.statement.MetaData;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.jdbi.v3.core.statement.Query;\nimport org.jdbi.v3.core.statement.Script;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.Update;\nimport org.jdbi.v3.core.transaction.TransactionException;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.jdbi.v3.core.transaction.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.meta.Beta;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * This represents a connection to the database system. It is a wrapper around\n * a JDBC Connection object.  Handle provides essential methods for transaction\n * management, statement creation, and other operations tied to the database session.\n */\npublic class Handle implements Closeable, Configurable<Handle> {\n    private static final Logger LOG = LoggerFactory.getLogger(Handle.class);\n\n    private final Jdbi jdbi;\n    private final Cleanable closer;\n    private final TransactionHandler transactions;\n    private final Connection connection;\n    private final boolean forceEndTransactions;\n\n    private ThreadLocal<ConfigRegistry> localConfig;\n    private ThreadLocal<ExtensionMethod> localExtensionMethod;\n    private StatementBuilder statementBuilder;\n\n    @GuardedBy(\"transactionCallbacks\")\n    private final List<TransactionCallback> transactionCallbacks = new ArrayList<>();\n\n    private final Set<HandleListener> handleListeners;\n\n    private boolean closed = false;\n\n    static Handle createHandle(Jdbi jdbi,\n        ConfigRegistry localConfig,\n        Cleanable closer,\n        TransactionHandler transactions,\n        StatementBuilder statementBuilder,\n        Connection connection) throws SQLException {\n        Handle handle = new Handle(jdbi, localConfig, closer, transactions, statementBuilder, connection);\n\n        handle.notifyHandleCreated();\n        return handle;\n    }\n\n    private Handle(Jdbi jdbi,\n           ConfigRegistry localConfig,\n           Cleanable closer,\n           TransactionHandler transactions,\n           StatementBuilder statementBuilder,\n           Connection connection) throws SQLException {\n        this.jdbi = jdbi;\n        this.closer = closer;\n        this.connection = connection;\n\n        this.localConfig = ThreadLocal.withInitial(() -> localConfig);\n        this.localExtensionMethod = new ThreadLocal<>();\n        this.statementBuilder = statementBuilder;\n        this.transactions = transactions.specialize(this);\n        this.forceEndTransactions = !transactions.isInTransaction(this);\n\n        this.handleListeners = new CopyOnWriteArraySet<>(localConfig.get(Handles.class).getListeners());\n    }\n\n    public Jdbi getJdbi() {\n        return jdbi;\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return localConfig.get();\n    }\n\n    void setConfig(ConfigRegistry config) {\n        this.localConfig.set(config);\n    }\n\n    void setLocalConfig(ThreadLocal<ConfigRegistry> configThreadLocal) {\n        // Without explicit remove the Tomcats thread-local leak detector gives superfluous warnings\n        this.localConfig.remove();\n        this.localConfig = configThreadLocal;\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses.\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    public Connection getConnection() {\n        return this.connection;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilder}.\n     *\n     * @return the current {@link StatementBuilder}\n     */\n    public StatementBuilder getStatementBuilder() {\n        return statementBuilder;\n    }\n\n    /**\n     * Specify the statement builder to use for this handle.\n     *\n     * @param builder StatementBuilder to be used\n     * @return this\n     */\n    public Handle setStatementBuilder(StatementBuilder builder) {\n        this.statementBuilder = builder;\n        return this;\n    }\n\n    /**\n     * Add a specific {@link HandleListener} which is called for specific events for this Handle. Note that\n     * it is not possible to add a listener that wants to implement {@link HandleListener#handleCreated} this way\n     * as the handle has already been created. Use {@link Handles#addListener} in this case.\n     * <br>\n     * A listener added through this call is specific to the handle and not shared with other handles.\n     *\n     * @param handleListener A {@link HandleListener} object.\n     *\n     * @return The handle itself.\n     */\n    public Handle addHandleListener(HandleListener handleListener) {\n        handleListeners.add(handleListener);\n\n        return this;\n    }\n\n    /**\n     * Remove a {@link HandleListener} from this handle.\n     * <br>\n     * Removing the listener only affects the current handle. To remove a listener for all future handles, use {@link Handles#removeListener}.\n     *\n     * @param handleListener A {@link HandleListener} object.\n     *\n     * @return The handle itself.\n     */\n    public Handle removeHandleListener(HandleListener handleListener) {\n        handleListeners.remove(handleListener);\n\n        return this;\n    }\n\n    /**\n     * Closes the handle, its connection, and any other database resources it is holding.\n     *\n     * @throws CloseException if any resources throw exception while closing\n     * @throws TransactionException if called while the handle has a transaction open. The open transaction will be\n     * rolled back.\n     */\n    @Override\n    public void close() {\n        final List<Throwable> suppressed = new ArrayList<>();\n        if (closed) {\n            return;\n        }\n\n        boolean connectionIsLive;\n\n        try {\n            connectionIsLive = !connection.isClosed();\n        } catch (SQLException e) {\n            // if the connection state can not be determined, assume that the\n            // connection is closed and ignore the exception\n            connectionIsLive = false;\n        }\n\n        boolean wasInTransaction = false;\n\n        if (connectionIsLive && forceEndTransactions && localConfig.get().get(Handles.class).isForceEndTransactions()) {\n            try {\n                wasInTransaction = isInTransaction();\n            } catch (Exception e) {\n                suppressed.add(e);\n            }\n        }\n\n        localExtensionMethod.remove();\n        localConfig.remove();\n\n        if (wasInTransaction) {\n            try {\n                rollback();\n            } catch (Exception e) {\n                suppressed.add(e);\n            }\n        }\n\n        if (connectionIsLive) {\n            try {\n                statementBuilder.close(getConnection());\n            } catch (Exception e) {\n                suppressed.add(e);\n            }\n        }\n\n        try {\n            if (connectionIsLive) {\n                closer.close();\n            }\n\n            if (!suppressed.isEmpty()) {\n                final Throwable original = suppressed.remove(0);\n                suppressed.forEach(original::addSuppressed);\n                throw new CloseException(\"Failed to clear transaction status on close\", original);\n            }\n            if (wasInTransaction) {\n                throw new TransactionException(\"Improper transaction handling detected: A Handle with an open \"\n                    + \"transaction was closed. Transactions must be explicitly committed or rolled back \"\n                    + \"before closing the Handle. \"\n                    + \"Jdbi has rolled back this transaction automatically. \"\n                    + \"This check may be disabled by calling getConfig(Handles.class).setForceEndTransactions(false).\");\n            }\n        } catch (SQLException e) {\n            CloseException ce = new CloseException(\"Unable to close Connection\", e);\n            suppressed.forEach(ce::addSuppressed);\n            throw ce;\n        } finally {\n            LOG.trace(\"Handle [{}] released\", this);\n            closed = true;\n\n            notifyHandleClosed();\n        }\n    }\n\n    /**\n     * Returns true if the {@link Handle} has been closed.\n     *\n     * @return True if the Handle is closed.\n     */\n    public boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Convenience method which creates a query with the given positional arguments.\n     *\n     * @param sql SQL or named statement\n     * @param args arguments to bind positionally\n     * @return query object\n     */\n    public Query select(CharSequence sql, Object... args) {\n        Query query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query;\n    }\n\n    /**\n     * Convenience method which creates a query with the given positional arguments. Takes a string argument for backwards compatibility reasons.\n     * @param sql SQL or named statement\n     * @param args arguments to bind positionally\n     * @return query object\n     * @see Handle#select(CharSequence, Object...)\n     */\n    public Query select(String sql, Object... args) {\n        return select((CharSequence) sql, args);\n    }\n\n    /**\n     * Execute a SQL statement, and return the number of rows affected by the statement.\n     *\n     * @param sql the SQL statement to execute, using positional parameters (if any).\n     * @param args positional arguments.\n     *\n     * @return the number of rows affected.\n     */\n    public int execute(CharSequence sql, Object... args) {\n        try (Update stmt = createUpdate(sql)) {\n            int position = 0;\n            for (Object arg : args) {\n                stmt.bind(position++, arg);\n            }\n            return stmt.execute();\n        }\n    }\n\n    /**\n     * Execute a SQL statement, and return the number of rows affected by the statement. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the SQL statement to execute, using positional parameters (if any).\n     * @param args positional arguments.\n     *\n     * @return the number of rows affected.\n     * @see Handle#execute(CharSequence, Object...)\n     */\n    public int execute(String sql, Object... args) {\n        return execute((CharSequence) sql, args);\n    }\n\n    /**\n     * Create a non-prepared (no bound parameters, but different SQL) batch statement.\n     * @return empty batch\n     * @see Handle#prepareBatch(String)\n     */\n    public Batch createBatch() {\n        return new Batch(this);\n    }\n\n    /**\n     * Prepare a batch to execute. This is for efficiently executing more than one\n     * of the same statements with different parameters bound.\n     *\n     * @param sql the batch SQL.\n     * @return a batch which can have \"statements\" added.\n     */\n    public PreparedBatch prepareBatch(CharSequence sql) {\n        return new PreparedBatch(this, sql);\n    }\n\n    /**\n     * Prepare a batch to execute. This is for efficiently executing more than one\n     * of the same statements with different parameters bound. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the batch SQL.\n     * @return a batch which can have \"statements\" added.\n     * @see Handle#prepareBatch(CharSequence)\n     */\n    public PreparedBatch prepareBatch(String sql) {\n        return prepareBatch((CharSequence) sql);\n    }\n\n    /**\n     * Create a call to a stored procedure.\n     *\n     * @param sql the stored procedure sql.\n     *\n     * @return the Call.\n     */\n    public Call createCall(CharSequence sql) {\n        return new Call(this, sql);\n    }\n\n    /**\n     * Create a call to a stored procedure. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the stored procedure sql.\n     *\n     * @return the Call.\n     * @see Handle#createCall(CharSequence)\n     */\n    public Call createCall(String sql) {\n        return createCall((CharSequence) sql);\n    }\n\n    /**\n     * Return a Query instance that executes a statement\n     * with bound parameters and maps the result set into Java types.\n     * @param sql SQL that may return results.\n     * @return a Query builder.\n     */\n    public Query createQuery(CharSequence sql) {\n        return new Query(this, sql);\n    }\n\n    /**\n     * Return a Query instance that executes a statement\n     * with bound parameters and maps the result set into Java types. Takes a string argument for backwards compatibility reasons.\n     * @param sql SQL that may return results.\n     * @return a Query builder.\n     * @see Handle#createQuery(CharSequence)\n     */\n    public Query createQuery(String sql) {\n        return createQuery((CharSequence) sql);\n    }\n\n    /**\n     * Creates a Script from the given SQL script.\n     *\n     * @param sql the SQL script.\n     *\n     * @return the created Script.\n     */\n    public Script createScript(CharSequence sql) {\n        return new Script(this, sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     *\n     * @see Handle#createScript(CharSequence)\n     */\n    public Script createScript(String sql) {\n        return createScript((CharSequence) sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     */\n    public Update createUpdate(CharSequence sql) {\n        return new Update(this, sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     *\n     * @see Handle#createUpdate(CharSequence)\n     */\n    public Update createUpdate(String sql) {\n        return createUpdate((CharSequence) sql);\n    }\n\n    /**\n     * Access database metadata that returns a {@link java.sql.ResultSet}. All methods of {@link org.jdbi.v3.core.result.ResultBearing} can be used to format\n     * and map the returned results.\n     *\n     * <pre>\n     *     List&lt;String&gt; catalogs = h.queryMetadata(DatabaseMetaData::getCatalogs)\n     *                                      .mapTo(String.class)\n     *                                      .list();\n     * <\/pre>\n     * <p>\n     * returns the list of catalogs from the current database.\n     *\n     * @param metadataFunction Maps the provided {@link java.sql.DatabaseMetaData} object onto a {@link java.sql.ResultSet} object.\n     * @return The metadata builder.\n     */\n    public ResultBearing queryMetadata(MetaData.MetaDataResultSetProvider metadataFunction) {\n        return new MetaData(this, metadataFunction);\n    }\n\n    /**\n     * Access all database metadata that returns simple values.\n     *\n     * <pre>\n     *     boolean supportsTransactions = handle.queryMetadata(DatabaseMetaData::supportsTransactions);\n     * <\/pre>\n     *\n     * @param metadataFunction Maps the provided {@link java.sql.DatabaseMetaData} object to a response object.\n     * @return The response object.\n     */\n    public <T> T queryMetadata(MetaData.MetaDataValueProvider<T> metadataFunction) {\n        try (MetaData metadata = new MetaData(this, metadataFunction)) {\n            return metadata.execute();\n        }\n    }\n\n    /**\n     * Returns whether the handle is in a transaction. Delegates to the underlying {@link TransactionHandler}.\n     *\n     * @return True if the handle is in a transaction.\n     */\n    public boolean isInTransaction() {\n        return transactions.isInTransaction(this);\n    }\n\n    /**\n     * Start a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle begin() {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle commit() {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, msSince(start));\n        drainCallbacks()\n                .forEach(TransactionCallback::afterCommit);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle rollback() {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, msSince(start));\n        drainCallbacks()\n                .forEach(TransactionCallback::afterRollback);\n        return this;\n    }\n\n    /**\n     * Execute an action the next time this Handle commits, unless it is rolled back first.\n     * @param afterCommit the action to execute after commit\n     * @return this Handle\n     */\n    @Beta\n    public Handle afterCommit(Runnable afterCommit) {\n        return addTransactionCallback(new TransactionCallback() {\n            @Override\n            public void afterCommit() {\n                afterCommit.run();\n            }\n        });\n    }\n\n    /**\n     * Execute an action the next time this Handle rolls back, unless it is committed first.\n     * @param afterRollback the action to execute after rollback\n     * @return this Handle\n     */\n    @Beta\n    public Handle afterRollback(Runnable afterRollback) {\n       return addTransactionCallback(new TransactionCallback() {\n            @Override\n            public void afterRollback() {\n                afterRollback.run();\n            }\n        });\n    }\n\n    List<TransactionCallback> drainCallbacks() {\n        synchronized (transactionCallbacks) {\n            List<TransactionCallback> result = new ArrayList<>(transactionCallbacks);\n            transactionCallbacks.clear();\n            return result;\n        }\n    }\n\n    Handle addTransactionCallback(TransactionCallback cb) {\n        if (!isInTransaction()) {\n            throw new IllegalStateException(\"Handle must be in transaction\");\n        }\n        synchronized (transactionCallbacks) {\n            transactionCallbacks.add(cb);\n        }\n        return this;\n    }\n\n    /**\n     * Rollback a transaction to a named savepoint.\n     *\n     * @param savepointName the name of the savepoint, previously declared with {@link Handle#savepoint}\n     *\n     * @return the same handle\n     */\n    public Handle rollbackToSavepoint(String savepointName) {\n        final long start = System.nanoTime();\n        transactions.rollbackToSavepoint(this, savepointName);\n        LOG.trace(\"Handle [{}] rollback to savepoint \\\"{}\\\" in {}ms\", this, savepointName, msSince(start));\n        return this;\n    }\n\n    private static long msSince(final long start) {\n        return MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS);\n    }\n\n    /**\n     * Create a transaction savepoint with the name provided.\n     *\n     * @param name The name of the savepoint\n     * @return The same handle\n     */\n    public Handle savepoint(String name) {\n        transactions.savepoint(this, name);\n        LOG.trace(\"Handle [{}] savepoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release a previously created savepoint.\n     *\n     * @param savepointName the name of the savepoint to release\n     * @return the same handle\n     */\n    public Handle release(String savepointName) {\n        transactions.releaseSavepoint(this, savepointName);\n        LOG.trace(\"Handle [{}] release savepoint \\\"{}\\\"\", this, savepointName);\n        return this;\n    }\n\n    /**\n     * Whether the connection is in read-only mode.\n     *\n     * @return True if the connection is in read-only mode.\n     * @see Connection#isReadOnly()\n     */\n    public boolean isReadOnly() {\n        try {\n            return connection.isReadOnly();\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"Could not getReadOnly\", e);\n        }\n    }\n\n    /**\n     * Set the Handle readOnly.\n     * This acts as a hint to the database to improve performance or concurrency.\n     *\n     * May not be called in an active transaction!\n     *\n     * @see Connection#setReadOnly(boolean)\n     * @param readOnly whether the Handle is readOnly\n     * @return this Handle\n     */\n    public Handle setReadOnly(boolean readOnly) {\n        try {\n            connection.setReadOnly(readOnly);\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"Could not setReadOnly\", e);\n        }\n        return this;\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction, and returns the result of the callback.\n     *\n     * @param callback a callback which will receive an open handle, in a transaction.\n     * @param <R> type returned by callback\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @return value returned from the callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(HandleCallback<R, X> callback) throws X {\n        return isInTransaction()\n            ? callback.withHandle(this)\n            : transactions.inTransaction(this, callback);\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction.\n     *\n     * @param consumer a callback which will receive an open handle, in a transaction.\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> consumer) throws X {\n        inTransaction(consumer.asCallback());\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction, and returns the result of the callback.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback a callback which will receive an open handle, in a transaction.\n     * @param <R> type returned by callback\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @return value returned from the callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(TransactionIsolationLevel level, HandleCallback<R, X> callback) throws X {\n        if (isInTransaction()) {\n            TransactionIsolationLevel currentLevel = getTransactionIsolationLevel();\n            if (currentLevel != level && level != TransactionIsolationLevel.UNKNOWN) {\n                throw new TransactionException(\n                    \"Tried to execute nested transaction with isolation level \" + level + \", \"\n                    + \"but already running in a transaction with isolation level \" + currentLevel + \".\");\n            }\n            return callback.withHandle(this);\n        }\n\n        try (TransactionResetter tr = new TransactionResetter(getTransactionIsolationLevel())) {\n            setTransactionIsolation(level);\n            return transactions.inTransaction(this, level, callback);\n        }\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param consumer a callback which will receive an open handle, in a transaction.\n     * @param <X> exception type thrown by the callback, if any\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(TransactionIsolationLevel level, HandleConsumer<X> consumer) throws X {\n        inTransaction(level, consumer.asCallback());\n    }\n\n    /**\n     * Set the transaction isolation level on the underlying connection.\n     *\n     * @throws UnableToManipulateTransactionIsolationLevelException if isolation level is not supported by the underlying connection or JDBC driver\n     *\n     * @param level the isolation level to use\n     */\n    public void setTransactionIsolation(TransactionIsolationLevel level) {\n        if (level != TransactionIsolationLevel.UNKNOWN) {\n            setTransactionIsolation(level.intValue());\n        }\n    }\n\n    /**\n     * Set the transaction isolation level on the underlying connection.\n     *\n     * @param level the isolation level to use\n     */\n    public void setTransactionIsolation(int level) {\n        try {\n            if (connection.getTransactionIsolation() != level) {\n                connection.setTransactionIsolation(level);\n            }\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    /**\n     * Obtain the current transaction isolation level.\n     *\n     * @return the current isolation level on the underlying connection\n     */\n    public TransactionIsolationLevel getTransactionIsolationLevel() {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    /**\n     * Create a Jdbi extension object of the specified type bound to this handle. The returned extension's lifecycle is\n     * coupled to the lifecycle of this handle. Closing the handle will render the extension unusable.\n     *\n     * @param extensionType the extension class\n     * @param <T> the extension type\n     * @return the new extension object bound to this handle\n     */\n    public <T> T attach(Class<T> extensionType) {\n        return getConfig(Extensions.class)\n                .findFor(extensionType, ConstantHandleSupplier.of(this))\n                .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n    }\n\n    /**\n     * Returns the extension method currently bound to the handle's context.\n     *\n     * @return the extension method currently bound to the handle's context\n     */\n    public ExtensionMethod getExtensionMethod() {\n        return localExtensionMethod.get();\n    }\n\n    void setExtensionMethod(ExtensionMethod extensionMethod) {\n        this.localExtensionMethod.set(extensionMethod);\n    }\n\n    void setExtensionMethodThreadLocal(ThreadLocal<ExtensionMethod> extensionMethodThreadLocal) {\n        this.localExtensionMethod = requireNonNull(extensionMethodThreadLocal);\n    }\n\n    private void notifyHandleCreated() {\n        handleListeners.forEach(listener -> listener.handleCreated(this));\n    }\n\n    private void notifyHandleClosed() {\n        handleListeners.forEach(listener -> listener.handleClosed(this));\n    }\n\n    private class TransactionResetter implements Closeable {\n\n        private final TransactionIsolationLevel initial;\n\n        TransactionResetter(TransactionIsolationLevel initial) {\n            this.initial = initial;\n        }\n\n        @Override\n        public void close() {\n            setTransactionIsolation(initial);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.io.Closeable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport javax.annotation.concurrent.GuardedBy;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.Configurable;\nimport org.jdbi.v3.core.extension.ExtensionMethod;\nimport org.jdbi.v3.core.extension.Extensions;\nimport org.jdbi.v3.core.extension.NoSuchExtensionException;\nimport org.jdbi.v3.core.internal.exceptions.ThrowableSuppressor;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.statement.Batch;\nimport org.jdbi.v3.core.statement.Call;\nimport org.jdbi.v3.core.statement.Cleanable;\nimport org.jdbi.v3.core.statement.MetaData;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.jdbi.v3.core.statement.Query;\nimport org.jdbi.v3.core.statement.Script;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.Update;\nimport org.jdbi.v3.core.transaction.TransactionException;\nimport org.jdbi.v3.core.transaction.TransactionHandler;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.jdbi.v3.core.transaction.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.meta.Beta;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\n/**\n * This represents a connection to the database system. It is a wrapper around\n * a JDBC Connection object.  Handle provides essential methods for transaction\n * management, statement creation, and other operations tied to the database session.\n */\npublic class Handle implements Closeable, Configurable<Handle> {\n    private static final Logger LOG = LoggerFactory.getLogger(Handle.class);\n\n    private final Jdbi jdbi;\n    private final Cleanable connectionCleaner;\n    private final TransactionHandler transactions;\n    private final Connection connection;\n    private final boolean forceEndTransactions;\n\n    private ThreadLocal<ConfigRegistry> localConfig;\n    private ThreadLocal<ExtensionMethod> localExtensionMethod;\n    private StatementBuilder statementBuilder;\n\n    @GuardedBy(\"transactionCallbacks\")\n    private final List<TransactionCallback> transactionCallbacks = new ArrayList<>();\n\n    private final Set<Cleanable> cleanables = new LinkedHashSet<>();\n\n    private final Set<HandleListener> handleListeners = new CopyOnWriteArraySet<>();\n\n    private final AtomicBoolean closed = new AtomicBoolean();\n\n    static Handle createHandle(Jdbi jdbi,\n        ConfigRegistry config,\n        Cleanable connectionCleaner,\n        TransactionHandler transactions,\n        StatementBuilder statementBuilder,\n        Connection connection) throws SQLException {\n        Handle handle = new Handle(jdbi, config, connectionCleaner, transactions, statementBuilder, connection);\n\n        handle.notifyHandleCreated();\n        return handle;\n    }\n\n    private Handle(Jdbi jdbi,\n        ConfigRegistry config,\n        Cleanable connectionCleaner,\n        TransactionHandler transactions,\n        StatementBuilder statementBuilder,\n        Connection connection) throws SQLException {\n        this.jdbi = jdbi;\n        this.connectionCleaner = connectionCleaner;\n        this.connection = connection;\n\n        // this piece is probably related to the comments in LazyHandleSupplier\n        // about tomcat leak checker false positives. This needs revisiting.\n        this.localConfig = ThreadLocal.withInitial(() -> config);\n        this.localExtensionMethod = new ThreadLocal<>();\n\n        this.statementBuilder = statementBuilder;\n        this.handleListeners.addAll(config.get(Handles.class).getListeners());\n\n        // both of these methods are bad because they leak a reference to this handle before the c'tor finished.\n        this.transactions = transactions.specialize(this);\n        this.forceEndTransactions = !transactions.isInTransaction(this);\n\n        addCleanable(() -> {\n            // shut down statement builder\n            if (checkConnectionIsLive()) {\n                statementBuilder.close(connection);\n            }\n            // clean up the local state when the handle is closed.\n            localExtensionMethod.remove();\n            localConfig.remove();\n        });\n    }\n\n    public Jdbi getJdbi() {\n        return jdbi;\n    }\n\n    @Override\n    public ConfigRegistry getConfig() {\n        return localConfig.get();\n    }\n\n    void setConfig(ConfigRegistry config) {\n        this.localConfig.set(config);\n    }\n\n    void setLocalConfig(ThreadLocal<ConfigRegistry> configThreadLocal) {\n        // Without explicit remove the Tomcats thread-local leak detector gives superfluous warnings\n        this.localConfig.remove();\n        this.localConfig = configThreadLocal;\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses.\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    public Connection getConnection() {\n        return this.connection;\n    }\n\n    /**\n     * Returns the current {@link StatementBuilder}.\n     *\n     * @return the current {@link StatementBuilder}\n     */\n    public StatementBuilder getStatementBuilder() {\n        return statementBuilder;\n    }\n\n    /**\n     * Specify the statement builder to use for this handle.\n     *\n     * @param builder StatementBuilder to be used\n     * @return this\n     */\n    public Handle setStatementBuilder(StatementBuilder builder) {\n        this.statementBuilder = builder;\n        return this;\n    }\n\n    /**\n     * Add a specific {@link HandleListener} which is called for specific events for this Handle. Note that\n     * it is not possible to add a listener that wants to implement {@link HandleListener#handleCreated} this way\n     * as the handle has already been created. Use {@link Handles#addListener} in this case.\n     * <br>\n     * A listener added through this call is specific to the handle and not shared with other handles.\n     *\n     * @param handleListener A {@link HandleListener} object.\n     *\n     * @return The handle itself.\n     */\n    public Handle addHandleListener(HandleListener handleListener) {\n        handleListeners.add(handleListener);\n\n        return this;\n    }\n\n    /**\n     * Remove a {@link HandleListener} from this handle.\n     * <br>\n     * Removing the listener only affects the current handle. To remove a listener for all future handles, use {@link Handles#removeListener}.\n     *\n     * @param handleListener A {@link HandleListener} object.\n     *\n     * @return The handle itself.\n     */\n    public Handle removeHandleListener(HandleListener handleListener) {\n        handleListeners.remove(handleListener);\n\n        return this;\n    }\n\n    /**\n     * Registers a {@code Cleanable} to be invoked when the handle is closed. Any cleanable registered here will only be cleaned once.\n     * <p>\n     * Resources cleaned up by Jdbi include {@link java.sql.ResultSet}, {@link java.sql.Statement}, {@link java.sql.Array}, and {@link StatementBuilder}.\n     *\n     * @param cleanable the Cleanable to clean on close\n     */\n    public final void addCleanable(Cleanable cleanable) {\n\n        synchronized (cleanables) {\n            cleanables.add(cleanable);\n        }\n    }\n\n    /**\n     * Unegister a {@code Cleanable} from the Handle.\n     *\n     * @param cleanable the Cleanable to be unregistered.\n     */\n    public final void removeCleanable(Cleanable cleanable) {\n\n        synchronized (cleanables) {\n            cleanables.remove(cleanable);\n        }\n    }\n\n    /**\n     * Closes the handle, its connection, and any other database resources it is holding.\n     *\n     * @throws CloseException if any resources throw exception while closing\n     * @throws TransactionException if called while the handle has a transaction open. The open transaction will be\n     * rolled back.\n     */\n    @Override\n    public void close() {\n\n        if (closed.getAndSet(true)) {\n            return;\n        }\n\n        // do this at call time, otherwise running the cleanables may affect the state of the other handle objects (e.g. the config)\n        final boolean doForceEndTransactions = this.forceEndTransactions && localConfig.get().get(Handles.class).isForceEndTransactions();\n\n        try {\n            ThrowableSuppressor throwableSuppressor = new ThrowableSuppressor();\n\n            doClean(throwableSuppressor);\n\n            try {\n                cleanConnection(doForceEndTransactions);\n            } catch (Throwable t) {\n                throwableSuppressor.attachToThrowable(t);\n                throw t;\n            }\n\n            throwableSuppressor.throwIfNecessary(t -> new CloseException(\"While closing handle\", t));\n        } finally {\n            LOG.trace(\"Handle [{}] released\", this);\n\n            notifyHandleClosed();\n        }\n    }\n\n    /**\n     * Release any database resource that may be held by the handle. This affects\n     * any statement that was created from the Handle.\n     */\n    public void clean() {\n        ThrowableSuppressor throwableSuppressor = new ThrowableSuppressor();\n\n        doClean(throwableSuppressor);\n\n        throwableSuppressor.throwIfNecessary();\n    }\n\n    /**\n     * Returns true if the Handle currently holds no database resources.\n     * <br>\n     * Note that this method will return <code>false<\/code> right after statement creation\n     * as every statement registers its statement context with the handle. Once\n     *\n     * @return True if the handle holds no database resources.\n     */\n    public boolean isClean() {\n        synchronized (cleanables) {\n            return cleanables.isEmpty();\n        }\n    }\n\n    private void doClean(ThrowableSuppressor throwableSuppressor) {\n        List<Cleanable> cleanablesCopy;\n\n        synchronized (cleanables) {\n            cleanablesCopy = new ArrayList<>(cleanables);\n            cleanables.clear();\n        }\n\n        Collections.reverse(cleanablesCopy);\n\n        for (Cleanable cleanable : cleanablesCopy) {\n            throwableSuppressor.suppressAppend(cleanable::close);\n        }\n    }\n\n    /**\n     * Returns true if the {@link Handle} has been closed.\n     *\n     * @return True if the Handle is closed.\n     */\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    /**\n     * Convenience method which creates a query with the given positional arguments.\n     *\n     * @param sql SQL or named statement\n     * @param args arguments to bind positionally\n     * @return query object\n     */\n    public Query select(CharSequence sql, Object... args) {\n        Query query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query;\n    }\n\n    /**\n     * Convenience method which creates a query with the given positional arguments. Takes a string argument for backwards compatibility reasons.\n     * @param sql SQL or named statement\n     * @param args arguments to bind positionally\n     * @return query object\n     * @see Handle#select(CharSequence, Object...)\n     */\n    public Query select(String sql, Object... args) {\n        return select((CharSequence) sql, args);\n    }\n\n    /**\n     * Execute a SQL statement, and return the number of rows affected by the statement.\n     *\n     * @param sql the SQL statement to execute, using positional parameters (if any).\n     * @param args positional arguments.\n     *\n     * @return the number of rows affected.\n     */\n    public int execute(CharSequence sql, Object... args) {\n        try (Update stmt = createUpdate(sql)) {\n            int position = 0;\n            for (Object arg : args) {\n                stmt.bind(position++, arg);\n            }\n            return stmt.execute();\n        }\n    }\n\n    /**\n     * Execute a SQL statement, and return the number of rows affected by the statement. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the SQL statement to execute, using positional parameters (if any).\n     * @param args positional arguments.\n     *\n     * @return the number of rows affected.\n     * @see Handle#execute(CharSequence, Object...)\n     */\n    public int execute(String sql, Object... args) {\n        return execute((CharSequence) sql, args);\n    }\n\n    /**\n     * Create a non-prepared (no bound parameters, but different SQL) batch statement.\n     * @return empty batch\n     * @see Handle#prepareBatch(String)\n     */\n    public Batch createBatch() {\n        return new Batch(this);\n    }\n\n    /**\n     * Prepare a batch to execute. This is for efficiently executing more than one\n     * of the same statements with different parameters bound.\n     *\n     * @param sql the batch SQL.\n     * @return a batch which can have \"statements\" added.\n     */\n    public PreparedBatch prepareBatch(CharSequence sql) {\n        return new PreparedBatch(this, sql);\n    }\n\n    /**\n     * Prepare a batch to execute. This is for efficiently executing more than one\n     * of the same statements with different parameters bound. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the batch SQL.\n     * @return a batch which can have \"statements\" added.\n     * @see Handle#prepareBatch(CharSequence)\n     */\n    public PreparedBatch prepareBatch(String sql) {\n        return prepareBatch((CharSequence) sql);\n    }\n\n    /**\n     * Create a call to a stored procedure.\n     *\n     * @param sql the stored procedure sql.\n     *\n     * @return the Call.\n     */\n    public Call createCall(CharSequence sql) {\n        return new Call(this, sql);\n    }\n\n    /**\n     * Create a call to a stored procedure. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the stored procedure sql.\n     *\n     * @return the Call.\n     * @see Handle#createCall(CharSequence)\n     */\n    public Call createCall(String sql) {\n        return createCall((CharSequence) sql);\n    }\n\n    /**\n     * Return a Query instance that executes a statement\n     * with bound parameters and maps the result set into Java types.\n     * @param sql SQL that may return results.\n     * @return a Query builder.\n     */\n    public Query createQuery(CharSequence sql) {\n        return new Query(this, sql);\n    }\n\n    /**\n     * Return a Query instance that executes a statement\n     * with bound parameters and maps the result set into Java types. Takes a string argument for backwards compatibility reasons.\n     * @param sql SQL that may return results.\n     * @return a Query builder.\n     * @see Handle#createQuery(CharSequence)\n     */\n    public Query createQuery(String sql) {\n        return createQuery((CharSequence) sql);\n    }\n\n    /**\n     * Creates a Script from the given SQL script.\n     *\n     * @param sql the SQL script.\n     *\n     * @return the created Script.\n     */\n    public Script createScript(CharSequence sql) {\n        return new Script(this, sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     *\n     * @see Handle#createScript(CharSequence)\n     */\n    public Script createScript(String sql) {\n        return createScript((CharSequence) sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     */\n    public Update createUpdate(CharSequence sql) {\n        return new Update(this, sql);\n    }\n\n    /**\n     * Create an Insert or Update statement which returns the number of rows modified. Takes a string argument for backwards compatibility reasons.\n     *\n     * @param sql the statement sql.\n     *\n     * @return the Update builder.\n     *\n     * @see Handle#createUpdate(CharSequence)\n     */\n    public Update createUpdate(String sql) {\n        return createUpdate((CharSequence) sql);\n    }\n\n    /**\n     * Access database metadata that returns a {@link java.sql.ResultSet}. All methods of {@link org.jdbi.v3.core.result.ResultBearing} can be used to format\n     * and map the returned results.\n     *\n     * <pre>\n     *     List&lt;String&gt; catalogs = h.queryMetadata(DatabaseMetaData::getCatalogs)\n     *                                      .mapTo(String.class)\n     *                                      .list();\n     * <\/pre>\n     * <p>\n     * returns the list of catalogs from the current database.\n     *\n     * @param metadataFunction Maps the provided {@link java.sql.DatabaseMetaData} object onto a {@link java.sql.ResultSet} object.\n     * @return The metadata builder.\n     */\n    public ResultBearing queryMetadata(MetaData.MetaDataResultSetProvider metadataFunction) {\n        return new MetaData(this, metadataFunction);\n    }\n\n    /**\n     * Access all database metadata that returns simple values.\n     *\n     * <pre>\n     *     boolean supportsTransactions = handle.queryMetadata(DatabaseMetaData::supportsTransactions);\n     * <\/pre>\n     *\n     * @param metadataFunction Maps the provided {@link java.sql.DatabaseMetaData} object to a response object.\n     * @return The response object.\n     */\n    public <T> T queryMetadata(MetaData.MetaDataValueProvider<T> metadataFunction) {\n        try (MetaData metadata = new MetaData(this, metadataFunction)) {\n            return metadata.execute();\n        }\n    }\n\n    /**\n     * Returns whether the handle is in a transaction. Delegates to the underlying {@link TransactionHandler}.\n     *\n     * @return True if the handle is in a transaction.\n     */\n    public boolean isInTransaction() {\n        return transactions.isInTransaction(this);\n    }\n\n    /**\n     * Start a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle begin() {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle commit() {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, msSince(start));\n        drainCallbacks()\n                .forEach(TransactionCallback::afterCommit);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction.\n     *\n     * @return the same handle\n     */\n    public Handle rollback() {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, msSince(start));\n        drainCallbacks()\n                .forEach(TransactionCallback::afterRollback);\n        return this;\n    }\n\n    /**\n     * Execute an action the next time this Handle commits, unless it is rolled back first.\n     * @param afterCommit the action to execute after commit\n     * @return this Handle\n     */\n    @Beta\n    public Handle afterCommit(Runnable afterCommit) {\n        return addTransactionCallback(new TransactionCallback() {\n            @Override\n            public void afterCommit() {\n                afterCommit.run();\n            }\n        });\n    }\n\n    /**\n     * Execute an action the next time this Handle rolls back, unless it is committed first.\n     * @param afterRollback the action to execute after rollback\n     * @return this Handle\n     */\n    @Beta\n    public Handle afterRollback(Runnable afterRollback) {\n       return addTransactionCallback(new TransactionCallback() {\n            @Override\n            public void afterRollback() {\n                afterRollback.run();\n            }\n        });\n    }\n\n    List<TransactionCallback> drainCallbacks() {\n        synchronized (transactionCallbacks) {\n            List<TransactionCallback> result = new ArrayList<>(transactionCallbacks);\n            transactionCallbacks.clear();\n            return result;\n        }\n    }\n\n    Handle addTransactionCallback(TransactionCallback cb) {\n        if (!isInTransaction()) {\n            throw new IllegalStateException(\"Handle must be in transaction\");\n        }\n        synchronized (transactionCallbacks) {\n            transactionCallbacks.add(cb);\n        }\n        return this;\n    }\n\n    /**\n     * Rollback a transaction to a named savepoint.\n     *\n     * @param savepointName the name of the savepoint, previously declared with {@link Handle#savepoint}\n     *\n     * @return the same handle\n     */\n    public Handle rollbackToSavepoint(String savepointName) {\n        final long start = System.nanoTime();\n        transactions.rollbackToSavepoint(this, savepointName);\n        LOG.trace(\"Handle [{}] rollback to savepoint \\\"{}\\\" in {}ms\", this, savepointName, msSince(start));\n        return this;\n    }\n\n    private static long msSince(final long start) {\n        return MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS);\n    }\n\n    /**\n     * Create a transaction savepoint with the name provided.\n     *\n     * @param name The name of the savepoint\n     * @return The same handle\n     */\n    public Handle savepoint(String name) {\n        transactions.savepoint(this, name);\n        LOG.trace(\"Handle [{}] savepoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release a previously created savepoint.\n     *\n     * @param savepointName the name of the savepoint to release\n     * @return the same handle\n     */\n    public Handle release(String savepointName) {\n        transactions.releaseSavepoint(this, savepointName);\n        LOG.trace(\"Handle [{}] release savepoint \\\"{}\\\"\", this, savepointName);\n        return this;\n    }\n\n    /**\n     * Whether the connection is in read-only mode.\n     *\n     * @return True if the connection is in read-only mode.\n     * @see Connection#isReadOnly()\n     */\n    public boolean isReadOnly() {\n        try {\n            return connection.isReadOnly();\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"Could not getReadOnly\", e);\n        }\n    }\n\n    /**\n     * Set the Handle readOnly.\n     * This acts as a hint to the database to improve performance or concurrency.\n     *\n     * May not be called in an active transaction!\n     *\n     * @see Connection#setReadOnly(boolean)\n     * @param readOnly whether the Handle is readOnly\n     * @return this Handle\n     */\n    public Handle setReadOnly(boolean readOnly) {\n        try {\n            connection.setReadOnly(readOnly);\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"Could not setReadOnly\", e);\n        }\n        return this;\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction, and returns the result of the callback.\n     *\n     * @param callback a callback which will receive an open handle, in a transaction.\n     * @param <R> type returned by callback\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @return value returned from the callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(HandleCallback<R, X> callback) throws X {\n        return isInTransaction()\n            ? callback.withHandle(this)\n            : transactions.inTransaction(this, callback);\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction.\n     *\n     * @param consumer a callback which will receive an open handle, in a transaction.\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(final HandleConsumer<X> consumer) throws X {\n        inTransaction(consumer.asCallback());\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction, and returns the result of the callback.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param callback a callback which will receive an open handle, in a transaction.\n     * @param <R> type returned by callback\n     * @param <X> exception type thrown by the callback, if any\n     *\n     * @return value returned from the callback\n     *\n     * @throws X any exception thrown by the callback\n     */\n    public <R, X extends Exception> R inTransaction(TransactionIsolationLevel level, HandleCallback<R, X> callback) throws X {\n        if (isInTransaction()) {\n            TransactionIsolationLevel currentLevel = getTransactionIsolationLevel();\n            if (currentLevel != level && level != TransactionIsolationLevel.UNKNOWN) {\n                throw new TransactionException(\n                    \"Tried to execute nested transaction with isolation level \" + level + \", \"\n                    + \"but already running in a transaction with isolation level \" + currentLevel + \".\");\n            }\n            return callback.withHandle(this);\n        }\n\n        try (TransactionResetter tr = new TransactionResetter(getTransactionIsolationLevel())) {\n            setTransactionIsolation(level);\n            return transactions.inTransaction(this, level, callback);\n        }\n    }\n\n    /**\n     * Executes <code>callback<\/code> in a transaction.\n     *\n     * <p>\n     * This form accepts a transaction isolation level which will be applied to the connection\n     * for the scope of this transaction, after which the original isolation level will be restored.\n     * <\/p>\n     * @param level the transaction isolation level which will be applied to the connection for the scope of this\n     *              transaction, after which the original isolation level will be restored.\n     * @param consumer a callback which will receive an open handle, in a transaction.\n     * @param <X> exception type thrown by the callback, if any\n     * @throws X any exception thrown by the callback\n     */\n    public <X extends Exception> void useTransaction(TransactionIsolationLevel level, HandleConsumer<X> consumer) throws X {\n        inTransaction(level, consumer.asCallback());\n    }\n\n    /**\n     * Set the transaction isolation level on the underlying connection.\n     *\n     * @throws UnableToManipulateTransactionIsolationLevelException if isolation level is not supported by the underlying connection or JDBC driver\n     *\n     * @param level the isolation level to use\n     */\n    public void setTransactionIsolation(TransactionIsolationLevel level) {\n        if (level != TransactionIsolationLevel.UNKNOWN) {\n            setTransactionIsolation(level.intValue());\n        }\n    }\n\n    /**\n     * Set the transaction isolation level on the underlying connection.\n     *\n     * @param level the isolation level to use\n     */\n    public void setTransactionIsolation(int level) {\n        try {\n            if (connection.getTransactionIsolation() != level) {\n                connection.setTransactionIsolation(level);\n            }\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    /**\n     * Obtain the current transaction isolation level.\n     *\n     * @return the current isolation level on the underlying connection\n     */\n    public TransactionIsolationLevel getTransactionIsolationLevel() {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        } catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    /**\n     * Create a Jdbi extension object of the specified type bound to this handle. The returned extension's lifecycle is\n     * coupled to the lifecycle of this handle. Closing the handle will render the extension unusable.\n     *\n     * @param extensionType the extension class\n     * @param <T> the extension type\n     * @return the new extension object bound to this handle\n     */\n    public <T> T attach(Class<T> extensionType) {\n        return getConfig(Extensions.class)\n                .findFor(extensionType, ConstantHandleSupplier.of(this))\n                .orElseThrow(() -> new NoSuchExtensionException(extensionType));\n    }\n\n    /**\n     * Returns the extension method currently bound to the handle's context.\n     *\n     * @return the extension method currently bound to the handle's context\n     */\n    public ExtensionMethod getExtensionMethod() {\n        return localExtensionMethod.get();\n    }\n\n    void setExtensionMethod(ExtensionMethod extensionMethod) {\n        this.localExtensionMethod.set(extensionMethod);\n    }\n\n    void setExtensionMethodThreadLocal(ThreadLocal<ExtensionMethod> extensionMethodThreadLocal) {\n        this.localExtensionMethod = requireNonNull(extensionMethodThreadLocal);\n    }\n\n    private void notifyHandleCreated() {\n        handleListeners.forEach(listener -> listener.handleCreated(this));\n    }\n\n    private void notifyHandleClosed() {\n        handleListeners.forEach(listener -> listener.handleClosed(this));\n    }\n\n    private void cleanConnection(boolean doForceEndTransactions) {\n\n        final ThrowableSuppressor throwableSuppressor = new ThrowableSuppressor();\n        final boolean connectionIsLive = checkConnectionIsLive();\n\n        boolean wasInTransaction = false;\n\n        if (connectionIsLive && doForceEndTransactions) {\n            wasInTransaction = throwableSuppressor.suppressAppend(this::isInTransaction, false);\n        }\n\n        if (wasInTransaction) {\n            throwableSuppressor.suppressAppend(this::rollback);\n        }\n\n        if (connectionIsLive) {\n            try {\n                connectionCleaner.close();\n            } catch (SQLException e) {\n                CloseException ce = new CloseException(\"Unable to close Connection\", e);\n                throwableSuppressor.attachToThrowable(ce);\n                throw ce;\n            }\n\n            throwableSuppressor.throwIfNecessary(t -> new CloseException(\"Failed to clear transaction status on close\", t));\n\n            if (wasInTransaction) {\n                TransactionException te = new TransactionException(\"Improper transaction handling detected: A Handle with an open \"\n                    + \"transaction was closed. Transactions must be explicitly committed or rolled back \"\n                    + \"before closing the Handle. \"\n                    + \"Jdbi has rolled back this transaction automatically. \"\n                    + \"This check may be disabled by calling getConfig(Handles.class).setForceEndTransactions(false).\");\n\n                throwableSuppressor.attachToThrowable(te); // any exception present is not the cause but just collateral.\n                throw te;\n            }\n        } else {\n            throwableSuppressor.throwIfNecessary(t -> new CloseException(\"Failed to clear transaction status on close\", t));\n        }\n    }\n\n    private boolean checkConnectionIsLive() {\n        try {\n            return !connection.isClosed();\n        } catch (SQLException e) {\n            // if the connection state can not be determined, assume that the\n            // connection is closed and ignore the exception\n            return false;\n        }\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Handle handle = (Handle) o;\n        return jdbi.equals(handle.jdbi) && connection.equals(handle.connection);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(jdbi, connection);\n    }\n\n    private class TransactionResetter implements Closeable {\n\n        private final TransactionIsolationLevel initial;\n\n        TransactionResetter(TransactionIsolationLevel initial) {\n            this.initial = initial;\n        }\n\n        @Override\n        public void close() {\n            setTransactionIsolation(initial);\n        }\n    }\n}\n","lineNo":251}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport de.softwareforge.testing.postgres.junit5.EmbeddedPgExtension;\nimport de.softwareforge.testing.postgres.junit5.MultiDatabaseBuilder;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.statement.SqlStatements;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\nimport org.jdbi.v3.postgres.PostgresPlugin;\nimport org.jdbi.v3.sqlobject.SqlObjectPlugin;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.postgresql.util.PSQLException;\nimport org.postgresql.util.PSQLState;\n\nimport static org.assertj.core.api.Assertions.assertThatCode;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestStatementsTimeout {\n\n    @RegisterExtension\n    public static EmbeddedPgExtension pg = MultiDatabaseBuilder.instanceWithDefaults().build();\n\n    @RegisterExtension\n    public JdbiExtension pgExtension = JdbiExtension.postgres(pg).withPlugins(new SqlObjectPlugin(), new PostgresPlugin());\n\n    private Handle h;\n\n    @BeforeEach\n    public void setUp() {\n        h = pgExtension.openHandle();\n    }\n\n    @AfterEach\n    public void tearDown() {\n        h.close();\n    }\n\n    @Test\n    public void testTimeout() {\n        h.getConfig(SqlStatements.class).setQueryTimeout(2);\n\n        assertThatCode(h.createQuery(\"select pg_sleep(1)\").mapTo(String.class)::findOnly)\n            .doesNotThrowAnyException();\n\n        assertThatThrownBy(h.createQuery(\"select pg_sleep(3)\").mapTo(String.class)::findOnly)\n            .isInstanceOf(UnableToExecuteStatementException.class)\n            .hasCauseInstanceOf(PSQLException.class)\n            .matches(ex -> PSQLState.QUERY_CANCELED.getState().equals(((PSQLException) ex.getCause()).getSQLState()));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport de.softwareforge.testing.postgres.junit5.EmbeddedPgExtension;\nimport de.softwareforge.testing.postgres.junit5.MultiDatabaseBuilder;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.statement.Query;\nimport org.jdbi.v3.core.statement.SqlStatements;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\nimport org.jdbi.v3.postgres.PostgresPlugin;\nimport org.jdbi.v3.sqlobject.SqlObjectPlugin;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.postgresql.util.PSQLException;\nimport org.postgresql.util.PSQLState;\n\nimport static org.assertj.core.api.Assertions.assertThatCode;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestStatementsTimeout {\n\n    @RegisterExtension\n    public static EmbeddedPgExtension pg = MultiDatabaseBuilder.instanceWithDefaults().build();\n\n    @RegisterExtension\n    public JdbiExtension pgExtension = JdbiExtension.postgres(pg).withPlugins(new SqlObjectPlugin(), new PostgresPlugin());\n\n    private Handle h;\n\n    @BeforeEach\n    public void setUp() {\n        h = pgExtension.openHandle();\n    }\n\n    @AfterEach\n    public void tearDown() {\n        h.close();\n    }\n\n    @Test\n    public void testTimeout() {\n        h.getConfig(SqlStatements.class).setQueryTimeout(2);\n\n        assertThatCode(h.createQuery(\"select pg_sleep(1)\").mapTo(String.class)::one)\n            .doesNotThrowAnyException();\n\n        try (Query query = h.createQuery(\"select pg_sleep(3)\")) {\n            ResultIterable<String> iterable = query.mapTo(String.class);\n\n            assertThatThrownBy(iterable::one)\n            .isInstanceOf(UnableToExecuteStatementException.class)\n                .hasCauseInstanceOf(PSQLException.class)\n                .matches(ex -> PSQLState.QUERY_CANCELED.getState().equals(((PSQLException) ex.getCause()).getSQLState()));\n        }\n    }\n}\n","lineNo":64}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.result;\n\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.junit5.H2DatabaseExtension;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestIterator {\n\n    @RegisterExtension\n    public H2DatabaseExtension h2Extension = H2DatabaseExtension.withSomething();\n\n    private Handle h;\n\n    @BeforeEach\n    public void setUp() {\n        h = h2Extension.openHandle();\n    }\n\n    @AfterEach\n    public void doTearDown() {\n        assertThat(h.isClosed()).withFailMessage(\"Handle was not closed correctly!\").isTrue();\n    }\n\n    @Test\n    public void testSimple() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).isExhausted();\n    }\n\n    @Test\n    public void testEmptyWorksToo() {\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).isExhausted();\n    }\n\n    @Test\n    public void testHasNext() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).hasNext()\n                      .hasNext()\n                      .hasNext();\n        it.next();\n        assertThat(it).hasNext()\n                      .hasNext()\n                      .hasNext();\n        it.next();\n        assertThat(it).hasNext()\n                      .hasNext()\n                      .hasNext();\n        it.next();\n        assertThat(it).isExhausted()\n                      .isExhausted()\n                      .isExhausted();\n    }\n\n    @Test\n    public void testNext() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).hasNext();\n        it.next();\n        it.next();\n        it.next();\n        assertThat(it).isExhausted();\n    }\n\n    @Test\n    public void testJustNext() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it.next()).containsEntry(\"name\", \"eric\");\n        assertThat(it.next()).containsEntry(\"name\", \"brian\");\n        assertThat(it.next()).containsEntry(\"name\", \"john\");\n    }\n\n    @Test\n    public void testTwoTwo() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        it.next();\n        it.next();\n        assertThat(it).hasNext()\n                      .hasNext();\n        it.next();\n        assertThat(it).isExhausted()\n                      .isExhausted();\n    }\n\n    @Test\n    public void testTwoOne() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).hasNext();\n        it.next();\n        it.next();\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).isExhausted();\n    }\n\n    @Test\n    public void testExplodeIterator() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).isExhausted();\n\n        assertThatThrownBy(it::next).isInstanceOf(IllegalStateException.class);\n    }\n\n    @Test\n    public void testEmptyExplosion() {\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThatThrownBy(it::next).isInstanceOf(NoSuchElementException.class);\n    }\n\n    @Test\n    public void testNonPathologicalJustNext() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n\n        // Yes, you *should* use first(). But sometimes, an iterator is passed 17 levels deep and then\n        // used in this way (Hello Jackson!).\n        final Map<String, Object> result = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator()\n            .next();\n\n        assertThat(result.get(\"id\")).isEqualTo(1L);\n        assertThat(result.get(\"name\")).isEqualTo(\"eric\");\n    }\n\n    @Test\n    public void testStillLeakingJustNext() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n\n        // Yes, you *should* use first(). But sometimes, an iterator is passed 17 levels deep and then\n        // used in this way (Hello Jackson!).\n        final Map<String, Object> result = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator()\n            .next();\n\n        assertThat(result.get(\"id\")).isEqualTo(1L);\n        assertThat(result.get(\"name\")).isEqualTo(\"eric\");\n\n        assertThat(h.isClosed()).isFalse();\n\n        // The Query created by createQuery() above just leaked a Statement and a ResultSet. It is necessary\n        // to explicitly close the iterator in that case. However, as this test case is using the CachingStatementBuilder,\n        // closing the handle will close the statements (which also closes the result sets).\n        //\n        // Don't try this at home folks. It is still very possible to leak stuff with the iterators.\n\n        h.close();\n    }\n\n    @Test\n    public void testLessLeakingJustNext() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n\n        try (ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n                .cleanupHandleRollback()\n                .mapToMap()\n                .iterator()) {\n            final Map<String, Object> result = it.next();\n            assertThat(result).containsEntry(\"id\", 1L).containsEntry(\"name\", \"eric\");\n\n            assertThat(h.isClosed()).isFalse();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.result;\n\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.junit5.H2DatabaseExtension;\nimport org.jdbi.v3.core.statement.Query;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestIterator {\n\n    @RegisterExtension\n    public H2DatabaseExtension h2Extension = H2DatabaseExtension.withSomething();\n\n    private Handle h;\n\n    @BeforeEach\n    public void setUp() {\n        h = h2Extension.openHandle();\n    }\n\n    @AfterEach\n    public void doTearDown() {\n        assertThat(h.isClosed()).withFailMessage(\"Handle was not closed correctly!\").isTrue();\n    }\n\n    @Test\n    public void testSimple() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).isExhausted();\n    }\n\n    @Test\n    public void testEmptyWorksToo() {\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).isExhausted();\n    }\n\n    @Test\n    public void testHasNext() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).hasNext()\n                      .hasNext()\n                      .hasNext();\n        it.next();\n        assertThat(it).hasNext()\n                      .hasNext()\n                      .hasNext();\n        it.next();\n        assertThat(it).hasNext()\n                      .hasNext()\n                      .hasNext();\n        it.next();\n        assertThat(it).isExhausted()\n                      .isExhausted()\n                      .isExhausted();\n    }\n\n    @Test\n    public void testNext() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).hasNext();\n        it.next();\n        it.next();\n        it.next();\n        assertThat(it).isExhausted();\n    }\n\n    @Test\n    public void testJustNext() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it.next()).containsEntry(\"name\", \"eric\");\n        assertThat(it.next()).containsEntry(\"name\", \"brian\");\n        assertThat(it.next()).containsEntry(\"name\", \"john\");\n    }\n\n    @Test\n    public void testTwoTwo() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        it.next();\n        it.next();\n        assertThat(it).hasNext()\n                      .hasNext();\n        it.next();\n        assertThat(it).isExhausted()\n                      .isExhausted();\n    }\n\n    @Test\n    public void testTwoOne() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).hasNext();\n        it.next();\n        it.next();\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).isExhausted();\n    }\n\n    @Test\n    public void testExplodeIterator() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (3, 'john')\").execute();\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).hasNext();\n        it.next();\n        assertThat(it).isExhausted();\n\n        assertThatThrownBy(it::next).isInstanceOf(IllegalStateException.class);\n    }\n\n    @Test\n    public void testEmptyExplosion() {\n\n        ResultIterator<Map<String, Object>> it = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator();\n\n        assertThatThrownBy(it::next).isInstanceOf(NoSuchElementException.class);\n    }\n\n    @Test\n    public void testNonPathologicalJustNext() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n\n        // this only works (and does not leak resources) because the iterator contains only a single\n        // element and is closed (and resources released once that element is processed).\n        final Map<String, Object> result = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap()\n            .iterator()\n            .next();\n\n        assertThat(result.get(\"id\")).isEqualTo(1L);\n        assertThat(result.get(\"name\")).isEqualTo(\"eric\");\n    }\n\n    @Test\n    public void testManageResourcesOnQuery() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n\n        // this requires t-w-r to ensure that the resources of the query are released properly.\n        // this could be done through the iterator as well (see next test).\n        try (Query query = h.createQuery(\"select * from something order by id\")) {\n            final Map<String, Object> result = query.cleanupHandleRollback()\n                .mapToMap()\n                .iterator()\n                .next();\n\n            assertThat(result.get(\"id\")).isEqualTo(1L);\n            assertThat(result.get(\"name\")).isEqualTo(\"eric\");\n\n            assertThat(h.isClosed()).isFalse();\n        }\n    }\n\n    @Test\n    public void testManageResourcesOnIterator() {\n        h.createUpdate(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createUpdate(\"insert into something (id, name) values (2, 'brian')\").execute();\n\n        ResultIterable<Map<String, Object>> iterable = h.createQuery(\"select * from something order by id\")\n            .cleanupHandleRollback()\n            .mapToMap();\n\n        // use t-w-r to ensure that the resources of the query are released properly.\n        try (ResultIterator<Map<String, Object>> it = iterable.iterator()) {\n            final Map<String, Object> result = it.next();\n\n            assertThat(result.get(\"id\")).isEqualTo(1L);\n            assertThat(result.get(\"name\")).isEqualTo(\"eric\");\n\n            assertThat(h.isClosed()).isFalse();\n        }\n    }\n}\n","lineNo":252}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.interceptor;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nullable;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class JdbiInterceptionChainHolderTest {\n\n    @Test\n    public void testDefault() {\n        JdbiInterceptionChainHolder<Object, Object> holder = new JdbiInterceptionChainHolder<>();\n\n        UnsupportedOperationException e = assertThrows(UnsupportedOperationException.class, () -> holder.process(new Object()));\n\n        assertEquals(\"object type 'Object' is not supported\", e.getMessage());\n    }\n\n    @Test\n    public void testDefaultNull() {\n        JdbiInterceptionChainHolder<Object, Object> holder = new JdbiInterceptionChainHolder<>();\n\n        UnsupportedOperationException e = assertThrows(UnsupportedOperationException.class, () -> holder.process(null));\n\n        assertEquals(\"null value is not supported\", e.getMessage());\n    }\n\n    @Test\n    public void testCustomTransformer() {\n        Transformer<Object> t = new Transformer<>();\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n\n        Object source = new Object();\n\n        String result = holder.process(source);\n\n        assertSame(source, t.getSource());\n        assertEquals(t.getTarget(), result);\n    }\n\n    @Test\n    public void testCustomTransformerNull() {\n        Transformer<Object> t = new Transformer<>();\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n\n        String result = holder.process(null);\n\n        assertNull(t.getSource());\n        assertEquals(t.getTarget(), result);\n    }\n\n    @Test\n    public void testFirstInterceptorSkip() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i = new Interceptor<>(false);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addFirst(i);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertSame(source, t.getSource());\n        assertSame(source, i.getSource());\n        assertEquals(t.getTarget(), result);\n        assertNotEquals(i.getTarget(), result);\n    }\n\n    @Test\n    public void testFirstInterceptorHit() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i = new Interceptor<>(true);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addFirst(i);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertSame(source, i.getSource());\n        assertNull(t.getSource());\n        assertNotEquals(t.getTarget(), result);\n        assertEquals(i.getTarget(), result);\n    }\n\n    @Test\n    public void testLastInterceptorHit() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i = new Interceptor<>(true);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addLast(i);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertSame(source, i.getSource());\n        assertNull(t.getSource());\n        assertNotEquals(t.getTarget(), result);\n        assertEquals(i.getTarget(), result);\n    }\n\n    @Test\n    public void testLastInterceptorSkip() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i = new Interceptor<>(false);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addLast(i);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertSame(source, t.getSource());\n        assertSame(source, i.getSource());\n        assertEquals(t.getTarget(), result);\n        assertNotEquals(i.getTarget(), result);\n    }\n\n    @Test\n    public void testFirstSkipHit() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i1 = new Interceptor<>(true);\n        Interceptor<Object> i2 = new Interceptor<>(false);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addFirst(i1);\n        holder.addFirst(i2);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertSame(source, i2.getSource());\n        assertSame(source, i1.getSource());\n        assertNull(t.getSource());\n\n        assertEquals(i1.getTarget(), result);\n        assertNotEquals(i2.getTarget(), result);\n        assertNotEquals(t.getTarget(), result);\n    }\n\n    @Test\n    public void testFirstHitSkip() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i1 = new Interceptor<>(false);\n        Interceptor<Object> i2 = new Interceptor<>(true);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addFirst(i1);\n        holder.addFirst(i2);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertSame(source, i2.getSource());\n        assertNull(i1.getSource());\n        assertNull(t.getSource());\n\n        assertEquals(i2.getTarget(), result);\n        assertNotEquals(i1.getTarget(), result);\n        assertNotEquals(t.getTarget(), result);\n    }\n\n    @Test\n    public void testLastSkipHit() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i1 = new Interceptor<>(true);\n        Interceptor<Object> i2 = new Interceptor<>(false);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addLast(i1);\n        holder.addLast(i2);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertSame(source, i1.getSource());\n        assertNull(i2.getSource());\n        assertNull(t.getSource());\n\n        assertEquals(i1.getTarget(), result);\n        assertNotEquals(i2.getTarget(), result);\n        assertNotEquals(t.getTarget(), result);\n    }\n\n    @Test\n    public void testLastHitSkip() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i1 = new Interceptor<>(false);\n        Interceptor<Object> i2 = new Interceptor<>(true);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addLast(i1);\n        holder.addLast(i2);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertSame(source, i2.getSource());\n        assertSame(source, i1.getSource());\n        assertNull(t.getSource());\n\n        assertEquals(i2.getTarget(), result);\n        assertNotEquals(i1.getTarget(), result);\n        assertNotEquals(t.getTarget(), result);\n    }\n\n    static class Transformer<S> implements Function<S, String> {\n\n        private S source;\n        private final String target = UUID.randomUUID().toString();\n\n        S getSource() {\n            return source;\n        }\n\n        String getTarget() {\n            return target;\n        }\n\n        @Override\n        public String apply(S s) {\n            this.source = s;\n            return this.target;\n        }\n    }\n\n    static class Interceptor<S> implements JdbiInterceptor<S, String> {\n\n        private S source;\n        private final String target = UUID.randomUUID().toString();\n        private final boolean doIt;\n\n        Interceptor(boolean doIt) {\n            this.doIt = doIt;\n        }\n\n        S getSource() {\n            return source;\n        }\n\n        String getTarget() {\n            return target;\n        }\n\n        @CheckForNull\n        @Override\n        public String intercept(@Nullable S s, JdbiInterceptionChain<String> chain) {\n            this.source = s;\n            if (doIt) {\n                return this.target;\n            } else {\n                return chain.next();\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.interceptor;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nullable;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class JdbiInterceptionChainHolderTest {\n\n    @Test\n    public void testDefault() {\n        JdbiInterceptionChainHolder<Object, Object> jdbiInterceptionChainHolder = new JdbiInterceptionChainHolder<>();\n        Object source = new Object();\n        assertThatThrownBy(() -> jdbiInterceptionChainHolder.process(source))\n                .isInstanceOf(UnsupportedOperationException.class)\n                .hasMessage(\"object type 'Object' is not supported\");\n    }\n\n    @Test\n    public void testDefaultNull() {\n        JdbiInterceptionChainHolder<Object, Object> jdbiInterceptionChainHolder = new JdbiInterceptionChainHolder<>();\n        assertThatThrownBy(() -> jdbiInterceptionChainHolder.process(null))\n                .isInstanceOf(UnsupportedOperationException.class)\n                .hasMessage(\"null value is not supported\");\n    }\n\n    @Test\n    public void testCustomTransformer() {\n        Transformer<Object> t = new Transformer<>();\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n\n        Object source = new Object();\n\n        String result = holder.process(source);\n\n        assertThat(source).isSameAs(t.getSource());\n        assertThat(t.getTarget()).isEqualTo(result);\n    }\n\n    @Test\n    public void testCustomTransformerNull() {\n        Transformer<Object> t = new Transformer<>();\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n\n        String result = holder.process(null);\n\n        assertThat(t.getSource()).isNull();\n        assertThat(t.getTarget()).isEqualTo(result);\n    }\n\n    @Test\n    public void testFirstInterceptorSkip() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i = new Interceptor<>(false);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addFirst(i);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertThat(source).isSameAs(t.getSource())\n                          .isSameAs(i.getSource());\n        assertThat(t.getTarget()).isEqualTo(result);\n        assertThat(i.getTarget()).isNotEqualTo(result);\n    }\n\n    @Test\n    public void testFirstInterceptorHit() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i = new Interceptor<>(true);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addFirst(i);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertThat(source).isSameAs(i.getSource());\n        assertThat(t.getSource()).isNull();\n        assertThat(t.getTarget()).isNotEqualTo(result);\n        assertThat(i.getTarget()).isEqualTo(result);\n    }\n\n    @Test\n    public void testLastInterceptorHit() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i = new Interceptor<>(true);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addLast(i);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertThat(source).isSameAs(i.getSource());\n        assertThat(t.getSource()).isNull();\n        assertThat(t.getTarget()).isNotEqualTo(result);\n        assertThat(i.getTarget()).isEqualTo(result);\n    }\n\n    @Test\n    public void testLastInterceptorSkip() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i = new Interceptor<>(false);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addLast(i);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertThat(source).isSameAs(t.getSource())\n                          .isSameAs(i.getSource());\n        assertThat(t.getTarget()).isEqualTo(result);\n        assertThat(i.getTarget()).isNotEqualTo(result);\n    }\n\n    @Test\n    public void testFirstSkipHit() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i1 = new Interceptor<>(true);\n        Interceptor<Object> i2 = new Interceptor<>(false);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addFirst(i1);\n        holder.addFirst(i2);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertThat(source).isSameAs(i2.getSource())\n                          .isSameAs(i1.getSource());\n        assertThat(t.getSource()).isNull();\n\n        assertThat(i1.getTarget()).isEqualTo(result);\n        assertThat(i2.getTarget()).isNotEqualTo(result);\n        assertThat(t.getTarget()).isNotEqualTo(result);\n    }\n\n    @Test\n    public void testFirstHitSkip() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i1 = new Interceptor<>(false);\n        Interceptor<Object> i2 = new Interceptor<>(true);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addFirst(i1);\n        holder.addFirst(i2);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertThat(source).isSameAs(i2.getSource());\n        assertThat(i1.getSource()).isNull();\n        assertThat(t.getSource()).isNull();\n\n        assertThat(i2.getTarget()).isEqualTo(result);\n        assertThat(i1.getTarget()).isNotEqualTo(result);\n        assertThat(t.getTarget()).isNotEqualTo(result);\n    }\n\n    @Test\n    public void testLastSkipHit() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i1 = new Interceptor<>(true);\n        Interceptor<Object> i2 = new Interceptor<>(false);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addLast(i1);\n        holder.addLast(i2);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertThat(source).isSameAs(i1.getSource());\n        assertThat(i2.getSource()).isNull();\n        assertThat(t.getSource()).isNull();\n\n        assertThat(i1.getTarget()).isEqualTo(result);\n        assertThat(i2.getTarget()).isNotEqualTo(result);\n        assertThat(t.getTarget()).isNotEqualTo(result);\n    }\n\n    @Test\n    public void testLastHitSkip() {\n        Transformer<Object> t = new Transformer<>();\n        Interceptor<Object> i1 = new Interceptor<>(false);\n        Interceptor<Object> i2 = new Interceptor<>(true);\n\n        JdbiInterceptionChainHolder<Object, String> holder = new JdbiInterceptionChainHolder<>(t);\n        holder.addLast(i1);\n        holder.addLast(i2);\n\n        Object source = new Object();\n        String result = holder.process(source);\n\n        assertThat(source).isSameAs(i2.getSource())\n                          .isSameAs(i1.getSource());\n        assertThat(t.getSource()).isNull();\n\n        assertThat(i2.getTarget()).isEqualTo(result);\n        assertThat(i1.getTarget()).isNotEqualTo(result);\n        assertThat(t.getTarget()).isNotEqualTo(result);\n    }\n\n    static class Transformer<S> implements Function<S, String> {\n\n        private S source;\n        private final String target = UUID.randomUUID().toString();\n\n        S getSource() {\n            return source;\n        }\n\n        String getTarget() {\n            return target;\n        }\n\n        @Override\n        public String apply(S s) {\n            this.source = s;\n            return this.target;\n        }\n    }\n\n    static class Interceptor<S> implements JdbiInterceptor<S, String> {\n\n        private S source;\n        private final String target = UUID.randomUUID().toString();\n        private final boolean doIt;\n\n        Interceptor(boolean doIt) {\n            this.doIt = doIt;\n        }\n\n        S getSource() {\n            return source;\n        }\n\n        String getTarget() {\n            return target;\n        }\n\n        @CheckForNull\n        @Override\n        public String intercept(@Nullable S s, JdbiInterceptionChain<String> chain) {\n            this.source = s;\n            if (doIt) {\n                return this.target;\n            } else {\n                return chain.next();\n            }\n        }\n    }\n}\n","lineNo":32}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class InferredRowMapperFactoryTest {\n\n    @Test\n    public void acceptConcreteMapper() {\n        RowMapperFactory factory = new InferredRowMapperFactory(new DummyMapper());\n\n        Optional<RowMapper<?>> mapper = factory.build(Dummy.class, new ConfigRegistry());\n\n        assertTrue(mapper.isPresent());\n        assertEquals(DummyMapper.class, mapper.get().getClass());\n    }\n\n    @Test\n    public void rejectGenericMapper() {\n        UnsupportedOperationException e = assertThrows(UnsupportedOperationException.class,\n            () -> new InferredRowMapperFactory(new GenericMapper<>(Dummy.class)));\n        assertEquals(\"Must use a concretely typed RowMapper here\", e.getMessage());\n    }\n\n    @Test\n    public void rejectObjectMapper() {\n        UnsupportedOperationException e = assertThrows(UnsupportedOperationException.class, () -> new InferredRowMapperFactory(new ObjectMapper()));\n        assertEquals(\"Must use a concretely typed RowMapper here\", e.getMessage());\n    }\n\n    @Test\n    public void testDetectConcreteMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new DummyMapper());\n        assertTrue(type.isPresent());\n        assertSame(Dummy.class, type.get());\n    }\n\n    @Test\n    public void testDetectGenericMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new GenericMapper<>(Dummy.class));\n        assertFalse(type.isPresent());\n    }\n\n    @Test\n    public void testDetectObjectMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new ObjectMapper());\n        assertFalse(type.isPresent());\n    }\n\n    public static class Dummy {}\n\n    public static class DummyMapper implements RowMapper<Dummy> {\n\n        @Override\n        public Dummy map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return new Dummy();\n        }\n    }\n\n    public static class GenericMapper<T> implements RowMapper<T> {\n\n        public GenericMapper(Class<T> clazz) {}\n\n        @Override\n        public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n\n    public static class ObjectMapper implements RowMapper<Object> {\n\n        @Override\n        public Object map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class InferredRowMapperFactoryTest {\n\n    @Test\n    public void acceptConcreteMapper() {\n        RowMapperFactory factory = new InferredRowMapperFactory(new DummyMapper());\n\n        Optional<RowMapper<?>> mapper = factory.build(Dummy.class, new ConfigRegistry());\n\n        assertThat(mapper).isPresent().get()\n                .extracting(RowMapper::getClass).isEqualTo(DummyMapper.class);\n    }\n\n    @Test\n    public void rejectGenericMapper() {\n        GenericMapper<Dummy> mapper = new GenericMapper<>(Dummy.class);\n        assertThatThrownBy(() -> new InferredRowMapperFactory(mapper))\n                .isInstanceOf(UnsupportedOperationException.class)\n                .hasMessage(\"Must use a concretely typed RowMapper here\");\n    }\n\n    @Test\n    public void rejectObjectMapper() {\n        ObjectMapper mapper = new ObjectMapper();\n        assertThatThrownBy(() -> new InferredRowMapperFactory(mapper))\n                .isInstanceOf(UnsupportedOperationException.class)\n                .hasMessage(\"Must use a concretely typed RowMapper here\");\n    }\n\n    @Test\n    public void testDetectConcreteMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new DummyMapper());\n        assertThat(type).isPresent().get()\n                .isSameAs(Dummy.class);\n    }\n\n    @Test\n    public void testDetectGenericMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new GenericMapper<>(Dummy.class));\n        assertThat(type).isNotPresent();\n    }\n\n    @Test\n    public void testDetectObjectMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new ObjectMapper());\n        assertThat(type).isNotPresent();\n    }\n\n    public static class Dummy {}\n\n    public static class DummyMapper implements RowMapper<Dummy> {\n\n        @Override\n        public Dummy map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return new Dummy();\n        }\n    }\n\n    public static class GenericMapper<T> implements RowMapper<T> {\n\n        public GenericMapper(Class<T> clazz) {}\n\n        @Override\n        public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n\n    public static class ObjectMapper implements RowMapper<Object> {\n\n        @Override\n        public Object map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n}\n","lineNo":42}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class InferredRowMapperFactoryTest {\n\n    @Test\n    public void acceptConcreteMapper() {\n        RowMapperFactory factory = new InferredRowMapperFactory(new DummyMapper());\n\n        Optional<RowMapper<?>> mapper = factory.build(Dummy.class, new ConfigRegistry());\n\n        assertTrue(mapper.isPresent());\n        assertEquals(DummyMapper.class, mapper.get().getClass());\n    }\n\n    @Test\n    public void rejectGenericMapper() {\n        UnsupportedOperationException e = assertThrows(UnsupportedOperationException.class,\n            () -> new InferredRowMapperFactory(new GenericMapper<>(Dummy.class)));\n        assertEquals(\"Must use a concretely typed RowMapper here\", e.getMessage());\n    }\n\n    @Test\n    public void rejectObjectMapper() {\n        UnsupportedOperationException e = assertThrows(UnsupportedOperationException.class, () -> new InferredRowMapperFactory(new ObjectMapper()));\n        assertEquals(\"Must use a concretely typed RowMapper here\", e.getMessage());\n    }\n\n    @Test\n    public void testDetectConcreteMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new DummyMapper());\n        assertTrue(type.isPresent());\n        assertSame(Dummy.class, type.get());\n    }\n\n    @Test\n    public void testDetectGenericMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new GenericMapper<>(Dummy.class));\n        assertFalse(type.isPresent());\n    }\n\n    @Test\n    public void testDetectObjectMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new ObjectMapper());\n        assertFalse(type.isPresent());\n    }\n\n    public static class Dummy {}\n\n    public static class DummyMapper implements RowMapper<Dummy> {\n\n        @Override\n        public Dummy map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return new Dummy();\n        }\n    }\n\n    public static class GenericMapper<T> implements RowMapper<T> {\n\n        public GenericMapper(Class<T> clazz) {}\n\n        @Override\n        public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n\n    public static class ObjectMapper implements RowMapper<Object> {\n\n        @Override\n        public Object map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class InferredRowMapperFactoryTest {\n\n    @Test\n    public void acceptConcreteMapper() {\n        RowMapperFactory factory = new InferredRowMapperFactory(new DummyMapper());\n\n        Optional<RowMapper<?>> mapper = factory.build(Dummy.class, new ConfigRegistry());\n\n        assertThat(mapper).isPresent().get()\n                .extracting(RowMapper::getClass).isEqualTo(DummyMapper.class);\n    }\n\n    @Test\n    public void rejectGenericMapper() {\n        GenericMapper<Dummy> mapper = new GenericMapper<>(Dummy.class);\n        assertThatThrownBy(() -> new InferredRowMapperFactory(mapper))\n                .isInstanceOf(UnsupportedOperationException.class)\n                .hasMessage(\"Must use a concretely typed RowMapper here\");\n    }\n\n    @Test\n    public void rejectObjectMapper() {\n        ObjectMapper mapper = new ObjectMapper();\n        assertThatThrownBy(() -> new InferredRowMapperFactory(mapper))\n                .isInstanceOf(UnsupportedOperationException.class)\n                .hasMessage(\"Must use a concretely typed RowMapper here\");\n    }\n\n    @Test\n    public void testDetectConcreteMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new DummyMapper());\n        assertThat(type).isPresent().get()\n                .isSameAs(Dummy.class);\n    }\n\n    @Test\n    public void testDetectGenericMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new GenericMapper<>(Dummy.class));\n        assertThat(type).isNotPresent();\n    }\n\n    @Test\n    public void testDetectObjectMapper() {\n        Optional<Type> type = InferredRowMapperFactory.detectType(new ObjectMapper());\n        assertThat(type).isNotPresent();\n    }\n\n    public static class Dummy {}\n\n    public static class DummyMapper implements RowMapper<Dummy> {\n\n        @Override\n        public Dummy map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return new Dummy();\n        }\n    }\n\n    public static class GenericMapper<T> implements RowMapper<T> {\n\n        public GenericMapper(Class<T> clazz) {}\n\n        @Override\n        public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n\n    public static class ObjectMapper implements RowMapper<Object> {\n\n        @Override\n        public Object map(ResultSet rs, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n}\n","lineNo":50}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.Map;\n\nimport com.google.common.collect.ImmutableMap;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.BindMap;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.jdbi.v3.testing.junit5.internal.TestingInitializers;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static java.util.Collections.emptyMap;\nimport static java.util.Collections.singletonMap;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class TestBindMap {\n\n    @RegisterExtension\n    public JdbiExtension h2Extension = JdbiExtension.h2().withInitializer(TestingInitializers.something()).withPlugin(new SqlObjectPlugin());\n\n    private Handle handle;\n\n    private Dao dao;\n\n    @BeforeEach\n    public void setUp() {\n        handle = h2Extension.getSharedHandle();\n\n        dao = handle.attach(Dao.class);\n    }\n\n    @Test\n    public void testBindMap() {\n        handle.execute(\"insert into something (id, name) values (1, 'Alice')\");\n\n        dao.update(1, singletonMap(\"name\", \"Alicia\"));\n\n        assertThat(dao.get(1).getName()).isEqualTo(\"Alicia\");\n    }\n\n    @Test\n    public void testBindMapPrefixed() {\n        handle.execute(\"insert into something (id, name) values (1, 'Alice')\");\n\n        dao.updatePrefix(1, singletonMap(\"name\", \"Alicia\"));\n\n        assertThat(dao.get(1).getName()).isEqualTo(\"Alicia\");\n    }\n\n    @Test\n    public void testBindMapKeyInKeysAndMap() {\n        handle.execute(\"insert into something (id, name) values (2, 'Bob')\");\n\n        dao.updateNameKey(2, singletonMap(\"name\", \"Rob\"));\n\n        assertThat(dao.get(2).getName()).isEqualTo(\"Rob\");\n    }\n\n    @Test\n    public void testBindMapKeyInKeysNotInMap() {\n        handle.execute(\"insert into something(id, name) values (2, 'Bob')\");\n\n        dao.updateNameKey(2, emptyMap());\n\n        assertThat(dao.get(2).getName()).isNull();\n    }\n\n    @Test\n    public void testBindMapKeyInMapNotInKeys() {\n        handle.execute(\"insert into something(id, name) values (3, 'Carol')\");\n\n        dao.updateNameKey(3, ImmutableMap.of(\"name\", \"Cheryl\", \"integerValue\", 3));\n\n        assertThat(dao.get(3).getName()).isEqualTo(\"Cheryl\");\n        assertThat(dao.get(3).getIntegerValue()).isNull();\n    }\n\n    @Test\n    public void testBindMapKeyNotInMapOrKeys() {\n        handle.execute(\"insert into something(id, name) values (3, 'Carol')\");\n        assertThrows(UnableToCreateStatementException.class, () -> dao.update(3, emptyMap()));\n    }\n\n    @Test\n    public void testBindMapConvertKeysStringKeys() {\n        handle.execute(\"insert into something(id, name) values (4, 'Dave')\");\n\n        dao.updateConvertKeys(4, singletonMap(\"name\", \"David\"));\n\n        assertThat(dao.get(4).getName()).isEqualTo(\"David\");\n    }\n\n    @Test\n    public void testBindMapConvertKeysNonStringKeys() {\n        handle.execute(\"insert into something(id, name) values (4, 'Dave')\");\n\n        dao.updateConvertKeys(4, singletonMap(new MapKey(\"name\"), \"David\"));\n\n        assertThat(dao.get(4).getName()).isEqualTo(\"David\");\n    }\n\n    @Test\n    public void testBindMapNonStringKeys() {\n        handle.execute(\"insert into something(id, name) values (5, 'Edward')\");\n\n        assertThrows(IllegalArgumentException.class, () -> dao.update(5, singletonMap(new MapKey(\"name\"), \"Jacob\")));\n    }\n\n    public static class MapKey {\n        private final String value;\n\n        MapKey(String value) {\n            this.value = value;\n        }\n\n        @Override\n        public String toString() {\n            return value;\n        }\n    }\n\n    public interface Dao {\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void update(@Bind int id, @BindMap Map<Object, Object> map);\n\n        @SqlUpdate(\"update something set name=:map.name where id=:id\")\n        void updatePrefix(@Bind int id, @BindMap(\"map\") Map<String, Object> map);\n\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void updateNameKey(@Bind int id, @BindMap(keys = \"name\") Map<String, Object> map);\n\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void updateConvertKeys(@Bind int id, @BindMap(convertKeys = true) Map<Object, Object> map);\n\n        @SqlQuery(\"select * from something where id=:id\")\n        @UseRowMapper(SomethingMapper.class)\n        Something get(long id);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.Map;\n\nimport com.google.common.collect.ImmutableMap;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.BindMap;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.jdbi.v3.testing.junit5.internal.TestingInitializers;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static java.util.Collections.emptyMap;\nimport static java.util.Collections.singletonMap;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestBindMap {\n\n    @RegisterExtension\n    public JdbiExtension h2Extension = JdbiExtension.h2().withInitializer(TestingInitializers.something()).withPlugin(new SqlObjectPlugin());\n\n    private Handle handle;\n\n    private Dao dao;\n\n    @BeforeEach\n    public void setUp() {\n        handle = h2Extension.getSharedHandle();\n\n        dao = handle.attach(Dao.class);\n    }\n\n    @Test\n    public void testBindMap() {\n        handle.execute(\"insert into something (id, name) values (1, 'Alice')\");\n\n        dao.update(1, singletonMap(\"name\", \"Alicia\"));\n\n        assertThat(dao.get(1).getName()).isEqualTo(\"Alicia\");\n    }\n\n    @Test\n    public void testBindMapPrefixed() {\n        handle.execute(\"insert into something (id, name) values (1, 'Alice')\");\n\n        dao.updatePrefix(1, singletonMap(\"name\", \"Alicia\"));\n\n        assertThat(dao.get(1).getName()).isEqualTo(\"Alicia\");\n    }\n\n    @Test\n    public void testBindMapKeyInKeysAndMap() {\n        handle.execute(\"insert into something (id, name) values (2, 'Bob')\");\n\n        dao.updateNameKey(2, singletonMap(\"name\", \"Rob\"));\n\n        assertThat(dao.get(2).getName()).isEqualTo(\"Rob\");\n    }\n\n    @Test\n    public void testBindMapKeyInKeysNotInMap() {\n        handle.execute(\"insert into something(id, name) values (2, 'Bob')\");\n\n        dao.updateNameKey(2, emptyMap());\n\n        assertThat(dao.get(2).getName()).isNull();\n    }\n\n    @Test\n    public void testBindMapKeyInMapNotInKeys() {\n        handle.execute(\"insert into something(id, name) values (3, 'Carol')\");\n\n        dao.updateNameKey(3, ImmutableMap.of(\"name\", \"Cheryl\", \"integerValue\", 3));\n\n        assertThat(dao.get(3).getName()).isEqualTo(\"Cheryl\");\n        assertThat(dao.get(3).getIntegerValue()).isNull();\n    }\n\n    @Test\n    public void testBindMapKeyNotInMapOrKeys() {\n        handle.execute(\"insert into something(id, name) values (3, 'Carol')\");\n        Map<Object, Object> m = emptyMap();\n        assertThatThrownBy(() -> dao.update(3, m)).isInstanceOf(UnableToCreateStatementException.class);\n    }\n\n    @Test\n    public void testBindMapConvertKeysStringKeys() {\n        handle.execute(\"insert into something(id, name) values (4, 'Dave')\");\n\n        dao.updateConvertKeys(4, singletonMap(\"name\", \"David\"));\n\n        assertThat(dao.get(4).getName()).isEqualTo(\"David\");\n    }\n\n    @Test\n    public void testBindMapConvertKeysNonStringKeys() {\n        handle.execute(\"insert into something(id, name) values (4, 'Dave')\");\n\n        dao.updateConvertKeys(4, singletonMap(new MapKey(\"name\"), \"David\"));\n\n        assertThat(dao.get(4).getName()).isEqualTo(\"David\");\n    }\n\n    @Test\n    public void testBindMapNonStringKeys() {\n        handle.execute(\"insert into something(id, name) values (5, 'Edward')\");\n        Map<Object, Object> m = singletonMap(new MapKey(\"name\"), \"Jacob\");\n\n        assertThatThrownBy(() -> dao.update(5, m)).isInstanceOf(IllegalArgumentException.class);\n    }\n\n    public static class MapKey {\n        private final String value;\n\n        MapKey(String value) {\n            this.value = value;\n        }\n\n        @Override\n        public String toString() {\n            return value;\n        }\n    }\n\n    public interface Dao {\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void update(@Bind int id, @BindMap Map<Object, Object> map);\n\n        @SqlUpdate(\"update something set name=:map.name where id=:id\")\n        void updatePrefix(@Bind int id, @BindMap(\"map\") Map<String, Object> map);\n\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void updateNameKey(@Bind int id, @BindMap(keys = \"name\") Map<String, Object> map);\n\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void updateConvertKeys(@Bind int id, @BindMap(convertKeys = true) Map<Object, Object> map);\n\n        @SqlQuery(\"select * from something where id=:id\")\n        @UseRowMapper(SomethingMapper.class)\n        Something get(long id);\n    }\n}\n","lineNo":105}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.Map;\n\nimport com.google.common.collect.ImmutableMap;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.BindMap;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.jdbi.v3.testing.junit5.internal.TestingInitializers;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static java.util.Collections.emptyMap;\nimport static java.util.Collections.singletonMap;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class TestBindMap {\n\n    @RegisterExtension\n    public JdbiExtension h2Extension = JdbiExtension.h2().withInitializer(TestingInitializers.something()).withPlugin(new SqlObjectPlugin());\n\n    private Handle handle;\n\n    private Dao dao;\n\n    @BeforeEach\n    public void setUp() {\n        handle = h2Extension.getSharedHandle();\n\n        dao = handle.attach(Dao.class);\n    }\n\n    @Test\n    public void testBindMap() {\n        handle.execute(\"insert into something (id, name) values (1, 'Alice')\");\n\n        dao.update(1, singletonMap(\"name\", \"Alicia\"));\n\n        assertThat(dao.get(1).getName()).isEqualTo(\"Alicia\");\n    }\n\n    @Test\n    public void testBindMapPrefixed() {\n        handle.execute(\"insert into something (id, name) values (1, 'Alice')\");\n\n        dao.updatePrefix(1, singletonMap(\"name\", \"Alicia\"));\n\n        assertThat(dao.get(1).getName()).isEqualTo(\"Alicia\");\n    }\n\n    @Test\n    public void testBindMapKeyInKeysAndMap() {\n        handle.execute(\"insert into something (id, name) values (2, 'Bob')\");\n\n        dao.updateNameKey(2, singletonMap(\"name\", \"Rob\"));\n\n        assertThat(dao.get(2).getName()).isEqualTo(\"Rob\");\n    }\n\n    @Test\n    public void testBindMapKeyInKeysNotInMap() {\n        handle.execute(\"insert into something(id, name) values (2, 'Bob')\");\n\n        dao.updateNameKey(2, emptyMap());\n\n        assertThat(dao.get(2).getName()).isNull();\n    }\n\n    @Test\n    public void testBindMapKeyInMapNotInKeys() {\n        handle.execute(\"insert into something(id, name) values (3, 'Carol')\");\n\n        dao.updateNameKey(3, ImmutableMap.of(\"name\", \"Cheryl\", \"integerValue\", 3));\n\n        assertThat(dao.get(3).getName()).isEqualTo(\"Cheryl\");\n        assertThat(dao.get(3).getIntegerValue()).isNull();\n    }\n\n    @Test\n    public void testBindMapKeyNotInMapOrKeys() {\n        handle.execute(\"insert into something(id, name) values (3, 'Carol')\");\n        assertThrows(UnableToCreateStatementException.class, () -> dao.update(3, emptyMap()));\n    }\n\n    @Test\n    public void testBindMapConvertKeysStringKeys() {\n        handle.execute(\"insert into something(id, name) values (4, 'Dave')\");\n\n        dao.updateConvertKeys(4, singletonMap(\"name\", \"David\"));\n\n        assertThat(dao.get(4).getName()).isEqualTo(\"David\");\n    }\n\n    @Test\n    public void testBindMapConvertKeysNonStringKeys() {\n        handle.execute(\"insert into something(id, name) values (4, 'Dave')\");\n\n        dao.updateConvertKeys(4, singletonMap(new MapKey(\"name\"), \"David\"));\n\n        assertThat(dao.get(4).getName()).isEqualTo(\"David\");\n    }\n\n    @Test\n    public void testBindMapNonStringKeys() {\n        handle.execute(\"insert into something(id, name) values (5, 'Edward')\");\n\n        assertThrows(IllegalArgumentException.class, () -> dao.update(5, singletonMap(new MapKey(\"name\"), \"Jacob\")));\n    }\n\n    public static class MapKey {\n        private final String value;\n\n        MapKey(String value) {\n            this.value = value;\n        }\n\n        @Override\n        public String toString() {\n            return value;\n        }\n    }\n\n    public interface Dao {\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void update(@Bind int id, @BindMap Map<Object, Object> map);\n\n        @SqlUpdate(\"update something set name=:map.name where id=:id\")\n        void updatePrefix(@Bind int id, @BindMap(\"map\") Map<String, Object> map);\n\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void updateNameKey(@Bind int id, @BindMap(keys = \"name\") Map<String, Object> map);\n\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void updateConvertKeys(@Bind int id, @BindMap(convertKeys = true) Map<Object, Object> map);\n\n        @SqlQuery(\"select * from something where id=:id\")\n        @UseRowMapper(SomethingMapper.class)\n        Something get(long id);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.Map;\n\nimport com.google.common.collect.ImmutableMap;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.BindMap;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.jdbi.v3.testing.junit5.internal.TestingInitializers;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static java.util.Collections.emptyMap;\nimport static java.util.Collections.singletonMap;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestBindMap {\n\n    @RegisterExtension\n    public JdbiExtension h2Extension = JdbiExtension.h2().withInitializer(TestingInitializers.something()).withPlugin(new SqlObjectPlugin());\n\n    private Handle handle;\n\n    private Dao dao;\n\n    @BeforeEach\n    public void setUp() {\n        handle = h2Extension.getSharedHandle();\n\n        dao = handle.attach(Dao.class);\n    }\n\n    @Test\n    public void testBindMap() {\n        handle.execute(\"insert into something (id, name) values (1, 'Alice')\");\n\n        dao.update(1, singletonMap(\"name\", \"Alicia\"));\n\n        assertThat(dao.get(1).getName()).isEqualTo(\"Alicia\");\n    }\n\n    @Test\n    public void testBindMapPrefixed() {\n        handle.execute(\"insert into something (id, name) values (1, 'Alice')\");\n\n        dao.updatePrefix(1, singletonMap(\"name\", \"Alicia\"));\n\n        assertThat(dao.get(1).getName()).isEqualTo(\"Alicia\");\n    }\n\n    @Test\n    public void testBindMapKeyInKeysAndMap() {\n        handle.execute(\"insert into something (id, name) values (2, 'Bob')\");\n\n        dao.updateNameKey(2, singletonMap(\"name\", \"Rob\"));\n\n        assertThat(dao.get(2).getName()).isEqualTo(\"Rob\");\n    }\n\n    @Test\n    public void testBindMapKeyInKeysNotInMap() {\n        handle.execute(\"insert into something(id, name) values (2, 'Bob')\");\n\n        dao.updateNameKey(2, emptyMap());\n\n        assertThat(dao.get(2).getName()).isNull();\n    }\n\n    @Test\n    public void testBindMapKeyInMapNotInKeys() {\n        handle.execute(\"insert into something(id, name) values (3, 'Carol')\");\n\n        dao.updateNameKey(3, ImmutableMap.of(\"name\", \"Cheryl\", \"integerValue\", 3));\n\n        assertThat(dao.get(3).getName()).isEqualTo(\"Cheryl\");\n        assertThat(dao.get(3).getIntegerValue()).isNull();\n    }\n\n    @Test\n    public void testBindMapKeyNotInMapOrKeys() {\n        handle.execute(\"insert into something(id, name) values (3, 'Carol')\");\n        Map<Object, Object> m = emptyMap();\n        assertThatThrownBy(() -> dao.update(3, m)).isInstanceOf(UnableToCreateStatementException.class);\n    }\n\n    @Test\n    public void testBindMapConvertKeysStringKeys() {\n        handle.execute(\"insert into something(id, name) values (4, 'Dave')\");\n\n        dao.updateConvertKeys(4, singletonMap(\"name\", \"David\"));\n\n        assertThat(dao.get(4).getName()).isEqualTo(\"David\");\n    }\n\n    @Test\n    public void testBindMapConvertKeysNonStringKeys() {\n        handle.execute(\"insert into something(id, name) values (4, 'Dave')\");\n\n        dao.updateConvertKeys(4, singletonMap(new MapKey(\"name\"), \"David\"));\n\n        assertThat(dao.get(4).getName()).isEqualTo(\"David\");\n    }\n\n    @Test\n    public void testBindMapNonStringKeys() {\n        handle.execute(\"insert into something(id, name) values (5, 'Edward')\");\n        Map<Object, Object> m = singletonMap(new MapKey(\"name\"), \"Jacob\");\n\n        assertThatThrownBy(() -> dao.update(5, m)).isInstanceOf(IllegalArgumentException.class);\n    }\n\n    public static class MapKey {\n        private final String value;\n\n        MapKey(String value) {\n            this.value = value;\n        }\n\n        @Override\n        public String toString() {\n            return value;\n        }\n    }\n\n    public interface Dao {\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void update(@Bind int id, @BindMap Map<Object, Object> map);\n\n        @SqlUpdate(\"update something set name=:map.name where id=:id\")\n        void updatePrefix(@Bind int id, @BindMap(\"map\") Map<String, Object> map);\n\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void updateNameKey(@Bind int id, @BindMap(keys = \"name\") Map<String, Object> map);\n\n        @SqlUpdate(\"update something set name=:name where id=:id\")\n        void updateConvertKeys(@Bind int id, @BindMap(convertKeys = true) Map<Object, Object> map);\n\n        @SqlQuery(\"select * from something where id=:id\")\n        @UseRowMapper(SomethingMapper.class)\n        Something get(long id);\n    }\n}\n","lineNo":130}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.List;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.statement.SqlBatch;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.sqlobject.transaction.Transaction;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.jdbi.v3.testing.junit5.internal.TestingInitializers;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class TestCreateSqlObjectAnnotation {\n\n    @RegisterExtension\n    public JdbiExtension h2Extension = JdbiExtension.h2().withInitializer(TestingInitializers.something()).withPlugin(new SqlObjectPlugin());\n\n    private Handle handle;\n\n    @BeforeEach\n    public void setUp() {\n        h2Extension.getJdbi().registerRowMapper(new SomethingMapper());\n        handle = h2Extension.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n    }\n\n    @Test\n    public void testSimpleCreate() {\n        Foo foo = handle.attach(Foo.class);\n        foo.insert(1, \"Stephane\");\n        Something s = foo.createBar().findById(1);\n        assertThat(s).isEqualTo(new Something(1, \"Stephane\"));\n    }\n\n    @Test\n    public void testInsertAndFind() {\n        Foo foo = handle.attach(Foo.class);\n        Something s = foo.insertAndFind(1, \"Stephane\");\n        assertThat(s).isEqualTo(new Something(1, \"Stephane\"));\n    }\n\n    @Test\n    public void testTransactionPropagates() {\n        Foo foo = h2Extension.getJdbi().open().attach(Foo.class);\n\n        assertThatExceptionOfType(Exception.class).isThrownBy(() -> foo.insertAndFail(1, \"Jeff\"));\n\n        Something n = foo.createBar().findById(1);\n        assertThat(n).isNull();\n    }\n\n    @Test\n    public void subObjectIsSqlObject() throws Exception {\n        assertThat(h2Extension.getJdbi().withExtension(Foo.class, Foo::createBar)).isInstanceOf(SqlObject.class);\n    }\n\n    public interface Foo {\n        @CreateSqlObject\n        Bar createBar();\n\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        int insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n\n        @Transaction\n        default Something insertAndFind(int id, String name) {\n            insert(id, name);\n            return createBar().findById(id);\n        }\n\n        @Transaction\n        default Something insertAndFail(int id, String name) {\n            insert(id, name);\n            return createBar().explode();\n        }\n    }\n\n    public interface Bar {\n        @SqlQuery(\"select id, name from something where id = :id\")\n        Something findById(@Bind(\"id\") int id);\n\n        default Something explode() {\n            throw new RuntimeException();\n        }\n\n    }\n\n    @Test\n    public void testMeaningfulExceptionWhenWrongReturnTypeOfSqlUpdate() {\n        UnableToCreateSqlObjectException e = assertThrows(UnableToCreateSqlObjectException.class,\n            () -> h2Extension.getJdbi().open().attach(BogusSqlUpdateDao.class));\n        assertEquals(\"BogusSqlUpdateDao.getNames method is annotated with @SqlUpdate \"\n            + \"so should return void, boolean, or Number but is returning: java.util.List<java.lang.String>\", e.getMessage());\n    }\n\n    public interface BogusSqlUpdateDao {\n        @SqlUpdate(\"select name from something\")\n        List<String> getNames();\n    }\n\n    @Test\n    public void testMeaningfulExceptionWhenWrongReturnTypeOfSqlBatch() {\n        UnableToCreateSqlObjectException e = assertThrows(UnableToCreateSqlObjectException.class,\n            () -> h2Extension.getJdbi().open().attach(BogusSqlBatchDao.class));\n        assertThat(e.getMessage()).contains(\"BogusSqlBatchDao.getNames method is annotated with @SqlBatch \"\n            + \"so should return void, int[], or boolean[] but is returning: int\");\n\n    }\n\n    public interface BogusSqlBatchDao {\n        @SqlBatch(\"insert into table (a) values (:a)\")\n        int getNames(@Bind(\"a\") String a);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.List;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.statement.SqlBatch;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.sqlobject.transaction.Transaction;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.jdbi.v3.testing.junit5.internal.TestingInitializers;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestCreateSqlObjectAnnotation {\n\n    @RegisterExtension\n    public JdbiExtension h2Extension = JdbiExtension.h2().withInitializer(TestingInitializers.something()).withPlugin(new SqlObjectPlugin());\n\n    private Handle handle;\n\n    @BeforeEach\n    public void setUp() {\n        h2Extension.getJdbi().registerRowMapper(new SomethingMapper());\n        handle = h2Extension.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n    }\n\n    @Test\n    public void testSimpleCreate() {\n        Foo foo = handle.attach(Foo.class);\n        foo.insert(1, \"Stephane\");\n        Something s = foo.createBar().findById(1);\n        assertThat(s).isEqualTo(new Something(1, \"Stephane\"));\n    }\n\n    @Test\n    public void testInsertAndFind() {\n        Foo foo = handle.attach(Foo.class);\n        Something s = foo.insertAndFind(1, \"Stephane\");\n        assertThat(s).isEqualTo(new Something(1, \"Stephane\"));\n    }\n\n    @Test\n    public void testTransactionPropagates() {\n        Foo foo = h2Extension.getJdbi().open().attach(Foo.class);\n\n        assertThatExceptionOfType(Exception.class).isThrownBy(() -> foo.insertAndFail(1, \"Jeff\"));\n\n        Something n = foo.createBar().findById(1);\n        assertThat(n).isNull();\n    }\n\n    @Test\n    public void subObjectIsSqlObject() throws Exception {\n        assertThat(h2Extension.getJdbi().withExtension(Foo.class, Foo::createBar)).isInstanceOf(SqlObject.class);\n    }\n\n    public interface Foo {\n        @CreateSqlObject\n        Bar createBar();\n\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        int insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n\n        @Transaction\n        default Something insertAndFind(int id, String name) {\n            insert(id, name);\n            return createBar().findById(id);\n        }\n\n        @Transaction\n        default Something insertAndFail(int id, String name) {\n            insert(id, name);\n            return createBar().explode();\n        }\n    }\n\n    public interface Bar {\n        @SqlQuery(\"select id, name from something where id = :id\")\n        Something findById(@Bind(\"id\") int id);\n\n        default Something explode() {\n            throw new RuntimeException();\n        }\n\n    }\n\n    @Test\n    public void testMeaningfulExceptionWhenWrongReturnTypeOfSqlUpdate() {\n        Handle h = h2Extension.getJdbi().open();\n        assertThatThrownBy(() -> h.attach(BogusSqlUpdateDao.class))\n                .isInstanceOf(UnableToCreateSqlObjectException.class)\n                .hasMessage(\"BogusSqlUpdateDao.getNames method is annotated with @SqlUpdate \"\n                          + \"so should return void, boolean, or Number but is returning: java.util.List<java.lang.String>\");\n    }\n\n    public interface BogusSqlUpdateDao {\n        @SqlUpdate(\"select name from something\")\n        List<String> getNames();\n    }\n\n    @Test\n    public void testMeaningfulExceptionWhenWrongReturnTypeOfSqlBatch() {\n        Handle h = h2Extension.getJdbi().open();\n        assertThatThrownBy(() -> h.attach(BogusSqlBatchDao.class))\n                .isInstanceOf(UnableToCreateSqlObjectException.class)\n                .hasMessageContaining(\"BogusSqlBatchDao.getNames method is annotated with @SqlBatch \"\n                                    + \"so should return void, int[], or boolean[] but is returning: int\");\n    }\n\n    public interface BogusSqlBatchDao {\n        @SqlBatch(\"insert into table (a) values (:a)\")\n        int getNames(@Bind(\"a\") String a);\n    }\n}\n","lineNo":112}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.List;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.statement.SqlBatch;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.sqlobject.transaction.Transaction;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.jdbi.v3.testing.junit5.internal.TestingInitializers;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class TestCreateSqlObjectAnnotation {\n\n    @RegisterExtension\n    public JdbiExtension h2Extension = JdbiExtension.h2().withInitializer(TestingInitializers.something()).withPlugin(new SqlObjectPlugin());\n\n    private Handle handle;\n\n    @BeforeEach\n    public void setUp() {\n        h2Extension.getJdbi().registerRowMapper(new SomethingMapper());\n        handle = h2Extension.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n    }\n\n    @Test\n    public void testSimpleCreate() {\n        Foo foo = handle.attach(Foo.class);\n        foo.insert(1, \"Stephane\");\n        Something s = foo.createBar().findById(1);\n        assertThat(s).isEqualTo(new Something(1, \"Stephane\"));\n    }\n\n    @Test\n    public void testInsertAndFind() {\n        Foo foo = handle.attach(Foo.class);\n        Something s = foo.insertAndFind(1, \"Stephane\");\n        assertThat(s).isEqualTo(new Something(1, \"Stephane\"));\n    }\n\n    @Test\n    public void testTransactionPropagates() {\n        Foo foo = h2Extension.getJdbi().open().attach(Foo.class);\n\n        assertThatExceptionOfType(Exception.class).isThrownBy(() -> foo.insertAndFail(1, \"Jeff\"));\n\n        Something n = foo.createBar().findById(1);\n        assertThat(n).isNull();\n    }\n\n    @Test\n    public void subObjectIsSqlObject() throws Exception {\n        assertThat(h2Extension.getJdbi().withExtension(Foo.class, Foo::createBar)).isInstanceOf(SqlObject.class);\n    }\n\n    public interface Foo {\n        @CreateSqlObject\n        Bar createBar();\n\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        int insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n\n        @Transaction\n        default Something insertAndFind(int id, String name) {\n            insert(id, name);\n            return createBar().findById(id);\n        }\n\n        @Transaction\n        default Something insertAndFail(int id, String name) {\n            insert(id, name);\n            return createBar().explode();\n        }\n    }\n\n    public interface Bar {\n        @SqlQuery(\"select id, name from something where id = :id\")\n        Something findById(@Bind(\"id\") int id);\n\n        default Something explode() {\n            throw new RuntimeException();\n        }\n\n    }\n\n    @Test\n    public void testMeaningfulExceptionWhenWrongReturnTypeOfSqlUpdate() {\n        UnableToCreateSqlObjectException e = assertThrows(UnableToCreateSqlObjectException.class,\n            () -> h2Extension.getJdbi().open().attach(BogusSqlUpdateDao.class));\n        assertEquals(\"BogusSqlUpdateDao.getNames method is annotated with @SqlUpdate \"\n            + \"so should return void, boolean, or Number but is returning: java.util.List<java.lang.String>\", e.getMessage());\n    }\n\n    public interface BogusSqlUpdateDao {\n        @SqlUpdate(\"select name from something\")\n        List<String> getNames();\n    }\n\n    @Test\n    public void testMeaningfulExceptionWhenWrongReturnTypeOfSqlBatch() {\n        UnableToCreateSqlObjectException e = assertThrows(UnableToCreateSqlObjectException.class,\n            () -> h2Extension.getJdbi().open().attach(BogusSqlBatchDao.class));\n        assertThat(e.getMessage()).contains(\"BogusSqlBatchDao.getNames method is annotated with @SqlBatch \"\n            + \"so should return void, int[], or boolean[] but is returning: int\");\n\n    }\n\n    public interface BogusSqlBatchDao {\n        @SqlBatch(\"insert into table (a) values (:a)\")\n        int getNames(@Bind(\"a\") String a);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.List;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.statement.SqlBatch;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.sqlobject.transaction.Transaction;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.jdbi.v3.testing.junit5.internal.TestingInitializers;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestCreateSqlObjectAnnotation {\n\n    @RegisterExtension\n    public JdbiExtension h2Extension = JdbiExtension.h2().withInitializer(TestingInitializers.something()).withPlugin(new SqlObjectPlugin());\n\n    private Handle handle;\n\n    @BeforeEach\n    public void setUp() {\n        h2Extension.getJdbi().registerRowMapper(new SomethingMapper());\n        handle = h2Extension.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n    }\n\n    @Test\n    public void testSimpleCreate() {\n        Foo foo = handle.attach(Foo.class);\n        foo.insert(1, \"Stephane\");\n        Something s = foo.createBar().findById(1);\n        assertThat(s).isEqualTo(new Something(1, \"Stephane\"));\n    }\n\n    @Test\n    public void testInsertAndFind() {\n        Foo foo = handle.attach(Foo.class);\n        Something s = foo.insertAndFind(1, \"Stephane\");\n        assertThat(s).isEqualTo(new Something(1, \"Stephane\"));\n    }\n\n    @Test\n    public void testTransactionPropagates() {\n        Foo foo = h2Extension.getJdbi().open().attach(Foo.class);\n\n        assertThatExceptionOfType(Exception.class).isThrownBy(() -> foo.insertAndFail(1, \"Jeff\"));\n\n        Something n = foo.createBar().findById(1);\n        assertThat(n).isNull();\n    }\n\n    @Test\n    public void subObjectIsSqlObject() throws Exception {\n        assertThat(h2Extension.getJdbi().withExtension(Foo.class, Foo::createBar)).isInstanceOf(SqlObject.class);\n    }\n\n    public interface Foo {\n        @CreateSqlObject\n        Bar createBar();\n\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        int insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n\n        @Transaction\n        default Something insertAndFind(int id, String name) {\n            insert(id, name);\n            return createBar().findById(id);\n        }\n\n        @Transaction\n        default Something insertAndFail(int id, String name) {\n            insert(id, name);\n            return createBar().explode();\n        }\n    }\n\n    public interface Bar {\n        @SqlQuery(\"select id, name from something where id = :id\")\n        Something findById(@Bind(\"id\") int id);\n\n        default Something explode() {\n            throw new RuntimeException();\n        }\n\n    }\n\n    @Test\n    public void testMeaningfulExceptionWhenWrongReturnTypeOfSqlUpdate() {\n        Handle h = h2Extension.getJdbi().open();\n        assertThatThrownBy(() -> h.attach(BogusSqlUpdateDao.class))\n                .isInstanceOf(UnableToCreateSqlObjectException.class)\n                .hasMessage(\"BogusSqlUpdateDao.getNames method is annotated with @SqlUpdate \"\n                          + \"so should return void, boolean, or Number but is returning: java.util.List<java.lang.String>\");\n    }\n\n    public interface BogusSqlUpdateDao {\n        @SqlUpdate(\"select name from something\")\n        List<String> getNames();\n    }\n\n    @Test\n    public void testMeaningfulExceptionWhenWrongReturnTypeOfSqlBatch() {\n        Handle h = h2Extension.getJdbi().open();\n        assertThatThrownBy(() -> h.attach(BogusSqlBatchDao.class))\n                .isInstanceOf(UnableToCreateSqlObjectException.class)\n                .hasMessageContaining(\"BogusSqlBatchDao.getNames method is annotated with @SqlBatch \"\n                                    + \"so should return void, int[], or boolean[] but is returning: int\");\n    }\n\n    public interface BogusSqlBatchDao {\n        @SqlBatch(\"insert into table (a) values (:a)\")\n        int getNames(@Bind(\"a\") String a);\n    }\n}\n","lineNo":126}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.sqlobject.transaction.Transactional;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.jdbi.v3.testing.junit5.internal.TestingInitializers;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestVariousOddities {\n\n    @RegisterExtension\n    public JdbiExtension h2Extension = JdbiExtension.h2().withInitializer(TestingInitializers.something()).withPlugin(new SqlObjectPlugin());\n\n    @Test\n    public void testAttach() {\n        Spiffy s = h2Extension.getSharedHandle().attach(Spiffy.class);\n        s.insert(new Something(14, \"Tom\"));\n\n        Something tom = s.byId(14);\n        assertThat(tom.getName()).isEqualTo(\"Tom\");\n    }\n\n    @Test\n    public void testEquals() {\n        Spiffy s1 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        Spiffy s2 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        assertThat(s1).isEqualTo(s1);\n        assertThat(s1).isNotSameAs(s2);\n        assertThat(s1).isNotEqualTo(s2);\n    }\n\n    @Test\n    public void testToString() {\n        Spiffy s1 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        Spiffy s2 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        assertThat(s1.toString()).isNotNull();\n        assertThat(s2.toString()).isNotNull();\n        assertThat(s1.toString()).isNotEqualTo(s2.toString());\n    }\n\n    @Test\n    public void testHashCode() {\n        Spiffy s1 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        Spiffy s2 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        assertThat(s1.hashCode()).isNotZero();\n        assertThat(s2.hashCode()).isNotZero();\n        assertThat(s1.hashCode()).isNotEqualTo(s2.hashCode());\n    }\n\n    @Test\n    public void testConcurrentHashCode() throws ExecutionException, InterruptedException {\n        Callable<SpiffyConcurrent> callable = () ->\n            h2Extension.getSharedHandle().attach(SpiffyConcurrent.class);\n\n        ExecutorService pool = Executors.newFixedThreadPool(2);\n        Future<SpiffyConcurrent> f1 = pool.submit(callable);\n        Future<SpiffyConcurrent> f2 = pool.submit(callable);\n        pool.shutdown();\n        SpiffyConcurrent s1 = f1.get();\n        SpiffyConcurrent s2 = f2.get();\n\n        assertThat(s1.hashCode()).isNotZero();\n        assertThat(s2.hashCode()).isNotZero();\n        assertThat(s1.hashCode()).isNotEqualTo(s2.hashCode());\n    }\n\n    @Test\n    public void testNullQueryReturn() {\n\n        IllegalStateException e = Assertions.assertThrows(IllegalStateException.class, () -> h2Extension.getSharedHandle().attach(SpiffyBoom.class));\n\n        assertThat(e.getMessage()).contains(\"returnNothing is annotated as if it should return a value, but the method is void.\");\n    }\n\n    public interface Spiffy {\n        @SqlQuery(\"select id, name from something where id = :id\")\n        @UseRowMapper(SomethingMapper.class)\n        Something byId(@Bind(\"id\") long id);\n\n        @SqlUpdate(\"insert into something (id, name) values (:it.id, :it.name)\")\n        void insert(@BindSomething(\"it\") Something it);\n\n    }\n\n    public interface SpiffyBoom {\n        @SqlQuery(\"SELECT 1\")\n        void returnNothing();\n    }\n\n    /**\n     * This interface should not be loaded by any test other than {@link TestVariousOddities#testConcurrentHashCode()}.\n     */\n    public interface SpiffyConcurrent extends SqlObject {}\n\n    @Test\n    public void testInterfaceAmbiguousMethods() {\n        assertThatThrownBy(() ->\n            h2Extension.getSharedHandle().attach(AmbiguousMethods.class))\n            .isInstanceOf(UnableToCreateSqlObjectException.class)\n            .hasMessageContaining(\"AmbiguousMethods has ambiguous methods\");\n    }\n\n    @Test\n    public void testAmbiguityResolved() {\n        ResolvedMethods methods = h2Extension.getSharedHandle().attach(ResolvedMethods.class);\n        assertThat(methods.value()).isEqualTo(\"resolved\");\n    }\n\n    public interface VersionA {\n        @SqlQuery(\"select 'intriguing'\")\n        String value();\n    }\n    public interface VersionB {\n        @SqlQuery(\"select 'indubitably'\")\n        String value();\n    }\n\n    public interface AmbiguousMethods extends VersionA, VersionB {}\n    public interface ResolvedMethods extends AmbiguousMethods {\n        @SqlQuery(\"select 'resolved'\")\n        @Override\n        String value();\n    }\n\n    public interface OnDemandOddities extends SqlObject, Transactional<OnDemandOddities> {\n        @CreateSqlObject\n        VersionA versionA();\n    }\n\n    public class DecoratedOnDemandOddities implements OnDemandOddities {\n\n        private OnDemandOddities onDemand = h2Extension.getJdbi().onDemand(OnDemandOddities.class);\n\n        @Override\n        public Handle getHandle() {\n            return onDemand.getHandle();\n        }\n\n        @Override\n        public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {\n            return onDemand.withHandle(callback);\n        }\n\n        @Override\n        public VersionA versionA() {\n            return onDemand.versionA();\n        }\n    }\n\n    @Test\n    public void onDemandCreateSqlObject() throws Exception {\n        assertThat(h2Extension.getJdbi().onDemand(OnDemandOddities.class).versionA().value())\n                .isEqualTo(\"intriguing\");\n    }\n\n    @Test\n    public void decoratedOnDemandWithHandleInTransaction() throws Exception {\n        OnDemandOddities onDemand = new DecoratedOnDemandOddities();\n        onDemand.withHandle(h ->\n            h.inTransaction(txn ->\n                assertThat(onDemand.versionA().value()).isEqualTo(\"intriguing\")));\n    }\n\n    @Test\n    public void decoratedOnDemandInTransaction() throws Exception {\n        OnDemandOddities onDemand = new DecoratedOnDemandOddities();\n        onDemand.inTransaction(txn ->\n                assertThat(onDemand.versionA().value()).isEqualTo(\"intriguing\"));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.sqlobject.transaction.Transactional;\nimport org.jdbi.v3.testing.junit5.JdbiExtension;\nimport org.jdbi.v3.testing.junit5.internal.TestingInitializers;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestVariousOddities {\n\n    @RegisterExtension\n    public JdbiExtension h2Extension = JdbiExtension.h2().withInitializer(TestingInitializers.something()).withPlugin(new SqlObjectPlugin());\n\n    @Test\n    public void testAttach() {\n        Spiffy s = h2Extension.getSharedHandle().attach(Spiffy.class);\n        s.insert(new Something(14, \"Tom\"));\n\n        Something tom = s.byId(14);\n        assertThat(tom.getName()).isEqualTo(\"Tom\");\n    }\n\n    @Test\n    public void testEquals() {\n        Spiffy s1 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        Spiffy s2 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        assertThat(s1).isEqualTo(s1);\n        assertThat(s1).isNotSameAs(s2);\n        assertThat(s1).isNotEqualTo(s2);\n    }\n\n    @Test\n    public void testToString() {\n        Spiffy s1 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        Spiffy s2 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        assertThat(s1.toString()).isNotNull();\n        assertThat(s2.toString()).isNotNull();\n        assertThat(s1.toString()).isNotEqualTo(s2.toString());\n    }\n\n    @Test\n    public void testHashCode() {\n        Spiffy s1 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        Spiffy s2 = h2Extension.getSharedHandle().attach(Spiffy.class);\n        assertThat(s1.hashCode()).isNotZero();\n        assertThat(s2.hashCode()).isNotZero();\n        assertThat(s1.hashCode()).isNotEqualTo(s2.hashCode());\n    }\n\n    @Test\n    public void testConcurrentHashCode() throws ExecutionException, InterruptedException {\n        Callable<SpiffyConcurrent> callable = () ->\n            h2Extension.getSharedHandle().attach(SpiffyConcurrent.class);\n\n        ExecutorService pool = Executors.newFixedThreadPool(2);\n        Future<SpiffyConcurrent> f1 = pool.submit(callable);\n        Future<SpiffyConcurrent> f2 = pool.submit(callable);\n        pool.shutdown();\n        SpiffyConcurrent s1 = f1.get();\n        SpiffyConcurrent s2 = f2.get();\n\n        assertThat(s1.hashCode()).isNotZero();\n        assertThat(s2.hashCode()).isNotZero();\n        assertThat(s1.hashCode()).isNotEqualTo(s2.hashCode());\n    }\n\n    @Test\n    public void testNullQueryReturn() {\n        Handle h = h2Extension.getSharedHandle();\n        assertThatThrownBy(() -> h.attach(SpiffyBoom.class))\n                .isInstanceOf(IllegalStateException.class)\n                .hasMessageContaining(\"returnNothing is annotated as if it should return a value, but the method is void.\");\n    }\n\n    public interface Spiffy {\n        @SqlQuery(\"select id, name from something where id = :id\")\n        @UseRowMapper(SomethingMapper.class)\n        Something byId(@Bind(\"id\") long id);\n\n        @SqlUpdate(\"insert into something (id, name) values (:it.id, :it.name)\")\n        void insert(@BindSomething(\"it\") Something it);\n\n    }\n\n    public interface SpiffyBoom {\n        @SqlQuery(\"SELECT 1\")\n        void returnNothing();\n    }\n\n    /**\n     * This interface should not be loaded by any test other than {@link TestVariousOddities#testConcurrentHashCode()}.\n     */\n    public interface SpiffyConcurrent extends SqlObject {}\n\n    @Test\n    public void testInterfaceAmbiguousMethods() {\n        assertThatThrownBy(() ->\n            h2Extension.getSharedHandle().attach(AmbiguousMethods.class))\n            .isInstanceOf(UnableToCreateSqlObjectException.class)\n            .hasMessageContaining(\"AmbiguousMethods has ambiguous methods\");\n    }\n\n    @Test\n    public void testAmbiguityResolved() {\n        ResolvedMethods methods = h2Extension.getSharedHandle().attach(ResolvedMethods.class);\n        assertThat(methods.value()).isEqualTo(\"resolved\");\n    }\n\n    public interface VersionA {\n        @SqlQuery(\"select 'intriguing'\")\n        String value();\n    }\n    public interface VersionB {\n        @SqlQuery(\"select 'indubitably'\")\n        String value();\n    }\n\n    public interface AmbiguousMethods extends VersionA, VersionB {}\n    public interface ResolvedMethods extends AmbiguousMethods {\n        @SqlQuery(\"select 'resolved'\")\n        @Override\n        String value();\n    }\n\n    public interface OnDemandOddities extends SqlObject, Transactional<OnDemandOddities> {\n        @CreateSqlObject\n        VersionA versionA();\n    }\n\n    public class DecoratedOnDemandOddities implements OnDemandOddities {\n\n        private OnDemandOddities onDemand = h2Extension.getJdbi().onDemand(OnDemandOddities.class);\n\n        @Override\n        public Handle getHandle() {\n            return onDemand.getHandle();\n        }\n\n        @Override\n        public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {\n            return onDemand.withHandle(callback);\n        }\n\n        @Override\n        public VersionA versionA() {\n            return onDemand.versionA();\n        }\n    }\n\n    @Test\n    public void onDemandCreateSqlObject() throws Exception {\n        assertThat(h2Extension.getJdbi().onDemand(OnDemandOddities.class).versionA().value())\n                .isEqualTo(\"intriguing\");\n    }\n\n    @Test\n    public void decoratedOnDemandWithHandleInTransaction() throws Exception {\n        OnDemandOddities onDemand = new DecoratedOnDemandOddities();\n        onDemand.withHandle(h ->\n            h.inTransaction(txn ->\n                assertThat(onDemand.versionA().value()).isEqualTo(\"intriguing\")));\n    }\n\n    @Test\n    public void decoratedOnDemandInTransaction() throws Exception {\n        OnDemandOddities onDemand = new DecoratedOnDemandOddities();\n        onDemand.inTransaction(txn ->\n                assertThat(onDemand.versionA().value()).isEqualTo(\"intriguing\"));\n    }\n}\n","lineNo":99}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.lang.reflect.Type;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.internal.NamedArgumentFinderFactory;\nimport org.jdbi.v3.core.argument.internal.NamedArgumentFinderFactory.PrepareKey;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.result.ResultProducer;\nimport org.jdbi.v3.core.result.ResultProducers;\nimport org.jdbi.v3.core.result.ResultSetScanner;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.jdbi.v3.core.statement.internal.PreparedBinding;\n\nimport static org.jdbi.v3.core.result.ResultProducers.returningGeneratedKeys;\n\n/**\n * Represents a prepared batch statement.  Multiple bindings are added to the\n * compiled statement and then executed in a single operation. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n *\n * The statement starts with an empty binding.  You bind a single batch of parameters\n * with the usual {@link SqlStatement} binding methods, and then call\n * {@link PreparedBatch#add()} to add the current binding as a batch and then clear it.\n *\n * An entire batch can be bound and added in one go with {@link PreparedBatch#add(Map)}\n * or {@link PreparedBatch#add(Object...)}.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch> implements ResultBearing {\n    private final List<PreparedBinding> bindings = new ArrayList<>();\n    final Map<PrepareKey, Function<String, Optional<Function<Object, Argument>>>> preparedFinders = new HashMap<>();\n\n    public PreparedBatch(Handle handle, String sql) {\n        super(handle, sql);\n        getContext().setBinding(new PreparedBinding(getContext()));\n    }\n\n    @Override\n    PreparedBatch bindNamedArgumentFinder(NamedArgumentFinderFactory factory, String prefix, Object value, Type type, Supplier<NamedArgumentFinder> backupArgumentFinder) {\n        PreparedBinding binding = getBinding();\n        PrepareKey key = factory.keyFor(prefix, value);\n        preparedFinders.computeIfAbsent(key,\n                pk -> factory.prepareFor(getConfig(), this::buildArgument, prefix, value, type));\n        binding.prepareKeys.put(key, value);\n        binding.backupArgumentFinders.add(backupArgumentFinder);\n        return this;\n    }\n\n    @Override\n    protected PreparedBinding getBinding() {\n        return (PreparedBinding) super.getBinding();\n    }\n\n    Function<Object, Argument> buildArgument(QualifiedType<?> type) {\n        return getContext().getConfig(Arguments.class)\n                .prepareFor(type)\n                .orElse(value ->\n                    (pos, st, ctx) ->\n                        ctx.getConfig(Arguments.class)\n                            .findFor(type, value)\n                            .orElseThrow(() -> new UnableToCreateStatementException(\"no argument factory for type \" + type, ctx))\n                            .apply(pos, st, ctx));\n    }\n\n    @Override\n    public <R> R scanResultSet(ResultSetScanner<R> mapper) {\n        return execute(ResultProducers.returningResults()).scanResultSet(mapper);\n    }\n\n    /**\n     * Execute the batch and return the number of rows affected for each batch part.\n     * Note that some database drivers might return special values like {@link Statement#SUCCESS_NO_INFO}\n     * or {@link Statement#EXECUTE_FAILED}.\n     *\n     * @return the number of rows affected per batch part\n     * @see Statement#executeBatch()\n     */\n    public int[] execute() {\n        try {\n            return internalBatchExecute().updateCounts;\n        } finally {\n            getContext().close();\n        }\n    }\n\n    /**\n     * Execute the batch and return the mod counts as in {@code execute}, but as a\n     * Jdbi result iterator instead of an array.\n     * @return the number of rows affected per batch part\n     * @see #execute()\n     * @see Statement#executeBatch()\n     */\n    public ResultIterator<Integer> executeAndGetModCount() {\n        StatementContext ctx = getContext();\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return ctx;\n            }\n\n            @Override\n            public void close() {\n                ctx.close();\n            }\n        };\n    }\n\n    public ResultBearing executeAndReturnGeneratedKeys(String... columnNames) {\n        return execute(returningGeneratedKeys(columnNames));\n    }\n\n    /**\n     * Executes the batch, returning the result obtained from the given {@link ResultProducer}.\n     *\n     * @param <R> the type of the result\n     * @param producer the result producer.\n     * @return value returned by the result producer.\n     */\n    public <R> R execute(ResultProducer<R> producer) {\n        try {\n            return producer.produce(() -> internalBatchExecute().stmt, getContext());\n        } catch (SQLException e) {\n            try {\n                close();\n            } catch (Exception e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToProduceResultException(\"Exception producing batch result\", e, getContext());\n        }\n    }\n\n    private ExecutedBatch internalBatchExecute() {\n        if (!getBinding().isEmpty()) {\n            add();\n        }\n\n        beforeTemplating();\n\n        final StatementContext ctx = getContext();\n\n        ParsedSql parsedSql = parseSql();\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n\n        try {\n            try {\n                StatementBuilder statementBuilder = getHandle().getStatementBuilder();\n                @SuppressWarnings(\"PMD.CloseResource\")\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, ctx);\n\n                addCleanable(() -> statementBuilder.close(connection, sql, stmt));\n                getConfig(SqlStatements.class).customize(stmt);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, ctx);\n            }\n\n            if (bindings.isEmpty()) {\n                return new ExecutedBatch(stmt, new int[0]);\n            }\n\n            beforeBinding();\n\n            try {\n                ArgumentBinder binder = new ArgumentBinder.Prepared(this, parsedParameters, bindings.get(0));\n                for (Binding binding : bindings) {\n                    ctx.setBinding(binding);\n                    binder.bind(binding);\n                    stmt.addBatch();\n                }\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, ctx);\n            }\n\n            beforeExecution();\n\n            try {\n                final int[] rs = SqlLoggerUtil.wrap(stmt::executeBatch, ctx, getConfig(SqlStatements.class).getSqlLogger());\n\n                afterExecution();\n\n                ctx.setBinding(new PreparedBinding(ctx));\n\n                return new ExecutedBatch(stmt, rs);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), ctx);\n            }\n        } finally {\n            bindings.clear();\n        }\n    }\n\n    /**\n     * Add the current binding as a saved batch and clear the binding.\n     * @return this\n     */\n    public PreparedBatch add() {\n        final PreparedBinding currentBinding = getBinding();\n        if (currentBinding.isEmpty()) {\n            throw new IllegalStateException(\"Attempt to add() an empty batch, you probably didn't mean to do this \"\n                    + \"- call add() *after* setting batch parameters\");\n        }\n        bindings.add(currentBinding);\n        getContext().setBinding(new PreparedBinding(getContext()));\n        return this;\n    }\n\n    /**\n     * Bind arguments positionally, add the binding as a saved batch, and\n     * then clear the current binding.\n     * @param args the positional arguments to bind\n     * @return this\n     */\n    public PreparedBatch add(Object... args) {\n        for (int i = 0; i < args.length; i++) {\n            bind(i, args[i]);\n        }\n        add();\n        return this;\n    }\n\n    /**\n     * Bind arguments from a Map, add the binding as a saved batch,\n     * then clear the current binding.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     * @return this\n     */\n    public PreparedBatch add(Map<String, ?> args) {\n        bindMap(args);\n        add();\n        return this;\n    }\n\n    /**\n     * Returns the number of bindings in this batch.\n     *\n     * @return the number of bindings in this batch.\n     */\n    public int size() {\n        return bindings.size();\n    }\n\n    private static class ExecutedBatch {\n        final PreparedStatement stmt;\n        final int[] updateCounts;\n\n        ExecutedBatch(PreparedStatement stmt, int[] updateCounts) {\n            this.stmt = stmt;\n            this.updateCounts = Arrays.copyOf(updateCounts, updateCounts.length);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.lang.reflect.Type;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.internal.NamedArgumentFinderFactory;\nimport org.jdbi.v3.core.argument.internal.NamedArgumentFinderFactory.PrepareKey;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.result.BatchResultBearing;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.result.ResultProducer;\nimport org.jdbi.v3.core.result.ResultProducers;\nimport org.jdbi.v3.core.result.ResultSetScanner;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.jdbi.v3.core.statement.internal.PreparedBinding;\n\nimport static org.jdbi.v3.core.result.ResultProducers.returningGeneratedKeys;\n\n/**\n * Represents a prepared batch statement.  Multiple bindings are added to the\n * compiled statement and then executed in a single operation. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n *\n * The statement starts with an empty binding.  You bind a single batch of parameters\n * with the usual {@link SqlStatement} binding methods, and then call\n * {@link PreparedBatch#add()} to add the current binding as a batch and then clear it.\n *\n * An entire batch can be bound and added in one go with {@link PreparedBatch#add(Map)}\n * or {@link PreparedBatch#add(Object...)}.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch> implements ResultBearing {\n    private final List<PreparedBinding> bindings = new ArrayList<>();\n    final Map<PrepareKey, Function<String, Optional<Function<Object, Argument>>>> preparedFinders = new HashMap<>();\n\n    public PreparedBatch(Handle handle, String sql) {\n        super(handle, sql);\n        getContext().setBinding(new PreparedBinding(getContext()));\n    }\n\n    @Override\n    PreparedBatch bindNamedArgumentFinder(NamedArgumentFinderFactory factory, String prefix, Object value, Type type, Supplier<NamedArgumentFinder> backupArgumentFinder) {\n        PreparedBinding binding = getBinding();\n        PrepareKey key = factory.keyFor(prefix, value);\n        preparedFinders.computeIfAbsent(key,\n                pk -> factory.prepareFor(getConfig(), this::buildArgument, prefix, value, type));\n        binding.prepareKeys.put(key, value);\n        binding.backupArgumentFinders.add(backupArgumentFinder);\n        return this;\n    }\n\n    @Override\n    protected PreparedBinding getBinding() {\n        return (PreparedBinding) super.getBinding();\n    }\n\n    Function<Object, Argument> buildArgument(QualifiedType<?> type) {\n        return getContext().getConfig(Arguments.class)\n                .prepareFor(type)\n                .orElse(value ->\n                    (pos, st, ctx) ->\n                        ctx.getConfig(Arguments.class)\n                            .findFor(type, value)\n                            .orElseThrow(() -> new UnableToCreateStatementException(\"no argument factory for type \" + type, ctx))\n                            .apply(pos, st, ctx));\n    }\n\n    @Override\n    public <R> R scanResultSet(ResultSetScanner<R> mapper) {\n        return execute(ResultProducers.returningResults()).scanResultSet(mapper);\n    }\n\n    /**\n     * Execute the batch and return the number of rows affected for each batch part.\n     * Note that some database drivers might return special values like {@link Statement#SUCCESS_NO_INFO}\n     * or {@link Statement#EXECUTE_FAILED}.\n     *\n     * @return the number of rows affected per batch part\n     * @see Statement#executeBatch()\n     */\n    public int[] execute() {\n        try {\n            return internalBatchExecute().updateCounts;\n        } finally {\n            getContext().close();\n        }\n    }\n\n    /**\n     * Execute the batch and return the mod counts as in {@code execute}, but as a\n     * Jdbi result iterator instead of an array.\n     * @return the number of rows affected per batch part\n     * @see #execute()\n     * @see Statement#executeBatch()\n     */\n    public ResultIterator<Integer> executeAndGetModCount() {\n        StatementContext ctx = getContext();\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return ctx;\n            }\n\n            @Override\n            public void close() {\n                ctx.close();\n            }\n        };\n    }\n\n    /**\n     * Execute the batch and give access to any generated keys returned by the operation.\n     *\n     * @param columnNames The column names for generated keys.\n     * @return A {@link ResultBearing} object that can be used to access the results of the batch.\n     * @deprecated Use {@link #executePreparedBatch(String...)} which has the same functionality but also returns the per-batch modified row counts.\n     */\n    @Deprecated\n    public ResultBearing executeAndReturnGeneratedKeys(String... columnNames) {\n        return execute(returningGeneratedKeys(columnNames));\n    }\n\n    /**\n     * Execute the batch and give access to any generated keys returned by the operation.\n     *\n     * @param columnNames The column names for generated keys.\n     * @return A {@link BatchResultBearing} object that can be used to access the results of the batch and the per-batch modified row counts.\n     */\n    public BatchResultBearing executePreparedBatch(String... columnNames) {\n        final ExecutedBatchConsumer executedBatchConsumer = new ExecutedBatchConsumer();\n        final ResultBearing resultBearing = execute(returningGeneratedKeys(columnNames), executedBatchConsumer);\n        return new BatchResultBearing(resultBearing, executedBatchConsumer);\n    }\n\n    /**\n     * Executes the batch, returning the result obtained from the given {@link ResultProducer}.\n     *\n     * @param <R> the type of the result\n     * @param producer the result producer.\n     * @return value returned by the result producer.\n     */\n    public <R> R execute(ResultProducer<R> producer) {\n        return execute(producer, x -> {});\n    }\n\n    private <R> R execute(ResultProducer<R> producer, Consumer<ExecutedBatch> batchConsumer) {\n        try {\n            return producer.produce(() -> {\n                ExecutedBatch batch = internalBatchExecute();\n                batchConsumer.accept(batch);\n                return batch.stmt;\n            }, getContext());\n        } catch (SQLException e) {\n            try {\n                close();\n            } catch (Exception e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToProduceResultException(\"Exception producing batch result\", e, getContext());\n        }\n    }\n\n    private ExecutedBatch internalBatchExecute() {\n        if (!getBinding().isEmpty()) {\n            add();\n        }\n\n        beforeTemplating();\n\n        final StatementContext ctx = getContext();\n\n        ParsedSql parsedSql = parseSql();\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n\n        try {\n            try {\n                StatementBuilder statementBuilder = getHandle().getStatementBuilder();\n                @SuppressWarnings(\"PMD.CloseResource\")\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, ctx);\n\n                addCleanable(() -> statementBuilder.close(connection, sql, stmt));\n                getConfig(SqlStatements.class).customize(stmt);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, ctx);\n            }\n\n            if (bindings.isEmpty()) {\n                return new ExecutedBatch(stmt, new int[0]);\n            }\n\n            beforeBinding();\n\n            try {\n                ArgumentBinder binder = new ArgumentBinder.Prepared(this, parsedParameters, bindings.get(0));\n                for (Binding binding : bindings) {\n                    ctx.setBinding(binding);\n                    binder.bind(binding);\n                    stmt.addBatch();\n                }\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, ctx);\n            }\n\n            beforeExecution();\n\n            try {\n                final int[] modifiedRows = SqlLoggerUtil.wrap(stmt::executeBatch, ctx, getConfig(SqlStatements.class).getSqlLogger());\n\n                afterExecution();\n\n                ctx.setBinding(new PreparedBinding(ctx));\n\n                return new ExecutedBatch(stmt, modifiedRows);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), ctx);\n            }\n        } finally {\n            bindings.clear();\n        }\n    }\n\n    /**\n     * Add the current binding as a saved batch and clear the binding.\n     * @return this\n     */\n    public PreparedBatch add() {\n        final PreparedBinding currentBinding = getBinding();\n        if (currentBinding.isEmpty()) {\n            throw new IllegalStateException(\"Attempt to add() an empty batch, you probably didn't mean to do this \"\n                    + \"- call add() *after* setting batch parameters\");\n        }\n        bindings.add(currentBinding);\n        getContext().setBinding(new PreparedBinding(getContext()));\n        return this;\n    }\n\n    /**\n     * Bind arguments positionally, add the binding as a saved batch, and\n     * then clear the current binding.\n     * @param args the positional arguments to bind\n     * @return this\n     */\n    public PreparedBatch add(Object... args) {\n        for (int i = 0; i < args.length; i++) {\n            bind(i, args[i]);\n        }\n        add();\n        return this;\n    }\n\n    /**\n     * Bind arguments from a Map, add the binding as a saved batch,\n     * then clear the current binding.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     * @return this\n     */\n    public PreparedBatch add(Map<String, ?> args) {\n        bindMap(args);\n        add();\n        return this;\n    }\n\n    /**\n     * Returns the number of bindings in this batch.\n     *\n     * @return the number of bindings in this batch.\n     */\n    public int size() {\n        return bindings.size();\n    }\n\n    private static class ExecutedBatch {\n        final PreparedStatement stmt;\n        final int[] updateCounts;\n\n        ExecutedBatch(PreparedStatement stmt, int[] updateCounts) {\n            this.stmt = stmt;\n            this.updateCounts = Arrays.copyOf(updateCounts, updateCounts.length);\n        }\n    }\n\n    private static final class ExecutedBatchConsumer implements Consumer<ExecutedBatch>, Supplier<int[]> {\n\n        private int[] modifiedRowCounts = new int[0];\n\n        @Override\n        public void accept(ExecutedBatch executedBatch) {\n            // has been copied within the executed batch\n            this.modifiedRowCounts = executedBatch.updateCounts;\n        }\n\n        @Override\n        @SuppressWarnings(\"PMD.MethodReturnsInternalArray\")\n        public int[] get() {\n            // Array was copied as when the ExecutedBatch was created, so exposing it is fine.\n            return modifiedRowCounts;\n        }\n    }\n}\n","lineNo":195}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.function.Function;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.internal.IterableLike;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.SingleValue;\nimport org.jdbi.v3.sqlobject.UnableToCreateSqlObjectException;\nimport org.jdbi.v3.sqlobject.statement.BatchChunkSize;\nimport org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;\nimport org.jdbi.v3.sqlobject.statement.SqlBatch;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.sqlobject.statement.UseRowReducer;\n\npublic class SqlBatchHandler extends CustomizingStatementHandler<PreparedBatch> {\n    private final SqlBatch sqlBatch;\n    private final SqlBatchHandler.ChunkSizeFunction batchChunkSize;\n    private final Function<PreparedBatch, ResultIterator<?>> batchIntermediate;\n    private final ResultReturner magic;\n\n    public SqlBatchHandler(Class<?> sqlObjectType, Method method) {\n        super(sqlObjectType, method);\n\n        if (method.isAnnotationPresent(UseRowReducer.class)) {\n            throw new UnsupportedOperationException(\"Cannot declare @UseRowReducer on a @SqlUpdate method.\");\n        }\n\n        this.sqlBatch = method.getAnnotation(SqlBatch.class);\n        this.batchChunkSize = determineBatchChunkSize(sqlObjectType, method);\n        final GetGeneratedKeys getGeneratedKeys = method.getAnnotation(GetGeneratedKeys.class);\n\n        if (getGeneratedKeys == null) {\n            if (!returnTypeIsValid(method.getReturnType())) {\n                throw new UnableToCreateSqlObjectException(invalidReturnTypeMessage(method));\n            }\n            Function<PreparedBatch, ResultIterator<?>> modCounts = PreparedBatch::executeAndGetModCount;\n            batchIntermediate = method.getReturnType().equals(boolean[].class)\n                    ? mapToBoolean(modCounts)\n                    : modCounts;\n            magic = ResultReturner.forOptionalReturn(sqlObjectType, method);\n        } else {\n            String[] columnNames = getGeneratedKeys.value();\n            magic = ResultReturner.forMethod(sqlObjectType, method);\n\n            if (method.isAnnotationPresent(UseRowMapper.class)) {\n                RowMapper<?> mapper = rowMapperFor(method.getAnnotation(UseRowMapper.class));\n                batchIntermediate = batch -> batch.executeAndReturnGeneratedKeys(columnNames)\n                        .map(mapper)\n                        .iterator();\n            } else {\n                batchIntermediate = batch -> batch.executeAndReturnGeneratedKeys(columnNames)\n                        .mapTo(magic.elementType(batch.getConfig()))\n                        .iterator();\n            }\n        }\n    }\n\n    @Override\n    public void warm(ConfigRegistry config) {\n        super.warm(config);\n        magic.warm(config);\n    }\n\n    private Function<PreparedBatch, ResultIterator<?>> mapToBoolean(Function<PreparedBatch, ResultIterator<?>> modCounts) {\n        return modCounts.andThen(iterator -> new ResultIterator<Boolean>() {\n            @Override\n            public boolean hasNext() {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public Boolean next() {\n                return ((Integer) iterator.next()) > 0;\n            }\n\n            @Override\n            public void close() {\n                iterator.close();\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return iterator.getContext();\n            }\n        });\n    }\n\n    private SqlBatchHandler.ChunkSizeFunction determineBatchChunkSize(Class<?> sqlObjectType, Method method) {\n        // this next big if chain determines the batch chunk size. It looks from most specific\n        // scope to least, that is: as an argument, then on the method, then on the class,\n        // then default to Integer.MAX_VALUE\n\n        int batchChunkSizeParameterIndex = indexOfBatchChunkSizeParameter(method);\n        if (batchChunkSizeParameterIndex >= 0) {\n            return new ParamBasedChunkSizeFunction(batchChunkSizeParameterIndex);\n        } else if (method.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = method.getAnnotation(BatchChunkSize.class).value();\n            if (size <= 0) {\n                throw new IllegalArgumentException(\"Batch chunk size must be >= 0\");\n            }\n            return new ConstantChunkSizeFunction(size);\n        } else if (sqlObjectType.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = sqlObjectType.getAnnotation(BatchChunkSize.class).value();\n            return new ConstantChunkSizeFunction(size);\n        } else {\n            return new ConstantChunkSizeFunction(Integer.MAX_VALUE);\n        }\n    }\n\n    private int indexOfBatchChunkSizeParameter(Method method) {\n        Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n        return IntStream.range(0, parameterAnnotations.length)\n                .filter(i -> Stream.of(parameterAnnotations[i]).anyMatch(BatchChunkSize.class::isInstance))\n                .findFirst()\n                .orElse(-1);\n    }\n\n    @Override\n    PreparedBatch createStatement(Handle handle, String locatedSql) {\n        return handle.prepareBatch(locatedSql);\n    }\n\n    @Override\n    void configureReturner(PreparedBatch stmt, SqlObjectStatementConfiguration cfg) {}\n\n    @Override\n    Type getParameterType(Parameter parameter) {\n        Type type = super.getParameterType(parameter);\n\n        if (!parameter.isAnnotationPresent(SingleValue.class)) {\n            Class<?> erasedType = GenericTypes.getErasedType(type);\n            if (Iterable.class.isAssignableFrom(erasedType)) {\n                return GenericTypes.findGenericParameter(type, Iterable.class).get();\n            } else if (Iterator.class.isAssignableFrom(erasedType)) {\n                return GenericTypes.findGenericParameter(type, Iterator.class).get();\n            } else if (GenericTypes.isArray(type)) {\n                return ((Class<?>) type).getComponentType();\n            }\n        }\n\n        return type;\n    }\n\n    @Override\n    @SuppressWarnings(\"PMD.ExcessiveMethodLength\")\n    public Object invoke(Object target, Object[] args, HandleSupplier h) {\n        final Handle handle = h.getHandle();\n        final String sql = locateSql(handle);\n        final int chunkSize = batchChunkSize.call(args);\n        final Iterator<Object[]> batchArgs = zipArgs(getMethod(), args);\n\n        final class BatchChunkIterator implements ResultIterator<Object> {\n            private ResultIterator<?> batchResult = null;\n            private boolean closed = false;\n\n            BatchChunkIterator() {\n                if (batchArgs.hasNext()) {\n                    // if arguments are present, preload the next result chunk\n                    batchResult = loadChunk();\n                }\n            }\n\n            private ResultIterator<?> loadChunk() {\n                // execute a single chunk and buffer\n                PreparedBatch batch = handle.prepareBatch(sql);\n                for (int i = 0; i < chunkSize && batchArgs.hasNext(); i++) {\n                    applyCustomizers(batch, batchArgs.next());\n                    batch.add();\n                }\n                return executeBatch(handle, batch);\n            }\n\n            @Override\n            public boolean hasNext() {\n                if (closed) {\n                    throw new IllegalStateException(\"closed\");\n                }\n                // first, any elements already buffered?\n                if (batchResult != null) {\n                    if (batchResult.hasNext()) {\n                        return true;\n                    }\n                    // no more in this chunk, release resources\n                    batchResult.close();\n                }\n                // more chunks?\n                if (batchArgs.hasNext()) {\n                    // preload the next result chunk\n                    batchResult = loadChunk();\n\n                    // recurse to ensure we actually got elements\n                    return hasNext();\n                }\n\n                return false;\n            }\n\n            @Override\n            public Object next() {\n                if (closed) {\n                    throw new IllegalStateException(\"closed\");\n                }\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return batchResult.next();\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return batchResult.getContext();\n            }\n\n            @Override\n            public void close() {\n                closed = true;\n                batchResult.close();\n            }\n        }\n\n        ResultIterator<Object> result;\n\n        if (batchArgs.hasNext()) {\n            result = new BatchChunkIterator();\n        } else {\n            // only created to get access to the context.\n            PreparedBatch dummy = handle.prepareBatch(sql);\n            result = new ResultIterator<Object>() {\n                @Override\n                public void close() {\n                    // no op\n                }\n\n                @Override\n                public StatementContext getContext() {\n                    return dummy.getContext();\n                }\n\n                @Override\n                public boolean hasNext() {\n                    return false;\n                }\n\n                @Override\n                public Object next() {\n                    throw new NoSuchElementException();\n                }\n            };\n        }\n\n        ResultIterable<Object> iterable = ResultIterable.of(result);\n\n        return magic.mappedResult(iterable, result.getContext());\n    }\n\n    private Iterator<Object[]> zipArgs(Method method, Object[] args) {\n        boolean foundIterator = false;\n        List<Iterator<?>> extras = new ArrayList<>();\n        for (int paramIdx = 0; paramIdx < method.getParameterCount(); paramIdx++) {\n            final boolean singleValue = method.getParameters()[paramIdx].isAnnotationPresent(SingleValue.class);\n            final Object arg = args[paramIdx];\n            if (!singleValue && IterableLike.isIterable(arg)) {\n                extras.add(IterableLike.of(arg));\n                foundIterator = true;\n            } else {\n                extras.add(Stream.generate(() -> arg).iterator());\n            }\n        }\n\n        if (!foundIterator) {\n            throw new UnableToCreateStatementException(\"@SqlBatch method has no Iterable or array parameters,\"\n                    + \" did you mean @SqlQuery?\", null, null);\n        }\n\n        final Object[] sharedArg = new Object[args.length];\n        return new Iterator<Object[]>() {\n            @Override\n            public boolean hasNext() {\n                for (Iterator<?> extra : extras) {\n                    if (!extra.hasNext()) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            @Override\n            public Object[] next() {\n                for (int i = 0; i < extras.size(); i++) {\n                    sharedArg[i] = extras.get(i).next();\n                }\n                return sharedArg;\n            }\n        };\n    }\n\n    private ResultIterator<?> executeBatch(final Handle handle, final PreparedBatch batch) {\n        if (!handle.isInTransaction() && sqlBatch.transactional()) {\n            // it is safe to use same prepared batch as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction(c -> batchIntermediate.apply(batch));\n        } else {\n            return batchIntermediate.apply(batch);\n        }\n    }\n\n    private static boolean returnTypeIsValid(Class<?> type) {\n        if (type.equals(Void.TYPE)) {\n            return true;\n        }\n\n        if (type.isArray()) {\n            Class<?> componentType = type.getComponentType();\n            return componentType.equals(Integer.TYPE) || componentType.equals(Boolean.TYPE);\n        }\n\n        return false;\n    }\n\n    private static String invalidReturnTypeMessage(Method method) {\n        return method.getDeclaringClass() + \".\" + method.getName()\n                + \" method is annotated with @SqlBatch so should return void, int[], or boolean[] but is returning: \"\n                + method.getReturnType();\n    }\n\n    private interface ChunkSizeFunction {\n        int call(Object[] args);\n    }\n\n    private static class ConstantChunkSizeFunction implements SqlBatchHandler.ChunkSizeFunction {\n        private final int value;\n\n        ConstantChunkSizeFunction(int value) {\n            this.value = value;\n        }\n\n        @Override\n        public int call(Object[] args) {\n            return value;\n        }\n    }\n\n    private static class ParamBasedChunkSizeFunction implements SqlBatchHandler.ChunkSizeFunction {\n        private final int index;\n\n        ParamBasedChunkSizeFunction(int index) {\n            this.index = index;\n        }\n\n        @Override\n        public int call(Object[] args) {\n            return (Integer) args[index];\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.internal.IterableLike;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.SingleValue;\nimport org.jdbi.v3.sqlobject.UnableToCreateSqlObjectException;\nimport org.jdbi.v3.sqlobject.statement.BatchChunkSize;\nimport org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;\nimport org.jdbi.v3.sqlobject.statement.SqlBatch;\nimport org.jdbi.v3.sqlobject.statement.UseRowMapper;\nimport org.jdbi.v3.sqlobject.statement.UseRowReducer;\n\npublic class SqlBatchHandler extends CustomizingStatementHandler<PreparedBatch> {\n    private final SqlBatch sqlBatch;\n    private final SqlBatchHandler.ChunkSizeFunction batchChunkSize;\n    private final Function<PreparedBatch, ResultIterator<?>> batchIntermediate;\n    private final ResultReturner magic;\n\n    public SqlBatchHandler(Class<?> sqlObjectType, Method method) {\n        super(sqlObjectType, method);\n\n        if (method.isAnnotationPresent(UseRowReducer.class)) {\n            throw new UnsupportedOperationException(\"Cannot declare @UseRowReducer on a @SqlUpdate method.\");\n        }\n\n        this.sqlBatch = method.getAnnotation(SqlBatch.class);\n        this.batchChunkSize = determineBatchChunkSize(sqlObjectType, method);\n        final GetGeneratedKeys getGeneratedKeys = method.getAnnotation(GetGeneratedKeys.class);\n\n        if (getGeneratedKeys == null) {\n            if (!returnTypeIsValid(method.getReturnType())) {\n                throw new UnableToCreateSqlObjectException(invalidReturnTypeMessage(method));\n            }\n            Function<PreparedBatch, ResultIterator<?>> modCounts = PreparedBatch::executeAndGetModCount;\n            batchIntermediate = method.getReturnType().equals(boolean[].class)\n                    ? mapToBoolean(modCounts)\n                    : modCounts;\n            magic = ResultReturner.forOptionalReturn(sqlObjectType, method);\n        } else {\n            String[] columnNames = getGeneratedKeys.value();\n            magic = ResultReturner.forMethod(sqlObjectType, method);\n\n            if (method.isAnnotationPresent(UseRowMapper.class)) {\n                RowMapper<?> mapper = rowMapperFor(method.getAnnotation(UseRowMapper.class));\n                batchIntermediate = batch -> batch.executeAndReturnGeneratedKeys(columnNames)\n                        .map(mapper)\n                        .iterator();\n            } else {\n                batchIntermediate = batch -> batch.executeAndReturnGeneratedKeys(columnNames)\n                        .mapTo(magic.elementType(batch.getConfig()))\n                        .iterator();\n            }\n        }\n    }\n\n    @Override\n    public void warm(ConfigRegistry config) {\n        super.warm(config);\n        magic.warm(config);\n    }\n\n    private Function<PreparedBatch, ResultIterator<?>> mapToBoolean(Function<PreparedBatch, ResultIterator<?>> modCounts) {\n        return modCounts.andThen(iterator -> new ResultIterator<Boolean>() {\n            @Override\n            public boolean hasNext() {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public Boolean next() {\n                return ((Integer) iterator.next()) > 0;\n            }\n\n            @Override\n            public void close() {\n                iterator.close();\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return iterator.getContext();\n            }\n        });\n    }\n\n    private SqlBatchHandler.ChunkSizeFunction determineBatchChunkSize(Class<?> sqlObjectType, Method method) {\n        // this next big if chain determines the batch chunk size. It looks from most specific\n        // scope to least, that is: as an argument, then on the method, then on the class,\n        // then default to Integer.MAX_VALUE\n\n        int batchChunkSizeParameterIndex = indexOfBatchChunkSizeParameter(method);\n        if (batchChunkSizeParameterIndex >= 0) {\n            return new ParamBasedChunkSizeFunction(batchChunkSizeParameterIndex);\n        } else if (method.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = method.getAnnotation(BatchChunkSize.class).value();\n            if (size <= 0) {\n                throw new IllegalArgumentException(\"Batch chunk size must be >= 0\");\n            }\n            return new ConstantChunkSizeFunction(size);\n        } else if (sqlObjectType.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = sqlObjectType.getAnnotation(BatchChunkSize.class).value();\n            return new ConstantChunkSizeFunction(size);\n        } else {\n            return new ConstantChunkSizeFunction(Integer.MAX_VALUE);\n        }\n    }\n\n    private int indexOfBatchChunkSizeParameter(Method method) {\n        Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n        return IntStream.range(0, parameterAnnotations.length)\n                .filter(i -> Stream.of(parameterAnnotations[i]).anyMatch(BatchChunkSize.class::isInstance))\n                .findFirst()\n                .orElse(-1);\n    }\n\n    @Override\n    PreparedBatch createStatement(Handle handle, String locatedSql) {\n        return handle.prepareBatch(locatedSql);\n    }\n\n    @Override\n    void configureReturner(PreparedBatch stmt, SqlObjectStatementConfiguration cfg) {}\n\n    @Override\n    Type getParameterType(Parameter parameter) {\n        Type type = super.getParameterType(parameter);\n\n        if (!parameter.isAnnotationPresent(SingleValue.class)) {\n            Class<?> erasedType = GenericTypes.getErasedType(type);\n            if (Iterable.class.isAssignableFrom(erasedType)) {\n                return GenericTypes.findGenericParameter(type, Iterable.class).get();\n            } else if (Iterator.class.isAssignableFrom(erasedType)) {\n                return GenericTypes.findGenericParameter(type, Iterator.class).get();\n            } else if (GenericTypes.isArray(type)) {\n                return ((Class<?>) type).getComponentType();\n            }\n        }\n\n        return type;\n    }\n\n    @Override\n    @SuppressWarnings(\"PMD.ExcessiveMethodLength\")\n    public Object invoke(Object target, Object[] args, HandleSupplier h) {\n        final Handle handle = h.getHandle();\n        final String sql = locateSql(handle);\n        final int chunkSize = batchChunkSize.call(args);\n        final Iterator<Object[]> batchArgs = zipArgs(getMethod(), args);\n\n        final class BatchChunkIterator implements ResultIterator<Object> {\n            private ResultIterator<?> batchResult = null;\n            private boolean closed = false;\n\n            BatchChunkIterator() {\n                if (batchArgs.hasNext()) {\n                    // if arguments are present, preload the next result chunk\n                    batchResult = loadChunk();\n                }\n            }\n\n            private ResultIterator<?> loadChunk() {\n                // execute a single chunk and buffer\n                List<Object[]> currArgs = new ArrayList<>();\n                for (int i = 0; i < chunkSize && batchArgs.hasNext(); i++) {\n                    Object[] batchArg = batchArgs.next();\n                    currArgs.add(Arrays.copyOf(batchArg, batchArg.length));\n                }\n                Supplier<PreparedBatch> preparedBatchSupplier = () -> createPreparedBatch(handle, sql, currArgs);\n                return executeBatch(handle, preparedBatchSupplier);\n            }\n\n            private PreparedBatch createPreparedBatch(Handle handle, String sql, List<Object[]> currArgs) {\n                PreparedBatch batch = handle.prepareBatch(sql);\n                for (Object[] currArg : currArgs) {\n                    applyCustomizers(batch, currArg);\n                    batch.add();\n                }\n                return batch;\n            }\n\n            @Override\n            public boolean hasNext() {\n                if (closed) {\n                    throw new IllegalStateException(\"closed\");\n                }\n                // first, any elements already buffered?\n                if (batchResult != null) {\n                    if (batchResult.hasNext()) {\n                        return true;\n                    }\n                    // no more in this chunk, release resources\n                    batchResult.close();\n                }\n                // more chunks?\n                if (batchArgs.hasNext()) {\n                    // preload the next result chunk\n                    batchResult = loadChunk();\n\n                    // recurse to ensure we actually got elements\n                    return hasNext();\n                }\n\n                return false;\n            }\n\n            @Override\n            public Object next() {\n                if (closed) {\n                    throw new IllegalStateException(\"closed\");\n                }\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return batchResult.next();\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return batchResult.getContext();\n            }\n\n            @Override\n            public void close() {\n                closed = true;\n                batchResult.close();\n            }\n        }\n\n        ResultIterator<Object> result;\n\n        if (batchArgs.hasNext()) {\n            result = new BatchChunkIterator();\n        } else {\n            // only created to get access to the context.\n            PreparedBatch dummy = handle.prepareBatch(sql);\n            result = new ResultIterator<Object>() {\n                @Override\n                public void close() {\n                    // no op\n                }\n\n                @Override\n                public StatementContext getContext() {\n                    return dummy.getContext();\n                }\n\n                @Override\n                public boolean hasNext() {\n                    return false;\n                }\n\n                @Override\n                public Object next() {\n                    throw new NoSuchElementException();\n                }\n            };\n        }\n\n        ResultIterable<Object> iterable = ResultIterable.of(result);\n\n        return magic.mappedResult(iterable, result.getContext());\n    }\n\n    private Iterator<Object[]> zipArgs(Method method, Object[] args) {\n        boolean foundIterator = false;\n        List<Iterator<?>> extras = new ArrayList<>();\n        for (int paramIdx = 0; paramIdx < method.getParameterCount(); paramIdx++) {\n            final boolean singleValue = method.getParameters()[paramIdx].isAnnotationPresent(SingleValue.class);\n            final Object arg = args[paramIdx];\n            if (!singleValue && IterableLike.isIterable(arg)) {\n                extras.add(IterableLike.of(arg));\n                foundIterator = true;\n            } else {\n                extras.add(Stream.generate(() -> arg).iterator());\n            }\n        }\n\n        if (!foundIterator) {\n            throw new UnableToCreateStatementException(\"@SqlBatch method has no Iterable or array parameters,\"\n                    + \" did you mean @SqlQuery?\", null, null);\n        }\n\n        final Object[] sharedArg = new Object[args.length];\n        return new Iterator<Object[]>() {\n            @Override\n            public boolean hasNext() {\n                for (Iterator<?> extra : extras) {\n                    if (!extra.hasNext()) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            @Override\n            public Object[] next() {\n                for (int i = 0; i < extras.size(); i++) {\n                    sharedArg[i] = extras.get(i).next();\n                }\n                return sharedArg;\n            }\n        };\n    }\n\n    private ResultIterator<?> executeBatch(final Handle handle, final Supplier<PreparedBatch> preparedBatchSupplier) {\n        if (!handle.isInTransaction() && sqlBatch.transactional()) {\n            // it is safe to use same prepared preparedBatchSupplier as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction(c -> batchIntermediate.apply(preparedBatchSupplier.get()));\n        } else {\n            return batchIntermediate.apply(preparedBatchSupplier.get());\n        }\n    }\n\n    private static boolean returnTypeIsValid(Class<?> type) {\n        if (type.equals(Void.TYPE)) {\n            return true;\n        }\n\n        if (type.isArray()) {\n            Class<?> componentType = type.getComponentType();\n            return componentType.equals(Integer.TYPE) || componentType.equals(Boolean.TYPE);\n        }\n\n        return false;\n    }\n\n    private static String invalidReturnTypeMessage(Method method) {\n        return method.getDeclaringClass() + \".\" + method.getName()\n                + \" method is annotated with @SqlBatch so should return void, int[], or boolean[] but is returning: \"\n                + method.getReturnType();\n    }\n\n    private interface ChunkSizeFunction {\n        int call(Object[] args);\n    }\n\n    private static class ConstantChunkSizeFunction implements SqlBatchHandler.ChunkSizeFunction {\n        private final int value;\n\n        ConstantChunkSizeFunction(int value) {\n            this.value = value;\n        }\n\n        @Override\n        public int call(Object[] args) {\n            return value;\n        }\n    }\n\n    private static class ParamBasedChunkSizeFunction implements SqlBatchHandler.ChunkSizeFunction {\n        private final int index;\n\n        ParamBasedChunkSizeFunction(int index) {\n            this.index = index;\n        }\n\n        @Override\n        public int call(Object[] args) {\n            return (Integer) args[index];\n        }\n    }\n}\n","lineNo":197}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.net.URI;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.UUID;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.argument.ObjectFieldArguments;\nimport org.jdbi.v3.core.argument.ObjectMethodArguments;\nimport org.jdbi.v3.core.argument.internal.NamedArgumentFinderFactory;\nimport org.jdbi.v3.core.argument.internal.PojoPropertyArguments;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.internal.IterableLike;\nimport org.jdbi.v3.core.mapper.Mappers;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.immutables.JdbiImmutables;\nimport org.jdbi.v3.core.qualifier.NVarchar;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.meta.Beta;\n\nimport static java.util.stream.Collectors.joining;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.arrayType;\nimport static org.jdbi.v3.core.generic.GenericTypes.parameterizeClass;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\n@SuppressWarnings({\"deprecation\", \"PMD.ExcessiveClassLength\"})\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private final Handle handle;\n    private final String sql;\n    PreparedStatement stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding() {\n        return getContext().getBinding();\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql() {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds) {\n        return addCustomizer(StatementCustomizers.statementTimeout(seconds));\n    }\n\n    /**\n     * Transfer ownership of the handle to the statement: when the statement is closed,\n     * commit the handle's transaction (if one exists) and close the handle.\n     * @return this\n     */\n    public This cleanupHandleCommit() {\n        return cleanupHandle(Handle::commit);\n    }\n\n    /**\n     * When the statement is closed, roll it back then close the owning Handle.\n     * @return this\n     */\n    public This cleanupHandleRollback() {\n        return cleanupHandle(Handle::rollback);\n    }\n\n    private This cleanupHandle(Consumer<Handle> action) {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    action.accept(handle);\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument) {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument) {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean) {\n        return bindBean(null, bean);\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"deprecation\")\n    public This bindBean(String prefix, Object bean) {\n        return bindNamedArgumentFinder(\n                NamedArgumentFinderFactory.BEAN,\n                prefix,\n                bean,\n                bean.getClass(),\n                () -> new BeanPropertyArguments(prefix, bean, getConfig()));\n    }\n\n    /**\n     * Binds named parameters from object properties on the argument.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param pojo source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(Object pojo) {\n        return bindPojo(null, pojo);\n    }\n\n    /**\n     * Binds named parameters from object properties on the bean argument, with the given prefix.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param pojo source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(String prefix, Object pojo) {\n        return bindPojo(prefix, pojo, pojo.getClass());\n    }\n\n    /**\n     * Binds named parameters from object properties on the argument.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param pojo source of named parameter values to use as arguments\n     * @param type the static, possibly generic type of the pojo\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(Object pojo, Type type) {\n        return bindPojo(null, pojo, type);\n    }\n\n    /**\n     * Binds named parameters from object properties on the bean argument, with the given prefix.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param pojo source of named parameter values to use as arguments\n     * @param type the static, possibly generic type of the pojo\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(String prefix, Object pojo, Type type) {\n        return bindNamedArgumentFinder(\n                NamedArgumentFinderFactory.POJO,\n                prefix,\n                pojo,\n                type,\n                () -> new PojoPropertyArguments(prefix, pojo, type, getConfig()));\n    }\n\n    /**\n     * Binds named parameters from object properties on the argument.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param pojo source of named parameter values to use as arguments\n     * @param type the static generic type of the pojo\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(Object pojo, GenericType<?> type) {\n        return bindPojo(null, pojo, type.getType());\n    }\n\n    /**\n     * Binds named parameters from object properties on the bean argument, with the given prefix.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param pojo source of named parameter values to use as arguments\n     * @param type the static generic type of the pojo\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(String prefix, Object pojo, GenericType<?> type) {\n        return bindPojo(prefix, pojo, type.getType());\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(Object object) {\n        return bindFields(null, object);\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param prefix a prefix to apply to all field names.\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(String prefix, Object object) {\n        return bindNamedArgumentFinder(\n                NamedArgumentFinderFactory.FIELDS,\n                prefix,\n                object,\n                object.getClass(),\n                () -> new ObjectFieldArguments(prefix, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument.\n     *\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(Object object) {\n        return bindMethods(null, object);\n    }\n\n    /**\n     * Binds methods with no parameters on the argument, with the given prefix.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(String prefix, Object object) {\n        return bindNamedArgumentFinder(\n                NamedArgumentFinderFactory.METHODS,\n                prefix,\n                object,\n                object.getClass(),\n                () -> new ObjectMethodArguments(prefix, object));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map) {\n        if (map != null) {\n            map.forEach((name, value) -> bind(name, value));\n        }\n        return typedThis;\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder) {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    This bindNamedArgumentFinder(\n            NamedArgumentFinderFactory<?> factory,\n            String prefix,\n            Object value,\n            Type type,\n            Supplier<NamedArgumentFinder> namedArgumentFinder) {\n        return bindNamedArgumentFinder(namedArgumentFinder.get());\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value) {\n        return bind(position, Character.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value) {\n        return bind(name, Character.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value) {\n        return bind(position, String.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value) {\n        return bind(name, String.class, value);\n    }\n\n    /**\n     * Bind a {@code String} argument positionally, as {@code NVARCHAR} type.\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindNVarchar(int position, String value) {\n        return bindByType(position, value, QualifiedType.of(String.class).with(NVarchar.class));\n    }\n\n    /**\n     * Bind a {@code String} argument by name, as {@code NVARCHAR} type.\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindNVarchar(String name, String value) {\n        return bindByType(name, value, QualifiedType.of(String.class).with(NVarchar.class));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value) {\n        return bind(position, int.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value) {\n        return bind(position, Integer.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value) {\n        return bind(name, int.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value) {\n        return bind(name, Integer.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value) {\n        return bind(position, char.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value) {\n        return bind(name, char.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value) {\n        return bind(position, BigDecimal.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value) {\n        return bind(name, BigDecimal.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value) {\n        return bind(position, Blob.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value) {\n        return bind(name, Blob.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value) {\n        return bind(position, boolean.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value) {\n        return bind(position, Boolean.class, value);\n    }\n\n    private This bind(int position, Class<?> type, Object value) {\n        return bindByType(position, value, type);\n    }\n\n    private This bind(String name, Class<?> type, Object value) {\n        return bindByType(name, value, type);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value) {\n        return bindByType(name, value, boolean.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value) {\n        return bindByType(name, value, Boolean.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value) {\n        return bindByType(position, value, byte.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value) {\n        return bindByType(position, value, Byte.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value) {\n        return bindByType(name, value, byte.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value) {\n        return bindByType(name, value, Byte.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value) {\n        return bindByType(position, value, byte[].class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value) {\n        return bindByType(name, value, byte[].class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length) {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length) {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value) {\n        return bindByType(position, value, Clob.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value) {\n        return bindByType(name, value, Clob.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value) {\n        return bindByType(position, value, java.sql.Date.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value) {\n        return bindByType(name, value, java.sql.Date.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value) {\n        return bindByType(position, value, java.util.Date.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value) {\n        return bindByType(name, value, java.util.Date.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value) {\n        return bindByType(position, value, double.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value) {\n        return bindByType(position, value, Double.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value) {\n        return bindByType(name, value, double.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value) {\n        return bindByType(name, value, Double.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value) {\n        return bindByType(position, value, float.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value) {\n        return bindByType(position, value, Float.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value) {\n        return bindByType(name, value, float.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value) {\n        return bindByType(name, value, Float.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value) {\n        return bindByType(position, value, long.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value) {\n        return bindByType(position, value, Long.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value) {\n        return bindByType(name, value, long.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value) {\n        return bindByType(name, value, Long.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value) {\n        return bindByType(position, value, Short.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value) {\n        return bindByType(position, value, short.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value) {\n        return bindByType(name, value, short.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value) {\n        return bindByType(name, value, Short.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value) {\n        getBinding().addPositional(position, value);\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value) {\n        getBinding().addNamed(name, value);\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value) {\n        return bindByType(position, value, Time.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value) {\n        return bindByType(name, value, Time.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value) {\n        return bindByType(position, value, Timestamp.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value) {\n        return bindByType(name, value, Timestamp.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value) {\n        return bindByType(position, value, URL.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value) {\n        return bindByType(name, value, URL.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URI value) {\n        return bindByType(position, value, URI.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URI value) {\n        return bindByType(name, value, URI.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, UUID value) {\n        return bindByType(position, value, UUID.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, UUID value) {\n        return bindByType(name, value, UUID.class);\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType) {\n        return bindByType(position, value, QualifiedType.of(argumentType));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType) {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the qualified type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindByType(int position, Object value, QualifiedType<?> argumentType) {\n        getBinding().addPositional(position, value, argumentType);\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType) {\n        return bindByType(name, value, QualifiedType.of(argumentType));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType) {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindByType(String name, Object value, QualifiedType<?> argumentType) {\n        getBinding().addNamed(name, value, argumentType);\n        return typedThis;\n    }\n\n    /**\n     * Bind a Java array as a SQL array.  Usually you can just {@link #bind(int, Object)} an array,\n     * but this method allows varargs.\n     * @param <T> the array element type\n     * @param name the name of the parameter to bind\n     * @param array the array to bind\n     * @return this Query\n     */\n    @SafeVarargs\n    public final <T> This bindArray(String name, T... array) {\n        return bindArray(name, array.getClass().getComponentType(), array);\n    }\n\n    /**\n     * Bind a Java array as a SQL array.  Usually you can just {@link #bind(int, Object)} an array,\n     * but this method allows varargs.\n     * @param <T> the array element type\n     * @param pos the position of the parameter to bind\n     * @param array the array to bind\n     * @return this Query\n     */\n    @SafeVarargs\n    public final <T> This bindArray(int pos, T... array) {\n        return bindArray(pos, array.getClass().getComponentType(), array);\n    }\n\n    /**\n     * Bind a Java array as a SQL array, casting each element to a new type.\n     * @param name the name of the parameter to bind\n     * @param elementType the array element type\n     * @param array the array to bind\n     * @return this Query\n     */\n    public final This bindArray(String name, Type elementType, Object... array) {\n        return bindByType(name, array, arrayType(elementType));\n    }\n\n    /**\n     * Bind a Java array as a SQL array, casting each element to a new type.\n     * @param pos the position of the parameter to bind\n     * @param elementType the array element type\n     * @param array the array to bind\n     * @return this Query\n     */\n    public final This bindArray(int pos, Type elementType, Object... array) {\n        return bindByType(pos, array, arrayType(elementType));\n    }\n\n    /**\n     * Bind an Iterable as a SQL array.\n     * @param name the name of the parameter to bind\n     * @param elementType the element type of the Iterable\n     * @param iterable the iterable to bind as an array\n     * @return this Query\n     */\n    public final This bindArray(String name, Type elementType, Iterable<?> iterable) {\n        return bindByType(name, iterable, parameterizeClass(Iterable.class, elementType));\n    }\n\n    /**\n     * Bind an Iterable as a SQL array.\n     * @param pos the position of the parameter to bind\n     * @param elementType the element type of the Iterable\n     * @param iterable the iterable to bind as an array\n     * @return this Query\n     */\n    public final This bindArray(int pos, Type elementType, Iterable<?> iterable) {\n        return bindByType(pos, iterable, parameterizeClass(Iterable.class, elementType));\n    }\n\n    /**\n     * Bind an Iterator as a SQL array.\n     * @param name the name of the parameter to bind\n     * @param elementType the element type of the Iterable\n     * @param iterator the iterator to bind as an array\n     * @return this Query\n     */\n    public final This bindArray(String name, Type elementType, Iterator<?> iterator) {\n        return bindByType(name, iterator, parameterizeClass(Iterator.class, elementType));\n    }\n\n    /**\n     * Bind an Iterator as a SQL array.\n     * @param pos the position of the parameter to bind\n     * @param elementType the element type of the Iterator\n     * @param iterator the Iterator to bind as an array\n     * @return this Query\n     */\n    public final This bindArray(int pos, Type elementType, Iterator<?> iterator) {\n        return bindByType(pos, iterator, parameterizeClass(Iterator.class, elementType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType) {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType) {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType) {\n        return bind(name, ObjectArgument.of(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType) {\n        return bind(position, ObjectArgument.of(value, sqlType));\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        return bindList(EmptyHandling.THROW, key, values);\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param onEmpty handler for null/empty vararg array\n     * @param key     attribute name\n     * @param values  vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     * @see EmptyHandling\n     */\n    public final This bindList(BiConsumer<SqlStatement, String> onEmpty, String key, Object... values) {\n        return bindList(onEmpty, key, values == null ? null : Arrays.asList(values));\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param key    attribute name\n     * @param values iterable values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the iterable is empty.\n     */\n    public final This bindList(String key, Iterable<?> values) {\n        return bindList(EmptyHandling.THROW, key, values);\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param onEmpty handler for null/empty list\n     * @param key     attribute name\n     * @param values  iterable values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the iterable is empty.\n     * @see EmptyHandling\n     */\n    public final This bindList(BiConsumer<SqlStatement, String> onEmpty, String key, Iterable<?> values) {\n        return bindList(onEmpty, key, values == null ? null : IterableLike.toList(values));\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param key    attribute name\n     * @param values iterator of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the iterator is empty.\n     */\n    public final This bindList(String key, Iterator<?> values) {\n        return bindList(EmptyHandling.THROW, key, values);\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param onEmpty handler for null/empty list\n     * @param key     attribute name\n     * @param values  iterator of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the iterator is empty.\n     * @see EmptyHandling\n     */\n    public final This bindList(BiConsumer<SqlStatement, String> onEmpty, String key, Iterator<?> values) {\n        return bindList(onEmpty, key, values == null ? null : IterableLike.toList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param onEmpty handler for null/empty list\n     * @param key     attribute name\n     * @param values  list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     * @see EmptyHandling\n     */\n    public final This bindList(BiConsumer<SqlStatement, String> onEmpty, String key, List<?> values) {\n        if (values == null || values.isEmpty()) {\n            onEmpty.accept(this, key);\n            return typedThis;\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            String paramName = getConfig().get(SqlStatements.class).getSqlParser().nameParameter(name, getContext());\n            names.append(paramName);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean, getConfig());\n\n            names.append('(');\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(',');\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + '_' + valueIndex + '_' + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(')');\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * For each value given, create a tuple by invoking each given method in order, and bind the tuple into\n     * a {@code VALUES (...)} format insert clause.\n     * @param key attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value\n     * @param methodNames list of methods that will be invoked on the values\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException if the method cannot be found\n     */\n    public final This bindMethodsList(String key, Iterable<?> values, List<String> methodNames) {\n        final Iterator<?> valueIter = values.iterator();\n        if (!valueIter.hasNext()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        if (methodNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        final StringBuilder names = new StringBuilder();\n        final StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIter.hasNext(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            final Object bean = valueIter.next();\n            final ObjectMethodArguments beanMethods = new ObjectMethodArguments(null, bean);\n\n            names.append('(');\n            for (int methodIndex = 0; methodIndex < methodNames.size(); methodIndex++) {\n                if (methodIndex > 0) {\n                    names.append(',');\n                }\n\n                final String methodName = methodNames.get(methodIndex);\n                final String name = key + valueIndex + '.' + methodName;\n                names.append(':').append(name);\n                final Argument argument = beanMethods.find(methodName, ctx)\n                    .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + methodName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(')');\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        // Uses stream match, cause the Java 9 ImmutableList implementation throws an NPE if asked `contains(null)`\n        if (values.stream().anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    /**\n     * Define all bound arguments that don't already have a definition with a boolean indicating their presence.\n     * Useful to easily template optional properties of pojos or beans like {@code <if(property)>property = :property<endif>}.\n     * @return this\n     */\n    @Beta\n    public This defineNamedBindings() {\n        return addCustomizer(new DefineNamedBindingsStatementCustomizer());\n    }\n\n    PreparedStatement internalExecute() {\n        final StatementContext ctx = getContext();\n\n        beforeTemplating();\n\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(sql, ctx);\n        ctx.setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, ctx);\n        ctx.setParsedSql(parsedSql);\n\n        try {\n            stmt = createStatement(ctx, parsedSql);\n            // The statement builder might (or might not) clean up the statement when called. E.g. the\n            // caching statement builder relies on the statement *not* being closed.\n            addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), this.sql, stmt));\n            getConfig(SqlStatements.class).customize(stmt);\n        } catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, ctx);\n        }\n\n        ctx.setStatement(stmt);\n\n        beforeBinding();\n\n        new ArgumentBinder<>(stmt, ctx, parsedSql.getParameters()).bind(getBinding());\n\n        beforeExecution();\n\n        try {\n            SqlLoggerUtil.wrap(stmt::execute, ctx, getConfig(SqlStatements.class).getSqlLogger());\n        } catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n\n            throw new UnableToExecuteStatementException(e, ctx);\n        }\n\n        afterExecution();\n\n        return stmt;\n    }\n\n    PreparedStatement createStatement(final StatementContext ctx, ParsedSql parsedSql) throws SQLException {\n        return handle.getStatementBuilder().create(handle.getConnection(), parsedSql.getSql(), ctx);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(Class<T> type) {\n        return (RowMapper<T>) mapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(GenericType<T> type) {\n        return (RowMapper<T>) mapperForType(type.getType());\n    }\n\n    RowMapper<?> mapperForType(Type type) {\n        return getConfig(Mappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n\n    void beforeTemplating() {\n        callCustomizers(c -> c.beforeTemplating(stmt, getContext()));\n    }\n\n    void beforeBinding() {\n        callCustomizers(c -> c.beforeBinding(stmt, getContext()));\n    }\n\n    void beforeExecution() {\n        callCustomizers(c -> c.beforeExecution(stmt, getContext()));\n    }\n\n    void afterExecution() {\n        callCustomizers(c -> c.afterExecution(stmt, getContext()));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.net.URI;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.UUID;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.argument.ObjectFieldArguments;\nimport org.jdbi.v3.core.argument.ObjectMethodArguments;\nimport org.jdbi.v3.core.argument.internal.NamedArgumentFinderFactory;\nimport org.jdbi.v3.core.argument.internal.PojoPropertyArguments;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.internal.IterableLike;\nimport org.jdbi.v3.core.mapper.Mappers;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.immutables.JdbiImmutables;\nimport org.jdbi.v3.core.qualifier.NVarchar;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.meta.Beta;\n\nimport static java.util.stream.Collectors.joining;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.arrayType;\nimport static org.jdbi.v3.core.generic.GenericTypes.parameterizeClass;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\n@SuppressWarnings({\"deprecation\", \"PMD.ExcessiveClassLength\"})\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private final Handle handle;\n    private final String sql;\n    PreparedStatement stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding() {\n        return getContext().getBinding();\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql() {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds) {\n        return addCustomizer(StatementCustomizers.statementTimeout(seconds));\n    }\n\n    /**\n     * Transfer ownership of the handle to the statement: when the statement is closed,\n     * commit the handle's transaction (if one exists) and close the handle.\n     * @return this\n     */\n    public This cleanupHandleCommit() {\n        return cleanupHandle(Handle::commit);\n    }\n\n    /**\n     * When the statement is closed, roll it back then close the owning Handle.\n     * @return this\n     */\n    public This cleanupHandleRollback() {\n        return cleanupHandle(Handle::rollback);\n    }\n\n    private This cleanupHandle(Consumer<Handle> action) {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    action.accept(handle);\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument) {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument) {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean) {\n        return bindBean(null, bean);\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"deprecation\")\n    public This bindBean(String prefix, Object bean) {\n        return bindNamedArgumentFinder(\n                NamedArgumentFinderFactory.BEAN,\n                prefix,\n                bean,\n                bean.getClass(),\n                () -> new BeanPropertyArguments(prefix, bean, getConfig()));\n    }\n\n    /**\n     * Binds named parameters from object properties on the argument.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param pojo source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(Object pojo) {\n        return bindPojo(null, pojo);\n    }\n\n    /**\n     * Binds named parameters from object properties on the bean argument, with the given prefix.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param pojo source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(String prefix, Object pojo) {\n        return bindPojo(prefix, pojo, pojo.getClass());\n    }\n\n    /**\n     * Binds named parameters from object properties on the argument.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param pojo source of named parameter values to use as arguments\n     * @param type the static, possibly generic type of the pojo\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(Object pojo, Type type) {\n        return bindPojo(null, pojo, type);\n    }\n\n    /**\n     * Binds named parameters from object properties on the bean argument, with the given prefix.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param pojo source of named parameter values to use as arguments\n     * @param type the static, possibly generic type of the pojo\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(String prefix, Object pojo, Type type) {\n        return bindNamedArgumentFinder(\n                NamedArgumentFinderFactory.POJO,\n                prefix,\n                pojo,\n                type,\n                () -> new PojoPropertyArguments(prefix, pojo, type, getConfig()));\n    }\n\n    /**\n     * Binds named parameters from object properties on the argument.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param pojo source of named parameter values to use as arguments\n     * @param type the static generic type of the pojo\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(Object pojo, GenericType<?> type) {\n        return bindPojo(null, pojo, type.getType());\n    }\n\n    /**\n     * Binds named parameters from object properties on the bean argument, with the given prefix.\n     * The type must have been registered with pojo type mapping functionality first, usually\n     * by a plugin or configuration.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param pojo source of named parameter values to use as arguments\n     * @param type the static generic type of the pojo\n     *\n     * @return modified statement\n     * @see JdbiImmutables an example method of registering a type\n     */\n    @Beta\n    public This bindPojo(String prefix, Object pojo, GenericType<?> type) {\n        return bindPojo(prefix, pojo, type.getType());\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(Object object) {\n        return bindFields(null, object);\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param prefix a prefix to apply to all field names.\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(String prefix, Object object) {\n        return bindNamedArgumentFinder(\n                NamedArgumentFinderFactory.FIELDS,\n                prefix,\n                object,\n                object.getClass(),\n                () -> new ObjectFieldArguments(prefix, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument.\n     *\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(Object object) {\n        return bindMethods(null, object);\n    }\n\n    /**\n     * Binds methods with no parameters on the argument, with the given prefix.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(String prefix, Object object) {\n        return bindNamedArgumentFinder(\n                NamedArgumentFinderFactory.METHODS,\n                prefix,\n                object,\n                object.getClass(),\n                () -> new ObjectMethodArguments(prefix, object));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map) {\n        if (map != null) {\n            map.forEach((name, value) -> bind(name, value));\n        }\n        return typedThis;\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder) {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    This bindNamedArgumentFinder(\n            NamedArgumentFinderFactory<?> factory,\n            String prefix,\n            Object value,\n            Type type,\n            Supplier<NamedArgumentFinder> namedArgumentFinder) {\n        return bindNamedArgumentFinder(namedArgumentFinder.get());\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value) {\n        return bind(position, Character.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value) {\n        return bind(name, Character.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value) {\n        return bind(position, String.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value) {\n        return bind(name, String.class, value);\n    }\n\n    /**\n     * Bind a {@code String} argument positionally, as {@code NVARCHAR} type.\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindNVarchar(int position, String value) {\n        return bindByType(position, value, QualifiedType.of(String.class).with(NVarchar.class));\n    }\n\n    /**\n     * Bind a {@code String} argument by name, as {@code NVARCHAR} type.\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindNVarchar(String name, String value) {\n        return bindByType(name, value, QualifiedType.of(String.class).with(NVarchar.class));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value) {\n        return bind(position, int.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value) {\n        return bind(position, Integer.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value) {\n        return bind(name, int.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value) {\n        return bind(name, Integer.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value) {\n        return bind(position, char.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value) {\n        return bind(name, char.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value) {\n        return bind(position, BigDecimal.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value) {\n        return bind(name, BigDecimal.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value) {\n        return bind(position, Blob.class, value);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value) {\n        return bind(name, Blob.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value) {\n        return bind(position, boolean.class, value);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value) {\n        return bind(position, Boolean.class, value);\n    }\n\n    private This bind(int position, Class<?> type, Object value) {\n        return bindByType(position, value, type);\n    }\n\n    private This bind(String name, Class<?> type, Object value) {\n        return bindByType(name, value, type);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value) {\n        return bindByType(name, value, boolean.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value) {\n        return bindByType(name, value, Boolean.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value) {\n        return bindByType(position, value, byte.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value) {\n        return bindByType(position, value, Byte.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value) {\n        return bindByType(name, value, byte.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value) {\n        return bindByType(name, value, Byte.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value) {\n        return bindByType(position, value, byte[].class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value) {\n        return bindByType(name, value, byte[].class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length) {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length) {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value) {\n        return bindByType(position, value, Clob.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value) {\n        return bindByType(name, value, Clob.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value) {\n        return bindByType(position, value, java.sql.Date.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value) {\n        return bindByType(name, value, java.sql.Date.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value) {\n        return bindByType(position, value, java.util.Date.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value) {\n        return bindByType(name, value, java.util.Date.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value) {\n        return bindByType(position, value, double.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value) {\n        return bindByType(position, value, Double.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value) {\n        return bindByType(name, value, double.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value) {\n        return bindByType(name, value, Double.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value) {\n        return bindByType(position, value, float.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value) {\n        return bindByType(position, value, Float.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value) {\n        return bindByType(name, value, float.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value) {\n        return bindByType(name, value, Float.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value) {\n        return bindByType(position, value, long.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value) {\n        return bindByType(position, value, Long.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value) {\n        return bindByType(name, value, long.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value) {\n        return bindByType(name, value, Long.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value) {\n        return bindByType(position, value, Short.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value) {\n        return bindByType(position, value, short.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value) {\n        return bindByType(name, value, short.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value) {\n        return bindByType(name, value, Short.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value) {\n        getBinding().addPositional(position, value);\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value) {\n        getBinding().addNamed(name, value);\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value) {\n        return bindByType(position, value, Time.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value) {\n        return bindByType(name, value, Time.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value) {\n        return bindByType(position, value, Timestamp.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value) {\n        return bindByType(name, value, Timestamp.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value) {\n        return bindByType(position, value, URL.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value) {\n        return bindByType(name, value, URL.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URI value) {\n        return bindByType(position, value, URI.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URI value) {\n        return bindByType(name, value, URI.class);\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, UUID value) {\n        return bindByType(position, value, UUID.class);\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, UUID value) {\n        return bindByType(name, value, UUID.class);\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType) {\n        return bindByType(position, value, QualifiedType.of(argumentType));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType) {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the qualified type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindByType(int position, Object value, QualifiedType<?> argumentType) {\n        getBinding().addPositional(position, value, argumentType);\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType) {\n        return bindByType(name, value, QualifiedType.of(argumentType));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType) {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindByType(String name, Object value, QualifiedType<?> argumentType) {\n        getBinding().addNamed(name, value, argumentType);\n        return typedThis;\n    }\n\n    /**\n     * Bind a Java array as a SQL array.  Usually you can just {@link #bind(int, Object)} an array,\n     * but this method allows varargs.\n     * @param <T> the array element type\n     * @param name the name of the parameter to bind\n     * @param array the array to bind\n     * @return this Query\n     */\n    @SafeVarargs\n    public final <T> This bindArray(String name, T... array) {\n        return bindArray(name, array.getClass().getComponentType(), array);\n    }\n\n    /**\n     * Bind a Java array as a SQL array.  Usually you can just {@link #bind(int, Object)} an array,\n     * but this method allows varargs.\n     * @param <T> the array element type\n     * @param pos the position of the parameter to bind\n     * @param array the array to bind\n     * @return this Query\n     */\n    @SafeVarargs\n    public final <T> This bindArray(int pos, T... array) {\n        return bindArray(pos, array.getClass().getComponentType(), array);\n    }\n\n    /**\n     * Bind a Java array as a SQL array, casting each element to a new type.\n     * @param name the name of the parameter to bind\n     * @param elementType the array element type\n     * @param array the array to bind\n     * @return this Query\n     */\n    public final This bindArray(String name, Type elementType, Object... array) {\n        return bindByType(name, array, arrayType(elementType));\n    }\n\n    /**\n     * Bind a Java array as a SQL array, casting each element to a new type.\n     * @param pos the position of the parameter to bind\n     * @param elementType the array element type\n     * @param array the array to bind\n     * @return this Query\n     */\n    public final This bindArray(int pos, Type elementType, Object... array) {\n        return bindByType(pos, array, arrayType(elementType));\n    }\n\n    /**\n     * Bind an Iterable as a SQL array.\n     * @param name the name of the parameter to bind\n     * @param elementType the element type of the Iterable\n     * @param iterable the iterable to bind as an array\n     * @return this Query\n     */\n    public final This bindArray(String name, Type elementType, Iterable<?> iterable) {\n        return bindByType(name, iterable, parameterizeClass(Iterable.class, elementType));\n    }\n\n    /**\n     * Bind an Iterable as a SQL array.\n     * @param pos the position of the parameter to bind\n     * @param elementType the element type of the Iterable\n     * @param iterable the iterable to bind as an array\n     * @return this Query\n     */\n    public final This bindArray(int pos, Type elementType, Iterable<?> iterable) {\n        return bindByType(pos, iterable, parameterizeClass(Iterable.class, elementType));\n    }\n\n    /**\n     * Bind an Iterator as a SQL array.\n     * @param name the name of the parameter to bind\n     * @param elementType the element type of the Iterable\n     * @param iterator the iterator to bind as an array\n     * @return this Query\n     */\n    public final This bindArray(String name, Type elementType, Iterator<?> iterator) {\n        return bindByType(name, iterator, parameterizeClass(Iterator.class, elementType));\n    }\n\n    /**\n     * Bind an Iterator as a SQL array.\n     * @param pos the position of the parameter to bind\n     * @param elementType the element type of the Iterator\n     * @param iterator the Iterator to bind as an array\n     * @return this Query\n     */\n    public final This bindArray(int pos, Type elementType, Iterator<?> iterator) {\n        return bindByType(pos, iterator, parameterizeClass(Iterator.class, elementType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType) {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType) {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType) {\n        return bind(name, ObjectArgument.of(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType) {\n        return bind(position, ObjectArgument.of(value, sqlType));\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        return bindList(EmptyHandling.THROW, key, values);\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param onEmpty handler for null/empty vararg array\n     * @param key     attribute name\n     * @param values  vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     * @see EmptyHandling\n     */\n    public final This bindList(BiConsumer<SqlStatement, String> onEmpty, String key, Object... values) {\n        return bindList(onEmpty, key, values == null ? null : Arrays.asList(values));\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param key    attribute name\n     * @param values iterable values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the iterable is empty.\n     */\n    public final This bindList(String key, Iterable<?> values) {\n        return bindList(EmptyHandling.THROW, key, values);\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param onEmpty handler for null/empty list\n     * @param key     attribute name\n     * @param values  iterable values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the iterable is empty.\n     * @see EmptyHandling\n     */\n    public final This bindList(BiConsumer<SqlStatement, String> onEmpty, String key, Iterable<?> values) {\n        return bindList(onEmpty, key, values == null ? null : IterableLike.toList(values));\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param key    attribute name\n     * @param values iterator of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the iterator is empty.\n     */\n    public final This bindList(String key, Iterator<?> values) {\n        return bindList(EmptyHandling.THROW, key, values);\n    }\n\n    /**\n     * see {@link #bindList(BiConsumer, String, List)}\n     *\n     * @param onEmpty handler for null/empty list\n     * @param key     attribute name\n     * @param values  iterator of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the iterator is empty.\n     * @see EmptyHandling\n     */\n    public final This bindList(BiConsumer<SqlStatement, String> onEmpty, String key, Iterator<?> values) {\n        return bindList(onEmpty, key, values == null ? null : IterableLike.toList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param onEmpty handler for null/empty list\n     * @param key     attribute name\n     * @param values  list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     * @see EmptyHandling\n     */\n    public final This bindList(BiConsumer<SqlStatement, String> onEmpty, String key, List<?> values) {\n        if (values == null || values.isEmpty()) {\n            onEmpty.accept(this, key);\n            return typedThis;\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            String paramName = getConfig().get(SqlStatements.class).getSqlParser().nameParameter(name, getContext());\n            names.append(paramName);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean, getConfig());\n\n            names.append('(');\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(',');\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + '_' + valueIndex + '_' + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(')');\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * For each value given, create a tuple by invoking each given method in order, and bind the tuple into\n     * a {@code VALUES (...)} format insert clause.\n     * @param key attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value\n     * @param methodNames list of methods that will be invoked on the values\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException if the method cannot be found\n     */\n    public final This bindMethodsList(String key, Iterable<?> values, List<String> methodNames) {\n        final Iterator<?> valueIter = values.iterator();\n        if (!valueIter.hasNext()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        if (methodNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        final StringBuilder names = new StringBuilder();\n        final StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIter.hasNext(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            final Object bean = valueIter.next();\n            final ObjectMethodArguments beanMethods = new ObjectMethodArguments(null, bean);\n\n            names.append('(');\n            for (int methodIndex = 0; methodIndex < methodNames.size(); methodIndex++) {\n                if (methodIndex > 0) {\n                    names.append(',');\n                }\n\n                final String methodName = methodNames.get(methodIndex);\n                final String name = key + valueIndex + '.' + methodName;\n                names.append(':').append(name);\n                final Argument argument = beanMethods.find(methodName, ctx)\n                    .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + methodName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(')');\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        // Uses stream match, cause the Java 9 ImmutableList implementation throws an NPE if asked `contains(null)`\n        if (values.stream().anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    /**\n     * Define all bound arguments that don't already have a definition with a boolean indicating their presence.\n     * Useful to easily template optional properties of pojos or beans like {@code <if(property)>property = :property<endif>}.\n     * @return this\n     */\n    @Beta\n    public This defineNamedBindings() {\n        return addCustomizer(new DefineNamedBindingsStatementCustomizer());\n    }\n\n    PreparedStatement internalExecute() {\n        final StatementContext ctx = getContext();\n\n        beforeTemplating();\n\n        ParsedSql parsedSql = parseSql();\n\n        try {\n            stmt = createStatement(ctx, parsedSql);\n            // The statement builder might (or might not) clean up the statement when called. E.g. the\n            // caching statement builder relies on the statement *not* being closed.\n            addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), this.sql, stmt));\n            getConfig(SqlStatements.class).customize(stmt);\n        } catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, ctx);\n        }\n\n        ctx.setStatement(stmt);\n\n        beforeBinding();\n\n        new ArgumentBinder<>(stmt, ctx, parsedSql.getParameters()).bind(getBinding());\n\n        beforeExecution();\n\n        try {\n            SqlLoggerUtil.wrap(stmt::execute, ctx, getConfig(SqlStatements.class).getSqlLogger());\n        } catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n\n            throw new UnableToExecuteStatementException(e, ctx);\n        }\n\n        afterExecution();\n\n        return stmt;\n    }\n\n    PreparedStatement createStatement(final StatementContext ctx, ParsedSql parsedSql) throws SQLException {\n        return handle.getStatementBuilder().create(handle.getConnection(), parsedSql.getSql(), ctx);\n    }\n\n    ParsedSql parseSql() {\n        StatementContext ctx = getContext();\n        SqlStatements statements = getConfig(SqlStatements.class);\n\n        String renderedSql = statements.preparedRender(sql, ctx);\n        ctx.setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = statements.getSqlParser().parse(renderedSql, ctx);\n        ctx.setParsedSql(parsedSql);\n\n        return parsedSql;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(Class<T> type) {\n        return (RowMapper<T>) mapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(GenericType<T> type) {\n        return (RowMapper<T>) mapperForType(type.getType());\n    }\n\n    RowMapper<?> mapperForType(Type type) {\n        return getConfig(Mappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n\n    void beforeTemplating() {\n        callCustomizers(c -> c.beforeTemplating(stmt, getContext()));\n    }\n\n    void beforeBinding() {\n        callCustomizers(c -> c.beforeBinding(stmt, getContext()));\n    }\n\n    void beforeExecution() {\n        callCustomizers(c -> c.beforeExecution(stmt, getContext()));\n    }\n\n    void afterExecution() {\n        callCustomizers(c -> c.afterExecution(stmt, getContext()));\n    }\n}\n","lineNo":1808}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.MethodType;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\n\npublic class AnnotationFactory {\n    private AnnotationFactory() {}\n\n    public static <T extends Annotation> T create(Class<T> annotationType) {\n        return create(annotationType, Collections.emptyMap());\n    }\n    public static <T extends Annotation> T create(Class<T> annotationType, Map<String, ?> values) {\n        Arrays.stream(annotationType.getDeclaredMethods())\n            .filter(m -> m.getDefaultValue() == null)\n            .filter(m -> !values.containsKey(m.getName()))\n            .findAny()\n            .ifPresent(m -> {\n                throw new IllegalArgumentException(String.format(\n                        \"Cannot synthesize annotation @%s from %s.class because it has attribute \" + m.getName() + \" without a default or specified value\",\n                        annotationType.getSimpleName(),\n                        annotationType.getSimpleName()));\n        });\n\n        Class<?>[] interfaces = {annotationType};\n        InvocationHandler invocationHandler = getInvocationHandler(annotationType, values);\n\n        @SuppressWarnings(\"unchecked\")\n        T annotation = (T) Proxy.newProxyInstance(\n                Optional.ofNullable(annotationType.getClassLoader())\n                        .orElseGet(Thread.currentThread()::getContextClassLoader),\n                interfaces,\n                invocationHandler);\n\n        return annotation;\n    }\n\n    private static <T extends Annotation> InvocationHandler getInvocationHandler(Class<T> annotationType, Map<String, ?> values) {\n        final Function<Method, Object> getValue = method ->\n            Optional.<Object>ofNullable(values.get(method.getName()))\n                .orElseGet(method::getDefaultValue);\n        final int hashCode = Arrays.stream(annotationType.getDeclaredMethods())\n                .mapToInt(m -> memberHash(m.getName(), getValue.apply(m)))\n                .sum();\n        final String toString = \"@\" + annotationType.getName() + \"(\"\n                + values.entrySet()\n                    .stream()\n                    .sorted(Comparator.comparing(Entry::getKey))\n                    .map(e -> e.getKey() + \"=\" + e.getValue())\n                    .collect(Collectors.joining(\", \"))\n                + \")\";\n        return (proxy, method, args) -> {\n            String name = method.getName();\n            if (\"annotationType\".equals(name) && method.getParameterCount() == 0) {\n                return annotationType;\n            }\n\n            if (\"equals\".equals(name) && method.getParameterCount() == 1\n                && Object.class.equals(method.getParameterTypes()[0])) {\n                Annotation that = (Annotation) args[0];\n                return annotationType.equals(that.annotationType()) && valuesEqual(annotationType, proxy, that);\n            }\n\n            if (\"hashCode\".equals(name) && method.getParameterCount() == 0) {\n                return hashCode;\n            }\n\n            if (\"toString\".equals(name) && method.getParameterCount() == 0) {\n                return toString;\n            }\n\n            if (method.getDeclaringClass() == annotationType) {\n                return getValue.apply(method);\n            }\n\n            throw new IllegalStateException(\"Unknown method \" + method + \" for annotation type \" + annotationType);\n        };\n    }\n\n    private static int memberHash(String name, Object value) {\n        return (127 * name.hashCode()) ^ valueHash(value);\n    }\n\n    private static int valueHash(Object value) {\n        Class<? extends Object> valueClass = value.getClass();\n        if (!valueClass.isArray()) {\n            return value.hashCode();\n        }\n        return Unchecked.supplier(() ->\n            (Integer) MethodHandles.publicLookup()\n                .findStatic(Arrays.class, \"hashCode\", MethodType.methodType(int.class, valueClass))\n                .invoke(value)).get();\n    }\n\n    private static <A extends Annotation> boolean valuesEqual(Class<A> annotationType, Object a, Object b) {\n        for (Method m : annotationType.getDeclaredMethods()) {\n            Function<Object, Object> invoker = Unchecked.function(m::invoke);\n            Object valueA = invoker.apply(a);\n            Object valueB = invoker.apply(b);\n            if (valueA != null\n             && valueB != null\n             && valueA.getClass().isArray()\n             && valueA.getClass().equals(valueB.getClass())\n             && Boolean.FALSE.equals(Unchecked.supplier(() ->\n                    MethodHandles.publicLookup()\n                        .findStatic(Arrays.class, \"equals\", MethodType.methodType(boolean.class, valueA.getClass(), valueB.getClass()))\n                        .invoke(a, b)).get())) {\n                return false;\n            }\n            if (!Objects.equals(valueA, valueB)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.MethodType;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\n\npublic class AnnotationFactory {\n    private AnnotationFactory() {}\n\n    public static <T extends Annotation> T create(Class<T> annotationType) {\n        return create(annotationType, Collections.emptyMap());\n    }\n    public static <T extends Annotation> T create(Class<T> annotationType, Map<String, ?> values) {\n        Arrays.stream(annotationType.getDeclaredMethods())\n            .filter(m -> m.getDefaultValue() == null)\n            .filter(m -> !values.containsKey(m.getName()))\n            .findAny()\n            .ifPresent(m -> {\n                throw new IllegalArgumentException(String.format(\n                        \"Cannot synthesize annotation @%s from %s.class because it has attribute \" + m.getName() + \" without a default or specified value\",\n                        annotationType.getSimpleName(),\n                        annotationType.getSimpleName()));\n        });\n\n        Class<?>[] interfaces = {annotationType};\n        InvocationHandler invocationHandler = getInvocationHandler(annotationType, values);\n\n        @SuppressWarnings(\"unchecked\")\n        T annotation = (T) Proxy.newProxyInstance(\n                Optional.ofNullable(annotationType.getClassLoader())\n                        .orElseGet(Thread.currentThread()::getContextClassLoader),\n                interfaces,\n                invocationHandler);\n\n        return annotation;\n    }\n\n    private static <T extends Annotation> InvocationHandler getInvocationHandler(Class<T> annotationType, Map<String, ?> values) {\n        final Function<Method, Object> getValue = method ->\n            Optional.<Object>ofNullable(values.get(method.getName()))\n                .orElseGet(method::getDefaultValue);\n        final int hashCode = Arrays.stream(annotationType.getDeclaredMethods())\n                .mapToInt(m -> memberHash(m.getName(), getValue.apply(m)))\n                .sum();\n        final String toString = \"@\" + annotationType.getName() + \"(\"\n                + values.entrySet()\n                    .stream()\n                    .sorted(Comparator.comparing(Entry::getKey))\n                    .map(e -> e.getKey() + \"=\" + e.getValue())\n                    .collect(Collectors.joining(\", \"))\n                + \")\";\n        return (proxy, method, args) -> {\n            String name = method.getName();\n            if (\"annotationType\".equals(name) && method.getParameterCount() == 0) {\n                return annotationType;\n            }\n\n            if (\"equals\".equals(name) && method.getParameterCount() == 1\n                && Object.class.equals(method.getParameterTypes()[0])) {\n                Object arg = args[0];\n                if (!(arg instanceof Annotation)) {\n                    return false;\n                }\n                Annotation that = (Annotation) arg;\n                return annotationType.equals(that.annotationType()) && valuesEqual(annotationType, proxy, that);\n            }\n\n            if (\"hashCode\".equals(name) && method.getParameterCount() == 0) {\n                return hashCode;\n            }\n\n            if (\"toString\".equals(name) && method.getParameterCount() == 0) {\n                return toString;\n            }\n\n            if (method.getDeclaringClass() == annotationType) {\n                return getValue.apply(method);\n            }\n\n            throw new IllegalStateException(\"Unknown method \" + method + \" for annotation type \" + annotationType);\n        };\n    }\n\n    private static int memberHash(String name, Object value) {\n        return (127 * name.hashCode()) ^ valueHash(value);\n    }\n\n    private static int valueHash(Object value) {\n        Class<? extends Object> valueClass = value.getClass();\n        if (!valueClass.isArray()) {\n            return value.hashCode();\n        }\n        return Unchecked.supplier(() ->\n            (Integer) MethodHandles.publicLookup()\n                .findStatic(Arrays.class, \"hashCode\", MethodType.methodType(int.class, valueClass))\n                .invoke(value)).get();\n    }\n\n    private static <A extends Annotation> boolean valuesEqual(Class<A> annotationType, Object a, Object b) {\n        for (Method m : annotationType.getDeclaredMethods()) {\n            Function<Object, Object> invoker = Unchecked.function(m::invoke);\n            Object valueA = invoker.apply(a);\n            Object valueB = invoker.apply(b);\n            if (valueA != null\n             && valueB != null\n             && valueA.getClass().isArray()\n             && valueA.getClass().equals(valueB.getClass())\n             && Boolean.FALSE.equals(Unchecked.supplier(() ->\n                    MethodHandles.publicLookup()\n                        .findStatic(Arrays.class, \"equals\", MethodType.methodType(boolean.class, valueA.getClass(), valueB.getClass()))\n                        .invoke(a, b)).get())) {\n                return false;\n            }\n            if (!Objects.equals(valueA, valueB)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","lineNo":87}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.lang.reflect.Type;\nimport java.sql.Types;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.function.Function;\n\nimport org.jdbi.v3.core.array.SqlArrayArgumentFactory;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.JdbiConfig;\nimport org.jdbi.v3.core.internal.JdbiOptionals;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.meta.Beta;\n\n/**\n * A registry for ArgumentFactory instances.\n * When a statement with bound parameters is executed, Jdbi consults the\n * Arguments registry to obtain an Argument instance for each bound parameter\n * (see #findFor(...)).\n * The factories are consulted in reverse order of registration (i.e. last-registered wins).\n */\npublic class Arguments implements JdbiConfig<Arguments> {\n    private final List<QualifiedArgumentFactory> factories = new CopyOnWriteArrayList<>();\n    private final Map<QualifiedType<?>, Function<Object, Argument>> preparedFactories = new ConcurrentHashMap<>();\n\n    private ConfigRegistry registry;\n    private Argument untypedNullArgument = new NullArgument(Types.OTHER);\n    private boolean bindingNullToPrimitivesPermitted = true;\n\n    public Arguments(ConfigRegistry registry) {\n        this.registry = registry;\n\n        // the null factory must be interrogated last to preserve types!\n        register(new UntypedNullArgumentFactory());\n\n        register(new PrimitivesArgumentFactory());\n        register(new BoxedArgumentFactory());\n        register(new SqlArgumentFactory());\n        register(new InternetArgumentFactory());\n        register(new SqlTimeArgumentFactory());\n        register(new JavaTimeArgumentFactory());\n        register(new SqlArrayArgumentFactory());\n        register(new EssentialsArgumentFactory());\n        register(new JavaTimeZoneIdArgumentFactory());\n        register(new NVarcharArgumentFactory());\n        register(new EnumArgumentFactory());\n        register(new OptionalArgumentFactory());\n        register(new DirectArgumentFactory());\n    }\n\n    @Override\n    public void setRegistry(ConfigRegistry registry) {\n        this.registry = registry;\n        if (preparedFactories.isEmpty()) {\n            for (int i = factories.size() - 1; i >= 0; --i) {\n                prePrepareTypes(factories.get(i));\n            }\n        }\n    }\n\n    private Arguments(Arguments that) {\n        factories.addAll(that.factories);\n        untypedNullArgument = that.untypedNullArgument;\n        bindingNullToPrimitivesPermitted = that.bindingNullToPrimitivesPermitted;\n    }\n\n    /**\n     * Registers the given argument factory.\n     * If more than one of the registered factories supports a given parameter type, the last-registered factory wins.\n     * @param factory the factory to add\n     * @return this\n     */\n    public Arguments register(ArgumentFactory factory) {\n        return register(QualifiedArgumentFactory.adapt(registry, factory));\n    }\n\n    /**\n     * Registers the given qualified argument factory.\n     * If more than one of the registered factories supports a given parameter type, the last-registered factory wins.\n     * @param factory the qualified factory to add\n     * @return this\n     */\n    @Beta\n    public Arguments register(QualifiedArgumentFactory factory) {\n        factories.add(0, factory);\n        prePrepareTypes(factory);\n        return this;\n    }\n\n    private void prePrepareTypes(QualifiedArgumentFactory factory) {\n        if (factory instanceof QualifiedArgumentFactory.Preparable) {\n            QualifiedArgumentFactory.Preparable qaf = (QualifiedArgumentFactory.Preparable) factory;\n            qaf.prePreparedTypes()\n                .forEach(t ->\n                    preparedFactories.put(t,\n                        qaf.prepare(t, registry)\n                            .orElseThrow(() -> new IllegalStateException(\"Preparable \" + t + \" failed on \" + qaf))));\n        }\n    }\n\n    /**\n     * Obtain an argument for given value in the given context\n     *\n     * @param type  the type of the argument.\n     * @param value the argument value.\n     * @return an Argument for the given value.\n     */\n    public Optional<Argument> findFor(Type type, Object value) {\n        return findFor(QualifiedType.of(type), value);\n    }\n\n    /**\n     * Obtain an argument for given value in the given context.\n     *\n     * @param type  the qualified type of the argument.\n     * @param value the argument value.\n     * @return an Argument for the given value.\n     */\n    @Beta\n    public Optional<Argument> findFor(QualifiedType<?> type, Object value) {\n        Function<Object, Argument> prepared = preparedFactories.get(type);\n        if (prepared != null) {\n            return Optional.of(prepared.apply(value));\n        }\n        return factories.stream()\n            .flatMap(factory -> JdbiOptionals.stream(factory.build(type, value, registry)))\n            .findFirst();\n    }\n\n    /**\n     * Obtain a prepared argument function for given type in the given context.\n     *\n     * @param type  the type of the argument.\n     * @return an Argument factory function for the given value.\n     */\n    public Optional<Function<Object, Argument>> prepareFor(Type type) {\n        return prepareFor(QualifiedType.of(type));\n    }\n\n    /**\n     * Obtain a prepared argument function for given type in the given context.\n     *\n     * @param type  the qualified type of the argument.\n     * @return an Argument factory function for the given value.\n     */\n    @Beta\n    public Optional<Function<Object, Argument>> prepareFor(QualifiedType<?> type) {\n        Function<Object, Argument> prepared = preparedFactories.get(type);\n        if (prepared != null) {\n            return Optional.of(prepared);\n        }\n        return factories.stream()\n            .filter(QualifiedArgumentFactory.Preparable.class::isInstance)\n            .map(QualifiedArgumentFactory.Preparable.class::cast)\n            .flatMap(factory -> JdbiOptionals.stream(factory.prepare(type, registry)))\n            .findFirst();\n    }\n\n    @Beta\n    public List<QualifiedArgumentFactory> getFactories() {\n        return Collections.unmodifiableList(factories);\n    }\n\n    /**\n     * Configure the {@link Argument} to use when binding a null\n     * we don't have a type for.\n     * @param untypedNullArgument the argument to bind\n     */\n    public void setUntypedNullArgument(Argument untypedNullArgument) {\n        if (untypedNullArgument == null) {\n            throw new IllegalArgumentException(\"the Argument itself may not be null\");\n        }\n        this.untypedNullArgument = untypedNullArgument;\n    }\n\n    /**\n     * @return the untyped null argument\n     */\n    public Argument getUntypedNullArgument() {\n        return untypedNullArgument;\n    }\n\n    /**\n     * @return if binding {@code null} to a variable declared as a primitive type is allowed\n     */\n    public boolean isBindingNullToPrimitivesPermitted() {\n        return bindingNullToPrimitivesPermitted;\n    }\n\n    /**\n     * @param bindingNullToPrimitivesPermitted if binding {@code null} to a variable declared as a primitive type should be allowed\n     */\n    public void setBindingNullToPrimitivesPermitted(boolean bindingNullToPrimitivesPermitted) {\n        this.bindingNullToPrimitivesPermitted = bindingNullToPrimitivesPermitted;\n    }\n\n    @Override\n    public Arguments createCopy() {\n        return new Arguments(this);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.lang.reflect.Type;\nimport java.sql.Types;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.function.Function;\n\nimport org.jdbi.v3.core.array.SqlArrayArgumentFactory;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.JdbiConfig;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.meta.Beta;\n\n/**\n * A registry for ArgumentFactory instances.\n * When a statement with bound parameters is executed, Jdbi consults the\n * Arguments registry to obtain an Argument instance for each bound parameter\n * (see #findFor(...)).\n * The factories are consulted in reverse order of registration (i.e. last-registered wins).\n */\npublic class Arguments implements JdbiConfig<Arguments> {\n    private final List<QualifiedArgumentFactory> factories = new CopyOnWriteArrayList<>();\n    private final Map<QualifiedType<?>, Function<Object, Argument>> preparedFactories = new ConcurrentHashMap<>();\n    private final Set<QualifiedType<?>> didPrepare = ConcurrentHashMap.newKeySet();\n\n    private ConfigRegistry registry;\n    private Argument untypedNullArgument = new NullArgument(Types.OTHER);\n    private boolean bindingNullToPrimitivesPermitted = true;\n\n    public Arguments(ConfigRegistry registry) {\n        this.registry = registry;\n\n        // the null factory must be interrogated last to preserve types!\n        register(new UntypedNullArgumentFactory());\n\n        register(new PrimitivesArgumentFactory());\n        register(new BoxedArgumentFactory());\n        register(new SqlArgumentFactory());\n        register(new InternetArgumentFactory());\n        register(new SqlTimeArgumentFactory());\n        register(new JavaTimeArgumentFactory());\n        register(new SqlArrayArgumentFactory());\n        register(new EssentialsArgumentFactory());\n        register(new JavaTimeZoneIdArgumentFactory());\n        register(new NVarcharArgumentFactory());\n        register(new EnumArgumentFactory());\n        register(new OptionalArgumentFactory());\n        register(new DirectArgumentFactory());\n    }\n\n    @Override\n    public void setRegistry(ConfigRegistry registry) {\n        this.registry = registry;\n    }\n\n    private Arguments(Arguments that) {\n        factories.addAll(that.factories);\n        untypedNullArgument = that.untypedNullArgument;\n        bindingNullToPrimitivesPermitted = that.bindingNullToPrimitivesPermitted;\n    }\n\n    /**\n     * Registers the given argument factory.\n     * If more than one of the registered factories supports a given parameter type, the last-registered factory wins.\n     * @param factory the factory to add\n     * @return this\n     */\n    public Arguments register(ArgumentFactory factory) {\n        return register(QualifiedArgumentFactory.adapt(registry, factory));\n    }\n\n    /**\n     * Registers the given qualified argument factory.\n     * If more than one of the registered factories supports a given parameter type, the last-registered factory wins.\n     * @param factory the qualified factory to add\n     * @return this\n     */\n    @Beta\n    public Arguments register(QualifiedArgumentFactory factory) {\n        factories.add(0, factory);\n        return this;\n    }\n\n    /**\n     * Obtain an argument for given value in the given context\n     *\n     * @param type  the type of the argument.\n     * @param value the argument value.\n     * @return an Argument for the given value.\n     */\n    public Optional<Argument> findFor(Type type, Object value) {\n        return findFor(QualifiedType.of(type), value);\n    }\n\n    /**\n     * Obtain an argument for given value in the given context.\n     *\n     * @param type  the qualified type of the argument.\n     * @param value the argument value.\n     * @return an Argument for the given value.\n     */\n    @Beta\n    public Optional<Argument> findFor(QualifiedType<?> type, Object value) {\n        Function<Object, Argument> prepared = preparedFactories.get(type);\n        if (prepared != null) {\n            return Optional.of(prepared.apply(value));\n        }\n        for (QualifiedArgumentFactory factory : factories) {\n            Optional<Argument> maybeBuilt = factory.build(type, value, registry);\n            if (maybeBuilt.isPresent()) {\n                if (factory instanceof QualifiedArgumentFactory.Preparable && didPrepare.add(type)) {\n                    ((QualifiedArgumentFactory.Preparable) factory).prepare(type, registry)\n                            .ifPresent(argumentFactory -> preparedFactories.putIfAbsent(type, argumentFactory));\n                }\n                return maybeBuilt;\n            }\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Obtain a prepared argument function for given type in the given context.\n     *\n     * @param type  the type of the argument.\n     * @return an Argument factory function for the given value.\n     */\n    public Optional<Function<Object, Argument>> prepareFor(Type type) {\n        return prepareFor(QualifiedType.of(type));\n    }\n\n    /**\n     * Obtain a prepared argument function for given type in the given context.\n     *\n     * @param type  the qualified type of the argument.\n     * @return an Argument factory function for the given value.\n     */\n    @Beta\n    public Optional<Function<Object, Argument>> prepareFor(QualifiedType<?> type) {\n        Function<Object, Argument> prepared = preparedFactories.get(type);\n        if (prepared != null) {\n            return Optional.of(prepared);\n        }\n        for (QualifiedArgumentFactory factory : factories) {\n            if (factory instanceof QualifiedArgumentFactory.Preparable) {\n                Optional<Function<Object, Argument>> argumentFactory =\n                        ((QualifiedArgumentFactory.Preparable) factory).prepare(type, registry);\n                if (argumentFactory.isPresent()) {\n                    preparedFactories.putIfAbsent(type, argumentFactory.get());\n                    return argumentFactory;\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Beta\n    public List<QualifiedArgumentFactory> getFactories() {\n        return Collections.unmodifiableList(factories);\n    }\n\n    /**\n     * Configure the {@link Argument} to use when binding a null\n     * we don't have a type for.\n     * @param untypedNullArgument the argument to bind\n     */\n    public void setUntypedNullArgument(Argument untypedNullArgument) {\n        if (untypedNullArgument == null) {\n            throw new IllegalArgumentException(\"the Argument itself may not be null\");\n        }\n        this.untypedNullArgument = untypedNullArgument;\n    }\n\n    /**\n     * @return the untyped null argument\n     */\n    public Argument getUntypedNullArgument() {\n        return untypedNullArgument;\n    }\n\n    /**\n     * @return if binding {@code null} to a variable declared as a primitive type is allowed\n     */\n    public boolean isBindingNullToPrimitivesPermitted() {\n        return bindingNullToPrimitivesPermitted;\n    }\n\n    /**\n     * @param bindingNullToPrimitivesPermitted if binding {@code null} to a variable declared as a primitive type should be allowed\n     */\n    public void setBindingNullToPrimitivesPermitted(boolean bindingNullToPrimitivesPermitted) {\n        this.bindingNullToPrimitivesPermitted = bindingNullToPrimitivesPermitted;\n    }\n\n    @Override\n    public Arguments createCopy() {\n        return new Arguments(this);\n    }\n}\n","lineNo":128}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.transaction;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Savepoint;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleCallback;\n\n/**\n * This <code>TransactionHandler<\/code> uses local JDBC transactions\n * demarcated explicitly on the handle and passed through to be handled\n * directly on the JDBC Connection instance.\n */\npublic class LocalTransactionHandler implements TransactionHandler {\n    private final ConcurrentHashMap<Handle, LocalStuff> localStuff = new ConcurrentHashMap<>();\n    private final ThreadLocal<Boolean> didTxnRollback = ThreadLocal.withInitial(() -> false);\n\n    @Override\n    public void begin(Handle handle) {\n        try {\n            if (!localStuff.containsKey(handle)) {\n                boolean initial = handle.getConnection().getAutoCommit();\n                localStuff.putIfAbsent(handle, new LocalStuff(initial));\n                handle.getConnection().setAutoCommit(false);\n            }\n        } catch (SQLException e) {\n            throw new TransactionException(\"Failed to start transaction\", e);\n        }\n    }\n\n    @Override\n    public void commit(Handle handle) {\n        try {\n            handle.getConnection().commit();\n        } catch (SQLException e) {\n            throw new TransactionException(\"Failed to commit transaction\", e);\n        } finally {\n            restoreAutoCommitState(handle);\n        }\n    }\n\n    @Override\n    public void rollback(Handle handle) {\n        didTxnRollback.set(true);\n        try {\n            handle.getConnection().rollback();\n        } catch (SQLException e) {\n            throw new TransactionException(\"Failed to rollback transaction\", e);\n        } finally {\n            restoreAutoCommitState(handle);\n        }\n    }\n\n    @Override\n    public void savepoint(Handle handle, String name) {\n        @SuppressWarnings(\"PMD.CloseResource\")\n        final Connection conn = handle.getConnection();\n        try {\n            final Savepoint savepoint = conn.setSavepoint(name);\n            localStuff.get(handle).getSavepoints().put(name, savepoint);\n        } catch (SQLException e) {\n            throw new TransactionException(String.format(\"Unable to create savepoint '%s'\", name), e);\n        }\n    }\n\n    @Override\n    public void releaseSavepoint(Handle handle, String name) {\n        @SuppressWarnings(\"PMD.CloseResource\")\n        final Connection conn = handle.getConnection();\n        try {\n            final Savepoint savepoint = localStuff.get(handle).getSavepoints().remove(name);\n            if (savepoint == null) {\n                throw new TransactionException(String.format(\"Attempt to release non-existent savepoint, '%s'\",\n                                                             name));\n            }\n            conn.releaseSavepoint(savepoint);\n        } catch (SQLException e) {\n            throw new TransactionException(String.format(\"Unable to create savepoint %s\", name), e);\n        }\n    }\n\n    @Override\n    public void rollbackToSavepoint(Handle handle, String name) {\n        @SuppressWarnings(\"PMD.CloseResource\")\n        final Connection conn = handle.getConnection();\n        try {\n            final Savepoint savepoint = localStuff.get(handle).getSavepoints().remove(name);\n            if (savepoint == null) {\n                throw new TransactionException(String.format(\"Attempt to rollback to non-existent savepoint, '%s'\",\n                                                             name));\n            }\n            conn.rollback(savepoint);\n        } catch (SQLException e) {\n            throw new TransactionException(String.format(\"Unable to create savepoint %s\", name), e);\n        }\n    }\n\n    @Override\n    public boolean isInTransaction(Handle handle) {\n        try {\n            return !handle.getConnection().getAutoCommit();\n        } catch (SQLException e) {\n            throw new TransactionException(\"Failed to test for transaction status\", e);\n        }\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle,\n                                                    HandleCallback<R, X> callback) throws X {\n        if (isInTransaction(handle)) {\n            throw new IllegalStateException(\"Already in transaction\");\n        }\n        didTxnRollback.set(false);\n        final R returnValue;\n        try {\n            handle.begin();\n            returnValue = callback.withHandle(handle);\n            if (!didTxnRollback.get()) {\n                handle.commit();\n            }\n        } catch (Throwable e) {\n            try {\n                handle.rollback();\n            } catch (Exception rollback) {\n                e.addSuppressed(rollback);\n            }\n            throw e;\n        }\n\n        didTxnRollback.remove();\n        return returnValue;\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle,\n                                                    TransactionIsolationLevel level,\n                                                    HandleCallback<R, X> callback) throws X {\n        final TransactionIsolationLevel initial = handle.getTransactionIsolationLevel();\n        try {\n            handle.setTransactionIsolation(level);\n            return inTransaction(handle, callback);\n        } finally {\n            handle.setTransactionIsolation(initial);\n        }\n    }\n\n    private void restoreAutoCommitState(final Handle handle) {\n        try {\n            final LocalStuff stuff = localStuff.remove(handle);\n            if (stuff != null) {\n                handle.getConnection().setAutoCommit(stuff.getInitialAutocommit());\n                stuff.getSavepoints().clear();\n            }\n        } catch (SQLException e) {\n            throw new UnableToRestoreAutoCommitStateException(e);\n        } finally {\n            // prevent memory leak if rollback throws an exception\n            localStuff.remove(handle);\n        }\n    }\n\n    private static class LocalStuff {\n        private final Map<String, Savepoint> savepoints = new HashMap<>();\n        private final boolean initialAutocommit;\n\n        LocalStuff(boolean initial) {\n            this.initialAutocommit = initial;\n        }\n\n        Map<String, Savepoint> getSavepoints() {\n            return savepoints;\n        }\n\n        boolean getInitialAutocommit() {\n            return initialAutocommit;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.transaction;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Savepoint;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\n\n/**\n * This <code>TransactionHandler<\/code> uses local JDBC transactions\n * demarcated explicitly on the handle and passed through to be handled\n * directly on the JDBC Connection instance.\n */\npublic class LocalTransactionHandler implements TransactionHandler {\n    private final Map<Handle, BoundLocalTransactionHandler> bound = Collections.synchronizedMap(new WeakHashMap<>());\n\n    @Override\n    public void begin(Handle handle) {\n        nonspecial(handle).begin(handle);\n    }\n\n    @Override\n    public void commit(Handle handle) {\n        nonspecial(handle).commit(handle);\n    }\n\n    @Override\n    public void rollback(Handle handle) {\n        nonspecial(handle).rollback(handle);\n    }\n\n    @Override\n    public boolean isInTransaction(Handle handle) {\n        return nonspecial(handle).isInTransaction(handle);\n    }\n\n    @Override\n    public void savepoint(Handle handle, String savepointName) {\n        nonspecial(handle).savepoint(handle, savepointName);\n    }\n\n    @Override\n    public void rollbackToSavepoint(Handle handle, String savepointName) {\n        nonspecial(handle).rollbackToSavepoint(handle, savepointName);\n    }\n\n    @Override\n    public void releaseSavepoint(Handle handle, String savepointName) {\n        nonspecial(handle).releaseSavepoint(handle, savepointName);\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle, HandleCallback<R, X> callback) throws X {\n        return nonspecial(handle).inTransaction(handle, callback);\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle, TransactionIsolationLevel level, HandleCallback<R, X> callback) throws X {\n        return nonspecial(handle).inTransaction(handle, level, callback);\n    }\n\n    TransactionHandler nonspecial(Handle handle) {\n        return bound.computeIfAbsent(handle, Unchecked.function(BoundLocalTransactionHandler::new));\n    }\n\n    public static LocalTransactionHandler binding() {\n        return new BindingLocalTransactionHandler();\n    }\n\n    static class BindingLocalTransactionHandler extends LocalTransactionHandler {\n        @Override\n        public TransactionHandler specialize(Handle handle) throws SQLException {\n            return new BoundLocalTransactionHandler(handle);\n        }\n    }\n\n    static class BoundLocalTransactionHandler implements TransactionHandler {\n        private final Map<String, Savepoint> savepoints = new HashMap<>();\n        private boolean initialAutocommit;\n        private boolean didBegin;\n        private boolean didTxnRollback;\n\n        BoundLocalTransactionHandler(Handle handle) throws SQLException {\n            this.initialAutocommit = handle.getConnection().getAutoCommit();\n        }\n\n        @Override\n        public void begin(Handle handle) {\n            try {\n                if (!didBegin) {\n                    Connection conn = handle.getConnection(); // NOPMD\n                    initialAutocommit = conn.getAutoCommit();\n                    didTxnRollback = false;\n                    savepoints.clear();\n                    conn.setAutoCommit(false);\n                    didBegin = true;\n                }\n            } catch (SQLException e) {\n                throw new TransactionException(\"Failed to start transaction\", e);\n            }\n        }\n\n        @Override\n        public void commit(Handle handle) {\n            try {\n                handle.getConnection().commit();\n            } catch (SQLException e) {\n                throw new TransactionException(\"Failed to commit transaction\", e);\n            } finally {\n                restoreAutoCommitState(handle);\n            }\n        }\n\n        @Override\n        public void rollback(Handle handle) {\n            didTxnRollback = true;\n            try {\n                handle.getConnection().rollback();\n            } catch (SQLException e) {\n                throw new TransactionException(\"Failed to rollback transaction\", e);\n            } finally {\n                restoreAutoCommitState(handle);\n            }\n        }\n\n        @Override\n        public void savepoint(Handle handle, String name) {\n            @SuppressWarnings(\"PMD.CloseResource\")\n            final Connection conn = handle.getConnection();\n            try {\n                final Savepoint savepoint = conn.setSavepoint(name);\n                savepoints.put(name, savepoint);\n            } catch (SQLException e) {\n                throw new TransactionException(String.format(\"Unable to create savepoint '%s'\", name), e);\n            }\n        }\n\n        @Override\n        public void releaseSavepoint(Handle handle, String name) {\n            @SuppressWarnings(\"PMD.CloseResource\")\n            final Connection conn = handle.getConnection();\n            try {\n                final Savepoint savepoint = savepoints.remove(name);\n                if (savepoint == null) {\n                    throw new TransactionException(String.format(\"Attempt to release non-existent savepoint, '%s'\",\n                                                                 name));\n                }\n                conn.releaseSavepoint(savepoint);\n            } catch (SQLException e) {\n                throw new TransactionException(String.format(\"Unable to create savepoint %s\", name), e);\n            }\n        }\n\n        @Override\n        public void rollbackToSavepoint(Handle handle, String name) {\n            @SuppressWarnings(\"PMD.CloseResource\")\n            final Connection conn = handle.getConnection();\n            try {\n                final Savepoint savepoint = savepoints.remove(name);\n                if (savepoint == null) {\n                    throw new TransactionException(String.format(\"Attempt to rollback to non-existent savepoint, '%s'\",\n                                                                 name));\n                }\n                conn.rollback(savepoint);\n            } catch (SQLException e) {\n                throw new TransactionException(String.format(\"Unable to create savepoint %s\", name), e);\n            }\n        }\n\n        @Override\n        public boolean isInTransaction(Handle handle) {\n            try {\n                return !handle.getConnection().getAutoCommit();\n            } catch (SQLException e) {\n                throw new TransactionException(\"Failed to test for transaction status\", e);\n            }\n        }\n\n        @Override\n        public <R, X extends Exception> R inTransaction(Handle handle,\n                                                        HandleCallback<R, X> callback) throws X {\n            if (isInTransaction(handle)) {\n                throw new IllegalStateException(\"Already in transaction\");\n            }\n            didTxnRollback = false;\n            final R returnValue;\n            try {\n                handle.begin();\n                returnValue = callback.withHandle(handle);\n                if (!didTxnRollback) {\n                    handle.commit();\n                }\n            } catch (Throwable e) {\n                try {\n                    handle.rollback();\n                } catch (Exception rollback) {\n                    e.addSuppressed(rollback);\n                }\n                throw e;\n            } finally {\n                didTxnRollback = false;\n            }\n\n            return returnValue;\n        }\n\n        @Override\n        public <R, X extends Exception> R inTransaction(Handle handle,\n                                                        TransactionIsolationLevel level,\n                                                        HandleCallback<R, X> callback) throws X {\n            final TransactionIsolationLevel initial = handle.getTransactionIsolationLevel();\n            try {\n                handle.setTransactionIsolation(level);\n                return inTransaction(handle, callback);\n            } finally {\n                handle.setTransactionIsolation(initial);\n            }\n        }\n\n        private void restoreAutoCommitState(Handle handle) {\n            try {\n                if (initialAutocommit) {\n                    handle.getConnection().setAutoCommit(initialAutocommit);\n                    savepoints.clear();\n                    didBegin = false;\n                }\n            } catch (SQLException e) {\n                throw new UnableToRestoreAutoCommitStateException(e);\n            }\n        }\n    }\n}\n","lineNo":110}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.postgres;\n\nimport java.util.Map;\nimport java.util.UUID;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.argument.ArgumentFactory;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.postgres.internal.BitStringEnumSetArgumentFactory;\nimport org.jdbi.v3.postgres.internal.BitStringEnumSetMapperFactory;\nimport org.postgresql.PGConnection;\nimport org.postgresql.geometric.PGbox;\nimport org.postgresql.geometric.PGcircle;\nimport org.postgresql.geometric.PGline;\nimport org.postgresql.geometric.PGlseg;\nimport org.postgresql.geometric.PGpath;\nimport org.postgresql.geometric.PGpoint;\nimport org.postgresql.geometric.PGpolygon;\nimport org.postgresql.util.PGInterval;\nimport org.postgresql.util.PGmoney;\n\n/**\n * Postgres plugin. Adds support for binding and mapping the following data types:\n *\n * <ul>\n * <li>{@link java.net.InetAddress} (including {@link java.net.Inet4Address} and {@link java.net.Inet6Address})<\/li>\n * <li>{@link java.time.LocalDate}<\/li>\n * <li>{@link java.time.LocalTime}<\/li>\n * <li>{@link java.time.LocalDateTime}<\/li>\n * <li>{@link java.time.OffsetDateTime}<\/li>\n * <li>{@link java.time.Duration} (see notes below)<\/li>\n * <li>{@link java.time.Period} (see notes below)<\/li>\n * <li>{@link java.util.Map Map&lt;String, String&gt;} (for {@code HSTORE} columns)<\/li>\n * <li>{@link java.util.UUID}<\/li>\n * <\/ul>\n *\n * <p>\n * The following qualified types have {@link org.jdbi.v3.meta.Beta} support for binding and mapping:\n *\n * <ul>\n * <li>{@link MacAddr @MacAddr java.lang.String} (for MACADDR columns)<\/li>\n * <li>{@link HStore @HStore Map&lt;String, String&gt;} (for HSTORE columns)<\/li>\n * <\/ul>\n *\n * <p>\n * Also sets up SQL array support for the following types:\n *\n * <ul>\n * <li>{@code double}<\/li>\n * <li>{@code float}<\/li>\n * <li>{@code int}<\/li>\n * <li>{@code long}<\/li>\n * <li>{@link java.lang.Double}<\/li>\n * <li>{@link java.lang.Float}<\/li>\n * <li>{@link java.lang.Integer}<\/li>\n * <li>{@link java.lang.Long}<\/li>\n * <li>{@link java.lang.String}<\/li>\n * <li>{@link java.util.UUID}<\/li>\n * <\/ul>\n *\n * <p>\n * A note about the mapping between the Postgres {@code interval} type and the Java {@link java.time.Period} and\n * {@link java.time.Duration} types:\n * The Java library authors are much more strict about the temporal amounts representable by Periods and Durations than\n * Postgres is with its {@code interval} type.  The argument factories and column mapper factories implemented in this\n * package respect this spirit of unambiguous strictness.  Consequently:\n * <ul>\n *     <li>All {@link java.time.Period}s can be mapped to {@code interval}s.<\/li>\n *     <li>Not all {@link java.time.Duration}s can be mapped to {@code interval}s.<\/li>\n *     <li>Not all {@code interval}s can be mapped to {@link java.time.Period}s.<\/li>\n *     <li>Not all {@code interval}s can be mapped to {@link java.time.Duration}s.<\/li>\n * <\/ul>\n * For more specific detail, see the caveats in the documentation for {@link DurationArgumentFactory},\n * {@link PeriodColumnMapperFactory}, and {@link DurationColumnMapperFactory}.\n *\n * <p>\n * In addition, some potentially unexpected implicit conversions can occur by virtue of the Postgres <em>server<\/em>\n * logic. For example, at the time of writing, storing a Period of -3 years, 2 months, and -1 days results in an\n * interval (and consequently, a column-mapped Period) of <em>-2 years, -10 months<\/em>, and -1 days.\n */\npublic class PostgresPlugin extends JdbiPlugin.Singleton {\n    @Override\n    public void customizeJdbi(Jdbi jdbi) {\n        jdbi.registerArgument(new TypedEnumArgumentFactory());\n        jdbi.registerArgument(new JavaTimeArgumentFactory());\n        jdbi.registerArgument(new DurationArgumentFactory());\n        jdbi.registerArgument(new PeriodArgumentFactory());\n        jdbi.registerArgument(new InetArgumentFactory());\n        jdbi.registerArgument(new HStoreArgumentFactory());\n        jdbi.registerArgument(new MacAddrArgumentFactory());\n        jdbi.registerArgument(new UUIDArgumentFactory());\n        jdbi.registerArgument(new PGobjectArgumentFactory());\n        jdbi.registerArgument(new BitStringEnumSetArgumentFactory());\n\n        jdbi.registerArrayType(int.class, \"integer\");\n        jdbi.registerArrayType(Integer.class, \"integer\");\n        jdbi.registerArrayType(long.class, \"bigint\");\n        jdbi.registerArrayType(Long.class, \"bigint\");\n        jdbi.registerArrayType(String.class, \"varchar\");\n        jdbi.registerArrayType(UUID.class, \"uuid\");\n        jdbi.registerArrayType(float.class, \"float4\");\n        jdbi.registerArrayType(Float.class, \"float4\");\n        jdbi.registerArrayType(double.class, \"float8\");\n        jdbi.registerArrayType(Double.class, \"float8\");\n\n        // built-in PGobject types\n        jdbi.registerArrayType(PGbox.class, \"box\");\n        jdbi.registerArrayType(PGcircle.class, \"circle\");\n        jdbi.registerArrayType(PGInterval.class, \"interval\");\n        jdbi.registerArrayType(PGline.class, \"line\");\n        jdbi.registerArrayType(PGlseg.class, \"lseg\");\n        jdbi.registerArrayType(PGmoney.class, \"money\");\n        jdbi.registerArrayType(PGpath.class, \"path\");\n        jdbi.registerArrayType(PGpoint.class, \"point\");\n        jdbi.registerArrayType(PGpolygon.class, \"polygon\");\n\n        jdbi.registerColumnMapper(new JavaTimeMapperFactory());\n        jdbi.registerColumnMapper(new HStoreColumnMapper());\n        jdbi.registerColumnMapper(new MacAddrColumnMapper());\n        jdbi.registerColumnMapper(new DurationColumnMapperFactory());\n        jdbi.registerColumnMapper(new PeriodColumnMapperFactory());\n        jdbi.registerColumnMapper(new PGobjectColumnMapperFactory());\n        jdbi.registerColumnMapper(new BitStringEnumSetMapperFactory());\n\n        // legacy unqualified HSTORE\n        jdbi.registerArgument((ArgumentFactory) new HStoreArgumentFactory()::build);\n        jdbi.registerColumnMapper(new GenericType<Map<String, String>>() {}, new HStoreColumnMapper());\n\n        // optional integration\n        if (JdbiClassUtils.isPresent(\"org.jdbi.v3.json.JsonConfig\")) {\n            jdbi.registerArgument(new JsonArgumentFactory());\n        }\n    }\n\n    @Override\n    public Handle customizeHandle(Handle handle) {\n        PGConnection pgConnection = Unchecked.supplier(() -> handle.getConnection().unwrap(PGConnection.class)).get();\n        return handle.configure(PostgresTypes.class, pt -> pt.addTypesToConnection(pgConnection));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.postgres;\n\nimport java.sql.Connection;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.argument.ArgumentFactory;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.internal.JdbiClassUtils;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\nimport org.jdbi.v3.postgres.internal.BitStringEnumSetArgumentFactory;\nimport org.jdbi.v3.postgres.internal.BitStringEnumSetMapperFactory;\nimport org.postgresql.PGConnection;\nimport org.postgresql.geometric.PGbox;\nimport org.postgresql.geometric.PGcircle;\nimport org.postgresql.geometric.PGline;\nimport org.postgresql.geometric.PGlseg;\nimport org.postgresql.geometric.PGpath;\nimport org.postgresql.geometric.PGpoint;\nimport org.postgresql.geometric.PGpolygon;\nimport org.postgresql.util.PGInterval;\nimport org.postgresql.util.PGmoney;\n\n/**\n * Postgres plugin. Adds support for binding and mapping the following data types:\n *\n * <ul>\n * <li>{@link java.net.InetAddress} (including {@link java.net.Inet4Address} and {@link java.net.Inet6Address})<\/li>\n * <li>{@link java.time.LocalDate}<\/li>\n * <li>{@link java.time.LocalTime}<\/li>\n * <li>{@link java.time.LocalDateTime}<\/li>\n * <li>{@link java.time.OffsetDateTime}<\/li>\n * <li>{@link java.time.Duration} (see notes below)<\/li>\n * <li>{@link java.time.Period} (see notes below)<\/li>\n * <li>{@link java.util.Map Map&lt;String, String&gt;} (for {@code HSTORE} columns)<\/li>\n * <li>{@link java.util.UUID}<\/li>\n * <li>{@link java.io.InputStream} and {@link java.io.Reader} from {@code oid} large object columns<\/li>\n * <\/ul>\n *\n * <p>\n * The following qualified types have {@link org.jdbi.v3.meta.Beta} support for binding and mapping:\n *\n * <ul>\n * <li>{@link MacAddr @MacAddr java.lang.String} (for MACADDR columns)<\/li>\n * <li>{@link HStore @HStore Map&lt;String, String&gt;} (for HSTORE columns)<\/li>\n * <\/ul>\n *\n * <p>\n * Also sets up SQL array support for the following types:\n *\n * <ul>\n * <li>{@code double}<\/li>\n * <li>{@code float}<\/li>\n * <li>{@code int}<\/li>\n * <li>{@code long}<\/li>\n * <li>{@link java.lang.Double}<\/li>\n * <li>{@link java.lang.Float}<\/li>\n * <li>{@link java.lang.Integer}<\/li>\n * <li>{@link java.lang.Long}<\/li>\n * <li>{@link java.lang.String}<\/li>\n * <li>{@link java.util.UUID}<\/li>\n * <\/ul>\n *\n * <p>\n * A note about the mapping between the Postgres {@code interval} type and the Java {@link java.time.Period} and\n * {@link java.time.Duration} types:\n * The Java library authors are much more strict about the temporal amounts representable by Periods and Durations than\n * Postgres is with its {@code interval} type.  The argument factories and column mapper factories implemented in this\n * package respect this spirit of unambiguous strictness.  Consequently:\n * <ul>\n *     <li>All {@link java.time.Period}s can be mapped to {@code interval}s.<\/li>\n *     <li>Not all {@link java.time.Duration}s can be mapped to {@code interval}s.<\/li>\n *     <li>Not all {@code interval}s can be mapped to {@link java.time.Period}s.<\/li>\n *     <li>Not all {@code interval}s can be mapped to {@link java.time.Duration}s.<\/li>\n * <\/ul>\n * For more specific detail, see the caveats in the documentation for {@link DurationArgumentFactory},\n * {@link PeriodColumnMapperFactory}, and {@link DurationColumnMapperFactory}.\n *\n * <p>\n * In addition, some potentially unexpected implicit conversions can occur by virtue of the Postgres <em>server<\/em>\n * logic. For example, at the time of writing, storing a Period of -3 years, 2 months, and -1 days results in an\n * interval (and consequently, a column-mapped Period) of <em>-2 years, -10 months<\/em>, and -1 days.\n */\npublic class PostgresPlugin extends JdbiPlugin.Singleton {\n    @Override\n    public void customizeJdbi(Jdbi jdbi) {\n        jdbi.registerArgument(new TypedEnumArgumentFactory());\n        jdbi.registerArgument(new JavaTimeArgumentFactory());\n        jdbi.registerArgument(new DurationArgumentFactory());\n        jdbi.registerArgument(new PeriodArgumentFactory());\n        jdbi.registerArgument(new InetArgumentFactory());\n        jdbi.registerArgument(new HStoreArgumentFactory());\n        jdbi.registerArgument(new MacAddrArgumentFactory());\n        jdbi.registerArgument(new UUIDArgumentFactory());\n        jdbi.registerArgument(new PGobjectArgumentFactory());\n        jdbi.registerArgument(new BitStringEnumSetArgumentFactory());\n        jdbi.registerArgument(new BlobInputStreamArgumentFactory());\n        jdbi.registerArgument(new ClobReaderArgumentFactory());\n\n        jdbi.registerArrayType(int.class, \"integer\");\n        jdbi.registerArrayType(Integer.class, \"integer\");\n        jdbi.registerArrayType(long.class, \"bigint\");\n        jdbi.registerArrayType(Long.class, \"bigint\");\n        jdbi.registerArrayType(String.class, \"varchar\");\n        jdbi.registerArrayType(UUID.class, \"uuid\");\n        jdbi.registerArrayType(float.class, \"float4\");\n        jdbi.registerArrayType(Float.class, \"float4\");\n        jdbi.registerArrayType(double.class, \"float8\");\n        jdbi.registerArrayType(Double.class, \"float8\");\n\n        // built-in PGobject types\n        jdbi.registerArrayType(PGbox.class, \"box\");\n        jdbi.registerArrayType(PGcircle.class, \"circle\");\n        jdbi.registerArrayType(PGInterval.class, \"interval\");\n        jdbi.registerArrayType(PGline.class, \"line\");\n        jdbi.registerArrayType(PGlseg.class, \"lseg\");\n        jdbi.registerArrayType(PGmoney.class, \"money\");\n        jdbi.registerArrayType(PGpath.class, \"path\");\n        jdbi.registerArrayType(PGpoint.class, \"point\");\n        jdbi.registerArrayType(PGpolygon.class, \"polygon\");\n\n        jdbi.registerColumnMapper(new JavaTimeMapperFactory());\n        jdbi.registerColumnMapper(new HStoreColumnMapper());\n        jdbi.registerColumnMapper(new MacAddrColumnMapper());\n        jdbi.registerColumnMapper(new DurationColumnMapperFactory());\n        jdbi.registerColumnMapper(new PeriodColumnMapperFactory());\n        jdbi.registerColumnMapper(new PGobjectColumnMapperFactory());\n        jdbi.registerColumnMapper(new BitStringEnumSetMapperFactory());\n        jdbi.registerColumnMapper(new BlobInputStreamColumnMapperFactory());\n        jdbi.registerColumnMapper(new ClobReaderColumnMapperFactory());\n\n        // legacy unqualified HSTORE\n        jdbi.registerArgument((ArgumentFactory) new HStoreArgumentFactory()::build);\n        jdbi.registerColumnMapper(new GenericType<Map<String, String>>() {}, new HStoreColumnMapper());\n\n        // optional integration\n        if (JdbiClassUtils.isPresent(\"org.jdbi.v3.json.JsonConfig\")) {\n            jdbi.registerArgument(new JsonArgumentFactory());\n        }\n    }\n\n    @Override\n    @SuppressWarnings(\"PMD.CloseResource\")\n    public Handle customizeHandle(Handle handle) {\n        Connection conn = handle.getConnection();\n        PGConnection pgConnection = Unchecked.supplier(() -> conn.unwrap(PGConnection.class)).get();\n        return handle.configure(PostgresTypes.class, pt -> {\n            pt.addTypesToConnection(pgConnection);\n            pt.setLobApi(new PgLobApiImpl(conn));\n        });\n    }\n}\n","lineNo":161}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.postgres;\n\nimport java.util.EnumSet;\nimport java.util.List;\n\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.jdbi.v3.sqlobject.SingleValue;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.testing.JdbiRule;\nimport org.junit.Before;\nimport org.junit.ClassRule;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestEnumSets {\n    private static final GenericType<EnumSet<Platform>> PLATFORM_SET = new GenericType<EnumSet<Platform>>() {};\n\n    // postgres is kinda slow so this test is set up to reuse a single instance\n    @ClassRule\n    public static JdbiRule db = PostgresDbRule.rule();\n\n    private VideoDao videoDao;\n\n    @Before\n    public void setupDbi() {\n        db.getHandle().useTransaction(h -> {\n            h.execute(\"drop table if exists videos\");\n            h.execute(\"create table videos (id int primary key, supported_platforms bit(5))\");\n\n            PreparedBatch batch = h.prepareBatch(\"insert into videos(id, supported_platforms) values (:id,:supported_platforms::varbit)\");\n            batch\n                .bind(\"id\", 0)\n                .bindByType(\"supported_platforms\", EnumSet.of(Platform.IOS, Platform.ANDROID, Platform.WEB), PLATFORM_SET)\n                .add();\n            batch\n                .bind(\"id\", 1)\n                .bindByType(\"supported_platforms\", EnumSet.of(Platform.SMART_TV), PLATFORM_SET)\n                .add();\n            batch\n                .bind(\"id\", 2)\n                .bindByType(\"supported_platforms\", EnumSet.of(Platform.ANDROID, Platform.STB), PLATFORM_SET)\n                .add();\n            batch\n                .bind(\"id\", 3)\n                .bindByType(\"supported_platforms\", EnumSet.of(Platform.IOS, Platform.WEB), PLATFORM_SET)\n                .add();\n            batch\n                .bind(\"id\", 4)\n                .bindByType(\"supported_platforms\", EnumSet.noneOf(Platform.class), PLATFORM_SET)\n                .add();\n            batch\n                .bind(\"id\", 5)\n                .bindByType(\"supported_platforms\", null, PLATFORM_SET)\n                .add();\n            batch.execute();\n        });\n\n        videoDao = db.getHandle().attach(VideoDao.class);\n    }\n\n    @Test\n    public void testInserts() {\n        videoDao.insert(6, EnumSet.of(Platform.IOS, Platform.ANDROID));\n        assertThat(getSupportedPlatforms(6)).containsExactly(Platform.ANDROID, Platform.IOS);\n    }\n\n    @Test\n    public void testInsertsEmpty() {\n        videoDao.insert(7, EnumSet.noneOf(Platform.class));\n        assertThat(getSupportedPlatforms(7)).isEmpty();\n    }\n\n    @Test\n    public void testInsertsNull() {\n        videoDao.insert(8, null);\n        assertThat(getSupportedPlatforms(8)).isNull();\n    }\n\n    @Test\n    public void testReads() {\n        EnumSet<Platform> supportedPlatforms = videoDao.getSupportedPlatforms(0);\n        assertThat(supportedPlatforms).containsOnly(Platform.ANDROID, Platform.IOS, Platform.WEB);\n    }\n\n    @Test\n    public void testReadsEmpty() {\n        EnumSet<Platform> supportedPlatforms = videoDao.getSupportedPlatforms(4);\n        assertThat(supportedPlatforms).isEmpty();\n    }\n\n    @Test\n    public void testReadsNull() {\n        EnumSet<Platform> supportedPlatforms = videoDao.getSupportedPlatforms(5);\n        assertThat(supportedPlatforms).isNull();\n    }\n\n    @Test\n    public void testBitwiseWorksForNoneElements() {\n        List<Integer> notNullVideos = videoDao.getSupportedVideosOnPlatforms(EnumSet.noneOf(Platform.class));\n        assertThat(notNullVideos).containsExactly(0, 1, 2, 3, 4);\n    }\n\n    @Test\n    public void testBitwiseWorksForOneElement() {\n        List<Integer> stbVideos = videoDao.getSupportedVideosOnPlatforms(EnumSet.of(Platform.STB));\n        assertThat(stbVideos).containsOnlyOnce(2);\n    }\n\n    @Test\n    public void testBitwiseWorksForSeveralElements() {\n        List<Integer> webIosVideos = videoDao.getSupportedVideosOnPlatforms(EnumSet.of(Platform.WEB, Platform.IOS));\n        assertThat(webIosVideos).containsExactly(0, 3);\n    }\n\n    @Test\n    public void testBitwiseAdditionWorks() {\n        videoDao.addPlatforms(1, EnumSet.of(Platform.IOS, Platform.ANDROID));\n        EnumSet<Platform> supportedPlatforms = getSupportedPlatforms(1);\n        assertThat(supportedPlatforms).containsExactly(Platform.ANDROID, Platform.IOS, Platform.SMART_TV);\n    }\n\n    @Test\n    public void testBitwiseRemovingWorks() {\n        videoDao.removePlatforms(0, EnumSet.of(Platform.IOS, Platform.ANDROID, Platform.SMART_TV));\n        EnumSet<Platform> supportedPlatforms = getSupportedPlatforms(0);\n        assertThat(supportedPlatforms).containsOnlyOnce(Platform.WEB);\n    }\n\n    @Test\n    public void testAmountPlatforms() {\n        int amount = videoDao.getAmountOfSupportedPlatforms(0);\n        assertThat(amount).isEqualTo(3);\n    }\n\n    @Test\n    public void throwsOnNonBitChars() {\n        db.getHandle().useTransaction(handle -> {\n            // redefine column to varchar type\n            handle.execute(\"drop table if exists videos\");\n            handle.execute(\"create table videos (id int primary key, supported_platforms varchar)\");\n\n            // insert wrong bitstring\n            int id = 1;\n            String notBit = \"2\";\n            handle.createUpdate(\"insert into videos(id, supported_platforms) values (:id, :notBits)\")\n                .bind(\"id\", id)\n                .bind(\"notBits\", \"0101\" + notBit)\n                .execute();\n\n            assertThatThrownBy(() -> handle.attach(VideoDao.class).getSupportedPlatforms(id))\n                .hasMessageContaining(\"non-bit character \" + notBit);\n        });\n    }\n\n    private EnumSet<Platform> getSupportedPlatforms(int id) {\n        return db.getHandle()\n            .createQuery(\"select supported_platforms from videos where id=:id\")\n            .bind(\"id\", id)\n            .mapTo(PLATFORM_SET)\n            .one();\n    }\n\n    public interface VideoDao {\n\n        @SqlUpdate(\"insert into videos(id, supported_platforms) values (:id, :platforms::varbit)\")\n        void insert(int id, EnumSet<Platform> platforms);\n\n        @SqlQuery(\"select supported_platforms from videos where id=:id\")\n        @SingleValue\n        EnumSet<Platform> getSupportedPlatforms(int id);\n\n        @SqlQuery(\"select id from videos \"\n            + \"where (supported_platforms & :platforms::varbit) = :platforms::varbit \"\n            + \"order by id\")\n        List<Integer> getSupportedVideosOnPlatforms(EnumSet<Platform> platforms);\n\n        @SqlUpdate(\"update videos \"\n            + \"set supported_platforms = (supported_platforms | :platforms::varbit) \"\n            + \"where id=:id\")\n        void addPlatforms(int id, EnumSet<Platform> platforms);\n\n        @SqlUpdate(\"update videos \"\n            + \"set supported_platforms = (supported_platforms & ~:platforms::varbit) \"\n            + \"where id=:id\")\n        void removePlatforms(int id, EnumSet<Platform> platforms);\n\n        @SqlQuery(\"select length(replace(supported_platforms::varchar, '0', '')) from videos \"\n            + \"where id=:id\")\n        int getAmountOfSupportedPlatforms(int id);\n    }\n\n    public enum Platform {\n        ANDROID,\n        IOS,\n        SMART_TV,\n        STB,\n        WEB\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.postgres;\n\nimport java.util.EnumSet;\nimport java.util.List;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.jdbi.v3.sqlobject.SingleValue;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.testing.JdbiRule;\nimport org.junit.Before;\nimport org.junit.ClassRule;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestEnumSets {\n    private static final GenericType<EnumSet<Platform>> PLATFORM_SET = new GenericType<EnumSet<Platform>>() {};\n\n    // postgres is kinda slow so this test is set up to reuse a single instance\n    @ClassRule\n    public static JdbiRule db = PostgresDbRule.rule();\n\n    private VideoDao videoDao;\n\n    @Before\n    public void setupDbi() {\n        db.getHandle().useTransaction(h -> {\n            h.execute(\"drop table if exists videos\");\n            h.execute(\"create table videos (id int primary key, supported_platforms bit(5))\");\n\n            PreparedBatch batch = h.prepareBatch(\"insert into videos(id, supported_platforms) values (:id,:supported_platforms::varbit)\");\n            batch\n                .bind(\"id\", 0)\n                .bindByType(\"supported_platforms\", EnumSet.of(Platform.IOS, Platform.ANDROID, Platform.WEB), PLATFORM_SET)\n                .add();\n            batch\n                .bind(\"id\", 1)\n                .bindByType(\"supported_platforms\", EnumSet.of(Platform.SMART_TV), PLATFORM_SET)\n                .add();\n            batch\n                .bind(\"id\", 2)\n                .bindByType(\"supported_platforms\", EnumSet.of(Platform.ANDROID, Platform.STB), PLATFORM_SET)\n                .add();\n            batch\n                .bind(\"id\", 3)\n                .bindByType(\"supported_platforms\", EnumSet.of(Platform.IOS, Platform.WEB), PLATFORM_SET)\n                .add();\n            batch\n                .bind(\"id\", 4)\n                .bindByType(\"supported_platforms\", EnumSet.noneOf(Platform.class), PLATFORM_SET)\n                .add();\n            batch\n                .bind(\"id\", 5)\n                .bindByType(\"supported_platforms\", null, PLATFORM_SET)\n                .add();\n            batch.execute();\n        });\n\n        videoDao = db.getHandle().attach(VideoDao.class);\n    }\n\n    @Test\n    public void testInserts() {\n        videoDao.insert(6, EnumSet.of(Platform.IOS, Platform.ANDROID));\n        assertThat(getSupportedPlatforms(6)).containsExactly(Platform.ANDROID, Platform.IOS);\n    }\n\n    @Test\n    public void testInsertsEmpty() {\n        videoDao.insert(7, EnumSet.noneOf(Platform.class));\n        assertThat(getSupportedPlatforms(7)).isEmpty();\n    }\n\n    @Test\n    public void testInsertsNull() {\n        videoDao.insert(8, null);\n        assertThat(getSupportedPlatforms(8)).isNull();\n    }\n\n    @Test\n    public void testReads() {\n        EnumSet<Platform> supportedPlatforms = videoDao.getSupportedPlatforms(0);\n        assertThat(supportedPlatforms).containsOnly(Platform.ANDROID, Platform.IOS, Platform.WEB);\n    }\n\n    @Test\n    public void testReadsEmpty() {\n        EnumSet<Platform> supportedPlatforms = videoDao.getSupportedPlatforms(4);\n        assertThat(supportedPlatforms).isEmpty();\n    }\n\n    @Test\n    public void testReadsNull() {\n        EnumSet<Platform> supportedPlatforms = videoDao.getSupportedPlatforms(5);\n        assertThat(supportedPlatforms).isNull();\n    }\n\n    @Test\n    public void testBitwiseWorksForNoneElements() {\n        List<Integer> notNullVideos = videoDao.getSupportedVideosOnPlatforms(EnumSet.noneOf(Platform.class));\n        assertThat(notNullVideos).containsExactly(0, 1, 2, 3, 4);\n    }\n\n    @Test\n    public void testBitwiseWorksForOneElement() {\n        List<Integer> stbVideos = videoDao.getSupportedVideosOnPlatforms(EnumSet.of(Platform.STB));\n        assertThat(stbVideos).containsOnlyOnce(2);\n    }\n\n    @Test\n    public void testBitwiseWorksForSeveralElements() {\n        List<Integer> webIosVideos = videoDao.getSupportedVideosOnPlatforms(EnumSet.of(Platform.WEB, Platform.IOS));\n        assertThat(webIosVideos).containsExactly(0, 3);\n    }\n\n    @Test\n    public void testBitwiseAdditionWorks() {\n        videoDao.addPlatforms(1, EnumSet.of(Platform.IOS, Platform.ANDROID));\n        EnumSet<Platform> supportedPlatforms = getSupportedPlatforms(1);\n        assertThat(supportedPlatforms).containsExactly(Platform.ANDROID, Platform.IOS, Platform.SMART_TV);\n    }\n\n    @Test\n    public void testBitwiseRemovingWorks() {\n        videoDao.removePlatforms(0, EnumSet.of(Platform.IOS, Platform.ANDROID, Platform.SMART_TV));\n        EnumSet<Platform> supportedPlatforms = getSupportedPlatforms(0);\n        assertThat(supportedPlatforms).containsOnlyOnce(Platform.WEB);\n    }\n\n    @Test\n    public void testAmountPlatforms() {\n        int amount = videoDao.getAmountOfSupportedPlatforms(0);\n        assertThat(amount).isEqualTo(3);\n    }\n\n    @Test\n    public void throwsOnNonBitChars() {\n        Handle handle = db.getHandle();\n        // redefine column to varchar type\n        handle.execute(\"drop table if exists videos\");\n        handle.execute(\"create table videos (id int primary key, supported_platforms varchar)\");\n        handle.execute(\"discard all\");\n        handle.useTransaction(h -> {\n            // insert wrong bitstring\n            int id = 1;\n            String notBit = \"2\";\n            h.createUpdate(\"insert into videos(id, supported_platforms) values (:id, :notBits)\")\n                .bind(\"id\", id)\n                .bind(\"notBits\", \"0101\" + notBit)\n                .execute();\n\n            assertThatThrownBy(() -> h.attach(VideoDao.class).getSupportedPlatforms(id))\n                .hasMessageContaining(\"non-bit character \" + notBit);\n        });\n    }\n\n    private EnumSet<Platform> getSupportedPlatforms(int id) {\n        return db.getHandle()\n            .createQuery(\"select supported_platforms from videos where id=:id\")\n            .bind(\"id\", id)\n            .mapTo(PLATFORM_SET)\n            .one();\n    }\n\n    public interface VideoDao {\n\n        @SqlUpdate(\"insert into videos(id, supported_platforms) values (:id, :platforms::varbit)\")\n        void insert(int id, EnumSet<Platform> platforms);\n\n        @SqlQuery(\"select supported_platforms from videos where id=:id\")\n        @SingleValue\n        EnumSet<Platform> getSupportedPlatforms(int id);\n\n        @SqlQuery(\"select id from videos \"\n            + \"where (supported_platforms & :platforms::varbit) = :platforms::varbit \"\n            + \"order by id\")\n        List<Integer> getSupportedVideosOnPlatforms(EnumSet<Platform> platforms);\n\n        @SqlUpdate(\"update videos \"\n            + \"set supported_platforms = (supported_platforms | :platforms::varbit) \"\n            + \"where id=:id\")\n        void addPlatforms(int id, EnumSet<Platform> platforms);\n\n        @SqlUpdate(\"update videos \"\n            + \"set supported_platforms = (supported_platforms & ~:platforms::varbit) \"\n            + \"where id=:id\")\n        void removePlatforms(int id, EnumSet<Platform> platforms);\n\n        @SqlQuery(\"select length(replace(supported_platforms::varchar, '0', '')) from videos \"\n            + \"where id=:id\")\n        int getAmountOfSupportedPlatforms(int id);\n    }\n\n    public enum Platform {\n        ANDROID,\n        IOS,\n        SMART_TV,\n        STB,\n        WEB\n    }\n}\n","lineNo":155}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.internal.NamedArgumentFinderFactory;\nimport org.jdbi.v3.core.argument.internal.NamedArgumentFinderFactory.PrepareKey;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.result.ResultProducer;\nimport org.jdbi.v3.core.result.ResultProducers;\nimport org.jdbi.v3.core.result.ResultSetScanner;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.jdbi.v3.core.statement.internal.PreparedBinding;\n\nimport static org.jdbi.v3.core.result.ResultProducers.returningGeneratedKeys;\n\n/**\n * Represents a prepared batch statement.  Multiple bindings are added to the\n * compiled statement and then executed in a single operation. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n *\n * The statement starts with an empty binding.  You bind a single batch of parameters\n * with the usual {@link SqlStatement} binding methods, and then call\n * {@link PreparedBatch#add()} to add the current binding as a batch and then clear it.\n *\n * An entire batch can be bound and added in one go with {@link PreparedBatch#add(Map)}\n * or {@link PreparedBatch#add(Object...)}.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch> implements ResultBearing {\n    private final List<PreparedBinding> bindings = new ArrayList<>();\n    final Map<PrepareKey, Function<String, Optional<Function<Object, Argument>>>> preparedFinders = new HashMap<>();\n\n    public PreparedBatch(Handle handle, String sql) {\n        super(handle, sql);\n        getContext().setBinding(new PreparedBinding(getContext()));\n    }\n\n    @Override\n    PreparedBatch bindNamedArgumentFinder(NamedArgumentFinderFactory<?> factory, String prefix, Object value, Supplier<NamedArgumentFinder> backupArgumentFinder) {\n        PreparedBinding binding = getBinding();\n        PrepareKey key = factory.keyFor(prefix, value);\n        preparedFinders.computeIfAbsent(key,\n                pk -> factory.prepareFor(getConfig(), this::buildArgument, prefix, value));\n        binding.prepareKeys.put(key, value);\n        binding.backupArgumentFinders.add(backupArgumentFinder);\n        return this;\n    }\n\n    @Override\n    protected PreparedBinding getBinding() {\n        return (PreparedBinding) super.getBinding();\n    }\n\n    Function<Object, Argument> buildArgument(QualifiedType<?> type) {\n        return getContext().getConfig(Arguments.class)\n                .prepareFor(type)\n                .orElseThrow(() -> new IllegalStateException());\n    }\n\n    @Override\n    public <R> R scanResultSet(ResultSetScanner<R> mapper) {\n        return execute(ResultProducers.returningResults()).scanResultSet(mapper);\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        try {\n            return internalBatchExecute().updateCounts;\n        } finally {\n            getContext().close();\n        }\n    }\n\n    public ResultIterator<Integer> executeAndGetModCount() {\n        StatementContext ctx = getContext();\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return ctx;\n            }\n\n            @Override\n            public void close() {\n                ctx.close();\n            }\n        };\n    }\n\n    public ResultBearing executeAndReturnGeneratedKeys(String... columnNames) {\n        return execute(returningGeneratedKeys(columnNames));\n    }\n\n    /**\n     * Executes the batch, returning the result obtained from the given {@link ResultProducer}.\n     *\n     * @param <R> the type of the result\n     * @param producer the result producer.\n     * @return value returned by the result producer.\n     */\n    public <R> R execute(ResultProducer<R> producer) {\n        try {\n            return producer.produce(() -> internalBatchExecute().stmt, getContext());\n        } catch (SQLException e) {\n            try {\n                close();\n            } catch (Exception e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToProduceResultException(\"Exception producing batch result\", e, getContext());\n        }\n    }\n\n    private ExecutedBatch internalBatchExecute() {\n        if (!getBinding().isEmpty()) {\n            add();\n        }\n\n        beforeTemplating();\n\n        final StatementContext ctx = getContext();\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(getSql(), ctx);\n        ctx.setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, ctx);\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n        ctx.setParsedSql(parsedSql);\n\n        try {\n            try {\n                StatementBuilder statementBuilder = getHandle().getStatementBuilder();\n                @SuppressWarnings(\"PMD.CloseResource\")\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, ctx);\n\n                addCleanable(() -> statementBuilder.close(connection, sql, stmt));\n                getConfig(SqlStatements.class).customize(stmt);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, ctx);\n            }\n\n            if (bindings.isEmpty()) {\n                return new ExecutedBatch(stmt, new int[0]);\n            }\n\n            beforeBinding();\n\n            try {\n                ArgumentBinder<?> binder = new ArgumentBinder.Prepared(this, parsedParameters, bindings.get(0));\n                for (Binding binding : bindings) {\n                    ctx.setBinding(binding);\n                    binder.bind(binding);\n                    stmt.addBatch();\n                }\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, ctx);\n            }\n\n            beforeExecution();\n\n            try {\n                final int[] rs = SqlLoggerUtil.wrap(stmt::executeBatch, ctx, getConfig(SqlStatements.class).getSqlLogger());\n\n                afterExecution();\n\n                ctx.setBinding(new PreparedBinding(ctx));\n\n                return new ExecutedBatch(stmt, rs);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), ctx);\n            }\n        } finally {\n            bindings.clear();\n        }\n    }\n\n    /**\n     * Add the current binding as a saved batch and clear the binding.\n     * @return this\n     */\n    public PreparedBatch add() {\n        final PreparedBinding currentBinding = getBinding();\n        if (currentBinding.isEmpty()) {\n            throw new IllegalStateException(\"Attempt to add() an empty batch, you probably didn't mean to do this \"\n                    + \"- call add() *after* setting batch parameters\");\n        }\n        bindings.add(currentBinding);\n        getContext().setBinding(new PreparedBinding(getContext()));\n        return this;\n    }\n\n    /**\n     * Bind arguments positionally, add the binding as a saved batch, and\n     * then clear the current binding.\n     * @param args the positional arguments to bind\n     * @return this\n     */\n    public PreparedBatch add(Object... args) {\n        for (int i = 0; i < args.length; i++) {\n            bind(i, args[i]);\n        }\n        add();\n        return this;\n    }\n\n    /**\n     * Bind arguments from a Map, add the binding as a saved batch,\n     * then clear the current binding.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     * @return this\n     */\n    public PreparedBatch add(Map<String, ?> args) {\n        bindMap(args);\n        add();\n        return this;\n    }\n\n    /**\n     * @return the number of bindings which are in this batch\n     */\n    public int size() {\n        return bindings.size();\n    }\n\n    private static class ExecutedBatch {\n        final PreparedStatement stmt;\n        final int[] updateCounts;\n\n        ExecutedBatch(PreparedStatement stmt, int[] updateCounts) {\n            this.stmt = stmt;\n            this.updateCounts = Arrays.copyOf(updateCounts, updateCounts.length);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.internal.NamedArgumentFinderFactory;\nimport org.jdbi.v3.core.argument.internal.NamedArgumentFinderFactory.PrepareKey;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.result.ResultProducer;\nimport org.jdbi.v3.core.result.ResultProducers;\nimport org.jdbi.v3.core.result.ResultSetScanner;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.jdbi.v3.core.statement.internal.PreparedBinding;\n\nimport static org.jdbi.v3.core.result.ResultProducers.returningGeneratedKeys;\n\n/**\n * Represents a prepared batch statement.  Multiple bindings are added to the\n * compiled statement and then executed in a single operation. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n *\n * The statement starts with an empty binding.  You bind a single batch of parameters\n * with the usual {@link SqlStatement} binding methods, and then call\n * {@link PreparedBatch#add()} to add the current binding as a batch and then clear it.\n *\n * An entire batch can be bound and added in one go with {@link PreparedBatch#add(Map)}\n * or {@link PreparedBatch#add(Object...)}.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch> implements ResultBearing {\n    private final List<PreparedBinding> bindings = new ArrayList<>();\n    final Map<PrepareKey, Function<String, Optional<Function<Object, Argument>>>> preparedFinders = new HashMap<>();\n\n    public PreparedBatch(Handle handle, String sql) {\n        super(handle, sql);\n        getContext().setBinding(new PreparedBinding(getContext()));\n    }\n\n    @Override\n    PreparedBatch bindNamedArgumentFinder(NamedArgumentFinderFactory<?> factory, String prefix, Object value, Supplier<NamedArgumentFinder> backupArgumentFinder) {\n        PreparedBinding binding = getBinding();\n        PrepareKey key = factory.keyFor(prefix, value);\n        preparedFinders.computeIfAbsent(key,\n                pk -> factory.prepareFor(getConfig(), this::buildArgument, prefix, value));\n        binding.prepareKeys.put(key, value);\n        binding.backupArgumentFinders.add(backupArgumentFinder);\n        return this;\n    }\n\n    @Override\n    protected PreparedBinding getBinding() {\n        return (PreparedBinding) super.getBinding();\n    }\n\n    Function<Object, Argument> buildArgument(QualifiedType<?> type) {\n        Arguments args = getContext().getConfig(Arguments.class);\n        return args\n                .prepareFor(type)\n                .orElse(value -> (pos, st, ctx) -> args.findFor(type, value)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"no argument factory for type \" + type, ctx))\n                        .apply(pos, st, ctx));\n    }\n\n    @Override\n    public <R> R scanResultSet(ResultSetScanner<R> mapper) {\n        return execute(ResultProducers.returningResults()).scanResultSet(mapper);\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        try {\n            return internalBatchExecute().updateCounts;\n        } finally {\n            getContext().close();\n        }\n    }\n\n    public ResultIterator<Integer> executeAndGetModCount() {\n        StatementContext ctx = getContext();\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return ctx;\n            }\n\n            @Override\n            public void close() {\n                ctx.close();\n            }\n        };\n    }\n\n    public ResultBearing executeAndReturnGeneratedKeys(String... columnNames) {\n        return execute(returningGeneratedKeys(columnNames));\n    }\n\n    /**\n     * Executes the batch, returning the result obtained from the given {@link ResultProducer}.\n     *\n     * @param <R> the type of the result\n     * @param producer the result producer.\n     * @return value returned by the result producer.\n     */\n    public <R> R execute(ResultProducer<R> producer) {\n        try {\n            return producer.produce(() -> internalBatchExecute().stmt, getContext());\n        } catch (SQLException e) {\n            try {\n                close();\n            } catch (Exception e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToProduceResultException(\"Exception producing batch result\", e, getContext());\n        }\n    }\n\n    private ExecutedBatch internalBatchExecute() {\n        if (!getBinding().isEmpty()) {\n            add();\n        }\n\n        beforeTemplating();\n\n        final StatementContext ctx = getContext();\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(getSql(), ctx);\n        ctx.setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, ctx);\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n        ctx.setParsedSql(parsedSql);\n\n        try {\n            try {\n                StatementBuilder statementBuilder = getHandle().getStatementBuilder();\n                @SuppressWarnings(\"PMD.CloseResource\")\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, ctx);\n\n                addCleanable(() -> statementBuilder.close(connection, sql, stmt));\n                getConfig(SqlStatements.class).customize(stmt);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, ctx);\n            }\n\n            if (bindings.isEmpty()) {\n                return new ExecutedBatch(stmt, new int[0]);\n            }\n\n            beforeBinding();\n\n            try {\n                ArgumentBinder<?> binder = new ArgumentBinder.Prepared(this, parsedParameters, bindings.get(0));\n                for (Binding binding : bindings) {\n                    ctx.setBinding(binding);\n                    binder.bind(binding);\n                    stmt.addBatch();\n                }\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, ctx);\n            }\n\n            beforeExecution();\n\n            try {\n                final int[] rs = SqlLoggerUtil.wrap(stmt::executeBatch, ctx, getConfig(SqlStatements.class).getSqlLogger());\n\n                afterExecution();\n\n                ctx.setBinding(new PreparedBinding(ctx));\n\n                return new ExecutedBatch(stmt, rs);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), ctx);\n            }\n        } finally {\n            bindings.clear();\n        }\n    }\n\n    /**\n     * Add the current binding as a saved batch and clear the binding.\n     * @return this\n     */\n    public PreparedBatch add() {\n        final PreparedBinding currentBinding = getBinding();\n        if (currentBinding.isEmpty()) {\n            throw new IllegalStateException(\"Attempt to add() an empty batch, you probably didn't mean to do this \"\n                    + \"- call add() *after* setting batch parameters\");\n        }\n        bindings.add(currentBinding);\n        getContext().setBinding(new PreparedBinding(getContext()));\n        return this;\n    }\n\n    /**\n     * Bind arguments positionally, add the binding as a saved batch, and\n     * then clear the current binding.\n     * @param args the positional arguments to bind\n     * @return this\n     */\n    public PreparedBatch add(Object... args) {\n        for (int i = 0; i < args.length; i++) {\n            bind(i, args[i]);\n        }\n        add();\n        return this;\n    }\n\n    /**\n     * Bind arguments from a Map, add the binding as a saved batch,\n     * then clear the current binding.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     * @return this\n     */\n    public PreparedBatch add(Map<String, ?> args) {\n        bindMap(args);\n        add();\n        return this;\n    }\n\n    /**\n     * @return the number of bindings which are in this batch\n     */\n    public int size() {\n        return bindings.size();\n    }\n\n    private static class ExecutedBatch {\n        final PreparedStatement stmt;\n        final int[] updateCounts;\n\n        ExecutedBatch(PreparedStatement stmt, int[] updateCounts) {\n            this.stmt = stmt;\n            this.updateCounts = Arrays.copyOf(updateCounts, updateCounts.length);\n        }\n    }\n}\n","lineNo":85}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.qualifier;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.StreamSupport;\n\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.internal.AnnotationFactory;\nimport org.jdbi.v3.meta.Beta;\n\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.unmodifiableSet;\nimport static java.util.stream.Collectors.toSet;\n\n/**\n * A {@link java.lang.reflect.Type} qualified by a set of qualifier annotations. Two qualified types are equal to each other\n * if their {@link #getType()} and {@link #getQualifiers()} properties are equal.\n *\n * @param <T> the type that is qualified\n */\n@Beta\npublic final class QualifiedType<T> {\n    private final Type type;\n    private final Set<Annotation> qualifiers;\n    private int hashCode;\n\n    /**\n     * Creates a {@code QualifiedType<T>} for a {@code Class<T>} with no qualifiers.\n     * @param clazz the unqualified type\n     * @return the unqualified QualifiedType\n     * @see #with(Annotation...) to then qualify your type\n     */\n    public static <T> QualifiedType<T> of(Class<T> clazz) {\n        return new QualifiedType<>(clazz, emptySet());\n    }\n\n    /**\n     * Creates a wildcard {@code QualifiedType<?>} for a {@link Type} with no qualifiers.\n     * @param type the unqualified type\n     * @return the unqualified QualifiedType\n     * @see #with(Annotation...) to then qualify your type\n     */\n    public static QualifiedType<?> of(Type type) {\n        return new QualifiedType<>(type, emptySet());\n    }\n\n    /**\n     * Creates a {@code QualifiedType<T>} for a {@code GenericType<T>} with no qualifiers.\n     * @param type the unqualified type\n     * @return the unqualified QualifiedType\n     * @see #with(Annotation...) to then qualify your type\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> QualifiedType<T> of(GenericType<T> type) {\n        return (QualifiedType<T>) of(type.getType());\n    }\n\n    private QualifiedType(Type type, Set<? extends Annotation> qualifiers) {\n        this.type = type;\n        this.qualifiers = unmodifiableSet(qualifiers);\n    }\n\n    /**\n     * Returns a QualifiedType that has the same type as this instance, but with <b>only<\/b> the given qualifiers.\n     *\n     * @param newQualifiers the qualifiers for the new qualified type.\n     * @return the QualifiedType\n     */\n    public QualifiedType<T> with(Annotation... newQualifiers) {\n        return new QualifiedType<>(type, Arrays.stream(newQualifiers).collect(toSet()));\n    }\n\n    /**\n     * Returns a QualifiedType that has the same type as this instance, but with <b>only<\/b> the given qualifiers.\n     *\n     * @param newQualifiers the qualifiers for the new qualified type.\n     * @throws IllegalArgumentException if any of the given qualifier types have annotation attributes.\n     * @return the QualifiedType\n     */\n    @SafeVarargs\n    public final QualifiedType<T> with(Class<? extends Annotation>... newQualifiers) {\n        Set<? extends Annotation> annotations = Arrays.stream(newQualifiers)\n            .map(AnnotationFactory::create)\n            .collect(toSet());\n        return new QualifiedType<>(type, annotations);\n    }\n\n    /**\n     * @return a QualifiedType that has the same type as this instance, but with <b>only<\/b> the given qualifiers.\n     *\n     * @param newQualifiers the qualifiers for the new qualified type.\n     */\n    public QualifiedType<T> withAnnotations(Iterable<? extends Annotation> newQualifiers) {\n        return new QualifiedType<>(type, StreamSupport.stream(newQualifiers.spliterator(), false).collect(toSet()));\n    }\n\n    /**\n     * @return a QualifiedType that has the same type as this instance, but with <b>only<\/b> the given qualifiers.\n     *\n     * @param newQualifiers the qualifiers for the new qualified type.\n     */\n    public QualifiedType<T> withAnnotationClasses(Iterable<Class<? extends Annotation>> newQualifiers) {\n        Set<? extends Annotation> annotations = StreamSupport.stream(newQualifiers.spliterator(), false)\n            .map(AnnotationFactory::create)\n            .collect(toSet());\n        return new QualifiedType<>(type, annotations);\n    }\n\n    /**\n     * @return the type being qualified\n     */\n    public Type getType() {\n        return type;\n    }\n\n    /**\n     * @return the type qualifiers.\n     */\n    public Set<Annotation> getQualifiers() {\n        return qualifiers;\n    }\n\n    /**\n     * Apply the provided mapping function to the type, and if non-empty is returned,\n     * return an {@code Optional<QualifiedType<?>>} with the returned type, and the same\n     * qualifiers as this instance.\n     *\n     * @param mapper a mapping function to apply to the type\n     * @return an optional qualified type with the mapped type and the same qualifiers\n     */\n    public QualifiedType<?> mapType(Function<Type, Type> mapper) {\n        return new QualifiedType<>(mapper.apply(type), qualifiers);\n    }\n\n    /**\n     * Apply the provided mapping function to the type, and if non-empty is returned,\n     * return an {@code Optional<QualifiedType<?>>} with the returned type, and the same\n     * qualifiers as this instance.\n     *\n     * @param mapper a mapping function to apply to the type\n     * @return an optional qualified type with the mapped type and the same qualifiers\n     */\n    public Optional<QualifiedType<?>> flatMapType(Function<Type, Optional<Type>> mapper) {\n        return mapper.apply(type).map(mappedType -> new QualifiedType<>(mappedType, qualifiers));\n    }\n\n    /**\n     * @param qualifier qualifier to check for\n     * @return true if this instance contains the given qualifier\n     */\n    public boolean hasQualifier(Class<? extends Annotation> qualifier) {\n        return qualifiers.stream().anyMatch(qualifier::isInstance);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        QualifiedType<?> that = (QualifiedType<?>) o;\n        return Objects.equals(type, that.type)\n            && Objects.equals(qualifiers, that.qualifiers);\n    }\n\n    @Override\n    public int hashCode() {\n        if (hashCode != 0) {\n            return hashCode;\n        }\n        return hashCode = Objects.hash(type, qualifiers);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        qualifiers.forEach(qualifier -> builder.append(qualifier).append(\" \"));\n        builder.append(type.getTypeName());\n        return builder.toString();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.qualifier;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.StreamSupport;\n\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.internal.AnnotationFactory;\nimport org.jdbi.v3.meta.Beta;\n\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.unmodifiableSet;\nimport static java.util.stream.Collectors.toSet;\n\n/**\n * A {@link java.lang.reflect.Type} qualified by a set of qualifier annotations. Two qualified types are equal to each other\n * if their {@link #getType()} and {@link #getQualifiers()} properties are equal.\n *\n * @param <T> the type that is qualified\n */\n@Beta\npublic final class QualifiedType<T> {\n    private final Type type;\n    private final Set<Annotation> qualifiers;\n    private int hashCode;\n\n    /**\n     * Creates a {@code QualifiedType<T>} for a {@code Class<T>} with no qualifiers.\n     * @param clazz the unqualified type\n     * @return the unqualified QualifiedType\n     * @see #with(Annotation...) to then qualify your type\n     */\n    public static <T> QualifiedType<T> of(Class<T> clazz) {\n        return new QualifiedType<>(clazz, emptySet());\n    }\n\n    /**\n     * Creates a wildcard {@code QualifiedType<?>} for a {@link Type} with no qualifiers.\n     * @param type the unqualified type\n     * @return the unqualified QualifiedType\n     * @see #with(Annotation...) to then qualify your type\n     */\n    public static QualifiedType<?> of(Type type) {\n        return new QualifiedType<>(type, emptySet());\n    }\n\n    /**\n     * Creates a {@code QualifiedType<T>} for a {@code GenericType<T>} with no qualifiers.\n     * @param type the unqualified type\n     * @return the unqualified QualifiedType\n     * @see #with(Annotation...) to then qualify your type\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> QualifiedType<T> of(GenericType<T> type) {\n        return (QualifiedType<T>) of(type.getType());\n    }\n\n    private QualifiedType(Type type, Set<? extends Annotation> qualifiers) {\n        this.type = type;\n        this.qualifiers = unmodifiableSet(qualifiers);\n    }\n\n    /**\n     * Returns a QualifiedType that has the same type as this instance, but with <b>only<\/b> the given qualifiers.\n     *\n     * @param newQualifiers the qualifiers for the new qualified type.\n     * @return the QualifiedType\n     */\n    public QualifiedType<T> with(Annotation... newQualifiers) {\n        return new QualifiedType<>(type, Arrays.stream(newQualifiers).collect(toSet()));\n    }\n\n    /**\n     * Returns a QualifiedType that has the same type as this instance, but with <b>only<\/b> the given qualifiers.\n     *\n     * @param newQualifiers the qualifiers for the new qualified type.\n     * @throws IllegalArgumentException if any of the given qualifier types have annotation attributes.\n     * @return the QualifiedType\n     */\n    @SafeVarargs\n    public final QualifiedType<T> with(Class<? extends Annotation>... newQualifiers) {\n        Set<? extends Annotation> annotations = Arrays.stream(newQualifiers)\n            .map(AnnotationFactory::create)\n            .collect(toSet());\n        return new QualifiedType<>(type, annotations);\n    }\n\n    /**\n     * @return a QualifiedType that has the same type as this instance, but with <b>only<\/b> the given qualifiers.\n     *\n     * @param newQualifiers the qualifiers for the new qualified type.\n     */\n    public QualifiedType<T> withAnnotations(Iterable<? extends Annotation> newQualifiers) {\n        return new QualifiedType<>(type, StreamSupport.stream(newQualifiers.spliterator(), false).collect(toSet()));\n    }\n\n    /**\n     * @return a QualifiedType that has the same type as this instance, but with <b>only<\/b> the given qualifiers.\n     *\n     * @param newQualifiers the qualifiers for the new qualified type.\n     */\n    public QualifiedType<T> withAnnotationClasses(Iterable<Class<? extends Annotation>> newQualifiers) {\n        Set<? extends Annotation> annotations = StreamSupport.stream(newQualifiers.spliterator(), false)\n            .map(AnnotationFactory::create)\n            .collect(toSet());\n        return new QualifiedType<>(type, annotations);\n    }\n\n    /**\n     * @return the type being qualified\n     */\n    public Type getType() {\n        return type;\n    }\n\n    /**\n     * @return the type qualifiers.\n     */\n    public Set<Annotation> getQualifiers() {\n        return qualifiers;\n    }\n\n    /**\n     * Apply the provided mapping function to the type, and if non-empty is returned,\n     * return an {@code Optional<QualifiedType<?>>} with the returned type, and the same\n     * qualifiers as this instance.\n     *\n     * @param mapper a mapping function to apply to the type\n     * @return an optional qualified type with the mapped type and the same qualifiers\n     */\n    public QualifiedType<?> mapType(Function<Type, Type> mapper) {\n        return new QualifiedType<>(mapper.apply(type), qualifiers);\n    }\n\n    /**\n     * Apply the provided mapping function to the type, and if non-empty is returned,\n     * return an {@code Optional<QualifiedType<?>>} with the returned type, and the same\n     * qualifiers as this instance.\n     *\n     * @param mapper a mapping function to apply to the type\n     * @return an optional qualified type with the mapped type and the same qualifiers\n     */\n    public Optional<QualifiedType<?>> flatMapType(Function<Type, Optional<Type>> mapper) {\n        return mapper.apply(type).map(mappedType -> new QualifiedType<>(mappedType, qualifiers));\n    }\n\n    /**\n     * @param qualifier qualifier to check for\n     * @return true if this instance contains the given qualifier\n     */\n    public boolean hasQualifier(Class<? extends Annotation> qualifier) {\n        return qualifiers.stream().anyMatch(qualifier::isInstance);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        QualifiedType<?> that = (QualifiedType<?>) o;\n        return Objects.equals(type, that.type)\n            && Objects.equals(qualifiers, that.qualifiers);\n    }\n\n    @Override\n    public int hashCode() {\n        int h = hashCode;\n        if (h == 0) {\n            hashCode = h = Objects.hash(type, qualifiers);\n        }\n        return h;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        qualifiers.forEach(qualifier -> builder.append(qualifier).append(\" \"));\n        builder.append(type.getTypeName());\n        return builder.toString();\n    }\n}\n","lineNo":188}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.argument.internal.MethodReturnValueNamedArgumentFinder;\nimport org.jdbi.v3.core.argument.internal.TypedValue;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.JdbiCache;\nimport org.jdbi.v3.core.config.JdbiCaches;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.qualifier.Qualifiers;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * Binds public methods with no parameters on a specified object.\n * @deprecated this functionality will remain supported, but this class should not be API\n */\n@Deprecated\npublic class ObjectMethodArguments extends MethodReturnValueNamedArgumentFinder {\n    private static final JdbiCache<Class<?>, Map<String, Function<Object, TypedValue>>> NULLARY_METHOD_CACHE =\n            JdbiCaches.declare(ObjectMethodArguments::load);\n    /**\n     * @param prefix an optional prefix (we insert a '.' as a separator)\n     * @param object the object to bind functions on\n     */\n    public ObjectMethodArguments(String prefix, Object object) {\n        super(prefix, object);\n    }\n\n    private static Map<String, Function<Object, TypedValue>> load(ConfigRegistry config, Class<?> type) {\n        final HashMap<String, Function<Object, TypedValue>> methodMap = new HashMap<>();\n        if (Modifier.isPublic(type.getModifiers())) {\n            Arrays.stream(type.getMethods())\n                .filter(m -> m.getParameterCount() == 0)\n                .collect(Collectors.toMap(\n                        Method::getName,\n                        Function.identity(),\n                        ObjectMethodArguments::bridgeMethodMerge))\n                .forEach((name, method) -> {\n                    QualifiedType<?> qualifiedType = QualifiedType.of(method.getReturnType())\n                            .withAnnotations(config.get(Qualifiers.class).findFor(method));\n                    methodMap.put(name, Unchecked.function(\n                            value -> new TypedValue(qualifiedType, method.invoke(value))));\n                });\n        } else {\n            Optional.ofNullable(type.getSuperclass()).ifPresent(superclass -> methodMap.putAll(load(config, superclass)));\n            Arrays.stream(type.getInterfaces()).forEach(interfaceClass -> methodMap.putAll(load(config, interfaceClass)));\n        }\n        return methodMap;\n    }\n\n    @Override\n    protected Optional<TypedValue> getValue(String name, StatementContext ctx) {\n        return getter(name, ctx.getConfig()).map(m -> m.apply(obj));\n    }\n\n    public Optional<Function<Object, TypedValue>> getter(String name, ConfigRegistry config) {\n        return Optional.ofNullable(NULLARY_METHOD_CACHE.get(obj.getClass(), config).get(name));\n    }\n\n    @Override\n    protected NamedArgumentFinder getNestedArgumentFinder(Object source) {\n        return new ObjectMethodArguments(null, source);\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy object functions arguments \\\"\" + obj + \"\\\"\";\n    }\n\n    private static Method bridgeMethodMerge(Method a, Method b) {\n        return a.isBridge() ? b : a;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.argument.internal.ObjectPropertyNamedArgumentFinder;\nimport org.jdbi.v3.core.argument.internal.TypedValue;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.JdbiCache;\nimport org.jdbi.v3.core.config.JdbiCaches;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.qualifier.Qualifiers;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * Binds public methods with no parameters on a specified object.\n * @deprecated this functionality will remain supported, but this class should not be API\n */\n@Deprecated\npublic class ObjectMethodArguments extends ObjectPropertyNamedArgumentFinder {\n    private static final JdbiCache<Class<?>, Map<String, Function<Object, TypedValue>>> NULLARY_METHOD_CACHE =\n            JdbiCaches.declare(ObjectMethodArguments::load);\n    /**\n     * @param prefix an optional prefix (we insert a '.' as a separator)\n     * @param object the object to bind functions on\n     */\n    public ObjectMethodArguments(String prefix, Object object) {\n        super(prefix, object);\n    }\n\n    private static Map<String, Function<Object, TypedValue>> load(ConfigRegistry config, Class<?> type) {\n        final HashMap<String, Function<Object, TypedValue>> methodMap = new HashMap<>();\n        if (Modifier.isPublic(type.getModifiers())) {\n            Arrays.stream(type.getMethods())\n                .filter(m -> m.getParameterCount() == 0)\n                .collect(Collectors.toMap(\n                        Method::getName,\n                        Function.identity(),\n                        ObjectMethodArguments::bridgeMethodMerge))\n                .forEach((name, method) -> {\n                    QualifiedType<?> qualifiedType = QualifiedType.of(method.getReturnType())\n                            .withAnnotations(config.get(Qualifiers.class).findFor(method));\n                    MethodHandle mh = Unchecked.function(MethodHandles.lookup()::unreflect).apply(method);\n                    methodMap.put(name, Unchecked.function(\n                            value -> new TypedValue(qualifiedType, mh.invoke(value))));\n                });\n        } else {\n            Optional.ofNullable(type.getSuperclass()).ifPresent(superclass -> methodMap.putAll(load(config, superclass)));\n            Arrays.stream(type.getInterfaces()).forEach(interfaceClass -> methodMap.putAll(load(config, interfaceClass)));\n        }\n        return methodMap;\n    }\n\n    @Override\n    protected Optional<TypedValue> getValue(String name, StatementContext ctx) {\n        return getter(name, ctx.getConfig()).map(m -> m.apply(obj));\n    }\n\n    public Optional<Function<Object, TypedValue>> getter(String name, ConfigRegistry config) {\n        return Optional.ofNullable(NULLARY_METHOD_CACHE.get(obj.getClass(), config).get(name));\n    }\n\n    @Override\n    protected NamedArgumentFinder getNestedArgumentFinder(Object source) {\n        return new ObjectMethodArguments(null, source);\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy object functions arguments \\\"\" + obj + \"\\\"\";\n    }\n\n    private static Method bridgeMethodMerge(Method a, Method b) {\n        return a.isBridge() ? b : a;\n    }\n}\n","lineNo":65}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.util.Optional;\nimport java.util.function.Function;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.qualifier.Qualifiers;\nimport org.jdbi.v3.meta.Beta;\n\n/**\n * Inspect a value with optional static qualified type information and produce an {@link Argument}\n * that binds the value to a prepared statement.\n *\n * <p>Make sure to override {@link Object#toString} in your {@link Argument} instances if you want\n * to be able to log their values with an {@link org.jdbi.v3.core.statement.SqlLogger}.\n *\n * <p>Note that {@code null} is handled specially in a few cases, and a few {@code Jdbi} features\n * assume you'll return an instance of {@link NullArgument} when you intend to bind null.\n */\n@FunctionalInterface\n@Beta\npublic interface QualifiedArgumentFactory {\n    /**\n     * Returns an {@link Argument} for the given value if the factory supports it; empty otherwise.\n     *\n     * @param type the known qualified type of value. Depending on the situation this may be a full\n     *     generic signature e.g. {@link java.lang.reflect.ParameterizedType}, a {@link Class}, or\n     *     Object.class if no type information is known.\n     * @param value the value to convert into an {@link Argument}\n     * @param config the config registry, for composition\n     * @return an argument for the given value if this factory supports it, or <code>Optional.empty()\n     *     <\/code> otherwise.\n     * @see org.jdbi.v3.core.statement.StatementContext#findArgumentFor(QualifiedType, Object)\n     * @see Arguments#findFor(QualifiedType, Object)\n     * @see QualifiedType\n     */\n    Optional<Argument> build(QualifiedType<?> type, Object value, ConfigRegistry config);\n\n    /**\n     * Adapts an {@link ArgumentFactory} into a QualifiedArgumentFactory. The returned factory only\n     * matches qualified types with zero qualifiers.\n     *\n     * @param factory the factory to adapt\n     */\n    static QualifiedArgumentFactory adapt(ArgumentFactory factory) {\n        if (factory instanceof ArgumentFactory.Preparable) {\n            return adapt((ArgumentFactory.Preparable) factory);\n        }\n        return (type, value, config) -> type.getQualifiers().equals(\n                config.get(Qualifiers.class).findFor(factory.getClass()))\n            ? factory.build(type.getType(), value, config)\n            : Optional.empty();\n    }\n\n    /**\n     * Adapts an {@link ArgumentFactory.Preparable} into a QualifiedArgumentFactory.Preparable.\n     * The returned factory only matches qualified types with zero qualifiers.\n     *\n     * @param factory the factory to adapt\n     */\n    static QualifiedArgumentFactory.Preparable adapt(ArgumentFactory.Preparable factory) {\n        return QualifiedArgumentFactory.Preparable.adapt(factory);\n    }\n\n    /**\n     * QualifiedArgumentFactory extension interface that allows preparing arguments for efficient batch binding.\n     */\n    @Beta\n    interface Preparable extends QualifiedArgumentFactory {\n        Optional<Function<Object, Argument>> prepare(QualifiedType<?> type, ConfigRegistry config);\n\n        /**\n         * Adapts an {@link ArgumentFactory.Preparable} into a QualifiedArgumentFactory.Preparable\n         * The returned factory only matches qualified types with zero qualifiers.\n         *\n         * @param factory the factory to adapt\n         */\n        static QualifiedArgumentFactory.Preparable adapt(ArgumentFactory.Preparable factory) {\n            return new Preparable() {\n                @Override\n                public Optional<Argument> build(QualifiedType<?> type, Object value, ConfigRegistry config) {\n                    return type.getQualifiers().equals(\n                                config.get(Qualifiers.class).findFor(factory.getClass()))\n                            ? factory.build(type.getType(), value, config)\n                            : Optional.empty();\n                }\n\n                @Override\n                public Optional<Function<Object, Argument>> prepare(QualifiedType<?> type, ConfigRegistry config) {\n                    return type.getQualifiers().equals(\n                                config.get(Qualifiers.class).findFor(factory.getClass()))\n                            ? factory.prepare(type.getType(), config)\n                            : Optional.empty();\n                }\n            };\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.qualifier.Qualifiers;\nimport org.jdbi.v3.meta.Beta;\n\n/**\n * Inspect a value with optional static qualified type information and produce an {@link Argument}\n * that binds the value to a prepared statement.\n *\n * <p>Make sure to override {@link Object#toString} in your {@link Argument} instances if you want\n * to be able to log their values with an {@link org.jdbi.v3.core.statement.SqlLogger}.\n *\n * <p>Note that {@code null} is handled specially in a few cases, and a few {@code Jdbi} features\n * assume you'll return an instance of {@link NullArgument} when you intend to bind null.\n */\n@FunctionalInterface\n@Beta\npublic interface QualifiedArgumentFactory {\n    /**\n     * Returns an {@link Argument} for the given value if the factory supports it; empty otherwise.\n     *\n     * @param type the known qualified type of value. Depending on the situation this may be a full\n     *     generic signature e.g. {@link java.lang.reflect.ParameterizedType}, a {@link Class}, or\n     *     Object.class if no type information is known.\n     * @param value the value to convert into an {@link Argument}\n     * @param config the config registry, for composition\n     * @return an argument for the given value if this factory supports it, or <code>Optional.empty()\n     *     <\/code> otherwise.\n     * @see org.jdbi.v3.core.statement.StatementContext#findArgumentFor(QualifiedType, Object)\n     * @see Arguments#findFor(QualifiedType, Object)\n     * @see QualifiedType\n     */\n    Optional<Argument> build(QualifiedType<?> type, Object value, ConfigRegistry config);\n\n    /**\n     * Adapts an {@link ArgumentFactory} into a QualifiedArgumentFactory. The returned factory only\n     * matches qualified types with zero qualifiers.\n     *\n     * @param config the ConfigRegistry\n     * @param factory the factory to adapt\n     */\n    static QualifiedArgumentFactory adapt(ConfigRegistry config, ArgumentFactory factory) {\n        if (factory instanceof ArgumentFactory.Preparable) {\n            return adapt(config, (ArgumentFactory.Preparable) factory);\n        }\n        Set<Annotation> qualifiers = config.get(Qualifiers.class).findFor(factory.getClass());\n        return (type, value, cfg) ->\n            type.getQualifiers().equals(qualifiers)\n                ? factory.build(type.getType(), value, cfg)\n                : Optional.empty();\n    }\n\n    /**\n     * Adapts an {@link ArgumentFactory.Preparable} into a QualifiedArgumentFactory.Preparable.\n     * The returned factory only matches qualified types with zero qualifiers.\n     *\n     * @param factory the factory to adapt\n     */\n    static QualifiedArgumentFactory.Preparable adapt(ConfigRegistry config, ArgumentFactory.Preparable factory) {\n        return QualifiedArgumentFactory.Preparable.adapt(config, factory);\n    }\n\n    /**\n     * QualifiedArgumentFactory extension interface that allows preparing arguments for efficient batch binding.\n     */\n    @Beta\n    interface Preparable extends QualifiedArgumentFactory {\n        Optional<Function<Object, Argument>> prepare(QualifiedType<?> type, ConfigRegistry config);\n\n        Collection<QualifiedType<?>> prepPreparedTypes();\n\n        /**\n         * Adapts an {@link ArgumentFactory.Preparable} into a QualifiedArgumentFactory.Preparable\n         * The returned factory only matches qualified types with zero qualifiers.\n         *\n         * @param factory the factory to adapt\n         */\n        static QualifiedArgumentFactory.Preparable adapt(ConfigRegistry config, ArgumentFactory.Preparable factory) {\n            return new Preparable() {\n                Set<Annotation> qualifiers = config.get(Qualifiers.class).findFor(factory.getClass());\n                @Override\n                public Optional<Argument> build(QualifiedType<?> type, Object value, ConfigRegistry cfg) {\n                    return type.getQualifiers().equals(qualifiers)\n                            ? factory.build(type.getType(), value, cfg)\n                            : Optional.empty();\n                }\n\n                @Override\n                public Optional<Function<Object, Argument>> prepare(QualifiedType<?> type, ConfigRegistry cfg) {\n                    return type.getQualifiers().equals(qualifiers)\n                            ? factory.prepare(type.getType(), cfg)\n                            : Optional.empty();\n                }\n\n                @Override\n                public Collection<QualifiedType<?>> prepPreparedTypes() {\n                    return factory.prePreparedTypes().stream()\n                            .map(QualifiedType::of)\n                            .map(qt -> qt.withAnnotations(qualifiers))\n                            .collect(Collectors.toList());\n                }\n\n                @Override\n                public String toString() {\n                    return \"Qualified[\" + factory + \"]\";\n                }\n            };\n        }\n    }\n}\n","lineNo":68}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.result.ResultProducer;\nimport org.jdbi.v3.core.result.ResultProducers;\nimport org.jdbi.v3.core.result.ResultSetScanner;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\n\nimport static org.jdbi.v3.core.result.ResultProducers.returningGeneratedKeys;\n\n/**\n * Represents a prepared batch statement.  Multiple bindings are added to the\n * compiled statement and then executed in a single operation. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n *\n * The statement starts with an empty binding.  You bind a single batch of parameters\n * with the usual {@link SqlStatement} binding methods, and then call\n * {@link PreparedBatch#add()} to add the current binding as a batch and then clear it.\n *\n * An entire batch can be bound and added in one go with {@link PreparedBatch#add(Map)}\n * or {@link PreparedBatch#add(Object...)}.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch> implements ResultBearing {\n    private final List<Binding> bindings = new ArrayList<>();\n\n    public PreparedBatch(Handle handle, String sql) {\n        super(handle, sql);\n    }\n\n    @Override\n    public <R> R scanResultSet(ResultSetScanner<R> mapper) {\n        return execute(ResultProducers.returningResults()).scanResultSet(mapper);\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        try {\n            return internalBatchExecute().updateCounts;\n        } finally {\n            getContext().close();\n        }\n    }\n\n    public ResultIterator<Integer> executeAndGetModCount() {\n        StatementContext ctx = getContext();\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return ctx;\n            }\n\n            @Override\n            public void close() {\n                ctx.close();\n            }\n        };\n    }\n\n    public ResultBearing executeAndReturnGeneratedKeys(String... columnNames) {\n        return execute(returningGeneratedKeys(columnNames));\n    }\n\n    /**\n     * Executes the batch, returning the result obtained from the given {@link ResultProducer}.\n     *\n     * @param <R> the type of the result\n     * @param producer the result producer.\n     * @return value returned by the result producer.\n     */\n    public <R> R execute(ResultProducer<R> producer) {\n        try {\n            return producer.produce(() -> internalBatchExecute().stmt, getContext());\n        } catch (SQLException e) {\n            try {\n                close();\n            } catch (Exception e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToProduceResultException(\"Exception producing batch result\", e, getContext());\n        }\n    }\n\n    private ExecutedBatch internalBatchExecute() {\n        if (!getBinding().isEmpty()) {\n            add();\n        }\n\n        beforeTemplating();\n\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(getSql(), getContext());\n        getContext().setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, getContext());\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            try {\n                StatementBuilder statementBuilder = getHandle().getStatementBuilder();\n                @SuppressWarnings(\"PMD.CloseResource\")\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, getContext());\n\n                addCleanable(() -> statementBuilder.close(connection, sql, stmt));\n                getConfig(SqlStatements.class).customize(stmt);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n            beforeBinding();\n\n            try {\n                for (Binding binding : bindings) {\n                    getContext().setBinding(binding);\n                    ArgumentBinder.bind(parsedParameters, binding, stmt, getContext());\n                    stmt.addBatch();\n                }\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, getContext());\n            }\n\n            beforeExecution();\n\n            try {\n                final int[] rs = SqlLoggerUtil.wrap(stmt::executeBatch, getContext(), getConfig(SqlStatements.class).getSqlLogger());\n\n                afterExecution();\n\n                getContext().setBinding(new Binding());\n\n                return new ExecutedBatch(stmt, rs);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), getContext());\n            }\n        } finally {\n            bindings.clear();\n        }\n    }\n\n    /**\n     * Add the current binding as a saved batch and clear the binding.\n     * @return this\n     */\n    public PreparedBatch add() {\n        final Binding currentBinding = getBinding();\n        if (currentBinding.isEmpty()) {\n            throw new IllegalStateException(\"Attempt to add() an empty batch, you probably didn't mean to do this \"\n                    + \"- call add() *after* setting batch parameters\");\n        }\n        bindings.add(currentBinding);\n        getContext().setBinding(new Binding());\n        return this;\n    }\n\n    /**\n     * Bind arguments positionally, add the binding as a saved batch, and\n     * then clear the current binding.\n     * @param args the positional arguments to bind\n     * @return this\n     */\n    public PreparedBatch add(Object... args) {\n        for (int i = 0; i < args.length; i++) {\n            bind(i, args[i]);\n        }\n        add();\n        return this;\n    }\n\n    /**\n     * Bind arguments from a Map, add the binding as a saved batch,\n     * then clear the current binding.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     * @return this\n     */\n    public PreparedBatch add(Map<String, ?> args) {\n        bindMap(args);\n        add();\n        return this;\n    }\n\n    /**\n     * @return the number of bindings which are in this batch\n     */\n    public int size() {\n        return bindings.size();\n    }\n\n    private static class ExecutedBatch {\n        final PreparedStatement stmt;\n        final int[] updateCounts;\n\n        ExecutedBatch(PreparedStatement stmt, int[] updateCounts) {\n            this.stmt = stmt;\n            this.updateCounts = Arrays.copyOf(updateCounts, updateCounts.length);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.result.ResultProducer;\nimport org.jdbi.v3.core.result.ResultProducers;\nimport org.jdbi.v3.core.result.ResultSetScanner;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\n\nimport static org.jdbi.v3.core.result.ResultProducers.returningGeneratedKeys;\n\n/**\n * Represents a prepared batch statement.  Multiple bindings are added to the\n * compiled statement and then executed in a single operation. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n *\n * The statement starts with an empty binding.  You bind a single batch of parameters\n * with the usual {@link SqlStatement} binding methods, and then call\n * {@link PreparedBatch#add()} to add the current binding as a batch and then clear it.\n *\n * An entire batch can be bound and added in one go with {@link PreparedBatch#add(Map)}\n * or {@link PreparedBatch#add(Object...)}.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch> implements ResultBearing {\n    private final List<Binding> bindings = new ArrayList<>();\n\n    public PreparedBatch(Handle handle, String sql) {\n        super(handle, sql);\n    }\n\n    @Override\n    public <R> R scanResultSet(ResultSetScanner<R> mapper) {\n        return execute(ResultProducers.returningResults()).scanResultSet(mapper);\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        try {\n            return internalBatchExecute().updateCounts;\n        } finally {\n            getContext().close();\n        }\n    }\n\n    public ResultIterator<Integer> executeAndGetModCount() {\n        StatementContext ctx = getContext();\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return ctx;\n            }\n\n            @Override\n            public void close() {\n                ctx.close();\n            }\n        };\n    }\n\n    public ResultBearing executeAndReturnGeneratedKeys(String... columnNames) {\n        return execute(returningGeneratedKeys(columnNames));\n    }\n\n    /**\n     * Executes the batch, returning the result obtained from the given {@link ResultProducer}.\n     *\n     * @param <R> the type of the result\n     * @param producer the result producer.\n     * @return value returned by the result producer.\n     */\n    public <R> R execute(ResultProducer<R> producer) {\n        try {\n            return producer.produce(() -> internalBatchExecute().stmt, getContext());\n        } catch (SQLException e) {\n            try {\n                close();\n            } catch (Exception e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToProduceResultException(\"Exception producing batch result\", e, getContext());\n        }\n    }\n\n    private ExecutedBatch internalBatchExecute() {\n        if (!getBinding().isEmpty()) {\n            add();\n        }\n\n        beforeTemplating();\n\n        final StatementContext ctx = getContext();\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(getSql(), ctx);\n        ctx.setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, ctx);\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n        ctx.setParsedSql(parsedSql);\n\n        try {\n            try {\n                StatementBuilder statementBuilder = getHandle().getStatementBuilder();\n                @SuppressWarnings(\"PMD.CloseResource\")\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, ctx);\n\n                addCleanable(() -> statementBuilder.close(connection, sql, stmt));\n                getConfig(SqlStatements.class).customize(stmt);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, ctx);\n            }\n\n            beforeBinding();\n\n            try {\n                ArgumentBinder binder = ArgumentBinder.of(ctx, parsedParameters);\n                for (Binding binding : bindings) {\n                    ctx.setBinding(binding);\n                    binder.bind(binding, stmt, ctx);\n                    stmt.addBatch();\n                }\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, ctx);\n            }\n\n            beforeExecution();\n\n            try {\n                final int[] rs = SqlLoggerUtil.wrap(stmt::executeBatch, ctx, getConfig(SqlStatements.class).getSqlLogger());\n\n                afterExecution();\n\n                ctx.setBinding(new Binding(ctx));\n\n                return new ExecutedBatch(stmt, rs);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), ctx);\n            }\n        } finally {\n            bindings.clear();\n        }\n    }\n\n    /**\n     * Add the current binding as a saved batch and clear the binding.\n     * @return this\n     */\n    public PreparedBatch add() {\n        final Binding currentBinding = getBinding();\n        if (currentBinding.isEmpty()) {\n            throw new IllegalStateException(\"Attempt to add() an empty batch, you probably didn't mean to do this \"\n                    + \"- call add() *after* setting batch parameters\");\n        }\n        bindings.add(currentBinding);\n        getContext().setBinding(new Binding(getContext()));\n        return this;\n    }\n\n    /**\n     * Bind arguments positionally, add the binding as a saved batch, and\n     * then clear the current binding.\n     * @param args the positional arguments to bind\n     * @return this\n     */\n    public PreparedBatch add(Object... args) {\n        for (int i = 0; i < args.length; i++) {\n            bind(i, args[i]);\n        }\n        add();\n        return this;\n    }\n\n    /**\n     * Bind arguments from a Map, add the binding as a saved batch,\n     * then clear the current binding.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     * @return this\n     */\n    public PreparedBatch add(Map<String, ?> args) {\n        bindMap(args);\n        add();\n        return this;\n    }\n\n    /**\n     * @return the number of bindings which are in this batch\n     */\n    public int size() {\n        return bindings.size();\n    }\n\n    private static class ExecutedBatch {\n        final PreparedStatement stmt;\n        final int[] updateCounts;\n\n        ExecutedBatch(PreparedStatement stmt, int[] updateCounts) {\n            this.stmt = stmt;\n            this.updateCounts = Arrays.copyOf(updateCounts, updateCounts.length);\n        }\n    }\n}\n","lineNo":134}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.internal.JdbiOptionals;\n/**\n * Represents the arguments bound to a particular statement.\n */\npublic class Binding {\n    private final Map<Integer, Argument> positionals = new HashMap<>();\n    private final Map<String, Argument> named = new HashMap<>();\n    private final List<NamedArgumentFinder> namedArgumentFinder = new ArrayList<>();\n\n    /**\n     * Bind a positional parameter at the given index (0-based).\n     * @param position binding position\n     * @param argument the argument to bind\n     */\n    public void addPositional(int position, Argument argument) {\n        positionals.put(position, argument);\n    }\n\n    /**\n     * Bind a named parameter for the given name.\n     * @param name bound argument name\n     * @param argument the argument to bind\n     */\n    public void addNamed(String name, Argument argument) {\n        this.named.put(name, argument);\n    }\n\n    /**\n     * Bind a named argument finder.\n     * @param args the argument finder to bind\n     */\n    public void addNamedArgumentFinder(NamedArgumentFinder args) {\n        namedArgumentFinder.add(args);\n    }\n\n    /**\n     * Look up an argument by name.\n     *\n     * @param name the key to lookup the value of\n     * @param ctx the statement context\n     *\n     * @return the bound Argument\n     */\n    public Optional<Argument> findForName(String name, StatementContext ctx) {\n        if (named.containsKey(name)) {\n            return Optional.of(named.get(name));\n        }\n\n        return namedArgumentFinder.stream()\n                .flatMap(arguments -> JdbiOptionals.stream(arguments.find(name, ctx)))\n                .findFirst();\n    }\n\n    /**\n     * @return the set of known binding names\n     */\n    public Collection<String> getNames() {\n        final Set<String> names = new HashSet<>(named.keySet());\n        namedArgumentFinder.forEach(args -> names.addAll(args.getNames()));\n        return Collections.unmodifiableSet(names);\n    }\n\n    /**\n     * Look up an argument by position.\n     *\n     * @param position starts at 0, not 1\n     * @return argument bound to that position\n     */\n    public Optional<Argument> findForPosition(int position) {\n        return Optional.ofNullable(positionals.get(position));\n    }\n\n    @Override\n    public String toString() {\n        String positionalsDescription = positionals.entrySet().stream()\n            .map(x -> x.getKey().toString() + ':' + x.getValue())\n            .collect(Collectors.joining(\",\"));\n\n        String namedDescription = named.entrySet().stream()\n            .map(x -> x.getKey() + ':' + x.getValue())\n            .collect(Collectors.joining(\",\"));\n\n        String found = namedArgumentFinder.stream()\n            .map(Object::toString)\n            .collect(Collectors.joining(\",\"));\n\n        return \"{positional:{\" + positionalsDescription + \"}, named:{\" + namedDescription + \"}, finder:[\" + found + \"]}\";\n    }\n\n    /**\n     * Remove all bindings from this Binding.\n     */\n    public void clear() {\n        positionals.clear();\n        named.clear();\n        namedArgumentFinder.clear();\n    }\n\n    /**\n     * @return true if there are no bindings yet\n     */\n    public boolean isEmpty() {\n        return positionals.isEmpty() && named.isEmpty() && namedArgumentFinder.isEmpty();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.internal.JdbiOptionals;\n/**\n * Represents the arguments bound to a particular statement.\n */\npublic class Binding {\n    private final Map<Integer, Argument> positionals = new HashMap<>();\n    private final Map<String, Argument> named = new HashMap<>();\n    private final List<NamedArgumentFinder> namedArgumentFinder = new ArrayList<>();\n\n    /**\n     * Bind a positional parameter at the given index (0-based).\n     * @param position binding position\n     * @param argument the argument to bind\n     */\n    public void addPositional(int position, Argument argument) {\n        positionals.put(position, argument);\n    }\n\n    /**\n     * Bind a named parameter for the given name.\n     * @param name bound argument name\n     * @param argument the argument to bind\n     */\n    public void addNamed(String name, Argument argument) {\n        this.named.put(name, argument);\n    }\n\n    /**\n     * Bind a named argument finder.\n     * @param args the argument finder to bind\n     */\n    public void addNamedArgumentFinder(NamedArgumentFinder args) {\n        namedArgumentFinder.add(args);\n    }\n\n    /**\n     * Look up an argument by name.\n     *\n     * @param name the key to lookup the value of\n     * @param ctx the statement context\n     *\n     * @return the bound Argument\n     */\n    public Optional<Argument> findForName(String name, StatementContext ctx) {\n        final Argument found = named.get(name);\n        if (found != null) {\n            return Optional.of(found);\n        }\n\n        return namedArgumentFinder.stream()\n                .flatMap(arguments -> JdbiOptionals.stream(arguments.find(name, ctx)))\n                .findFirst();\n    }\n\n    /**\n     * @return the set of known binding names\n     */\n    public Collection<String> getNames() {\n        final Set<String> names = new HashSet<>(named.keySet());\n        namedArgumentFinder.forEach(args -> names.addAll(args.getNames()));\n        return Collections.unmodifiableSet(names);\n    }\n\n    /**\n     * Look up an argument by position.\n     *\n     * @param position starts at 0, not 1\n     * @return argument bound to that position\n     */\n    public Optional<Argument> findForPosition(int position) {\n        return Optional.ofNullable(positionals.get(position));\n    }\n\n    @Override\n    public String toString() {\n        String positionalsDescription = positionals.entrySet().stream()\n            .map(x -> x.getKey().toString() + ':' + x.getValue())\n            .collect(Collectors.joining(\",\"));\n\n        String namedDescription = named.entrySet().stream()\n            .map(x -> x.getKey() + ':' + x.getValue())\n            .collect(Collectors.joining(\",\"));\n\n        String found = namedArgumentFinder.stream()\n            .map(Object::toString)\n            .collect(Collectors.joining(\",\"));\n\n        return \"{positional:{\" + positionalsDescription + \"}, named:{\" + namedDescription + \"}, finder:[\" + found + \"]}\";\n    }\n\n    /**\n     * Remove all bindings from this Binding.\n     */\n    public void clear() {\n        positionals.clear();\n        named.clear();\n        namedArgumentFinder.clear();\n    }\n\n    /**\n     * @return true if there are no bindings yet\n     */\n    public boolean isEmpty() {\n        return positionals.isEmpty() && named.isEmpty() && namedArgumentFinder.isEmpty();\n    }\n}\n","lineNo":73}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.postgres.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.EnumSet;\n\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.statement.StatementContext;\n\npublic class BitStringEnumSetArgument implements Argument {\n\n    private Enum<?>[] enumConstants;\n    private EnumSet<?> elements;\n\n    public BitStringEnumSetArgument(Class<Enum<?>> enumType, EnumSet<?> elements) {\n        this.elements = elements;\n        enumConstants = enumType.getEnumConstants();\n    }\n\n    @Override\n    public void apply(int position, PreparedStatement statement, StatementContext ctx) throws SQLException {\n        if (elements == null) {\n            statement.setString(position, null);\n            return;\n        }\n\n        char[] bits = new char[enumConstants.length];\n        for (int i = 0; i < enumConstants.length; i++) {\n            bits[i] = elements.contains(enumConstants[i]) ? '1' : '0';\n        }\n        statement.setString(position, new String(bits));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.postgres.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.EnumSet;\n\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.statement.StatementContext;\n\nimport static java.util.stream.Collectors.joining;\n\npublic class BitStringEnumSetArgument<E extends Enum<E>> implements Argument {\n    private final E[] enumConstants;\n    private final EnumSet<E> elements;\n\n    BitStringEnumSetArgument(Class<E> enumType, EnumSet<E> elements) {\n        enumConstants = enumType.getEnumConstants();\n        this.elements = elements;\n    }\n\n    @Override\n    public void apply(int position, PreparedStatement statement, StatementContext ctx) throws SQLException {\n        String bits = elements == null ? null : Arrays.stream(enumConstants)\n            .map(value -> elements.contains(value) ? \"1\" : \"0\")\n            .collect(joining());\n\n        statement.setString(position, bits);\n    }\n}\n","lineNo":37}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\n\n/**\n * Plugin that installs the SqlObject extension.\n */\npublic class SqlObjectPlugin implements JdbiPlugin {\n    @Override\n    public void customizeJdbi(Jdbi db) {\n        db.registerExtension(new SqlObjectFactory());\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.internal.OnDemandExtensions;\nimport org.jdbi.v3.core.spi.JdbiPlugin;\n\n/**\n * Plugin that installs the SqlObject extension.\n */\npublic class SqlObjectPlugin implements JdbiPlugin {\n    @Override\n    public void customizeJdbi(Jdbi db) {\n        SqlObjectFactory factory = new SqlObjectFactory();\n        db.registerExtension(factory);\n        db.getConfig(OnDemandExtensions.class).setFactory(factory);\n    }\n}\n","lineNo":26}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizer.internal;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.time.LocalDate;\nimport java.time.LocalTime;\nimport java.time.Month;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneOffset;\nimport java.time.temporal.ChronoUnit;\n\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.statement.SqlLogger;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.sqlobject.MockClock;\nimport org.jdbi.v3.sqlobject.SqlObjectPlugin;\nimport org.jdbi.v3.sqlobject.config.RegisterRowMapper;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.BindBean;\nimport org.jdbi.v3.sqlobject.customizer.Timestamped;\nimport org.jdbi.v3.sqlobject.customizer.TimestampedConfig;\nimport org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.testing.JdbiRule;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for the {@link Timestamped} annotation\n */\npublic class TestTimestamped {\n    private static final ZoneOffset GMT_PLUS_2 = ZoneOffset.ofHours(2);\n    private static final OffsetDateTime UTC_MOMENT = OffsetDateTime.of(LocalDate.of(2018, Month.JANUARY, 1), LocalTime.NOON, ZoneOffset.UTC);\n\n    @Rule\n    public JdbiRule dbRule = JdbiRule.h2().withPlugin(new SqlObjectPlugin());\n    private PersonDAO personDAO;\n\n    private OffsetDateTime insertedTimestamp;\n    private Timestamp insertedSqlTimestamp;\n\n    private final MockClock clock = MockClock.at(UTC_MOMENT.toZonedDateTime());\n\n    @Before\n    public void before() {\n        TimestampedFactory.setTimeSource(clock::withZone);\n        dbRule.getJdbi().getConfig(TimestampedConfig.class).setTimezone(GMT_PLUS_2);\n\n        personDAO = dbRule.getJdbi().onDemand(PersonDAO.class);\n        personDAO.createTable();\n    }\n\n    @Test\n    public void shouldInsertCreatedAndModifiedFields() {\n        Person input = new Person(\"John\", \"Phiri\");\n        input.setId(1);\n\n        recordNextTimestamp(\"now\");\n        personDAO.insert(input);\n        assertThat(insertedTimestamp.getOffset()).isEqualTo(GMT_PLUS_2);\n        assertThat(insertedTimestamp.toInstant()).isEqualTo(UTC_MOMENT.toInstant());\n\n        Person result = personDAO.get(1);\n\n        assertThat(result.getCreated())\n            .isEqualTo(result.getModified())\n            .isEqualTo(insertedSqlTimestamp);\n    }\n\n    @Test\n    public void shouldAllowCustomTimestampParameter() {\n        Person input = new Person(\"John\", \"Phiri\");\n        input.setId(1);\n\n        recordNextTimestamp(\"createdAt\");\n        personDAO.insertWithCustomTimestampFields(input);\n        assertThat(insertedTimestamp.getOffset()).isEqualTo(GMT_PLUS_2);\n        assertThat(insertedTimestamp.toInstant()).isEqualTo(UTC_MOMENT.toInstant());\n\n        Person result = personDAO.get(1);\n\n        assertThat(result.getFirstName()).isEqualTo(input.getFirstName());\n        assertThat(result.getLastName()).isEqualTo(input.getLastName());\n        assertThat(result.getCreated())\n            .isEqualTo(result.getModified())\n            .isEqualTo(insertedSqlTimestamp);\n    }\n\n    @Test\n    public void shouldUpdateModifiedTimestamp() {\n        Person input = new Person(\"John\", \"Phiri\");\n        input.setId(3);\n\n        recordNextTimestamp(\"now\");\n        personDAO.insert(input);\n        Timestamp insert = insertedSqlTimestamp;\n\n        Person fetched = personDAO.get(3);\n        fetched.setLastName(\"Banda\");\n        clock.advance(1, ChronoUnit.SECONDS);\n\n        recordNextTimestamp(\"now\");\n        personDAO.updatePerson(fetched);\n        Timestamp update = insertedSqlTimestamp;\n\n        Person result = personDAO.get(3);\n\n        assertThat(insert).isNotEqualTo(update);\n        assertThat(result.getLastName()).isEqualToIgnoringCase(\"Banda\");\n        assertThat(result.getCreated()).isEqualTo(insert);\n        assertThat(result.getModified()).isEqualTo(update);\n    }\n\n    @RegisterRowMapper(PersonRowMapper.class)\n    public interface PersonDAO {\n        @SqlUpdate(\"CREATE TABLE people(id identity primary key, firstName varchar(50), lastName varchar(50), created timestamp, modified timestamp);\")\n        void createTable();\n\n        @GetGeneratedKeys\n        @SqlUpdate(\"INSERT INTO people(id, firstName, lastName, created, modified) VALUES (:p.id, :p.firstName, :p.lastName, :now, :now)\")\n        @Timestamped\n        int insert(@BindBean(\"p\") Person person);\n\n        @SqlUpdate(\"INSERT INTO people(id, firstName, lastName, created, modified) VALUES (:p.id, :p.firstName, :p.lastName, :createdAt, :createdAt)\")\n        @Timestamped(\"createdAt\")\n        int insertWithCustomTimestampFields(@BindBean(\"p\") Person person);\n\n        @SqlUpdate(\"UPDATE people SET firstName = :p.firstName, lastName = :p.lastName, modified = :now WHERE id = :p.id\")\n        @Timestamped\n        int updatePerson(@BindBean(\"p\") Person person);\n\n        @SqlQuery(\"SELECT id, firstName, lastName, created, modified from people WHERE id=:id\")\n        Person get(@Bind(\"id\") int id);\n    }\n\n    private void recordNextTimestamp(String name) {\n        final Jdbi jdbi = dbRule.getJdbi();\n\n        jdbi.setSqlLogger(new SqlLogger() {\n            @Override\n            public void logBeforeExecution(StatementContext ctx) {\n                String toString = ctx.getBinding()\n                    .findForName(name, ctx)\n                    .orElseThrow(AssertionError::new)\n                    .toString();\n                insertedTimestamp = OffsetDateTime.parse(toString);\n                insertedSqlTimestamp = Timestamp.from(insertedTimestamp.toInstant());\n            }\n\n            @Override\n            public void logAfterExecution(StatementContext context) {\n                jdbi.setSqlLogger(SqlLogger.NOP_SQL_LOGGER);\n            }\n\n            @Override\n            public void logException(StatementContext context, SQLException ex) {\n                jdbi.setSqlLogger(SqlLogger.NOP_SQL_LOGGER);\n            }\n        });\n    }\n\n    public static final class PersonRowMapper implements RowMapper<Person> {\n        @Override\n        public Person map(ResultSet resultSet, StatementContext statementContext) throws SQLException {\n            Person person = new Person(resultSet.getString(\"firstName\"), resultSet.getString(\"lastName\"));\n            person.setId(resultSet.getInt(\"id\"));\n            person.setCreated(resultSet.getTimestamp(\"created\"));\n            person.setModified(resultSet.getTimestamp(\"modified\"));\n            return person;\n        }\n    }\n\n    /**\n     * Person JavaBean for tests\n     */\n    public static final class Person {\n        private int id;\n\n        private String firstName;\n\n        private String lastName;\n\n        private Timestamp created;\n\n        private Timestamp modified;\n\n        public Person(String firstName, String lastName) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n\n        public int getId() {\n            return id;\n        }\n\n        public void setId(int id) {\n            this.id = id;\n        }\n\n        public String getFirstName() {\n            return firstName;\n        }\n\n        public void setFirstName(String firstName) {\n            this.firstName = firstName;\n        }\n\n        public String getLastName() {\n            return lastName;\n        }\n\n        public void setLastName(String lastName) {\n            this.lastName = lastName;\n        }\n\n        public Timestamp getCreated() {\n            return created;\n        }\n\n        public void setCreated(Timestamp created) {\n            this.created = created;\n        }\n\n        public Timestamp getModified() {\n            return modified;\n        }\n\n        public void setModified(Timestamp modified) {\n            this.modified = modified;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            Person person = (Person) o;\n\n            if (id != person.id) {\n                return false;\n            }\n            if (!firstName.equals(person.firstName)) {\n                return false;\n            }\n            return lastName != null ? lastName.equals(person.lastName) : person.lastName == null;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = id;\n            result = 31 * result + firstName.hashCode();\n            result = 31 * result + lastName.hashCode();\n            result = 31 * result + (created != null ? created.hashCode() : 0);\n            result = 31 * result + (modified != null ? modified.hashCode() : 0);\n            return result;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizer.internal;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.time.LocalDate;\nimport java.time.LocalTime;\nimport java.time.Month;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneOffset;\nimport java.time.temporal.ChronoUnit;\n\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.statement.SqlLogger;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.sqlobject.MockClock;\nimport org.jdbi.v3.sqlobject.SqlObjectPlugin;\nimport org.jdbi.v3.sqlobject.config.RegisterRowMapper;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.BindBean;\nimport org.jdbi.v3.sqlobject.customizer.Timestamped;\nimport org.jdbi.v3.sqlobject.customizer.TimestampedConfig;\nimport org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.jdbi.v3.testing.JdbiRule;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for the {@link Timestamped} annotation\n */\npublic class TestTimestamped {\n    private static final ZoneOffset GMT_PLUS_2 = ZoneOffset.ofHours(2);\n    private static final OffsetDateTime UTC_MOMENT = OffsetDateTime.of(LocalDate.of(2018, Month.JANUARY, 1), LocalTime.NOON, ZoneOffset.UTC);\n\n    @Rule\n    public JdbiRule dbRule = JdbiRule.h2().withPlugin(new SqlObjectPlugin());\n    private PersonDAO personDAO;\n\n    private static ThreadLocal<String> logNext = new ThreadLocal<>();\n    private static ThreadLocal<OffsetDateTime> insertedTimestamp = new ThreadLocal<>();\n\n    private final MockClock clock = MockClock.at(UTC_MOMENT.toZonedDateTime());\n\n    @Before\n    public void before() {\n        TimestampedFactory.setTimeSource(clock::withZone);\n        final Jdbi db = dbRule.getJdbi();\n        db.getConfig(TimestampedConfig.class).setTimezone(GMT_PLUS_2);\n\n        db.setSqlLogger(new SqlLogger() {\n            @Override\n            public void logBeforeExecution(StatementContext ctx) {\n                String name = logNext.get();\n                if (name != null) {\n                    String toString = ctx.getBinding()\n                        .findForName(name, ctx)\n                        .orElseThrow(AssertionError::new)\n                        .toString();\n                    insertedTimestamp.set(OffsetDateTime.parse(toString));\n                    logNext.set(null);\n                }\n            }\n        });\n\n        personDAO = db.onDemand(PersonDAO.class);\n        personDAO.createTable();\n    }\n\n    @Test\n    public void shouldInsertCreatedAndModifiedFields() {\n        Person input = new Person(\"John\", \"Phiri\");\n        input.setId(1);\n\n        logNext.set(\"now\");\n        personDAO.insert(input);\n        assertThat(insertedTimestamp.get().getOffset()).isEqualTo(GMT_PLUS_2);\n        assertThat(insertedTimestamp.get().toInstant()).isEqualTo(UTC_MOMENT.toInstant());\n\n        Person result = personDAO.get(1);\n\n        assertThat(result.getCreated())\n            .isEqualTo(result.getModified())\n            .isEqualTo(insertedSqlTimestamp());\n    }\n\n    @Test\n    public void shouldAllowCustomTimestampParameter() {\n        Person input = new Person(\"John\", \"Phiri\");\n        input.setId(1);\n\n        logNext.set(\"createdAt\");\n        personDAO.insertWithCustomTimestampFields(input);\n        assertThat(insertedTimestamp.get().getOffset()).isEqualTo(GMT_PLUS_2);\n        assertThat(insertedTimestamp.get().toInstant()).isEqualTo(UTC_MOMENT.toInstant());\n\n        Person result = personDAO.get(1);\n\n        assertThat(result.getFirstName()).isEqualTo(input.getFirstName());\n        assertThat(result.getLastName()).isEqualTo(input.getLastName());\n        assertThat(result.getCreated())\n            .isEqualTo(result.getModified())\n            .isEqualTo(insertedSqlTimestamp());\n    }\n\n    @Test\n    public void shouldUpdateModifiedTimestamp() {\n        Person input = new Person(\"John\", \"Phiri\");\n        input.setId(3);\n\n        logNext.set(\"now\");\n        personDAO.insert(input);\n        Timestamp insert = insertedSqlTimestamp();\n\n        Person fetched = personDAO.get(3);\n        fetched.setLastName(\"Banda\");\n        clock.advance(1, ChronoUnit.SECONDS);\n\n        logNext.set(\"now\");\n        personDAO.updatePerson(fetched);\n        Timestamp update = insertedSqlTimestamp();\n\n        Person result = personDAO.get(3);\n\n        assertThat(insert).isNotEqualTo(update);\n        assertThat(result.getLastName()).isEqualToIgnoringCase(\"Banda\");\n        assertThat(result.getCreated()).isEqualTo(insert);\n        assertThat(result.getModified()).isEqualTo(update);\n    }\n\n    private static Timestamp insertedSqlTimestamp() {\n        return Timestamp.from(insertedTimestamp.get().toInstant());\n    }\n\n    @RegisterRowMapper(PersonRowMapper.class)\n    public interface PersonDAO {\n        @SqlUpdate(\"CREATE TABLE people(id identity primary key, firstName varchar(50), lastName varchar(50), created timestamp, modified timestamp);\")\n        void createTable();\n\n        @GetGeneratedKeys\n        @SqlUpdate(\"INSERT INTO people(id, firstName, lastName, created, modified) VALUES (:p.id, :p.firstName, :p.lastName, :now, :now)\")\n        @Timestamped\n        int insert(@BindBean(\"p\") Person person);\n\n        @SqlUpdate(\"INSERT INTO people(id, firstName, lastName, created, modified) VALUES (:p.id, :p.firstName, :p.lastName, :createdAt, :createdAt)\")\n        @Timestamped(\"createdAt\")\n        int insertWithCustomTimestampFields(@BindBean(\"p\") Person person);\n\n        @SqlUpdate(\"UPDATE people SET firstName = :p.firstName, lastName = :p.lastName, modified = :now WHERE id = :p.id\")\n        @Timestamped\n        int updatePerson(@BindBean(\"p\") Person person);\n\n        @SqlQuery(\"SELECT id, firstName, lastName, created, modified from people WHERE id=:id\")\n        Person get(@Bind(\"id\") int id);\n    }\n\n    public static final class PersonRowMapper implements RowMapper<Person> {\n        @Override\n        public Person map(ResultSet resultSet, StatementContext statementContext) throws SQLException {\n            Person person = new Person(resultSet.getString(\"firstName\"), resultSet.getString(\"lastName\"));\n            person.setId(resultSet.getInt(\"id\"));\n            person.setCreated(resultSet.getTimestamp(\"created\"));\n            person.setModified(resultSet.getTimestamp(\"modified\"));\n            return person;\n        }\n    }\n\n    /**\n     * Person JavaBean for tests\n     */\n    public static final class Person {\n        private int id;\n\n        private String firstName;\n\n        private String lastName;\n\n        private Timestamp created;\n\n        private Timestamp modified;\n\n        public Person(String firstName, String lastName) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n\n        public int getId() {\n            return id;\n        }\n\n        public void setId(int id) {\n            this.id = id;\n        }\n\n        public String getFirstName() {\n            return firstName;\n        }\n\n        public void setFirstName(String firstName) {\n            this.firstName = firstName;\n        }\n\n        public String getLastName() {\n            return lastName;\n        }\n\n        public void setLastName(String lastName) {\n            this.lastName = lastName;\n        }\n\n        public Timestamp getCreated() {\n            return created;\n        }\n\n        public void setCreated(Timestamp created) {\n            this.created = created;\n        }\n\n        public Timestamp getModified() {\n            return modified;\n        }\n\n        public void setModified(Timestamp modified) {\n            this.modified = modified;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            Person person = (Person) o;\n\n            if (id != person.id) {\n                return false;\n            }\n            if (!firstName.equals(person.firstName)) {\n                return false;\n            }\n            return lastName != null ? lastName.equals(person.lastName) : person.lastName == null;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = id;\n            result = 31 * result + firstName.hashCode();\n            result = 31 * result + lastName.hashCode();\n            result = 31 * result + (created != null ? created.hashCode() : 0);\n            result = 31 * result + (modified != null ? modified.hashCode() : 0);\n            return result;\n        }\n    }\n}\n","lineNo":66}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.extension.ExtensionMethod;\n\nclass WithHandleMethodHandlerFactory implements HandlerFactory {\n    private static final Method WITH_HANDLE = Handlers.methodLookup(SqlObject.class, \"withHandle\", HandleCallback.class);\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Optional<Handler> buildHandler(Class<?> sqlObjectType, Method method) {\n        if (!WITH_HANDLE.equals(method)) {\n            return Optional.empty();\n        }\n        return Optional.of((t, a, h) ->\n            h.invokeInContext(\n                    new ExtensionMethod(sqlObjectType, method),\n                    h.getConfig(),\n                    () -> ((HandleCallback<?, RuntimeException>) a[0]).withHandle(h.getHandle())));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.extension.ExtensionMethod;\n\nclass WithHandleMethodHandlerFactory implements HandlerFactory {\n    private static final Method WITH_HANDLE = Handlers.methodLookup(SqlObject.class, \"withHandle\", HandleCallback.class);\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Optional<Handler> buildHandler(Class<?> sqlObjectType, Method method) {\n        if (!WITH_HANDLE.equals(method)) {\n            return Optional.empty();\n        }\n        ExtensionMethod extensionMethod = new ExtensionMethod(sqlObjectType, method);\n        return Optional.of((t, a, h) ->\n            h.invokeInContext(\n                    extensionMethod,\n                    h.getConfig(),\n                    () -> ((HandleCallback<?, RuntimeException>) a[0]).withHandle(h.getHandle())));\n    }\n}\n","lineNo":31}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.beans.ConstructorProperties;\nimport java.util.List;\nimport java.util.Map;\n\nimport com.google.common.collect.ImmutableMap;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.reflect.ConstructorMapper;\nimport org.jdbi.v3.core.rule.H2DatabaseRule;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.fail;\nimport static org.assertj.core.api.Assertions.tuple;\n\npublic class TestPreparedBatch {\n    @Rule\n    public H2DatabaseRule dbRule = new H2DatabaseRule().withSomething();\n\n    private Handle h;\n\n    @Before\n    public void openHandle() {\n        h = dbRule.openHandle();\n    }\n\n    @After\n    public void closeHandle() {\n        h.close();\n    }\n\n    @Test\n    public void emptyBatch() {\n        assertThat(h.prepareBatch(\"insert into something (id, name) values (:id, :name)\").execute()).isEmpty();\n    }\n\n    @Test\n    public void testBindBatch() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.bind(\"id\", 1).bind(\"name\", \"Eric\").add();\n        b.bind(\"id\", 2).bind(\"name\", \"Brian\").add();\n        b.bind(\"id\", 3).bind(\"name\", \"Keith\").add();\n        b.execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).hasSize(3);\n        assertThat(r.get(2).getName()).isEqualTo(\"Keith\");\n    }\n\n    @Test\n    public void testBigishBatch() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        int count = 100;\n        for (int i = 0; i < count; ++i) {\n            b.bind(\"id\", i).bind(\"name\", \"A Name\").add();\n\n        }\n        b.execute();\n\n        int rowCount = h.createQuery(\"select count(id) from something\").mapTo(int.class).one();\n\n        assertThat(rowCount).isEqualTo(count);\n    }\n\n    @Test\n    public void testBindProperties() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (?, ?)\");\n\n        b.add(0, \"Keith\");\n        b.add(1, \"Eric\");\n        b.add(2, \"Brian\");\n\n        b.execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).hasSize(3);\n        assertThat(r.get(2).getName()).isEqualTo(\"Brian\");\n    }\n\n    @Test\n    public void testBindMaps() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.add(ImmutableMap.of(\"id\", 0, \"name\", \"Keith\"));\n        b.add(ImmutableMap.of(\"id\", 1, \"name\", \"Eric\"));\n        b.add(ImmutableMap.of(\"id\", 2, \"name\", \"Brian\"));\n\n        b.execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).hasSize(3);\n        assertThat(r.get(2).getName()).isEqualTo(\"Brian\");\n    }\n\n    @Test\n    public void testMixedModeBatch() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        Map<String, Object> one = ImmutableMap.of(\"id\", 0);\n        b.bind(\"name\", \"Keith\").add(one);\n        b.execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).extracting(Something::getName).containsExactly(\"Keith\");\n    }\n\n    @Test\n    public void testPositionalBinding() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (?, ?)\");\n\n        b.bind(0, 0).bind(1, \"Keith\").add().execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).extracting(Something::getName).containsExactly(\"Keith\");\n    }\n\n    @Test\n    public void testForgotFinalAdd() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.bind(\"id\", 1);\n        b.bind(\"name\", \"Jeff\");\n        b.add();\n\n        b.bind(\"id\", 2);\n        b.bind(\"name\", \"Tom\");\n        // forgot to add() here but we fix it up\n\n        b.execute();\n\n        assertThat(h.createQuery(\"select name from something order by id\").mapTo(String.class).list())\n                .containsExactly(\"Jeff\", \"Tom\");\n    }\n\n    @Test\n    public void testContextGetsBinding() {\n        try {\n            h.prepareBatch(\"insert into something (id, name) values (:id, :name)\")\n                .bind(\"id\", 0)\n                .bind(\"name\", \"alice\")\n                .add()\n                .bind(\"id\", 0)\n                .bind(\"name\", \"bob\")\n                .add()\n                .execute();\n            fail(\"expected exception\");\n        } catch (UnableToExecuteStatementException e) {\n            final StatementContext ctx = e.getStatementContext();\n            assertThat(ctx.getBinding().findForName(\"name\", ctx).toString()).contains(\"bob\");\n        }\n    }\n\n    @Test\n    public void testMultipleExecuteBindBean() {\n        final PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.bindBean(new Something(1, \"Eric\")).add();\n        b.bindBean(new Something(2, \"Brian\")).add();\n        b.execute();\n\n        // bindings should be cleared after execute()\n\n        b.bindBean(new Something(3, \"Keith\")).add();\n        b.execute();\n\n        final List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).extracting(Something::getId, Something::getName)\n                .containsExactly(tuple(1, \"Eric\"), tuple(2, \"Brian\"), tuple(3, \"Keith\"));\n    }\n\n    @Test\n    public void testMultipleExecuteBind() {\n        final PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.bind(\"id\", 1).bind(\"name\", \"Eric\").add();\n        b.bind(\"id\", 2).bind(\"name\", \"Brian\").add();\n        b.execute();\n\n        // bindings should be cleared after execute()\n\n        b.bind(\"id\", 3).bind(\"name\", \"Keith\").add();\n        b.execute();\n\n        final List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).extracting(Something::getId, Something::getName)\n                .containsExactly(tuple(1, \"Eric\"), tuple(2, \"Brian\"), tuple(3, \"Keith\"));\n    }\n\n    @Test\n    public void testMultipleExecuteBindFields() {\n        h.registerRowMapper(ConstructorMapper.factory(PublicSomething.class));\n        final PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.bindFields(new PublicSomething(1, \"Eric\")).add();\n        b.bindFields(new PublicSomething(2, \"Brian\")).add();\n        b.execute();\n\n        // bindings should be cleared after execute()\n\n        b.bindFields(new PublicSomething(3, \"Keith\")).add();\n        b.execute();\n\n        final List<PublicSomething> r = h.createQuery(\"select * from something order by id\").mapTo(PublicSomething.class).list();\n        assertThat(r).extracting(s -> s.id, s -> s.name).containsExactly(tuple(1, \"Eric\"), tuple(2, \"Brian\"), tuple(3, \"Keith\"));\n    }\n\n    public static class PublicSomething {\n        public int id;\n        public String name;\n\n        @ConstructorProperties({\"id\", \"name\"})\n        public PublicSomething(Integer id, String name) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.beans.ConstructorProperties;\nimport java.util.List;\nimport java.util.Map;\n\nimport com.google.common.collect.ImmutableMap;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.reflect.ConstructorMapper;\nimport org.jdbi.v3.core.rule.H2DatabaseRule;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.fail;\nimport static org.assertj.core.api.Assertions.tuple;\n\npublic class TestPreparedBatch {\n    @Rule\n    public H2DatabaseRule dbRule = new H2DatabaseRule().withSomething();\n\n    private Handle h;\n\n    @Before\n    public void openHandle() {\n        h = dbRule.openHandle();\n    }\n\n    @After\n    public void closeHandle() {\n        h.close();\n    }\n\n    @Test\n    public void emptyBatch() {\n        final PreparedBatch batch = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n        assertThat(batch.execute()).isEmpty();\n        assertThat(batch.getContext().isClosed()).isTrue();\n    }\n\n    @Test\n    public void testBindBatch() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.bind(\"id\", 1).bind(\"name\", \"Eric\").add();\n        b.bind(\"id\", 2).bind(\"name\", \"Brian\").add();\n        b.bind(\"id\", 3).bind(\"name\", \"Keith\").add();\n        b.execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).hasSize(3);\n        assertThat(r.get(2).getName()).isEqualTo(\"Keith\");\n    }\n\n    @Test\n    public void testBigishBatch() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        int count = 100;\n        for (int i = 0; i < count; ++i) {\n            b.bind(\"id\", i).bind(\"name\", \"A Name\").add();\n\n        }\n        b.execute();\n\n        int rowCount = h.createQuery(\"select count(id) from something\").mapTo(int.class).one();\n\n        assertThat(rowCount).isEqualTo(count);\n    }\n\n    @Test\n    public void testBindProperties() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (?, ?)\");\n\n        b.add(0, \"Keith\");\n        b.add(1, \"Eric\");\n        b.add(2, \"Brian\");\n\n        b.execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).hasSize(3);\n        assertThat(r.get(2).getName()).isEqualTo(\"Brian\");\n    }\n\n    @Test\n    public void testBindMaps() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.add(ImmutableMap.of(\"id\", 0, \"name\", \"Keith\"));\n        b.add(ImmutableMap.of(\"id\", 1, \"name\", \"Eric\"));\n        b.add(ImmutableMap.of(\"id\", 2, \"name\", \"Brian\"));\n\n        b.execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).hasSize(3);\n        assertThat(r.get(2).getName()).isEqualTo(\"Brian\");\n    }\n\n    @Test\n    public void testMixedModeBatch() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        Map<String, Object> one = ImmutableMap.of(\"id\", 0);\n        b.bind(\"name\", \"Keith\").add(one);\n        b.execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).extracting(Something::getName).containsExactly(\"Keith\");\n    }\n\n    @Test\n    public void testPositionalBinding() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (?, ?)\");\n\n        b.bind(0, 0).bind(1, \"Keith\").add().execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).extracting(Something::getName).containsExactly(\"Keith\");\n    }\n\n    @Test\n    public void testForgotFinalAdd() {\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.bind(\"id\", 1);\n        b.bind(\"name\", \"Jeff\");\n        b.add();\n\n        b.bind(\"id\", 2);\n        b.bind(\"name\", \"Tom\");\n        // forgot to add() here but we fix it up\n\n        b.execute();\n\n        assertThat(h.createQuery(\"select name from something order by id\").mapTo(String.class).list())\n                .containsExactly(\"Jeff\", \"Tom\");\n    }\n\n    @Test\n    public void testContextGetsBinding() {\n        try {\n            h.prepareBatch(\"insert into something (id, name) values (:id, :name)\")\n                .bind(\"id\", 0)\n                .bind(\"name\", \"alice\")\n                .add()\n                .bind(\"id\", 0)\n                .bind(\"name\", \"bob\")\n                .add()\n                .execute();\n            fail(\"expected exception\");\n        } catch (UnableToExecuteStatementException e) {\n            final StatementContext ctx = e.getStatementContext();\n            assertThat(ctx.getBinding().findForName(\"name\", ctx).toString()).contains(\"bob\");\n        }\n    }\n\n    @Test\n    public void testMultipleExecuteBindBean() {\n        final PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.bindBean(new Something(1, \"Eric\")).add();\n        b.bindBean(new Something(2, \"Brian\")).add();\n        b.execute();\n\n        // bindings should be cleared after execute()\n\n        b.bindBean(new Something(3, \"Keith\")).add();\n        b.execute();\n\n        final List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).extracting(Something::getId, Something::getName)\n                .containsExactly(tuple(1, \"Eric\"), tuple(2, \"Brian\"), tuple(3, \"Keith\"));\n    }\n\n    @Test\n    public void testMultipleExecuteBind() {\n        final PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.bind(\"id\", 1).bind(\"name\", \"Eric\").add();\n        b.bind(\"id\", 2).bind(\"name\", \"Brian\").add();\n        b.execute();\n\n        // bindings should be cleared after execute()\n\n        b.bind(\"id\", 3).bind(\"name\", \"Keith\").add();\n        b.execute();\n\n        final List<Something> r = h.createQuery(\"select * from something order by id\").mapToBean(Something.class).list();\n        assertThat(r).extracting(Something::getId, Something::getName)\n                .containsExactly(tuple(1, \"Eric\"), tuple(2, \"Brian\"), tuple(3, \"Keith\"));\n    }\n\n    @Test\n    public void testMultipleExecuteBindFields() {\n        h.registerRowMapper(ConstructorMapper.factory(PublicSomething.class));\n        final PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b.bindFields(new PublicSomething(1, \"Eric\")).add();\n        b.bindFields(new PublicSomething(2, \"Brian\")).add();\n        b.execute();\n\n        // bindings should be cleared after execute()\n\n        b.bindFields(new PublicSomething(3, \"Keith\")).add();\n        b.execute();\n\n        final List<PublicSomething> r = h.createQuery(\"select * from something order by id\").mapTo(PublicSomething.class).list();\n        assertThat(r).extracting(s -> s.id, s -> s.name).containsExactly(tuple(1, \"Eric\"), tuple(2, \"Brian\"), tuple(3, \"Keith\"));\n    }\n\n    public static class PublicSomething {\n        public int id;\n        public String name;\n\n        @ConstructorProperties({\"id\", \"name\"})\n        public PublicSomething(Integer id, String name) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n}\n","lineNo":52}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.MethodType;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.JdbiCache;\nimport org.jdbi.v3.core.config.JdbiCaches;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.mapper.reflect.internal.PojoProperties.PojoProperty;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.qualifier.Qualifiers;\n\npublic interface ImmutablesPropertiesFactory {\n    @SuppressWarnings(\"unchecked\")\n    JdbiCache<ImmutableSpec<?, ?>, ImmutablePojoProperties<?, ?>> IMMUTABLE_CACHE =\n            JdbiCaches.declare(s -> s.type, ImmutablePojoProperties::new);\n    @SuppressWarnings(\"unchecked\")\n    JdbiCache<ModifiableSpec<?, ?>, ModifiablePojoProperties<?, ?>> MODIFIABLE_CACHE =\n            JdbiCaches.declare(s -> s.type, ModifiablePojoProperties::new);\n\n    PojoProperties<?> create(Type type, ConfigRegistry config);\n\n    static <T, B> ImmutablesPropertiesFactory immutable(Class<T> defn, Supplier<B> builder) {\n        return (t, config) -> IMMUTABLE_CACHE.get(new ImmutableSpec<>(t, config, defn, builder), config);\n    }\n\n    static <T, M extends T> ImmutablesPropertiesFactory modifiable(Class<T> defn, Class<M> impl, Supplier<M> constructor) {\n        return (t, config) -> MODIFIABLE_CACHE.get(new ModifiableSpec<>(t, config, defn, impl, constructor), config);\n    }\n\n    static MethodHandle alwaysSet() {\n        return MethodHandles.dropArguments(MethodHandles.constant(boolean.class, true), 0, Object.class);\n    }\n\n    abstract class BasePojoProperties<T, B> extends PojoProperties<T> {\n        private final Map<String, ImmutablesPojoProperty<T>> properties;\n        protected final ConfigRegistry config;\n        protected final Class<T> defn;\n        protected final Class<?> impl;\n        protected final Supplier<?> builder;\n\n        BasePojoProperties(Type type, ConfigRegistry config, Class<T> defn, Class<?> impl, Supplier<B> builder) {\n            super(type);\n            this.config = config;\n            this.defn = defn;\n            this.impl = impl;\n            this.builder = builder;\n            properties = Arrays.stream(defn.getMethods())\n                    .filter(BasePojoProperties::isProperty)\n                    .map(p -> createProperty(propertyName(p), p))\n                    .collect(Collectors.toMap(PojoProperty::getName, Function.identity()));\n        }\n\n        static String propertyName(Method m) {\n            final String[] prefixes = new String[] {\"get\", \"is\"};\n            final String name = m.getName();\n            for (String prefix : prefixes) {\n                if (name.startsWith(prefix)) {\n                    return chopPrefix(name, prefix.length());\n                }\n            }\n            return name;\n        }\n\n        private static String chopPrefix(final String name, int off) {\n            return name.substring(off, off + 1).toLowerCase() + name.substring(off + 1);\n        }\n\n        private static boolean isProperty(Method m) {\n            return m.getParameterCount() == 0\n                && !m.isSynthetic()\n                && !Modifier.isStatic(m.getModifiers())\n                && m.getDeclaringClass() != Object.class;\n        }\n\n        @Override\n        public Map<String, ImmutablesPojoProperty<T>> getProperties() {\n            return properties;\n        }\n\n        abstract ImmutablesPojoProperty<T> createProperty(String name, Method m);\n    }\n\n    class ImmutablePojoProperties<T, B> extends BasePojoProperties<T, B> {\n        private MethodHandle builderBuild;\n\n        ImmutablePojoProperties(ImmutableSpec<T, B> spec) {\n            super(spec.type, spec.config, spec.defn, null, spec.builder);\n            try {\n                builderBuild = MethodHandles.lookup().unreflect(builder.get().getClass().getMethod(\"build\"));\n            } catch (NoSuchMethodException | IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Failed to inspect Immutables \" + defn, e);\n            }\n        }\n        @Override\n        protected ImmutablesPojoProperty<T> createProperty(String name, Method m) {\n            final Class<?> builderClass = builder.get().getClass();\n            try {\n                final Type propertyType = GenericTypes.resolveType(m.getGenericReturnType(), getType());\n                return new ImmutablesPojoProperty<T>(\n                        name,\n                        QualifiedType.of(propertyType).withAnnotations(config.get(Qualifiers.class).findFor(m)),\n                        m,\n                        alwaysSet(),\n                        MethodHandles.lookup().unreflect(m).asFixedArity(),\n                        findBuilderSetter(builderClass, name, propertyType).asFixedArity());\n            } catch (IllegalAccessException | NoSuchMethodException e) {\n                throw new IllegalArgumentException(\"Failed to inspect method \" + m, e);\n            }\n        }\n\n        private MethodHandle findBuilderSetter(final Class<?> builderClass, String name, Type type)\n        throws IllegalAccessException, NoSuchMethodException {\n            final List<NoSuchMethodException> failures = new ArrayList<>();\n            final String setName = \"set\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n            final Set<String> names = new HashSet<>(Arrays.asList(setName, name));\n            for (String tryName : names) {\n                try {\n                    return MethodHandles.lookup().unreflect(builderClass.getMethod(tryName, GenericTypes.getErasedType(type)));\n                } catch (NoSuchMethodException e) {\n                    failures.add(e);\n                }\n            }\n            for (Method m : builderClass.getMethods()) {\n                if (names.contains(m.getName()) && m.getParameterCount() == 1) {\n                    return MethodHandles.lookup().unreflect(m);\n                }\n            }\n            final IllegalArgumentException iae = new IllegalArgumentException(\"Failed to find builder setter for property \" + name + \" on \" + builderClass);\n            failures.forEach(iae::addSuppressed);\n            return MethodHandles.dropArguments(\n                    MethodHandles.throwException(Object.class, IllegalArgumentException.class),\n                    1, Arrays.asList(Object.class, Object.class))\n                .bindTo(iae);\n        }\n\n        @Override\n        public PojoBuilder<T> create() {\n            final Object b = builder.get();\n            return new PojoBuilder<T>() {\n                @Override\n                public void set(String property, Object value) {\n                    Unchecked.biFunction(getProperties().get(property).setter::invoke).apply(b, value);\n                }\n\n                @Override\n                public T build() {\n                    return defn.cast(Unchecked.function(builderBuild::invoke).apply(b));\n                }\n            };\n        }\n    }\n\n    class ModifiablePojoProperties<T, M> extends BasePojoProperties<T, M> {\n        ModifiablePojoProperties(ModifiableSpec<T, M> spec) {\n            super(spec.type, spec.config, spec.defn, spec.impl, spec.constructor);\n        }\n\n        @Override\n        protected ImmutablesPojoProperty<T> createProperty(String name, Method m) {\n            final Type propertyType = GenericTypes.resolveType(m.getGenericReturnType(), getType());\n            try {\n                return new ImmutablesPojoProperty<T>(\n                        name,\n                        QualifiedType.of(propertyType).withAnnotations(config.get(Qualifiers.class).findFor(m)),\n                        m,\n                        isSetMethod(name),\n                        MethodHandles.lookup().unreflect(m).asFixedArity(),\n                        MethodHandles.lookup().findVirtual(impl, setterName(name), MethodType.methodType(impl, GenericTypes.getErasedType(propertyType))).asFixedArity());\n            } catch (IllegalAccessException | NoSuchMethodException e) {\n                throw new IllegalArgumentException(\"Failed to inspect method \" + m, e);\n            }\n        }\n\n        private MethodHandle isSetMethod(String name) {\n            try {\n                return MethodHandles.lookup().findVirtual(impl, name + \"IsSet\", MethodType.methodType(boolean.class));\n            } catch (NoSuchMethodException e) {\n                // not optional field\n                return alwaysSet();\n            } catch (IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Failed to find IsSet method for \" + name, e);\n            }\n        }\n\n        private String setterName(String name) {\n            return \"set\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n        }\n\n        @Override\n        public PojoBuilder<T> create() {\n            final Object instance = builder.get();\n            return new PojoBuilder<T>() {\n                @Override\n                public void set(String property, Object value) {\n                    Unchecked.biFunction(getProperties().get(property).setter::invoke).apply(instance, value);\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public T build() {\n                    return (T) instance;\n                }\n            };\n        }\n    }\n\n    class ImmutablesPojoProperty<T> implements PojoProperty<T> {\n        private final String name;\n        private final QualifiedType<?> type;\n        private final Method defn;\n        private final MethodHandle isSet;\n        private final MethodHandle getter;\n        final MethodHandle setter;\n\n        ImmutablesPojoProperty(String name, QualifiedType<?> type, Method defn, MethodHandle isSet, MethodHandle getter, MethodHandle setter) {\n            this.name = name;\n            this.type = type;\n            this.defn = defn;\n            this.isSet = isSet;\n            this.getter = getter;\n            this.setter = setter;\n        }\n\n        @Override\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public QualifiedType<?> getQualifiedType() {\n            return type;\n        }\n\n        @Override\n        public <A extends Annotation> Optional<A> getAnnotation(Class<A> anno) {\n            return Optional.ofNullable(defn.getAnnotation(anno));\n        }\n\n        @Override\n        public Object get(T pojo) {\n            return Unchecked.callable(() -> {\n                if (Boolean.TRUE.equals(isSet.invoke(pojo))) {\n                    return getter.invoke(pojo);\n                } else {\n                    return null;\n                }\n            }).call();\n        }\n    }\n\n    class ImmutableSpec<T, B> {\n        Type type;\n        ConfigRegistry config;\n        Class<T> defn;\n        Supplier<B> builder;\n\n        ImmutableSpec(Type type, ConfigRegistry config, Class<T> defn, Supplier<B> builder) {\n            this.type = type;\n            this.config = config;\n            this.defn = defn;\n            this.builder = builder;\n        }\n    }\n\n    class ModifiableSpec<T, M> {\n        Type type;\n        ConfigRegistry config;\n        Class<T> defn;\n        Class<M> impl;\n        Supplier<M> constructor;\n\n        ModifiableSpec(Type type, ConfigRegistry config, Class<T> defn, Class<M> impl, Supplier<M> constructor) {\n            this.type = type;\n            this.config = config;\n            this.defn = defn;\n            this.impl = impl;\n            this.constructor = constructor;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.MethodType;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.config.JdbiCache;\nimport org.jdbi.v3.core.config.JdbiCaches;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.internal.exceptions.Unchecked;\nimport org.jdbi.v3.core.mapper.reflect.internal.PojoProperties.PojoProperty;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.qualifier.Qualifiers;\n\npublic interface ImmutablesPropertiesFactory {\n    @SuppressWarnings(\"unchecked\")\n    JdbiCache<ImmutableSpec<?, ?>, ImmutablePojoProperties<?, ?>> IMMUTABLE_CACHE =\n            JdbiCaches.declare(s -> s.type, ImmutablePojoProperties::new);\n    @SuppressWarnings(\"unchecked\")\n    JdbiCache<ModifiableSpec<?, ?>, ModifiablePojoProperties<?, ?>> MODIFIABLE_CACHE =\n            JdbiCaches.declare(s -> s.type, ModifiablePojoProperties::new);\n\n    PojoProperties<?> create(Type type, ConfigRegistry config);\n\n    static <T, B> ImmutablesPropertiesFactory immutable(Class<T> defn, Supplier<B> builder) {\n        return (t, config) -> IMMUTABLE_CACHE.get(new ImmutableSpec<>(t, config, defn, builder), config);\n    }\n\n    static <T, M extends T> ImmutablesPropertiesFactory modifiable(Class<T> defn, Class<M> impl, Supplier<M> constructor) {\n        return (t, config) -> MODIFIABLE_CACHE.get(new ModifiableSpec<>(t, config, defn, impl, constructor), config);\n    }\n\n    static MethodHandle alwaysSet() {\n        return MethodHandles.dropArguments(MethodHandles.constant(boolean.class, true), 0, Object.class);\n    }\n\n    abstract class BasePojoProperties<T, B> extends PojoProperties<T> {\n        private final Map<String, ImmutablesPojoProperty<T>> properties;\n        protected final ConfigRegistry config;\n        protected final Class<T> defn;\n        protected final Class<?> impl;\n        protected final Supplier<?> builder;\n\n        BasePojoProperties(Type type, ConfigRegistry config, Class<T> defn, Class<?> impl, Supplier<B> builder) {\n            super(type);\n            this.config = config;\n            this.defn = defn;\n            this.impl = impl;\n            this.builder = builder;\n            properties = Arrays.stream(defn.getMethods())\n                    .filter(BasePojoProperties::isProperty)\n                    .map(p -> createProperty(propertyName(p), p))\n                    .collect(Collectors.toMap(PojoProperty::getName, Function.identity()));\n        }\n\n        static String propertyName(Method m) {\n            final String[] prefixes = new String[] {\"get\", \"is\"};\n            final String name = m.getName();\n            for (String prefix : prefixes) {\n                if (name.startsWith(prefix)\n                    && name.length() > prefix.length()\n                    && Character.isUpperCase(name.charAt(prefix.length()))) {\n                    return chopPrefix(name, prefix.length());\n                }\n            }\n            return name;\n        }\n\n        private static String chopPrefix(final String name, int off) {\n            return name.substring(off, off + 1).toLowerCase() + name.substring(off + 1);\n        }\n\n        private static boolean isProperty(Method m) {\n            return m.getParameterCount() == 0\n                && !m.isSynthetic()\n                && !Modifier.isStatic(m.getModifiers())\n                && m.getDeclaringClass() != Object.class;\n        }\n\n        @Override\n        public Map<String, ImmutablesPojoProperty<T>> getProperties() {\n            return properties;\n        }\n\n        abstract ImmutablesPojoProperty<T> createProperty(String name, Method m);\n    }\n\n    class ImmutablePojoProperties<T, B> extends BasePojoProperties<T, B> {\n        private MethodHandle builderBuild;\n\n        ImmutablePojoProperties(ImmutableSpec<T, B> spec) {\n            super(spec.type, spec.config, spec.defn, null, spec.builder);\n            try {\n                builderBuild = MethodHandles.lookup().unreflect(builder.get().getClass().getMethod(\"build\"));\n            } catch (NoSuchMethodException | IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Failed to inspect Immutables \" + defn, e);\n            }\n        }\n        @Override\n        protected ImmutablesPojoProperty<T> createProperty(String name, Method m) {\n            final Class<?> builderClass = builder.get().getClass();\n            try {\n                final Type propertyType = GenericTypes.resolveType(m.getGenericReturnType(), getType());\n                return new ImmutablesPojoProperty<T>(\n                        name,\n                        QualifiedType.of(propertyType).withAnnotations(config.get(Qualifiers.class).findFor(m)),\n                        m,\n                        alwaysSet(),\n                        MethodHandles.lookup().unreflect(m).asFixedArity(),\n                        findBuilderSetter(builderClass, name, propertyType).asFixedArity());\n            } catch (IllegalAccessException | NoSuchMethodException e) {\n                throw new IllegalArgumentException(\"Failed to inspect method \" + m, e);\n            }\n        }\n\n        private MethodHandle findBuilderSetter(final Class<?> builderClass, String name, Type type)\n        throws IllegalAccessException, NoSuchMethodException {\n            final List<NoSuchMethodException> failures = new ArrayList<>();\n            final Set<String> names = new LinkedHashSet<>();\n            if (name.length() > 1) {\n                final String rest = name.substring(0, 1).toUpperCase() + name.substring(1);\n                names.add(\"set\" + rest);\n                names.add(\"is\" + rest);\n            }\n            names.add(name);\n            for (String tryName : names) {\n                try {\n                    return MethodHandles.lookup().unreflect(builderClass.getMethod(tryName, GenericTypes.getErasedType(type)));\n                } catch (NoSuchMethodException e) {\n                    failures.add(e);\n                }\n            }\n            for (Method m : builderClass.getMethods()) {\n                if (names.contains(m.getName()) && m.getParameterCount() == 1) {\n                    return MethodHandles.lookup().unreflect(m);\n                }\n            }\n            final IllegalArgumentException iae = new IllegalArgumentException(\"Failed to find builder setter for property \" + name + \" on \" + builderClass);\n            failures.forEach(iae::addSuppressed);\n            return MethodHandles.dropArguments(\n                    MethodHandles.throwException(Object.class, IllegalArgumentException.class),\n                    1, Arrays.asList(Object.class, Object.class))\n                .bindTo(iae);\n        }\n\n        @Override\n        public PojoBuilder<T> create() {\n            final Object b = builder.get();\n            return new PojoBuilder<T>() {\n                @Override\n                public void set(String property, Object value) {\n                    Unchecked.biFunction(getProperties().get(property).setter::invoke).apply(b, value);\n                }\n\n                @Override\n                public T build() {\n                    return defn.cast(Unchecked.function(builderBuild::invoke).apply(b));\n                }\n            };\n        }\n    }\n\n    class ModifiablePojoProperties<T, M> extends BasePojoProperties<T, M> {\n        ModifiablePojoProperties(ModifiableSpec<T, M> spec) {\n            super(spec.type, spec.config, spec.defn, spec.impl, spec.constructor);\n        }\n\n        @Override\n        protected ImmutablesPojoProperty<T> createProperty(String name, Method m) {\n            final Type propertyType = GenericTypes.resolveType(m.getGenericReturnType(), getType());\n            try {\n                return new ImmutablesPojoProperty<T>(\n                        name,\n                        QualifiedType.of(propertyType).withAnnotations(config.get(Qualifiers.class).findFor(m)),\n                        m,\n                        isSetMethod(name),\n                        MethodHandles.lookup().unreflect(m).asFixedArity(),\n                        MethodHandles.lookup().findVirtual(impl, setterName(name), MethodType.methodType(impl, GenericTypes.getErasedType(propertyType))).asFixedArity());\n            } catch (IllegalAccessException | NoSuchMethodException e) {\n                throw new IllegalArgumentException(\"Failed to inspect method \" + m, e);\n            }\n        }\n\n        private MethodHandle isSetMethod(String name) {\n            try {\n                return MethodHandles.lookup().findVirtual(impl, name + \"IsSet\", MethodType.methodType(boolean.class));\n            } catch (NoSuchMethodException e) {\n                // not optional field\n                return alwaysSet();\n            } catch (IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Failed to find IsSet method for \" + name, e);\n            }\n        }\n\n        private String setterName(String name) {\n            return \"set\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n        }\n\n        @Override\n        public PojoBuilder<T> create() {\n            final Object instance = builder.get();\n            return new PojoBuilder<T>() {\n                @Override\n                public void set(String property, Object value) {\n                    Unchecked.biFunction(getProperties().get(property).setter::invoke).apply(instance, value);\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public T build() {\n                    return (T) instance;\n                }\n            };\n        }\n    }\n\n    class ImmutablesPojoProperty<T> implements PojoProperty<T> {\n        private final String name;\n        private final QualifiedType<?> type;\n        private final Method defn;\n        private final MethodHandle isSet;\n        private final MethodHandle getter;\n        final MethodHandle setter;\n\n        ImmutablesPojoProperty(String name, QualifiedType<?> type, Method defn, MethodHandle isSet, MethodHandle getter, MethodHandle setter) {\n            this.name = name;\n            this.type = type;\n            this.defn = defn;\n            this.isSet = isSet;\n            this.getter = getter;\n            this.setter = setter;\n        }\n\n        @Override\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public QualifiedType<?> getQualifiedType() {\n            return type;\n        }\n\n        @Override\n        public <A extends Annotation> Optional<A> getAnnotation(Class<A> anno) {\n            return Optional.ofNullable(defn.getAnnotation(anno));\n        }\n\n        @Override\n        public Object get(T pojo) {\n            return Unchecked.callable(() -> {\n                if (Boolean.TRUE.equals(isSet.invoke(pojo))) {\n                    return getter.invoke(pojo);\n                } else {\n                    return null;\n                }\n            }).call();\n        }\n    }\n\n    class ImmutableSpec<T, B> {\n        Type type;\n        ConfigRegistry config;\n        Class<T> defn;\n        Supplier<B> builder;\n\n        ImmutableSpec(Type type, ConfigRegistry config, Class<T> defn, Supplier<B> builder) {\n            this.type = type;\n            this.config = config;\n            this.defn = defn;\n            this.builder = builder;\n        }\n    }\n\n    class ModifiableSpec<T, M> {\n        Type type;\n        ConfigRegistry config;\n        Class<T> defn;\n        Class<M> impl;\n        Supplier<M> constructor;\n\n        ModifiableSpec(Type type, ConfigRegistry config, Class<T> defn, Class<M> impl, Supplier<M> constructor) {\n            this.type = type;\n            this.config = config;\n            this.defn = defn;\n            this.impl = impl;\n            this.constructor = constructor;\n        }\n    }\n}\n","lineNo":149}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\nimport net.jodah.expiringmap.ExpirationPolicy;\nimport net.jodah.expiringmap.ExpiringMap;\nimport org.jdbi.v3.core.enums.EnumByName;\nimport org.jdbi.v3.core.enums.EnumByOrdinal;\nimport org.jdbi.v3.core.enums.Enums;\nimport org.jdbi.v3.core.internal.JdbiOptionals;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * Column mapper for Java {@code enum} types.\n * @param <E> the enum type mapped\n *\n * @see Enums\n * @see EnumByName\n * @see EnumByOrdinal\n */\n// TODO jdbi4: move to enums package\npublic abstract class EnumMapper<E extends Enum<E>> implements ColumnMapper<E> {\n    private static final Map<Class<? extends Enum<?>>, ColumnMapper<? extends Enum<?>>> BY_NAME_MAPPER_CACHE =\n        ExpiringMap.builder().expiration(10, TimeUnit.MINUTES).expirationPolicy(ExpirationPolicy.ACCESSED).build();\n\n    EnumMapper() {}\n\n    /**\n     * @param <E> the enum type to map\n     * @param type the enum type to map\n     * @return an enum mapper that matches on {@link Enum#name()}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Enum<E>> ColumnMapper<E> byName(Class<E> type) {\n        return (ColumnMapper<E>) BY_NAME_MAPPER_CACHE.computeIfAbsent(type, t -> new EnumByNameColumnMapper<>(type));\n    }\n\n    /**\n     * @param <E> the enum type to map\n     * @param type the enum type to map\n     * @return an enum mapper that matches on {@link Enum#ordinal()}\n     */\n    public static <E extends Enum<E>> ColumnMapper<E> byOrdinal(Class<E> type) {\n        return new EnumByOrdinalColumnMapper<>(type);\n    }\n\n    static class EnumByNameColumnMapper<E extends Enum<E>> implements ColumnMapper<E> {\n        private final Map<String, E> nameValueCache = new ConcurrentHashMap<>();\n        private final Class<E> enumClass;\n\n        private EnumByNameColumnMapper(Class<E> enumClass) {\n            this.enumClass = enumClass;\n        }\n\n        @Override\n        public E map(ResultSet rs, int columnNumber, StatementContext ctx) throws SQLException {\n            String name = rs.getString(columnNumber);\n\n            return name == null || name.isEmpty() // some vendors treat null and empty varchar as the same\n                ? null\n                : nameValueCache.computeIfAbsent(name, n -> getValueByName(enumClass, name, ctx));\n        }\n\n        private static <E extends Enum<E>> E getValueByName(Class<E> enumClass, String name, StatementContext ctx) {\n            return JdbiOptionals.findFirstPresent(\n                    () -> Arrays.stream(enumClass.getEnumConstants()).filter(e -> e.name().equals(name)).findFirst(),\n                    () -> Arrays.stream(enumClass.getEnumConstants()).filter(e -> e.name().equalsIgnoreCase(name)).findFirst()\n                )\n                .orElseThrow(() -> new UnableToProduceResultException(\n                    String.format(\"no %s value could be matched to the name %s\", enumClass.getSimpleName(), name),\n                    ctx));\n        }\n    }\n\n    static class EnumByOrdinalColumnMapper<E extends Enum<E>> implements ColumnMapper<E> {\n        private final Class<E> enumClass;\n\n        private EnumByOrdinalColumnMapper(Class<E> enumClass) {\n            this.enumClass = enumClass;\n        }\n\n        @Override\n        public E map(ResultSet rs, int columnNumber, StatementContext ctx) throws SQLException {\n            int ordinal = rs.getInt(columnNumber);\n\n            return rs.wasNull() ? null : getValueByOrdinal(enumClass, ordinal, ctx);\n        }\n\n        private static <E extends Enum<E>> E getValueByOrdinal(Class<E> enumClass, int ordinal, StatementContext ctx) {\n            try {\n                return enumClass.getEnumConstants()[ordinal];\n            } catch (ArrayIndexOutOfBoundsException oob) {\n                throw new UnableToProduceResultException(String.format(\n                    \"no %s value could be matched to the ordinal %s\", enumClass.getSimpleName(), ordinal\n                ), oob, ctx);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\n\nimport org.jdbi.v3.core.config.JdbiCache;\nimport org.jdbi.v3.core.config.JdbiCaches;\nimport org.jdbi.v3.core.enums.EnumByName;\nimport org.jdbi.v3.core.enums.EnumByOrdinal;\nimport org.jdbi.v3.core.enums.Enums;\nimport org.jdbi.v3.core.internal.JdbiOptionals;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * Column mapper for Java {@code enum} types.\n * @param <E> the enum type mapped\n *\n * @see Enums\n * @see EnumByName\n * @see EnumByOrdinal\n */\n// TODO jdbi4: move to enums package\npublic abstract class EnumMapper<E extends Enum<E>> implements ColumnMapper<E> {\n    EnumMapper() {}\n\n    /**\n     * @param <E> the enum type to map\n     * @param type the enum type to map\n     * @return an enum mapper that matches on {@link Enum#name()}\n     */\n    public static <E extends Enum<E>> ColumnMapper<E> byName(Class<E> type) {\n        return new EnumByNameColumnMapper<>(type);\n    }\n\n    /**\n     * @param <E> the enum type to map\n     * @param type the enum type to map\n     * @return an enum mapper that matches on {@link Enum#ordinal()}\n     */\n    public static <E extends Enum<E>> ColumnMapper<E> byOrdinal(Class<E> type) {\n        return new EnumByOrdinalColumnMapper<>(type);\n    }\n\n    static class EnumByNameColumnMapper<E extends Enum<E>> implements ColumnMapper<E> {\n        private static final JdbiCache<Class<? extends Enum<?>>, JdbiCache<String, Enum<?>>> BY_NAME_CACHE =\n                JdbiCaches.declare(e -> JdbiCaches.declare(\n                        name -> e.cast(getValueByName(e, name))));\n        private final Class<E> enumClass;\n\n        private EnumByNameColumnMapper(Class<E> enumClass) {\n            this.enumClass = enumClass;\n        }\n\n        @Override\n        public E map(ResultSet rs, int columnNumber, StatementContext ctx) throws SQLException {\n            String name = rs.getString(columnNumber);\n\n            return name == null || name.isEmpty() // some vendors treat null and empty varchar as the same\n                ? null\n                : enumClass.cast(BY_NAME_CACHE.get(enumClass, ctx).get(name, ctx));\n        }\n\n        private static Object getValueByName(Class<? extends Enum<?>> enumClass, String name) {\n            final Enum<?>[] enumConstants = enumClass.getEnumConstants();\n            return JdbiOptionals.findFirstPresent(\n                    () -> Arrays.stream(enumConstants).filter(e -> e.name().equals(name)).findFirst(),\n                    () -> Arrays.stream(enumConstants).filter(e -> e.name().equalsIgnoreCase(name)).findFirst()\n                )\n                .orElseThrow(() -> new UnableToProduceResultException(\n                    String.format(\"no %s value could be matched to the name %s\", enumClass.getSimpleName(), name)));\n        }\n    }\n\n    static class EnumByOrdinalColumnMapper<E extends Enum<E>> implements ColumnMapper<E> {\n        private final Class<E> enumClass;\n        private final E[] enumConstants;\n\n        private EnumByOrdinalColumnMapper(Class<E> enumClass) {\n            this.enumClass = enumClass;\n            this.enumConstants = enumClass.getEnumConstants();\n        }\n\n        @Override\n        public E map(ResultSet rs, int columnNumber, StatementContext ctx) throws SQLException {\n            int ordinal = rs.getInt(columnNumber);\n\n            try {\n                return rs.wasNull() ? null : enumConstants[ordinal];\n            } catch (ArrayIndexOutOfBoundsException oob) {\n                throw new UnableToProduceResultException(String.format(\n                        \"no %s value could be matched to the ordinal %s\", enumClass.getSimpleName(), ordinal),\n                    oob, ctx);\n            }\n        }\n    }\n}\n","lineNo":79}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.jackson2;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.jdbi.v3.json.JsonMapper;\n\nclass JacksonJsonMapper implements JsonMapper {\n    @Override\n    public String toJson(Type type, Object value, ConfigRegistry config) {\n        try {\n            ObjectMapper mapper = getMapper(config);\n            return mapper\n                    .writerFor(mapper.constructType(type))\n                    .writeValueAsString(value);\n        } catch (JsonProcessingException e) {\n            throw new UnableToProduceResultException(e);\n        }\n    }\n\n    @Override\n    public Object fromJson(Type type, String json, ConfigRegistry config) {\n        try {\n            ObjectMapper mapper = getMapper(config);\n            return mapper.readValue(json, mapper.constructType(type));\n        } catch (IOException e) {\n            throw new UnableToProduceResultException(e);\n        }\n    }\n\n    private ObjectMapper getMapper(ConfigRegistry config) {\n        return config.get(Jackson2Config.class).getMapper();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.jackson2;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectReader;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.jdbi.v3.json.JsonMapper;\n\nclass JacksonJsonMapper implements JsonMapper {\n    @Override\n    public String toJson(Type type, Object value, ConfigRegistry config) {\n        try {\n            Jackson2Config cfg = config.get(Jackson2Config.class);\n            ObjectWriter writer = cfg.getMapper().writerFor(cfg.getMapper().constructType(type));\n            Class<?> view = cfg.getSerializationView();\n            if (view != null) {\n                writer = writer.withView(view);\n            }\n            return writer.writeValueAsString(value);\n        } catch (JsonProcessingException e) {\n            throw new UnableToProduceResultException(e);\n        }\n    }\n\n    @Override\n    public Object fromJson(Type type, String json, ConfigRegistry config) {\n        try {\n            Jackson2Config cfg = config.get(Jackson2Config.class);\n            ObjectReader reader = cfg.getMapper().readerFor(cfg.getMapper().constructType(type));\n            Class<?> view = cfg.getDeserializationView();\n            if (view != null) {\n                reader = reader.withView(view);\n            }\n            return reader.readValue(json);\n        } catch (IOException e) {\n            throw new UnableToProduceResultException(e);\n        }\n    }\n}\n","lineNo":31}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.ObjectFieldArguments;\nimport org.jdbi.v3.core.argument.ObjectMethodArguments;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.MapArguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.qualifier.NVarchar;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.Mappers;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.meta.Beta;\n\nimport static java.util.stream.Collectors.joining;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private final Handle handle;\n    private final String sql;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private PreparedStatement stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding() {\n        return getContext().getBinding();\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql() {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds) {\n        return addCustomizer(StatementCustomizers.statementTimeout(seconds));\n    }\n\n    /**\n     * Transfer ownership of the handle to the statement: when the statement is closed,\n     * commit the handle's transaction (if one exists) and close the handle.\n     * @return this\n     */\n    public This cleanupHandleCommit() {\n        return cleanupHandle(Handle::commit);\n    }\n\n    /**\n     * When the statement is closed, roll it back then close the owning Handle.\n     * @return this\n     */\n    public This cleanupHandleRollback() {\n        return cleanupHandle(Handle::rollback);\n    }\n\n    private This cleanupHandle(Consumer<Handle> action) {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    action.accept(handle);\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument) {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument) {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean) {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(null, bean));\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(String prefix, Object bean) {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(Object object) {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(null, object));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param prefix a prefix to apply to all field names.\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(String prefix, Object object) {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(prefix, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument.\n     *\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(Object object) {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(null, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument, with the given prefix.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(String prefix, Object object) {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(prefix, object));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map) {\n        return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map));\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder) {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value) {\n        return bind(position, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value) {\n        return bind(name, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value) {\n        return bind(position, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value) {\n        return bind(name, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind a {@code String} argument positionally, as {@code NVARCHAR} type.\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindNVarchar(int position, String value) {\n        return bind(position, toArgument(QualifiedType.of(String.class).with(NVarchar.class), value));\n    }\n\n    /**\n     * Bind a {@code String} argument by name, as {@code NVARCHAR} type.\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindNVarchar(String name, String value) {\n        return bind(name, toArgument(QualifiedType.of(String.class).with(NVarchar.class), value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value) {\n        return bind(position, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value) {\n        return bind(position, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value) {\n        return bind(name, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value) {\n        return bind(name, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value) {\n        return bind(position, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value) {\n        return bind(name, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value) {\n        return bind(position, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value) {\n        return bind(name, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value) {\n        return bind(position, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value) {\n        return bind(name, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value) {\n        return bind(position, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value) {\n        return bind(position, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value) {\n        return bind(name, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value) {\n        return bind(name, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value) {\n        return bind(position, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value) {\n        return bind(position, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value) {\n        return bind(name, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value) {\n        return bind(name, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value) {\n        return bind(position, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value) {\n        return bind(name, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length) {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length) {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value) {\n        return bind(position, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value) {\n        return bind(name, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value) {\n        return bind(position, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value) {\n        return bind(name, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value) {\n        return bind(position, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value) {\n        return bind(name, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value) {\n        return bind(position, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value) {\n        return bind(position, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value) {\n        return bind(name, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value) {\n        return bind(name, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value) {\n        return bind(position, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value) {\n        return bind(position, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value) {\n        return bind(name, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value) {\n        return bind(name, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value) {\n        return bind(position, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value) {\n        return bind(position, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value) {\n        return bind(name, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value) {\n        return bind(name, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value) {\n        return bind(position, toArgument(Short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value) {\n        return bind(position, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value) {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value) {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value) {\n        return bind(position, toArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value) {\n        return bind(name, toArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value) {\n        return bind(position, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value) {\n        return bind(name, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value) {\n        return bind(position, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value) {\n        return bind(name, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value) {\n        return bind(position, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value) {\n        return bind(name, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType) {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType) {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the qualified type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindByType(int position, Object value, QualifiedType argumentType) {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType) {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType) {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindByType(String name, Object value, QualifiedType argumentType) {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    private Argument toArgument(Object value) {\n        return toArgument(value == null ? Object.class : value.getClass(), value);\n    }\n\n    private Argument toArgument(Type type, Object value) {\n        Argument arg = getConfig(Arguments.class).findFor(type, value)\n            .orElseThrow(() -> factoryNotFound(type, value));\n\n        try {\n            boolean toStringIsImplementedInArgument = arg.getClass().getMethod(\"toString\").getDeclaringClass() != Object.class;\n\n            if (toStringIsImplementedInArgument) {\n                return arg;\n            } else {\n                return new Argument() {\n                    @Override\n                    public void apply(int position, PreparedStatement statement, StatementContext ctx) throws SQLException {\n                        arg.apply(position, statement, ctx);\n                    }\n\n                    @Override\n                    public String toString() {\n                        return Objects.toString(value);\n                    }\n                };\n            }\n        } catch (NoSuchMethodException e) {\n            throw new Error(\"toString method does not exist, Object hierarchy is corrupt\", e);\n        }\n    }\n\n    private Argument toArgument(QualifiedType type, Object value) {\n        return getConfig(Arguments.class).findFor(type, value)\n                .orElseThrow(() -> factoryNotFound(type, value));\n    }\n\n    private UnsupportedOperationException factoryNotFound(Type type, Object value) {\n        if (type instanceof Class<?>) { // not a ParameterizedType\n            final TypeVariable<?>[] params = ((Class<?>) type).getTypeParameters();\n            if (params.length > 0) {\n                return new UnsupportedOperationException(\"No type parameters found for erased type '\" + type + Arrays.toString(params)\n                    + \"'. To bind a generic type, prefer using bindByType.\");\n            }\n        }\n        return new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of type \" + type);\n    }\n\n    private UnsupportedOperationException factoryNotFound(QualifiedType qualifiedType, Object value) {\n        Type type = qualifiedType.getType();\n        if (type instanceof Class<?>) { // not a ParameterizedType\n            final TypeVariable<?>[] params = ((Class<?>) type).getTypeParameters();\n            if (params.length > 0) {\n                return new UnsupportedOperationException(\"No type parameters found for erased type '\" + type + Arrays.toString(params)\n                    + \"' with qualifiers '\" + qualifiedType.getQualifiers()\n                    + \"'. To bind a generic type, prefer using bindByType.\");\n            }\n        }\n        return new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of qualified type \" + qualifiedType);\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType) {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType) {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType) {\n        return bind(name, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType) {\n        return bind(position, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a parameter for each value in the given vararg array, and defines an attribute as the comma-separated list\n     * of parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", 1, 2, 3)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with no vararg values.\");\n        }\n\n        return bindList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     */\n    public final This bindList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with an empty list.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            String paramName = getConfig().get(SqlStatements.class).getSqlParser().nameParameter(name, getContext());\n            names.append(paramName);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean);\n\n            names.append(\"(\");\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(\",\");\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + \"_\" + valueIndex + \"_\" + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * For each value given, create a tuple by invoking each given method in order, and bind the tuple into\n     * a {@code VALUES (...)} format insert clause.\n     * @param key attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value\n     * @param methodNames list of methods that will be invoked on the values\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException if the method cannot be found\n     */\n    public final This bindMethodsList(String key, Iterable<?> values, List<String> methodNames) throws UnableToCreateStatementException {\n        final Iterator<?> valueIter = values.iterator();\n        if (!valueIter.hasNext()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        if (methodNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        final StringBuilder names = new StringBuilder();\n        final StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIter.hasNext(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            final Object bean = valueIter.next();\n            final ObjectMethodArguments beanMethods = new ObjectMethodArguments(null, bean);\n\n            names.append(\"(\");\n            for (int methodIndex = 0; methodIndex < methodNames.size(); methodIndex++) {\n                if (methodIndex > 0) {\n                    names.append(\",\");\n                }\n\n                final String methodName = methodNames.get(methodIndex);\n                final String name = key + valueIndex + \".\" + methodName;\n                names.append(\":\").append(name);\n                final Argument argument = beanMethods.find(methodName, ctx)\n                    .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + methodName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        // Uses stream match, cause the Java 9 ImmutableList implementation throws an NPE if asked `contains(null)`\n        if (values.stream().anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    /**\n     * Define all bound arguments that don't already have a definition with a boolean indicating\n     * their presence.\n     * @return this\n     */\n    @Beta\n    public This defineNamedBindings() {\n        return defineNamedBindings(DefineNamedBindingMode.BOOLEAN);\n    }\n\n    /**\n     * Define all bound arguments that don't already have a definition with the given defining mode.\n     * @return this\n     */\n    @Beta\n    public This defineNamedBindings(DefineNamedBindingMode mode) {\n        return configure(SqlStatements.class, s ->\n            s.setTemplateEngine(new DefineNamedBindingsTemplateEngine(mode, s.getTemplateEngine())));\n    }\n\n    PreparedStatement internalExecute() {\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(sql, getContext());\n        getContext().setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, getContext());\n        String sql = parsedSql.getSql();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            if (getClass().isAssignableFrom(Call.class)) {\n                stmt = handle.getStatementBuilder().createCall(handle.getConnection(), sql, getContext());\n            } else {\n                stmt = handle.getStatementBuilder().create(handle.getConnection(), sql, getContext());\n            }\n\n            // The statement builder might (or might not) clean up the statement when called. E.g. the\n            // caching statement builder relies on the statement *not* being closed.\n            addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), this.sql, stmt));\n            getConfig(SqlStatements.class).customize(stmt);\n        } catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, getContext());\n        }\n\n        getContext().setStatement(stmt);\n\n        beforeBinding(stmt);\n\n        ArgumentBinder.bind(parsedSql.getParameters(), getBinding(), stmt, getContext());\n\n        beforeExecution(stmt);\n\n        try {\n            SqlLoggerUtil.wrap(stmt::execute, getContext(), getConfig(SqlStatements.class).getSqlLogger());\n        } catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n\n            throw new UnableToExecuteStatementException(e, getContext());\n        }\n\n        afterExecution(stmt);\n\n        return stmt;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(Class<T> type) {\n        return (RowMapper<T>) mapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(GenericType<T> type) {\n        return (RowMapper<T>) mapperForType(type.getType());\n    }\n\n    RowMapper<?> mapperForType(Type type) {\n        return getConfig(Mappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.ObjectFieldArguments;\nimport org.jdbi.v3.core.argument.ObjectMethodArguments;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.MapArguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.qualifier.NVarchar;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.Mappers;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.meta.Beta;\n\nimport static java.util.stream.Collectors.joining;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private final Handle handle;\n    private final String sql;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private PreparedStatement stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding() {\n        return getContext().getBinding();\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql() {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds) {\n        return addCustomizer(StatementCustomizers.statementTimeout(seconds));\n    }\n\n    /**\n     * Transfer ownership of the handle to the statement: when the statement is closed,\n     * commit the handle's transaction (if one exists) and close the handle.\n     * @return this\n     */\n    public This cleanupHandleCommit() {\n        return cleanupHandle(Handle::commit);\n    }\n\n    /**\n     * When the statement is closed, roll it back then close the owning Handle.\n     * @return this\n     */\n    public This cleanupHandleRollback() {\n        return cleanupHandle(Handle::rollback);\n    }\n\n    private This cleanupHandle(Consumer<Handle> action) {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    action.accept(handle);\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument) {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument) {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean) {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(null, bean));\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(String prefix, Object bean) {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(Object object) {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(null, object));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param prefix a prefix to apply to all field names.\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(String prefix, Object object) {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(prefix, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument.\n     *\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(Object object) {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(null, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument, with the given prefix.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(String prefix, Object object) {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(prefix, object));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map) {\n        return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map));\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder) {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value) {\n        return bind(position, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value) {\n        return bind(name, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value) {\n        return bind(position, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value) {\n        return bind(name, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind a {@code String} argument positionally, as {@code NVARCHAR} type.\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindNVarchar(int position, String value) {\n        return bind(position, toArgument(QualifiedType.of(String.class).with(NVarchar.class), value));\n    }\n\n    /**\n     * Bind a {@code String} argument by name, as {@code NVARCHAR} type.\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindNVarchar(String name, String value) {\n        return bind(name, toArgument(QualifiedType.of(String.class).with(NVarchar.class), value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value) {\n        return bind(position, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value) {\n        return bind(position, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value) {\n        return bind(name, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value) {\n        return bind(name, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value) {\n        return bind(position, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value) {\n        return bind(name, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value) {\n        return bind(position, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value) {\n        return bind(name, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value) {\n        return bind(position, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value) {\n        return bind(name, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value) {\n        return bind(position, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value) {\n        return bind(position, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value) {\n        return bind(name, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value) {\n        return bind(name, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value) {\n        return bind(position, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value) {\n        return bind(position, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value) {\n        return bind(name, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value) {\n        return bind(name, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value) {\n        return bind(position, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value) {\n        return bind(name, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length) {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length) {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value) {\n        return bind(position, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value) {\n        return bind(name, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value) {\n        return bind(position, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value) {\n        return bind(name, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value) {\n        return bind(position, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value) {\n        return bind(name, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value) {\n        return bind(position, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value) {\n        return bind(position, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value) {\n        return bind(name, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value) {\n        return bind(name, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value) {\n        return bind(position, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value) {\n        return bind(position, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value) {\n        return bind(name, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value) {\n        return bind(name, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value) {\n        return bind(position, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value) {\n        return bind(position, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value) {\n        return bind(name, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value) {\n        return bind(name, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value) {\n        return bind(position, toArgument(Short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value) {\n        return bind(position, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value) {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value) {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value) {\n        return bind(position, toArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value) {\n        return bind(name, toArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value) {\n        return bind(position, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value) {\n        return bind(name, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value) {\n        return bind(position, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value) {\n        return bind(name, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value) {\n        return bind(position, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value) {\n        return bind(name, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType) {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType) {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the qualified type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindByType(int position, Object value, QualifiedType argumentType) {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType) {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType) {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    @Beta\n    public final This bindByType(String name, Object value, QualifiedType argumentType) {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    private Argument toArgument(Object value) {\n        return toArgument(value == null ? Object.class : value.getClass(), value);\n    }\n\n    private Argument toArgument(Type type, Object value) {\n        Argument arg = getConfig(Arguments.class).findFor(type, value)\n            .orElseThrow(() -> factoryNotFound(type, value));\n\n        try {\n            boolean toStringIsImplementedInArgument = arg.getClass().getMethod(\"toString\").getDeclaringClass() != Object.class;\n\n            if (toStringIsImplementedInArgument) {\n                return arg;\n            } else {\n                return new Argument() {\n                    @Override\n                    public void apply(int position, PreparedStatement statement, StatementContext ctx) throws SQLException {\n                        arg.apply(position, statement, ctx);\n                    }\n\n                    @Override\n                    public String toString() {\n                        return Objects.toString(value);\n                    }\n                };\n            }\n        } catch (NoSuchMethodException e) {\n            throw new Error(\"toString method does not exist, Object hierarchy is corrupt\", e);\n        }\n    }\n\n    private Argument toArgument(QualifiedType type, Object value) {\n        return getConfig(Arguments.class).findFor(type, value)\n                .orElseThrow(() -> factoryNotFound(type, value));\n    }\n\n    private UnsupportedOperationException factoryNotFound(Type type, Object value) {\n        if (type instanceof Class<?>) { // not a ParameterizedType\n            final TypeVariable<?>[] params = ((Class<?>) type).getTypeParameters();\n            if (params.length > 0) {\n                return new UnsupportedOperationException(\"No type parameters found for erased type '\" + type + Arrays.toString(params)\n                    + \"'. To bind a generic type, prefer using bindByType.\");\n            }\n        }\n        return new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of type \" + type);\n    }\n\n    private UnsupportedOperationException factoryNotFound(QualifiedType qualifiedType, Object value) {\n        Type type = qualifiedType.getType();\n        if (type instanceof Class<?>) { // not a ParameterizedType\n            final TypeVariable<?>[] params = ((Class<?>) type).getTypeParameters();\n            if (params.length > 0) {\n                return new UnsupportedOperationException(\"No type parameters found for erased type '\" + type + Arrays.toString(params)\n                    + \"' with qualifiers '\" + qualifiedType.getQualifiers()\n                    + \"'. To bind a generic type, prefer using bindByType.\");\n            }\n        }\n        return new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of qualified type \" + qualifiedType);\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType) {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType) {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType) {\n        return bind(name, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType) {\n        return bind(position, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a parameter for each value in the given vararg array, and defines an attribute as the comma-separated list\n     * of parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", 1, 2, 3)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with no vararg values.\");\n        }\n\n        return bindList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     */\n    public final This bindList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with an empty list.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            String paramName = getConfig().get(SqlStatements.class).getSqlParser().nameParameter(name, getContext());\n            names.append(paramName);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean);\n\n            names.append(\"(\");\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(\",\");\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + \"_\" + valueIndex + \"_\" + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * For each value given, create a tuple by invoking each given method in order, and bind the tuple into\n     * a {@code VALUES (...)} format insert clause.\n     * @param key attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value\n     * @param methodNames list of methods that will be invoked on the values\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException if the method cannot be found\n     */\n    public final This bindMethodsList(String key, Iterable<?> values, List<String> methodNames) throws UnableToCreateStatementException {\n        final Iterator<?> valueIter = values.iterator();\n        if (!valueIter.hasNext()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        if (methodNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        final StringBuilder names = new StringBuilder();\n        final StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIter.hasNext(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            final Object bean = valueIter.next();\n            final ObjectMethodArguments beanMethods = new ObjectMethodArguments(null, bean);\n\n            names.append(\"(\");\n            for (int methodIndex = 0; methodIndex < methodNames.size(); methodIndex++) {\n                if (methodIndex > 0) {\n                    names.append(\",\");\n                }\n\n                final String methodName = methodNames.get(methodIndex);\n                final String name = key + valueIndex + \".\" + methodName;\n                names.append(\":\").append(name);\n                final Argument argument = beanMethods.find(methodName, ctx)\n                    .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + methodName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        // Uses stream match, cause the Java 9 ImmutableList implementation throws an NPE if asked `contains(null)`\n        if (values.stream().anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    /**\n     * Define all bound arguments that don't already have a definition with a boolean indicating\n     * their presence.\n     * @return this\n     */\n    @Beta\n    public This defineNamedBindings() {\n        return defineNamedBindings(DefineNamedBindingMode.BOOLEAN);\n    }\n\n    /**\n     * Define all bound arguments that don't already have a definition with the given defining mode.\n     * @return this\n     */\n    @Beta\n    public This defineNamedBindings(DefineNamedBindingMode mode) {\n        return addCustomizer(new DefineNamedBindingsStatementCustomizer(mode));\n    }\n\n    PreparedStatement internalExecute() {\n        final StatementContext ctx = getContext();\n\n        beforeTemplating();\n\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(sql, ctx);\n        ctx.setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, ctx);\n        String sql = parsedSql.getSql();\n        ctx.setParsedSql(parsedSql);\n\n        try {\n            if (getClass().isAssignableFrom(Call.class)) {\n                stmt = handle.getStatementBuilder().createCall(handle.getConnection(), sql, ctx);\n            } else {\n                stmt = handle.getStatementBuilder().create(handle.getConnection(), sql, ctx);\n            }\n\n            // The statement builder might (or might not) clean up the statement when called. E.g. the\n            // caching statement builder relies on the statement *not* being closed.\n            addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), this.sql, stmt));\n            getConfig(SqlStatements.class).customize(stmt);\n        } catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, ctx);\n        }\n\n        ctx.setStatement(stmt);\n\n        beforeBinding();\n\n        ArgumentBinder.bind(parsedSql.getParameters(), getBinding(), stmt, ctx);\n\n        beforeExecution();\n\n        try {\n            SqlLoggerUtil.wrap(stmt::execute, ctx, getConfig(SqlStatements.class).getSqlLogger());\n        } catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n\n            throw new UnableToExecuteStatementException(e, ctx);\n        }\n\n        afterExecution();\n\n        return stmt;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(Class<T> type) {\n        return (RowMapper<T>) mapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(GenericType<T> type) {\n        return (RowMapper<T>) mapperForType(type.getType());\n    }\n\n    RowMapper<?> mapperForType(Type type) {\n        return getConfig(Mappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n\n    void beforeTemplating() {\n        callCustomizers(c -> c.beforeTemplating(stmt, getContext()));\n    }\n\n    void beforeBinding() {\n        callCustomizers(c -> c.beforeBinding(stmt, getContext()));\n    }\n\n    void beforeExecution() {\n        callCustomizers(c -> c.beforeExecution(stmt, getContext()));\n    }\n\n    void afterExecution() {\n        callCustomizers(c -> c.afterExecution(stmt, getContext()));\n    }\n}\n","lineNo":1494}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizer.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\n\nimport java.util.Collections;\nimport org.jdbi.v3.core.internal.IterableLike;\nimport org.jdbi.v3.sqlobject.customizer.BindList;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\nimport org.jdbi.v3.sqlobject.internal.ParameterUtil;\n\npublic final class BindListFactory implements SqlStatementCustomizerFactory {\n    private static final String VALUE_NOT_HANDLED_MESSAGE = \"EmptyHandling type on BindList not handled. Please report this to the jdbi developers.\";\n\n    @Override\n    public SqlStatementParameterCustomizer createForParameter(Annotation annotation,\n                                                              Class<?> sqlObjectType,\n                                                              Method method,\n                                                              Parameter param,\n                                                              int index,\n                                                              Type type) {\n        final BindList bindList = (BindList) annotation;\n        final String name = ParameterUtil.findParameterName(bindList.value(), param)\n                .orElseThrow(() -> new UnsupportedOperationException(\"A @BindList parameter was not given a name, \"\n                        + \"and parameter name data is not present in the class file, for: \"\n                        + param.getDeclaringExecutable() + \"::\" + param));\n\n        return (stmt, arg) -> {\n            if (arg == null || IterableLike.isEmpty(arg)) {\n                switch (bindList.onEmpty()) {\n                case VOID:\n                    stmt.define(name, \"\");\n                    return;\n                case NULL:\n                    stmt.define(name, \"null\");\n                    return;\n                case THROW:\n                    throw new IllegalArgumentException(arg == null\n                    ? \"argument is null; null was explicitly forbidden on this instance of BindList\"\n                            : \"argument is empty; emptiness was explicitly forbidden on this instance of BindList\");\n                case EMPTY_LIST:\n                    stmt.define(name, Collections.emptyList());\n                    return;\n                default:\n                    throw new IllegalStateException(VALUE_NOT_HANDLED_MESSAGE);\n                }\n            }\n\n            stmt.bindList(name, IterableLike.toList(arg));\n        };\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizer.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\n\nimport java.util.Collections;\nimport org.jdbi.v3.core.internal.IterableLike;\nimport org.jdbi.v3.sqlobject.customizer.BindList;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\nimport org.jdbi.v3.sqlobject.internal.ParameterUtil;\n\npublic final class BindListFactory implements SqlStatementCustomizerFactory {\n    private static final String VALUE_NOT_HANDLED_MESSAGE = \"EmptyHandling type on BindList not handled. Please report this to the jdbi developers.\";\n\n    @Override\n    public SqlStatementParameterCustomizer createForParameter(Annotation annotation,\n                                                              Class<?> sqlObjectType,\n                                                              Method method,\n                                                              Parameter param,\n                                                              int index,\n                                                              Type type) {\n        final BindList bindList = (BindList) annotation;\n        final String name = ParameterUtil.findParameterName(bindList.value(), param)\n                .orElseThrow(() -> new UnsupportedOperationException(\"A @BindList parameter was not given a name, \"\n                        + \"and parameter name data is not present in the class file, for: \"\n                        + param.getDeclaringExecutable() + \"::\" + param));\n\n        return (stmt, arg) -> {\n            if (arg == null || IterableLike.isEmpty(arg)) {\n                switch (bindList.onEmpty()) {\n                case VOID:\n                    stmt.define(name, \"\");\n                    return;\n                case NULL:\n                    stmt.define(name, \"null\");\n                    return;\n                case EMPTY_LIST:\n                    stmt.define(name, Collections.emptyList());\n                    return;\n                case THROW:\n                    String msg = arg == null\n                        ? \"argument is null; null was explicitly forbidden on this instance of BindList\"\n                        : \"argument is empty; emptiness was explicitly forbidden on this instance of BindList\";\n                    throw new IllegalArgumentException(msg);\n                default:\n                    throw new IllegalStateException(VALUE_NOT_HANDLED_MESSAGE);\n                }\n            }\n\n            stmt.bindList(name, IterableLike.toList(arg));\n        };\n    }\n}\n","lineNo":57}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.json.internal;\n\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.internal.JdbiOptionals;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMapperFactory;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.json.Json;\nimport org.jdbi.v3.json.JsonConfig;\n\n@Json\nclass JsonColumnMapperFactory implements ColumnMapperFactory {\n    @Override\n    public Optional<ColumnMapper<?>> build(Type type, ConfigRegistry config) {\n        return Optional.of((r, i, c) -> {\n            final ColumnMapper<String> jsonStringMapper = JdbiOptionals.findFirstPresent(\n                () -> c.findColumnMapperFor(QualifiedType.of(Json.class)).map(JsonColumnMapperFactory::bludgeon),\n                () -> c.findColumnMapperFor(String.class))\n                    .orElseThrow(() -> new IllegalStateException(\"No column mapper found for '@Json String' or 'String', this really shouldn't happen...\"));\n            return c.getConfig(JsonConfig.class).getJsonMapper().fromJson(type, jsonStringMapper.map(r, i, c), c);\n        });\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static ColumnMapper<String> bludgeon(ColumnMapper<?> mapper) {\n        return (ColumnMapper<String>) mapper;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.json.internal;\n\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.internal.JdbiOptionals;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMapperFactory;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.json.Json;\nimport org.jdbi.v3.json.JsonConfig;\n\n@Json\nclass JsonColumnMapperFactory implements ColumnMapperFactory {\n    @Override\n    public Optional<ColumnMapper<?>> build(Type type, ConfigRegistry config) {\n        return Optional.of((r, i, c) -> {\n            final ColumnMapper<String> jsonStringMapper = JdbiOptionals.findFirstPresent(\n                () -> c.findColumnMapperFor(QualifiedType.of(Json.class)).map(JsonColumnMapperFactory::bludgeon),\n                () -> c.findColumnMapperFor(String.class))\n                    .orElseThrow(() -> new IllegalStateException(\"No column mapper found for '@Json String' or 'String', this really shouldn't happen...\"));\n            final String jsonValue = jsonStringMapper.map(r, i, c);\n            return jsonValue == null ? null : c.getConfig(JsonConfig.class).getJsonMapper().fromJson(type, jsonValue, c);\n        });\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static ColumnMapper<String> bludgeon(ColumnMapper<?> mapper) {\n        return (ColumnMapper<String>) mapper;\n    }\n}\n","lineNo":36}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.math.BigDecimal;\nimport java.util.List;\nimport java.util.Map;\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.CaseStrategy;\nimport org.jdbi.v3.core.mapper.GenericMapMapperFactory;\nimport org.jdbi.v3.core.mapper.MapMappers;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.rule.SqliteDatabaseRule;\nimport org.jdbi.v3.core.statement.Query;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class GenericMapMapperFactoryTest {\n    private static final String QUERY = \"select 1.0 as one, 2.0 as two, 3.0 as three\";\n\n    @Rule\n    public SqliteDatabaseRule db = new SqliteDatabaseRule().withPlugin(new SqlObjectPlugin());\n\n    private Jdbi jdbi;\n\n    @Before\n    public void before() {\n        jdbi = db.getJdbi().registerRowMapper(new GenericMapMapperFactory());\n    }\n\n    @Test\n    public void canFluentMapToGenericTypeOfMap() {\n        jdbi.useHandle(h -> {\n            Map<String, BigDecimal> map = h.createQuery(QUERY)\n                .mapTo(new GenericType<Map<String, BigDecimal>>() {})\n                .findOnly();\n\n            assertThat(map)\n                .containsOnlyKeys(\"one\", \"two\", \"three\")\n                .containsValues(new BigDecimal(\"1.0\"), new BigDecimal(\"2.0\"), new BigDecimal(\"3.0\"));\n        });\n    }\n\n    @Test\n    public void canFluentMapToMapWithGenericTypeForValue() {\n        jdbi.useHandle(h -> {\n            Map<String, BigDecimal> map = h.createQuery(QUERY)\n                .mapToMap(new GenericType<BigDecimal>() {})\n                .findOnly();\n\n            assertThat(map)\n                .containsOnlyKeys(\"one\", \"two\", \"three\")\n                .containsValues(new BigDecimal(\"1.0\"), new BigDecimal(\"2.0\"), new BigDecimal(\"3.0\"));\n        });\n    }\n\n    @Test\n    public void canFluentMapToMapWithClassForValue() {\n        jdbi.useHandle(h -> {\n            Map<String, BigDecimal> map = h.createQuery(QUERY)\n                .mapToMap(BigDecimal.class)\n                .findOnly();\n\n            assertThat(map)\n                .containsOnlyKeys(\"one\", \"two\", \"three\")\n                .containsValues(new BigDecimal(\"1.0\"), new BigDecimal(\"2.0\"), new BigDecimal(\"3.0\"));\n        });\n    }\n\n    @Test\n    public void canMapToMapWithSqlObject() {\n        jdbi.useExtension(WithTypicalMap.class, withTypicalMap -> {\n            List<Map<String, BigDecimal>> list = withTypicalMap.getMapList();\n\n            assertThat(list).hasSize(1);\n\n            Map<String, BigDecimal> map = list.get(0);\n\n            assertThat(map)\n                .containsOnlyKeys(\"one\", \"two\", \"three\")\n                .containsValues(new BigDecimal(\"1.0\"), new BigDecimal(\"2.0\"), new BigDecimal(\"3.0\"));\n        });\n    }\n\n    @Test\n    public void mapToMapFailsOnUnmappableClass() {\n        jdbi.useHandle(h -> {\n            Query query = h.createQuery(QUERY);\n\n            assertThatThrownBy(() -> query.mapToMap(Alien.class))\n                .hasMessage(\"no column mapper found for type \" + Alien.class);\n        });\n    }\n\n    @Test\n    public void mapToMapFailsOnUnmappableGenericType() {\n        jdbi.useHandle(h -> {\n            Query query = h.createQuery(QUERY);\n\n            assertThatThrownBy(() -> query.mapToMap(new GenericType<Alien>() {}))\n                .hasMessage(\"no column mapper found for type \" + Alien.class);\n        });\n    }\n\n    @Test\n    public void sqlObjectMethodFailsOnCallForUnmappableType() {\n        jdbi.useExtension(\n            WithUnsupportedMap.class, withUnsupportedMap -> assertThatThrownBy(withUnsupportedMap::getMapList)\n                .hasMessage(\"No mapper registered for type java.util.Map<java.lang.String, \" + Alien.class.getName() + \">\")\n        );\n    }\n\n    @Test\n    public void duplicateColumnsWithoutCaseChangeCauseException() {\n        jdbi.useHandle(h -> {\n            h.getConfig(MapMappers.class).setCaseChange(CaseStrategy.NOP);\n            ResultIterable<Map<String, BigDecimal>> query = h.createQuery(QUERY.replace(\"two\", \"one\")).mapToMap(BigDecimal.class);\n\n            assertThatThrownBy(query::findOnly)\n                .hasMessageContaining(\"map key \\\"one\\\" (from column \\\"one\\\") appears twice\");\n        });\n    }\n\n    @Test\n    public void duplicateKeysAfterCaseChangeCauseException() {\n        jdbi.useHandle(h -> {\n            h.getConfig(MapMappers.class).setCaseChange(CaseStrategy.LOWER);\n            // one and ONE\n            ResultIterable<Map<String, BigDecimal>> query = h.createQuery(QUERY.replace(\"two\", \"ONE\")).mapToMap(BigDecimal.class);\n\n            assertThatThrownBy(query::findOnly)\n                .hasMessageContaining(\"map key \\\"one\\\" (from column \\\"ONE\\\") appears twice\");\n        });\n    }\n\n    public interface WithTypicalMap {\n        @SqlQuery(QUERY)\n        List<Map<String, BigDecimal>> getMapList();\n    }\n\n    public static class Alien {}\n\n    public interface WithUnsupportedMap {\n        @SqlQuery(QUERY)\n        List<Map<String, Alien>> getMapList();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.math.BigDecimal;\nimport java.util.List;\nimport java.util.Map;\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.CaseStrategy;\nimport org.jdbi.v3.core.mapper.GenericMapMapperFactory;\nimport org.jdbi.v3.core.mapper.MapMappers;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.rule.SqliteDatabaseRule;\nimport org.jdbi.v3.core.statement.Query;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class GenericMapMapperFactoryTest {\n    private static final String QUERY = \"select 1.0 as one, 2.0 as two, 3.0 as three\";\n\n    @Rule\n    public SqliteDatabaseRule db = new SqliteDatabaseRule().withPlugin(new SqlObjectPlugin());\n\n    private Jdbi jdbi;\n\n    @Before\n    public void before() {\n        jdbi = db.getJdbi().registerRowMapper(new GenericMapMapperFactory());\n    }\n\n    @Test\n    public void canFluentMapToGenericTypeOfMap() {\n        jdbi.useHandle(h -> {\n            Map<String, BigDecimal> map = h.createQuery(QUERY)\n                .mapTo(new GenericType<Map<String, BigDecimal>>() {})\n                .findOnly();\n\n            assertThat(map)\n                .containsOnlyKeys(\"one\", \"two\", \"three\")\n                .containsValues(new BigDecimal(\"1.0\"), new BigDecimal(\"2.0\"), new BigDecimal(\"3.0\"));\n        });\n    }\n\n    @Test\n    public void canFluentMapToMapWithGenericTypeForValue() {\n        jdbi.useHandle(h -> {\n            Map<String, BigDecimal> map = h.createQuery(QUERY)\n                .mapToMap(new GenericType<BigDecimal>() {})\n                .findOnly();\n\n            assertThat(map)\n                .containsOnlyKeys(\"one\", \"two\", \"three\")\n                .containsValues(new BigDecimal(\"1.0\"), new BigDecimal(\"2.0\"), new BigDecimal(\"3.0\"));\n        });\n    }\n\n    @Test\n    public void canFluentMapToMapWithClassForValue() {\n        jdbi.useHandle(h -> {\n            Map<String, BigDecimal> map = h.createQuery(QUERY)\n                .mapToMap(BigDecimal.class)\n                .findOnly();\n\n            assertThat(map)\n                .containsOnlyKeys(\"one\", \"two\", \"three\")\n                .containsValues(new BigDecimal(\"1.0\"), new BigDecimal(\"2.0\"), new BigDecimal(\"3.0\"));\n        });\n    }\n\n    @Test\n    public void canMapToMapWithSqlObject() {\n        jdbi.useExtension(WithTypicalMap.class, withTypicalMap -> {\n            List<Map<String, BigDecimal>> list = withTypicalMap.getMapList();\n\n            assertThat(list).hasSize(1);\n\n            Map<String, BigDecimal> map = list.get(0);\n\n            assertThat(map)\n                .containsOnlyKeys(\"one\", \"two\", \"three\")\n                .containsValues(new BigDecimal(\"1.0\"), new BigDecimal(\"2.0\"), new BigDecimal(\"3.0\"));\n        });\n    }\n\n    @Test\n    public void mapToMapFailsOnUnmappableClass() {\n        jdbi.useHandle(h -> {\n            Query query = h.createQuery(QUERY);\n\n            assertThatThrownBy(() -> query.mapToMap(Alien.class))\n                .hasMessage(\"no column mapper found for type \" + Alien.class);\n        });\n    }\n\n    @Test\n    public void mapToMapFailsOnUnmappableGenericType() {\n        jdbi.useHandle(h -> {\n            Query query = h.createQuery(QUERY);\n            GenericType<Alien> type = new GenericType<Alien>() {};\n\n            assertThatThrownBy(() -> query.mapToMap(type))\n                .hasMessage(\"no column mapper found for type \" + type);\n        });\n    }\n\n    @Test\n    public void sqlObjectMethodFailsOnCallForUnmappableType() {\n        jdbi.useExtension(\n            WithUnsupportedMap.class, withUnsupportedMap -> assertThatThrownBy(withUnsupportedMap::getMapList)\n                .hasMessage(\"No mapper registered for type java.util.Map<java.lang.String, \" + Alien.class.getName() + \">\")\n        );\n    }\n\n    @Test\n    public void duplicateColumnsWithoutCaseChangeCauseException() {\n        jdbi.useHandle(h -> {\n            h.getConfig(MapMappers.class).setCaseChange(CaseStrategy.NOP);\n            ResultIterable<Map<String, BigDecimal>> query = h.createQuery(QUERY.replace(\"two\", \"one\")).mapToMap(BigDecimal.class);\n\n            assertThatThrownBy(query::findOnly)\n                .hasMessageContaining(\"map key \\\"one\\\" (from column \\\"one\\\") appears twice\");\n        });\n    }\n\n    @Test\n    public void duplicateKeysAfterCaseChangeCauseException() {\n        jdbi.useHandle(h -> {\n            h.getConfig(MapMappers.class).setCaseChange(CaseStrategy.LOWER);\n            // one and ONE\n            ResultIterable<Map<String, BigDecimal>> query = h.createQuery(QUERY.replace(\"two\", \"ONE\")).mapToMap(BigDecimal.class);\n\n            assertThatThrownBy(query::findOnly)\n                .hasMessageContaining(\"map key \\\"one\\\" (from column \\\"ONE\\\") appears twice\");\n        });\n    }\n\n    public interface WithTypicalMap {\n        @SqlQuery(QUERY)\n        List<Map<String, BigDecimal>> getMapList();\n    }\n\n    public static class Alien {}\n\n    public interface WithUnsupportedMap {\n        @SqlQuery(QUERY)\n        List<Map<String, Alien>> getMapList();\n    }\n}\n","lineNo":116}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class AnnotationFactory {\n    private AnnotationFactory() {}\n\n    public static <T extends Annotation> T create(Class<T> annotationType) {\n        @SuppressWarnings(\"unchecked\")\n        T annotation = (T) Proxy.newProxyInstance(\n            Thread.currentThread().getContextClassLoader(),\n            new Class[]{annotationType},\n            getInvocationHandler(annotationType));\n        return annotation;\n    }\n\n    private static <T extends Annotation> InvocationHandler getInvocationHandler(Class<T> annotationType) {\n        return (proxy, method, args) -> {\n            String name = method.getName();\n            if (\"annotationType\".equals(name) && method.getParameterCount() == 0) {\n                return annotationType;\n            }\n\n            if (\"equals\".equals(name) && method.getParameterCount() == 1\n                && Object.class.equals(method.getParameterTypes()[0])) {\n                Annotation that = (Annotation) args[0];\n                return annotationType.equals(that.annotationType());\n            }\n\n            if (\"hashCode\".equals(name) && method.getParameterCount() == 0) {\n                return 0;\n            }\n\n            if (\"toString\".equals(name) && method.getParameterCount() == 0) {\n                return \"@\" + annotationType.getCanonicalName() + \"()\";\n            }\n\n            throw new IllegalStateException(\"Unknown method \" + method + \" for annotation type \" + annotationType);\n        };\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class AnnotationFactory {\n    private AnnotationFactory() {}\n\n    public static <T extends Annotation> T create(Class<T> annotationType) {\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        Class[] interfaces = {annotationType};\n        InvocationHandler invocationHandler = getInvocationHandler(annotationType);\n\n        @SuppressWarnings(\"unchecked\")\n        T annotation = (T) Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);\n\n        return annotation;\n    }\n\n    private static <T extends Annotation> InvocationHandler getInvocationHandler(Class<T> annotationType) {\n        return (proxy, method, args) -> {\n            String name = method.getName();\n            if (\"annotationType\".equals(name) && method.getParameterCount() == 0) {\n                return annotationType;\n            }\n\n            if (\"equals\".equals(name) && method.getParameterCount() == 1\n                && Object.class.equals(method.getParameterTypes()[0])) {\n                Annotation that = (Annotation) args[0];\n                return annotationType.equals(that.annotationType());\n            }\n\n            if (\"hashCode\".equals(name) && method.getParameterCount() == 0) {\n                return 0;\n            }\n\n            if (\"toString\".equals(name) && method.getParameterCount() == 0) {\n                return \"@\" + annotationType.getCanonicalName() + \"()\";\n            }\n\n            throw new IllegalStateException(\"Unknown method \" + method + \" for annotation type \" + annotationType);\n        };\n    }\n}\n","lineNo":24}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class AnnotationFactory {\n    private AnnotationFactory() {}\n\n    public static <T extends Annotation> T create(Class<T> annotationType) {\n        @SuppressWarnings(\"unchecked\")\n        T annotation = (T) Proxy.newProxyInstance(\n            Thread.currentThread().getContextClassLoader(),\n            new Class[]{annotationType},\n            getInvocationHandler(annotationType));\n        return annotation;\n    }\n\n    private static <T extends Annotation> InvocationHandler getInvocationHandler(Class<T> annotationType) {\n        return (proxy, method, args) -> {\n            String name = method.getName();\n            if (\"annotationType\".equals(name) && method.getParameterCount() == 0) {\n                return annotationType;\n            }\n\n            if (\"equals\".equals(name) && method.getParameterCount() == 1\n                && Object.class.equals(method.getParameterTypes()[0])) {\n                Annotation that = (Annotation) args[0];\n                return annotationType.equals(that.annotationType());\n            }\n\n            if (\"hashCode\".equals(name) && method.getParameterCount() == 0) {\n                return 0;\n            }\n\n            if (\"toString\".equals(name) && method.getParameterCount() == 0) {\n                return \"@\" + annotationType.getCanonicalName() + \"()\";\n            }\n\n            throw new IllegalStateException(\"Unknown method \" + method + \" for annotation type \" + annotationType);\n        };\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class AnnotationFactory {\n    private AnnotationFactory() {}\n\n    public static <T extends Annotation> T create(Class<T> annotationType) {\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        Class[] interfaces = {annotationType};\n        InvocationHandler invocationHandler = getInvocationHandler(annotationType);\n\n        @SuppressWarnings(\"unchecked\")\n        T annotation = (T) Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);\n\n        return annotation;\n    }\n\n    private static <T extends Annotation> InvocationHandler getInvocationHandler(Class<T> annotationType) {\n        return (proxy, method, args) -> {\n            String name = method.getName();\n            if (\"annotationType\".equals(name) && method.getParameterCount() == 0) {\n                return annotationType;\n            }\n\n            if (\"equals\".equals(name) && method.getParameterCount() == 1\n                && Object.class.equals(method.getParameterTypes()[0])) {\n                Annotation that = (Annotation) args[0];\n                return annotationType.equals(that.annotationType());\n            }\n\n            if (\"hashCode\".equals(name) && method.getParameterCount() == 0) {\n                return 0;\n            }\n\n            if (\"toString\".equals(name) && method.getParameterCount() == 0) {\n                return \"@\" + annotationType.getCanonicalName() + \"()\";\n            }\n\n            throw new IllegalStateException(\"Unknown method \" + method + \" for annotation type \" + annotationType);\n        };\n    }\n}\n","lineNo":26}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.MapArguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.argument.ObjectFieldArguments;\nimport org.jdbi.v3.core.argument.ObjectMethodArguments;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.Mappers;\nimport org.jdbi.v3.core.mapper.RowMapper;\n\nimport static java.util.stream.Collectors.joining;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private final Handle handle;\n    private final String sql;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private PreparedStatement stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding() {\n        return getContext().getBinding();\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql() {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds) {\n        return addCustomizer(StatementCustomizers.statementTimeout(seconds));\n    }\n\n    /**\n     * Transfer ownership of the handle to the statement: when the statement is closed,\n     * commit the handle's transaction (if one exists) and close the handle.\n     * @return this\n     */\n    public This cleanupHandleCommit() {\n        return cleanupHandle(Handle::commit);\n    }\n\n    /**\n     * When the statement is closed, roll it back then close the owning Handle.\n     * @return this\n     */\n    public This cleanupHandleRollback() {\n        return cleanupHandle(Handle::rollback);\n    }\n\n    private This cleanupHandle(Consumer<Handle> action) {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    action.accept(handle);\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument) {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument) {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean) {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(null, bean));\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(String prefix, Object bean) {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(Object object) {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(null, object));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param prefix a prefix to apply to all field names.\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(String prefix, Object object) {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(prefix, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument.\n     *\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(Object object) {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(null, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument, with the given prefix.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(String prefix, Object object) {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(prefix, object));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map) {\n        return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map));\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder) {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value) {\n        return bind(position, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value) {\n        return bind(name, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value) {\n        return bind(position, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value) {\n        return bind(name, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value) {\n        return bind(position, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value) {\n        return bind(position, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value) {\n        return bind(name, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value) {\n        return bind(name, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value) {\n        return bind(position, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value) {\n        return bind(name, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value) {\n        return bind(position, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value) {\n        return bind(name, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value) {\n        return bind(position, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value) {\n        return bind(name, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value) {\n        return bind(position, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value) {\n        return bind(position, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value) {\n        return bind(name, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value) {\n        return bind(name, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value) {\n        return bind(position, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value) {\n        return bind(position, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value) {\n        return bind(name, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value) {\n        return bind(name, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value) {\n        return bind(position, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value) {\n        return bind(name, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length) {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length) {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value) {\n        return bind(position, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value) {\n        return bind(name, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value) {\n        return bind(position, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value) {\n        return bind(name, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value) {\n        return bind(position, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value) {\n        return bind(name, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value) {\n        return bind(position, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value) {\n        return bind(position, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value) {\n        return bind(name, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value) {\n        return bind(name, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value) {\n        return bind(position, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value) {\n        return bind(position, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value) {\n        return bind(name, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value) {\n        return bind(name, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value) {\n        return bind(position, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value) {\n        return bind(position, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value) {\n        return bind(name, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value) {\n        return bind(name, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value) {\n        return bind(position, toArgument(Short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value) {\n        return bind(position, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value) {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value) {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value) {\n        return bind(position, toArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value) {\n        return bind(name, toArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value) {\n        return bind(position, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value) {\n        return bind(name, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value) {\n        return bind(position, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value) {\n        return bind(name, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value) {\n        return bind(position, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value) {\n        return bind(name, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType) {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType) {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType) {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType) {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    private Argument toArgument(Object value) {\n        return toArgument(value == null ? Object.class : value.getClass(), value);\n    }\n\n    private Argument toArgument(Type type, Object value) {\n        Argument arg = getConfig(Arguments.class).findFor(type, value)\n            .orElseThrow(() -> factoryNotFound(type, value));\n\n        try {\n            boolean toStringIsImplementedInArgument = arg.getClass().getMethod(\"toString\").getDeclaringClass() != Object.class;\n\n            if (toStringIsImplementedInArgument) {\n                return arg;\n            } else {\n                return new Argument() {\n                    @Override\n                    public void apply(int position, PreparedStatement statement, StatementContext ctx) throws SQLException {\n                        arg.apply(position, statement, ctx);\n                    }\n\n                    @Override\n                    public String toString() {\n                        return Objects.toString(value);\n                    }\n                };\n            }\n        } catch (NoSuchMethodException e) {\n            throw new Error(\"toString method does not exist, Object hierarchy is corrupt\", e);\n        }\n    }\n\n    private UnsupportedOperationException factoryNotFound(Type type, Object value) {\n        if (type instanceof Class<?>) { // not a ParameterizedType\n            final TypeVariable<?>[] params = ((Class<?>) type).getTypeParameters();\n            if (params.length > 0) {\n                return new UnsupportedOperationException(\"No type parameters found for erased type '\" + type + Arrays.toString(params)\n                    + \"'. To bind a generic type, prefer using bindByType.\");\n            }\n        }\n        return new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of type \" + type);\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType) {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType) {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType) {\n        return bind(name, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType) {\n        return bind(position, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a parameter for each value in the given vararg array, and defines an attribute as the comma-separated list\n     * of parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", 1, 2, 3)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with no vararg values.\");\n        }\n\n        return bindList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     */\n    public final This bindList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with an empty list.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            String paramName = getConfig().get(SqlStatements.class).getSqlParser().nameParameter(name, getContext());\n            names.append(paramName);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean);\n\n            names.append(\"(\");\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(\",\");\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + \"_\" + valueIndex + \"_\" + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * @param key attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value\n     * @param methodNames list of methods that will be invoked on the values\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException if the method cannot be found\n     */\n    public final This bindMethodsList(String key, List<?> values, List<String> methodNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        if (methodNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            ObjectMethodArguments beanMethods = new ObjectMethodArguments(null, bean);\n\n            names.append(\"(\");\n            for (int methodIndex = 0; methodIndex < methodNames.size(); methodIndex++) {\n                if (methodIndex > 0) {\n                    names.append(\",\");\n                }\n\n                String methodName = methodNames.get(methodIndex);\n                String name = key + valueIndex + \".\" + methodName;\n                names.append(\":\").append(name);\n                Argument argument = beanMethods.find(methodName, ctx)\n                    .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + methodName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        if (values.contains(null)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    PreparedStatement internalExecute() {\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(sql, getContext());\n        getContext().setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, getContext());\n        String sql = parsedSql.getSql();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            if (getClass().isAssignableFrom(Call.class)) {\n                stmt = handle.getStatementBuilder().createCall(handle.getConnection(), sql, getContext());\n            } else {\n                stmt = handle.getStatementBuilder().create(handle.getConnection(), sql, getContext());\n            }\n\n            // The statement builder might (or might not) clean up the statement when called. E.g. the\n            // caching statement builder relies on the statement *not* being closed.\n            addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), this.sql, stmt));\n            getConfig(SqlStatements.class).customize(stmt);\n        } catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, getContext());\n        }\n\n        getContext().setStatement(stmt);\n\n        beforeBinding(stmt);\n\n        ArgumentBinder.bind(parsedSql.getParameters(), getBinding(), stmt, getContext());\n\n        beforeExecution(stmt);\n\n        try {\n            SqlLoggerUtil.wrap(stmt::execute, getContext(), getConfig(SqlStatements.class).getSqlLogger());\n        } catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n\n            throw new UnableToExecuteStatementException(e, getContext());\n        }\n\n        afterExecution(stmt);\n\n        return stmt;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(Class<T> type) {\n        return (RowMapper<T>) mapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(GenericType<T> type) {\n        return (RowMapper<T>) mapperForType(type.getType());\n    }\n\n    RowMapper<?> mapperForType(Type type) {\n        return getConfig(Mappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.MapArguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.argument.ObjectFieldArguments;\nimport org.jdbi.v3.core.argument.ObjectMethodArguments;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.Mappers;\nimport org.jdbi.v3.core.mapper.RowMapper;\n\nimport static java.util.stream.Collectors.joining;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private final Handle handle;\n    private final String sql;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private PreparedStatement stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding() {\n        return getContext().getBinding();\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql() {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds) {\n        return addCustomizer(StatementCustomizers.statementTimeout(seconds));\n    }\n\n    /**\n     * Transfer ownership of the handle to the statement: when the statement is closed,\n     * commit the handle's transaction (if one exists) and close the handle.\n     * @return this\n     */\n    public This cleanupHandleCommit() {\n        return cleanupHandle(Handle::commit);\n    }\n\n    /**\n     * When the statement is closed, roll it back then close the owning Handle.\n     * @return this\n     */\n    public This cleanupHandleRollback() {\n        return cleanupHandle(Handle::rollback);\n    }\n\n    private This cleanupHandle(Consumer<Handle> action) {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    action.accept(handle);\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument) {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument) {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean) {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(null, bean));\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(String prefix, Object bean) {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(Object object) {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(null, object));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param prefix a prefix to apply to all field names.\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(String prefix, Object object) {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(prefix, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument.\n     *\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(Object object) {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(null, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument, with the given prefix.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(String prefix, Object object) {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(prefix, object));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map) {\n        return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map));\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder) {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value) {\n        return bind(position, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value) {\n        return bind(name, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value) {\n        return bind(position, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value) {\n        return bind(name, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value) {\n        return bind(position, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value) {\n        return bind(position, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value) {\n        return bind(name, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value) {\n        return bind(name, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value) {\n        return bind(position, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value) {\n        return bind(name, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value) {\n        return bind(position, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value) {\n        return bind(name, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length) {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length) {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value) {\n        return bind(position, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value) {\n        return bind(name, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value) {\n        return bind(position, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value) {\n        return bind(position, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value) {\n        return bind(name, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value) {\n        return bind(name, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value) {\n        return bind(position, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value) {\n        return bind(position, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value) {\n        return bind(name, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value) {\n        return bind(name, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value) {\n        return bind(position, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value) {\n        return bind(name, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length) {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length) {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value) {\n        return bind(position, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value) {\n        return bind(name, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value) {\n        return bind(position, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value) {\n        return bind(name, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value) {\n        return bind(position, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value) {\n        return bind(name, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value) {\n        return bind(position, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value) {\n        return bind(position, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value) {\n        return bind(name, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value) {\n        return bind(name, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value) {\n        return bind(position, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value) {\n        return bind(position, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value) {\n        return bind(name, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value) {\n        return bind(name, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value) {\n        return bind(position, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value) {\n        return bind(position, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value) {\n        return bind(name, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value) {\n        return bind(name, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value) {\n        return bind(position, toArgument(Short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value) {\n        return bind(position, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value) {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value) {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value) {\n        return bind(position, toArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value) {\n        return bind(name, toArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value) {\n        return bind(position, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value) {\n        return bind(name, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value) {\n        return bind(position, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value) {\n        return bind(name, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value) {\n        return bind(position, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value) {\n        return bind(name, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType) {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType) {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType) {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType) {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    private Argument toArgument(Object value) {\n        return toArgument(value == null ? Object.class : value.getClass(), value);\n    }\n\n    private Argument toArgument(Type type, Object value) {\n        Argument arg = getConfig(Arguments.class).findFor(type, value)\n            .orElseThrow(() -> factoryNotFound(type, value));\n\n        try {\n            boolean toStringIsImplementedInArgument = arg.getClass().getMethod(\"toString\").getDeclaringClass() != Object.class;\n\n            if (toStringIsImplementedInArgument) {\n                return arg;\n            } else {\n                return new Argument() {\n                    @Override\n                    public void apply(int position, PreparedStatement statement, StatementContext ctx) throws SQLException {\n                        arg.apply(position, statement, ctx);\n                    }\n\n                    @Override\n                    public String toString() {\n                        return Objects.toString(value);\n                    }\n                };\n            }\n        } catch (NoSuchMethodException e) {\n            throw new Error(\"toString method does not exist, Object hierarchy is corrupt\", e);\n        }\n    }\n\n    private UnsupportedOperationException factoryNotFound(Type type, Object value) {\n        if (type instanceof Class<?>) { // not a ParameterizedType\n            final TypeVariable<?>[] params = ((Class<?>) type).getTypeParameters();\n            if (params.length > 0) {\n                return new UnsupportedOperationException(\"No type parameters found for erased type '\" + type + Arrays.toString(params)\n                    + \"'. To bind a generic type, prefer using bindByType.\");\n            }\n        }\n        return new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of type \" + type);\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType) {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType) {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType) {\n        return bind(name, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType) {\n        return bind(position, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a parameter for each value in the given vararg array, and defines an attribute as the comma-separated list\n     * of parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", 1, 2, 3)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with no vararg values.\");\n        }\n\n        return bindList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     */\n    public final This bindList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with an empty list.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            String paramName = getConfig().get(SqlStatements.class).getSqlParser().nameParameter(name, getContext());\n            names.append(paramName);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean);\n\n            names.append(\"(\");\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(\",\");\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + \"_\" + valueIndex + \"_\" + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * For each value given, create a tuple by invoking each given method in order, and bind the tuple into\n     * a {@code VALUES (...)} format insert clause.\n     * @param key attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value\n     * @param methodNames list of methods that will be invoked on the values\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException if the method cannot be found\n     */\n    public final This bindMethodsList(String key, Iterable<?> values, List<String> methodNames) throws UnableToCreateStatementException {\n        final Iterator<?> valueIter = values.iterator();\n        if (!valueIter.hasNext()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        if (methodNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                getClass().getSimpleName() + \".bindMethodsList was called with no values.\");\n        }\n\n        final StringBuilder names = new StringBuilder();\n        final StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIter.hasNext(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            final Object bean = valueIter.next();\n            final ObjectMethodArguments beanMethods = new ObjectMethodArguments(null, bean);\n\n            names.append(\"(\");\n            for (int methodIndex = 0; methodIndex < methodNames.size(); methodIndex++) {\n                if (methodIndex > 0) {\n                    names.append(\",\");\n                }\n\n                final String methodName = methodNames.get(methodIndex);\n                final String name = key + valueIndex + \".\" + methodName;\n                names.append(\":\").append(name);\n                final Argument argument = beanMethods.find(methodName, ctx)\n                    .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + methodName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        if (values.contains(null)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    PreparedStatement internalExecute() {\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(sql, getContext());\n        getContext().setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, getContext());\n        String sql = parsedSql.getSql();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            if (getClass().isAssignableFrom(Call.class)) {\n                stmt = handle.getStatementBuilder().createCall(handle.getConnection(), sql, getContext());\n            } else {\n                stmt = handle.getStatementBuilder().create(handle.getConnection(), sql, getContext());\n            }\n\n            // The statement builder might (or might not) clean up the statement when called. E.g. the\n            // caching statement builder relies on the statement *not* being closed.\n            addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), this.sql, stmt));\n            getConfig(SqlStatements.class).customize(stmt);\n        } catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, getContext());\n        }\n\n        getContext().setStatement(stmt);\n\n        beforeBinding(stmt);\n\n        ArgumentBinder.bind(parsedSql.getParameters(), getBinding(), stmt, getContext());\n\n        beforeExecution(stmt);\n\n        try {\n            SqlLoggerUtil.wrap(stmt::execute, getContext(), getConfig(SqlStatements.class).getSqlLogger());\n        } catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n\n            throw new UnableToExecuteStatementException(e, getContext());\n        }\n\n        afterExecution(stmt);\n\n        return stmt;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(Class<T> type) {\n        return (RowMapper<T>) mapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(GenericType<T> type) {\n        return (RowMapper<T>) mapperForType(type.getType());\n    }\n\n    RowMapper<?> mapperForType(Type type) {\n        return getConfig(Mappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n}\n","lineNo":1283}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\nimport net.jodah.expiringmap.ExpirationPolicy;\nimport net.jodah.expiringmap.ExpiringMap;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\nimport static java.util.stream.Collectors.toMap;\nimport static org.jdbi.v3.core.qualifier.Qualifiers.getQualifiers;\n\n/**\n * Inspect a {@link java.beans} style object and bind parameters\n * based on each of its discovered properties.\n */\npublic class BeanPropertyArguments extends MethodReturnValueNamedArgumentFinder {\n    private static final Map<Class<?>, Map<String, PropertyDescriptor>> CLASS_PROPERTY_DESCRIPTORS = ExpiringMap\n        .builder()\n        .expiration(10, TimeUnit.MINUTES)\n        .expirationPolicy(ExpirationPolicy.ACCESSED)\n        .entryLoader((Class<?> type) -> {\n            try {\n                BeanInfo info = Introspector.getBeanInfo(type);\n                return Stream.of(info.getPropertyDescriptors())\n                    .collect(toMap(PropertyDescriptor::getName, Function.identity()));\n            } catch (IntrospectionException e) {\n                throw new UnableToCreateStatementException(\n                    \"Failed to introspect object which is supposed to be used to \"\n                        + \"set named args for a statement via JavaBean properties\", e);\n            }\n        })\n        .build();\n\n    private final Map<String, PropertyDescriptor> propertyDescriptors;\n\n    /**\n     * @param prefix an optional prefix (we insert a '.' as a separator)\n     * @param bean the bean to inspect and bind\n     */\n    public BeanPropertyArguments(String prefix, Object bean) {\n        super(prefix, bean);\n\n        this.propertyDescriptors = CLASS_PROPERTY_DESCRIPTORS.get(bean.getClass());\n    }\n\n    @Override\n    Optional<TypedValue> getValue(String name, StatementContext ctx) {\n        PropertyDescriptor descriptor = propertyDescriptors.get(name);\n\n        if (descriptor == null) {\n            return Optional.empty();\n        }\n\n        Method getter = getGetter(name, descriptor, ctx);\n\n        Type type = getter.getGenericReturnType();\n        Set<Annotation> qualifiers = getQualifiers(getter, descriptor.getWriteMethod());\n        Object value = invokeMethod(getter, ctx);\n\n        return Optional.of(new TypedValue(type, qualifiers, value));\n    }\n\n    private Method getGetter(String name, PropertyDescriptor descriptor, StatementContext ctx) {\n        Method getter = descriptor.getReadMethod();\n\n        if (getter == null) {\n            throw new UnableToCreateStatementException(String.format(\"No getter method found for \"\n                    + \"bean property [%s] on [%s]\",\n                name, object), ctx);\n        }\n\n        return getter;\n    }\n\n    @Override\n    NamedArgumentFinder getNestedArgumentFinder(Object obj) {\n        return new BeanPropertyArguments(null, obj);\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + object + \"\\\"\";\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\nimport net.jodah.expiringmap.ExpirationPolicy;\nimport net.jodah.expiringmap.ExpiringMap;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\nimport static java.util.stream.Collectors.toMap;\nimport static org.jdbi.v3.core.qualifier.Qualifiers.getQualifiers;\n\n/**\n * Inspect a {@link java.beans} style object and bind parameters\n * based on each of its discovered properties.\n */\npublic class BeanPropertyArguments extends MethodReturnValueNamedArgumentFinder {\n    private static final Map<Class<?>, Map<String, PropertyDescriptor>> CLASS_PROPERTY_DESCRIPTORS = ExpiringMap\n        .builder()\n        .expiration(10, TimeUnit.MINUTES)\n        .expirationPolicy(ExpirationPolicy.ACCESSED)\n        .entryLoader((Class<?> type) -> {\n            try {\n                BeanInfo info = Introspector.getBeanInfo(type);\n                return Stream.of(info.getPropertyDescriptors())\n                    .collect(toMap(PropertyDescriptor::getName, Function.identity()));\n            } catch (IntrospectionException e) {\n                throw new UnableToCreateStatementException(\n                    \"Failed to introspect object which is supposed to be used to \"\n                        + \"set named args for a statement via JavaBean properties\", e);\n            }\n        })\n        .build();\n\n    private final Map<String, PropertyDescriptor> propertyDescriptors;\n\n    /**\n     * @param prefix an optional prefix (we insert a '.' as a separator)\n     * @param bean the bean to inspect and bind\n     */\n    public BeanPropertyArguments(String prefix, Object bean) {\n        super(prefix, bean);\n\n        this.propertyDescriptors = CLASS_PROPERTY_DESCRIPTORS.get(bean.getClass());\n    }\n\n    @Override\n    Optional<TypedValue> getValue(String name, StatementContext ctx) {\n        PropertyDescriptor descriptor = propertyDescriptors.get(name);\n\n        if (descriptor == null) {\n            return Optional.empty();\n        }\n\n        Method getter = getGetter(name, descriptor, ctx);\n        Method setter = descriptor.getWriteMethod();\n        Parameter setterParam = Optional.ofNullable(setter)\n            .map(m -> m.getParameterCount() > 0 ? m.getParameters()[0] : null)\n            .orElse(null);\n\n        Type type = getter.getGenericReturnType();\n        Set<Annotation> qualifiers = getQualifiers(getter, setter, setterParam);\n        Object value = invokeMethod(getter, ctx);\n\n        return Optional.of(new TypedValue(type, qualifiers, value));\n    }\n\n    private Method getGetter(String name, PropertyDescriptor descriptor, StatementContext ctx) {\n        Method getter = descriptor.getReadMethod();\n\n        if (getter == null) {\n            throw new UnableToCreateStatementException(String.format(\"No getter method found for \"\n                    + \"bean property [%s] on [%s]\",\n                name, object), ctx);\n        }\n\n        return getter;\n    }\n\n    @Override\n    NamedArgumentFinder getNestedArgumentFinder(Object obj) {\n        return new BeanPropertyArguments(null, obj);\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + object + \"\\\"\";\n    }\n}\n","lineNo":81}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\nimport net.jodah.expiringmap.ExpirationPolicy;\nimport net.jodah.expiringmap.ExpiringMap;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\nimport static java.util.stream.Collectors.toMap;\nimport static org.jdbi.v3.core.qualifier.Qualifiers.getQualifiers;\n\n/**\n * Inspect a {@link java.beans} style object and bind parameters\n * based on each of its discovered properties.\n */\npublic class BeanPropertyArguments extends MethodReturnValueNamedArgumentFinder {\n    private static final Map<Class<?>, Map<String, PropertyDescriptor>> CLASS_PROPERTY_DESCRIPTORS = ExpiringMap\n        .builder()\n        .expiration(10, TimeUnit.MINUTES)\n        .expirationPolicy(ExpirationPolicy.ACCESSED)\n        .entryLoader((Class<?> type) -> {\n            try {\n                BeanInfo info = Introspector.getBeanInfo(type);\n                return Stream.of(info.getPropertyDescriptors())\n                    .collect(toMap(PropertyDescriptor::getName, Function.identity()));\n            } catch (IntrospectionException e) {\n                throw new UnableToCreateStatementException(\n                    \"Failed to introspect object which is supposed to be used to \"\n                        + \"set named args for a statement via JavaBean properties\", e);\n            }\n        })\n        .build();\n\n    private final Map<String, PropertyDescriptor> propertyDescriptors;\n\n    /**\n     * @param prefix an optional prefix (we insert a '.' as a separator)\n     * @param bean the bean to inspect and bind\n     */\n    public BeanPropertyArguments(String prefix, Object bean) {\n        super(prefix, bean);\n\n        this.propertyDescriptors = CLASS_PROPERTY_DESCRIPTORS.get(bean.getClass());\n    }\n\n    @Override\n    Optional<TypedValue> getValue(String name, StatementContext ctx) {\n        PropertyDescriptor descriptor = propertyDescriptors.get(name);\n\n        if (descriptor == null) {\n            return Optional.empty();\n        }\n\n        Method getter = getGetter(name, descriptor, ctx);\n\n        Type type = getter.getGenericReturnType();\n        Set<Annotation> qualifiers = getQualifiers(getter, descriptor.getWriteMethod());\n        Object value = invokeMethod(getter, ctx);\n\n        return Optional.of(new TypedValue(type, qualifiers, value));\n    }\n\n    private Method getGetter(String name, PropertyDescriptor descriptor, StatementContext ctx) {\n        Method getter = descriptor.getReadMethod();\n\n        if (getter == null) {\n            throw new UnableToCreateStatementException(String.format(\"No getter method found for \"\n                    + \"bean property [%s] on [%s]\",\n                name, object), ctx);\n        }\n\n        return getter;\n    }\n\n    @Override\n    NamedArgumentFinder getNestedArgumentFinder(Object obj) {\n        return new BeanPropertyArguments(null, obj);\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + object + \"\\\"\";\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\nimport net.jodah.expiringmap.ExpirationPolicy;\nimport net.jodah.expiringmap.ExpiringMap;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\nimport static java.util.stream.Collectors.toMap;\nimport static org.jdbi.v3.core.qualifier.Qualifiers.getQualifiers;\n\n/**\n * Inspect a {@link java.beans} style object and bind parameters\n * based on each of its discovered properties.\n */\npublic class BeanPropertyArguments extends MethodReturnValueNamedArgumentFinder {\n    private static final Map<Class<?>, Map<String, PropertyDescriptor>> CLASS_PROPERTY_DESCRIPTORS = ExpiringMap\n        .builder()\n        .expiration(10, TimeUnit.MINUTES)\n        .expirationPolicy(ExpirationPolicy.ACCESSED)\n        .entryLoader((Class<?> type) -> {\n            try {\n                BeanInfo info = Introspector.getBeanInfo(type);\n                return Stream.of(info.getPropertyDescriptors())\n                    .collect(toMap(PropertyDescriptor::getName, Function.identity()));\n            } catch (IntrospectionException e) {\n                throw new UnableToCreateStatementException(\n                    \"Failed to introspect object which is supposed to be used to \"\n                        + \"set named args for a statement via JavaBean properties\", e);\n            }\n        })\n        .build();\n\n    private final Map<String, PropertyDescriptor> propertyDescriptors;\n\n    /**\n     * @param prefix an optional prefix (we insert a '.' as a separator)\n     * @param bean the bean to inspect and bind\n     */\n    public BeanPropertyArguments(String prefix, Object bean) {\n        super(prefix, bean);\n\n        this.propertyDescriptors = CLASS_PROPERTY_DESCRIPTORS.get(bean.getClass());\n    }\n\n    @Override\n    Optional<TypedValue> getValue(String name, StatementContext ctx) {\n        PropertyDescriptor descriptor = propertyDescriptors.get(name);\n\n        if (descriptor == null) {\n            return Optional.empty();\n        }\n\n        Method getter = getGetter(name, descriptor, ctx);\n        Method setter = descriptor.getWriteMethod();\n        Parameter setterParam = Optional.ofNullable(setter)\n            .map(m -> m.getParameterCount() > 0 ? m.getParameters()[0] : null)\n            .orElse(null);\n\n        Type type = getter.getGenericReturnType();\n        Set<Annotation> qualifiers = getQualifiers(getter, setter, setterParam);\n        Object value = invokeMethod(getter, ctx);\n\n        return Optional.of(new TypedValue(type, qualifiers, value));\n    }\n\n    private Method getGetter(String name, PropertyDescriptor descriptor, StatementContext ctx) {\n        Method getter = descriptor.getReadMethod();\n\n        if (getter == null) {\n            throw new UnableToCreateStatementException(String.format(\"No getter method found for \"\n                    + \"bean property [%s] on [%s]\",\n                name, object), ctx);\n        }\n\n        return getter;\n    }\n\n    @Override\n    NamedArgumentFinder getNestedArgumentFinder(Object obj) {\n        return new BeanPropertyArguments(null, obj);\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + object + \"\\\"\";\n    }\n}\n","lineNo":82}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Iterator;\nimport java.util.Optional;\nimport java.util.function.Consumer;\nimport java.util.stream.Collector;\nimport java.util.stream.Stream;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.sqlobject.SingleValue;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\n/**\n * Helper class used by the {@link CustomizingStatementHandler}s to assemble\n * the result Collection, Iterable, etc.\n */\nabstract class ResultReturner {\n    /**\n     * If the return type is {@code void}, swallow results.\n     * @param extensionType\n     * @param method\n     * @see ResultReturner#forMethod(Class, Method) if the return type is not void\n     * @return\n     */\n    static ResultReturner forOptionalReturn(Class<?> extensionType, Method method) {\n        if (method.getReturnType() == void.class) {\n            return new VoidReturner();\n        }\n        return forMethod(extensionType, method);\n    }\n\n    /**\n     * Inspect a Method for its return type, and choose a ResultReturner subclass\n     * that handles any container that might wrap the results.\n     * @param extensionType the type that owns the Method\n     * @param method the method whose return type chooses the ResultReturner\n     * @return an instance that takes a ResultIterable and constructs the return value\n     */\n    static ResultReturner forMethod(Class<?> extensionType, Method method) {\n        Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), extensionType);\n        Class<?> returnClass = getErasedType(returnType);\n        if (Void.TYPE.equals(returnClass)) {\n            return findConsumer(extensionType, method)\n                .orElseThrow(() -> new IllegalStateException(String.format(\n                    \"Method %s#%s is annotated as if it should return a value, but the method is void.\",\n                    method.getDeclaringClass().getName(),\n                    method.getName())));\n        } else if (ResultIterable.class.equals(returnClass)) {\n            return new ResultIterableReturner(returnType);\n        } else if (Stream.class.equals(returnClass)) {\n            return new StreamReturner(returnType);\n        } else if (ResultIterator.class.equals(returnClass)) {\n            return new ResultIteratorReturner(returnType);\n        } else if (Iterator.class.equals(returnClass)) {\n            return new IteratorReturner(returnType);\n        } else if (method.isAnnotationPresent(SingleValue.class)) {\n            return new SingleValueReturner(returnType);\n        } else {\n            return new CollectedResultReturner(returnType);\n        }\n    }\n\n    /**\n     * Inspect a Method for a {@link Consumer} to execute for each produced row.\n     * @param extensionType the extension that owns the method\n     * @param method the method called\n     * @return a ResultReturner that invokes the consumer and does not return a value\n     */\n    static Optional<ResultReturner> findConsumer(Class<?> extensionType, Method method) {\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        for (int i = 0; i < paramTypes.length; i++) {\n            if (paramTypes[i] == Consumer.class) {\n                return Optional.of(new ConsumerResultReturner(method, i));\n            }\n        }\n        return Optional.empty();\n    }\n\n    protected abstract Object mappedResult(ResultIterable<?> iterable, StatementContext ctx);\n    protected abstract Object reducedResult(Stream<?> stream, StatementContext ctx);\n\n    protected abstract Type elementType(StatementContext ctx);\n\n    private static Object checkResult(Object result, Type type) {\n        if (result == null && getErasedType(type).isPrimitive()) {\n            throw new IllegalStateException(\"SQL method returns primitive \" + type + \", but statement returned no results\");\n        }\n        return result;\n    }\n\n    static class VoidReturner extends ResultReturner {\n        @Override\n        protected Void mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            iterable.stream().forEach(i -> {}); // Make sure to consume the result\n            return null;\n        }\n\n        @Override\n        protected Void reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return void from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return null;\n        }\n    }\n\n    static class ResultIterableReturner extends ResultReturner {\n\n        private final Type elementType;\n\n        ResultIterableReturner(Type returnType) {\n            // extract T from Query<T>\n            elementType = GenericTypes.findGenericParameter(returnType, ResultIterable.class)\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect ResultIterable<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected ResultIterable<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable;\n        }\n\n        @Override\n        protected ResultIterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return ResultIterable from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n\n    static class StreamReturner extends ResultReturner {\n        private final Type elementType;\n\n        StreamReturner(Type returnType) {\n            elementType = GenericTypes.findGenericParameter(returnType, Stream.class)\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect Stream<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Stream<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.stream();\n        }\n\n        @Override\n        protected Stream<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            return stream;\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n\n    static class ResultIteratorReturner extends ResultReturner {\n        private final Type elementType;\n\n        ResultIteratorReturner(Type returnType) {\n            this.elementType = GenericTypes.findGenericParameter(returnType, Iterator.class)\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect ResultIterator<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected ResultIterator<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.iterator();\n        }\n\n        @Override\n        protected ResultIterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return ResultIterator from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n\n    static class IteratorReturner extends ResultReturner {\n        private final Type elementType;\n\n        IteratorReturner(Type returnType) {\n            this.elementType = GenericTypes.findGenericParameter(returnType, Iterator.class)\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect Iterator<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Iterator<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.iterator();\n        }\n\n        @Override\n        protected Iterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            return stream.iterator();\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n\n    static class SingleValueReturner extends ResultReturner {\n        private final Type returnType;\n\n        SingleValueReturner(Type returnType) {\n            this.returnType = returnType;\n        }\n\n        @Override\n        protected Object mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return checkResult(iterable.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected Object reducedResult(Stream<?> stream, StatementContext ctx) {\n            return checkResult(stream.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return returnType;\n        }\n    }\n\n    static class CollectedResultReturner extends ResultReturner {\n        private final Type returnType;\n\n        CollectedResultReturner(Type returnType) {\n            this.returnType = returnType;\n        }\n\n        @Override\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        protected Object mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            Collector collector = ctx.findCollectorFor(returnType).orElse(null);\n            if (collector != null) {\n                return iterable.collect(collector);\n            }\n            return checkResult(iterable.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected Object reducedResult(Stream<?> stream, StatementContext ctx) {\n            Collector collector = ctx.findCollectorFor(returnType).orElse(null);\n            if (collector != null) {\n                return stream.collect(collector);\n            }\n            return checkResult(stream.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            // if returnType is not supported by a collector factory, assume it to be a single-value return type.\n            return ctx.findElementTypeFor(returnType).orElse(returnType);\n        }\n    }\n\n    static class ConsumerResultReturner extends ResultReturner {\n        private final int consumerIndex;\n        private final Type elementType;\n\n        ConsumerResultReturner(Method method, int consumerIndex) {\n            this.consumerIndex = consumerIndex;\n            elementType = method.getGenericParameterTypes()[consumerIndex];\n        }\n\n        @Override\n        protected Void mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            @SuppressWarnings(\"unchecked\")\n            Consumer<Object> consumer = (Consumer<Object>)\n                ctx.getConfig(SqlObjectStatementConfiguration.class).getArgs()[consumerIndex];\n            iterable.forEach(consumer);\n            return null;\n        }\n\n        @Override\n        protected Void reducedResult(Stream<?> stream, StatementContext ctx) {\n            @SuppressWarnings(\"unchecked\")\n            Consumer<Object> consumer = (Consumer<Object>)\n                ctx.getConfig(SqlObjectStatementConfiguration.class).getArgs()[consumerIndex];\n            stream.forEach(consumer);\n            return null;\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement.internal;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Iterator;\nimport java.util.Optional;\nimport java.util.function.Consumer;\nimport java.util.stream.Collector;\nimport java.util.stream.Stream;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.qualifier.Qualifiers;\nimport org.jdbi.v3.core.result.ResultIterable;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.sqlobject.SingleValue;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\n/**\n * Helper class used by the {@link CustomizingStatementHandler}s to assemble\n * the result Collection, Iterable, etc.\n */\nabstract class ResultReturner {\n    /**\n     * If the return type is {@code void}, swallow results.\n     * @param extensionType\n     * @param method\n     * @see ResultReturner#forMethod(Class, Method) if the return type is not void\n     * @return\n     */\n    static ResultReturner forOptionalReturn(Class<?> extensionType, Method method) {\n        if (method.getReturnType() == void.class) {\n            return new VoidReturner();\n        }\n        return forMethod(extensionType, method);\n    }\n\n    /**\n     * Inspect a Method for its return type, and choose a ResultReturner subclass\n     * that handles any container that might wrap the results.\n     * @param extensionType the type that owns the Method\n     * @param method the method whose return type chooses the ResultReturner\n     * @return an instance that takes a ResultIterable and constructs the return value\n     */\n    static ResultReturner forMethod(Class<?> extensionType, Method method) {\n        Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), extensionType);\n        QualifiedType qualifiedReturnType =\n            QualifiedType.of(returnType, Qualifiers.getQualifyingAnnotations(method));\n        Class<?> returnClass = getErasedType(returnType);\n        if (Void.TYPE.equals(returnClass)) {\n            return findConsumer(extensionType, method)\n                .orElseThrow(() -> new IllegalStateException(String.format(\n                    \"Method %s#%s is annotated as if it should return a value, but the method is void.\",\n                    method.getDeclaringClass().getName(),\n                    method.getName())));\n        } else if (ResultIterable.class.equals(returnClass)) {\n            return new ResultIterableReturner(qualifiedReturnType);\n        } else if (Stream.class.equals(returnClass)) {\n            return new StreamReturner(qualifiedReturnType);\n        } else if (ResultIterator.class.equals(returnClass)) {\n            return new ResultIteratorReturner(qualifiedReturnType);\n        } else if (Iterator.class.equals(returnClass)) {\n            return new IteratorReturner(qualifiedReturnType);\n        } else if (method.isAnnotationPresent(SingleValue.class)) {\n            return new SingleValueReturner(qualifiedReturnType);\n        } else {\n            return new CollectedResultReturner(qualifiedReturnType);\n        }\n    }\n\n    /**\n     * Inspect a Method for a {@link Consumer} to execute for each produced row.\n     * @param extensionType the extension that owns the method\n     * @param method the method called\n     * @return a ResultReturner that invokes the consumer and does not return a value\n     */\n    static Optional<ResultReturner> findConsumer(Class<?> extensionType, Method method) {\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        for (int i = 0; i < paramTypes.length; i++) {\n            if (paramTypes[i] == Consumer.class) {\n                return Optional.of(new ConsumerResultReturner(method, i));\n            }\n        }\n        return Optional.empty();\n    }\n\n    protected abstract Object mappedResult(ResultIterable<?> iterable, StatementContext ctx);\n    protected abstract Object reducedResult(Stream<?> stream, StatementContext ctx);\n\n    protected abstract QualifiedType elementType(StatementContext ctx);\n\n    private static Object checkResult(Object result, QualifiedType type) {\n        if (result == null && getErasedType(type.getType()).isPrimitive()) {\n            throw new IllegalStateException(\"SQL method returns primitive \" + type + \", but statement returned no results\");\n        }\n        return result;\n    }\n\n    static class VoidReturner extends ResultReturner {\n        @Override\n        protected Void mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            iterable.stream().forEach(i -> {}); // Make sure to consume the result\n            return null;\n        }\n\n        @Override\n        protected Void reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return void from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected QualifiedType elementType(StatementContext ctx) {\n            return null;\n        }\n    }\n\n    static class ResultIterableReturner extends ResultReturner {\n\n        private final QualifiedType elementType;\n\n        ResultIterableReturner(QualifiedType returnType) {\n            // extract T from Query<T>\n            elementType = returnType.mapType(type -> GenericTypes.findGenericParameter(type, ResultIterable.class))\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect ResultIterable<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected ResultIterable<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable;\n        }\n\n        @Override\n        protected ResultIterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return ResultIterable from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected QualifiedType elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n\n    static class StreamReturner extends ResultReturner {\n        private final QualifiedType elementType;\n\n        StreamReturner(QualifiedType returnType) {\n            elementType = returnType.mapType(type -> GenericTypes.findGenericParameter(type, Stream.class))\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect Stream<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Stream<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.stream();\n        }\n\n        @Override\n        protected Stream<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            return stream;\n        }\n\n        @Override\n        protected QualifiedType elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n\n    static class ResultIteratorReturner extends ResultReturner {\n        private final QualifiedType elementType;\n\n        ResultIteratorReturner(QualifiedType returnType) {\n            this.elementType = returnType.mapType(type -> GenericTypes.findGenericParameter(type, Iterator.class))\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect ResultIterator<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected ResultIterator<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.iterator();\n        }\n\n        @Override\n        protected ResultIterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            throw new UnsupportedOperationException(\"Cannot return ResultIterator from a @UseRowReducer method\");\n        }\n\n        @Override\n        protected QualifiedType elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n\n    static class IteratorReturner extends ResultReturner {\n        private final QualifiedType elementType;\n\n        IteratorReturner(QualifiedType returnType) {\n            this.elementType = returnType.mapType(type -> GenericTypes.findGenericParameter(type, Iterator.class))\n                .orElseThrow(() -> new IllegalStateException(\n                    \"Cannot reflect Iterator<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Iterator<?> mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return iterable.iterator();\n        }\n\n        @Override\n        protected Iterator<?> reducedResult(Stream<?> stream, StatementContext ctx) {\n            return stream.iterator();\n        }\n\n        @Override\n        protected QualifiedType elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n\n    static class SingleValueReturner extends ResultReturner {\n        private final QualifiedType returnType;\n\n        SingleValueReturner(QualifiedType returnType) {\n            this.returnType = returnType;\n        }\n\n        @Override\n        protected Object mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            return checkResult(iterable.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected Object reducedResult(Stream<?> stream, StatementContext ctx) {\n            return checkResult(stream.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected QualifiedType elementType(StatementContext ctx) {\n            return returnType;\n        }\n    }\n\n    static class CollectedResultReturner extends ResultReturner {\n        private final QualifiedType returnType;\n\n        CollectedResultReturner(QualifiedType returnType) {\n            this.returnType = returnType;\n        }\n\n        @Override\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        protected Object mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            Collector collector = ctx.findCollectorFor(returnType.getType()).orElse(null);\n            if (collector != null) {\n                return iterable.collect(collector);\n            }\n            return checkResult(iterable.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected Object reducedResult(Stream<?> stream, StatementContext ctx) {\n            Collector collector = ctx.findCollectorFor(returnType.getType()).orElse(null);\n            if (collector != null) {\n                return stream.collect(collector);\n            }\n            return checkResult(stream.findFirst().orElse(null), returnType);\n        }\n\n        @Override\n        protected QualifiedType elementType(StatementContext ctx) {\n            // if returnType is not supported by a collector factory, assume it to be a single-value return type.\n            return returnType.mapType(type -> ctx.findElementTypeFor(type))\n                .orElse(returnType);\n        }\n    }\n\n    static class ConsumerResultReturner extends ResultReturner {\n        private final int consumerIndex;\n        private final QualifiedType elementType;\n\n        ConsumerResultReturner(Method method, int consumerIndex) {\n            this.consumerIndex = consumerIndex;\n            elementType = QualifiedType.of(\n                method.getGenericParameterTypes()[consumerIndex],\n                Qualifiers.getQualifyingAnnotations(method.getParameters()[consumerIndex]));\n        }\n\n        @Override\n        protected Void mappedResult(ResultIterable<?> iterable, StatementContext ctx) {\n            @SuppressWarnings(\"unchecked\")\n            Consumer<Object> consumer = (Consumer<Object>)\n                ctx.getConfig(SqlObjectStatementConfiguration.class).getArgs()[consumerIndex];\n            iterable.forEach(consumer);\n            return null;\n        }\n\n        @Override\n        protected Void reducedResult(Stream<?> stream, StatementContext ctx) {\n            @SuppressWarnings(\"unchecked\")\n            Consumer<Object> consumer = (Consumer<Object>)\n                ctx.getConfig(SqlObjectStatementConfiguration.class).getArgs()[consumerIndex];\n            stream.forEach(consumer);\n            return null;\n        }\n\n        @Override\n        protected QualifiedType elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n}\n","lineNo":61}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.util.Optional;\nimport org.jdbi.v3.core.argument.Argument;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.List;\n\nclass ArgumentBinder {\n    private ArgumentBinder() {\n        throw new UnsupportedOperationException(\"utility class\");\n    }\n\n    static void bind(ParsedParameters parameters, Binding binding, PreparedStatement statement, StatementContext context) {\n        if (parameters.isPositional()) {\n            bindPositional(parameters, binding, statement, context);\n        } else {\n            bindNamed(parameters, binding, statement, context);\n        }\n    }\n\n    private static void bindPositional(ParsedParameters params, Binding binding, PreparedStatement statement, StatementContext context) {\n        for (int i = 0; i < params.getParameterCount(); i++) {\n            Optional<Argument> argument = binding.findForPosition(i);\n\n            if (argument.isPresent()) {\n                try {\n                    argument.get().apply(i + 1, statement, context);\n                } catch (SQLException e) {\n                    throw new UnableToCreateStatementException(\"Exception while binding positional param at (0 based) position \" + i, e, context);\n                }\n            }\n        }\n    }\n\n    private static void bindNamed(ParsedParameters params, Binding binding, PreparedStatement statement, StatementContext context) {\n        List<String> parameterNames = params.getParameterNames();\n        if (parameterNames.isEmpty() && !binding.isEmpty() && !context.getConfig(SqlStatements.class).getAllowUnusedBindings()) {\n            throw new UnableToCreateStatementException(String.format(\"Unable to execute. The query doesn't have named parameters, but provided binding '%s'.\", binding), context);\n        }\n\n        for (int i = 0; i < parameterNames.size(); i++) {\n            String param = parameterNames.get(i);\n\n            try {\n                binding.findForName(param, context)\n                        .orElseThrow(() -> new UnableToCreateStatementException(String.format(\"Unable to execute, no named parameter matches '%s'.\", param), context))\n                        .apply(i + 1, statement, context);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(String.format(\"Exception while binding named parameter '%s'\", param), e, context);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.util.Optional;\nimport org.jdbi.v3.core.argument.Argument;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.List;\n\nclass ArgumentBinder {\n    private ArgumentBinder() {\n        throw new UnsupportedOperationException(\"utility class\");\n    }\n\n    static void bind(ParsedParameters parameters, Binding binding, PreparedStatement statement, StatementContext context) {\n        if (parameters.isPositional()) {\n            bindPositional(parameters, binding, statement, context);\n        } else {\n            bindNamed(parameters, binding, statement, context);\n        }\n    }\n\n    private static void bindPositional(ParsedParameters params, Binding binding, PreparedStatement statement, StatementContext context) {\n        // best effort: just try +1 (unless we expose a method to get the full binding count)\n        boolean moreArgumentsProvidedThanDeclared = binding.findForPosition(params.getParameterCount()).isPresent();\n        if (moreArgumentsProvidedThanDeclared && !context.getConfig(SqlStatements.class).getAllowUnusedBindings()) {\n            throw new UnableToCreateStatementException(\"Superfluous positional param at (0 based) position \" + params.getParameterCount(), context);\n        }\n\n        for (int i = 0; i < params.getParameterCount(); i++) {\n            Optional<Argument> argument = binding.findForPosition(i);\n\n            if (argument.isPresent()) {\n                try {\n                    argument.get().apply(i + 1, statement, context);\n                } catch (SQLException e) {\n                    throw new UnableToCreateStatementException(\"Exception while binding positional param at (0 based) position \" + i, e, context);\n                }\n            } else {\n                throw new UnableToCreateStatementException(\"Missing positional param at (0 based) position \" + i, context);\n            }\n        }\n    }\n\n    private static void bindNamed(ParsedParameters params, Binding binding, PreparedStatement statement, StatementContext context) {\n        List<String> paramNames = params.getParameterNames();\n\n        // best effort: compare empty to non-empty because we can't list the individual binding names (unless we expose a method to do so)\n        boolean argumentsProvidedButNoneDeclared = paramNames.isEmpty() && !binding.isEmpty();\n        if (argumentsProvidedButNoneDeclared && !context.getConfig(SqlStatements.class).getAllowUnusedBindings()) {\n            throw new UnableToCreateStatementException(String.format(\"Superfluous named parameters provided while the query declares none: '%s'.\", binding), context);\n        }\n\n        for (int i = 0; i < paramNames.size(); i++) {\n            String name = paramNames.get(i);\n\n            Optional<Argument> argument = binding.findForName(name, context);\n\n            if (argument.isPresent()) {\n                try {\n                    argument.get().apply(i + 1, statement, context);\n                } catch (SQLException e) {\n                    throw new UnableToCreateStatementException(String.format(\"Exception while binding named parameter '%s'\", name), e, context);\n                }\n            } else {\n                throw new UnableToCreateStatementException(String.format(\"Missing named parameter '%s'.\", name), context);\n            }\n        }\n    }\n}\n","lineNo":70}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.util.Optional;\nimport org.jdbi.v3.core.argument.Argument;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.List;\n\nclass ArgumentBinder {\n    private ArgumentBinder() {\n        throw new UnsupportedOperationException(\"utility class\");\n    }\n\n    static void bind(ParsedParameters parameters, Binding binding, PreparedStatement statement, StatementContext context) {\n        if (parameters.isPositional()) {\n            bindPositional(parameters, binding, statement, context);\n        } else {\n            bindNamed(parameters, binding, statement, context);\n        }\n    }\n\n    private static void bindPositional(ParsedParameters params, Binding binding, PreparedStatement statement, StatementContext context) {\n        for (int i = 0; i < params.getParameterCount(); i++) {\n            Optional<Argument> argument = binding.findForPosition(i);\n\n            if (argument.isPresent()) {\n                try {\n                    argument.get().apply(i + 1, statement, context);\n                } catch (SQLException e) {\n                    throw new UnableToCreateStatementException(\"Exception while binding positional param at (0 based) position \" + i, e, context);\n                }\n            }\n        }\n    }\n\n    private static void bindNamed(ParsedParameters params, Binding binding, PreparedStatement statement, StatementContext context) {\n        List<String> parameterNames = params.getParameterNames();\n        if (parameterNames.isEmpty() && !binding.isEmpty() && !context.getConfig(SqlStatements.class).getAllowUnusedBindings()) {\n            throw new UnableToCreateStatementException(String.format(\"Unable to execute. The query doesn't have named parameters, but provided binding '%s'.\", binding), context);\n        }\n\n        for (int i = 0; i < parameterNames.size(); i++) {\n            String param = parameterNames.get(i);\n\n            try {\n                binding.findForName(param, context)\n                        .orElseThrow(() -> new UnableToCreateStatementException(String.format(\"Unable to execute, no named parameter matches '%s'.\", param), context))\n                        .apply(i + 1, statement, context);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(String.format(\"Exception while binding named parameter '%s'\", param), e, context);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.util.Optional;\nimport org.jdbi.v3.core.argument.Argument;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.List;\n\nclass ArgumentBinder {\n    private ArgumentBinder() {\n        throw new UnsupportedOperationException(\"utility class\");\n    }\n\n    static void bind(ParsedParameters parameters, Binding binding, PreparedStatement statement, StatementContext context) {\n        if (parameters.isPositional()) {\n            bindPositional(parameters, binding, statement, context);\n        } else {\n            bindNamed(parameters, binding, statement, context);\n        }\n    }\n\n    private static void bindPositional(ParsedParameters params, Binding binding, PreparedStatement statement, StatementContext context) {\n        // best effort: just try +1 (unless we expose a method to get the full binding count)\n        boolean moreArgumentsProvidedThanDeclared = binding.findForPosition(params.getParameterCount()).isPresent();\n        if (moreArgumentsProvidedThanDeclared && !context.getConfig(SqlStatements.class).getAllowUnusedBindings()) {\n            throw new UnableToCreateStatementException(\"Superfluous positional param at (0 based) position \" + params.getParameterCount(), context);\n        }\n\n        for (int i = 0; i < params.getParameterCount(); i++) {\n            Optional<Argument> argument = binding.findForPosition(i);\n\n            if (argument.isPresent()) {\n                try {\n                    argument.get().apply(i + 1, statement, context);\n                } catch (SQLException e) {\n                    throw new UnableToCreateStatementException(\"Exception while binding positional param at (0 based) position \" + i, e, context);\n                }\n            } else {\n                throw new UnableToCreateStatementException(\"Missing positional param at (0 based) position \" + i, context);\n            }\n        }\n    }\n\n    private static void bindNamed(ParsedParameters params, Binding binding, PreparedStatement statement, StatementContext context) {\n        List<String> paramNames = params.getParameterNames();\n\n        // best effort: compare empty to non-empty because we can't list the individual binding names (unless we expose a method to do so)\n        boolean argumentsProvidedButNoneDeclared = paramNames.isEmpty() && !binding.isEmpty();\n        if (argumentsProvidedButNoneDeclared && !context.getConfig(SqlStatements.class).getAllowUnusedBindings()) {\n            throw new UnableToCreateStatementException(String.format(\"Superfluous named parameters provided while the query declares none: '%s'.\", binding), context);\n        }\n\n        for (int i = 0; i < paramNames.size(); i++) {\n            String name = paramNames.get(i);\n\n            Optional<Argument> argument = binding.findForName(name, context);\n\n            if (argument.isPresent()) {\n                try {\n                    argument.get().apply(i + 1, statement, context);\n                } catch (SQLException e) {\n                    throw new UnableToCreateStatementException(String.format(\"Exception while binding named parameter '%s'\", name), e, context);\n                }\n            } else {\n                throw new UnableToCreateStatementException(String.format(\"Missing named parameter '%s'.\", name), context);\n            }\n        }\n    }\n}\n","lineNo":62}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport java.beans.ConstructorProperties;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\nimport static org.jdbi.v3.core.mapper.reflect.JdbiConstructors.findConstructorFor;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\n/**\n * A row mapper which maps the fields in a result set into a constructor. The default implementation will perform a\n * case insensitive mapping between the constructor parameter names and the column labels,\n * also considering camel-case to underscores conversion.\n */\npublic class ConstructorMapper<T> implements RowMapper<T> {\n    /**\n     * Use the only declared constructor to map a class.\n     *\n     * @param clazz the class to find a constructor of\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Class<?> clazz) {\n        return RowMapperFactory.of(clazz, ConstructorMapper.of(clazz));\n    }\n\n    /**\n     * Use the only declared constructor to map a class.\n     *\n     * @param clazz the class to find a constructor of\n     * @param prefix a prefix for the parameter names\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Class<?> clazz, String prefix) {\n        return RowMapperFactory.of(clazz, ConstructorMapper.of(clazz, prefix));\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     *\n     * @param constructor the constructor to invoke\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Constructor<?> constructor) {\n        return RowMapperFactory.of(constructor.getDeclaringClass(), ConstructorMapper.of(constructor));\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     *\n     * @param constructor the constructor to invoke\n     * @param prefix a prefix to the constructor parameter names\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Constructor<?> constructor, String prefix) {\n        return RowMapperFactory.of(constructor.getDeclaringClass(), ConstructorMapper.of(constructor, prefix));\n    }\n\n    /**\n     * Return a ConstructorMapper for the given type.\n     *\n     * @param <T>  the type to map\n     * @param type the mapped type\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return ConstructorMapper.of(findConstructorFor(type));\n    }\n\n    /**\n     * Return a ConstructorMapper for the given type and prefix.\n     *\n     * @param <T>    the type to map\n     * @param type   the mapped type\n     * @param prefix the column name prefix\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return ConstructorMapper.of(findConstructorFor(type), prefix);\n    }\n\n    /**\n     * Return a ConstructorMapper using the given constructor\n     *\n     * @param <T> the type to map\n     * @param constructor the constructor to be used in mapping\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Constructor<T> constructor) {\n        return ConstructorMapper.of(constructor, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Instantiate a ConstructorMapper using the given constructor and prefix\n     *\n     * @param <T> the type to map\n     * @param constructor the constructor to be used in mapping\n     * @param prefix      the column name prefix\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Constructor<T> constructor, String prefix) {\n        return new ConstructorMapper<>(constructor, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Constructor<T> constructor;\n    private final String prefix;\n    private final ConstructorProperties constructorProperties;\n    private final Map<Parameter, ConstructorMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private ConstructorMapper(Constructor<T> constructor, String prefix) {\n        this.constructor = constructor;\n        this.prefix = prefix.toLowerCase();\n        this.constructorProperties = constructor.getAnnotation(ConstructorProperties.class);\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n        final List<ColumnNameMatcher> columnNameMatchers =\n                ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n        final List<String> unmatchedColumns = new ArrayList<>(columnNames);\n\n        RowMapper<T> mapper = specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching()\n            && unmatchedColumns.stream().anyMatch(col -> col.startsWith(prefix))) {\n\n            throw new IllegalArgumentException(String.format(\n                \"Mapping constructor-injected type %s could not match parameters for columns: %s\",\n                constructor.getDeclaringClass().getSimpleName(),\n                unmatchedColumns));\n        }\n\n        return mapper;\n    }\n\n    private RowMapper<T> specialize0(ResultSet rs,\n                                     StatementContext ctx,\n                                     List<String> columnNames,\n                                     List<ColumnNameMatcher> columnNameMatchers,\n                                     List<String> unmatchedColumns) throws SQLException {\n        final int count = constructor.getParameterCount();\n        final Parameter[] parameters = constructor.getParameters();\n\n        final RowMapper<?>[] mappers = new RowMapper<?>[count];\n        for (int i = 0; i < count; i++) {\n            final Parameter parameter = parameters[i];\n\n            Nested anno = parameter.getAnnotation(Nested.class);\n            if (anno == null) {\n                final String paramName = prefix + paramName(parameters, i, constructorProperties);\n\n                final int columnIndex = findColumnIndex(paramName, columnNames, columnNameMatchers,\n                    () -> debugName(parameter))\n                    .orElseThrow(() -> new IllegalArgumentException(String.format(\n                        \"Constructor '%s' parameter '%s' has no column in the result set. \"\n                            + \"Verify that the Java compiler is configured to emit parameter names, \"\n                            + \"that your result set has the columns expected, or annotate the \"\n                            + \"parameter names explicitly with @ColumnName\",\n                        constructor,\n                        paramName\n                   )));\n\n                final Type type = parameter.getParameterizedType();\n                mappers[i] = ctx.findColumnMapperFor(type)\n                    .map(mapper -> new SingleColumnMapper<>(mapper, columnIndex + 1))\n                    .orElseThrow(() -> new IllegalArgumentException(String.format(\n                        \"Could not find column mapper for type '%s' of parameter '%s' for constructor '%s'\",\n                        type, paramName, constructor)));\n\n                unmatchedColumns.remove(columnNames.get(columnIndex));\n            } else {\n                String nestedPrefix = prefix + anno.value();\n\n                mappers[i] = nestedMappers\n                    .computeIfAbsent(parameter, p ->\n                        new ConstructorMapper<>(findConstructorFor(p.getType()), nestedPrefix))\n                    .specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n            }\n        }\n\n        return (r, c) -> {\n            final Object[] params = new Object[count];\n\n            for (int i = 0; i < count; i++) {\n                params[i] = mappers[i].map(r, c);\n            }\n\n            return construct(params);\n        };\n    }\n\n    private static String paramName(Parameter[] parameters,\n                                    int position,\n                                    ConstructorProperties parameterNames) {\n        final Parameter parameter = parameters[position];\n        ColumnName dbName = parameter.getAnnotation(ColumnName.class);\n        if (dbName != null) {\n            return dbName.value();\n        }\n        if (parameterNames != null) {\n            return parameterNames.value()[position];\n        }\n        return parameter.getName();\n    }\n\n    private String debugName(Parameter parameter) {\n        return String.format(\"%s constructor parameter %s\",\n            constructor.getDeclaringClass().getSimpleName(),\n            parameter.getName());\n    }\n\n    private T construct(Object[] params) {\n        try {\n            return constructor.newInstance(params);\n        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            if (e.getCause() instanceof RuntimeException) {\n                throw (RuntimeException) e.getCause();\n            }\n            if (e.getCause() instanceof Error) {\n                throw (Error) e.getCause();\n            }\n            throw new RuntimeException(e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport java.beans.ConstructorProperties;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.OptionalInt;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\nimport static org.jdbi.v3.core.mapper.reflect.JdbiConstructors.findConstructorFor;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.anyColumnsStartWithPrefix;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\n/**\n * A row mapper which maps the fields in a result set into a constructor. The default implementation will perform a\n * case insensitive mapping between the constructor parameter names and the column labels,\n * also considering camel-case to underscores conversion.\n * <p>\n * This mapper respects {@link Nested} annotations on constructor parameters.\n * <p>\n * Constructor parameters annotated as {@code @Nullable} may be omitted from the result set without\n * error. Any annotation named \"Nullable\" is respected--nay, worshipped--no matter which package it is from.\n */\npublic class ConstructorMapper<T> implements RowMapper<T> {\n    private static final String DEFAULT_PREFIX = \"\";\n\n    private static final String UNMATCHED_CONSTRUCTOR_PARAMETERS =\n        \"Constructor '%s' could not match any parameter to any columns in the result set. \"\n            + \"Verify that the Java compiler is configured to emit parameter names, \"\n            + \"that your result set has the columns expected, annotate the \"\n            + \"parameter names explicitly with @ColumnName, or annotate nullable parameters as @Nullable\";\n\n    private static final String UNMATCHED_CONSTRUCTOR_PARAMETER =\n        \"Constructor '%s' parameter '%s' has no matching columns in the result set. \"\n            + \"Verify that the Java compiler is configured to emit parameter names, \"\n            + \"that your result set has the columns expected, annotate the \"\n            + \"parameter names explicitly with @ColumnName, or annotate nullable parameters as @Nullable\";\n\n    private static final String UNMATCHED_COLUMNS_STRICT =\n        \"Mapping constructor-injected type %s could not match parameters for columns: %s\";\n\n    private static final String MISSING_COLUMN_MAPPER =\n        \"Could not find column mapper for type '%s' of parameter '%s' for constructor '%s'\";\n\n    /**\n     * Use the only declared constructor to map a class.\n     *\n     * @param clazz the class to find a constructor of\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Class<?> clazz) {\n        return RowMapperFactory.of(clazz, ConstructorMapper.of(clazz));\n    }\n\n    /**\n     * Use the only declared constructor to map a class.\n     *\n     * @param clazz the class to find a constructor of\n     * @param prefix a prefix for the parameter names\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Class<?> clazz, String prefix) {\n        return RowMapperFactory.of(clazz, ConstructorMapper.of(clazz, prefix));\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     *\n     * @param constructor the constructor to invoke\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Constructor<?> constructor) {\n        return RowMapperFactory.of(constructor.getDeclaringClass(), ConstructorMapper.of(constructor));\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     *\n     * @param constructor the constructor to invoke\n     * @param prefix a prefix to the constructor parameter names\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Constructor<?> constructor, String prefix) {\n        return RowMapperFactory.of(constructor.getDeclaringClass(), ConstructorMapper.of(constructor, prefix));\n    }\n\n    /**\n     * Return a ConstructorMapper for the given type.\n     *\n     * @param <T>  the type to map\n     * @param type the mapped type\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return ConstructorMapper.of(findConstructorFor(type));\n    }\n\n    /**\n     * Return a ConstructorMapper for the given type and prefix.\n     *\n     * @param <T>    the type to map\n     * @param type   the mapped type\n     * @param prefix the column name prefix\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return ConstructorMapper.of(findConstructorFor(type), prefix);\n    }\n\n    /**\n     * Return a ConstructorMapper using the given constructor\n     *\n     * @param <T> the type to map\n     * @param constructor the constructor to be used in mapping\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Constructor<T> constructor) {\n        return ConstructorMapper.of(constructor, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Instantiate a ConstructorMapper using the given constructor and prefix\n     *\n     * @param <T> the type to map\n     * @param constructor the constructor to be used in mapping\n     * @param prefix      the column name prefix\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Constructor<T> constructor, String prefix) {\n        return new ConstructorMapper<>(constructor, prefix);\n    }\n\n    private final Constructor<T> constructor;\n    private final String prefix;\n    private final ConstructorProperties constructorProperties;\n    private final Map<Parameter, ConstructorMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private ConstructorMapper(Constructor<T> constructor, String prefix) {\n        this.constructor = constructor;\n        this.prefix = prefix.toLowerCase();\n        this.constructorProperties = constructor.getAnnotation(ConstructorProperties.class);\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n        final List<ColumnNameMatcher> columnNameMatchers =\n                ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n        final List<String> unmatchedColumns = new ArrayList<>(columnNames);\n\n        RowMapper<T> mapper = specialize0(ctx, columnNames, columnNameMatchers, unmatchedColumns)\n            .orElseThrow(() -> new IllegalArgumentException(String.format(\n                UNMATCHED_CONSTRUCTOR_PARAMETERS, constructor)));\n\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching()\n            && anyColumnsStartWithPrefix(unmatchedColumns, prefix, columnNameMatchers)) {\n\n            throw new IllegalArgumentException(\n                String.format(UNMATCHED_COLUMNS_STRICT, constructor.getDeclaringClass().getSimpleName(), unmatchedColumns));\n        }\n\n        return mapper;\n    }\n\n    private Optional<RowMapper<T>> specialize0(StatementContext ctx,\n                                               List<String> columnNames,\n                                               List<ColumnNameMatcher> columnNameMatchers,\n                                               List<String> unmatchedColumns) {\n        final int count = constructor.getParameterCount();\n        final Parameter[] parameters = constructor.getParameters();\n\n        final RowMapper<?>[] mappers = new RowMapper<?>[count];\n\n        boolean matchedColumns = false;\n        final List<String> unmatchedParameters = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            final Parameter parameter = parameters[i];\n\n            boolean nullable = isNullable(parameter);\n            Nested anno = parameter.getAnnotation(Nested.class);\n            if (anno == null) {\n                final String paramName = prefix + paramName(parameters, i, constructorProperties);\n\n                OptionalInt columnIndex = findColumnIndex(paramName, columnNames, columnNameMatchers,\n                    () -> debugName(parameter));\n                if (columnIndex.isPresent()) {\n                    int colIndex = columnIndex.getAsInt();\n                    final Type type = parameter.getParameterizedType();\n                    mappers[i] = ctx.findColumnMapperFor(type)\n                        .map(mapper -> new SingleColumnMapper<>(mapper, colIndex + 1))\n                        .orElseThrow(() -> new IllegalArgumentException(\n                            String.format(MISSING_COLUMN_MAPPER, type, paramName, constructor)));\n\n                    matchedColumns = true;\n                    unmatchedColumns.remove(columnNames.get(colIndex));\n                } else if (nullable) {\n                    mappers[i] = (r, c) -> null;\n                } else {\n                    unmatchedParameters.add(paramName);\n                }\n            } else {\n                String nestedPrefix = prefix + anno.value();\n\n                Optional<? extends RowMapper<?>> nestedMapper = nestedMappers\n                    .computeIfAbsent(parameter, p ->\n                        new ConstructorMapper<>(findConstructorFor(p.getType()), nestedPrefix))\n                    .specialize0(ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n                if (nestedMapper.isPresent()) {\n                    mappers[i] = nestedMapper.get();\n                    matchedColumns = true;\n                } else if (nullable) {\n                    mappers[i] = (r, c) -> null;\n                } else {\n                    unmatchedParameters.add(paramName(parameters, i, constructorProperties));\n                }\n            }\n        }\n\n        if (!matchedColumns) {\n            return Optional.empty();\n        }\n\n        if (!unmatchedParameters.isEmpty()) {\n            throw new IllegalArgumentException(String.format(\n                UNMATCHED_CONSTRUCTOR_PARAMETER, constructor, unmatchedParameters));\n\n        }\n\n        return Optional.of((r, c) -> {\n            final Object[] params = new Object[count];\n\n            for (int i = 0; i < count; i++) {\n                params[i] = mappers[i].map(r, c);\n            }\n\n            return construct(params);\n        });\n    }\n\n    private boolean isNullable(Parameter parameter) {\n        // Any annotation named @Nullable is honored. We're nice that way.\n        return Stream.of(parameter.getAnnotations())\n            .map(Annotation::annotationType)\n            .map(Class::getSimpleName)\n            .anyMatch(\"Nullable\"::equals);\n    }\n\n    private static String paramName(Parameter[] parameters,\n                                    int position,\n                                    ConstructorProperties parameterNames) {\n        final Parameter parameter = parameters[position];\n        ColumnName dbName = parameter.getAnnotation(ColumnName.class);\n        if (dbName != null) {\n            return dbName.value();\n        }\n        if (parameterNames != null) {\n            return parameterNames.value()[position];\n        }\n        return parameter.getName();\n    }\n\n    private String debugName(Parameter parameter) {\n        return String.format(\"%s constructor parameter %s\",\n            constructor.getDeclaringClass().getSimpleName(),\n            parameter.getName());\n    }\n\n    private T construct(Object[] params) {\n        try {\n            return constructor.newInstance(params);\n        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            if (e.getCause() instanceof RuntimeException) {\n                throw (RuntimeException) e.getCause();\n            }\n            if (e.getCause() instanceof Error) {\n                throw (Error) e.getCause();\n            }\n            throw new RuntimeException(e);\n        }\n    }\n}\n","lineNo":221}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizer.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\nimport org.jdbi.v3.sqlobject.internal.ParameterUtil;\n\npublic class BindFactory implements SqlStatementCustomizerFactory {\n    @Override\n    public SqlStatementParameterCustomizer createForParameter(Annotation annotation,\n                                                              Class<?> sqlObjectType,\n                                                              Method method,\n                                                              Parameter param,\n                                                              int index,\n                                                              Type type) {\n        Bind b = (Bind) annotation;\n        String nameFromAnnotation = b == null ? Bind.NO_VALUE : b.value();\n        Optional<String> name = ParameterUtil.findParameterName(nameFromAnnotation, param);\n\n        return (stmt, arg) -> {\n            stmt.bindByType(index, arg, type);\n            name.ifPresent(n -> stmt.bindByType(n, arg, type));\n        };\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizer.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.qualifier.Qualifiers;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\nimport org.jdbi.v3.sqlobject.internal.ParameterUtil;\n\npublic class BindFactory implements SqlStatementCustomizerFactory {\n    @Override\n    public SqlStatementParameterCustomizer createForParameter(Annotation annotation,\n                                                              Class<?> sqlObjectType,\n                                                              Method method,\n                                                              Parameter param,\n                                                              int index,\n                                                              Type type) {\n        Bind b = (Bind) annotation;\n        String nameFromAnnotation = b == null ? Bind.NO_VALUE : b.value();\n        Optional<String> name = ParameterUtil.findParameterName(nameFromAnnotation, param);\n        QualifiedType qualifiedType = QualifiedType.of(type, Qualifiers.getQualifyingAnnotations(param));\n\n        return (stmt, arg) -> {\n            stmt.bindByType(index, arg, qualifiedType);\n            name.ifPresent(n -> stmt.bindByType(n, arg, qualifiedType));\n        };\n    }\n}\n","lineNo":40}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the columns in a statement into a JavaBean. The default\n * implementation will perform a case insensitive mapping between the bean property\n * names and the column labels, also considering camel-case to underscores conversion.\n * This uses the JDK's built in bean mapping facilities, so it does not support nested\n * properties.\n *\n * The mapped class must have a default constructor.\n */\npublic class BeanMapper<T> implements RowMapper<T> {\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, BeanMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, BeanMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return BeanMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new BeanMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final BeanInfo info;\n    private final Map<PropertyDescriptor, BeanMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private BeanMapper(Class<T> type, String prefix) {\n        this.type = type;\n        this.prefix = prefix.toLowerCase();\n        try {\n            info = Introspector.getBeanInfo(type);\n        } catch (IntrospectionException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n        final List<ColumnNameMatcher> columnNameMatchers =\n                ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n        final List<String> unmatchedColumns = new ArrayList<>(columnNames);\n\n        RowMapper<T> result = specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching()\n            && unmatchedColumns.stream().anyMatch(col -> col.startsWith(prefix))) {\n\n            throw new IllegalArgumentException(String.format(\n                \"Mapping bean type %s could not match properties for columns: %s\",\n                type.getSimpleName(),\n                unmatchedColumns));\n        }\n\n        return result;\n    }\n\n    private RowMapper<T> specialize0(ResultSet rs,\n                                     StatementContext ctx,\n                                     List<String> columnNames,\n                                     List<ColumnNameMatcher> columnNameMatchers,\n                                     List<String> unmatchedColumns) throws SQLException {\n        final List<RowMapper<?>> mappers = new ArrayList<>();\n        final List<PropertyDescriptor> properties = new ArrayList<>();\n\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors()) {\n            Nested anno = Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(m -> m.getAnnotation(Nested.class))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElse(null);\n\n            if (anno == null) {\n                String paramName = prefix + paramName(descriptor);\n\n                findColumnIndex(paramName, columnNames, columnNameMatchers, () -> debugName(descriptor))\n                    .ifPresent(index -> {\n                        Type type = descriptor.getReadMethod().getGenericReturnType();\n                        ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                            .orElse((r, n, c) -> r.getObject(n));\n\n                        mappers.add(new SingleColumnMapper<>(mapper, index + 1));\n                        properties.add(descriptor);\n\n                        unmatchedColumns.remove(columnNames.get(index));\n                    });\n            } else {\n                String nestedPrefix = prefix + anno.value();\n\n                RowMapper<?> nestedMapper = nestedMappers\n                    .computeIfAbsent(descriptor, d -> new BeanMapper<>(d.getPropertyType(), nestedPrefix))\n                    .specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n                mappers.add(nestedMapper);\n                properties.add(descriptor);\n            }\n        }\n\n        if (mappers.isEmpty() && columnNames.size() > 0) {\n            throw new IllegalArgumentException(String.format(\"Mapping bean type %s \"\n                + \"didn't find any matching columns in result set\", type));\n        }\n\n        return (r, c) -> {\n            T bean = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                PropertyDescriptor property = properties.get(i);\n\n                Object value = mapper.map(r, ctx);\n\n                writeProperty(bean, property, value);\n            }\n\n            return bean;\n        };\n    }\n\n    private static String paramName(PropertyDescriptor descriptor) {\n        return Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(method -> method.getAnnotation(ColumnName.class))\n                .filter(Objects::nonNull)\n                .map(ColumnName::value)\n                .findFirst()\n                .orElseGet(descriptor::getName);\n    }\n\n    private String debugName(PropertyDescriptor descriptor) {\n        return String.format(\"%s.%s\", type.getSimpleName(), descriptor.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \"\n                + \"which was not instantiable\", type.getName()), e);\n        }\n    }\n\n    private static void writeProperty(Object bean, PropertyDescriptor property, Object value) {\n        try {\n            property.getWriteMethod().invoke(bean, value);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access setter for \"\n                + \"property, %s\", property.getName()), e);\n        } catch (InvocationTargetException e) {\n            throw new IllegalArgumentException(String.format(\"Invocation target exception trying to \"\n                + \"invoker setter for the %s property\", property.getName()), e);\n        } catch (NullPointerException e) {\n            throw new IllegalArgumentException(String.format(\"No appropriate method to \"\n                + \"write property %s\", property.getName()), e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\nimport static org.jdbi.v3.core.qualifier.Qualifiers.getQualifyingAnnotations;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the columns in a statement into a JavaBean. The default\n * implementation will perform a case insensitive mapping between the bean property\n * names and the column labels, also considering camel-case to underscores conversion.\n * This uses the JDK's built in bean mapping facilities, so it does not support nested\n * properties.\n *\n * The mapped class must have a default constructor.\n */\npublic class BeanMapper<T> implements RowMapper<T> {\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, BeanMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, BeanMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return BeanMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new BeanMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final BeanInfo info;\n    private final Map<PropertyDescriptor, BeanMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private BeanMapper(Class<T> type, String prefix) {\n        this.type = type;\n        this.prefix = prefix.toLowerCase();\n        try {\n            info = Introspector.getBeanInfo(type);\n        } catch (IntrospectionException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n        final List<ColumnNameMatcher> columnNameMatchers =\n                ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n        final List<String> unmatchedColumns = new ArrayList<>(columnNames);\n\n        RowMapper<T> result = specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching()\n            && unmatchedColumns.stream().anyMatch(col -> col.startsWith(prefix))) {\n\n            throw new IllegalArgumentException(String.format(\n                \"Mapping bean type %s could not match properties for columns: %s\",\n                type.getSimpleName(),\n                unmatchedColumns));\n        }\n\n        return result;\n    }\n\n    private RowMapper<T> specialize0(ResultSet rs,\n                                     StatementContext ctx,\n                                     List<String> columnNames,\n                                     List<ColumnNameMatcher> columnNameMatchers,\n                                     List<String> unmatchedColumns) throws SQLException {\n        final List<RowMapper<?>> mappers = new ArrayList<>();\n        final List<PropertyDescriptor> properties = new ArrayList<>();\n\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors()) {\n            Method getter = descriptor.getReadMethod();\n            Method setter = descriptor.getWriteMethod();\n            Nested anno = Stream.of(getter, setter)\n                .filter(Objects::nonNull)\n                .map(m -> m.getAnnotation(Nested.class))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElse(null);\n\n            if (anno == null) {\n                String paramName = prefix + paramName(descriptor);\n\n                findColumnIndex(paramName, columnNames, columnNameMatchers, () -> debugName(descriptor))\n                    .ifPresent(index -> {\n                        QualifiedType type = QualifiedType.of(\n                            getter.getGenericReturnType(),\n                            getQualifyingAnnotations(getter, setter));\n                        ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                            .orElse((r, n, c) -> r.getObject(n));\n\n                        mappers.add(new SingleColumnMapper<>(mapper, index + 1));\n                        properties.add(descriptor);\n\n                        unmatchedColumns.remove(columnNames.get(index));\n                    });\n            } else {\n                String nestedPrefix = prefix + anno.value();\n\n                RowMapper<?> nestedMapper = nestedMappers\n                    .computeIfAbsent(descriptor, d -> new BeanMapper<>(d.getPropertyType(), nestedPrefix))\n                    .specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n                mappers.add(nestedMapper);\n                properties.add(descriptor);\n            }\n        }\n\n        if (mappers.isEmpty() && columnNames.size() > 0) {\n            throw new IllegalArgumentException(String.format(\"Mapping bean type %s \"\n                + \"didn't find any matching columns in result set\", type));\n        }\n\n        return (r, c) -> {\n            T bean = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                PropertyDescriptor property = properties.get(i);\n\n                Object value = mapper.map(r, ctx);\n\n                writeProperty(bean, property, value);\n            }\n\n            return bean;\n        };\n    }\n\n    private static String paramName(PropertyDescriptor descriptor) {\n        return Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(method -> method.getAnnotation(ColumnName.class))\n                .filter(Objects::nonNull)\n                .map(ColumnName::value)\n                .findFirst()\n                .orElseGet(descriptor::getName);\n    }\n\n    private String debugName(PropertyDescriptor descriptor) {\n        return String.format(\"%s.%s\", type.getSimpleName(), descriptor.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \"\n                + \"which was not instantiable\", type.getName()), e);\n        }\n    }\n\n    private static void writeProperty(Object bean, PropertyDescriptor property, Object value) {\n        try {\n            property.getWriteMethod().invoke(bean, value);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access setter for \"\n                + \"property, %s\", property.getName()), e);\n        } catch (InvocationTargetException e) {\n            throw new IllegalArgumentException(String.format(\"Invocation target exception trying to \"\n                + \"invoker setter for the %s property\", property.getName()), e);\n        } catch (NullPointerException e) {\n            throw new IllegalArgumentException(String.format(\"No appropriate method to \"\n                + \"write property %s\", property.getName()), e);\n        }\n    }\n}\n","lineNo":149}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the columns in a statement into a JavaBean. The default\n * implementation will perform a case insensitive mapping between the bean property\n * names and the column labels, also considering camel-case to underscores conversion.\n * This uses the JDK's built in bean mapping facilities, so it does not support nested\n * properties.\n *\n * The mapped class must have a default constructor.\n */\npublic class BeanMapper<T> implements RowMapper<T> {\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, BeanMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, BeanMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return BeanMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new BeanMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final BeanInfo info;\n    private final Map<PropertyDescriptor, BeanMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private BeanMapper(Class<T> type, String prefix) {\n        this.type = type;\n        this.prefix = prefix.toLowerCase();\n        try {\n            info = Introspector.getBeanInfo(type);\n        } catch (IntrospectionException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n        final List<ColumnNameMatcher> columnNameMatchers =\n                ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n        final List<String> unmatchedColumns = new ArrayList<>(columnNames);\n\n        RowMapper<T> result = specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching()\n            && unmatchedColumns.stream().anyMatch(col -> col.startsWith(prefix))) {\n\n            throw new IllegalArgumentException(String.format(\n                \"Mapping bean type %s could not match properties for columns: %s\",\n                type.getSimpleName(),\n                unmatchedColumns));\n        }\n\n        return result;\n    }\n\n    private RowMapper<T> specialize0(ResultSet rs,\n                                     StatementContext ctx,\n                                     List<String> columnNames,\n                                     List<ColumnNameMatcher> columnNameMatchers,\n                                     List<String> unmatchedColumns) throws SQLException {\n        final List<RowMapper<?>> mappers = new ArrayList<>();\n        final List<PropertyDescriptor> properties = new ArrayList<>();\n\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors()) {\n            Nested anno = Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(m -> m.getAnnotation(Nested.class))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElse(null);\n\n            if (anno == null) {\n                String paramName = prefix + paramName(descriptor);\n\n                findColumnIndex(paramName, columnNames, columnNameMatchers, () -> debugName(descriptor))\n                    .ifPresent(index -> {\n                        Type type = descriptor.getReadMethod().getGenericReturnType();\n                        ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                            .orElse((r, n, c) -> r.getObject(n));\n\n                        mappers.add(new SingleColumnMapper<>(mapper, index + 1));\n                        properties.add(descriptor);\n\n                        unmatchedColumns.remove(columnNames.get(index));\n                    });\n            } else {\n                String nestedPrefix = prefix + anno.value();\n\n                RowMapper<?> nestedMapper = nestedMappers\n                    .computeIfAbsent(descriptor, d -> new BeanMapper<>(d.getPropertyType(), nestedPrefix))\n                    .specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n                mappers.add(nestedMapper);\n                properties.add(descriptor);\n            }\n        }\n\n        if (mappers.isEmpty() && columnNames.size() > 0) {\n            throw new IllegalArgumentException(String.format(\"Mapping bean type %s \"\n                + \"didn't find any matching columns in result set\", type));\n        }\n\n        return (r, c) -> {\n            T bean = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                PropertyDescriptor property = properties.get(i);\n\n                Object value = mapper.map(r, ctx);\n\n                writeProperty(bean, property, value);\n            }\n\n            return bean;\n        };\n    }\n\n    private static String paramName(PropertyDescriptor descriptor) {\n        return Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(method -> method.getAnnotation(ColumnName.class))\n                .filter(Objects::nonNull)\n                .map(ColumnName::value)\n                .findFirst()\n                .orElseGet(descriptor::getName);\n    }\n\n    private String debugName(PropertyDescriptor descriptor) {\n        return String.format(\"%s.%s\", type.getSimpleName(), descriptor.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \"\n                + \"which was not instantiable\", type.getName()), e);\n        }\n    }\n\n    private static void writeProperty(Object bean, PropertyDescriptor property, Object value) {\n        try {\n            property.getWriteMethod().invoke(bean, value);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access setter for \"\n                + \"property, %s\", property.getName()), e);\n        } catch (InvocationTargetException e) {\n            throw new IllegalArgumentException(String.format(\"Invocation target exception trying to \"\n                + \"invoker setter for the %s property\", property.getName()), e);\n        } catch (NullPointerException e) {\n            throw new IllegalArgumentException(String.format(\"No appropriate method to \"\n                + \"write property %s\", property.getName()), e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\nimport static org.jdbi.v3.core.qualifier.Qualifiers.getQualifyingAnnotations;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.qualifier.QualifiedType;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the columns in a statement into a JavaBean. The default\n * implementation will perform a case insensitive mapping between the bean property\n * names and the column labels, also considering camel-case to underscores conversion.\n * This uses the JDK's built in bean mapping facilities, so it does not support nested\n * properties.\n *\n * The mapped class must have a default constructor.\n */\npublic class BeanMapper<T> implements RowMapper<T> {\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, BeanMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, BeanMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return BeanMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new BeanMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final BeanInfo info;\n    private final Map<PropertyDescriptor, BeanMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private BeanMapper(Class<T> type, String prefix) {\n        this.type = type;\n        this.prefix = prefix.toLowerCase();\n        try {\n            info = Introspector.getBeanInfo(type);\n        } catch (IntrospectionException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n        final List<ColumnNameMatcher> columnNameMatchers =\n                ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n        final List<String> unmatchedColumns = new ArrayList<>(columnNames);\n\n        RowMapper<T> result = specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching()\n            && unmatchedColumns.stream().anyMatch(col -> col.startsWith(prefix))) {\n\n            throw new IllegalArgumentException(String.format(\n                \"Mapping bean type %s could not match properties for columns: %s\",\n                type.getSimpleName(),\n                unmatchedColumns));\n        }\n\n        return result;\n    }\n\n    private RowMapper<T> specialize0(ResultSet rs,\n                                     StatementContext ctx,\n                                     List<String> columnNames,\n                                     List<ColumnNameMatcher> columnNameMatchers,\n                                     List<String> unmatchedColumns) throws SQLException {\n        final List<RowMapper<?>> mappers = new ArrayList<>();\n        final List<PropertyDescriptor> properties = new ArrayList<>();\n\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors()) {\n            Method getter = descriptor.getReadMethod();\n            Method setter = descriptor.getWriteMethod();\n            Nested anno = Stream.of(getter, setter)\n                .filter(Objects::nonNull)\n                .map(m -> m.getAnnotation(Nested.class))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElse(null);\n\n            if (anno == null) {\n                String paramName = prefix + paramName(descriptor);\n\n                findColumnIndex(paramName, columnNames, columnNameMatchers, () -> debugName(descriptor))\n                    .ifPresent(index -> {\n                        QualifiedType type = QualifiedType.of(\n                            getter.getGenericReturnType(),\n                            getQualifyingAnnotations(getter, setter));\n                        ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                            .orElse((r, n, c) -> r.getObject(n));\n\n                        mappers.add(new SingleColumnMapper<>(mapper, index + 1));\n                        properties.add(descriptor);\n\n                        unmatchedColumns.remove(columnNames.get(index));\n                    });\n            } else {\n                String nestedPrefix = prefix + anno.value();\n\n                RowMapper<?> nestedMapper = nestedMappers\n                    .computeIfAbsent(descriptor, d -> new BeanMapper<>(d.getPropertyType(), nestedPrefix))\n                    .specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n                mappers.add(nestedMapper);\n                properties.add(descriptor);\n            }\n        }\n\n        if (mappers.isEmpty() && columnNames.size() > 0) {\n            throw new IllegalArgumentException(String.format(\"Mapping bean type %s \"\n                + \"didn't find any matching columns in result set\", type));\n        }\n\n        return (r, c) -> {\n            T bean = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                PropertyDescriptor property = properties.get(i);\n\n                Object value = mapper.map(r, ctx);\n\n                writeProperty(bean, property, value);\n            }\n\n            return bean;\n        };\n    }\n\n    private static String paramName(PropertyDescriptor descriptor) {\n        return Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(method -> method.getAnnotation(ColumnName.class))\n                .filter(Objects::nonNull)\n                .map(ColumnName::value)\n                .findFirst()\n                .orElseGet(descriptor::getName);\n    }\n\n    private String debugName(PropertyDescriptor descriptor) {\n        return String.format(\"%s.%s\", type.getSimpleName(), descriptor.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \"\n                + \"which was not instantiable\", type.getName()), e);\n        }\n    }\n\n    private static void writeProperty(Object bean, PropertyDescriptor property, Object value) {\n        try {\n            property.getWriteMethod().invoke(bean, value);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access setter for \"\n                + \"property, %s\", property.getName()), e);\n        } catch (InvocationTargetException e) {\n            throw new IllegalArgumentException(String.format(\"Invocation target exception trying to \"\n                + \"invoker setter for the %s property\", property.getName()), e);\n        } catch (NullPointerException e) {\n            throw new IllegalArgumentException(String.format(\"No appropriate method to \"\n                + \"write property %s\", property.getName()), e);\n        }\n    }\n}\n","lineNo":150}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\n/**\n * A row mapper which maps the columns in a statement into a JavaBean. The default\n * implementation will perform a case insensitive mapping between the bean property\n * names and the column labels, also considering camel-case to underscores conversion.\n * This uses the JDK's built in bean mapping facilities, so it does not support nested\n * properties.\n *\n * The mapped class must have a default constructor.\n */\npublic class BeanMapper<T> implements RowMapper<T> {\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, BeanMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, BeanMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return BeanMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new BeanMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final BeanInfo info;\n    private final Map<PropertyDescriptor, BeanMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private BeanMapper(Class<T> type, String prefix) {\n        this.type = type;\n        this.prefix = prefix.toLowerCase();\n        try {\n            info = Introspector.getBeanInfo(type);\n        } catch (IntrospectionException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n        final List<ColumnNameMatcher> columnNameMatchers =\n                ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n        final List<String> unmatchedColumns = new ArrayList<>(columnNames);\n\n        RowMapper<T> result = specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching()\n            && unmatchedColumns.stream().anyMatch(col -> col.startsWith(prefix))) {\n\n            throw new IllegalArgumentException(String.format(\n                \"Mapping bean type %s could not match properties for columns: %s\",\n                type.getSimpleName(),\n                unmatchedColumns));\n        }\n\n        return result;\n    }\n\n    private RowMapper<T> specialize0(ResultSet rs,\n                                     StatementContext ctx,\n                                     List<String> columnNames,\n                                     List<ColumnNameMatcher> columnNameMatchers,\n                                     List<String> unmatchedColumns) throws SQLException {\n        final List<RowMapper<?>> mappers = new ArrayList<>();\n        final List<PropertyDescriptor> properties = new ArrayList<>();\n\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors()) {\n            Nested anno = Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(m -> m.getAnnotation(Nested.class))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElse(null);\n\n            if (anno == null) {\n                String paramName = prefix + paramName(descriptor);\n\n                findColumnIndex(paramName, columnNames, columnNameMatchers, () -> debugName(descriptor))\n                    .ifPresent(index -> {\n                        Type type = descriptor.getReadMethod().getGenericReturnType();\n                        ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                            .orElse((r, n, c) -> r.getObject(n));\n\n                        mappers.add(new SingleColumnMapper<>(mapper, index + 1));\n                        properties.add(descriptor);\n\n                        unmatchedColumns.remove(columnNames.get(index));\n                    });\n            } else {\n                String nestedPrefix = prefix + anno.value();\n\n                RowMapper<?> nestedMapper = nestedMappers\n                    .computeIfAbsent(descriptor, d -> new BeanMapper<>(d.getPropertyType(), nestedPrefix))\n                    .specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n                mappers.add(nestedMapper);\n                properties.add(descriptor);\n            }\n        }\n\n        if (mappers.isEmpty() && !columnNames.isEmpty()) {\n            throw new IllegalArgumentException(String.format(\"Mapping bean type %s \"\n                + \"didn't find any matching columns in result set\", type));\n        }\n\n        return (r, c) -> {\n            T bean = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                PropertyDescriptor property = properties.get(i);\n\n                Object value = mapper.map(r, ctx);\n\n                writeProperty(bean, property, value);\n            }\n\n            return bean;\n        };\n    }\n\n    private static String paramName(PropertyDescriptor descriptor) {\n        return Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(method -> method.getAnnotation(ColumnName.class))\n                .filter(Objects::nonNull)\n                .map(ColumnName::value)\n                .findFirst()\n                .orElseGet(descriptor::getName);\n    }\n\n    private String debugName(PropertyDescriptor descriptor) {\n        return String.format(\"%s.%s\", type.getSimpleName(), descriptor.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \"\n                + \"which was not instantiable\", type.getName()), e);\n        }\n    }\n\n    private static void writeProperty(Object bean, PropertyDescriptor property, Object value) {\n        try {\n            property.getWriteMethod().invoke(bean, value);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access setter for \"\n                + \"property, %s\", property.getName()), e);\n        } catch (InvocationTargetException e) {\n            throw new IllegalArgumentException(String.format(\"Invocation target exception trying to \"\n                + \"invoker setter for the %s property\", property.getName()), e);\n        } catch (NullPointerException e) {\n            throw new IllegalArgumentException(String.format(\"No appropriate method to \"\n                + \"write property %s\", property.getName()), e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\n/**\n * A row mapper which maps the columns in a statement into a JavaBean. The default\n * implementation will perform a case insensitive mapping between the bean property\n * names and the column labels, also considering camel-case to underscores conversion.\n * This uses the JDK's built in bean mapping facilities, so it does not support nested\n * properties.\n *\n * The mapped class must have a default constructor.\n */\npublic class BeanMapper<T> implements RowMapper<T> {\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, BeanMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, BeanMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return BeanMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new BeanMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final BeanInfo info;\n    private final Map<PropertyDescriptor, BeanMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private BeanMapper(Class<T> type, String prefix) {\n        this.type = type;\n        this.prefix = prefix.toLowerCase();\n        try {\n            info = Introspector.getBeanInfo(type);\n        } catch (IntrospectionException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n        final List<ColumnNameMatcher> columnNameMatchers =\n                ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n        final List<String> unmatchedColumns = new ArrayList<>(columnNames);\n\n        RowMapper<T> result = specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching()\n            && unmatchedColumns.stream().anyMatch(col -> col.startsWith(prefix))) {\n\n            throw new IllegalArgumentException(String.format(\n                \"Mapping bean type %s could not match properties for columns: %s\",\n                type.getSimpleName(),\n                unmatchedColumns));\n        }\n\n        return result;\n    }\n\n    private RowMapper<T> specialize0(ResultSet rs,\n                                     StatementContext ctx,\n                                     List<String> columnNames,\n                                     List<ColumnNameMatcher> columnNameMatchers,\n                                     List<String> unmatchedColumns) throws SQLException {\n        final List<RowMapper<?>> mappers = new ArrayList<>();\n        final List<PropertyDescriptor> properties = new ArrayList<>();\n\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors()) {\n            Nested anno = Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(m -> m.getAnnotation(Nested.class))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElse(null);\n\n            if (anno == null) {\n                String paramName = prefix + paramName(descriptor);\n\n                findColumnIndex(paramName, columnNames, columnNameMatchers, () -> debugName(descriptor))\n                    .ifPresent(index -> {\n                        Type type = descriptor.getReadMethod().getGenericReturnType();\n                        ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                            .orElse((r, n, c) -> r.getObject(n));\n\n                        mappers.add(new SingleColumnMapper<>(mapper, index + 1));\n                        properties.add(descriptor);\n\n                        unmatchedColumns.remove(columnNames.get(index));\n                    });\n            } else {\n                String nestedPrefix = prefix + anno.value();\n\n                RowMapper<?> nestedMapper = nestedMappers\n                    .computeIfAbsent(descriptor, d -> new BeanMapper<>(d.getPropertyType(), nestedPrefix))\n                    .specialize0(rs, ctx, columnNames, columnNameMatchers, unmatchedColumns);\n\n                mappers.add(nestedMapper);\n                properties.add(descriptor);\n            }\n        }\n\n        if (mappers.isEmpty() && !columnNames.isEmpty()) {\n            throw new IllegalArgumentException(String.format(\"Mapping bean type %s \"\n                + \"didn't find any matching columns in result set\", type));\n        }\n\n        return (r, c) -> {\n            T bean = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                PropertyDescriptor property = properties.get(i);\n\n                Object value = mapper.map(r, ctx);\n\n                writeProperty(bean, property, value);\n            }\n\n            return bean;\n        };\n    }\n\n    private static String paramName(PropertyDescriptor descriptor) {\n        return Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(method -> method.getAnnotation(ColumnName.class))\n                .filter(Objects::nonNull)\n                .map(ColumnName::value)\n                .findFirst()\n                .orElseGet(descriptor::getName);\n    }\n\n    private String debugName(PropertyDescriptor descriptor) {\n        return String.format(\"%s.%s\", type.getSimpleName(), descriptor.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \"\n                + \"which was not instantiable\", type.getName()), e);\n        }\n    }\n\n    private static void writeProperty(Object bean, PropertyDescriptor property, Object value) {\n        try {\n            Method writeMethod = property.getWriteMethod();\n            if (writeMethod == null) {\n                throw new IllegalArgumentException(String.format(\"No appropriate method to write property %s\", property.getName()));\n            }\n            writeMethod.invoke(bean, value);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access setter for \"\n                + \"property, %s\", property.getName()), e);\n        } catch (InvocationTargetException e) {\n            throw new IllegalArgumentException(String.format(\"Invocation target exception trying to \"\n                + \"invoker setter for the %s property\", property.getName()), e);\n        }\n    }\n}\n","lineNo":226}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.transaction;\n\nimport java.sql.SQLException;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.config.JdbiConfig;\n\n/**\n * A TransactionHandler that automatically retries transactions that fail due to\n * serialization failures, which can generally be resolved by automatically\n * retrying the transaction.  Any HandleCallback used under this runner\n * should be aware that it may be invoked multiple times and should be idempotent.\n */\npublic class SerializableTransactionRunner extends DelegatingTransactionHandler implements TransactionHandler {\n    /* http://www.postgresql.org/docs/9.1/static/errcodes-appendix.html */\n    private static final String SQLSTATE_TXN_SERIALIZATION_FAILED = \"40001\";\n\n    public SerializableTransactionRunner() {\n        this(new LocalTransactionHandler());\n    }\n\n    public SerializableTransactionRunner(TransactionHandler delegate) {\n        super(delegate);\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle,\n                                                    HandleCallback<R, X> callback) throws X {\n        final Configuration config = handle.getConfig(Configuration.class);\n        int attempts = 1 + config.maxRetries;\n\n        Deque<X> stack = new ArrayDeque<>();\n        while (true) {\n            try {\n                return getDelegate().inTransaction(handle, callback);\n            } catch (Exception last) {\n                X x = (X) last;\n\n                // throw immediately if the exception is unexpected\n                if (!isSqlState(config.serializationFailureSqlState, x)) {\n                    throw last;\n                }\n\n                stack.push(x);\n                config.onFailure.accept(new ArrayList<>(stack));\n\n                // no more attempts left? Throw ALL the exceptions! \\o/\n                if (--attempts <= 0) {\n                    X toThrow = stack.removeFirst();\n                    while (!stack.isEmpty()) {\n                        toThrow.addSuppressed(stack.removeFirst());\n                    }\n                    throw toThrow;\n                }\n            }\n        }\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle,\n                                                    TransactionIsolationLevel level,\n                                                    HandleCallback<R, X> callback) throws X {\n        final TransactionIsolationLevel initial = handle.getTransactionIsolationLevel();\n        try {\n            handle.setTransactionIsolation(level);\n            return inTransaction(handle, callback);\n        } finally {\n            handle.setTransactionIsolation(initial);\n        }\n    }\n\n    /**\n     * @param expectedSqlState the expected SQL state\n     * @param throwable the Throwable to test\n     * @return whether the Throwable or one of its causes is an SQLException whose SQLState begins with the given state.\n     */\n    protected boolean isSqlState(String expectedSqlState, Throwable throwable) {\n        Throwable t = throwable;\n\n        do {\n            if (t instanceof SQLException) {\n                String sqlState = ((SQLException) t).getSQLState();\n\n                if (sqlState != null && sqlState.startsWith(expectedSqlState)) {\n                    return true;\n                }\n            }\n        } while ((t = t.getCause()) != null);\n\n        return false;\n    }\n\n    /**\n     * Configuration for serializable transaction runner\n     */\n    public static class Configuration implements JdbiConfig<Configuration> {\n        private static final int DEFAULT_MAX_RETRIES = 5;\n        private static final Consumer<List<Exception>> NOP = list -> {};\n\n        private int maxRetries = DEFAULT_MAX_RETRIES;\n        private String serializationFailureSqlState = SQLSTATE_TXN_SERIALIZATION_FAILED;\n        private Consumer<List<Exception>> onFailure = NOP;\n\n        /**\n         * @param maxRetries number of retry attempts before aborting\n         * @return this\n         */\n        public Configuration setMaxRetries(int maxRetries) {\n            if (maxRetries < 0) {\n                throw new IllegalArgumentException(\"\\\"\" + maxRetries + \" retries\\\" makes no sense. Set a number >= 0 (default \" + DEFAULT_MAX_RETRIES + \").\");\n            }\n\n            this.maxRetries = maxRetries;\n            return this;\n        }\n\n        /**\n         * @param serializationFailureSqlState the SQL state to consider as a serialization failure\n         * @return this\n         */\n        public Configuration setSerializationFailureSqlState(String serializationFailureSqlState) {\n            this.serializationFailureSqlState = serializationFailureSqlState;\n            return this;\n        }\n\n        /**\n         * @param onFailure consumer to handle the list of failures so far (e.g. for logging). Will not be called with an empty list, nor with any exceptions that are not the configured serialization failure \u20ac\u201d the latter will simply be thrown, aborting the operation.\n         * @return this\n         */\n        public Configuration setOnFailure(Consumer<List<Exception>> onFailure) {\n            this.onFailure = onFailure;\n            return this;\n        }\n\n        @Override\n        public Configuration createCopy() {\n            return new Configuration()\n                    .setMaxRetries(maxRetries)\n                    .setSerializationFailureSqlState(serializationFailureSqlState)\n                    .setOnFailure(onFailure);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.transaction;\n\nimport java.sql.SQLException;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.config.JdbiConfig;\n\n/**\n * A TransactionHandler that automatically retries transactions that fail due to\n * serialization failures, which can generally be resolved by automatically\n * retrying the transaction.  Any HandleCallback used under this runner\n * should be aware that it may be invoked multiple times and should be idempotent.\n */\npublic class SerializableTransactionRunner extends DelegatingTransactionHandler implements TransactionHandler {\n    /* http://www.postgresql.org/docs/9.1/static/errcodes-appendix.html */\n    private static final String SQLSTATE_TXN_SERIALIZATION_FAILED = \"40001\";\n\n    public SerializableTransactionRunner() {\n        this(new LocalTransactionHandler());\n    }\n\n    public SerializableTransactionRunner(TransactionHandler delegate) {\n        super(delegate);\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle,\n                                                    HandleCallback<R, X> callback) throws X {\n        final Configuration config = handle.getConfig(Configuration.class);\n        int attempts = 1 + config.maxRetries;\n\n        Deque<X> stack = new ArrayDeque<>();\n        while (true) {\n            try {\n                R result = getDelegate().inTransaction(handle, callback);\n                config.onSuccess.accept(new ArrayList<>(stack));\n                return result;\n            } catch (Exception last) {\n                X x = (X) last;\n\n                // throw immediately if the exception is unexpected\n                if (!isSqlState(config.serializationFailureSqlState, x)) {\n                    throw last;\n                }\n\n                stack.push(x);\n                config.onFailure.accept(new ArrayList<>(stack));\n\n                // no more attempts left? Throw ALL the exceptions! \\o/\n                if (--attempts <= 0) {\n                    X toThrow = stack.removeFirst();\n                    while (!stack.isEmpty()) {\n                        toThrow.addSuppressed(stack.removeFirst());\n                    }\n                    throw toThrow;\n                }\n            }\n        }\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle,\n                                                    TransactionIsolationLevel level,\n                                                    HandleCallback<R, X> callback) throws X {\n        final TransactionIsolationLevel initial = handle.getTransactionIsolationLevel();\n        try {\n            handle.setTransactionIsolation(level);\n            return inTransaction(handle, callback);\n        } finally {\n            handle.setTransactionIsolation(initial);\n        }\n    }\n\n    /**\n     * @param expectedSqlState the expected SQL state\n     * @param throwable the Throwable to test\n     * @return whether the Throwable or one of its causes is an SQLException whose SQLState begins with the given state.\n     */\n    protected boolean isSqlState(String expectedSqlState, Throwable throwable) {\n        Throwable t = throwable;\n\n        do {\n            if (t instanceof SQLException) {\n                String sqlState = ((SQLException) t).getSQLState();\n\n                if (sqlState != null && sqlState.startsWith(expectedSqlState)) {\n                    return true;\n                }\n            }\n        } while ((t = t.getCause()) != null);\n\n        return false;\n    }\n\n    /**\n     * Configuration for serializable transaction runner\n     */\n    public static class Configuration implements JdbiConfig<Configuration> {\n        private static final int DEFAULT_MAX_RETRIES = 5;\n        private static final Consumer<List<Exception>> NOP = list -> {};\n\n        private int maxRetries = DEFAULT_MAX_RETRIES;\n        private String serializationFailureSqlState = SQLSTATE_TXN_SERIALIZATION_FAILED;\n        private Consumer<List<Exception>> onFailure = NOP, onSuccess = NOP;\n\n        /**\n         * @param maxRetries number of retry attempts before aborting\n         * @return this\n         */\n        public Configuration setMaxRetries(int maxRetries) {\n            if (maxRetries < 0) {\n                throw new IllegalArgumentException(\"\\\"\" + maxRetries + \" retries\\\" makes no sense. Set a number >= 0 (default \" + DEFAULT_MAX_RETRIES + \").\");\n            }\n\n            this.maxRetries = maxRetries;\n            return this;\n        }\n\n        /**\n         * @param serializationFailureSqlState the SQL state to consider as a serialization failure\n         * @return this\n         */\n        public Configuration setSerializationFailureSqlState(String serializationFailureSqlState) {\n            this.serializationFailureSqlState = serializationFailureSqlState;\n            return this;\n        }\n\n        /**\n         * @param onFailure consumer to handle the list of failures so far (e.g. for logging). Will not be called with an empty list, nor with any exceptions that are not the configured serialization failure \u20ac\u201d the latter will simply be thrown, aborting the operation.\n         * @return this\n         */\n        public Configuration setOnFailure(Consumer<List<Exception>> onFailure) {\n            this.onFailure = onFailure;\n            return this;\n        }\n\n        /**\n         * @param onSuccess consumer to handle the list of failures that occurred during a transaction run, after the run has completed successfully (e.g. for logging). Will hopefully be called with an empty list, but with the same list of exceptions as the one passed to onFailure otherwise. Will not be called with any exceptions that are not the configured serialization failure \u20ac\u201d the latter will simply be thrown, aborting the operation.\n         * @return this\n         */\n        public Configuration setOnSuccess(Consumer<List<Exception>> onSuccess) {\n            this.onSuccess = onSuccess;\n            return this;\n        }\n\n        @Override\n        public Configuration createCopy() {\n            return new Configuration()\n                    .setMaxRetries(maxRetries)\n                    .setSerializationFailureSqlState(serializationFailureSqlState)\n                    .setOnFailure(onFailure)\n                    .setOnSuccess(onSuccess);\n        }\n    }\n}\n","lineNo":53}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.freemarker;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport freemarker.cache.ClassTemplateLoader;\nimport freemarker.cache.MultiTemplateLoader;\nimport freemarker.cache.TemplateLoader;\nimport freemarker.template.Configuration;\nimport freemarker.template.Template;\nimport net.jodah.expiringmap.ExpirationPolicy;\nimport net.jodah.expiringmap.ExpiringMap;\n\n/**\n * Locates SQL in {@code .sql.ftl} Freemarker files on the classpath.\n */\npublic class FreemarkerSqlLocator {\n    private static final Map<String, Template> CACHE = ExpiringMap.builder()\n            .expiration(10, TimeUnit.MINUTES)\n            .expirationPolicy(ExpirationPolicy.ACCESSED)\n            .build();\n\n    private FreemarkerSqlLocator() {}\n\n    private static File findTemplateDirectory(Class<?> type) {\n        try {\n            String classFolder = getPath(type);\n            URL resource = type.getClassLoader().getResource(classFolder);\n            if (resource != null) {\n                return new File(resource.toURI());\n            }\n        } catch (URISyntaxException ignored) { }\n        return null;\n    }\n\n    public static Template findTemplate(Class<?> type, String templateName) {\n        File templateDirectory = findTemplateDirectory(type);\n        if (templateDirectory == null) {\n            throw new IllegalStateException(\"No template directory found for class \" + type);\n        }\n        File templateFile = new File(templateDirectory, templateName + \".sql.ftl\");\n        return CACHE.computeIfAbsent(templateFile.getPath(), (p) -> {\n            Exception ex;\n            try {\n                if (templateFile.exists()) {\n                    Configuration configuration = new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);\n                    ClassTemplateLoader ctl1 = new ClassTemplateLoader(type, \"/\");\n                    ClassTemplateLoader ctl2 = new ClassTemplateLoader(type, \"/\" + getPath(type));\n                    MultiTemplateLoader mtl = new MultiTemplateLoader(new TemplateLoader[] {ctl1, ctl2});\n                    configuration.setTemplateLoader(mtl);\n                    return new Template(templateName, new FileReader(templateFile), configuration);\n                }\n                ex = new IllegalArgumentException(\"Template file \" + templateFile.getPath() + \" does not exist\");\n            } catch (Exception templateLoadingException) {\n                ex = templateLoadingException;\n            }\n            throw new IllegalStateException(\"Failed to load Freemarker template \" + templateName + \" in \" + templateDirectory.getAbsolutePath(), ex);\n        });\n    }\n\n    private static String getPath(Class<?> type) {\n        return type.getName().replace(\".\", \"/\");\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.freemarker;\n\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport freemarker.cache.ClassTemplateLoader;\nimport freemarker.cache.MultiTemplateLoader;\nimport freemarker.cache.TemplateLoader;\nimport freemarker.template.Configuration;\nimport freemarker.template.Template;\nimport net.jodah.expiringmap.ExpirationPolicy;\nimport net.jodah.expiringmap.ExpiringMap;\n\n/**\n * Locates SQL in {@code .sql.ftl} Freemarker files on the classpath.\n */\npublic class FreemarkerSqlLocator {\n    private static final Map<String, Template> CACHE = ExpiringMap.builder()\n            .expiration(10, TimeUnit.MINUTES)\n            .expirationPolicy(ExpirationPolicy.ACCESSED)\n            .build();\n\n    private FreemarkerSqlLocator() {}\n\n    public static Template findTemplate(Class<?> type, String templateName) {\n        String path = getPath(type);\n\n        return CACHE.computeIfAbsent(path + \"#\" + templateName, k -> {\n            try {\n                Configuration configuration = new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);\n                ClassTemplateLoader ctl1 = new ClassTemplateLoader(type, \"/\");\n                ClassTemplateLoader ctl2 = new ClassTemplateLoader(type, \"/\" + path);\n                MultiTemplateLoader mtl = new MultiTemplateLoader(new TemplateLoader[] {ctl1, ctl2});\n                configuration.setTemplateLoader(mtl);\n                return configuration.getTemplate(templateName + \".sql.ftl\");\n            } catch (Exception e) {\n                throw new IllegalStateException(\"Failed to load Freemarker template \" + templateName + \" in \" + path, e);\n            }\n\n        });\n    }\n\n    private static String getPath(Class<?> type) {\n        return type.getName().replace(\".\", \"/\");\n    }\n}\n","lineNo":39}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jdbi.v3.core.Handle;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Represents a group of non-prepared statements to be sent to the RDMBS in one \"request\".\n */\npublic class Batch extends BaseStatement<Batch>\n{\n    private static final Logger LOG = LoggerFactory.getLogger(Batch.class);\n\n    private final List<String> parts = new ArrayList<>();\n\n    public Batch(Handle handle)\n    {\n        super(handle);\n    }\n\n    /**\n     * Add a statement to the batch\n     *\n     * @param sql SQL to be added to the batch, possibly a named statement\n     * @return the same Batch statement\n     */\n    public Batch add(String sql)\n    {\n        parts.add(sql);\n        return this;\n    }\n\n    /**\n     * Execute all the queued up statements\n     *\n     * @return an array of integers representing the return values from each statement's execution\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) {\n            return new int[] {};\n        }\n\n        Statement stmt;\n        try\n        {\n            try\n            {\n                stmt = getHandle().getStatementBuilder().create(getHandle().getConnection(), getContext());\n                addCleanable(stmt::close);\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n            LOG.trace(\"Execute batch [\");\n\n            try\n            {\n                for (String part : parts)\n                {\n                    final String sql = getConfig(SqlStatements.class).getTemplateEngine().render(part, getContext());\n                    LOG.trace(\"  {}\", sql);\n                    stmt.addBatch(sql);\n                }\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(\"Unable to configure JDBC statement\", e, getContext());\n            }\n\n            Long startNanos = null;\n            try\n            {\n                getConfig(SqlStatements.class).getSqlLogger().logBeforeExecution(getContext());\n\n                startNanos = System.nanoTime();\n                final int[] rs = stmt.executeBatch();\n                final long elapsedNanos = System.nanoTime() - startNanos;\n\n                LOG.trace(\"] executed in {}ms\", elapsedNanos / 1000000L);\n                // Null for statement, because for batches, we don't really have a good way to keep the sql around.\n                getConfig(SqlStatements.class).getTimingCollector().collect(elapsedNanos, getContext());\n                getConfig(SqlStatements.class).getSqlLogger().logAfterExecution(getContext(), elapsedNanos);\n\n                return rs;\n            }\n            catch (SQLException e)\n            {\n                final long elapsedNanos = System.nanoTime() - startNanos;\n                getConfig(SqlStatements.class).getSqlLogger().logException(getContext(), e, elapsedNanos);\n                throw new UnableToExecuteStatementException(mungeBatchException(e), getContext());\n            }\n        }\n        finally {\n            close();\n        }\n    }\n\n    /**\n     * SQLExceptions thrown from batch executions have errors\n     * in a {@link SQLException#getNextException()} chain, which\n     * doesn't print out when you log them.  Convert them to be\n     * {@link Throwable#addSuppressed(Throwable)} exceptions,\n     * which do print out with common logging frameworks.\n     */\n    static SQLException mungeBatchException(SQLException e) {\n        for (SQLException next = e.getNextException(); next != null; next = next.getNextException()) {\n            e.addSuppressed(next);\n        }\n        return e;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jdbi.v3.core.Handle;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Represents a group of non-prepared statements to be sent to the RDMBS in one \"request\".\n */\npublic class Batch extends BaseStatement<Batch>\n{\n    private static final Logger LOG = LoggerFactory.getLogger(Batch.class);\n\n    private final List<String> parts = new ArrayList<>();\n\n    public Batch(Handle handle)\n    {\n        super(handle);\n    }\n\n    /**\n     * Add a statement to the batch\n     *\n     * @param sql SQL to be added to the batch, possibly a named statement\n     * @return the same Batch statement\n     */\n    public Batch add(String sql)\n    {\n        parts.add(sql);\n        return this;\n    }\n\n    /**\n     * Execute all the queued up statements\n     *\n     * @return an array of integers representing the return values from each statement's execution\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) {\n            return new int[] {};\n        }\n\n        Statement stmt;\n        try {\n            try {\n                stmt = getHandle().getStatementBuilder().create(getHandle().getConnection(), getContext());\n                addCleanable(stmt::close);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n            LOG.trace(\"Execute batch [\");\n\n            try {\n                for (String part : parts) {\n                    final String sql = getConfig(SqlStatements.class).getTemplateEngine().render(part, getContext());\n                    LOG.trace(\"  {}\", sql);\n                    stmt.addBatch(sql);\n                }\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Unable to configure JDBC statement\", e, getContext());\n            }\n\n            SqlLogger sqlLogger = getConfig(SqlStatements.class).getSqlLogger();\n            try {\n                getContext().setExecutionMoment(Instant.now());\n                sqlLogger.logBeforeExecution(getContext());\n\n                final int[] rs = stmt.executeBatch();\n\n                getContext().setCompletionMoment(Instant.now());\n                sqlLogger.logAfterExecution(getContext());\n\n                long elapsedNanos = getContext().getElapsedTime(ChronoUnit.NANOS);\n                LOG.trace(\"] executed in {}ms\", elapsedNanos / 1000000L);\n                // Null for statement, because for batches, we don't really have a good way to keep the sql around.\n                getConfig(SqlStatements.class).getTimingCollector().collect(elapsedNanos, getContext());\n\n                return rs;\n            } catch (SQLException e) {\n                getContext().setExceptionMoment(Instant.now());\n                sqlLogger.logException(getContext(), e);\n\n                throw new UnableToExecuteStatementException(mungeBatchException(e), getContext());\n            }\n        } finally {\n            close();\n        }\n    }\n\n    /**\n     * SQLExceptions thrown from batch executions have errors\n     * in a {@link SQLException#getNextException()} chain, which\n     * doesn't print out when you log them.  Convert them to be\n     * {@link Throwable#addSuppressed(Throwable)} exceptions,\n     * which do print out with common logging frameworks.\n     */\n    static SQLException mungeBatchException(SQLException e) {\n        for (SQLException next = e.getNextException(); next != null; next = next.getNextException()) {\n            e.addSuppressed(next);\n        }\n        return e;\n    }\n}\n","lineNo":85}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.result.ResultProducer;\nimport org.jdbi.v3.core.result.ResultProducers;\nimport org.jdbi.v3.core.result.ResultSetScanner;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.jdbi.v3.core.result.ResultProducers.returningGeneratedKeys;\n\n/**\n * Represents a prepared batch statement.  Multiple bindings are added to the\n * compiled statement and then executed in a single operation. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n *\n * The statement starts with an empty binding.  You bind a single batch of parameters\n * with the usual {@link SqlStatement} binding methods, and then call\n * {@link PreparedBatch#add()} to add the current binding as a batch and then clear it.\n *\n * An entire batch can be bound and added in one go with {@link PreparedBatch#add(Map)}\n * or {@link PreparedBatch#add(Object...)}.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch> implements ResultBearing\n{\n    private static final Logger LOG = LoggerFactory.getLogger(PreparedBatch.class);\n\n    private final List<Binding> bindings = new ArrayList<>();\n\n    public PreparedBatch(Handle handle, String sql)\n    {\n        super(handle, sql);\n    }\n\n    @Override\n    public <R> R scanResultSet(ResultSetScanner<R> mapper) {\n        return execute(ResultProducers.returningResults()).scanResultSet(mapper);\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        return internalBatchExecute().updateCounts;\n    }\n\n    public ResultIterator<Integer> executeAndGetModCount() {\n        StatementContext ctx = getContext();\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return ctx;\n            }\n\n            @Override\n            public void close() {\n                ctx.close();\n            }\n        };\n    }\n\n    public ResultBearing executeAndReturnGeneratedKeys(String... columnNames) {\n        return execute(returningGeneratedKeys(columnNames));\n    }\n\n    /**\n     * Executes the batch, returning the result obtained from the given {@link ResultProducer}.\n     *\n     * @param <R> the type of the result\n     * @param producer the result producer.\n     * @return value returned by the result producer.\n     */\n    public <R> R execute(ResultProducer<R> producer) {\n        try {\n            return producer.produce(() -> internalBatchExecute().stmt, getContext());\n        } catch (SQLException e) {\n            try {\n                close();\n            } catch (Exception e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToProduceResultException(\"Exception producing batch result\", e, getContext());\n        }\n    }\n\n    private static class ExecutedBatch {\n        final PreparedStatement stmt;\n        final int[] updateCounts;\n\n        ExecutedBatch(PreparedStatement stmt, int[] updateCounts) {\n            this.stmt = stmt;\n            this.updateCounts = updateCounts;\n        }\n    }\n\n    private ExecutedBatch internalBatchExecute() {\n        if (!getBinding().isEmpty()) {\n            add();\n        }\n        if (bindings.isEmpty()) {\n            throw new IllegalStateException(\"No batch parts to execute\");\n        }\n\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(getSql(), getContext());\n        getContext().setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, getContext());\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            final PreparedStatement stmt;\n            try {\n                StatementBuilder statementBuilder = getHandle().getStatementBuilder();\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, getContext());\n                addCleanable(() -> statementBuilder.close(connection, sql, stmt));\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n            beforeBinding(stmt);\n\n            try {\n                for (Binding binding : bindings) {\n                    getContext().setBinding(binding);\n                    ArgumentBinder.bind(parsedParameters, binding, stmt, getContext());\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, getContext());\n            }\n\n            beforeExecution(stmt);\n\n            Long startNanos = null;\n            try {\n                getConfig(SqlStatements.class).getSqlLogger().logBeforeExecution(getContext());\n\n                startNanos = System.nanoTime();\n                final int[] rs =  stmt.executeBatch();\n                final long elapsedNanos = System.nanoTime() - startNanos;\n\n                LOG.trace(\"Prepared batch of {} parts executed in {}ms\", bindings.size(), elapsedNanos / 1000000L, parsedSql);\n                getConfig(SqlStatements.class).getTimingCollector().collect(elapsedNanos, getContext());\n                getConfig(SqlStatements.class).getSqlLogger().logAfterExecution(getContext(), elapsedNanos);\n\n                afterExecution(stmt);\n\n                getContext().setBinding(new Binding());\n\n                return new ExecutedBatch(stmt, rs);\n            }\n            catch (SQLException e) {\n                final long elapsedNanos = System.nanoTime() - startNanos;\n                getConfig(SqlStatements.class).getSqlLogger().logException(getContext(), e, elapsedNanos);\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), getContext());\n            }\n        }\n        finally {\n            bindings.clear();\n        }\n    }\n\n    /**\n     * Add the current binding as a saved batch and clear the binding.\n     * @return this\n     */\n    public PreparedBatch add()\n    {\n        final Binding currentBinding = getBinding();\n        if (currentBinding.isEmpty()) {\n            throw new IllegalStateException(\"Attempt to add() a empty batch, you probably didn't mean to do this \"\n                    + \"- call add() *after* setting batch parameters\");\n        }\n        bindings.add(currentBinding);\n        getContext().setBinding(new Binding());\n        return this;\n    }\n\n    /**\n     * Bind arguments positionally, add the binding as a saved batch, and\n     * then clear the current binding.\n     * @param args the positional arguments to bind\n     * @return this\n     */\n    public PreparedBatch add(Object... args)\n    {\n        for(int i = 0; i < args.length; i++) {\n            bind(i, args[i]);\n        }\n        add();\n        return this;\n    }\n\n    /**\n     * Bind arguments from a Map, add the binding as a saved batch,\n     * then clear the current binding.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     * @return this\n     */\n    public PreparedBatch add(Map<String, ?> args)\n    {\n        bindMap(args);\n        add();\n        return this;\n    }\n\n    /**\n     * @return the number of bindings which are in this batch\n     */\n    public int size()\n    {\n        return bindings.size();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.result.ResultProducer;\nimport org.jdbi.v3.core.result.ResultProducers;\nimport org.jdbi.v3.core.result.ResultSetScanner;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.jdbi.v3.core.result.ResultProducers.returningGeneratedKeys;\n\n/**\n * Represents a prepared batch statement.  Multiple bindings are added to the\n * compiled statement and then executed in a single operation. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n *\n * The statement starts with an empty binding.  You bind a single batch of parameters\n * with the usual {@link SqlStatement} binding methods, and then call\n * {@link PreparedBatch#add()} to add the current binding as a batch and then clear it.\n *\n * An entire batch can be bound and added in one go with {@link PreparedBatch#add(Map)}\n * or {@link PreparedBatch#add(Object...)}.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch> implements ResultBearing\n{\n    private static final Logger LOG = LoggerFactory.getLogger(PreparedBatch.class);\n\n    private final List<Binding> bindings = new ArrayList<>();\n\n    public PreparedBatch(Handle handle, String sql)\n    {\n        super(handle, sql);\n    }\n\n    @Override\n    public <R> R scanResultSet(ResultSetScanner<R> mapper) {\n        return execute(ResultProducers.returningResults()).scanResultSet(mapper);\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        return internalBatchExecute().updateCounts;\n    }\n\n    public ResultIterator<Integer> executeAndGetModCount() {\n        StatementContext ctx = getContext();\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return ctx;\n            }\n\n            @Override\n            public void close() {\n                ctx.close();\n            }\n        };\n    }\n\n    public ResultBearing executeAndReturnGeneratedKeys(String... columnNames) {\n        return execute(returningGeneratedKeys(columnNames));\n    }\n\n    /**\n     * Executes the batch, returning the result obtained from the given {@link ResultProducer}.\n     *\n     * @param <R> the type of the result\n     * @param producer the result producer.\n     * @return value returned by the result producer.\n     */\n    public <R> R execute(ResultProducer<R> producer) {\n        try {\n            return producer.produce(() -> internalBatchExecute().stmt, getContext());\n        } catch (SQLException e) {\n            try {\n                close();\n            } catch (Exception e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToProduceResultException(\"Exception producing batch result\", e, getContext());\n        }\n    }\n\n    private static class ExecutedBatch {\n        final PreparedStatement stmt;\n        final int[] updateCounts;\n\n        ExecutedBatch(PreparedStatement stmt, int[] updateCounts) {\n            this.stmt = stmt;\n            this.updateCounts = updateCounts;\n        }\n    }\n\n    private ExecutedBatch internalBatchExecute() {\n        if (!getBinding().isEmpty()) {\n            add();\n        }\n        if (bindings.isEmpty()) {\n            throw new IllegalStateException(\"No batch parts to execute\");\n        }\n\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(getSql(), getContext());\n        getContext().setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, getContext());\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            final PreparedStatement stmt;\n            try {\n                StatementBuilder statementBuilder = getHandle().getStatementBuilder();\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, getContext());\n                addCleanable(() -> statementBuilder.close(connection, sql, stmt));\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n            beforeBinding(stmt);\n\n            try {\n                for (Binding binding : bindings) {\n                    getContext().setBinding(binding);\n                    ArgumentBinder.bind(parsedParameters, binding, stmt, getContext());\n                    stmt.addBatch();\n                }\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, getContext());\n            }\n\n            beforeExecution(stmt);\n\n            SqlLogger sqlLogger = getConfig(SqlStatements.class).getSqlLogger();\n            try {\n                getContext().setExecutionMoment(Instant.now());\n                sqlLogger.logBeforeExecution(getContext());\n\n                final int[] rs =  stmt.executeBatch();\n\n                getContext().setCompletionMoment(Instant.now());\n                sqlLogger.logAfterExecution(getContext());\n\n                long elapsedNanos = getContext().getElapsedTime(ChronoUnit.NANOS);\n                LOG.trace(\"Prepared batch of {} parts executed in {}ms\", bindings.size(), elapsedNanos / 1000000L, parsedSql);\n                getConfig(SqlStatements.class).getTimingCollector().collect(elapsedNanos, getContext());\n\n                afterExecution(stmt);\n\n                getContext().setBinding(new Binding());\n\n                return new ExecutedBatch(stmt, rs);\n            } catch (SQLException e) {\n                getContext().setExceptionMoment(Instant.now());\n                sqlLogger.logException(getContext(), e);\n\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), getContext());\n            }\n        } finally {\n            bindings.clear();\n        }\n    }\n\n    /**\n     * Add the current binding as a saved batch and clear the binding.\n     * @return this\n     */\n    public PreparedBatch add()\n    {\n        final Binding currentBinding = getBinding();\n        if (currentBinding.isEmpty()) {\n            throw new IllegalStateException(\"Attempt to add() a empty batch, you probably didn't mean to do this \"\n                    + \"- call add() *after* setting batch parameters\");\n        }\n        bindings.add(currentBinding);\n        getContext().setBinding(new Binding());\n        return this;\n    }\n\n    /**\n     * Bind arguments positionally, add the binding as a saved batch, and\n     * then clear the current binding.\n     * @param args the positional arguments to bind\n     * @return this\n     */\n    public PreparedBatch add(Object... args)\n    {\n        for(int i = 0; i < args.length; i++) {\n            bind(i, args[i]);\n        }\n        add();\n        return this;\n    }\n\n    /**\n     * Bind arguments from a Map, add the binding as a saved batch,\n     * then clear the current binding.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     * @return this\n     */\n    public PreparedBatch add(Map<String, ?> args)\n    {\n        bindMap(args);\n        add();\n        return this;\n    }\n\n    /**\n     * @return the number of bindings which are in this batch\n     */\n    public int size()\n    {\n        return bindings.size();\n    }\n}\n","lineNo":184}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.MapArguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.argument.ObjectFieldArguments;\nimport org.jdbi.v3.core.argument.ObjectMethodArguments;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.Mappers;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.stream.Collectors.joining;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private static final Logger LOG = LoggerFactory.getLogger(SqlStatement.class);\n\n    private final Handle  handle;\n    private final String  sql;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private PreparedStatement stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding()\n    {\n        return getContext().getBinding();\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql()\n    {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds)\n    {\n        return addCustomizer(StatementCustomizers.statementTimeout(seconds));\n    }\n\n    /**\n     * Transfer ownership of the handle to the statement: when the statement is closed,\n     * commit the handle's transaction (if one exists) and close the handle.\n     * @return this\n     */\n    public This cleanupHandleCommit()\n    {\n        return cleanupHandle(Handle::commit);\n    }\n\n    /**\n     * When the statement is closed, roll it back then close the owning Handle.\n     * @return this\n     */\n    public This cleanupHandleRollback()\n    {\n        return cleanupHandle(Handle::rollback);\n    }\n\n    private This cleanupHandle(Consumer<Handle> action) {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    action.accept(handle);\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument)\n    {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument)\n    {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(null, bean));\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(String prefix, Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(Object object)\n    {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(null, object));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param prefix a prefix to apply to all field names.\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(String prefix, Object object)\n    {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(prefix, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument.\n     *\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(Object object)\n    {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(null, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument, with the given prefix.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(String prefix, Object object)\n    {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(prefix, object));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map)\n    {\n        return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map));\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder)\n    {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value)\n    {\n        return bind(position, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value)\n    {\n        return bind(name, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value)\n    {\n        return bind(position, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value)\n    {\n        return bind(name, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value)\n    {\n        return bind(position, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value)\n    {\n        return bind(position, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value)\n    {\n        return bind(name, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value)\n    {\n        return bind(name, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value)\n    {\n        return bind(position, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value)\n    {\n        return bind(name, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value)\n    {\n        return bind(position, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value)\n    {\n        return bind(name, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value)\n    {\n        return bind(position, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value)\n    {\n        return bind(name, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value)\n    {\n        return bind(position, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value)\n    {\n        return bind(position, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value)\n    {\n        return bind(name, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value)\n    {\n        return bind(name, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value)\n    {\n        return bind(position, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value)\n    {\n        return bind(position, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value)\n    {\n        return bind(name, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value)\n    {\n        return bind(name, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value)\n    {\n        return bind(position, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value)\n    {\n        return bind(name, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length)\n    {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length)\n    {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value)\n    {\n        return bind(position, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value)\n    {\n        return bind(name, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value)\n    {\n        return bind(position, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value)\n    {\n        return bind(name, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value)\n    {\n        return bind(position, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value)\n    {\n        return bind(name, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value)\n    {\n        return bind(position, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value)\n    {\n        return bind(position, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value)\n    {\n        return bind(name, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value)\n    {\n        return bind(name, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value)\n    {\n        return bind(position, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value)\n    {\n        return bind(position, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value)\n    {\n        return bind(name, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value)\n    {\n        return bind(name, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value)\n    {\n        return bind(position, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value)\n    {\n        return bind(position, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value)\n    {\n        return bind(name, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value)\n    {\n        return bind(name, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value)\n    {\n        return bind(position, toArgument(Short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value)\n    {\n        return bind(position, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value)\n    {\n        return bind(position, toArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value)\n    {\n        return bind(name, toArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value)\n    {\n        return bind(position, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value)\n    {\n        return bind(name, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value)\n    {\n        return bind(position, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value)\n    {\n        return bind(name, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value)\n    {\n        return bind(position, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value)\n    {\n        return bind(name, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType)\n    {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType)\n    {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    private Argument toArgument(Object value) {\n        return toArgument(value == null ? Object.class : value.getClass(), value);\n    }\n\n    private Argument toArgument(Type type, Object value) {\n        return getConfig(Arguments.class).findFor(type, value)\n                .orElseThrow(() -> factoryNotFound(type, value));\n    }\n\n    private UnsupportedOperationException factoryNotFound(Type type, Object value) {\n        if (type instanceof Class<?>) { // not a ParameterizedType\n            final TypeVariable<?>[] params = ((Class<?>) type).getTypeParameters();\n            if (params.length > 0) {\n                return new UnsupportedOperationException(\"No type parameters found for erased type '\" + type + Arrays.toString(params) +\n                        \"'.  To bind a generic type, prefer using bindByType.\");\n            }\n        }\n        return new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of type \" + type);\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType)\n    {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType)\n    {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType)\n    {\n        return bind(name, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType)\n    {\n        return bind(position, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a parameter for each value in the given vararg array, and defines an attribute as the comma-separated list\n     * of parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", 1, 2, 3)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with no vararg values.\");\n        }\n\n        return bindList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     */\n    public final This bindList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with an empty list.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            String paramName = getConfig().get(SqlStatements.class).getSqlParser().nameParameter(name, getContext());\n            names.append(paramName);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean);\n\n            names.append(\"(\");\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(\",\");\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + \"_\" + valueIndex + \"_\" + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        if (values.contains(null)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    PreparedStatement internalExecute()\n    {\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(sql, getContext());\n        getContext().setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, getContext());\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            if (getClass().isAssignableFrom(Call.class)) {\n                stmt = handle.getStatementBuilder().createCall(handle.getConnection(), sql, getContext());\n            }\n            else {\n                stmt = handle.getStatementBuilder().create(handle.getConnection(), sql, getContext());\n            }\n        }\n        catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, getContext());\n        }\n\n        // The statement builder might (or might not) clean up the statement when called. E.g. the\n        // caching statement builder relies on the statement *not* being closed.\n        addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), this.sql, stmt));\n\n        getContext().setStatement(stmt);\n\n        beforeBinding(stmt);\n\n        ArgumentBinder.bind(parsedParameters, getBinding(), stmt, getContext());\n\n        beforeExecution(stmt);\n\n        Long startNanos = null;\n        try {\n            getConfig(SqlStatements.class).getSqlLogger().logBeforeExecution(getContext());\n\n            startNanos = System.nanoTime();\n            stmt.execute();\n            final long elapsedNanos = System.nanoTime() - startNanos;\n\n            LOG.trace(\"Execute SQL \\\"{}\\\" in {}ms\", sql, elapsedNanos / 1000000L);\n            getConfig(SqlStatements.class)\n                    .getTimingCollector()\n                    .collect(elapsedNanos, getContext());\n            getConfig(SqlStatements.class).getSqlLogger().logAfterExecution(getContext(), elapsedNanos);\n        }\n        catch (SQLException e) {\n            final long elapsedNanos = System.nanoTime() - startNanos;\n\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n\n            getConfig(SqlStatements.class).getSqlLogger().logException(getContext(), e, elapsedNanos);\n            throw new UnableToExecuteStatementException(e, getContext());\n        }\n\n        afterExecution(stmt);\n\n        return stmt;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(Class<T> type)\n    {\n        return (RowMapper<T>) mapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(GenericType<T> type)\n    {\n        return (RowMapper<T>) mapperForType(type.getType());\n    }\n\n    RowMapper<?> mapperForType(Type type)\n    {\n        return getConfig(Mappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.MapArguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.argument.ObjectFieldArguments;\nimport org.jdbi.v3.core.argument.ObjectMethodArguments;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.Mappers;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.stream.Collectors.joining;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private static final Logger LOG = LoggerFactory.getLogger(SqlStatement.class);\n\n    private final Handle  handle;\n    private final String  sql;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private PreparedStatement stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding()\n    {\n        return getContext().getBinding();\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql()\n    {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds)\n    {\n        return addCustomizer(StatementCustomizers.statementTimeout(seconds));\n    }\n\n    /**\n     * Transfer ownership of the handle to the statement: when the statement is closed,\n     * commit the handle's transaction (if one exists) and close the handle.\n     * @return this\n     */\n    public This cleanupHandleCommit()\n    {\n        return cleanupHandle(Handle::commit);\n    }\n\n    /**\n     * When the statement is closed, roll it back then close the owning Handle.\n     * @return this\n     */\n    public This cleanupHandleRollback()\n    {\n        return cleanupHandle(Handle::rollback);\n    }\n\n    private This cleanupHandle(Consumer<Handle> action) {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    action.accept(handle);\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument)\n    {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument)\n    {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(null, bean));\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(String prefix, Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(Object object)\n    {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(null, object));\n    }\n\n    /**\n     * Binds public fields of the specified object as arguments for the query.\n     *\n     * @param prefix a prefix to apply to all field names.\n     * @param object source of the public fields to bind.\n     *\n     * @return modified statement\n     */\n    public This bindFields(String prefix, Object object)\n    {\n        return bindNamedArgumentFinder(new ObjectFieldArguments(prefix, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument.\n     *\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(Object object)\n    {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(null, object));\n    }\n\n    /**\n     * Binds methods with no parameters on the argument, with the given prefix.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param object source of methods to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindMethods(String prefix, Object object)\n    {\n        return bindNamedArgumentFinder(new ObjectMethodArguments(prefix, object));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map)\n    {\n        return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map));\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder)\n    {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value)\n    {\n        return bind(position, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value)\n    {\n        return bind(name, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value)\n    {\n        return bind(position, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value)\n    {\n        return bind(name, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value)\n    {\n        return bind(position, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value)\n    {\n        return bind(position, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value)\n    {\n        return bind(name, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value)\n    {\n        return bind(name, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value)\n    {\n        return bind(position, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value)\n    {\n        return bind(name, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value)\n    {\n        return bind(position, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value)\n    {\n        return bind(name, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value)\n    {\n        return bind(position, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value)\n    {\n        return bind(name, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value)\n    {\n        return bind(position, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value)\n    {\n        return bind(position, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value)\n    {\n        return bind(name, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value)\n    {\n        return bind(name, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value)\n    {\n        return bind(position, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value)\n    {\n        return bind(position, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value)\n    {\n        return bind(name, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value)\n    {\n        return bind(name, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value)\n    {\n        return bind(position, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value)\n    {\n        return bind(name, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length)\n    {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length)\n    {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value)\n    {\n        return bind(position, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value)\n    {\n        return bind(name, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value)\n    {\n        return bind(position, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value)\n    {\n        return bind(name, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value)\n    {\n        return bind(position, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value)\n    {\n        return bind(name, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value)\n    {\n        return bind(position, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value)\n    {\n        return bind(position, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value)\n    {\n        return bind(name, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value)\n    {\n        return bind(name, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value)\n    {\n        return bind(position, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value)\n    {\n        return bind(position, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value)\n    {\n        return bind(name, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value)\n    {\n        return bind(name, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value)\n    {\n        return bind(position, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value)\n    {\n        return bind(position, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value)\n    {\n        return bind(name, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value)\n    {\n        return bind(name, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value)\n    {\n        return bind(position, toArgument(Short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value)\n    {\n        return bind(position, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value)\n    {\n        return bind(position, toArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value)\n    {\n        return bind(name, toArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value)\n    {\n        return bind(position, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value)\n    {\n        return bind(name, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value)\n    {\n        return bind(position, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value)\n    {\n        return bind(name, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value)\n    {\n        return bind(position, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value)\n    {\n        return bind(name, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType)\n    {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType)\n    {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    private Argument toArgument(Object value) {\n        return toArgument(value == null ? Object.class : value.getClass(), value);\n    }\n\n    private Argument toArgument(Type type, Object value) {\n        return getConfig(Arguments.class).findFor(type, value)\n                .orElseThrow(() -> factoryNotFound(type, value));\n    }\n\n    private UnsupportedOperationException factoryNotFound(Type type, Object value) {\n        if (type instanceof Class<?>) { // not a ParameterizedType\n            final TypeVariable<?>[] params = ((Class<?>) type).getTypeParameters();\n            if (params.length > 0) {\n                return new UnsupportedOperationException(\"No type parameters found for erased type '\" + type + Arrays.toString(params) +\n                        \"'.  To bind a generic type, prefer using bindByType.\");\n            }\n        }\n        return new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of type \" + type);\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType)\n    {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType)\n    {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType)\n    {\n        return bind(name, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType)\n    {\n        return bind(position, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a parameter for each value in the given vararg array, and defines an attribute as the comma-separated list\n     * of parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", 1, 2, 3)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with no vararg values.\");\n        }\n\n        return bindList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     */\n    public final This bindList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with an empty list.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            String paramName = getConfig().get(SqlStatements.class).getSqlParser().nameParameter(name, getContext());\n            names.append(paramName);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean);\n\n            names.append(\"(\");\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(\",\");\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + \"_\" + valueIndex + \"_\" + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        if (values.contains(null)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    PreparedStatement internalExecute()\n    {\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(sql, getContext());\n        getContext().setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, getContext());\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            if (getClass().isAssignableFrom(Call.class)) {\n                stmt = handle.getStatementBuilder().createCall(handle.getConnection(), sql, getContext());\n            }\n            else {\n                stmt = handle.getStatementBuilder().create(handle.getConnection(), sql, getContext());\n            }\n        }\n        catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, getContext());\n        }\n\n        // The statement builder might (or might not) clean up the statement when called. E.g. the\n        // caching statement builder relies on the statement *not* being closed.\n        addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), this.sql, stmt));\n\n        getContext().setStatement(stmt);\n\n        beforeBinding(stmt);\n\n        ArgumentBinder.bind(parsedParameters, getBinding(), stmt, getContext());\n\n        beforeExecution(stmt);\n\n        SqlLogger sqlLogger = getConfig(SqlStatements.class).getSqlLogger();\n        try {\n            getContext().setExecutionMoment(Instant.now());\n            sqlLogger.logBeforeExecution(getContext());\n\n            stmt.execute();\n\n            getContext().setCompletionMoment(Instant.now());\n            sqlLogger.logAfterExecution(getContext());\n\n            long elapsedNanos = getContext().getElapsedTime(ChronoUnit.NANOS);\n            LOG.trace(\"Execute SQL \\\"{}\\\" in {}ms\", sql, elapsedNanos / 1000000L);\n            getConfig(SqlStatements.class)\n                    .getTimingCollector()\n                    .collect(elapsedNanos, getContext());\n        } catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n\n            getContext().setExceptionMoment(Instant.now());\n            sqlLogger.logException(getContext(), e);\n\n            throw new UnableToExecuteStatementException(e, getContext());\n        }\n\n        afterExecution(stmt);\n\n        return stmt;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(Class<T> type)\n    {\n        return (RowMapper<T>) mapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> mapperForType(GenericType<T> type)\n    {\n        return (RowMapper<T>) mapperForType(type.getType());\n    }\n\n    RowMapper<?> mapperForType(Type type)\n    {\n        return getConfig(Mappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n}\n","lineNo":1450}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.transaction;\n\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.config.JdbiConfig;\n\n/**\n * A TransactionHandler that automatically retries transactions that fail due to\n * serialization failures, which can generally be resolved by automatically\n * retrying the transaction.  Any HandleCallback used under this runner\n * should be aware that it may be invoked multiple times and should be idempotent.\n */\npublic class SerializableTransactionRunner extends DelegatingTransactionHandler implements TransactionHandler {\n    /* http://www.postgresql.org/docs/9.1/static/errcodes-appendix.html */\n    private static final String SQLSTATE_TXN_SERIALIZATION_FAILED = \"40001\";\n\n    public SerializableTransactionRunner() {\n        this(new LocalTransactionHandler());\n    }\n\n    public SerializableTransactionRunner(TransactionHandler delegate) {\n        super(delegate);\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle,\n                                                    HandleCallback<R, X> callback) throws X {\n        final Configuration config = handle.getConfig(Configuration.class);\n        int attempts = 1 + config.maxRetries;\n\n        X stack = null;\n        while (true) {\n            try {\n                return getDelegate().inTransaction(handle, callback);\n            } catch (Exception last) {\n                X x = (X) last;\n\n                // throw immediately if the exception is unexpected\n                if (!isSqlState(config.serializationFailureSqlState, x)) {\n                    throw last;\n                }\n\n                // keep all exceptions thrown in the loop as a stack\n                if (stack == null) {\n                    stack = x;\n                } else {\n                    stack.addSuppressed(last);\n                }\n\n                // no more attempts left? Throw ALL the exceptions! \\o/\n                if (--attempts <= 0) {\n                    throw stack;\n                }\n            }\n        }\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle,\n                                                    TransactionIsolationLevel level,\n                                                    HandleCallback<R, X> callback) throws X {\n        final TransactionIsolationLevel initial = handle.getTransactionIsolationLevel();\n        try {\n            handle.setTransactionIsolation(level);\n            return inTransaction(handle, callback);\n        } finally {\n            handle.setTransactionIsolation(initial);\n        }\n    }\n\n    /**\n     * @param expectedSqlState the expected SQL state\n     * @param throwable the Throwable to test\n     * @return whether the Throwable or one of its causes is an SQLException whose SQLState begins with the given state.\n     */\n    protected boolean isSqlState(String expectedSqlState, Throwable throwable) {\n        do {\n            if (throwable instanceof SQLException) {\n                String sqlState = ((SQLException) throwable).getSQLState();\n\n                if (sqlState != null && sqlState.startsWith(expectedSqlState)) {\n                    return true;\n                }\n            }\n        } while ((throwable = throwable.getCause()) != null);\n\n        return false;\n    }\n\n    /**\n     * Configuration for serializable transaction runner\n     */\n    public static class Configuration implements JdbiConfig<Configuration> {\n        private static final int DEFAULT_MAX_RETRIES = 5;\n        private int maxRetries = DEFAULT_MAX_RETRIES;\n        private String serializationFailureSqlState = SQLSTATE_TXN_SERIALIZATION_FAILED;\n\n        /**\n         * @param maxRetries number of retry attempts before aborting\n         * @return this\n         */\n        public Configuration setMaxRetries(int maxRetries) {\n            if (maxRetries < 0) {\n                throw new IllegalArgumentException(\"\\\"\" + maxRetries + \" retries\\\" makes no sense. Set a number >= 0 (default \" + DEFAULT_MAX_RETRIES + \").\");\n            }\n\n            this.maxRetries = maxRetries;\n            return this;\n        }\n\n        /**\n         * @param serializationFailureSqlState the SQL state to consider as a serialization failure\n         * @return this\n         */\n        public Configuration setSerializationFailureSqlState(String serializationFailureSqlState) {\n            this.serializationFailureSqlState = serializationFailureSqlState;\n            return this;\n        }\n\n        @Override\n        public Configuration createCopy() {\n            return new Configuration()\n                    .setMaxRetries(maxRetries)\n                    .setSerializationFailureSqlState(serializationFailureSqlState);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.transaction;\n\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.config.JdbiConfig;\n\n/**\n * A TransactionHandler that automatically retries transactions that fail due to\n * serialization failures, which can generally be resolved by automatically\n * retrying the transaction.  Any HandleCallback used under this runner\n * should be aware that it may be invoked multiple times and should be idempotent.\n */\npublic class SerializableTransactionRunner extends DelegatingTransactionHandler implements TransactionHandler {\n    /* http://www.postgresql.org/docs/9.1/static/errcodes-appendix.html */\n    private static final String SQLSTATE_TXN_SERIALIZATION_FAILED = \"40001\";\n\n    public SerializableTransactionRunner() {\n        this(new LocalTransactionHandler());\n    }\n\n    public SerializableTransactionRunner(TransactionHandler delegate) {\n        super(delegate);\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle,\n                                                    HandleCallback<R, X> callback) throws X {\n        final Configuration config = handle.getConfig(Configuration.class);\n        int attempts = 1 + config.maxRetries;\n\n        X stack = null;\n        while (true) {\n            try {\n                return getDelegate().inTransaction(handle, callback);\n            } catch (Exception last) {\n                X x = (X) last;\n\n                // throw immediately if the exception is unexpected\n                if (!isSqlState(config.serializationFailureSqlState, x)) {\n                    throw last;\n                }\n\n                // keep all exceptions thrown in the loop as a stack\n                if (stack == null) {\n                    stack = x;\n                } else {\n                    stack.addSuppressed(last);\n                }\n\n                // no more attempts left? Throw ALL the exceptions! \\o/\n                if (--attempts <= 0) {\n                    throw stack;\n                }\n            }\n        }\n    }\n\n    @Override\n    public <R, X extends Exception> R inTransaction(Handle handle,\n                                                    TransactionIsolationLevel level,\n                                                    HandleCallback<R, X> callback) throws X {\n        final TransactionIsolationLevel initial = handle.getTransactionIsolationLevel();\n        try {\n            handle.setTransactionIsolation(level);\n            return inTransaction(handle, callback);\n        } finally {\n            handle.setTransactionIsolation(initial);\n        }\n    }\n\n    /**\n     * @param expectedSqlState the expected SQL state\n     * @param throwable the Throwable to test\n     * @return whether the Throwable or one of its causes is an SQLException whose SQLState begins with the given state.\n     */\n    protected boolean isSqlState(String expectedSqlState, Throwable throwable) {\n        Throwable t = throwable;\n\n        do {\n            if (t instanceof SQLException) {\n                String sqlState = ((SQLException) t).getSQLState();\n\n                if (sqlState != null && sqlState.startsWith(expectedSqlState)) {\n                    return true;\n                }\n            }\n        } while ((t = t.getCause()) != null);\n\n        return false;\n    }\n\n    /**\n     * Configuration for serializable transaction runner\n     */\n    public static class Configuration implements JdbiConfig<Configuration> {\n        private static final int DEFAULT_MAX_RETRIES = 5;\n        private int maxRetries = DEFAULT_MAX_RETRIES;\n        private String serializationFailureSqlState = SQLSTATE_TXN_SERIALIZATION_FAILED;\n\n        /**\n         * @param maxRetries number of retry attempts before aborting\n         * @return this\n         */\n        public Configuration setMaxRetries(int maxRetries) {\n            if (maxRetries < 0) {\n                throw new IllegalArgumentException(\"\\\"\" + maxRetries + \" retries\\\" makes no sense. Set a number >= 0 (default \" + DEFAULT_MAX_RETRIES + \").\");\n            }\n\n            this.maxRetries = maxRetries;\n            return this;\n        }\n\n        /**\n         * @param serializationFailureSqlState the SQL state to consider as a serialization failure\n         * @return this\n         */\n        public Configuration setSerializationFailureSqlState(String serializationFailureSqlState) {\n            this.serializationFailureSqlState = serializationFailureSqlState;\n            return this;\n        }\n\n        @Override\n        public Configuration createCopy() {\n            return new Configuration()\n                    .setMaxRetries(maxRetries)\n                    .setSerializationFailureSqlState(serializationFailureSqlState);\n        }\n    }\n}\n","lineNo":92}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.jpa.internal;\n\nimport java.beans.IndexedPropertyDescriptor;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.WeakHashMap;\nimport java.util.stream.Stream;\nimport javax.persistence.Column;\nimport javax.persistence.MappedSuperclass;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.Collections.synchronizedMap;\nimport static java.util.Collections.unmodifiableList;\n\npublic class JpaClass<C> {\n    private static final Logger LOGGER = LoggerFactory.getLogger(JpaClass.class);\n    private static final Map<Class<?>, JpaClass<?>> CACHE = synchronizedMap(new WeakHashMap<>());\n\n    @SuppressWarnings(\"unchecked\")\n    public static <C> JpaClass<C> get(Class<C> clazz) {\n        return (JpaClass<C>) CACHE.computeIfAbsent(clazz, JpaClass::new);\n    }\n\n    private final List<JpaMember> members;\n\n    private JpaClass(Class<C> clazz) {\n        this.members = unmodifiableList(new ArrayList<>(inspectClass(clazz)));\n\n        LOGGER.debug(\"init {}: {} members.\", clazz, members.size());\n    }\n\n    private static Collection<JpaMember> inspectClass(Class<?> clazz) {\n        Map<String, JpaMember> members = new HashMap<>();\n\n        inspectFields(clazz, members);\n        inspectAnnotatedProperties(clazz, members);\n        inspectSuperclasses(clazz, members);\n        inspectNonAnnotatedProperties(clazz, members);\n\n        return members.values();\n    }\n\n    private static void inspectSuperclasses(Class<?> clazz,\n                                            Map<String, JpaMember> members) {\n        while ((clazz = clazz.getSuperclass()) != null) {\n            if (clazz.isAnnotationPresent(MappedSuperclass.class)) {\n                inspectFields(clazz, members);\n            }\n        }\n    }\n\n    private static void inspectFields(Class<?> clazz,\n                                      Map<String, JpaMember> members) {\n        for (Field member : clazz.getDeclaredFields()) {\n            if (members.containsKey(member.getName())) {\n                continue;\n            }\n\n            Column column = member.getAnnotation(Column.class);\n            if (column != null) {\n                members.put(member.getName(), new JpaMember(clazz, column, member));\n            }\n        }\n    }\n\n    private static void inspectAnnotatedProperties(Class<?> clazz,\n                                                   Map<String, JpaMember> members) {\n        inspectProperties(clazz, members, true);\n    }\n\n    private static void inspectNonAnnotatedProperties(Class<?> clazz,\n                                                   Map<String, JpaMember> members) {\n        inspectProperties(clazz, members, false);\n    }\n\n    private static void inspectProperties(Class<?> clazz,\n                                          Map<String, JpaMember> members,\n                                          boolean hasColumnAnnotation) {\n        try {\n            Stream.of(Introspector.getBeanInfo(clazz).getPropertyDescriptors())\n                    .filter(property -> !members.containsKey(property.getName()))\n                    .filter(property -> !(property instanceof IndexedPropertyDescriptor))\n                    .filter(property -> !\"class\".equals(property.getName()))\n                    .forEach(property -> {\n                        Method getter = property.getReadMethod();\n                        Method setter = property.getWriteMethod();\n\n                        Column column = Stream.of(getter, setter)\n                                .filter(Objects::nonNull)\n                                .map(method -> method.getAnnotation(Column.class))\n                                .filter(Objects::nonNull)\n                                .findFirst()\n                                .orElse(null);\n                        if ((column != null) == hasColumnAnnotation) {\n                            members.put(property.getName(), new JpaMember(clazz, column, property));\n                        }\n                    });\n        } catch (IntrospectionException e) {\n            LOGGER.warn(\"Unable to introspect \" + clazz, e);\n        }\n    }\n\n    public JpaMember lookupMember(String columnLabel) {\n        String column = columnLabel.toLowerCase(Locale.ROOT);\n        return members.stream()\n                .filter(member -> column.equals(member.getColumnName().toLowerCase(Locale.ROOT)))\n                .findFirst()\n                .orElse(null);\n    }\n\n    public List<JpaMember> members() {\n        return members;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.jpa.internal;\n\nimport java.beans.IndexedPropertyDescriptor;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.WeakHashMap;\nimport java.util.stream.Stream;\nimport javax.persistence.Column;\nimport javax.persistence.MappedSuperclass;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.util.Collections.synchronizedMap;\nimport static java.util.Collections.unmodifiableList;\n\npublic class JpaClass<C> {\n    private static final Logger LOGGER = LoggerFactory.getLogger(JpaClass.class);\n    private static final Map<Class<?>, JpaClass<?>> CACHE = synchronizedMap(new WeakHashMap<>());\n\n    @SuppressWarnings(\"unchecked\")\n    public static <C> JpaClass<C> get(Class<C> clazz) {\n        return (JpaClass<C>) CACHE.computeIfAbsent(clazz, JpaClass::new);\n    }\n\n    private final List<JpaMember> members;\n\n    private JpaClass(Class<C> clazz) {\n        this.members = unmodifiableList(new ArrayList<>(inspectClass(clazz)));\n\n        LOGGER.debug(\"init {}: {} members.\", clazz, members.size());\n    }\n\n    private static Collection<JpaMember> inspectClass(Class<?> clazz) {\n        Map<String, JpaMember> members = new HashMap<>();\n\n        inspectFields(clazz, members);\n        inspectAnnotatedProperties(clazz, members);\n        inspectSuperclasses(clazz, members);\n        inspectNonAnnotatedProperties(clazz, members);\n\n        return members.values();\n    }\n\n    private static void inspectSuperclasses(Class<?> clazz,\n                                            Map<String, JpaMember> members) {\n        Class<?> c = clazz;\n        while ((c = c.getSuperclass()) != null) {\n            if (c.isAnnotationPresent(MappedSuperclass.class)) {\n                inspectFields(c, members);\n            }\n        }\n    }\n\n    private static void inspectFields(Class<?> clazz,\n                                      Map<String, JpaMember> members) {\n        for (Field member : clazz.getDeclaredFields()) {\n            if (members.containsKey(member.getName())) {\n                continue;\n            }\n\n            Column column = member.getAnnotation(Column.class);\n            if (column != null) {\n                members.put(member.getName(), new JpaMember(clazz, column, member));\n            }\n        }\n    }\n\n    private static void inspectAnnotatedProperties(Class<?> clazz,\n                                                   Map<String, JpaMember> members) {\n        inspectProperties(clazz, members, true);\n    }\n\n    private static void inspectNonAnnotatedProperties(Class<?> clazz,\n                                                   Map<String, JpaMember> members) {\n        inspectProperties(clazz, members, false);\n    }\n\n    private static void inspectProperties(Class<?> clazz,\n                                          Map<String, JpaMember> members,\n                                          boolean hasColumnAnnotation) {\n        try {\n            Stream.of(Introspector.getBeanInfo(clazz).getPropertyDescriptors())\n                    .filter(property -> !members.containsKey(property.getName()))\n                    .filter(property -> !(property instanceof IndexedPropertyDescriptor))\n                    .filter(property -> !\"class\".equals(property.getName()))\n                    .forEach(property -> {\n                        Method getter = property.getReadMethod();\n                        Method setter = property.getWriteMethod();\n\n                        Column column = Stream.of(getter, setter)\n                                .filter(Objects::nonNull)\n                                .map(method -> method.getAnnotation(Column.class))\n                                .filter(Objects::nonNull)\n                                .findFirst()\n                                .orElse(null);\n                        if ((column != null) == hasColumnAnnotation) {\n                            members.put(property.getName(), new JpaMember(clazz, column, property));\n                        }\n                    });\n        } catch (IntrospectionException e) {\n            LOGGER.warn(\"Unable to introspect \" + clazz, e);\n        }\n    }\n\n    public JpaMember lookupMember(String columnLabel) {\n        String column = columnLabel.toLowerCase(Locale.ROOT);\n        return members.stream()\n                .filter(member -> column.equals(member.getColumnName().toLowerCase(Locale.ROOT)))\n                .findFirst()\n                .orElse(null);\n    }\n\n    public List<JpaMember> members() {\n        return members;\n    }\n}\n","lineNo":68}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.postgres;\n\nimport java.sql.Types;\nimport java.time.Duration;\n\nimport org.jdbi.v3.core.argument.AbstractArgumentFactory;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.postgresql.util.PGInterval;\n\n/**\n * Postgres version of argument factory for {@link Duration}.\n *\n * <p>\n * For simplicity, this implementation makes the duration positive before proceeding. However, this can cause an\n * {@link ArithmeticException} to be thrown. E.g., this can occur if your duration is -2^63 seconds.\n *\n * <p>\n * Not all {@link Duration}s can be represented as intervals in Postgres.\n * One incompatibility results from {@link Duration}s that are too large. This is due to (1) {@link Duration}s using\n * a {@code long} internally, and {@link PGInterval}s using {@code int}s; and (2) the conversion of days to months or\n * years being ambiguous.\n * Another results from {@link Duration}s being too precise; they have nanosecond precision, whereas Postgres has only\n * microsecond.\n * An {@link IllegalArgumentException} will be thrown in these cases.\n * The handling of the second is subject to revision in the future; for example, it would be reasonable to have a\n * configurable truncation option.\n */\npublic class DurationArgumentFactory extends AbstractArgumentFactory<Duration> {\n\n    public DurationArgumentFactory() {\n        super(Types.OTHER);\n    }\n\n    @Override\n    public Argument build(Duration duration, ConfigRegistry config) {\n        final boolean isNegative = duration.isNegative();\n        if (isNegative) {\n            duration = duration.negated();\n        }\n        final long days = duration.toDays();\n        if (days > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    String.format(\"duration %s too large to be represented unambiguously as postgres interval\",\n                            duration));\n        }\n        duration = duration.minusDays(days);\n        final int hours = (int) duration.toHours();\n        duration = duration.minusHours(hours);\n        final int minutes = (int) duration.toMinutes();\n        duration = duration.minusMinutes(minutes);\n        if (duration.getNano() % 1000 != 0) {\n            throw new IllegalArgumentException(\n                    String.format(\"duration %s too precise to represented as postgres interval\", duration));\n        }\n        double seconds = duration.getSeconds() + duration.getNano() / 1e9;\n        final PGInterval interval = new PGInterval(0, 0, (int) days, hours, minutes, seconds);\n        if (isNegative) {\n            interval.scale(-1);\n        }\n        return (i, p, cx) -> p.setObject(i, interval, Types.OTHER);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.postgres;\n\nimport java.sql.Types;\nimport java.time.Duration;\n\nimport org.jdbi.v3.core.argument.AbstractArgumentFactory;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.postgresql.util.PGInterval;\n\n/**\n * Postgres version of argument factory for {@link Duration}.\n *\n * <p>\n * For simplicity, this implementation makes the duration positive before proceeding. However, this can cause an\n * {@link ArithmeticException} to be thrown. E.g., this can occur if your duration is -2^63 seconds.\n *\n * <p>\n * Not all {@link Duration}s can be represented as intervals in Postgres.\n * One incompatibility results from {@link Duration}s that are too large. This is due to (1) {@link Duration}s using\n * a {@code long} internally, and {@link PGInterval}s using {@code int}s; and (2) the conversion of days to months or\n * years being ambiguous.\n * Another results from {@link Duration}s being too precise; they have nanosecond precision, whereas Postgres has only\n * microsecond.\n * An {@link IllegalArgumentException} will be thrown in these cases.\n * The handling of the second is subject to revision in the future; for example, it would be reasonable to have a\n * configurable truncation option.\n */\npublic class DurationArgumentFactory extends AbstractArgumentFactory<Duration> {\n\n    public DurationArgumentFactory() {\n        super(Types.OTHER);\n    }\n\n    @Override\n    public Argument build(Duration duration, ConfigRegistry config) {\n        Duration d = duration;\n        final boolean isNegative = d.isNegative();\n        if (isNegative) {\n            d = d.negated();\n        }\n        final long days = d.toDays();\n        if (days > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    String.format(\"duration %s too large to be represented unambiguously as postgres interval\",\n                            d));\n        }\n        d = d.minusDays(days);\n        final int hours = (int) d.toHours();\n        d = d.minusHours(hours);\n        final int minutes = (int) d.toMinutes();\n        d = d.minusMinutes(minutes);\n        if (d.getNano() % 1000 != 0) {\n            throw new IllegalArgumentException(\n                    String.format(\"duration %s too precise to represented as postgres interval\", d));\n        }\n        double seconds = d.getSeconds() + d.getNano() / 1e9;\n        final PGInterval interval = new PGInterval(0, 0, (int) days, hours, minutes, seconds);\n        if (isNegative) {\n            interval.scale(-1);\n        }\n        return (i, p, cx) -> p.setObject(i, interval, Types.OTHER);\n    }\n}\n","lineNo":50}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.vavr;\n\nimport io.vavr.control.Option;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMapperFactory;\nimport org.jdbi.v3.core.mapper.NoSuchMapperException;\nimport org.jdbi.v3.core.statement.StatementContext;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\npublic class VavrOptionMapper<T> implements ColumnMapper<Option<T>> {\n\n    private final Type type;\n\n    private VavrOptionMapper(Type type) {\n        this.type = type;\n    }\n\n    public static ColumnMapper<?> of(Type type) {\n        return new VavrOptionMapper(type);\n    }\n\n    public static ColumnMapperFactory factory() {\n        return (type, config) -> {\n            Class<?> rawType = getErasedType(type);\n            if (rawType == Option.class) {\n                return Optional.of(VavrOptionMapper.of(type));\n            }\n            return Optional.empty();\n        };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Option<T> map(ResultSet r, int columnNumber, StatementContext ctx) throws SQLException {\n        final ColumnMapper<?> mapper = ctx.findColumnMapperFor(\n                GenericTypes.findGenericParameter(type, Option.class)\n                        .orElseThrow(() -> new NoSuchMapperException(\"No mapper for raw Option type\")))\n                .orElseThrow(() -> new NoSuchMapperException(\"No mapper for type \" + type + \" nested in Option\"));\n\n        return (Option<T>) Option.of(mapper.map(r, columnNumber, ctx));\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.vavr;\n\nimport io.vavr.control.Option;\nimport org.jdbi.v3.core.generic.GenericTypes;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMapperFactory;\nimport org.jdbi.v3.core.mapper.NoSuchMapperException;\nimport org.jdbi.v3.core.statement.StatementContext;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\npublic class VavrOptionMapper<T> implements ColumnMapper<Option<T>> {\n\n    private final Type nestedType;\n\n    private VavrOptionMapper(Type nestedType) {\n        this.nestedType = nestedType;\n    }\n\n    static ColumnMapperFactory factory() {\n        return (type, config) -> {\n            Class<?> rawType = getErasedType(type);\n            if (rawType == Option.class) {\n                final Type nestedType = GenericTypes.findGenericParameter(type, Option.class)\n                        .orElseThrow(() -> new NoSuchMapperException(\"No mapper for raw Option type\"));\n                return Optional.of(new VavrOptionMapper<>(nestedType));\n            }\n            return Optional.empty();\n        };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Option<T> map(ResultSet r, int columnNumber, StatementContext ctx) throws SQLException {\n        final ColumnMapper<?> mapper = ctx.findColumnMapperFor(nestedType)\n                .orElseThrow(() -> new NoSuchMapperException(\"No mapper for type \" + nestedType + \" nested in Option\"));\n        return (Option<T>) Option.of(mapper.map(r, columnNumber, ctx));\n    }\n\n}\n","lineNo":42}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.stringtemplate4;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport net.jodah.expiringmap.ExpirationPolicy;\nimport net.jodah.expiringmap.ExpiringMap;\nimport org.stringtemplate.v4.ST;\nimport org.stringtemplate.v4.STGroup;\nimport org.stringtemplate.v4.STGroupString;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * Locates SQL in <code>.sql.stg<\/code> StringTemplate group files on the classpath.\n */\npublic class StringTemplateSqlLocator {\n    private static final Map<String, STGroup> CACHE = ExpiringMap.builder()\n            .expiration(10, TimeUnit.MINUTES)\n            .expirationPolicy(ExpirationPolicy.ACCESSED)\n            .build();\n\n    private static final String TEMPLATE_GROUP_EXTENSION = \".sql.stg\";\n\n    private StringTemplateSqlLocator() {\n    }\n\n    /**\n     * Locates SQL for the given type and name. Example: Given a type <code>com.foo.Bar<\/code> and a name of\n     * <code>baz<\/code>, loads a StringTemplate group file from the resource named <code>com/foo/Bar.sql.stg<\/code> on\n     * the classpath, and returns the template with the given name from the group.\n     *\n     * @param type the type that \"owns\" the given StringTemplate group file. Dictates the filename of the\n     *             StringTemplate group file on the classpath.\n     * @param name the template name within the StringTemplate group.\n     * @return the located SQL.\n     */\n    public static ST findStringTemplate(Class<?> type, String name) {\n        STGroup group = findStringTemplateGroup(type);\n\n        if (!group.isDefined(name)) {\n            throw new IllegalStateException(\"No StringTemplate group \" + name + \" for class \" + type);\n        }\n\n        return group.getInstanceOf(name);\n    }\n\n    /**\n     * Locates SQL for the given type and name. Loads a StringTemplate group from the resource at the given path,\n     * and returns the template with the given name from the group.\n     *\n     * @param path the resource path for the StringTemplate group.\n     * @param name the template name within the StringTemplate group.\n     * @return the located SQL.\n     */\n    public static ST findStringTemplate(String path, String name) {\n        STGroup group = findStringTemplateGroup(path);\n\n        return findTemplateInGroup(path, name, group);\n    }\n\n    /**\n     * Locates SQL for the given type and name. Loads a StringTemplate group from the resource at the given path,\n     * and returns the template with the given name from the group.\n     *\n     * @param classLoader the classloader from which to load the resource.\n     * @param path the resource path for the StringTemplate group.\n     * @param name the template name within the StringTemplate group.\n     * @return the located SQL.\n     */\n    public static ST findStringTemplate(ClassLoader classLoader, String path, String name) {\n        STGroup group = findStringTemplateGroup(classLoader, path);\n\n        return findTemplateInGroup(path, name, group);\n    }\n\n    private static ST findTemplateInGroup(String path, String name, STGroup group) {\n        if (!group.isDefined(name)) {\n            throw new IllegalStateException(\"No StringTemplate group \" + name + \" for path \" + path);\n        }\n\n        return group.getInstanceOf(name);\n    }\n\n    /**\n     * Loads the StringTemplateGroup for the given type. Example: Given a type <code>com.foo.Bar<\/code>, returns a\n     * StringTemplateGroup loaded from the resource named <code>com/foo/Bar.sql.stg<\/code> on the classpath.\n     *\n     * @param type the type that \"owns\" the given StringTemplate group file. Dictates the filename of the\n     *             StringTemplate group file on the classpath.\n     * @return the loaded StringTemplateGroup.\n     */\n    public static STGroup findStringTemplateGroup(Class<?> type) {\n        return findStringTemplateGroup(type.getClassLoader(), resourcePathFor(type));\n    }\n\n    /**\n     * Loads the StringTemplateGroup from the given path on the classpath.\n     *\n     * @param path the resource path on the classpath.\n     * @return the loaded StringTemplateGroup.\n     */\n    public static STGroup findStringTemplateGroup(String path) {\n        return findStringTemplateGroup(Thread.currentThread().getContextClassLoader(), path);\n    }\n\n    /**\n     * Loads the StringTemplateGroup from the given path on the classpath.\n     *\n     * @param classLoader the classloader from which to load the resource.\n     * @param path the resource path on the classpath.\n     * @return the loaded StringTemplateGroup.\n     */\n    public static STGroup findStringTemplateGroup(ClassLoader classLoader, String path) {\n        return CACHE.computeIfAbsent(path, p -> readStringTemplateGroup(classLoader, path));\n    }\n\n    private static STGroup readStringTemplateGroup(ClassLoader classLoader, String path) {\n        try (InputStream is = openStream(classLoader, path)) {\n            return new STGroupString(toString(is));\n        }\n        catch (IOException e) {\n            throw new RuntimeException(\"Unable to read StringTemplate group file at \" + path + \" on classpath\", e);\n        }\n    }\n\n    private static String toString(InputStream inputStream) throws IOException {\n        char[] buffer = new char[1024];\n        StringBuilder out = new StringBuilder();\n        Reader in = new InputStreamReader(inputStream, UTF_8);\n        for (int rsz; (rsz = in.read(buffer, 0, buffer.length)) >= 0;) {\n            out.append(buffer, 0, rsz);\n        }\n        return out.toString();\n    }\n\n    private static InputStream openStream(ClassLoader classLoader, String path) {\n        InputStream is = classLoader.getResourceAsStream(path);\n\n        if (is == null) {\n            throw new IllegalStateException(\"Unable to find StringTemplate group file at \" + path + \" on classpath\");\n        }\n\n        return is;\n    }\n\n    private static String resourcePathFor(Class<?> clazz) {\n        return clazz.getName().replace('.', '/') + TEMPLATE_GROUP_EXTENSION;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.stringtemplate4;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport net.jodah.expiringmap.ExpirationPolicy;\nimport net.jodah.expiringmap.ExpiringMap;\nimport org.stringtemplate.v4.ST;\nimport org.stringtemplate.v4.STGroup;\nimport org.stringtemplate.v4.STGroupString;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * Locates SQL in <code>.sql.stg<\/code> StringTemplate group files on the classpath.\n */\npublic class StringTemplateSqlLocator {\n    private static final Map<String, STGroup> CACHE = ExpiringMap.builder()\n            .expiration(10, TimeUnit.MINUTES)\n            .expirationPolicy(ExpirationPolicy.ACCESSED)\n            .build();\n\n    private static final String TEMPLATE_GROUP_EXTENSION = \".sql.stg\";\n\n    private StringTemplateSqlLocator() {\n    }\n\n    /**\n     * Locates SQL for the given type and name. Example: Given a type <code>com.foo.Bar<\/code> and a name of\n     * <code>baz<\/code>, loads a StringTemplate group file from the resource named <code>com/foo/Bar.sql.stg<\/code> on\n     * the classpath, and returns the template with the given name from the group.\n     *\n     * @param type the type that \"owns\" the given StringTemplate group file. Dictates the filename of the\n     *             StringTemplate group file on the classpath.\n     * @param name the template name within the StringTemplate group.\n     * @return the located SQL.\n     */\n    public static ST findStringTemplate(Class<?> type, String name) {\n        STGroup group = findStringTemplateGroup(type);\n\n        if (!group.isDefined(name)) {\n            throw new IllegalStateException(\"No StringTemplate group \" + name + \" for class \" + type);\n        }\n\n        return group.getInstanceOf(name);\n    }\n\n    /**\n     * Locates SQL for the given type and name. Loads a StringTemplate group from the resource at the given path,\n     * and returns the template with the given name from the group.\n     *\n     * @param path the resource path for the StringTemplate group.\n     * @param name the template name within the StringTemplate group.\n     * @return the located SQL.\n     */\n    public static ST findStringTemplate(String path, String name) {\n        STGroup group = findStringTemplateGroup(path);\n\n        return findTemplateInGroup(path, name, group);\n    }\n\n    /**\n     * Locates SQL for the given type and name. Loads a StringTemplate group from the resource at the given path,\n     * and returns the template with the given name from the group.\n     *\n     * @param classLoader the classloader from which to load the resource.\n     * @param path the resource path for the StringTemplate group.\n     * @param name the template name within the StringTemplate group.\n     * @return the located SQL.\n     */\n    public static ST findStringTemplate(ClassLoader classLoader, String path, String name) {\n        STGroup group = findStringTemplateGroup(classLoader, path);\n\n        return findTemplateInGroup(path, name, group);\n    }\n\n    private static ST findTemplateInGroup(String path, String name, STGroup group) {\n        if (!group.isDefined(name)) {\n            throw new IllegalStateException(\"No StringTemplate group \" + name + \" for path \" + path);\n        }\n\n        return group.getInstanceOf(name);\n    }\n\n    /**\n     * Loads the StringTemplateGroup for the given type. Example: Given a type <code>com.foo.Bar<\/code>, returns a\n     * StringTemplateGroup loaded from the resource named <code>com/foo/Bar.sql.stg<\/code> on the classpath.\n     *\n     * @param type the type that \"owns\" the given StringTemplate group file. Dictates the filename of the\n     *             StringTemplate group file on the classpath.\n     * @return the loaded StringTemplateGroup.\n     */\n    public static STGroup findStringTemplateGroup(Class<?> type) {\n        return findStringTemplateGroup(type.getClassLoader(), resourcePathFor(type));\n    }\n\n    /**\n     * Loads the StringTemplateGroup from the given path on the classpath.\n     *\n     * @param path the resource path on the classpath.\n     * @return the loaded StringTemplateGroup.\n     */\n    public static STGroup findStringTemplateGroup(String path) {\n        return findStringTemplateGroup(Thread.currentThread().getContextClassLoader(), path);\n    }\n\n    /**\n     * Loads the StringTemplateGroup from the given path on the classpath.\n     *\n     * @param classLoader the classloader from which to load the resource.\n     * @param path the resource path on the classpath.\n     * @return the loaded StringTemplateGroup.\n     */\n    public static STGroup findStringTemplateGroup(ClassLoader classLoader, String path) {\n        return CACHE.computeIfAbsent(path, p -> readStringTemplateGroup(classLoader, path));\n    }\n\n    private static STGroup readStringTemplateGroup(ClassLoader classLoader, String path) {\n        try (InputStream is = openStream(classLoader, path)) {\n            STGroupString group = new STGroupString(toString(is));\n            group.load();\n            return group;\n        }\n        catch (IOException e) {\n            throw new RuntimeException(\"Unable to read StringTemplate group file at \" + path + \" on classpath\", e);\n        }\n    }\n\n    private static String toString(InputStream inputStream) throws IOException {\n        char[] buffer = new char[1024];\n        StringBuilder out = new StringBuilder();\n        Reader in = new InputStreamReader(inputStream, UTF_8);\n        for (int rsz; (rsz = in.read(buffer, 0, buffer.length)) >= 0;) {\n            out.append(buffer, 0, rsz);\n        }\n        return out.toString();\n    }\n\n    private static InputStream openStream(ClassLoader classLoader, String path) {\n        InputStream is = classLoader.getResourceAsStream(path);\n\n        if (is == null) {\n            throw new IllegalStateException(\"Unable to find StringTemplate group file at \" + path + \" on classpath\");\n        }\n\n        return is;\n    }\n\n    private static String resourcePathFor(Class<?> clazz) {\n        return clazz.getName().replace('.', '/') + TEMPLATE_GROUP_EXTENSION;\n    }\n}\n","lineNo":137}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport org.jdbi.v3.core.rule.H2DatabaseRule;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.TimingCollector;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.sqlobject.config.RegisterRowMapper;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.BindBean;\nimport org.jdbi.v3.sqlobject.customizer.Timestamped;\nimport org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.time.LocalDateTime;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for the {@link Timestamped} annotation\n */\npublic class TestTimestamped {\n    public PersonDAO personDAO;\n\n    @Rule\n    public H2DatabaseRule dbRule = new H2DatabaseRule();\n\n    @Before\n    public void beforeEach() {\n        dbRule.getJdbi().installPlugin(new SqlObjectPlugin());\n        personDAO = dbRule.getJdbi().onDemand(PersonDAO.class);\n        personDAO.createTable();\n    }\n\n    @Test\n    public void shouldInsertCreatedAndModifiedFields() {\n        // This is one way we can get the binding information of the executed query\n        dbRule.getJdbi().setTimingCollector((elapsed, ctx) ->\n                assertThat(ctx.getBinding().findForName(\"now\", ctx)).isPresent());\n\n        Person p = new Person(\"John\", \"Phiri\");\n        p.setId(1);\n        personDAO.insert(p);\n\n        // Clear the timing colletor\n        dbRule.getJdbi().setTimingCollector(TimingCollector.NOP_TIMING_COLLECTOR);\n\n        Person found = personDAO.get(1);\n\n        assertThat(found.getCreated()).isNotNull();\n        assertThat(found.getModified()).isNotNull();\n    }\n\n    @Test\n    public void shouldAllowCustomTimestampParameter() {\n        LocalDateTime timeBefore = LocalDateTime.now().minusMinutes(1);\n\n        Person p = new Person(\"John\", \"Phiri\");\n        p.setId(1);\n        dbRule.getJdbi().setTimingCollector((elapsed, ctx) ->\n                assertThat(ctx.getBinding().findForName(\"createdAt\", ctx)).isPresent());\n\n\n        personDAO.insertWithCustomTimestampFields(p);\n\n        dbRule.getJdbi().setTimingCollector(TimingCollector.NOP_TIMING_COLLECTOR);\n\n        Person fetched = personDAO.get(1);\n\n        assertThat(p.getFirstName()).isEqualTo(fetched.getFirstName());\n        assertThat(p.getLastName()).isEqualTo(fetched.getLastName());\n        assertThat(fetched.getCreated()).isNotNull();\n        assertThat(fetched.getModified()).isNotNull();\n\n        assertThat(fetched.getCreated()).isEqualTo(fetched.getModified());\n\n        assertThat(timeBefore).isBefore(fetched.getCreated().toLocalDateTime());\n    }\n\n    @Test\n    public void shouldUpdateModifiedTimestamp() {\n        Person p = new Person(\"John\", \"Phiri\");\n\n        p.setId(3);\n\n        dbRule.getJdbi().setTimingCollector((elapsed, ctx) ->\n                assertThat(ctx.getBinding().findForName(\"now\", ctx)).isPresent());\n\n        personDAO.insert(p);\n\n        dbRule.getJdbi().setTimingCollector(TimingCollector.NOP_TIMING_COLLECTOR);\n\n        Person personAfterCreate = personDAO.get(3);\n\n        personAfterCreate.setLastName(\"Banda\");\n\n        personDAO.updatePerson(personAfterCreate);\n\n        Person personAfterUpdate = personDAO.get(3);\n\n        assertThat(personAfterUpdate.getLastName()).isEqualToIgnoringCase(\"Banda\");\n\n        assertThat(personAfterUpdate.getCreated()).isEqualTo(personAfterCreate.getCreated());\n\n        assertThat(personAfterUpdate.getModified()).isAfter(personAfterCreate.getModified());\n    }\n\n    @RegisterRowMapper(PersonRowMapper.class)\n    public interface PersonDAO {\n        @SqlUpdate(\"CREATE TABLE people(id identity primary key, firstName varchar(50), lastName varchar(50), created timestamp, modified timestamp);\")\n        void createTable();\n\n        @GetGeneratedKeys\n        @SqlUpdate(\"INSERT INTO people(id, firstName, lastName, created, modified) VALUES (:p.id, :p.firstName, :p.lastName, :now, :now)\")\n        @Timestamped\n        int insert(@BindBean(\"p\") Person person);\n\n        @SqlUpdate(\"INSERT INTO people(id, firstName, lastName, created, modified) VALUES (:p.id, :p.firstName, :p.lastName, :createdAt, :createdAt)\")\n        @Timestamped(\"createdAt\")\n        int insertWithCustomTimestampFields(@BindBean(\"p\") Person person);\n\n        @SqlUpdate(\"UPDATE people SET firstName = :p.firstName, lastName = :p.lastName, modified = :now WHERE id = :p.id\")\n        @Timestamped\n        int updatePerson(@BindBean(\"p\") Person person);\n\n        @SqlQuery(\"SELECT id, firstName, lastName, created, modified from people WHERE id=:id\")\n        Person get(@Bind(\"id\") int id);\n    }\n\n    public final static class PersonRowMapper implements RowMapper<Person> {\n\n        @Override\n        public Person map(ResultSet resultSet, StatementContext statementContext) throws SQLException {\n            Person person = new Person(resultSet.getString(\"firstName\"), resultSet.getString(\"lastName\"));\n            person.setId(resultSet.getInt(\"id\"));\n            person.setCreated(resultSet.getTimestamp(\"created\"));\n            person.setModified(resultSet.getTimestamp(\"modified\"));\n            return person;\n        }\n    }\n\n    /**\n     * Person JavaBean for tests\n     */\n    public final static class Person {\n        private int id;\n\n        private String firstName;\n\n        private String lastName;\n\n        private Timestamp created;\n\n        private Timestamp modified;\n\n        public Person(String firstName, String lastName) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n\n        public int getId() {\n            return id;\n        }\n\n        public void setId(int id) {\n            this.id = id;\n        }\n\n        public String getFirstName() {\n            return firstName;\n        }\n\n        public void setFirstName(String firstName) {\n            this.firstName = firstName;\n        }\n\n        public String getLastName() {\n            return lastName;\n        }\n\n        public void setLastName(String lastName) {\n            this.lastName = lastName;\n        }\n\n        public Timestamp getCreated() {\n            return created;\n        }\n\n        public void setCreated(Timestamp created) {\n            this.created = created;\n        }\n\n        public Timestamp getModified() {\n            return modified;\n        }\n\n        public void setModified(Timestamp modified) {\n            this.modified = modified;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Person person = (Person) o;\n\n            if (id != person.id) return false;\n            if (!firstName.equals(person.firstName)) return false;\n            return lastName != null ? lastName.equals(person.lastName) : person.lastName== null;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = id;\n            result = 31 * result + firstName.hashCode();\n            result = 31 * result + lastName.hashCode();\n            result = 31 * result + (created != null ? created.hashCode() : 0);\n            result = 31 * result + (modified != null ? modified.hashCode() : 0);\n            return result;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.rule.H2DatabaseRule;\nimport org.jdbi.v3.sqlobject.config.RegisterBeanMapper;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.BindBean;\nimport org.jdbi.v3.sqlobject.customizer.Timestamped;\nimport org.jdbi.v3.sqlobject.customizer.internal.TimestampedConfig;\nimport org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;\nimport org.jdbi.v3.sqlobject.statement.SqlQuery;\nimport org.jdbi.v3.sqlobject.statement.SqlUpdate;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for the {@link Timestamped} annotation\n */\npublic class TestTimestamped {\n    public PersonDAO personDAO;\n\n    @Rule\n    public H2DatabaseRule dbRule = new H2DatabaseRule();\n\n    private MockClock mockClock = new MockClock();\n\n    @Before\n    public void beforeEach() {\n        Jdbi jdbi = dbRule.getJdbi();\n        jdbi.installPlugin(new SqlObjectPlugin());\n        jdbi.getConfig(TimestampedConfig.class).setClock(mockClock);\n        personDAO = jdbi.onDemand(PersonDAO.class);\n        personDAO.createTable();\n    }\n\n    @Test\n    public void shouldInsertCreatedAndModifiedFields() {\n        Instant insertTimestamp = mockClock.instant();\n\n        personDAO.insert(new Person(1, \"John\", \"Phiri\"));\n\n        Person found = personDAO.get(1);\n\n        assertThat(found)\n            .extracting(\"id\", \"firstName\", \"lastName\", \"created\", \"modified\")\n            .containsExactly(1, \"John\", \"Phiri\", insertTimestamp, insertTimestamp);\n    }\n\n    @Test\n    public void shouldAllowCustomTimestampParameter() {\n        Instant insertTimestamp = mockClock.instant();\n\n        personDAO.insertWithCustomTimestampFields(new Person(1, \"John\", \"Phiri\"));\n\n        Person fetched = personDAO.get(1);\n\n        assertThat(fetched)\n            .extracting(\"id\", \"firstName\", \"lastName\", \"created\", \"modified\")\n            .containsExactly(1, \"John\", \"Phiri\", insertTimestamp, insertTimestamp);\n    }\n\n    @Test\n    public void shouldUpdateModifiedTimestamp() {\n        Instant insertTimestamp = mockClock.instant();\n\n        personDAO.insert(new Person(3, \"John\", \"Phiri\"));\n\n        Person created = personDAO.get(3);\n        assertThat(created)\n            .extracting(\"id\", \"firstName\", \"lastName\", \"created\", \"modified\")\n            .containsExactly(3, \"John\", \"Phiri\", insertTimestamp, insertTimestamp);\n\n        Instant updateTimestamp = mockClock.advance(10, ChronoUnit.SECONDS);\n\n        created.setLastName(\"Banda\");\n        personDAO.updatePerson(created);\n\n        Person updated = personDAO.get(3);\n        assertThat(updated)\n            .extracting(\"id\", \"firstName\", \"lastName\", \"created\", \"modified\")\n            .containsExactly(3, \"John\", \"Banda\", insertTimestamp, updateTimestamp);\n    }\n\n    @RegisterBeanMapper(Person.class)\n    public interface PersonDAO {\n        @SqlUpdate(\"CREATE TABLE people(id identity primary key, firstName varchar(50), lastName varchar(50), created timestamp, modified timestamp);\")\n        void createTable();\n\n        @GetGeneratedKeys\n        @SqlUpdate(\"INSERT INTO people(id, firstName, lastName, created, modified) VALUES (:p.id, :p.firstName, :p.lastName, :now, :now)\")\n        @Timestamped\n        int insert(@BindBean(\"p\") Person person);\n\n        @SqlUpdate(\"INSERT INTO people(id, firstName, lastName, created, modified) VALUES (:p.id, :p.firstName, :p.lastName, :createdAt, :createdAt)\")\n        @Timestamped(\"createdAt\")\n        int insertWithCustomTimestampFields(@BindBean(\"p\") Person person);\n\n        @SqlUpdate(\"UPDATE people SET firstName = :p.firstName, lastName = :p.lastName, modified = :now WHERE id = :p.id\")\n        @Timestamped\n        int updatePerson(@BindBean(\"p\") Person person);\n\n        @SqlQuery(\"SELECT id, firstName, lastName, created, modified from people WHERE id=:id\")\n        Person get(@Bind(\"id\") int id);\n    }\n\n    /**\n     * Person JavaBean for tests\n     */\n    public final static class Person {\n        private int id;\n\n        private String firstName;\n\n        private String lastName;\n\n        private Instant created;\n\n        private Instant modified;\n\n        public Person() {\n        }\n\n        public Person(int id, String firstName, String lastName) {\n            this.id = id;\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n\n        public int getId() {\n            return id;\n        }\n\n        public void setId(int id) {\n            this.id = id;\n        }\n\n        public String getFirstName() {\n            return firstName;\n        }\n\n        public void setFirstName(String firstName) {\n            this.firstName = firstName;\n        }\n\n        public String getLastName() {\n            return lastName;\n        }\n\n        public void setLastName(String lastName) {\n            this.lastName = lastName;\n        }\n\n        public Instant getCreated() {\n            return created;\n        }\n\n        public void setCreated(Instant created) {\n            this.created = created;\n        }\n\n        public Instant getModified() {\n            return modified;\n        }\n\n        public void setModified(Instant modified) {\n            this.modified = modified;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Person person = (Person) o;\n\n            if (id != person.id) return false;\n            if (!firstName.equals(person.firstName)) return false;\n            return lastName != null ? lastName.equals(person.lastName) : person.lastName== null;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = id;\n            result = 31 * result + firstName.hashCode();\n            result = 31 * result + lastName.hashCode();\n            result = 31 * result + (created != null ? created.hashCode() : 0);\n            result = 31 * result + (modified != null ? modified.hashCode() : 0);\n            return result;\n        }\n    }\n}\n","lineNo":48}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the columns in a statement into a JavaBean. The default\n * implementation will perform a case insensitive mapping between the bean property\n * names and the column labels, also considering camel-case to underscores conversion.\n * This uses the JDK's built in bean mapping facilities, so it does not support nested\n * properties.\n *\n * The mapped class must have a default constructor.\n */\npublic class BeanMapper<T> implements RowMapper<T>\n{\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, BeanMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, BeanMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return BeanMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new BeanMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final BeanInfo info;\n    private final Map<PropertyDescriptor, RowMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private BeanMapper(Class<T> type, String prefix)\n    {\n        this.type = type;\n        this.prefix = prefix;\n        try\n        {\n            info = Introspector.getBeanInfo(type);\n        }\n        catch (IntrospectionException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = ReflectionMapperUtil.getColumnNames(rs);\n\n        final List<RowMapper<?>> mappers = new ArrayList<>();\n        final List<PropertyDescriptor> properties = new ArrayList<>();\n\n        final List<ColumnNameMatcher> columnNameMatchers = ReflectionMapperUtil.getColumnNameMatchers(ctx);\n\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors()) {\n            Nested anno = Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(m -> m.getAnnotation(Nested.class))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElse(null);\n\n            if (anno == null) {\n                String paramName = paramName(descriptor);\n\n                findColumnIndex(paramName, prefix, columnNames, columnNameMatchers, () -> debugName(descriptor))\n                    .ifPresent(index -> {\n                        Type type = descriptor.getReadMethod().getGenericReturnType();\n                        ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                            .orElse((r, n, c) -> r.getObject(n));\n\n                        mappers.add(new SingleColumnMapper<>(mapper, index + 1));\n                        properties.add(descriptor);\n                    });\n            } else {\n                RowMapper<?> nestedMapper = nestedMappers.computeIfAbsent(descriptor, d -> {\n                    String prefix = BeanMapper.this.prefix + anno.value();\n                    return BeanMapper.of(d.getPropertyType(), prefix);\n                }).specialize(rs, ctx);\n\n                mappers.add(nestedMapper);\n                properties.add(descriptor);\n            }\n        }\n\n        if (mappers.isEmpty() && columnNames.size() > 0) {\n            throw new IllegalArgumentException(String.format(\"Mapping bean type %s \" +\n                    \"didn't find any matching columns in result set\", type));\n        }\n\n        // TODO rethink strict matching in terms of nested row mappers\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching()\n            && mappers.size() != columnNames.size()) {\n            throw new IllegalArgumentException(String.format(\"Mapping bean type %s \" +\n                    \"only matched properties for %s of %s columns\", type,\n                mappers.size(), columnNames.size()));\n        }\n\n        return (r, c) -> {\n            T bean = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                PropertyDescriptor property = properties.get(i);\n\n                Object value = mapper.map(r, ctx);\n\n                writeProperty(bean, property, value);\n            }\n\n            return bean;\n        };\n    }\n\n    private static String paramName(PropertyDescriptor descriptor)\n    {\n        return Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(method -> method.getAnnotation(ColumnName.class))\n                .filter(Objects::nonNull)\n                .map(ColumnName::value)\n                .findFirst()\n                .orElseGet(descriptor::getName);\n    }\n\n    private String debugName(PropertyDescriptor descriptor) {\n        return String.format(\"%s.%s\", type.getSimpleName(), descriptor.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \" +\n                \"which was not instantiable\", type.getName()), e);\n        }\n    }\n\n    private static void writeProperty(Object bean, PropertyDescriptor property, Object value) {\n        try {\n            property.getWriteMethod().invoke(bean, value);\n        }\n        catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access setter for \" +\n                \"property, %s\", property.getName()), e);\n        }\n        catch (InvocationTargetException e) {\n            throw new IllegalArgumentException(String.format(\"Invocation target exception trying to \" +\n                \"invoker setter for the %s property\", property.getName()), e);\n        }\n        catch (NullPointerException e) {\n            throw new IllegalArgumentException(String.format(\"No appropriate method to \" +\n                \"write property %s\", property.getName()), e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNameMatchers;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the columns in a statement into a JavaBean. The default\n * implementation will perform a case insensitive mapping between the bean property\n * names and the column labels, also considering camel-case to underscores conversion.\n * This uses the JDK's built in bean mapping facilities, so it does not support nested\n * properties.\n *\n * The mapped class must have a default constructor.\n */\npublic class BeanMapper<T> implements RowMapper<T>\n{\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, BeanMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, BeanMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return BeanMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to find the mapper for\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped bean property\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new BeanMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final BeanInfo info;\n    private final Map<PropertyDescriptor, RowMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private BeanMapper(Class<T> type, String prefix)\n    {\n        this.type = type;\n        this.prefix = prefix.toLowerCase();\n        try\n        {\n            info = Introspector.getBeanInfo(type);\n        }\n        catch (IntrospectionException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n\n        final List<RowMapper<?>> mappers = new ArrayList<>();\n        final List<PropertyDescriptor> properties = new ArrayList<>();\n\n        final List<ColumnNameMatcher> columnNameMatchers = getColumnNameMatchers(ctx);\n\n        final boolean strict = ctx.getConfig(ReflectionMappers.class).isStrictMatching();\n        final List<String> unmatchedColumns = new ArrayList<>(columnNames);\n        if (!prefix.isEmpty()) {\n            unmatchedColumns.removeIf(column -> !column.startsWith(prefix));\n        }\n\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors()) {\n            Nested anno = Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(m -> m.getAnnotation(Nested.class))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElse(null);\n\n            if (anno == null) {\n                String paramName = paramName(descriptor);\n\n                findColumnIndex(paramName, prefix, columnNames, columnNameMatchers, () -> debugName(descriptor))\n                    .ifPresent(index -> {\n                        Type type = descriptor.getReadMethod().getGenericReturnType();\n                        ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                            .orElse((r, n, c) -> r.getObject(n));\n\n                        mappers.add(new SingleColumnMapper<>(mapper, index + 1));\n                        properties.add(descriptor);\n\n                        unmatchedColumns.remove(columnNames.get(index));\n                    });\n            } else {\n                String nestedPrefix = anno.value().toLowerCase();\n                if (strict && nestedPrefix.isEmpty()) {\n                    throw new IllegalArgumentException(String.format(\n                        \"Cannot do strict column matching on nested property %s.%s without a prefix\",\n                        type.getSimpleName(),\n                        descriptor.getName()));\n                }\n\n                String fullPrefix = prefix + nestedPrefix;\n\n                RowMapper<?> nestedMapper = nestedMappers\n                    .computeIfAbsent(descriptor, d -> BeanMapper.of(d.getPropertyType(), fullPrefix))\n                    .specialize(rs, ctx);\n\n                mappers.add(nestedMapper);\n                properties.add(descriptor);\n\n                unmatchedColumns.removeIf(column -> column.startsWith(fullPrefix));\n            }\n        }\n\n        if (mappers.isEmpty() && columnNames.size() > 0) {\n            throw new IllegalArgumentException(String.format(\"Mapping bean type %s \" +\n                    \"didn't find any matching columns in result set\", type));\n        }\n\n        if (strict && !unmatchedColumns.isEmpty()) {\n            throw new IllegalArgumentException(String.format(\n                \"Mapping bean type %s could not match properties for columns: %s\",\n                type.getSimpleName(),\n                unmatchedColumns));\n        }\n\n        return (r, c) -> {\n            T bean = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                PropertyDescriptor property = properties.get(i);\n\n                Object value = mapper.map(r, ctx);\n\n                writeProperty(bean, property, value);\n            }\n\n            return bean;\n        };\n    }\n\n    private static String paramName(PropertyDescriptor descriptor)\n    {\n        return Stream.of(descriptor.getReadMethod(), descriptor.getWriteMethod())\n                .filter(Objects::nonNull)\n                .map(method -> method.getAnnotation(ColumnName.class))\n                .filter(Objects::nonNull)\n                .map(ColumnName::value)\n                .findFirst()\n                .orElseGet(descriptor::getName);\n    }\n\n    private String debugName(PropertyDescriptor descriptor) {\n        return String.format(\"%s.%s\", type.getSimpleName(), descriptor.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \" +\n                \"which was not instantiable\", type.getName()), e);\n        }\n    }\n\n    private static void writeProperty(Object bean, PropertyDescriptor property, Object value) {\n        try {\n            property.getWriteMethod().invoke(bean, value);\n        }\n        catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access setter for \" +\n                \"property, %s\", property.getName()), e);\n        }\n        catch (InvocationTargetException e) {\n            throw new IllegalArgumentException(String.format(\"Invocation target exception trying to \" +\n                \"invoker setter for the %s property\", property.getName()), e);\n        }\n        catch (NullPointerException e) {\n            throw new IllegalArgumentException(String.format(\"No appropriate method to \" +\n                \"write property %s\", property.getName()), e);\n        }\n    }\n}\n","lineNo":131}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNameMatchers;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the columns in a statement into an object, using reflection\n * to set fields on the object. All declared fields of the class and its superclasses\n * may be set. Nested properties are not supported.\n *\n * The mapped class must have a default constructor.\n */\npublic class FieldMapper<T> implements RowMapper<T>\n{\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, FieldMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped field\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, FieldMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to map\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return FieldMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to map\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped field\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new FieldMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final Map<Field, RowMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private FieldMapper(Class<T> type, String prefix)\n    {\n        this.type = type;\n        this.prefix = prefix;\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n\n        List<RowMapper<?>> mappers = new ArrayList<>();\n        List<Field> fields = new ArrayList<>();\n\n        List<ColumnNameMatcher> columnNameMatchers = getColumnNameMatchers(ctx);\n\n        for (Class<?> aType = type; aType != null; aType = aType.getSuperclass()) {\n            for (Field field : aType.getDeclaredFields()) {\n                Nested anno = field.getAnnotation(Nested.class);\n                if (anno == null) {\n                    findColumnIndex(paramName(field), prefix, columnNames, columnNameMatchers, () -> debugName(field))\n                        .ifPresent(index -> {\n                            Type type = field.getGenericType();\n                            ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                                .orElse((r, n, c) -> rs.getObject(n));\n                            mappers.add(new SingleColumnMapper(mapper, index + 1));\n                            fields.add(field);\n                        });\n                } else {\n                    RowMapper<?> mapper = nestedMappers.computeIfAbsent(field, f -> {\n                        String prefix = FieldMapper.this.prefix + anno.value();\n                        return FieldMapper.of(field.getType(), prefix);\n                    }).specialize(rs, ctx);\n\n                    mappers.add(mapper);\n                    fields.add(field);\n                }\n            }\n        }\n\n        if (mappers.isEmpty() && columnNames.size() > 0) {\n            throw new IllegalArgumentException(String.format(\"Mapping fields for type %s \" +\n                \"didn't find any matching columns in result set\", type));\n        }\n\n        // TODO rethink strict mapping in terms of nested row mappers\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching() &&\n            mappers.size() != columnNames.size()) {\n            throw new IllegalArgumentException(String.format(\n                \"Mapping fields for type %s only matched properties for %s of %s columns\",\n                type,\n                mappers.size(),\n                columnNames.size()));\n        }\n\n        return (r, c) -> {\n            T obj = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                Field field = fields.get(i);\n\n                Object value = mapper.map(rs, ctx);\n                writeField(obj, field, value);\n            }\n\n            return obj;\n        };\n    }\n\n    private static String paramName(Field field) {\n        return Optional.ofNullable(field.getAnnotation(ColumnName.class))\n                .map(ColumnName::value)\n                .orElseGet(field::getName);\n    }\n\n    private String debugName(Field field) {\n        return String.format(\"%s.%s\", type.getSimpleName(), field.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        }\n        catch (Exception e) {\n            String message = String.format(\n                \"A type, %s, was mapped which was not instantiable\",\n                type.getName());\n            throw new IllegalArgumentException(message, e);\n        }\n    }\n\n    private void writeField(T obj, Field field, Object value) {\n        try {\n            field.setAccessible(true);\n            field.set(obj, value);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access \" +\n                \"property, %s\", field.getName()), e);\n        }\n    }\n}\n\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNameMatchers;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the columns in a statement into an object, using reflection\n * to set fields on the object. All declared fields of the class and its superclasses\n * may be set. Nested properties are not supported.\n *\n * The mapped class must have a default constructor.\n */\npublic class FieldMapper<T> implements RowMapper<T>\n{\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, FieldMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped field\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, FieldMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to map\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return FieldMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to map\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped field\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new FieldMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final Map<Field, RowMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private FieldMapper(Class<T> type, String prefix)\n    {\n        this.type = type;\n        this.prefix = prefix.toLowerCase();\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n\n        List<RowMapper<?>> mappers = new ArrayList<>();\n        List<Field> fields = new ArrayList<>();\n\n        List<ColumnNameMatcher> columnNameMatchers = getColumnNameMatchers(ctx);\n\n        final boolean strict = ctx.getConfig(ReflectionMappers.class).isStrictMatching();\n        final List<String> unmatchedColumns = new ArrayList<>(columnNames);\n        if (!prefix.isEmpty()) {\n            unmatchedColumns.removeIf(column -> !column.startsWith(prefix));\n        }\n\n        for (Class<?> aType = type; aType != null; aType = aType.getSuperclass()) {\n            for (Field field : aType.getDeclaredFields()) {\n                Nested anno = field.getAnnotation(Nested.class);\n                if (anno == null) {\n                    findColumnIndex(paramName(field), prefix, columnNames, columnNameMatchers, () -> debugName(field))\n                        .ifPresent(index -> {\n                            Type type = field.getGenericType();\n                            ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                                .orElse((r, n, c) -> rs.getObject(n));\n                            mappers.add(new SingleColumnMapper(mapper, index + 1));\n                            fields.add(field);\n\n                            unmatchedColumns.remove(columnNames.get(index));\n                        });\n                } else {\n                    String nestedPrefix = anno.value();\n                    if (strict && nestedPrefix.isEmpty()) {\n                        throw new IllegalArgumentException(String.format(\n                            \"Cannot do strict column matching on nested field %s.%s without a prefix\",\n                            type.getSimpleName(),\n                            field.getName()));\n                    }\n\n                    String fullPrefix = prefix + nestedPrefix;\n\n                    RowMapper<?> mapper = nestedMappers\n                        .computeIfAbsent(field, f -> FieldMapper.of(field.getType(), fullPrefix))\n                        .specialize(rs, ctx);\n\n                    mappers.add(mapper);\n                    fields.add(field);\n\n                    unmatchedColumns.removeIf(column -> column.startsWith(fullPrefix));\n                }\n            }\n        }\n\n        if (mappers.isEmpty() && columnNames.size() > 0) {\n            throw new IllegalArgumentException(String.format(\"Mapping fields for type %s \" +\n                \"didn't find any matching columns in result set\", type));\n        }\n\n        if (strict && !unmatchedColumns.isEmpty()) {\n            throw new IllegalArgumentException(String.format(\n                \"Mapping type %s could not match fields for columns: %s\",\n                type.getSimpleName(),\n                unmatchedColumns));\n        }\n\n        return (r, c) -> {\n            T obj = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                Field field = fields.get(i);\n\n                Object value = mapper.map(rs, ctx);\n                writeField(obj, field, value);\n            }\n\n            return obj;\n        };\n    }\n\n    private static String paramName(Field field) {\n        return Optional.ofNullable(field.getAnnotation(ColumnName.class))\n                .map(ColumnName::value)\n                .orElseGet(field::getName);\n    }\n\n    private String debugName(Field field) {\n        return String.format(\"%s.%s\", type.getSimpleName(), field.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        }\n        catch (Exception e) {\n            String message = String.format(\n                \"A type, %s, was mapped which was not instantiable\",\n                type.getName());\n            throw new IllegalArgumentException(message, e);\n        }\n    }\n\n    private void writeField(T obj, Field field, Object value) {\n        try {\n            field.setAccessible(true);\n            field.set(obj, value);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access \" +\n                \"property, %s\", field.getName()), e);\n        }\n    }\n}\n\n","lineNo":116}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.JdbiConstructors.findConstructorFor;\n\nimport java.beans.ConstructorProperties;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the fields in a result set into a constructor. The default implementation will perform a\n * case insensitive mapping between the constructor parameter names and the column labels,\n * also considering camel-case to underscores conversion.\n * <p>\n * Currently the constructor must have exactly the same number of columns as the result set, and\n * the mapping must be one-to-one.  These restrictions may be reconsidered at a later time.\n */\npublic class ConstructorMapper<T> implements RowMapper<T>\n{\n    /**\n     * Use the only declared constructor to map a class.\n     *\n     * @param clazz the class to find a constructor of\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Class<?> clazz) {\n        return RowMapperFactory.of(clazz, ConstructorMapper.of(clazz));\n    }\n\n    /**\n     * Use the only declared constructor to map a class.\n     *\n     * @param clazz the class to find a constructor of\n     * @param prefix a prefix for the parameter names\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Class<?> clazz, String prefix) {\n        return RowMapperFactory.of(clazz, ConstructorMapper.of(clazz, prefix));\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     *\n     * @param constructor the constructor to invoke\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Constructor<?> constructor) {\n        return RowMapperFactory.of(constructor.getDeclaringClass(), ConstructorMapper.of(constructor));\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     *\n     * @param constructor the constructor to invoke\n     * @param prefix a prefix to the constructor parameter names\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Constructor<?> constructor, String prefix) {\n        return RowMapperFactory.of(constructor.getDeclaringClass(), ConstructorMapper.of(constructor, prefix));\n    }\n\n    /**\n     * Return a ConstructorMapper for the given type.\n     *\n     * @param <T>  the type to map\n     * @param type the mapped type\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return ConstructorMapper.of(findConstructorFor(type));\n    }\n\n    /**\n     * Return a ConstructorMapper for the given type and prefix.\n     *\n     * @param <T>    the type to map\n     * @param type   the mapped type\n     * @param prefix the column name prefix\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return ConstructorMapper.of(findConstructorFor(type), prefix);\n    }\n\n    /**\n     * Return a ConstructorMapper using the given constructor\n     *\n     * @param <T> the type to map\n     * @param constructor the constructor to be used in mapping\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Constructor<T> constructor) {\n        return ConstructorMapper.of(constructor, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Instantiate a ConstructorMapper using the given constructor and prefix\n     *\n     * @param <T> the type to map\n     * @param constructor the constructor to be used in mapping\n     * @param prefix      the column name prefix\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Constructor<T> constructor, String prefix) {\n        return new ConstructorMapper<>(constructor, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Constructor<T> constructor;\n    private final String prefix;\n    private final ConstructorProperties constructorProperties;\n\n    private ConstructorMapper(Constructor<T> constructor, String prefix) {\n        this.constructor = constructor;\n        this.prefix = prefix;\n        this.constructorProperties = constructor.getAnnotation(ConstructorProperties.class);\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final ResultSetMetaData metadata = rs.getMetaData();\n        final List<String> columnNames = new ArrayList<>(metadata.getColumnCount());\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            columnNames.add(metadata.getColumnLabel(i));\n        }\n\n        final int columns = constructor.getParameterCount();\n\n        if (columns > columnNames.size()) {\n            throw new IllegalStateException(columnNames.size() +\n                    \" columns in result set, but constructor takes \" +\n                    constructor.getParameterCount());\n        }\n\n        List<ColumnNameMatcher> columnNameMatchers = ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n\n        final int[] columnMap = new int[columns];\n        final ColumnMapper<?>[] mappers = new ColumnMapper<?>[columns];\n\n        for (int i = 0; i < columns; i++) {\n            final Type type = constructor.getGenericParameterTypes()[i];\n            final String paramName = paramName(constructor.getParameters(), i, constructorProperties);\n            final int columnIndex = columnIndexForParameter(columnNames, paramName, columnNameMatchers);\n\n            mappers[i] = ctx.findColumnMapperFor(type)\n                    .orElseThrow(() -> new IllegalArgumentException(String.format(\n                            \"Could not find column mapper for type '%s' of parameter '%s' for constructor '%s'\",\n                            type, paramName, constructor)));\n            columnMap[i] = columnIndex;\n        }\n\n        return (r, c) -> {\n            final Object[] params = new Object[columns];\n            for (int i = 0; i < columns; i++) {\n                params[i] = mappers[i].map(r, columnMap[i] + 1, c);\n            }\n            try {\n                return constructor.newInstance(params);\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                if (e.getCause() instanceof RuntimeException) {\n                    throw (RuntimeException) e.getCause();\n                }\n                if (e.getCause() instanceof Error) {\n                    throw (Error) e.getCause();\n                }\n                throw new RuntimeException(e);\n            }\n        };\n    }\n\n    private int columnIndexForParameter(List<String> columnNames,\n                                        String parameterName,\n                                        List<ColumnNameMatcher> columnNameMatchers)\n    {\n        int result = -1;\n        for (int i = 0; i < columnNames.size(); i++) {\n            String columnName = columnNames.get(i);\n            if (prefix.length() > 0) {\n                if (columnName.length() > prefix.length() &&\n                        columnName.regionMatches(true, 0, prefix, 0, prefix.length())) {\n                    columnName = columnName.substring(prefix.length());\n                }\n                else {\n                    continue;\n                }\n            }\n\n            for (ColumnNameMatcher strategy : columnNameMatchers) {\n                if (strategy.columnNameMatches(columnName, parameterName)) {\n                    if (result >= 0) {\n                        throw new IllegalArgumentException(String.format(\n                                \"Constructor '%s' parameter '%s' matches multiple \" +\n                                \"columns: '%s' (%d) and '%s' (%d)\", constructor,\n                                parameterName, columnNames.get(result), result,\n                                columnNames.get(i), i));\n                    }\n                    result = i;\n                    break;\n                }\n            }\n        }\n        if (result >= 0) {\n            return result;\n        }\n        throw new IllegalArgumentException(\"Constructor '\" + constructor + \"' parameter '\" +\n                parameterName +\n                \"' has no column in the result set.  Verify that the Java \" +\n                \"compiler is configured to emit parameter names, \" +\n                \"that your result set has the columns expected, \" +\n                \"or annotate the parameter names explicitly with @ColumnName\");\n    }\n\n    private static String paramName(Parameter[] parameters, int position, ConstructorProperties parameterNames) {\n        final Parameter parameter = parameters[position];\n        ColumnName dbName = parameter.getAnnotation(ColumnName.class);\n        if (dbName != null) {\n            return dbName.value();\n        }\n        if (parameterNames != null) {\n            return parameterNames.value()[position];\n        }\n        return parameter.getName();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.JdbiConstructors.findConstructorFor;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNameMatchers;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\nimport java.beans.ConstructorProperties;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the fields in a result set into a constructor. The default implementation will perform a\n * case insensitive mapping between the constructor parameter names and the column labels,\n * also considering camel-case to underscores conversion.\n * <p>\n * Currently the constructor must have exactly the same number of columns as the result set, and\n * the mapping must be one-to-one.  These restrictions may be reconsidered at a later time.\n */\npublic class ConstructorMapper<T> implements RowMapper<T>\n{\n    /**\n     * Use the only declared constructor to map a class.\n     *\n     * @param clazz the class to find a constructor of\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Class<?> clazz) {\n        return RowMapperFactory.of(clazz, ConstructorMapper.of(clazz));\n    }\n\n    /**\n     * Use the only declared constructor to map a class.\n     *\n     * @param clazz the class to find a constructor of\n     * @param prefix a prefix for the parameter names\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Class<?> clazz, String prefix) {\n        return RowMapperFactory.of(clazz, ConstructorMapper.of(clazz, prefix));\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     *\n     * @param constructor the constructor to invoke\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Constructor<?> constructor) {\n        return RowMapperFactory.of(constructor.getDeclaringClass(), ConstructorMapper.of(constructor));\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     *\n     * @param constructor the constructor to invoke\n     * @param prefix a prefix to the constructor parameter names\n     * @return the factory\n     */\n    public static RowMapperFactory factory(Constructor<?> constructor, String prefix) {\n        return RowMapperFactory.of(constructor.getDeclaringClass(), ConstructorMapper.of(constructor, prefix));\n    }\n\n    /**\n     * Return a ConstructorMapper for the given type.\n     *\n     * @param <T>  the type to map\n     * @param type the mapped type\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return ConstructorMapper.of(findConstructorFor(type));\n    }\n\n    /**\n     * Return a ConstructorMapper for the given type and prefix.\n     *\n     * @param <T>    the type to map\n     * @param type   the mapped type\n     * @param prefix the column name prefix\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return ConstructorMapper.of(findConstructorFor(type), prefix);\n    }\n\n    /**\n     * Return a ConstructorMapper using the given constructor\n     *\n     * @param <T> the type to map\n     * @param constructor the constructor to be used in mapping\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Constructor<T> constructor) {\n        return ConstructorMapper.of(constructor, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Instantiate a ConstructorMapper using the given constructor and prefix\n     *\n     * @param <T> the type to map\n     * @param constructor the constructor to be used in mapping\n     * @param prefix      the column name prefix\n     * @return the mapper\n     */\n    public static <T> RowMapper<T> of(Constructor<T> constructor, String prefix) {\n        return new ConstructorMapper<>(constructor, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Constructor<T> constructor;\n    private final String prefix;\n    private final ConstructorProperties constructorProperties;\n    private final Map<Parameter, RowMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private ConstructorMapper(Constructor<T> constructor, String prefix) {\n        this.constructor = constructor;\n        this.prefix = prefix;\n        this.constructorProperties = constructor.getAnnotation(ConstructorProperties.class);\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n\n        final int count = constructor.getParameterCount();\n        if (count > columnNames.size()) {\n            throw new IllegalStateException(String.format(\n                \"%s columns in result set, but constructor takes %s\",\n                columnNames.size(),\n                constructor.getParameterCount()));\n        }\n\n        final Parameter[] parameters = constructor.getParameters();\n        final List<ColumnNameMatcher> columnNameMatchers = getColumnNameMatchers(ctx);\n\n        final RowMapper<?>[] mappers = new RowMapper<?>[count];\n\n        for (int i = 0; i < count; i++) {\n            final Parameter parameter = parameters[i];\n\n            Nested anno = parameter.getAnnotation(Nested.class);\n            if (anno == null) {\n                final Type type = parameter.getParameterizedType();\n                final String paramName = paramName(parameters, i, constructorProperties);\n\n                final int columnIndex = findColumnIndex(paramName, prefix, columnNames, columnNameMatchers,\n                    () -> debugName(parameter))\n                    .orElseThrow(() -> new IllegalArgumentException(String.format(\n                        \"Constructor '%s' parameter '%s' has no column in the result set. \" +\n                            \"Verify that the Java compiler is configured to emit parameter names, \" +\n                            \"that your result set has the columns expected, or annotate the \" +\n                            \"parameter names explicitly with @ColumnName\",\n                        constructor,\n                        paramName\n                    )));\n\n                mappers[i] = ctx.findColumnMapperFor(type)\n                    .map(mapper -> new SingleColumnMapper(mapper, columnIndex + 1))\n                    .orElseThrow(() -> new IllegalArgumentException(String.format(\n                        \"Could not find column mapper for type '%s' of parameter '%s' for constructor '%s'\",\n                        type, paramName, constructor)));\n            } else {\n                mappers[i] = nestedMappers.computeIfAbsent(parameter, p -> {\n                    String prefix = ConstructorMapper.this.prefix + anno.value();\n                    return ConstructorMapper.of(parameter.getType(), prefix);\n                }).specialize(rs, ctx);\n            }\n        }\n\n        return (r, c) -> {\n            final Object[] params = new Object[count];\n\n            for (int i = 0; i < count; i++) {\n                params[i] = mappers[i].map(r, c);\n            }\n\n            return construct(params);\n        };\n    }\n\n    private static String paramName(Parameter[] parameters,\n                                    int position,\n                                    ConstructorProperties parameterNames) {\n        final Parameter parameter = parameters[position];\n        ColumnName dbName = parameter.getAnnotation(ColumnName.class);\n        if (dbName != null) {\n            return dbName.value();\n        }\n        if (parameterNames != null) {\n            return parameterNames.value()[position];\n        }\n        return parameter.getName();\n    }\n\n    private String debugName(Parameter parameter) {\n        return String.format(\"%s constructor parameter %s\",\n            constructor.getDeclaringClass().getSimpleName(),\n            parameter.getName());\n    }\n\n    private T construct(Object[] params) {\n        try {\n            return constructor.newInstance(params);\n        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            if (e.getCause() instanceof RuntimeException) {\n                throw (RuntimeException) e.getCause();\n            }\n            if (e.getCause() instanceof Error) {\n                throw (Error) e.getCause();\n            }\n            throw new RuntimeException(e);\n        }\n    }\n}\n","lineNo":166}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\n\n/**\n * A row mapper which maps the columns in a statement into an object, using reflection\n * to set fields on the object. All declared fields of the class and its superclasses\n * may be set. Nested properties are not supported.\n *\n * The mapped class must have a default constructor.\n */\npublic class FieldMapper<T> implements RowMapper<T>\n{\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, FieldMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped field\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, FieldMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to map\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return FieldMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to map\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped field\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new FieldMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final ConcurrentMap<String, Optional<Field>> fieldByNameCache = new ConcurrentHashMap<>();\n\n    private FieldMapper(Class<T> type, String prefix)\n    {\n        this.type = type;\n        this.prefix = prefix;\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        List<Integer> columnNumbers = new ArrayList<>();\n        List<ColumnMapper<?>> mappers = new ArrayList<>();\n        List<Field> fields = new ArrayList<>();\n\n        ResultSetMetaData metadata = rs.getMetaData();\n        List<ColumnNameMatcher> columnNameMatchers = ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            String name = metadata.getColumnLabel(i).toLowerCase();\n\n            if (prefix.length() > 0) {\n                if (name.length() > prefix.length() &&\n                        name.regionMatches(true, 0, prefix, 0, prefix.length())) {\n                    name = name.substring(prefix.length());\n                }\n                else {\n                    continue;\n                }\n            }\n\n            Optional<Field> maybeField = fieldByNameCache.computeIfAbsent(name, n -> fieldByColumn(n, columnNameMatchers));\n\n            if (!maybeField.isPresent()) {\n                continue;\n            }\n\n            final Field field = maybeField.get();\n            final Type type = field.getGenericType();\n            final ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                    .orElse((r, n, c) -> r.getObject(n));\n\n            columnNumbers.add(i);\n            mappers.add(mapper);\n            fields.add(field);\n        }\n\n        if (columnNumbers.isEmpty() && metadata.getColumnCount() > 0) {\n            throw new IllegalArgumentException(String.format(\"Mapping fields for type %s \" +\n                    \"didn't find any matching columns in result set\", type));\n        }\n\n        if (    ctx.getConfig(ReflectionMappers.class).isStrictMatching() &&\n                columnNumbers.size() != metadata.getColumnCount()) {\n            throw new IllegalArgumentException(String.format(\"Mapping fields for type %s \" +\n                    \"only matched properties for %s of %s columns\", type,\n                    columnNumbers.size(), metadata.getColumnCount()));\n        }\n\n\n        return (r, c) -> {\n            T obj;\n            try {\n                obj = type.newInstance();\n            }\n            catch (Exception e) {\n                throw new IllegalArgumentException(String.format(\"A type, %s, was mapped \" +\n                        \"which was not instantiable\", type.getName()), e);\n            }\n\n            for (int i = 0; i < columnNumbers.size(); i++) {\n                int columnNumber = columnNumbers.get(i);\n                ColumnMapper<?> mapper = mappers.get(i);\n                Field field = fields.get(i);\n\n                Object value = mapper.map(rs, columnNumber, ctx);\n                try {\n                    field.setAccessible(true);\n                    field.set(obj, value);\n                } catch (IllegalAccessException e) {\n                    throw new IllegalArgumentException(String.format(\"Unable to access \" +\n                            \"property, %s\", field.getName()), e);\n                }\n            }\n            return obj;\n        };\n    }\n\n    private Optional<Field> fieldByColumn(String columnName, List<ColumnNameMatcher> columnNameMatchers)\n    {\n        Class<?> aClass = type;\n        while(aClass != null) {\n            for (Field field : aClass.getDeclaredFields()) {\n                String paramName = paramName(field);\n                for (ColumnNameMatcher strategy : columnNameMatchers) {\n                    if (strategy.columnNameMatches(columnName, paramName)) {\n                        return Optional.of(field);\n                    }\n                }\n            }\n            aClass = aClass.getSuperclass();\n        }\n        return Optional.empty();\n    }\n\n    private String paramName(Field field)\n    {\n        return Optional.ofNullable(field.getAnnotation(ColumnName.class))\n                .map(ColumnName::value)\n                .orElseGet(field::getName);\n    }\n}\n\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.findColumnIndex;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNameMatchers;\nimport static org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.getColumnNames;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.Nested;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the columns in a statement into an object, using reflection\n * to set fields on the object. All declared fields of the class and its superclasses\n * may be set. Nested properties are not supported.\n *\n * The mapped class must have a default constructor.\n */\npublic class FieldMapper<T> implements RowMapper<T>\n{\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type) {\n        return RowMapperFactory.of(type, FieldMapper.of(type));\n    }\n\n    /**\n     * Returns a mapper factory that maps to the given bean class\n     *\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped field\n     * @return a mapper factory that maps to the given bean class\n     */\n    public static RowMapperFactory factory(Class<?> type, String prefix) {\n        return RowMapperFactory.of(type, FieldMapper.of(type, prefix));\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to map\n     * @param type the mapped class\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type) {\n        return FieldMapper.of(type, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Returns a mapper for the given bean class\n     *\n     * @param <T> the type to map\n     * @param type the mapped class\n     * @param prefix the column name prefix for each mapped field\n     * @return a mapper for the given bean class\n     */\n    public static <T> RowMapper<T> of(Class<T> type, String prefix) {\n        return new FieldMapper<>(type, prefix);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Class<T> type;\n    private final String prefix;\n    private final Map<Field, RowMapper<?>> nestedMappers = new ConcurrentHashMap<>();\n\n    private FieldMapper(Class<T> type, String prefix)\n    {\n        this.type = type;\n        this.prefix = prefix;\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final List<String> columnNames = getColumnNames(rs);\n\n        List<RowMapper<?>> mappers = new ArrayList<>();\n        List<Field> fields = new ArrayList<>();\n\n        List<ColumnNameMatcher> columnNameMatchers = getColumnNameMatchers(ctx);\n\n        for (Class<?> aType = type; aType != null; aType = aType.getSuperclass()) {\n            for (Field field : aType.getDeclaredFields()) {\n                Nested anno = field.getAnnotation(Nested.class);\n                if (anno == null) {\n                    findColumnIndex(paramName(field), prefix, columnNames, columnNameMatchers, () -> debugName(field))\n                        .ifPresent(index -> {\n                            Type type = field.getGenericType();\n                            ColumnMapper<?> mapper = ctx.findColumnMapperFor(type)\n                                .orElse((r, n, c) -> rs.getObject(n));\n                            mappers.add(new SingleColumnMapper(mapper, index + 1));\n                            fields.add(field);\n                        });\n                } else {\n                    RowMapper<?> mapper = nestedMappers.computeIfAbsent(field, f -> {\n                        String prefix = FieldMapper.this.prefix + anno.value();\n                        return FieldMapper.of(field.getType(), prefix);\n                    }).specialize(rs, ctx);\n\n                    mappers.add(mapper);\n                    fields.add(field);\n                }\n            }\n        }\n\n        if (mappers.isEmpty() && columnNames.size() > 0) {\n            throw new IllegalArgumentException(String.format(\"Mapping fields for type %s \" +\n                \"didn't find any matching columns in result set\", type));\n        }\n\n        // TODO rethink strict mapping in terms of nested row mappers\n        if (ctx.getConfig(ReflectionMappers.class).isStrictMatching() &&\n            mappers.size() != columnNames.size()) {\n            throw new IllegalArgumentException(String.format(\n                \"Mapping fields for type %s only matched properties for %s of %s columns\",\n                type,\n                mappers.size(),\n                columnNames.size()));\n        }\n\n        return (r, c) -> {\n            T obj = construct();\n\n            for (int i = 0; i < mappers.size(); i++) {\n                RowMapper<?> mapper = mappers.get(i);\n                Field field = fields.get(i);\n\n                Object value = mapper.map(rs, ctx);\n                writeField(obj, field, value);\n            }\n\n            return obj;\n        };\n    }\n\n    private static String paramName(Field field) {\n        return Optional.ofNullable(field.getAnnotation(ColumnName.class))\n                .map(ColumnName::value)\n                .orElseGet(field::getName);\n    }\n\n    private String debugName(Field field) {\n        return String.format(\"%s.%s\", type.getSimpleName(), field.getName());\n    }\n\n    private T construct() {\n        try {\n            return type.newInstance();\n        }\n        catch (Exception e) {\n            String message = String.format(\n                \"A type, %s, was mapped which was not instantiable\",\n                type.getName());\n            throw new IllegalArgumentException(message, e);\n        }\n    }\n\n    private void writeField(T obj, Field field, Object value) {\n        try {\n            field.setAccessible(true);\n            field.set(obj, value);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(String.format(\"Unable to access \" +\n                \"property, %s\", field.getName()), e);\n        }\n    }\n}\n\n","lineNo":185}
{"Smelly Sample":"package jdbi.doc;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.rule.H2DatabaseRule;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class StatementsTest\n{\n    @Rule\n    public H2DatabaseRule dbRule = new H2DatabaseRule();\n\n    private Handle handle;\n\n    @Before\n    public void setUp()\n    {\n        handle = dbRule.getSharedHandle();\n        handle.execute(\"CREATE TABLE user (id INTEGER PRIMARY KEY, name VARCHAR)\");\n        handle.execute(\"INSERT INTO user VALUES (1, 'Alice')\");\n        handle.execute(\"INSERT INTO user VALUES (2, 'Bob')\");\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testQuery() throws Exception\n    {\n        // tag::query[]\n        List<Map<String, Object>> users =\n            handle.createQuery(\"SELECT id, name FROM user ORDER BY id ASC\")\n                .mapToMap()\n                .list();\n\n        assertThat(users).containsExactly(\n                map(\"id\", 1, \"name\", \"Alice\"),\n                map(\"id\", 2, \"name\", \"Bob\"));\n        // end::query[]\n    }\n\n    @Test\n    public void testUpdate() throws Exception\n    {\n        // tag::update[]\n        int count = handle.createUpdate(\"INSERT INTO user(id, name) VALUES(:id, :name)\")\n            .bind(\"id\", 3)\n            .bind(\"name\", \"Charlie\")\n            .execute();\n        assertThat(count).isEqualTo(1);\n        // end::update[]\n    }\n\n    @Test\n    public void testScript() throws Exception\n    {\n        // tag::script[]\n        int[] results = handle.createScript(\n                \"INSERT INTO user VALUES(3, 'Charlie');\" +\n                \"UPDATE user SET name='Bobby Tables' WHERE id=2;\")\n            .execute();\n\n        assertThat(results).containsExactly(1, 1);\n        // end::script[]\n    }\n\n    @Test\n    public void testBatch() throws Exception\n    {\n        // tag::batch[]\n        PreparedBatch batch = handle.prepareBatch(\"INSERT INTO user(id, name) VALUES(:id, :name)\");\n        for (int i = 100; i < 5000; i++)\n        {\n            batch.bind(\"id\", i).bind(\"name\", \"User:\" + i).add();\n        }\n\n        int[] expected = new int[4900];\n        Arrays.fill(expected, 1);\n        assertThat(batch.execute()).isEqualTo(expected);\n        // end::batch[]\n    }\n\n    static <K, V> Map<K, V> map(K k1, V v1, K k2, V v2)\n    {\n        HashMap<K, V> h = new HashMap<>();\n        h.put(k1, v1);\n        h.put(k2, v2);\n        return h;\n    }\n}\n","Method after Refactoring":"package jdbi.doc;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.rule.H2DatabaseRule;\nimport org.jdbi.v3.core.statement.PreparedBatch;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class StatementsTest\n{\n    @Rule\n    public H2DatabaseRule dbRule = new H2DatabaseRule();\n\n    private Handle handle;\n\n    @Before\n    public void setUp()\n    {\n        handle = dbRule.getSharedHandle();\n        handle.execute(\"CREATE TABLE user (id INTEGER PRIMARY KEY, name VARCHAR)\");\n        handle.execute(\"INSERT INTO user VALUES (1, 'Alice')\");\n        handle.execute(\"INSERT INTO user VALUES (2, 'Bob')\");\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testQuery() throws Exception\n    {\n        // tag::query[]\n        List<Map<String, Object>> users =\n            handle.createQuery(\"SELECT id, name FROM user ORDER BY id ASC\")\n                .mapToMap()\n                .list();\n\n        assertThat(users).containsExactly(\n                map(\"id\", 1, \"name\", \"Alice\"),\n                map(\"id\", 2, \"name\", \"Bob\"));\n        // end::query[]\n    }\n\n    @Test\n    public void testUpdate() throws Exception\n    {\n        // tag::update[]\n        int count = handle.createUpdate(\"INSERT INTO user(id, name) VALUES(:id, :name)\")\n            .bind(\"id\", 3)\n            .bind(\"name\", \"Charlie\")\n            .execute();\n        assertThat(count).isEqualTo(1);\n        // end::update[]\n\n        // tag::execute[]\n        count = handle.execute(\"INSERT INTO user(id, name) VALUES(?, ?)\", 4, \"Alice\");\n        assertThat(count).isEqualTo(1);\n        // end::execute[]\n    }\n\n    @Test\n    public void testScript() throws Exception\n    {\n        // tag::script[]\n        int[] results = handle.createScript(\n                \"INSERT INTO user VALUES(3, 'Charlie');\" +\n                \"UPDATE user SET name='Bobby Tables' WHERE id=2;\")\n            .execute();\n\n        assertThat(results).containsExactly(1, 1);\n        // end::script[]\n    }\n\n    @Test\n    public void testBatch() throws Exception\n    {\n        // tag::batch[]\n        PreparedBatch batch = handle.prepareBatch(\"INSERT INTO user(id, name) VALUES(:id, :name)\");\n        for (int i = 100; i < 5000; i++)\n        {\n            batch.bind(\"id\", i).bind(\"name\", \"User:\" + i).add();\n        }\n        int[] counts = batch.execute();\n        // end::batch[]\n\n        int[] expected = new int[4900];\n        Arrays.fill(expected, 1);\n        assertThat(counts).isEqualTo(expected);\n    }\n\n    static <K, V> Map<K, V> map(K k1, V v1, K k2, V v2)\n    {\n        HashMap<K, V> h = new HashMap<>();\n        h.put(k1, v1);\n        h.put(k2, v2);\n        return h;\n    }\n}\n","lineNo":88}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.config.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.mapper.MapEntryMappers;\nimport org.jdbi.v3.sqlobject.config.Configurer;\nimport org.jdbi.v3.sqlobject.config.KeyColumn;\n\npublic class KeyColumnImpl implements Configurer {\n    @Override\n    public void configureForMethod(ConfigRegistry registry, Annotation annotation, Class<?> sqlObjectType, Method method) {\n        KeyColumn keyColumn = (KeyColumn) annotation;\n        registry.get(MapEntryMappers.class).setKeyColumn(keyColumn.value());\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.config.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.mapper.MapEntryMappers;\nimport org.jdbi.v3.sqlobject.config.Configurer;\nimport org.jdbi.v3.sqlobject.config.KeyColumn;\n\npublic class KeyColumnImpl implements Configurer {\n    @Override\n    public void configureForMethod(ConfigRegistry registry, Annotation annotation, Class<?> sqlObjectType, Method method) {\n        KeyColumn keyColumn = (KeyColumn) annotation;\n        String name = keyColumn.value();\n        registry.get(MapEntryMappers.class).setKeyColumn(name.isEmpty() ? null : name);\n    }\n}\n","lineNo":28}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.config.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.mapper.MapEntryMappers;\nimport org.jdbi.v3.sqlobject.config.Configurer;\nimport org.jdbi.v3.sqlobject.config.ValueColumn;\n\npublic class ValueColumnImpl implements Configurer {\n    @Override\n    public void configureForMethod(ConfigRegistry registry, Annotation annotation, Class<?> sqlObjectType, Method method) {\n        ValueColumn valueColumn = (ValueColumn) annotation;\n        registry.get(MapEntryMappers.class).setValueColumn(valueColumn.value());\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.config.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.mapper.MapEntryMappers;\nimport org.jdbi.v3.sqlobject.config.Configurer;\nimport org.jdbi.v3.sqlobject.config.ValueColumn;\n\npublic class ValueColumnImpl implements Configurer {\n    @Override\n    public void configureForMethod(ConfigRegistry registry, Annotation annotation, Class<?> sqlObjectType, Method method) {\n        ValueColumn valueColumn = (ValueColumn) annotation;\n        String name = valueColumn.value();\n        registry.get(MapEntryMappers.class).setValueColumn(name.isEmpty() ? null : name);\n    }\n}\n","lineNo":28}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.vavr;\n\nimport io.vavr.Tuple1;\nimport io.vavr.Tuple2;\nimport io.vavr.Tuple3;\nimport io.vavr.Tuple4;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.NoSuchMapperException;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.core.rule.H2DatabaseRule;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport java.sql.SQLException;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestVavrTupleRowMapperFactoryWithDB {\n\n    @Rule\n    public H2DatabaseRule dbRule = new H2DatabaseRule().withPlugins();\n\n    @Before\n    public void addData() {\n        Handle handle = dbRule.openHandle();\n        handle.createUpdate(\"insert into something (id, name, integerValue, intValue) values (1, 'eric', 99, 100)\").execute();\n        handle.createUpdate(\"insert into something (id, name, integerValue, intValue) values (2, 'brian', 101, 102)\").execute();\n    }\n\n    @Test\n    public void testMapTuple1WithNameOnlyUsingColumnMapper_shouldSucceed() throws SQLException {\n        Tuple1<String> result = dbRule.getSharedHandle()\n                .createQuery(\"select name from something where id = 1\")\n                .mapTo(new GenericType<Tuple1<String>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualToIgnoringCase(\"eric\");\n    }\n\n    @Test\n    public void testMapTuple1UsingRegisteredRowMapper_shouldSucceed() throws SQLException {\n        Handle handle = dbRule.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n\n        Tuple1<Something> result = handle\n                .createQuery(\"select id, name from something where id = 1\")\n                .mapTo(new GenericType<Tuple1<Something>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(new Something(1, \"eric\"));\n    }\n\n    @Test\n    public void testMapTuple2UsingRegisteredRowMappers_shouldSucceed() throws SQLException {\n        Handle handle = dbRule.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n        handle.registerRowMapper(SomethingValues.class,\n                (rs, ctx) -> new SomethingValues(rs.getInt(\"integerValue\"),\n                        rs.getInt(\"intValue\")));\n\n        Tuple2<Something, SomethingValues> result = handle\n                .createQuery(\"select * from something where id = 2\")\n                .mapTo(new GenericType<Tuple2<Something, SomethingValues>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(new Something(2, \"brian\"));\n        assertThat(result._2).isEqualTo(new SomethingValues(101, 102));\n    }\n\n    @Test\n    public void testMapTuple1HavingOnlyOneRowMapper_shouldFail() throws SQLException {\n        assertThatThrownBy(() -> dbRule.getSharedHandle()\n                .createQuery(\"select * from something where id = 1\")\n                .mapTo(new GenericType<Tuple2<Something, SomethingValues>>() {})\n                .findOnly()\n        ).isInstanceOf(NoSuchMapperException.class);\n    }\n\n    @Test\n    public void testMapTuple3WithExtraSpecifiedColumn_shouldSucceed() throws SQLException {\n        Handle handle = dbRule.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n        handle.configure(TupleMappers.class, c ->\n                c.setColumn(2, \"integerValue\").setColumn(3, \"intValue\"));\n\n        Tuple3<Something, Integer, Integer> result = handle\n                .createQuery(\"select * from something where id = 1\")\n                .mapTo(new GenericType<Tuple3<Something, Integer, Integer>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(new Something(1, \"eric\"));\n        assertThat(result._2).isEqualTo(99);\n        assertThat(result._3).isEqualTo(100);\n    }\n\n    @Test\n    public void testMapTuple3WithoutSpecifiedColumn_shouldFail() throws SQLException {\n        Handle handle = dbRule.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n\n        Tuple3<Integer, Something, Integer> result = handle\n                .createQuery(\"select * from something where id = 1\")\n                .mapTo(new GenericType<Tuple3<Integer, Something, Integer>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(1);\n        assertThat(result._2).isEqualTo(new Something(1, \"eric\"));\n\n        // TODO should this fail?\n        assertThat(result._3).isNotEqualTo(100);\n    }\n\n    @Test\n    public void testMapTuple2SelectedColumns_shouldSucceed() throws SQLException {\n        Tuple2<Integer, String> result = dbRule.getSharedHandle()\n                .createQuery(\"select intValue, name from something where id = 2\")\n                .mapTo(new GenericType<Tuple2<Integer, String>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(102);\n        assertThat(result._2).isEqualTo(\"brian\");\n    }\n\n    @Test\n    public void testMapTuple4AllColumns_shouldSucceed() throws SQLException {\n        Tuple4<Integer, String, Integer, Integer> result = dbRule.getSharedHandle()\n                .createQuery(\"select * from something where id = 2\")\n                .mapTo(new GenericType<Tuple4<Integer, String, Integer, Integer>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(2);\n        assertThat(result._2).isEqualTo(\"brian\");\n        assertThat(result._3).isEqualTo(101);\n        assertThat(result._4).isEqualTo(102);\n    }\n\n    private static class SomethingValues {\n        private int integerValue;\n        private int intValue;\n\n        SomethingValues(int integerValue, int intValue) {\n            this.integerValue = integerValue;\n            this.intValue = intValue;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            SomethingValues that = (SomethingValues) o;\n\n            if (integerValue != that.integerValue) return false;\n            return intValue == that.intValue;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = integerValue;\n            result = 31 * result + intValue;\n            return result;\n        }\n    }\n\n\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.vavr;\n\nimport io.vavr.Tuple1;\nimport io.vavr.Tuple2;\nimport io.vavr.Tuple3;\nimport io.vavr.Tuple4;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.NoSuchMapperException;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.core.rule.H2DatabaseRule;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport java.sql.SQLException;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\npublic class TestVavrTupleRowMapperFactoryWithDB {\n\n    @Rule\n    public H2DatabaseRule dbRule = new H2DatabaseRule().withPlugins();\n\n    @Before\n    public void addData() {\n        Handle handle = dbRule.openHandle();\n        handle.createUpdate(\"insert into something (id, name, integerValue, intValue) values (1, 'eric', 99, 100)\").execute();\n        handle.createUpdate(\"insert into something (id, name, integerValue, intValue) values (2, 'brian', 101, 102)\").execute();\n    }\n\n    @Test\n    public void testMapTuple1WithNameOnlyUsingColumnMapper_shouldSucceed() throws SQLException {\n        Tuple1<String> result = dbRule.getSharedHandle()\n                .createQuery(\"select name from something where id = 1\")\n                .mapTo(new GenericType<Tuple1<String>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualToIgnoringCase(\"eric\");\n    }\n\n    @Test\n    public void testMapTuple1UsingRegisteredRowMapper_shouldSucceed() throws SQLException {\n        Handle handle = dbRule.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n\n        Tuple1<Something> result = handle\n                .createQuery(\"select id, name from something where id = 1\")\n                .mapTo(new GenericType<Tuple1<Something>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(new Something(1, \"eric\"));\n    }\n\n    @Test\n    public void testMapTuple2UsingRegisteredRowMappers_shouldSucceed() throws SQLException {\n        Handle handle = dbRule.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n        handle.registerRowMapper(SomethingValues.class,\n                (rs, ctx) -> new SomethingValues(rs.getInt(\"integerValue\"),\n                        rs.getInt(\"intValue\")));\n\n        Tuple2<Something, SomethingValues> result = handle\n                .createQuery(\"select * from something where id = 2\")\n                .mapTo(new GenericType<Tuple2<Something, SomethingValues>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(new Something(2, \"brian\"));\n        assertThat(result._2).isEqualTo(new SomethingValues(101, 102));\n    }\n\n    @Test\n    public void testMapTuple2HavingOnlyOneRowMapper_shouldFail() throws SQLException {\n        final Handle handle = dbRule.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n\n        assertThatThrownBy(() -> handle\n                .createQuery(\"select * from something where id = 1\")\n                .mapTo(new GenericType<Tuple2<Something, SomethingValues>>() {})\n                .findOnly()\n        ).isInstanceOf(NoSuchMapperException.class);\n    }\n\n    @Test\n    public void testMapTuple3WithExtraSpecifiedColumn_shouldSucceed() throws SQLException {\n        Handle handle = dbRule.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n        handle.configure(TupleMappers.class, c ->\n                c.setColumn(2, \"integerValue\").setColumn(3, \"intValue\"));\n\n        Tuple3<Something, Integer, Integer> result = handle\n                .createQuery(\"select * from something where id = 1\")\n                .mapTo(new GenericType<Tuple3<Something, Integer, Integer>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(new Something(1, \"eric\"));\n        assertThat(result._2).isEqualTo(99);\n        assertThat(result._3).isEqualTo(100);\n    }\n\n    @Test\n    public void testMapTuple3WithoutSpecifiedColumn_shouldFail() throws SQLException {\n        Handle handle = dbRule.getSharedHandle();\n        handle.registerRowMapper(new SomethingMapper());\n\n        assertThatThrownBy(() -> handle\n                .createQuery(\"select * from something where id = 1\")\n                .mapTo(new GenericType<Tuple3<Integer, Something, Integer>>() {})\n                .findOnly()).isInstanceOf(NoSuchMapperException.class);\n    }\n\n    @Test\n    public void testMapTuple2SelectedColumns_shouldSucceed() throws SQLException {\n        Tuple2<Integer, String> result = dbRule.getSharedHandle()\n                .createQuery(\"select intValue, name from something where id = 2\")\n                .mapTo(new GenericType<Tuple2<Integer, String>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(102);\n        assertThat(result._2).isEqualTo(\"brian\");\n    }\n\n    @Test\n    public void testMapTuple4AllColumns_shouldSucceed() throws SQLException {\n        Tuple4<Integer, String, Integer, Integer> result = dbRule.getSharedHandle()\n                .createQuery(\"select * from something where id = 2\")\n                .mapTo(new GenericType<Tuple4<Integer, String, Integer, Integer>>() {})\n                .findOnly();\n\n        assertThat(result._1).isEqualTo(2);\n        assertThat(result._2).isEqualTo(\"brian\");\n        assertThat(result._3).isEqualTo(101);\n        assertThat(result._4).isEqualTo(102);\n    }\n\n    private static class SomethingValues {\n        private int integerValue;\n        private int intValue;\n\n        SomethingValues(int integerValue, int intValue) {\n            this.integerValue = integerValue;\n            this.intValue = intValue;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            SomethingValues that = (SomethingValues) o;\n\n            if (integerValue != that.integerValue) return false;\n            return intValue == that.intValue;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = integerValue;\n            result = 31 * result + intValue;\n            return result;\n        }\n    }\n\n\n}\n","lineNo":89}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.core.rule.H2DatabaseRule;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.statement.Update;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class TestNamedParams\n{\n    @Rule\n    public H2DatabaseRule dbRule = new H2DatabaseRule();\n\n    @Test\n    public void testInsert() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update insert = h.createUpdate(\"insert into something (id, name) values (:id, :name)\");\n        insert.bind(\"id\", 1);\n        insert.bind(\"name\", \"Brian\");\n        int count = insert.execute();\n        assertThat(count).isEqualTo(1);\n    }\n\n    @Test\n    public void testDemo() throws Exception\n    {\n        Handle h = dbRule.getSharedHandle();\n        h.createUpdate(\"insert into something (id, name) values (:id, :name)\")\n                .bind(\"id\", 1)\n                .bind(\"name\", \"Brian\")\n                .execute();\n        h.execute(\"insert into something (id, name) values (?, ?)\", 2, \"Eric\");\n        h.execute(\"insert into something (id, name) values (?, ?)\", 3, \"Erin\");\n\n        List<Something> r = h.createQuery(\"select id, name from something \" +\n                                          \"where name like :name \" +\n                                          \"order by id\")\n                .bind(\"name\", \"Eri%\")\n                .mapToBean(Something.class)\n                .list();\n\n        assertThat(r).extracting(Something::getId).containsExactly(2, 3);\n    }\n\n    @Test\n    public void testBeanPropertyBinding() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update s = h.createUpdate(\"insert into something (id, name) values (:id, :name)\");\n        s.bindBean(new Something(0, \"Keith\"));\n        int insert_count = s.execute();\n        assertThat(insert_count).isEqualTo(1);\n    }\n\n    @Test\n    public void testFieldsBinding() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update s = h.createUpdate(\"insert into something (id, name) values (:id, :name)\");\n        s.bindFields(new Object() {\n            @SuppressWarnings(\"unused\")\n            public int id = 0;\n            @SuppressWarnings(\"unused\")\n            public String name = \"Keith\";\n        });\n        int insert_count = s.execute();\n        assertThat(insert_count).isEqualTo(1);\n    }\n\n    @Test\n    public void testFunctionsBinding() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update s = h.createUpdate(\"insert into something (id, name) values (:id, :aFunctionThatReturnsTheName)\");\n        s.bindFunctions(new Object() {\n            @SuppressWarnings(\"unused\")\n            public int id() {\n                return 0;\n            }\n\n            @SuppressWarnings(\"unused\")\n            public String aFunctionThatReturnsTheName() {\n                return \"Keith\";\n            }\n        });\n        int insert_count = s.execute();\n        assertThat(insert_count).isEqualTo(1);\n    }\n\n    @Test\n    public void testMapKeyBinding() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update s = h.createUpdate(\"insert into something (id, name) values (:id, :name)\");\n        Map<String, Object> args = new HashMap<>();\n        args.put(\"id\", 0);\n        args.put(\"name\", \"Keith\");\n        s.bindMap(args);\n        int insert_count = s.execute();\n        assertThat(insert_count).isEqualTo(1);\n    }\n\n    @Test\n    public void testCascadedLazyArgs() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update s = h.createUpdate(\"insert into something (id, name) values (:id, :name)\");\n        Map<String, Object> args = new HashMap<>();\n        args.put(\"id\", 0);\n        s.bindMap(args);\n        s.bindBean(new Object()\n        {\n            @SuppressWarnings(\"unused\")\n            public String getName() { return \"Keith\"; }\n        });\n        int insert_count = s.execute();\n        assertThat(insert_count).isEqualTo(1);\n        Something something = h.createQuery(\"select id, name from something\").mapToBean(Something.class).findOnly();\n        assertThat(something).isEqualTo(new Something(0, \"Keith\"));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.core.rule.H2DatabaseRule;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.statement.Query;\nimport org.jdbi.v3.core.statement.Update;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class TestNamedParams\n{\n    @Rule\n    public H2DatabaseRule dbRule = new H2DatabaseRule();\n\n    @Test\n    public void testInsert() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update insert = h.createUpdate(\"insert into something (id, name) values (:id, :name)\");\n        insert.bind(\"id\", 1);\n        insert.bind(\"name\", \"Brian\");\n        int count = insert.execute();\n        assertThat(count).isEqualTo(1);\n    }\n\n    @Test\n    public void testDemo() throws Exception\n    {\n        Handle h = dbRule.getSharedHandle();\n        h.createUpdate(\"insert into something (id, name) values (:id, :name)\")\n                .bind(\"id\", 1)\n                .bind(\"name\", \"Brian\")\n                .execute();\n        h.execute(\"insert into something (id, name) values (?, ?)\", 2, \"Eric\");\n        h.execute(\"insert into something (id, name) values (?, ?)\", 3, \"Erin\");\n\n        List<Something> r = h.createQuery(\"select id, name from something \" +\n                                          \"where name like :name \" +\n                                          \"order by id\")\n                .bind(\"name\", \"Eri%\")\n                .mapToBean(Something.class)\n                .list();\n\n        assertThat(r).extracting(Something::getId).containsExactly(2, 3);\n    }\n\n    @Test\n    public void testBeanPropertyBinding() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Something original = new Something(0, \"Keith\");\n\n        Update s = h.createUpdate(\"insert into something (id, name) values (:id, :name)\");\n        s.bindBean(original);\n        int insert_count = s.execute();\n        assertThat(insert_count).isEqualTo(1);\n\n        Query q = h.createQuery(\"select * from something where id = :id\").bind(\"id\", original.getId());\n        final Something fromDb = q.mapToBean(Something.class).findOnly();\n\n        assertThat(fromDb).isEqualTo(original);\n    }\n\n    @Test\n    public void testFieldsBinding() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update s = h.createUpdate(\"insert into something (id, name) values (:id, :name)\");\n        s.bindFields(new Object() {\n            @SuppressWarnings(\"unused\")\n            public int id = 0;\n            @SuppressWarnings(\"unused\")\n            public String name = \"Keith\";\n        });\n        int insert_count = s.execute();\n\n        Query q = h.createQuery(\"select * from something where id = :id\").bind(\"id\", 0);\n        final Something fromDb = q.mapToBean(Something.class).findOnly();\n\n        assertThat(insert_count).isEqualTo(1);\n        assertThat(fromDb).extracting(Something::getId, Something::getName).containsExactly(0, \"Keith\");\n    }\n\n    @Test\n    public void testFunctionsBinding() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update s = h.createUpdate(\"insert into something (id, name) values (:id, :aFunctionThatReturnsTheName)\");\n        s.bindMethods(new Object() {\n            @SuppressWarnings(\"unused\")\n            public int id() {\n                return 0;\n            }\n\n            @SuppressWarnings(\"unused\")\n            public String aFunctionThatReturnsTheName() {\n                return \"Keith\";\n            }\n        });\n        int insert_count = s.execute();\n\n        Query q = h.createQuery(\"select * from something where id = :id\").bind(\"id\", 0);\n        final Something fromDb = q.mapToBean(Something.class).findOnly();\n\n        assertThat(insert_count).isEqualTo(1);\n        assertThat(fromDb).extracting(Something::getId, Something::getName).containsExactly(0, \"Keith\");\n    }\n\n    @Test\n    public void testMapKeyBinding() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update s = h.createUpdate(\"insert into something (id, name) values (:id, :name)\");\n        Map<String, Object> args = new HashMap<>();\n        args.put(\"id\", 0);\n        args.put(\"name\", \"Keith\");\n        s.bindMap(args);\n        int insert_count = s.execute();\n\n        Query q = h.createQuery(\"select * from something where id = :id\").bind(\"id\", 0);\n        final Something fromDb = q.mapToBean(Something.class).findOnly();\n\n        assertThat(insert_count).isEqualTo(1);\n        assertThat(fromDb).extracting(Something::getId, Something::getName).containsExactly(0, \"Keith\");\n    }\n\n    @Test\n    public void testCascadedLazyArgs() throws Exception\n    {\n        Handle h = dbRule.openHandle();\n        Update s = h.createUpdate(\"insert into something (id, name) values (:id, :name)\");\n        Map<String, Object> args = new HashMap<>();\n        args.put(\"id\", 0);\n        s.bindMap(args);\n        s.bindBean(new Object()\n        {\n            @SuppressWarnings(\"unused\")\n            public String getName() { return \"Keith\"; }\n        });\n        int insert_count = s.execute();\n        assertThat(insert_count).isEqualTo(1);\n        Something something = h.createQuery(\"select id, name from something\").mapToBean(Something.class).findOnly();\n        assertThat(something).isEqualTo(new Something(0, \"Keith\"));\n    }\n}\n","lineNo":71}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\n/**\n * Inspect a {@link java.beans} style object and bind parameters\n * based on each of its discovered properties.\n */\npublic class BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private BeanInfo info;\n\n    /**\n     * @param prefix an optional prefix (we insert a '.' as a separator)\n     * @param bean the bean to inspect and bind\n     */\n    public BeanPropertyArguments(String prefix, Object bean)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name, StatementContext ctx)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    Method getter = descriptor.getReadMethod();\n                    if (getter == null)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"No getter method found for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), ctx);\n                    }\n\n                    try\n                    {\n                        Type propertyType = getter.getGenericReturnType();\n                        Object propertyValue = getter.invoke(bean);\n                        Optional<Argument> argument = ctx.findArgumentFor(propertyType, propertyValue);\n\n                        if (!argument.isPresent()) {\n                            throw new UnableToCreateStatementException(\n                                    String.format(\"No argument factory registered for type [%s] for bean property [%s] on [%s]\",\n                                            propertyType,\n                                            propertyName,\n                                            bean), ctx);\n                        }\n\n                        return argument;\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n\n            try\n            {\n                for (Field field : bean.getClass().getFields())\n                {\n                    if (Modifier.isPublic(field.getModifiers()) && field.getName().equals(propertyName))\n                    {\n                        Object fieldValue = field.get(bean);\n                        Optional<Argument> argument = ctx.findArgumentFor(field.getGenericType(), fieldValue);\n\n                        if (argument.isPresent())\n                        {\n                            return argument;\n                        }\n                    }\n                }\n            }\n            catch (IllegalAccessException e)\n            {\n                throw new UnableToCreateStatementException(String.format(\"Access exception getting field for \" +\n                                \"bean property [%s] on [%s]\",\n                        propertyName, bean), e, ctx);\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\n/**\n * Inspect a {@link java.beans} style object and bind parameters\n * based on each of its discovered properties.\n */\npublic class BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private BeanInfo info;\n\n    /**\n     * @param prefix an optional prefix (we insert a '.' as a separator)\n     * @param bean the bean to inspect and bind\n     */\n    public BeanPropertyArguments(String prefix, Object bean)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name, StatementContext ctx)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    Method getter = descriptor.getReadMethod();\n                    if (getter == null)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"No getter method found for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), ctx);\n                    }\n\n                    try\n                    {\n                        Type propertyType = getter.getGenericReturnType();\n                        Object propertyValue = getter.invoke(bean);\n                        Optional<Argument> argument = ctx.findArgumentFor(propertyType, propertyValue);\n\n                        if (!argument.isPresent()) {\n                            throw new UnableToCreateStatementException(\n                                    String.format(\"No argument factory registered for type [%s] for bean property [%s] on [%s]\",\n                                            propertyType,\n                                            propertyName,\n                                            bean), ctx);\n                        }\n\n                        return argument;\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n\n            try\n            {\n                for (Field field : bean.getClass().getFields())\n                {\n                    if (field.getName().equals(propertyName))\n                    {\n                        Object fieldValue = field.get(bean);\n                        Type fieldType = field.getGenericType();\n                        Optional<Argument> argument = ctx.findArgumentFor(fieldType, fieldValue);\n\n                        if (!argument.isPresent())\n                        {\n                            throw new UnableToCreateStatementException(\n                                    String.format(\"No argument factory registered for type [%s] for field [%s] on [%s]\",\n                                            fieldType,\n                                            propertyName,\n                                            bean), ctx);\n                        }\n\n                        return argument;\n                    }\n                }\n            }\n            catch (IllegalAccessException e)\n            {\n                throw new UnableToCreateStatementException(String.format(\"Access exception getting field for \" +\n                                \"bean property [%s] on [%s]\",\n                        propertyName, bean), e, ctx);\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","lineNo":113}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport static org.jdbi.v3.core.result.ResultProducers.returningGeneratedKeys;\nimport static org.jdbi.v3.core.result.ResultProducers.returningResults;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.result.ResultProducer;\nimport org.jdbi.v3.core.result.ResultSetScanner;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Represents a prepared batch statement.  Multiple bindings are added to the\n * compiled statement and then executed in a single operation. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n *\n * The statement starts with an empty binding.  You bind a single batch of parameters\n * with the usual {@link SqlStatement} binding methods, and then call\n * {@link PreparedBatch#add()} to add the current binding as a batch and then clear it.\n *\n * An entire batch can be bound and added in one go with {@link PreparedBatch#add(Map)}\n * or {@link PreparedBatch#add(Object...)}.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch> implements ResultBearing\n{\n    private static final Logger LOG = LoggerFactory.getLogger(PreparedBatch.class);\n\n    private final List<Binding> bindings = new ArrayList<>();\n\n    public PreparedBatch(Handle handle, String sql)\n    {\n        super(handle, sql);\n    }\n\n    @Override\n    public <R> R scanResultSet(ResultSetScanner<R> mapper) {\n        return execute(returningResults()).scanResultSet(mapper);\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        return internalBatchExecute().updateCounts;\n    }\n\n    public ResultIterator<Integer> executeAndGetModCount() {\n        StatementContext ctx = getContext();\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return ctx;\n            }\n\n            @Override\n            public void close() {\n            }\n        };\n    }\n\n    public ResultBearing executeAndReturnGeneratedKeys(String... columnNames) {\n        return execute(returningGeneratedKeys(columnNames));\n    }\n\n    /**\n     * Executes the batch, returning the result obtained from the given {@link ResultProducer}.\n     *\n     * @param <R> the type of the result\n     * @param producer the result producer.\n     * @return value returned by the result producer.\n     */\n    public <R> R execute(ResultProducer<R> producer) {\n        try {\n            return producer.produce(() -> internalBatchExecute().stmt, getContext());\n        } catch (SQLException e) {\n            try {\n                close();\n            } catch (Exception e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToProduceResultException(\"Exception producing batch result\", e, getContext());\n        }\n    }\n\n    private static class ExecutedBatch {\n        final PreparedStatement stmt;\n        final int[] updateCounts;\n\n        ExecutedBatch(PreparedStatement stmt, int[] updateCounts) {\n            this.stmt = stmt;\n            this.updateCounts = updateCounts;\n        }\n    }\n\n    private ExecutedBatch internalBatchExecute() {\n        if (!getBinding().isEmpty()) {\n            add();\n        }\n        if (bindings.isEmpty()) {\n            throw new IllegalStateException(\"No batch parts to execute\");\n        }\n\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(getSql(), getContext());\n        getContext().setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, getContext());\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            final PreparedStatement stmt;\n            try {\n                StatementBuilder statementBuilder = getHandle().getStatementBuilder();\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, getContext());\n                addCleanable(() -> statementBuilder.close(connection, sql, stmt));\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n\n            try {\n                for (Binding binding : bindings) {\n                    ArgumentBinder.bind(parsedParameters, binding, stmt, getContext());\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, getContext());\n            }\n\n            beforeExecution(stmt);\n\n            try {\n                final long start = System.nanoTime();\n                final int[] rs =  stmt.executeBatch();\n                final long elapsedTime = System.nanoTime() - start;\n                LOG.trace(\"Prepared batch of {} parts executed in {}ms\", bindings.size(), elapsedTime / 1000000L, parsedSql);\n                getConfig(SqlStatements.class).getTimingCollector().collect(elapsedTime, getContext());\n\n                afterExecution(stmt);\n\n                return new ExecutedBatch(stmt, rs);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), getContext());\n            }\n        }\n        finally {\n            bindings.clear();\n        }\n    }\n\n    /**\n     * Add the current binding as a saved batch and clear the binding.\n     * @return this\n     */\n    public PreparedBatch add()\n    {\n        bindings.add(getBinding());\n        getContext().setBinding(new Binding());\n        return this;\n    }\n\n    /**\n     * Bind arguments positionally, add the binding as a saved batch, and\n     * then clear the current binding.\n     * @param args the positional arguments to bind\n     * @return this\n     */\n    public PreparedBatch add(Object... args)\n    {\n        for(int i = 0; i < args.length; i++) {\n            bind(i, args[i]);\n        }\n        add();\n        return this;\n    }\n\n    /**\n     * Bind arguments from a Map, add the binding as a saved batch,\n     * then clear the current binding.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     * @return this\n     */\n    public PreparedBatch add(Map<String, ?> args)\n    {\n        bindMap(args);\n        add();\n        return this;\n    }\n\n    /**\n     * @return the number of bindings which are in this batch\n     */\n    public int size()\n    {\n        return bindings.size();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport static org.jdbi.v3.core.result.ResultProducers.returningGeneratedKeys;\nimport static org.jdbi.v3.core.result.ResultProducers.returningResults;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.result.ResultBearing;\nimport org.jdbi.v3.core.result.ResultIterator;\nimport org.jdbi.v3.core.result.ResultProducer;\nimport org.jdbi.v3.core.result.ResultSetScanner;\nimport org.jdbi.v3.core.result.UnableToProduceResultException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Represents a prepared batch statement.  Multiple bindings are added to the\n * compiled statement and then executed in a single operation. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n *\n * The statement starts with an empty binding.  You bind a single batch of parameters\n * with the usual {@link SqlStatement} binding methods, and then call\n * {@link PreparedBatch#add()} to add the current binding as a batch and then clear it.\n *\n * An entire batch can be bound and added in one go with {@link PreparedBatch#add(Map)}\n * or {@link PreparedBatch#add(Object...)}.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch> implements ResultBearing\n{\n    private static final Logger LOG = LoggerFactory.getLogger(PreparedBatch.class);\n\n    private final List<Binding> bindings = new ArrayList<>();\n\n    public PreparedBatch(Handle handle, String sql)\n    {\n        super(handle, sql);\n    }\n\n    @Override\n    public <R> R scanResultSet(ResultSetScanner<R> mapper) {\n        return execute(returningResults()).scanResultSet(mapper);\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        return internalBatchExecute().updateCounts;\n    }\n\n    public ResultIterator<Integer> executeAndGetModCount() {\n        StatementContext ctx = getContext();\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return ctx;\n            }\n\n            @Override\n            public void close() {\n            }\n        };\n    }\n\n    public ResultBearing executeAndReturnGeneratedKeys(String... columnNames) {\n        return execute(returningGeneratedKeys(columnNames));\n    }\n\n    /**\n     * Executes the batch, returning the result obtained from the given {@link ResultProducer}.\n     *\n     * @param <R> the type of the result\n     * @param producer the result producer.\n     * @return value returned by the result producer.\n     */\n    public <R> R execute(ResultProducer<R> producer) {\n        try {\n            return producer.produce(() -> internalBatchExecute().stmt, getContext());\n        } catch (SQLException e) {\n            try {\n                close();\n            } catch (Exception e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToProduceResultException(\"Exception producing batch result\", e, getContext());\n        }\n    }\n\n    private static class ExecutedBatch {\n        final PreparedStatement stmt;\n        final int[] updateCounts;\n\n        ExecutedBatch(PreparedStatement stmt, int[] updateCounts) {\n            this.stmt = stmt;\n            this.updateCounts = updateCounts;\n        }\n    }\n\n    private ExecutedBatch internalBatchExecute() {\n        if (!getBinding().isEmpty()) {\n            add();\n        }\n        if (bindings.isEmpty()) {\n            throw new IllegalStateException(\"No batch parts to execute\");\n        }\n\n        String renderedSql = getConfig(SqlStatements.class)\n                .getTemplateEngine()\n                .render(getSql(), getContext());\n        getContext().setRenderedSql(renderedSql);\n\n        ParsedSql parsedSql = getConfig(SqlStatements.class)\n                .getSqlParser()\n                .parse(renderedSql, getContext());\n        String sql = parsedSql.getSql();\n        ParsedParameters parsedParameters = parsedSql.getParameters();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            final PreparedStatement stmt;\n            try {\n                StatementBuilder statementBuilder = getHandle().getStatementBuilder();\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, getContext());\n                addCleanable(() -> statementBuilder.close(connection, sql, stmt));\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n\n            try {\n                for (Binding binding : bindings) {\n                    ArgumentBinder.bind(parsedParameters, binding, stmt, getContext());\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, getContext());\n            }\n\n            beforeExecution(stmt);\n\n            try {\n                final long start = System.nanoTime();\n                final int[] rs =  stmt.executeBatch();\n                final long elapsedTime = System.nanoTime() - start;\n                LOG.trace(\"Prepared batch of {} parts executed in {}ms\", bindings.size(), elapsedTime / 1000000L, parsedSql);\n                getConfig(SqlStatements.class).getTimingCollector().collect(elapsedTime, getContext());\n\n                afterExecution(stmt);\n\n                return new ExecutedBatch(stmt, rs);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), getContext());\n            }\n        }\n        finally {\n            bindings.clear();\n        }\n    }\n\n    /**\n     * Add the current binding as a saved batch and clear the binding.\n     * @return this\n     */\n    public PreparedBatch add()\n    {\n        final Binding currentBinding = getBinding();\n        if (currentBinding.isEmpty()) {\n            throw new IllegalStateException(\"Attempt to add() a empty batch, you probably didn't mean to do this \"\n                    + \"- call add() *after* setting batch parameters\");\n        }\n        bindings.add(currentBinding);\n        getContext().setBinding(new Binding());\n        return this;\n    }\n\n    /**\n     * Bind arguments positionally, add the binding as a saved batch, and\n     * then clear the current binding.\n     * @param args the positional arguments to bind\n     * @return this\n     */\n    public PreparedBatch add(Object... args)\n    {\n        for(int i = 0; i < args.length; i++) {\n            bind(i, args[i]);\n        }\n        add();\n        return this;\n    }\n\n    /**\n     * Bind arguments from a Map, add the binding as a saved batch,\n     * then clear the current binding.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     * @return this\n     */\n    public PreparedBatch add(Map<String, ?> args)\n    {\n        bindMap(args);\n        add();\n        return this;\n    }\n\n    /**\n     * @return the number of bindings which are in this batch\n     */\n    public int size()\n    {\n        return bindings.size();\n    }\n}\n","lineNo":208}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\npublic class BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private BeanInfo info;\n\n    public BeanPropertyArguments(String prefix, Object bean)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name, StatementContext ctx)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    Method getter = descriptor.getReadMethod();\n                    if (getter == null)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"No getter method found for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), ctx);\n                    }\n\n                    try\n                    {\n                        return ctx.findArgumentFor(getter.getGenericReturnType(), getter.invoke(bean));\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\npublic class BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private BeanInfo info;\n\n    public BeanPropertyArguments(String prefix, Object bean)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name, StatementContext ctx)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    Method getter = descriptor.getReadMethod();\n                    if (getter == null)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"No getter method found for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), ctx);\n                    }\n\n                    try\n                    {\n                        Type propertyType = getter.getGenericReturnType();\n                        Object propertyValue = getter.invoke(bean);\n                        Argument argument = ctx.findArgumentFor(propertyType, propertyValue)\n                                .orElseThrow(() -> new UnableToCreateStatementException(\n                                        String.format(\"No argument factory registered for type [%s] for bean property [%s] on [%s]\",\n                                                propertyType,\n                                                propertyName,\n                                                bean), ctx));\n\n                        return Optional.of(argument);\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","lineNo":69}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\npublic class BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private BeanInfo info;\n\n    public BeanPropertyArguments(String prefix, Object bean)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name, StatementContext ctx)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    Method getter = descriptor.getReadMethod();\n                    if (getter == null)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"No getter method found for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), ctx);\n                    }\n\n                    try\n                    {\n                        return ctx.findArgumentFor(getter.getGenericReturnType(), getter.invoke(bean));\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\npublic class BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private BeanInfo info;\n\n    public BeanPropertyArguments(String prefix, Object bean)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name, StatementContext ctx)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    Method getter = descriptor.getReadMethod();\n                    if (getter == null)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"No getter method found for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), ctx);\n                    }\n\n                    try\n                    {\n                        Type propertyType = getter.getGenericReturnType();\n                        Object propertyValue = getter.invoke(bean);\n                        Argument argument = ctx.findArgumentFor(propertyType, propertyValue)\n                                .orElseThrow(() -> new UnableToCreateStatementException(\n                                        String.format(\"No argument factory registered for type [%s] for bean property [%s] on [%s]\",\n                                                propertyType,\n                                                propertyName,\n                                                bean), ctx));\n\n                        return Optional.of(argument);\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","lineNo":70}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\npublic class BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private BeanInfo info;\n\n    public BeanPropertyArguments(String prefix, Object bean)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name, StatementContext ctx)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    Method getter = descriptor.getReadMethod();\n                    if (getter == null)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"No getter method found for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), ctx);\n                    }\n\n                    try\n                    {\n                        return ctx.findArgumentFor(getter.getGenericReturnType(), getter.invoke(bean));\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\n\npublic class BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private BeanInfo info;\n\n    public BeanPropertyArguments(String prefix, Object bean)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name, StatementContext ctx)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    Method getter = descriptor.getReadMethod();\n                    if (getter == null)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"No getter method found for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), ctx);\n                    }\n\n                    try\n                    {\n                        Type propertyType = getter.getGenericReturnType();\n                        Object propertyValue = getter.invoke(bean);\n                        Argument argument = ctx.findArgumentFor(propertyType, propertyValue)\n                                .orElseThrow(() -> new UnableToCreateStatementException(\n                                        String.format(\"No argument factory registered for type [%s] for bean property [%s] on [%s]\",\n                                                propertyType,\n                                                propertyName,\n                                                bean), ctx));\n\n                        return Optional.of(argument);\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","lineNo":68}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport static java.util.stream.Collectors.joining;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.MapArguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMappers;\nimport org.jdbi.v3.core.rewriter.RewrittenStatement;\nimport org.jdbi.v3.core.transaction.TransactionState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private static final Logger LOG = LoggerFactory.getLogger(SqlStatement.class);\n\n    private final Handle  handle;\n    private final String  sql;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private RewrittenStatement rewritten;\n    private PreparedStatement  stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding()\n    {\n        return getContext().getBinding();\n    }\n\n    public This setFetchDirection(final int value)\n    {\n        addCustomizer(StatementCustomizers.fetchDirection(value));\n        return typedThis;\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql()\n    {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds)\n    {\n        return addCustomizer(StatementCustomizers.statementTimeout(seconds));\n    }\n\n    /**\n     * Close the handle when the statement is closed.\n     *\n     * @return the same Query instance\n     */\n    public This cleanupHandle()\n    {\n        return cleanupHandle(TransactionState.ROLLBACK);\n    }\n\n    /**\n     * Force transaction state when the statement is cleaned up.\n     *\n     * @param state the transaction state to enforce.\n     *\n     * @return the same Query instance\n     */\n    public This cleanupHandle(final TransactionState state)\n    {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    if (state == TransactionState.COMMIT) {\n                        handle.commit();\n                    } else {\n                        handle.rollback();\n                    }\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument)\n    {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument)\n    {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(null, bean));\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(String prefix, Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map)\n    {\n        return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map));\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder)\n    {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value)\n    {\n        return bind(position, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value)\n    {\n        return bind(name, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value)\n    {\n        return bind(position, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value)\n    {\n        return bind(name, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value)\n    {\n        return bind(position, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value)\n    {\n        return bind(position, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value)\n    {\n        return bind(name, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value)\n    {\n        return bind(name, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value)\n    {\n        return bind(position, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value)\n    {\n        return bind(name, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value)\n    {\n        return bind(position, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value)\n    {\n        return bind(name, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value)\n    {\n        return bind(position, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value)\n    {\n        return bind(name, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value)\n    {\n        return bind(position, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value)\n    {\n        return bind(position, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value)\n    {\n        return bind(name, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value)\n    {\n        return bind(name, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value)\n    {\n        return bind(position, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value)\n    {\n        return bind(position, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value)\n    {\n        return bind(name, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value)\n    {\n        return bind(name, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value)\n    {\n        return bind(position, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value)\n    {\n        return bind(name, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length)\n    {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length)\n    {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value)\n    {\n        return bind(position, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value)\n    {\n        return bind(name, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value)\n    {\n        return bind(position, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value)\n    {\n        return bind(name, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value)\n    {\n        return bind(position, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value)\n    {\n        return bind(name, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value)\n    {\n        return bind(position, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value)\n    {\n        return bind(position, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value)\n    {\n        return bind(name, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value)\n    {\n        return bind(name, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value)\n    {\n        return bind(position, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value)\n    {\n        return bind(position, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value)\n    {\n        return bind(name, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value)\n    {\n        return bind(name, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value)\n    {\n        return bind(position, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value)\n    {\n        return bind(position, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value)\n    {\n        return bind(name, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value)\n    {\n        return bind(name, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value)\n    {\n        return bind(position, toArgument(Short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value)\n    {\n        return bind(position, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value)\n    {\n        return bind(position, toArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value)\n    {\n        return bind(name, toArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value)\n    {\n        return bind(position, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value)\n    {\n        return bind(name, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value)\n    {\n        return bind(position, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value)\n    {\n        return bind(name, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value)\n    {\n        return bind(position, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value)\n    {\n        return bind(name, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType)\n    {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType)\n    {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    private Argument toArgument(Object value) {\n        return toArgument(value == null ? Object.class : value.getClass(), value);\n    }\n\n    private Argument toArgument(Type type, Object value) {\n        return getConfig(Arguments.class).findFor(type, value)\n                .orElseThrow(() -> new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of type \" + type));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType)\n    {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType)\n    {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType)\n    {\n        return bind(name, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType)\n    {\n        return bind(position, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a parameter for each value in the given vararg array, and defines an attribute as the comma-separated list\n     * of parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", 1, 2, 3)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with no vararg values.\");\n        }\n\n        return bindList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     */\n    public final This bindList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with an empty list.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            names.append(':').append(name);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean);\n\n            names.append(\"(\");\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(\",\");\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + \"_\" + valueIndex + \"_\" + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        if (values.contains(null)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    PreparedStatement internalExecute()\n    {\n        rewritten = getConfig(SqlStatements.class)\n                .getStatementRewriter()\n                .rewrite(sql, getBinding(), getContext());\n        getContext().setRewrittenSql(rewritten.getSql());\n        try {\n            if (getClass().isAssignableFrom(Call.class)) {\n                stmt = handle.getStatementBuilder().createCall(handle.getConnection(), rewritten.getSql(), getContext());\n            }\n            else {\n                stmt = handle.getStatementBuilder().create(handle.getConnection(), rewritten.getSql(), getContext());\n            }\n        }\n        catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, getContext());\n        }\n\n        // The statement builder might (or might not) clean up the statement when called. E.g. the\n        // caching statement builder relies on the statement *not* being closed.\n        addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), sql, stmt));\n\n        getContext().setStatement(stmt);\n\n        try {\n            rewritten.bind(getBinding(), stmt);\n        }\n        catch (SQLException e) {\n            throw new UnableToExecuteStatementException(\"Unable to bind parameters to query\", e, getContext());\n        }\n\n        beforeExecution(stmt);\n\n        try {\n            final long start = System.nanoTime();\n            stmt.execute();\n            final long elapsedTime = System.nanoTime() - start;\n            LOG.trace(\"Execute SQL \\\"{}\\\" in {}ms\", rewritten.getSql(), elapsedTime / 1000000L);\n            getConfig(SqlStatements.class)\n                    .getTimingCollector()\n                    .collect(elapsedTime, getContext());\n        }\n        catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToExecuteStatementException(e, getContext());\n        }\n\n        afterExecution(stmt);\n\n        return stmt;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> rowMapperForType(Class<T> type)\n    {\n        return (RowMapper<T>) rowMapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> rowMapperForType(GenericType<T> type)\n    {\n        return (RowMapper<T>) rowMapperForType(type.getType());\n    }\n\n    RowMapper<?> rowMapperForType(Type type)\n    {\n        return getConfig(RowMappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport static java.util.stream.Collectors.joining;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.MapArguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMappers;\nimport org.jdbi.v3.core.rewriter.ParsedParameters;\nimport org.jdbi.v3.core.rewriter.ParsedStatement;\nimport org.jdbi.v3.core.transaction.TransactionState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private static final Logger LOG = LoggerFactory.getLogger(SqlStatement.class);\n\n    private final Handle  handle;\n    private final String  sql;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private PreparedStatement stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding()\n    {\n        return getContext().getBinding();\n    }\n\n    public This setFetchDirection(final int value)\n    {\n        addCustomizer(StatementCustomizers.fetchDirection(value));\n        return typedThis;\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql()\n    {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds)\n    {\n        return addCustomizer(StatementCustomizers.statementTimeout(seconds));\n    }\n\n    /**\n     * Close the handle when the statement is closed.\n     *\n     * @return the same Query instance\n     */\n    public This cleanupHandle()\n    {\n        return cleanupHandle(TransactionState.ROLLBACK);\n    }\n\n    /**\n     * Force transaction state when the statement is cleaned up.\n     *\n     * @param state the transaction state to enforce.\n     *\n     * @return the same Query instance\n     */\n    public This cleanupHandle(final TransactionState state)\n    {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    if (state == TransactionState.COMMIT) {\n                        handle.commit();\n                    } else {\n                        handle.rollback();\n                    }\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument)\n    {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument)\n    {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(null, bean));\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(String prefix, Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map)\n    {\n        return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map));\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder)\n    {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value)\n    {\n        return bind(position, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value)\n    {\n        return bind(name, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value)\n    {\n        return bind(position, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value)\n    {\n        return bind(name, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value)\n    {\n        return bind(position, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value)\n    {\n        return bind(position, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value)\n    {\n        return bind(name, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value)\n    {\n        return bind(name, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value)\n    {\n        return bind(position, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value)\n    {\n        return bind(name, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value)\n    {\n        return bind(position, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value)\n    {\n        return bind(name, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value)\n    {\n        return bind(position, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value)\n    {\n        return bind(name, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value)\n    {\n        return bind(position, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value)\n    {\n        return bind(position, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value)\n    {\n        return bind(name, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value)\n    {\n        return bind(name, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value)\n    {\n        return bind(position, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value)\n    {\n        return bind(position, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value)\n    {\n        return bind(name, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value)\n    {\n        return bind(name, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value)\n    {\n        return bind(position, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value)\n    {\n        return bind(name, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length)\n    {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length)\n    {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value)\n    {\n        return bind(position, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value)\n    {\n        return bind(name, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value)\n    {\n        return bind(position, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value)\n    {\n        return bind(name, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value)\n    {\n        return bind(position, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value)\n    {\n        return bind(name, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value)\n    {\n        return bind(position, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value)\n    {\n        return bind(position, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value)\n    {\n        return bind(name, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value)\n    {\n        return bind(name, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value)\n    {\n        return bind(position, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value)\n    {\n        return bind(position, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value)\n    {\n        return bind(name, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value)\n    {\n        return bind(name, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value)\n    {\n        return bind(position, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value)\n    {\n        return bind(position, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value)\n    {\n        return bind(name, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value)\n    {\n        return bind(name, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value)\n    {\n        return bind(position, toArgument(Short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value)\n    {\n        return bind(position, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value)\n    {\n        return bind(position, toArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value)\n    {\n        return bind(name, toArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value)\n    {\n        return bind(position, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value)\n    {\n        return bind(name, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value)\n    {\n        return bind(position, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value)\n    {\n        return bind(name, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value)\n    {\n        return bind(position, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value)\n    {\n        return bind(name, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType)\n    {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType)\n    {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    private Argument toArgument(Object value) {\n        return toArgument(value == null ? Object.class : value.getClass(), value);\n    }\n\n    private Argument toArgument(Type type, Object value) {\n        return getConfig(Arguments.class).findFor(type, value)\n                .orElseThrow(() -> new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of type \" + type));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType)\n    {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType)\n    {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType)\n    {\n        return bind(name, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType)\n    {\n        return bind(position, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a parameter for each value in the given vararg array, and defines an attribute as the comma-separated list\n     * of parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", 1, 2, 3)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with no vararg values.\");\n        }\n\n        return bindList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     */\n    public final This bindList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with an empty list.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            names.append(':').append(name);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean);\n\n            names.append(\"(\");\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(\",\");\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + \"_\" + valueIndex + \"_\" + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        if (values.contains(null)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    PreparedStatement internalExecute()\n    {\n        String rewrittenSql = getConfig(SqlStatements.class)\n                .getStatementRewriter()\n                .rewrite(sql, getContext());\n        getContext().setRewrittenSql(rewrittenSql);\n\n        ParsedStatement parsed = getConfig(SqlStatements.class)\n                .getStatementParser()\n                .parse(rewrittenSql);\n        String parsedSql = parsed.getSql();\n        ParsedParameters parsedParameters = parsed.getParameters();\n        getContext().setParsedSql(parsedSql);\n\n        try {\n            if (getClass().isAssignableFrom(Call.class)) {\n                stmt = handle.getStatementBuilder().createCall(handle.getConnection(), parsedSql, getContext());\n            }\n            else {\n                stmt = handle.getStatementBuilder().create(handle.getConnection(), parsedSql, getContext());\n            }\n        }\n        catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, getContext());\n        }\n\n        // The statement builder might (or might not) clean up the statement when called. E.g. the\n        // caching statement builder relies on the statement *not* being closed.\n        addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), this.sql, stmt));\n\n        getContext().setStatement(stmt);\n\n        ArgumentBinder.bind(parsedParameters, getBinding(), stmt, getContext());\n\n        beforeExecution(stmt);\n\n        try {\n            final long start = System.nanoTime();\n            stmt.execute();\n            final long elapsedTime = System.nanoTime() - start;\n            LOG.trace(\"Execute SQL \\\"{}\\\" in {}ms\", parsedSql, elapsedTime / 1000000L);\n            getConfig(SqlStatements.class)\n                    .getTimingCollector()\n                    .collect(elapsedTime, getContext());\n        }\n        catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToExecuteStatementException(e, getContext());\n        }\n\n        afterExecution(stmt);\n\n        return stmt;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> rowMapperForType(Class<T> type)\n    {\n        return (RowMapper<T>) rowMapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> rowMapperForType(GenericType<T> type)\n    {\n        return (RowMapper<T>) rowMapperForType(type.getType());\n    }\n\n    RowMapper<?> rowMapperForType(Type type)\n    {\n        return getConfig(RowMappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n}\n","lineNo":1367}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.config.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.collector.CollectorFactory;\nimport org.jdbi.v3.core.collector.JdbiCollectors;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.sqlobject.config.Configurer;\nimport org.jdbi.v3.sqlobject.config.RegisterCollectorFactory;\n\npublic class RegisterCollectorFactoryImpl implements Configurer {\n    @Override\n    public void configureForMethod(ConfigRegistry registry, Annotation annotation, Class<?> sqlObjectType, Method method) {\n        configureForType(registry, annotation, sqlObjectType);\n    }\n\n    @Override\n    public void configureForType(ConfigRegistry registry, Annotation annotation, Class<?> sqlObjectType) {\n        RegisterCollectorFactory registerCollectorFactory = (RegisterCollectorFactory) annotation;\n        JdbiCollectors collectors = registry.get(JdbiCollectors.class);\n        for (Class<? extends CollectorFactory> type : registerCollectorFactory.value()) {\n            try {\n                collectors.register(type.newInstance());\n            } catch (InstantiationException | IllegalAccessException e) {\n                throw new IllegalStateException(\"Unable to instantiate container factory\", e);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.config.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport org.jdbi.v3.core.collector.CollectorFactory;\nimport org.jdbi.v3.core.collector.JdbiCollectors;\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.sqlobject.config.Configurer;\nimport org.jdbi.v3.sqlobject.config.RegisterCollectorFactory;\n\npublic class RegisterCollectorFactoryImpl implements Configurer {\n    @Override\n    public void configureForMethod(ConfigRegistry registry, Annotation annotation, Class<?> sqlObjectType, Method method) {\n        configureForType(registry, annotation, sqlObjectType);\n    }\n\n    @Override\n    public void configureForType(ConfigRegistry registry, Annotation annotation, Class<?> sqlObjectType) {\n        RegisterCollectorFactory registerCollectorFactory = (RegisterCollectorFactory) annotation;\n        JdbiCollectors collectors = registry.get(JdbiCollectors.class);\n        Class<? extends CollectorFactory> type = registerCollectorFactory.value();\n        try {\n            collectors.register(type.newInstance());\n        } catch (InstantiationException | IllegalAccessException e) {\n            throw new IllegalStateException(\"Unable to instantiate container factory\", e);\n        }\n    }\n}\n","lineNo":34}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport static java.util.stream.Collectors.joining;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.MapArguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMappers;\nimport org.jdbi.v3.core.rewriter.RewrittenStatement;\nimport org.jdbi.v3.core.transaction.TransactionState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private static final Logger LOG = LoggerFactory.getLogger(SqlStatement.class);\n\n    private final Handle  handle;\n    private final String  sql;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private RewrittenStatement rewritten;\n    private PreparedStatement  stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding()\n    {\n        return getContext().getBinding();\n    }\n\n    public This setFetchDirection(final int value)\n    {\n        addCustomizer(new StatementCustomizers.FetchDirectionStatementCustomizer(value));\n        return typedThis;\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql()\n    {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds)\n    {\n        return addCustomizer(new StatementCustomizers.QueryTimeoutCustomizer(seconds));\n    }\n\n    /**\n     * Close the handle when the statement is closed.\n     *\n     * @return the same Query instance\n     */\n    public This cleanupHandle()\n    {\n        return cleanupHandle(TransactionState.ROLLBACK);\n    }\n\n    /**\n     * Force transaction state when the statement is cleaned up.\n     *\n     * @param state the transaction state to enforce.\n     *\n     * @return the same Query instance\n     */\n    public This cleanupHandle(final TransactionState state)\n    {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    if (state == TransactionState.COMMIT) {\n                        handle.commit();\n                    } else {\n                        handle.rollback();\n                    }\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument)\n    {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument)\n    {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(null, bean, getContext()));\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(String prefix, Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean, getContext()));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map)\n    {\n        return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map, getContext()));\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder)\n    {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value)\n    {\n        return bind(position, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value)\n    {\n        return bind(name, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value)\n    {\n        return bind(position, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value)\n    {\n        return bind(name, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value)\n    {\n        return bind(position, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value)\n    {\n        return bind(position, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value)\n    {\n        return bind(name, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value)\n    {\n        return bind(name, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value)\n    {\n        return bind(position, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value)\n    {\n        return bind(name, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value)\n    {\n        return bind(position, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value)\n    {\n        return bind(name, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value)\n    {\n        return bind(position, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value)\n    {\n        return bind(name, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value)\n    {\n        return bind(position, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value)\n    {\n        return bind(position, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value)\n    {\n        return bind(name, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value)\n    {\n        return bind(name, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value)\n    {\n        return bind(position, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value)\n    {\n        return bind(position, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value)\n    {\n        return bind(name, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value)\n    {\n        return bind(name, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value)\n    {\n        return bind(position, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value)\n    {\n        return bind(name, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length)\n    {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length)\n    {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value)\n    {\n        return bind(position, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value)\n    {\n        return bind(name, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value)\n    {\n        return bind(position, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value)\n    {\n        return bind(name, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value)\n    {\n        return bind(position, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value)\n    {\n        return bind(name, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value)\n    {\n        return bind(position, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value)\n    {\n        return bind(position, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value)\n    {\n        return bind(name, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value)\n    {\n        return bind(name, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value)\n    {\n        return bind(position, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value)\n    {\n        return bind(position, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value)\n    {\n        return bind(name, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value)\n    {\n        return bind(name, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value)\n    {\n        return bind(position, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value)\n    {\n        return bind(position, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value)\n    {\n        return bind(name, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value)\n    {\n        return bind(name, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value)\n    {\n        return bind(position, toArgument(Short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value)\n    {\n        return bind(position, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value)\n    {\n        return bind(position, toArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value)\n    {\n        return bind(name, toArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value)\n    {\n        return bind(position, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value)\n    {\n        return bind(name, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value)\n    {\n        return bind(position, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value)\n    {\n        return bind(name, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value)\n    {\n        return bind(position, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value)\n    {\n        return bind(name, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType)\n    {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType)\n    {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    private Argument toArgument(Object value) {\n        return toArgument(value == null ? Object.class : value.getClass(), value);\n    }\n\n    private Argument toArgument(Type type, Object value) {\n        return getConfig(Arguments.class).findFor(type, value)\n                .orElseThrow(() -> new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of type \" + type));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType)\n    {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType)\n    {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType)\n    {\n        return bind(name, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType)\n    {\n        return bind(position, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a parameter for each value in the given vararg array, and defines an attribute as the comma-separated list\n     * of parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", 1, 2, 3)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with no vararg values.\");\n        }\n\n        return bindList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     */\n    public final This bindList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with an empty list.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            names.append(':').append(name);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean, getContext());\n\n            names.append(\"(\");\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(\",\");\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + \"_\" + valueIndex + \"_\" + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, getContext()));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        if (values.contains(null)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    PreparedStatement internalExecute()\n    {\n        rewritten = getConfig(SqlStatements.class)\n                .getStatementRewriter()\n                .rewrite(sql, getBinding(), getContext());\n        getContext().setRewrittenSql(rewritten.getSql());\n        try {\n            if (getClass().isAssignableFrom(Call.class)) {\n                stmt = handle.getStatementBuilder().createCall(handle.getConnection(), rewritten.getSql(), getContext());\n            }\n            else {\n                stmt = handle.getStatementBuilder().create(handle.getConnection(), rewritten.getSql(), getContext());\n            }\n        }\n        catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, getContext());\n        }\n\n        // The statement builder might (or might not) clean up the statement when called. E.g. the\n        // caching statement builder relies on the statement *not* being closed.\n        addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), sql, stmt));\n\n        getContext().setStatement(stmt);\n\n        try {\n            rewritten.bind(getBinding(), stmt);\n        }\n        catch (SQLException e) {\n            throw new UnableToExecuteStatementException(\"Unable to bind parameters to query\", e, getContext());\n        }\n\n        beforeExecution(stmt);\n\n        try {\n            final long start = System.nanoTime();\n            stmt.execute();\n            final long elapsedTime = System.nanoTime() - start;\n            LOG.trace(\"Execute SQL \\\"{}\\\" in {}ms\", rewritten.getSql(), elapsedTime / 1000000L);\n            getConfig(SqlStatements.class)\n                    .getTimingCollector()\n                    .collect(elapsedTime, getContext());\n        }\n        catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToExecuteStatementException(e, getContext());\n        }\n\n        afterExecution(stmt);\n\n        return stmt;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> rowMapperForType(Class<T> type)\n    {\n        return (RowMapper<T>) rowMapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> rowMapperForType(GenericType<T> type)\n    {\n        return (RowMapper<T>) rowMapperForType(type.getType());\n    }\n\n    RowMapper<?> rowMapperForType(Type type)\n    {\n        return getConfig(RowMappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport static java.util.stream.Collectors.joining;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.Arguments;\nimport org.jdbi.v3.core.argument.BeanPropertyArguments;\nimport org.jdbi.v3.core.argument.CharacterStreamArgument;\nimport org.jdbi.v3.core.argument.InputStreamArgument;\nimport org.jdbi.v3.core.argument.MapArguments;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.argument.NullArgument;\nimport org.jdbi.v3.core.argument.ObjectArgument;\nimport org.jdbi.v3.core.generic.GenericType;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMappers;\nimport org.jdbi.v3.core.rewriter.RewrittenStatement;\nimport org.jdbi.v3.core.transaction.TransactionState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SqlStatement<This extends SqlStatement<This>> extends BaseStatement<This> {\n    private static final Logger LOG = LoggerFactory.getLogger(SqlStatement.class);\n\n    private final Handle  handle;\n    private final String  sql;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private RewrittenStatement rewritten;\n    private PreparedStatement  stmt;\n\n    SqlStatement(Handle handle,\n                 String sql) {\n        super(handle);\n\n        this.handle = handle;\n        this.sql = sql;\n\n        getContext()\n            .setConnection(handle.getConnection())\n            .setRawSql(sql);\n    }\n\n    protected Binding getBinding()\n    {\n        return getContext().getBinding();\n    }\n\n    public This setFetchDirection(final int value)\n    {\n        addCustomizer(new StatementCustomizers.FetchDirectionStatementCustomizer(value));\n        return typedThis;\n    }\n\n    /**\n     * @return the un-translated SQL used to create this statement\n     */\n    protected String getSql()\n    {\n        return sql;\n    }\n\n    /**\n     * Set the query timeout, in seconds, on the prepared statement\n     *\n     * @param seconds number of seconds before timing out\n     *\n     * @return the same Query instance\n     */\n    public This setQueryTimeout(final int seconds)\n    {\n        return addCustomizer(new StatementCustomizers.QueryTimeoutCustomizer(seconds));\n    }\n\n    /**\n     * Close the handle when the statement is closed.\n     *\n     * @return the same Query instance\n     */\n    public This cleanupHandle()\n    {\n        return cleanupHandle(TransactionState.ROLLBACK);\n    }\n\n    /**\n     * Force transaction state when the statement is cleaned up.\n     *\n     * @param state the transaction state to enforce.\n     *\n     * @return the same Query instance\n     */\n    public This cleanupHandle(final TransactionState state)\n    {\n        addCleanable(() -> {\n            if (handle != null) {\n                if (handle.isInTransaction()) {\n                    if (state == TransactionState.COMMIT) {\n                        handle.commit();\n                    } else {\n                        handle.rollback();\n                    }\n                }\n                handle.close();\n            }\n        });\n        return typedThis;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public This bind(int position, Argument argument)\n    {\n        getBinding().addPositional(position, argument);\n        return (This) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    public This bind(String name, Argument argument)\n    {\n        getBinding().addNamed(name, argument);\n        return typedThis;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the argument.\n     *\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(null, bean));\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on the bean argument, with the given prefix.\n     *\n     * Example: the prefix {@code foo} applied to a bean property {@code bar} will be bound as {@code foo.bar}.\n     *\n     * @param prefix a prefix to apply to all property names.\n     * @param bean source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    public This bindBean(String prefix, Object bean)\n    {\n        return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean));\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param map map where keys are matched to named parameters in order to bind arguments.\n     *            Can be null, in which case the binding has no effect.\n     *\n     * @return modified statement\n     */\n    public This bindMap(Map<String, ?> map)\n    {\n        return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map));\n    }\n\n    /**\n     * Binds a new {@link NamedArgumentFinder}.\n     *\n     * @param namedArgumentFinder A NamedArgumentFinder to bind. Can be null.\n     *\n     * @return the same Query instance\n     */\n    public This bindNamedArgumentFinder(final NamedArgumentFinder namedArgumentFinder)\n    {\n        if (namedArgumentFinder != null) {\n            getBinding().addNamedArgumentFinder(namedArgumentFinder);\n        }\n\n        return typedThis;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Character value)\n    {\n        return bind(position, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Character value)\n    {\n        return bind(name, toArgument(Character.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, String value)\n    {\n        return bind(position, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, String value)\n    {\n        return bind(name, toArgument(String.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, int value)\n    {\n        return bind(position, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Integer value)\n    {\n        return bind(position, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, int value)\n    {\n        return bind(name, toArgument(int.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Integer value)\n    {\n        return bind(name, toArgument(Integer.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, char value)\n    {\n        return bind(position, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, char value)\n    {\n        return bind(name, toArgument(char.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindASCIIStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, BigDecimal value)\n    {\n        return bind(position, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, BigDecimal value)\n    {\n        return bind(name, toArgument(BigDecimal.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length the number of bytes in the stream.\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final This bindBinaryStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Blob value)\n    {\n        return bind(position, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Blob value)\n    {\n        return bind(name, toArgument(Blob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, boolean value)\n    {\n        return bind(position, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Boolean value)\n    {\n        return bind(position, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, boolean value)\n    {\n        return bind(name, toArgument(boolean.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Boolean value)\n    {\n        return bind(name, toArgument(Boolean.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte value)\n    {\n        return bind(position, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Byte value)\n    {\n        return bind(position, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte value)\n    {\n        return bind(name, toArgument(byte.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Byte value)\n    {\n        return bind(name, toArgument(Byte.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, byte[] value)\n    {\n        return bind(position, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, byte[] value)\n    {\n        return bind(name, toArgument(byte[].class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Reader value, int length)\n    {\n\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the parameter to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Reader value, int length)\n    {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Clob value)\n    {\n        return bind(position, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Clob value)\n    {\n        return bind(name, toArgument(Clob.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.sql.Date value)\n    {\n        return bind(position, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.sql.Date value)\n    {\n        return bind(name, toArgument(java.sql.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, java.util.Date value)\n    {\n        return bind(position, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, java.util.Date value)\n    {\n        return bind(name, toArgument(java.util.Date.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, double value)\n    {\n        return bind(position, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Double value)\n    {\n        return bind(position, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, double value)\n    {\n        return bind(name, toArgument(double.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Double value)\n    {\n        return bind(name, toArgument(Double.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, float value)\n    {\n        return bind(position, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Float value)\n    {\n        return bind(position, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, float value)\n    {\n        return bind(name, toArgument(float.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Float value)\n    {\n        return bind(name, toArgument(Float.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, long value)\n    {\n        return bind(position, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Long value)\n    {\n        return bind(position, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, long value)\n    {\n        return bind(name, toArgument(long.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Long value)\n    {\n        return bind(name, toArgument(Long.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Short value)\n    {\n        return bind(position, toArgument(Short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, short value)\n    {\n        return bind(position, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Short value)\n    {\n        return bind(name, toArgument(short.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Object value)\n    {\n        return bind(position, toArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Object value)\n    {\n        return bind(name, toArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Time value)\n    {\n        return bind(position, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Time value)\n    {\n        return bind(name, toArgument(Time.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, Timestamp value)\n    {\n        return bind(position, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, Timestamp value)\n    {\n        return bind(name, toArgument(Timestamp.class, value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the parameter at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(int position, URL value)\n    {\n        return bind(position, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final This bind(String name, URL value)\n    {\n        return bind(name, toArgument(URL.class, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, Type argumentType)\n    {\n        return bind(position, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param position     position to bind the parameter at, starting at 0\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(int position, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(position, value, argumentType.getType());\n    }\n\n    /**\n     * Bind an argument dynamically by the type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, Type argumentType)\n    {\n        return bind(name, toArgument(argumentType, value));\n    }\n\n    /**\n     * Bind an argument dynamically by the generic type passed in.\n     *\n     * @param name         token name to bind the parameter to\n     * @param value        to bind\n     * @param argumentType type token for value argument\n     *\n     * @return the same Query instance\n     */\n    public final This bindByType(String name, Object value, GenericType<?> argumentType)\n    {\n        return bindByType(name, value, argumentType.getType());\n    }\n\n    private Argument toArgument(Object value) {\n        return toArgument(value == null ? Object.class : value.getClass(), value);\n    }\n\n    private Argument toArgument(Type type, Object value) {\n        return getConfig(Arguments.class).findFor(type, value)\n                .orElseThrow(() -> new UnsupportedOperationException(\"No argument factory registered for '\" + value + \"' of type \" + type));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name    Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(String name, int sqlType)\n    {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType  The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     *\n     * @return the same statement instance\n     */\n    public final This bindNull(int position, int sqlType)\n    {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name    Named parameter to bind at\n     * @param value   Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(String name, Object value, int sqlType)\n    {\n        return bind(name, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value    Value to bind\n     * @param sqlType  The sqlType from java.sql.Types\n     *\n     * @return self\n     */\n    public final This bindBySqlType(int position, Object value, int sqlType)\n    {\n        return bind(position, new ObjectArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a parameter for each value in the given vararg array, and defines an attribute as the comma-separated list\n     * of parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", 1, 2, 3)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty.\n     */\n    public final This bindList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with no vararg values.\");\n        }\n\n        return bindList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Bind a parameter for each value in the given list, and defines an attribute as the comma-separated list of\n     * parameter references (using colon prefix).\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", values)\n     *     .execute();\n     *\n     * List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3);\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where id in (&lt;ids&gt;)\")\n     *     .bindList(\"ids\", ids)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty.\n     */\n    public final This bindList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindList was called with an empty list.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        for (int i = 0; i < values.size(); i++) {\n            String name = \"__\" + key + \"_\" + i;\n\n            if (i > 0) {\n                names.append(',');\n            }\n            names.append(':').append(name);\n\n            bind(name, values.get(i));\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Bind a parameter for each value in the given list * number of property names,\n     * and defines an attribute as the comma-separated list of parameter references (using colon prefix).\n     *\n     * Used to create query similar to:\n     * select * from things where (id, foo) in ((1,'abc'),(2,'def'),(3,'ghi'))\n     * <p>\n     * Examples:\n     * <pre>\n     *\n     * List&lt;ThingKey&gt; thingKeys = ...\n     * List&lt;Thing&gt; things = handle.createQuery(\"select * from things where (id, foo) in (&lt;thingKeys&gt;)\")\n     *     .bindBeanList(\"thingKeys\", thingKeys, Arrays.asList(\"id\", \"foo\"))\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @param propertyNames list of properties that will be invoked on the values.\n     * @return this\n     * @throws IllegalArgumentException if the list of values or properties is empty.\n     * @throws UnableToCreateStatementException If a property can't be found on an value or we can't find a Argument for it.\n     */\n    public final This bindBeanList(String key, List<?> values, List<String> propertyNames) throws UnableToCreateStatementException {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no values.\");\n        }\n\n        if (propertyNames.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".bindBeanList was called with no properties.\");\n        }\n\n        StringBuilder names = new StringBuilder();\n\n        StatementContext ctx = getContext();\n        for (int valueIndex = 0; valueIndex < values.size(); valueIndex++) {\n            if (valueIndex > 0) {\n                names.append(',');\n            }\n\n            Object bean = values.get(valueIndex);\n            BeanPropertyArguments beanProperties = new BeanPropertyArguments(null, bean);\n\n            names.append(\"(\");\n            for (int propertyIndex = 0; propertyIndex < propertyNames.size(); propertyIndex++) {\n                if (propertyIndex > 0) {\n                    names.append(\",\");\n                }\n                String propertyName = propertyNames.get(propertyIndex);\n                String name = \"__\" + key + \"_\" + valueIndex + \"_\" + propertyName;\n                names.append(':').append(name);\n                Argument argument = beanProperties.find(propertyName, ctx)\n                        .orElseThrow(() -> new UnableToCreateStatementException(\"Unable to get \" + propertyName + \" argument for \" + bean, ctx));\n                bind(name, argument);\n            }\n            names.append(\")\");\n        }\n\n        return define(key, names.toString());\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .bindList(\"values\", 1, \"Alice\", LocalDate.now())\n     *     .execute();\n     *\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", \"id\", \"name\", \"created_on\")\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values vararg values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the vararg array is empty, or contains any null elements.\n     */\n    public final This defineList(String key, Object... values) {\n        if (values.length == 0) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with no vararg values.\");\n        }\n        if (Stream.of(values).anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a vararg array containing null values.\");\n        }\n\n        return defineList(key, Arrays.asList(values));\n    }\n\n    /**\n     * Define an attribute as the comma-separated {@link String} from the elements of the {@code values} argument.\n     * <p>\n     * Examples:\n     * <pre>\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Object&gt; values = Arrays.asList(1, \"Alice\", LocalDate.now());\n     * handle.createUpdate(\"insert into things (&lt;columnNames&gt;) values (&lt;values&gt;)\")\n     *     .defineList(\"columnNames\", columnNames)\n     *     .bindList(\"values\", 1, values)\n     *     .execute();\n     *\n     * List&lt;String&gt; columnNames = Arrays.asList(\"id\", \"name\", \"created_on\");\n     * List&lt;Thing&gt; things = handle.createQuery(\"select &lt;columnNames&gt; from things\")\n     *     .bindList(\"columnNames\", columnNames)\n     *     .mapTo(Contact.class)\n     *     .list();\n     * <\/pre>\n     *\n     * @param key    attribute name\n     * @param values list of values that will be comma-spliced into the defined attribute value.\n     * @return this\n     * @throws IllegalArgumentException if the list is empty, or contains any null elements.\n     */\n    public final This defineList(String key, List<?> values) {\n        if (values.isEmpty()) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with an empty list.\");\n        }\n        if (values.contains(null)) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \".defineList was called with a list containing null values.\");\n        }\n\n        String value = values.stream()\n                .map(Object::toString)\n                .collect(joining(\", \"));\n\n        return define(key, value);\n    }\n\n    PreparedStatement internalExecute()\n    {\n        rewritten = getConfig(SqlStatements.class)\n                .getStatementRewriter()\n                .rewrite(sql, getBinding(), getContext());\n        getContext().setRewrittenSql(rewritten.getSql());\n        try {\n            if (getClass().isAssignableFrom(Call.class)) {\n                stmt = handle.getStatementBuilder().createCall(handle.getConnection(), rewritten.getSql(), getContext());\n            }\n            else {\n                stmt = handle.getStatementBuilder().create(handle.getConnection(), rewritten.getSql(), getContext());\n            }\n        }\n        catch (SQLException e) {\n            throw new UnableToCreateStatementException(e, getContext());\n        }\n\n        // The statement builder might (or might not) clean up the statement when called. E.g. the\n        // caching statement builder relies on the statement *not* being closed.\n        addCleanable(() -> handle.getStatementBuilder().close(handle.getConnection(), sql, stmt));\n\n        getContext().setStatement(stmt);\n\n        try {\n            rewritten.bind(getBinding(), stmt);\n        }\n        catch (SQLException e) {\n            throw new UnableToExecuteStatementException(\"Unable to bind parameters to query\", e, getContext());\n        }\n\n        beforeExecution(stmt);\n\n        try {\n            final long start = System.nanoTime();\n            stmt.execute();\n            final long elapsedTime = System.nanoTime() - start;\n            LOG.trace(\"Execute SQL \\\"{}\\\" in {}ms\", rewritten.getSql(), elapsedTime / 1000000L);\n            getConfig(SqlStatements.class)\n                    .getTimingCollector()\n                    .collect(elapsedTime, getContext());\n        }\n        catch (SQLException e) {\n            try {\n                stmt.close();\n            } catch (SQLException e1) {\n                e.addSuppressed(e1);\n            }\n            throw new UnableToExecuteStatementException(e, getContext());\n        }\n\n        afterExecution(stmt);\n\n        return stmt;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> rowMapperForType(Class<T> type)\n    {\n        return (RowMapper<T>) rowMapperForType((Type) type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> RowMapper<T> rowMapperForType(GenericType<T> type)\n    {\n        return (RowMapper<T>) rowMapperForType(type.getType());\n    }\n\n    RowMapper<?> rowMapperForType(Type type)\n    {\n        return getConfig(RowMappers.class).findFor(type)\n            .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n    }\n}\n","lineNo":1255}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.rewriter;\n\nimport static org.jdbi.v3.core.rewriter.ParsedStatement.POSITIONAL_PARAM;\n\nimport com.google.common.base.Joiner;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.List;\nimport org.jdbi.v3.core.statement.Binding;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\n\nclass InternalRewrittenStatement implements RewrittenStatement {\n    private final ParsedStatement stmt;\n    private final StatementContext context;\n\n    InternalRewrittenStatement(ParsedStatement stmt, StatementContext ctx) {\n        this.context = ctx;\n        this.stmt = stmt;\n    }\n\n    @Override\n    public void bind(Binding params, PreparedStatement statement) throws SQLException {\n        if (stmt.isPositional()) {\n            bindPositional(params, statement);\n        } else {\n            bindNamed(params, statement);\n        }\n    }\n\n    private void bindPositional(Binding params, PreparedStatement statement) {\n        for (int i = 0; i < stmt.getParams().size(); i++) {\n            int index = i;\n            try {\n                params.findForPosition(i)\n                        .orElseThrow(() -> new UnableToExecuteStatementException(\n                                \"Unable to execute, no positional parameter bound at position \" + index,\n                                context))\n                        .apply(i + 1, statement, context);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\n                        \"Exception while binding positional param at (0 based) position \" + i, e, context);\n            }\n        }\n    }\n\n    private void bindNamed(Binding params, PreparedStatement statement) {\n        List<String> paramList = stmt.getParams();\n\n        if (paramList.contains(POSITIONAL_PARAM)) {\n            throw new UnableToExecuteStatementException(\n                    \"Cannot mix named and positional parameters in a SQL statement: \" + Joiner.on(\", \").join(paramList),\n                    context);\n        }\n\n        for (int i = 0; i < paramList.size(); i++) {\n            String param = paramList.get(i);\n\n            try {\n                params.findForName(param)\n                        .orElseThrow(() -> new UnableToExecuteStatementException(\n                                String.format(\"Unable to execute, no named parameter matches '%s'.\", param),\n                                context))\n                        .apply(i + 1, statement, context);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(\n                        String.format(\"Exception while binding named parameter '%s'\", param), e, context);\n            }\n        }\n    }\n\n    @Override\n    public String getSql() {\n        return stmt.getParsedSql();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.rewriter;\n\nimport static org.jdbi.v3.core.rewriter.ParsedStatement.POSITIONAL_PARAM;\n\nimport com.google.common.base.Joiner;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.Optional;\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.statement.Binding;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\n\nclass InternalRewrittenStatement implements RewrittenStatement {\n    private final ParsedStatement stmt;\n    private final StatementContext context;\n\n    InternalRewrittenStatement(ParsedStatement stmt, StatementContext ctx) {\n        this.context = ctx;\n        this.stmt = stmt;\n    }\n\n    @Override\n    public void bind(Binding params, PreparedStatement statement) throws SQLException {\n        if (stmt.isPositional()) {\n            bindPositional(params, statement);\n        } else {\n            bindNamed(params, statement);\n        }\n    }\n\n    private void bindPositional(Binding params, PreparedStatement statement) {\n        for (int i = 0; i < stmt.getParams().size(); i++) {\n            try {\n                Optional<Argument> argument = params.findForPosition(i);\n                if (argument.isPresent()) {\n                    argument.get().apply(i + 1, statement, context);\n                }\n                // any missing positional parameters could be return parameters\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\n                        \"Exception while binding positional param at (0 based) position \" + i, e, context);\n            }\n        }\n    }\n\n    private void bindNamed(Binding params, PreparedStatement statement) {\n        List<String> paramList = stmt.getParams();\n\n        if (paramList.contains(POSITIONAL_PARAM)) {\n            throw new UnableToExecuteStatementException(\n                    \"Cannot mix named and positional parameters in a SQL statement: \" + Joiner.on(\", \").join(paramList),\n                    context);\n        }\n\n        for (int i = 0; i < paramList.size(); i++) {\n            String param = paramList.get(i);\n\n            try {\n                params.findForName(param)\n                        .orElseThrow(() -> new UnableToExecuteStatementException(\n                                String.format(\"Unable to execute, no named parameter matches '%s'.\", param),\n                                context))\n                        .apply(i + 1, statement, context);\n            } catch (SQLException e) {\n                throw new UnableToCreateStatementException(\n                        String.format(\"Exception while binding named parameter '%s'\", param), e, context);\n            }\n        }\n    }\n\n    @Override\n    public String getSql() {\n        return stmt.getParsedSql();\n    }\n}\n","lineNo":50}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.JdbiConstructors.findConstructorFor;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the fields in a result set into a constructor. The default implementation will perform a\n * case insensitive mapping between the constructor parameter names and the column labels,\n * also considering camel-case to underscores conversion.\n *\n * Currently the constructor must have exactly the same number of columns as the result set, and\n * the mapping must be one-to-one.  These restrictions may be reconsidered at a later time.\n */\npublic class ConstructorMapper<T> implements RowMapper<T>\n{\n    /**\n     * Use the only declared constructor to map a class.\n     */\n    public static RowMapperFactory of(Class<?> clazz) {\n        return of(clazz, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Use the only declared constructor to map a class.\n     */\n    public static RowMapperFactory of(Class<?> clazz, String prefix) {\n        return of(findConstructorFor(clazz), prefix);\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     */\n    public static RowMapperFactory of(Constructor<?> constructor) {\n        return of(constructor, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     */\n    public static RowMapperFactory of(Constructor<?> constructor, String prefix) {\n        final Class<?> type = constructor.getDeclaringClass();\n        final RowMapper<?> mapper = new ConstructorMapper<>(constructor, prefix);\n        return RowMapperFactory.of(type, mapper);\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Constructor<T> constructor;\n    private final String prefix;\n\n    private ConstructorMapper(Constructor<T> constructor,\n                              String prefix)\n    {\n        this.constructor = constructor;\n        this.prefix = prefix;\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final ResultSetMetaData metadata = rs.getMetaData();\n        final List<String> columnNames = new ArrayList<>(metadata.getColumnCount());\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            columnNames.add(metadata.getColumnLabel(i));\n        }\n\n        final int columns = constructor.getParameterCount();\n\n        if (columns > columnNames.size()) {\n            throw new IllegalStateException(columnNames.size() +\n                    \" columns in result set, but constructor takes \" +\n                    constructor.getParameterCount());\n        }\n\n        List<ColumnNameMatcher> columnNameMatchers = ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n\n        final int[] columnMap = new int[columns];\n        final ColumnMapper<?>[] mappers = new ColumnMapper<?>[columns];\n\n        for (int i = 0; i < columns; i++) {\n            final Type type = constructor.getGenericParameterTypes()[i];\n            final String paramName = paramName(constructor.getParameters()[i]);\n            final int columnIndex = columnIndexForParameter(columnNames, paramName, columnNameMatchers);\n\n            mappers[i] = ctx.findColumnMapperFor(type)\n                    .orElseThrow(() -> new IllegalArgumentException(String.format(\n                            \"Could not find column mapper for type '%s' of parameter '%s' for constructor '%s'\",\n                            type, paramName, constructor)));\n            columnMap[i] = columnIndex;\n        }\n\n        return (r, c) -> {\n            final Object[] params = new Object[columns];\n            for (int i = 0; i < columns; i++) {\n                params[i] = mappers[i].map(r, columnMap[i] + 1, c);\n            }\n            try {\n                return constructor.newInstance(params);\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                if (e.getCause() instanceof RuntimeException) {\n                    throw (RuntimeException) e.getCause();\n                }\n                if (e.getCause() instanceof Error) {\n                    throw (Error) e.getCause();\n                }\n                throw new RuntimeException(e);\n            }\n        };\n    }\n\n    private int columnIndexForParameter(List<String> columnNames,\n                                        String parameterName,\n                                        List<ColumnNameMatcher> columnNameMatchers)\n    {\n        int result = -1;\n        for (int i = 0; i < columnNames.size(); i++) {\n            String columnName = columnNames.get(i);\n            if (prefix.length() > 0) {\n                if (columnName.length() > prefix.length() &&\n                        columnName.regionMatches(true, 0, prefix, 0, prefix.length())) {\n                    columnName = columnName.substring(prefix.length());\n                }\n                else {\n                    continue;\n                }\n            }\n\n            for (ColumnNameMatcher strategy : columnNameMatchers) {\n                if (strategy.columnNameMatches(columnName, parameterName)) {\n                    if (result >= 0) {\n                        throw new IllegalArgumentException(String.format(\n                                \"Constructor '%s' parameter '%s' matches multiple \" +\n                                \"columns: '%s' (%d) and '%s' (%d)\", constructor,\n                                parameterName, columnNames.get(result), result,\n                                columnNames.get(i), i));\n                    }\n                    result = i;\n                    break;\n                }\n            }\n        }\n        if (result >= 0) {\n            return result;\n        }\n        throw new IllegalArgumentException(\"Constructor '\" + constructor + \"' parameter '\" +\n                parameterName +\n                \"' has no column in the result set.  Verify that the Java \" +\n                \"compiler is configured to emit parameter names, \" +\n                \"that your result set has the columns expected, \" +\n                \"or annotate the parameter names explicitly with @ColumnName\");\n    }\n\n    private static String paramName(Parameter parameter) {\n        ColumnName dbName = parameter.getAnnotation(ColumnName.class);\n        if (dbName != null) {\n            return dbName.value();\n        }\n        return parameter.getName();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper.reflect;\n\nimport static org.jdbi.v3.core.mapper.reflect.JdbiConstructors.findConstructorFor;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * A row mapper which maps the fields in a result set into a constructor. The default implementation will perform a\n * case insensitive mapping between the constructor parameter names and the column labels,\n * also considering camel-case to underscores conversion.\n * <p>\n * Currently the constructor must have exactly the same number of columns as the result set, and\n * the mapping must be one-to-one.  These restrictions may be reconsidered at a later time.\n */\npublic class ConstructorMapper<T> implements RowMapper<T>\n{\n    /**\n     * Use the only declared constructor to map a class.\n     */\n    public static RowMapperFactory of(Class<?> clazz) {\n        return RowMapperFactory.of(clazz, new ConstructorMapper<>(clazz));\n    }\n\n    /**\n     * Use the only declared constructor to map a class.\n     */\n    public static RowMapperFactory of(Class<?> clazz, String prefix) {\n        return RowMapperFactory.of(clazz, new ConstructorMapper<>(clazz, prefix));\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     */\n    public static RowMapperFactory of(Constructor<?> constructor) {\n        final Class<?> type = constructor.getDeclaringClass();\n        return RowMapperFactory.of(type, new ConstructorMapper<>(constructor));\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     */\n    public static RowMapperFactory of(Constructor<?> constructor, String prefix) {\n        final Class<?> type = constructor.getDeclaringClass();\n        return RowMapperFactory.of(type, new ConstructorMapper<>(constructor, prefix));\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Constructor<T> constructor;\n    private final String prefix;\n\n    /**\n     * Instantiate a ConstructorMapper for the given type.\n     *\n     * @param type the mapped type\n     */\n    public ConstructorMapper(Class<T> type) {\n        this(findConstructorFor(type), DEFAULT_PREFIX);\n    }\n\n    /**\n     * Instantiate a ConstructorMapper for the given type and prefix\n     *\n     * @param type   the mapped type\n     * @param prefix the column name prefix\n     */\n    public ConstructorMapper(Class<T> type, String prefix) {\n        this(findConstructorFor(type), prefix);\n    }\n\n    /**\n     * Instantiate a ConstructorMapper using the given constructor\n     *\n     * @param constructor the constructor to be used in mapping\n     */\n    public ConstructorMapper(Constructor<T> constructor) {\n        this(constructor, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Instantiate a ConstructorMapper using the given constructor and prefix\n     *\n     * @param constructor the constructor to be used in mapping\n     * @param prefix      the column name prefix\n     */\n    public ConstructorMapper(Constructor<T> constructor, String prefix) {\n        this.constructor = constructor;\n        this.prefix = prefix;\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx) throws SQLException {\n        return specialize(rs, ctx).map(rs, ctx);\n    }\n\n    @Override\n    public RowMapper<T> specialize(ResultSet rs, StatementContext ctx) throws SQLException {\n        final ResultSetMetaData metadata = rs.getMetaData();\n        final List<String> columnNames = new ArrayList<>(metadata.getColumnCount());\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            columnNames.add(metadata.getColumnLabel(i));\n        }\n\n        final int columns = constructor.getParameterCount();\n\n        if (columns > columnNames.size()) {\n            throw new IllegalStateException(columnNames.size() +\n                    \" columns in result set, but constructor takes \" +\n                    constructor.getParameterCount());\n        }\n\n        List<ColumnNameMatcher> columnNameMatchers = ctx.getConfig(ReflectionMappers.class).getColumnNameMatchers();\n\n        final int[] columnMap = new int[columns];\n        final ColumnMapper<?>[] mappers = new ColumnMapper<?>[columns];\n\n        for (int i = 0; i < columns; i++) {\n            final Type type = constructor.getGenericParameterTypes()[i];\n            final String paramName = paramName(constructor.getParameters()[i]);\n            final int columnIndex = columnIndexForParameter(columnNames, paramName, columnNameMatchers);\n\n            mappers[i] = ctx.findColumnMapperFor(type)\n                    .orElseThrow(() -> new IllegalArgumentException(String.format(\n                            \"Could not find column mapper for type '%s' of parameter '%s' for constructor '%s'\",\n                            type, paramName, constructor)));\n            columnMap[i] = columnIndex;\n        }\n\n        return (r, c) -> {\n            final Object[] params = new Object[columns];\n            for (int i = 0; i < columns; i++) {\n                params[i] = mappers[i].map(r, columnMap[i] + 1, c);\n            }\n            try {\n                return constructor.newInstance(params);\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                if (e.getCause() instanceof RuntimeException) {\n                    throw (RuntimeException) e.getCause();\n                }\n                if (e.getCause() instanceof Error) {\n                    throw (Error) e.getCause();\n                }\n                throw new RuntimeException(e);\n            }\n        };\n    }\n\n    private int columnIndexForParameter(List<String> columnNames,\n                                        String parameterName,\n                                        List<ColumnNameMatcher> columnNameMatchers)\n    {\n        int result = -1;\n        for (int i = 0; i < columnNames.size(); i++) {\n            String columnName = columnNames.get(i);\n            if (prefix.length() > 0) {\n                if (columnName.length() > prefix.length() &&\n                        columnName.regionMatches(true, 0, prefix, 0, prefix.length())) {\n                    columnName = columnName.substring(prefix.length());\n                }\n                else {\n                    continue;\n                }\n            }\n\n            for (ColumnNameMatcher strategy : columnNameMatchers) {\n                if (strategy.columnNameMatches(columnName, parameterName)) {\n                    if (result >= 0) {\n                        throw new IllegalArgumentException(String.format(\n                                \"Constructor '%s' parameter '%s' matches multiple \" +\n                                \"columns: '%s' (%d) and '%s' (%d)\", constructor,\n                                parameterName, columnNames.get(result), result,\n                                columnNames.get(i), i));\n                    }\n                    result = i;\n                    break;\n                }\n            }\n        }\n        if (result >= 0) {\n            return result;\n        }\n        throw new IllegalArgumentException(\"Constructor '\" + constructor + \"' parameter '\" +\n                parameterName +\n                \"' has no column in the result set.  Verify that the Java \" +\n                \"compiler is configured to emit parameter names, \" +\n                \"that your result set has the columns expected, \" +\n                \"or annotate the parameter names explicitly with @ColumnName\");\n    }\n\n    private static String paramName(Parameter parameter) {\n        ColumnName dbName = parameter.getAnnotation(ColumnName.class);\n        if (dbName != null) {\n            return dbName.value();\n        }\n        return parameter.getName();\n    }\n}\n","lineNo":61}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.guava;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.findGenericParameter;\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\nimport java.lang.reflect.Type;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.stream.Collector;\n\nimport org.jdbi.v3.core.collector.CollectorFactory;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSortedSet;\n\n/**\n * Provide Collector instances that create Guava collection types, especially immutable\n * versions of the base Java collections.\n */\npublic class GuavaCollectors {\n\n    /**\n     * @return a {@code CollectorFactory} which knows how to create all supported Guava types\n     */\n    public static CollectorFactory factory() {\n        return new Factory();\n    }\n\n    /**\n     * @param <T> the element type collected.\n     *\n     * @return a collector into Guava's {@code Optional<T>}\n     */\n    public static <T> Collector<T, ?, Optional<T>> toOptional() {\n        return Collector.<T, GuavaOptionalBuilder<T>, Optional<T>>of(\n                GuavaOptionalBuilder::new,\n                GuavaOptionalBuilder::set,\n                (left, right) -> left.build().isPresent() ? left : right,\n                GuavaOptionalBuilder::build);\n    }\n\n    private static class GuavaOptionalBuilder<T> {\n\n        private Optional<T> optional = Optional.absent();\n\n        public void set(T value) {\n            if (optional.isPresent()) {\n                throw new IllegalStateException(\n                        String.format(\"Multiple values for Optional type: ['%s','%s',...]\",\n                                optional.get(),\n                                value));\n            }\n            optional = Optional.of(value);\n        }\n\n        public Optional<T> build() {\n            return optional;\n        }\n    }\n\n    public static class Factory implements CollectorFactory {\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> collectors =\n            ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                .put(ImmutableList.class, ImmutableList.toImmutableList())\n                .put(ImmutableSet.class, ImmutableSet.toImmutableSet())\n                .put(ImmutableSortedSet.class, ImmutableSortedSet.toImmutableSortedSet(Comparator.naturalOrder()))\n                .put(Optional.class, toOptional())\n                .build();\n\n        @Override\n        public boolean accepts(Type containerType) {\n            return collectors.containsKey(getErasedType(containerType));\n        }\n\n        @Override\n        public java.util.Optional<Type> elementType(Type containerType) {\n            return findGenericParameter(containerType, getErasedType(containerType));\n        }\n\n        @Override\n        public Collector<?, ?, ?> build(Type containerType) {\n            return collectors.get(getErasedType(containerType));\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.guava;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.BiMap;\nimport com.google.common.collect.HashBiMap;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.LinkedListMultimap;\nimport com.google.common.collect.ListMultimap;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.collect.TreeMultimap;\nimport com.google.common.reflect.TypeParameter;\nimport com.google.common.reflect.TypeToken;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.stream.Collector;\nimport org.jdbi.v3.core.collector.CollectorFactory;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.findGenericParameter;\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\n/**\n * Provides Collectors for Guava collection types.\n * <p>Supported Collection types:<\/p>\n * <ul>\n *     <li>com.google.common.base.Optional&lt;T&gt; (throws an exception if more than one row in result)<\/li>\n *     <li>com.google.common.collect.ImmutableList&lt;T&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableSet&lt;T&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableSortedSet&lt;T extends Comparable&gt;<\/li>\n * <\/ul>\n * <p>Supported Maps and Multimaps types - for row type Map.Entry&lt;K, V&gt;:<\/p>\n * <ul>\n *     <li>com.google.common.collect.ArrayListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.BiMap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.HashMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableMap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.LinkedListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.Multimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.SetMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.TreeMultimap&lt;K, V&gt;<\/li>\n * <\/ul>\n */\npublic class GuavaCollectors {\n    private static final TypeVariable<Class<Map>> MAP_KEY;\n    private static final TypeVariable<Class<Map>> MAP_VALUE;\n    private static final TypeVariable<Class<Multimap>> MULTIMAP_KEY;\n    private static final TypeVariable<Class<Multimap>> MULTIMAP_VALUE;\n\n    static {\n        TypeVariable<Class<Map>>[] mapParams = Map.class.getTypeParameters();\n        MAP_KEY = mapParams[0];\n        MAP_VALUE = mapParams[1];\n\n        TypeVariable<Class<Multimap>>[] multimapParams = Multimap.class.getTypeParameters();\n        MULTIMAP_KEY = multimapParams[0];\n        MULTIMAP_VALUE = multimapParams[1];\n    }\n\n    /**\n     * @return a {@code CollectorFactory} which knows how to create all supported Guava types\n     */\n    public static CollectorFactory factory() {\n        return new Factory();\n    }\n\n    /**\n     * @param <T> the element type collected.\n     * @return a collector into Guava's {@code Optional<T>}\n     */\n    public static <T> Collector<T, ?, Optional<T>> toOptional() {\n        return Collector.<T, GuavaOptionalBuilder<T>, Optional<T>>of(\n                GuavaOptionalBuilder::new,\n                GuavaOptionalBuilder::set,\n                (left, right) -> left.build().isPresent() ? left : right,\n                GuavaOptionalBuilder::build);\n    }\n\n    private static class GuavaOptionalBuilder<T> {\n\n        private Optional<T> optional = Optional.absent();\n\n        public void set(T value) {\n            if (optional.isPresent()) {\n                throw new IllegalStateException(\n                        String.format(\"Multiple values for Optional type: ['%s','%s',...]\",\n                                optional.get(),\n                                value));\n            }\n            optional = Optional.of(value);\n        }\n\n        public Optional<T> build() {\n            return optional;\n        }\n    }\n\n    public static class Factory implements CollectorFactory {\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> collectors =\n                ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                        .put(ImmutableList.class, ImmutableList.toImmutableList())\n                        .put(ImmutableSet.class, ImmutableSet.toImmutableSet())\n                        .put(ImmutableSortedSet.class, ImmutableSortedSet.toImmutableSortedSet(Comparator.naturalOrder()))\n                        .put(Optional.class, toOptional())\n                        .build();\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> mapCollectors =\n                ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                        .put(ImmutableMap.class, toImmutableMap())\n                        .put(BiMap.class, toHashBiMap())\n                        .build();\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> multimapCollectors =\n                ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                        .put(ImmutableMultimap.class, toImmutableListMultimap())\n                        .put(ImmutableListMultimap.class, toImmutableListMultimap())\n                        .put(ImmutableSetMultimap.class, toImmutableSetMultimap())\n                        .put(Multimap.class, toImmutableListMultimap())\n                        .put(ListMultimap.class, toImmutableListMultimap())\n                        .put(ArrayListMultimap.class, toArrayListMultimap())\n                        .put(LinkedListMultimap.class, toLinkedListMultimap())\n                        .put(SetMultimap.class, toImmutableSetMultimap())\n                        .put(HashMultimap.class, toHashMultimap())\n                        .put(TreeMultimap.class, toTreeMultimap())\n                        .build();\n\n        @Override\n        public boolean accepts(Type containerType) {\n            Class<?> erasedType = getErasedType(containerType);\n            return collectors.containsKey(erasedType)\n                    || mapCollectors.containsKey(erasedType)\n                    || multimapCollectors.containsKey(erasedType);\n        }\n\n        @Override\n        public java.util.Optional<Type> elementType(Type containerType) {\n            Class<?> erasedType = getErasedType(containerType);\n\n            if (collectors.containsKey(erasedType)) {\n                return findGenericParameter(containerType, erasedType);\n            } else if (mapCollectors.containsKey(erasedType)) {\n                TypeToken<?> keyType = TypeToken.of(containerType).resolveType(MAP_KEY);\n                TypeToken<?> valueType = TypeToken.of(containerType).resolveType(MAP_VALUE);\n                return java.util.Optional.of(entryType(keyType, valueType));\n            } else if (multimapCollectors.containsKey(erasedType)) {\n                TypeToken<?> keyType = TypeToken.of(containerType).resolveType(MULTIMAP_KEY);\n                TypeToken<?> valueType = TypeToken.of(containerType).resolveType(MULTIMAP_VALUE);\n                return java.util.Optional.of(entryType(keyType, valueType));\n            }\n\n            return java.util.Optional.empty();\n        }\n\n        private <K, V> Type entryType(TypeToken<K> keyType, TypeToken<V> valueType) {\n            return new TypeToken<Map.Entry<K, V>>() {}\n                    .where(new TypeParameter<K>() {}, keyType)\n                    .where(new TypeParameter<V>() {}, valueType)\n                    .getType();\n        }\n\n        @Override\n        public Collector<?, ?, ?> build(Type containerType) {\n            Class<?> erasedType = getErasedType(containerType);\n            if (collectors.containsKey(erasedType)) {\n                return collectors.get(erasedType);\n            }\n            if (mapCollectors.containsKey(erasedType)) {\n                return mapCollectors.get(erasedType);\n            }\n            return multimapCollectors.get(erasedType);\n        }\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ImmutableMap<K, V>> toImmutableMap() {\n        return ImmutableMap.toImmutableMap(Map.Entry::getKey, Map.Entry::getValue);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, BiMap<K, V>> toHashBiMap() {\n        return Collector.of(\n                HashBiMap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ImmutableListMultimap<K, V>> toImmutableListMultimap() {\n        return Collector.of(\n                (Supplier<ImmutableListMultimap.Builder<K, V>>) ImmutableListMultimap::builder,\n                ImmutableListMultimap.Builder::put,\n                GuavaCollectors::combine,\n                ImmutableListMultimap.Builder::build);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ImmutableSetMultimap<K, V>> toImmutableSetMultimap() {\n        return Collector.of(\n                (Supplier<ImmutableSetMultimap.Builder<K, V>>) ImmutableSetMultimap::builder,\n                ImmutableSetMultimap.Builder::put,\n                GuavaCollectors::combine,\n                ImmutableSetMultimap.Builder::build);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ArrayListMultimap<K, V>> toArrayListMultimap() {\n        return Collector.of(\n                ArrayListMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, LinkedListMultimap<K, V>> toLinkedListMultimap() {\n        return Collector.of(\n                LinkedListMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, HashMultimap<K, V>> toHashMultimap() {\n        return Collector.of(\n                HashMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K extends Comparable, V extends Comparable> Collector<Map.Entry<K, V>, ?, TreeMultimap<K, V>> toTreeMultimap() {\n        return Collector.of(\n                TreeMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    private static <K, V, M extends Map<K, V>> void putEntry(M map, Map.Entry<K, V> entry) {\n        // FIXME throw exception on duplicate entry?\n        map.put(entry.getKey(), entry.getValue());\n    }\n\n    private static <K, V, M extends Multimap<K, V>> void putEntry(M map, Map.Entry<K, V> entry) {\n        map.put(entry.getKey(), entry.getValue());\n    }\n\n    private static <K, V, M extends Map<K, V>> M combine(M a, M b) {\n        // FIXME throw exception on duplicate entries?\n        a.putAll(b);\n        return a;\n    }\n\n    private static <K, V, MB extends ImmutableMultimap.Builder<K, V>> MB combine(MB a, MB b) {\n        a.putAll(b.build());\n        return a;\n    }\n\n    private static <K, V, M extends Multimap<K, V>> M combine(M a, M b) {\n        // FIXME throw exception on duplicate entries? e.g. SetMultimap.put() would return false\n        a.putAll(b);\n        return a;\n    }\n}\n","lineNo":157}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.guava;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.findGenericParameter;\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\nimport java.lang.reflect.Type;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.stream.Collector;\n\nimport org.jdbi.v3.core.collector.CollectorFactory;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSortedSet;\n\n/**\n * Provide Collector instances that create Guava collection types, especially immutable\n * versions of the base Java collections.\n */\npublic class GuavaCollectors {\n\n    /**\n     * @return a {@code CollectorFactory} which knows how to create all supported Guava types\n     */\n    public static CollectorFactory factory() {\n        return new Factory();\n    }\n\n    /**\n     * @param <T> the element type collected.\n     *\n     * @return a collector into Guava's {@code Optional<T>}\n     */\n    public static <T> Collector<T, ?, Optional<T>> toOptional() {\n        return Collector.<T, GuavaOptionalBuilder<T>, Optional<T>>of(\n                GuavaOptionalBuilder::new,\n                GuavaOptionalBuilder::set,\n                (left, right) -> left.build().isPresent() ? left : right,\n                GuavaOptionalBuilder::build);\n    }\n\n    private static class GuavaOptionalBuilder<T> {\n\n        private Optional<T> optional = Optional.absent();\n\n        public void set(T value) {\n            if (optional.isPresent()) {\n                throw new IllegalStateException(\n                        String.format(\"Multiple values for Optional type: ['%s','%s',...]\",\n                                optional.get(),\n                                value));\n            }\n            optional = Optional.of(value);\n        }\n\n        public Optional<T> build() {\n            return optional;\n        }\n    }\n\n    public static class Factory implements CollectorFactory {\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> collectors =\n            ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                .put(ImmutableList.class, ImmutableList.toImmutableList())\n                .put(ImmutableSet.class, ImmutableSet.toImmutableSet())\n                .put(ImmutableSortedSet.class, ImmutableSortedSet.toImmutableSortedSet(Comparator.naturalOrder()))\n                .put(Optional.class, toOptional())\n                .build();\n\n        @Override\n        public boolean accepts(Type containerType) {\n            return collectors.containsKey(getErasedType(containerType));\n        }\n\n        @Override\n        public java.util.Optional<Type> elementType(Type containerType) {\n            return findGenericParameter(containerType, getErasedType(containerType));\n        }\n\n        @Override\n        public Collector<?, ?, ?> build(Type containerType) {\n            return collectors.get(getErasedType(containerType));\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.guava;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.BiMap;\nimport com.google.common.collect.HashBiMap;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.LinkedListMultimap;\nimport com.google.common.collect.ListMultimap;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.collect.TreeMultimap;\nimport com.google.common.reflect.TypeParameter;\nimport com.google.common.reflect.TypeToken;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.stream.Collector;\nimport org.jdbi.v3.core.collector.CollectorFactory;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.findGenericParameter;\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\n/**\n * Provides Collectors for Guava collection types.\n * <p>Supported Collection types:<\/p>\n * <ul>\n *     <li>com.google.common.base.Optional&lt;T&gt; (throws an exception if more than one row in result)<\/li>\n *     <li>com.google.common.collect.ImmutableList&lt;T&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableSet&lt;T&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableSortedSet&lt;T extends Comparable&gt;<\/li>\n * <\/ul>\n * <p>Supported Maps and Multimaps types - for row type Map.Entry&lt;K, V&gt;:<\/p>\n * <ul>\n *     <li>com.google.common.collect.ArrayListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.BiMap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.HashMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableMap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.LinkedListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.Multimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.SetMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.TreeMultimap&lt;K, V&gt;<\/li>\n * <\/ul>\n */\npublic class GuavaCollectors {\n    private static final TypeVariable<Class<Map>> MAP_KEY;\n    private static final TypeVariable<Class<Map>> MAP_VALUE;\n    private static final TypeVariable<Class<Multimap>> MULTIMAP_KEY;\n    private static final TypeVariable<Class<Multimap>> MULTIMAP_VALUE;\n\n    static {\n        TypeVariable<Class<Map>>[] mapParams = Map.class.getTypeParameters();\n        MAP_KEY = mapParams[0];\n        MAP_VALUE = mapParams[1];\n\n        TypeVariable<Class<Multimap>>[] multimapParams = Multimap.class.getTypeParameters();\n        MULTIMAP_KEY = multimapParams[0];\n        MULTIMAP_VALUE = multimapParams[1];\n    }\n\n    /**\n     * @return a {@code CollectorFactory} which knows how to create all supported Guava types\n     */\n    public static CollectorFactory factory() {\n        return new Factory();\n    }\n\n    /**\n     * @param <T> the element type collected.\n     * @return a collector into Guava's {@code Optional<T>}\n     */\n    public static <T> Collector<T, ?, Optional<T>> toOptional() {\n        return Collector.<T, GuavaOptionalBuilder<T>, Optional<T>>of(\n                GuavaOptionalBuilder::new,\n                GuavaOptionalBuilder::set,\n                (left, right) -> left.build().isPresent() ? left : right,\n                GuavaOptionalBuilder::build);\n    }\n\n    private static class GuavaOptionalBuilder<T> {\n\n        private Optional<T> optional = Optional.absent();\n\n        public void set(T value) {\n            if (optional.isPresent()) {\n                throw new IllegalStateException(\n                        String.format(\"Multiple values for Optional type: ['%s','%s',...]\",\n                                optional.get(),\n                                value));\n            }\n            optional = Optional.of(value);\n        }\n\n        public Optional<T> build() {\n            return optional;\n        }\n    }\n\n    public static class Factory implements CollectorFactory {\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> collectors =\n                ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                        .put(ImmutableList.class, ImmutableList.toImmutableList())\n                        .put(ImmutableSet.class, ImmutableSet.toImmutableSet())\n                        .put(ImmutableSortedSet.class, ImmutableSortedSet.toImmutableSortedSet(Comparator.naturalOrder()))\n                        .put(Optional.class, toOptional())\n                        .build();\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> mapCollectors =\n                ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                        .put(ImmutableMap.class, toImmutableMap())\n                        .put(BiMap.class, toHashBiMap())\n                        .build();\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> multimapCollectors =\n                ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                        .put(ImmutableMultimap.class, toImmutableListMultimap())\n                        .put(ImmutableListMultimap.class, toImmutableListMultimap())\n                        .put(ImmutableSetMultimap.class, toImmutableSetMultimap())\n                        .put(Multimap.class, toImmutableListMultimap())\n                        .put(ListMultimap.class, toImmutableListMultimap())\n                        .put(ArrayListMultimap.class, toArrayListMultimap())\n                        .put(LinkedListMultimap.class, toLinkedListMultimap())\n                        .put(SetMultimap.class, toImmutableSetMultimap())\n                        .put(HashMultimap.class, toHashMultimap())\n                        .put(TreeMultimap.class, toTreeMultimap())\n                        .build();\n\n        @Override\n        public boolean accepts(Type containerType) {\n            Class<?> erasedType = getErasedType(containerType);\n            return collectors.containsKey(erasedType)\n                    || mapCollectors.containsKey(erasedType)\n                    || multimapCollectors.containsKey(erasedType);\n        }\n\n        @Override\n        public java.util.Optional<Type> elementType(Type containerType) {\n            Class<?> erasedType = getErasedType(containerType);\n\n            if (collectors.containsKey(erasedType)) {\n                return findGenericParameter(containerType, erasedType);\n            } else if (mapCollectors.containsKey(erasedType)) {\n                TypeToken<?> keyType = TypeToken.of(containerType).resolveType(MAP_KEY);\n                TypeToken<?> valueType = TypeToken.of(containerType).resolveType(MAP_VALUE);\n                return java.util.Optional.of(entryType(keyType, valueType));\n            } else if (multimapCollectors.containsKey(erasedType)) {\n                TypeToken<?> keyType = TypeToken.of(containerType).resolveType(MULTIMAP_KEY);\n                TypeToken<?> valueType = TypeToken.of(containerType).resolveType(MULTIMAP_VALUE);\n                return java.util.Optional.of(entryType(keyType, valueType));\n            }\n\n            return java.util.Optional.empty();\n        }\n\n        private <K, V> Type entryType(TypeToken<K> keyType, TypeToken<V> valueType) {\n            return new TypeToken<Map.Entry<K, V>>() {}\n                    .where(new TypeParameter<K>() {}, keyType)\n                    .where(new TypeParameter<V>() {}, valueType)\n                    .getType();\n        }\n\n        @Override\n        public Collector<?, ?, ?> build(Type containerType) {\n            Class<?> erasedType = getErasedType(containerType);\n            if (collectors.containsKey(erasedType)) {\n                return collectors.get(erasedType);\n            }\n            if (mapCollectors.containsKey(erasedType)) {\n                return mapCollectors.get(erasedType);\n            }\n            return multimapCollectors.get(erasedType);\n        }\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ImmutableMap<K, V>> toImmutableMap() {\n        return ImmutableMap.toImmutableMap(Map.Entry::getKey, Map.Entry::getValue);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, BiMap<K, V>> toHashBiMap() {\n        return Collector.of(\n                HashBiMap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ImmutableListMultimap<K, V>> toImmutableListMultimap() {\n        return Collector.of(\n                (Supplier<ImmutableListMultimap.Builder<K, V>>) ImmutableListMultimap::builder,\n                ImmutableListMultimap.Builder::put,\n                GuavaCollectors::combine,\n                ImmutableListMultimap.Builder::build);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ImmutableSetMultimap<K, V>> toImmutableSetMultimap() {\n        return Collector.of(\n                (Supplier<ImmutableSetMultimap.Builder<K, V>>) ImmutableSetMultimap::builder,\n                ImmutableSetMultimap.Builder::put,\n                GuavaCollectors::combine,\n                ImmutableSetMultimap.Builder::build);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ArrayListMultimap<K, V>> toArrayListMultimap() {\n        return Collector.of(\n                ArrayListMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, LinkedListMultimap<K, V>> toLinkedListMultimap() {\n        return Collector.of(\n                LinkedListMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, HashMultimap<K, V>> toHashMultimap() {\n        return Collector.of(\n                HashMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K extends Comparable, V extends Comparable> Collector<Map.Entry<K, V>, ?, TreeMultimap<K, V>> toTreeMultimap() {\n        return Collector.of(\n                TreeMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    private static <K, V, M extends Map<K, V>> void putEntry(M map, Map.Entry<K, V> entry) {\n        // FIXME throw exception on duplicate entry?\n        map.put(entry.getKey(), entry.getValue());\n    }\n\n    private static <K, V, M extends Multimap<K, V>> void putEntry(M map, Map.Entry<K, V> entry) {\n        map.put(entry.getKey(), entry.getValue());\n    }\n\n    private static <K, V, M extends Map<K, V>> M combine(M a, M b) {\n        // FIXME throw exception on duplicate entries?\n        a.putAll(b);\n        return a;\n    }\n\n    private static <K, V, MB extends ImmutableMultimap.Builder<K, V>> MB combine(MB a, MB b) {\n        a.putAll(b.build());\n        return a;\n    }\n\n    private static <K, V, M extends Multimap<K, V>> M combine(M a, M b) {\n        // FIXME throw exception on duplicate entries? e.g. SetMultimap.put() would return false\n        a.putAll(b);\n        return a;\n    }\n}\n","lineNo":165}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.guava;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.findGenericParameter;\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\nimport java.lang.reflect.Type;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.stream.Collector;\n\nimport org.jdbi.v3.core.collector.CollectorFactory;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSortedSet;\n\n/**\n * Provide Collector instances that create Guava collection types, especially immutable\n * versions of the base Java collections.\n */\npublic class GuavaCollectors {\n\n    /**\n     * @return a {@code CollectorFactory} which knows how to create all supported Guava types\n     */\n    public static CollectorFactory factory() {\n        return new Factory();\n    }\n\n    /**\n     * @param <T> the element type collected.\n     *\n     * @return a collector into Guava's {@code Optional<T>}\n     */\n    public static <T> Collector<T, ?, Optional<T>> toOptional() {\n        return Collector.<T, GuavaOptionalBuilder<T>, Optional<T>>of(\n                GuavaOptionalBuilder::new,\n                GuavaOptionalBuilder::set,\n                (left, right) -> left.build().isPresent() ? left : right,\n                GuavaOptionalBuilder::build);\n    }\n\n    private static class GuavaOptionalBuilder<T> {\n\n        private Optional<T> optional = Optional.absent();\n\n        public void set(T value) {\n            if (optional.isPresent()) {\n                throw new IllegalStateException(\n                        String.format(\"Multiple values for Optional type: ['%s','%s',...]\",\n                                optional.get(),\n                                value));\n            }\n            optional = Optional.of(value);\n        }\n\n        public Optional<T> build() {\n            return optional;\n        }\n    }\n\n    public static class Factory implements CollectorFactory {\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> collectors =\n            ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                .put(ImmutableList.class, ImmutableList.toImmutableList())\n                .put(ImmutableSet.class, ImmutableSet.toImmutableSet())\n                .put(ImmutableSortedSet.class, ImmutableSortedSet.toImmutableSortedSet(Comparator.naturalOrder()))\n                .put(Optional.class, toOptional())\n                .build();\n\n        @Override\n        public boolean accepts(Type containerType) {\n            return collectors.containsKey(getErasedType(containerType));\n        }\n\n        @Override\n        public java.util.Optional<Type> elementType(Type containerType) {\n            return findGenericParameter(containerType, getErasedType(containerType));\n        }\n\n        @Override\n        public Collector<?, ?, ?> build(Type containerType) {\n            return collectors.get(getErasedType(containerType));\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.guava;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.BiMap;\nimport com.google.common.collect.HashBiMap;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.LinkedListMultimap;\nimport com.google.common.collect.ListMultimap;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.collect.TreeMultimap;\nimport com.google.common.reflect.TypeParameter;\nimport com.google.common.reflect.TypeToken;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.stream.Collector;\nimport org.jdbi.v3.core.collector.CollectorFactory;\n\nimport static org.jdbi.v3.core.generic.GenericTypes.findGenericParameter;\nimport static org.jdbi.v3.core.generic.GenericTypes.getErasedType;\n\n/**\n * Provides Collectors for Guava collection types.\n * <p>Supported Collection types:<\/p>\n * <ul>\n *     <li>com.google.common.base.Optional&lt;T&gt; (throws an exception if more than one row in result)<\/li>\n *     <li>com.google.common.collect.ImmutableList&lt;T&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableSet&lt;T&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableSortedSet&lt;T extends Comparable&gt;<\/li>\n * <\/ul>\n * <p>Supported Maps and Multimaps types - for row type Map.Entry&lt;K, V&gt;:<\/p>\n * <ul>\n *     <li>com.google.common.collect.ArrayListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.BiMap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.HashMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableMap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.LinkedListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.ListMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.Multimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.SetMultimap&lt;K, V&gt;<\/li>\n *     <li>com.google.common.collect.TreeMultimap&lt;K, V&gt;<\/li>\n * <\/ul>\n */\npublic class GuavaCollectors {\n    private static final TypeVariable<Class<Map>> MAP_KEY;\n    private static final TypeVariable<Class<Map>> MAP_VALUE;\n    private static final TypeVariable<Class<Multimap>> MULTIMAP_KEY;\n    private static final TypeVariable<Class<Multimap>> MULTIMAP_VALUE;\n\n    static {\n        TypeVariable<Class<Map>>[] mapParams = Map.class.getTypeParameters();\n        MAP_KEY = mapParams[0];\n        MAP_VALUE = mapParams[1];\n\n        TypeVariable<Class<Multimap>>[] multimapParams = Multimap.class.getTypeParameters();\n        MULTIMAP_KEY = multimapParams[0];\n        MULTIMAP_VALUE = multimapParams[1];\n    }\n\n    /**\n     * @return a {@code CollectorFactory} which knows how to create all supported Guava types\n     */\n    public static CollectorFactory factory() {\n        return new Factory();\n    }\n\n    /**\n     * @param <T> the element type collected.\n     * @return a collector into Guava's {@code Optional<T>}\n     */\n    public static <T> Collector<T, ?, Optional<T>> toOptional() {\n        return Collector.<T, GuavaOptionalBuilder<T>, Optional<T>>of(\n                GuavaOptionalBuilder::new,\n                GuavaOptionalBuilder::set,\n                (left, right) -> left.build().isPresent() ? left : right,\n                GuavaOptionalBuilder::build);\n    }\n\n    private static class GuavaOptionalBuilder<T> {\n\n        private Optional<T> optional = Optional.absent();\n\n        public void set(T value) {\n            if (optional.isPresent()) {\n                throw new IllegalStateException(\n                        String.format(\"Multiple values for Optional type: ['%s','%s',...]\",\n                                optional.get(),\n                                value));\n            }\n            optional = Optional.of(value);\n        }\n\n        public Optional<T> build() {\n            return optional;\n        }\n    }\n\n    public static class Factory implements CollectorFactory {\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> collectors =\n                ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                        .put(ImmutableList.class, ImmutableList.toImmutableList())\n                        .put(ImmutableSet.class, ImmutableSet.toImmutableSet())\n                        .put(ImmutableSortedSet.class, ImmutableSortedSet.toImmutableSortedSet(Comparator.naturalOrder()))\n                        .put(Optional.class, toOptional())\n                        .build();\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> mapCollectors =\n                ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                        .put(ImmutableMap.class, toImmutableMap())\n                        .put(BiMap.class, toHashBiMap())\n                        .build();\n\n        private static final Map<Class<?>, Collector<?, ?, ?>> multimapCollectors =\n                ImmutableMap.<Class<?>, Collector<?, ?, ?>>builder()\n                        .put(ImmutableMultimap.class, toImmutableListMultimap())\n                        .put(ImmutableListMultimap.class, toImmutableListMultimap())\n                        .put(ImmutableSetMultimap.class, toImmutableSetMultimap())\n                        .put(Multimap.class, toImmutableListMultimap())\n                        .put(ListMultimap.class, toImmutableListMultimap())\n                        .put(ArrayListMultimap.class, toArrayListMultimap())\n                        .put(LinkedListMultimap.class, toLinkedListMultimap())\n                        .put(SetMultimap.class, toImmutableSetMultimap())\n                        .put(HashMultimap.class, toHashMultimap())\n                        .put(TreeMultimap.class, toTreeMultimap())\n                        .build();\n\n        @Override\n        public boolean accepts(Type containerType) {\n            Class<?> erasedType = getErasedType(containerType);\n            return collectors.containsKey(erasedType)\n                    || mapCollectors.containsKey(erasedType)\n                    || multimapCollectors.containsKey(erasedType);\n        }\n\n        @Override\n        public java.util.Optional<Type> elementType(Type containerType) {\n            Class<?> erasedType = getErasedType(containerType);\n\n            if (collectors.containsKey(erasedType)) {\n                return findGenericParameter(containerType, erasedType);\n            } else if (mapCollectors.containsKey(erasedType)) {\n                TypeToken<?> keyType = TypeToken.of(containerType).resolveType(MAP_KEY);\n                TypeToken<?> valueType = TypeToken.of(containerType).resolveType(MAP_VALUE);\n                return java.util.Optional.of(entryType(keyType, valueType));\n            } else if (multimapCollectors.containsKey(erasedType)) {\n                TypeToken<?> keyType = TypeToken.of(containerType).resolveType(MULTIMAP_KEY);\n                TypeToken<?> valueType = TypeToken.of(containerType).resolveType(MULTIMAP_VALUE);\n                return java.util.Optional.of(entryType(keyType, valueType));\n            }\n\n            return java.util.Optional.empty();\n        }\n\n        private <K, V> Type entryType(TypeToken<K> keyType, TypeToken<V> valueType) {\n            return new TypeToken<Map.Entry<K, V>>() {}\n                    .where(new TypeParameter<K>() {}, keyType)\n                    .where(new TypeParameter<V>() {}, valueType)\n                    .getType();\n        }\n\n        @Override\n        public Collector<?, ?, ?> build(Type containerType) {\n            Class<?> erasedType = getErasedType(containerType);\n            if (collectors.containsKey(erasedType)) {\n                return collectors.get(erasedType);\n            }\n            if (mapCollectors.containsKey(erasedType)) {\n                return mapCollectors.get(erasedType);\n            }\n            return multimapCollectors.get(erasedType);\n        }\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ImmutableMap<K, V>> toImmutableMap() {\n        return ImmutableMap.toImmutableMap(Map.Entry::getKey, Map.Entry::getValue);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, BiMap<K, V>> toHashBiMap() {\n        return Collector.of(\n                HashBiMap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ImmutableListMultimap<K, V>> toImmutableListMultimap() {\n        return Collector.of(\n                (Supplier<ImmutableListMultimap.Builder<K, V>>) ImmutableListMultimap::builder,\n                ImmutableListMultimap.Builder::put,\n                GuavaCollectors::combine,\n                ImmutableListMultimap.Builder::build);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ImmutableSetMultimap<K, V>> toImmutableSetMultimap() {\n        return Collector.of(\n                (Supplier<ImmutableSetMultimap.Builder<K, V>>) ImmutableSetMultimap::builder,\n                ImmutableSetMultimap.Builder::put,\n                GuavaCollectors::combine,\n                ImmutableSetMultimap.Builder::build);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, ArrayListMultimap<K, V>> toArrayListMultimap() {\n        return Collector.of(\n                ArrayListMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, LinkedListMultimap<K, V>> toLinkedListMultimap() {\n        return Collector.of(\n                LinkedListMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K, V> Collector<Map.Entry<K, V>, ?, HashMultimap<K, V>> toHashMultimap() {\n        return Collector.of(\n                HashMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    public static <K extends Comparable, V extends Comparable> Collector<Map.Entry<K, V>, ?, TreeMultimap<K, V>> toTreeMultimap() {\n        return Collector.of(\n                TreeMultimap::create,\n                GuavaCollectors::putEntry,\n                GuavaCollectors::combine);\n    }\n\n    private static <K, V, M extends Map<K, V>> void putEntry(M map, Map.Entry<K, V> entry) {\n        // FIXME throw exception on duplicate entry?\n        map.put(entry.getKey(), entry.getValue());\n    }\n\n    private static <K, V, M extends Multimap<K, V>> void putEntry(M map, Map.Entry<K, V> entry) {\n        map.put(entry.getKey(), entry.getValue());\n    }\n\n    private static <K, V, M extends Map<K, V>> M combine(M a, M b) {\n        // FIXME throw exception on duplicate entries?\n        a.putAll(b);\n        return a;\n    }\n\n    private static <K, V, MB extends ImmutableMultimap.Builder<K, V>> MB combine(MB a, MB b) {\n        a.putAll(b.build());\n        return a;\n    }\n\n    private static <K, V, M extends Multimap<K, V>> M combine(M a, M b) {\n        // FIXME throw exception on duplicate entries? e.g. SetMultimap.put() would return false\n        a.putAll(b);\n        return a;\n    }\n}\n","lineNo":191}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement;\n\nimport static java.util.stream.Stream.concat;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.statement.SqlStatement;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.SqlObjects;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizer;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizingAnnotation;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\n\nabstract class CustomizingStatementHandler<StatementType extends SqlStatement<StatementType>> implements Handler\n{\n    private final List<BoundCustomizer> statementCustomizers;\n    private final Class<?> sqlObjectType;\n    private final Method method;\n\n    CustomizingStatementHandler(Class<?> type, Method method)\n    {\n        this.sqlObjectType = type;\n        this.method = method;\n\n        // Prepare customizers that don't depend on actual arguments.\n        final Stream<BoundCustomizer> methodCustomizers = concat(\n                annotationsFor(type).map(a -> instantiateFactory(a).createForType(a, type)),\n                annotationsFor(method).map(a -> instantiateFactory(a).createForMethod(a, type, method)))\n            .map(BoundCustomizer::of);\n\n        // Append customizers that do.\n        statementCustomizers = concat(methodCustomizers, parameterCustomizers(type, method))\n            .collect(Collectors.<BoundCustomizer>toList());\n    }\n\n    private static Stream<Annotation> annotationsFor(AnnotatedElement... elements) {\n        return Stream.of(elements)\n                .map(AnnotatedElement::getAnnotations)\n                .flatMap(Stream::of)\n                .filter(a -> a.annotationType().isAnnotationPresent(SqlStatementCustomizingAnnotation.class));\n    }\n\n    private static Stream<BoundCustomizer> parameterCustomizers(Class<?> type, Method method) {\n        final Parameter[] parameters = method.getParameters();\n\n        final Function<Integer, Stream<BoundCustomizer>> customizeForParameter =\n                i -> defaultBinding(annotationsFor(parameters[i]))\n                        .map(a -> instantiateFactory(a).createForParameter(a, type, method, parameters[i], i))\n                        .map(c -> (stmt, args) -> c.apply(stmt, args[i]));\n\n        return IntStream.range(0, parameters.length)\n                .mapToObj(Integer::valueOf)\n                .flatMap(customizeForParameter);\n    }\n\n    /** Add a {@code @Bind} annotation to any parameter with no annotations. */\n    private static Stream<Annotation> defaultBinding(Stream<Annotation> annotations) {\n        final List<Annotation> a = annotations.collect(Collectors.toList());\n        if (!a.isEmpty()) {\n            return a.stream();\n        }\n        return Stream.of(Bind.DEFAULT);\n    }\n\n    private static SqlStatementCustomizerFactory instantiateFactory(Annotation annotation) {\n        SqlStatementCustomizingAnnotation sca = annotation.annotationType()\n                                                          .getAnnotation(SqlStatementCustomizingAnnotation.class);\n        try {\n            return sca.value().getConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new IllegalStateException(\"unable to instantiate sql statement customizer factory\", e);\n        }\n    }\n\n    @Override\n    public Object invoke(Object target, Object[] args, HandleSupplier hs) throws Exception {\n        final Handle h = hs.getHandle();\n        final String locatedSql = locateSql(h);\n        final StatementType stmt = createStatement(h, locatedSql);\n        final SqlObjectStatementConfiguration cfg = stmt.getConfig(SqlObjectStatementConfiguration.class);\n        configureReturner(stmt, cfg);\n        applyCustomizers(stmt, args);\n        return cfg.getReturner().get();\n    }\n\n    void applyCustomizers(final StatementType stmt, Object[] args) {\n        statementCustomizers.forEach(b -> {\n            try {\n                b.apply(stmt, args);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, stmt.getContext());\n            }\n        });\n    }\n\n    abstract void configureReturner(StatementType stmt, SqlObjectStatementConfiguration cfg);\n    abstract StatementType createStatement(Handle handle, String locatedSql);\n\n    String locateSql(final Handle h)\n    {\n        return h.getConfig(SqlObjects.class).getSqlLocator().locate(sqlObjectType, method);\n    }\n\n    Method getMethod()\n    {\n        return method;\n    }\n\n    static RowMapper<?> rowMapperFor(UseRowMapper annotation)\n    {\n        Class<? extends RowMapper<?>> mapperClass = annotation.value();\n        try {\n            return mapperClass.getConstructor().newInstance();\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(\"Could not create mapper \" + mapperClass.getName(), e, null);\n        }\n    }\n\n    /**\n     * A {@link SqlStatementCustomizer} or {@link SqlStatementParameterCustomizer} that\n     * is ready to apply.\n     */\n    private interface BoundCustomizer {\n        void apply(SqlStatement<?> stmt, Object[] args) throws SQLException;\n\n        static BoundCustomizer of(SqlStatementCustomizer c) {\n            return (stmt, args) -> c.apply(stmt);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement;\n\nimport static java.util.stream.Stream.concat;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.statement.SqlStatement;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.core.statement.UnableToExecuteStatementException;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.SqlObjects;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizer;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizingAnnotation;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\n\nabstract class CustomizingStatementHandler<StatementType extends SqlStatement<StatementType>> implements Handler\n{\n    private final List<BoundCustomizer> statementCustomizers;\n    private final Class<?> sqlObjectType;\n    private final Method method;\n\n    CustomizingStatementHandler(Class<?> type, Method method)\n    {\n        this.sqlObjectType = type;\n        this.method = method;\n\n        // Prepare customizers that don't depend on actual arguments.\n        final Stream<BoundCustomizer> methodCustomizers = concat(\n                annotationsFor(type).map(a -> instantiateFactory(a).createForType(a, type)),\n                annotationsFor(method).map(a -> instantiateFactory(a).createForMethod(a, type, method)))\n            .map(BoundCustomizer::of);\n\n        // Append customizers that do.\n        statementCustomizers = concat(methodCustomizers, parameterCustomizers(type, method))\n            .collect(Collectors.<BoundCustomizer>toList());\n    }\n\n    private static Stream<Annotation> annotationsFor(AnnotatedElement... elements) {\n        return Stream.of(elements)\n                .map(AnnotatedElement::getAnnotations)\n                .flatMap(Stream::of)\n                .filter(a -> a.annotationType().isAnnotationPresent(SqlStatementCustomizingAnnotation.class));\n    }\n\n    private static Stream<BoundCustomizer> parameterCustomizers(Class<?> type, Method method) {\n        final Parameter[] parameters = method.getParameters();\n\n        return IntStream.range(0, parameters.length)\n                .mapToObj(Integer::valueOf)\n                .flatMap(i -> eachParameterCustomizers(type, method, parameters[i], i));\n    }\n\n    private static Stream<BoundCustomizer> eachParameterCustomizers(Class<?> type, Method method, Parameter parameter, Integer i) {\n\n        List<BoundCustomizer> customizers = annotationsFor(parameter)\n                .map(a -> instantiateFactory(a).createForParameter(a, type, method, parameter, i))\n                .<BoundCustomizer>map(c -> (stmt, args) -> c.apply(stmt, args[i])).collect(Collectors.toList());\n\n        if (!customizers.isEmpty()) {\n            return customizers.stream();\n        }\n\n        return Stream.of(defaultParameterCustomizer(type, method, parameter, i));\n    }\n\n    /**\n     * Default parameter customizer for parameters with no annotations.\n     */\n    private static BoundCustomizer defaultParameterCustomizer(Class<?> type, Method method, Parameter parameter, Integer i) {\n        return (stmt, args) -> getDefaultParameterCustomizerFactory(stmt)\n                .createForParameter(null, type, method, parameter, i)\n                .apply(stmt, args[i]);\n    }\n\n    private static SqlStatementCustomizerFactory getDefaultParameterCustomizerFactory(SqlStatement<?> stmt) {\n        return stmt.getConfig(SqlObjectStatementCustomizerConfiguration.class).getDefaultParameterCustomizerFactory();\n    }\n\n    private static SqlStatementCustomizerFactory instantiateFactory(Annotation annotation) {\n        SqlStatementCustomizingAnnotation sca = annotation.annotationType()\n                .getAnnotation(SqlStatementCustomizingAnnotation.class);\n        try {\n            return sca.value().getConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new IllegalStateException(\"unable to instantiate sql statement customizer factory\", e);\n        }\n    }\n\n    @Override\n    public Object invoke(Object target, Object[] args, HandleSupplier hs) throws Exception {\n        final Handle h = hs.getHandle();\n        final String locatedSql = locateSql(h);\n        final StatementType stmt = createStatement(h, locatedSql);\n        final SqlObjectStatementConfiguration cfg = stmt.getConfig(SqlObjectStatementConfiguration.class);\n        configureReturner(stmt, cfg);\n        applyCustomizers(stmt, args);\n        return cfg.getReturner().get();\n    }\n\n    void applyCustomizers(final StatementType stmt, Object[] args) {\n        statementCustomizers.forEach(b -> {\n            try {\n                b.apply(stmt, args);\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, stmt.getContext());\n            }\n        });\n    }\n\n    abstract void configureReturner(StatementType stmt, SqlObjectStatementConfiguration cfg);\n    abstract StatementType createStatement(Handle handle, String locatedSql);\n\n    String locateSql(final Handle h)\n    {\n        return h.getConfig(SqlObjects.class).getSqlLocator().locate(sqlObjectType, method);\n    }\n\n    Method getMethod()\n    {\n        return method;\n    }\n\n    static RowMapper<?> rowMapperFor(UseRowMapper annotation)\n    {\n        Class<? extends RowMapper<?>> mapperClass = annotation.value();\n        try {\n            return mapperClass.getConstructor().newInstance();\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(\"Could not create mapper \" + mapperClass.getName(), e, null);\n        }\n    }\n\n    /**\n     * A {@link SqlStatementCustomizer} or {@link SqlStatementParameterCustomizer} that\n     * is ready to apply.\n     */\n    private interface BoundCustomizer {\n        void apply(SqlStatement<?> stmt, Object[] args) throws SQLException;\n\n        static BoundCustomizer of(SqlStatementCustomizer c) {\n            return (stmt, args) -> c.apply(stmt);\n        }\n    }\n}\n","lineNo":80}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizer;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\n\nimport org.jdbi.v3.core.statement.Query;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD, ElementType.PARAMETER})\n@SqlStatementCustomizingAnnotation(FetchSize.Factory.class)\npublic @interface FetchSize\n{\n    int value() default 0;\n\n    class Factory implements SqlStatementCustomizerFactory\n    {\n        @Override\n        public SqlStatementCustomizer createForMethod(Annotation annotation, Class<?> sqlObjectType, Method method)\n        {\n            final FetchSize fs = (FetchSize) annotation;\n            return q -> {\n                assert q instanceof Query;\n                ((Query) q).setFetchSize(fs.value());\n            };\n        }\n\n        @Override\n        public SqlStatementCustomizer createForType(Annotation annotation, Class<?> sqlObjectType)\n        {\n            final FetchSize fs = (FetchSize) annotation;\n            return q -> {\n                assert q instanceof Query;\n                ((Query) q).setFetchSize(fs.value());\n            };\n        }\n\n        @Override\n        public SqlStatementCustomizer createForParameter(Annotation annotation,\n                                                         Class<?> sqlObjectType,\n                                                         Method method,\n                                                         Parameter param,\n                                                         int index,\n                                                         Object arg)\n        {\n            final Integer va = (Integer) arg;\n            return q -> {\n                assert q instanceof Query;\n                ((Query) q).setFetchSize(va);\n            };\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizer;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\n\nimport org.jdbi.v3.core.statement.Query;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD, ElementType.PARAMETER})\n@SqlStatementCustomizingAnnotation(FetchSize.Factory.class)\npublic @interface FetchSize\n{\n    int value() default 0;\n\n    class Factory implements SqlStatementCustomizerFactory\n    {\n        @Override\n        public SqlStatementCustomizer createForType(Annotation annotation, Class<?> sqlObjectType)\n        {\n            int fetchSize = ((FetchSize) annotation).value();\n            return stmt -> {\n                assert stmt instanceof Query;\n                ((Query) stmt).setFetchSize(fetchSize);\n            };\n        }\n\n        @Override\n        public SqlStatementCustomizer createForMethod(Annotation annotation, Class<?> sqlObjectType, Method method)\n        {\n            return createForType(annotation, sqlObjectType);\n        }\n\n        @Override\n        public SqlStatementParameterCustomizer createForParameter(Annotation annotation,\n                                                                  Class<?> sqlObjectType,\n                                                                  Method method,\n                                                                  Parameter param,\n                                                                  int index)\n        {\n            return (stmt, fetchSize) -> {\n                assert stmt instanceof Query;\n                ((Query) stmt).setFetchSize((Integer) fetchSize);\n            };\n        }\n    }\n}\n","lineNo":38}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizer;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\n\n/**\n * Specify the query timeout in seconds. May be used on a method or parameter, the parameter must be of an int type.\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD, ElementType.PARAMETER})\n@SqlStatementCustomizingAnnotation(QueryTimeOut.Factory.class)\npublic @interface QueryTimeOut\n{\n    int value() default Integer.MAX_VALUE;\n\n    class Factory implements SqlStatementCustomizerFactory\n    {\n        @Override\n        public SqlStatementCustomizer createForMethod(Annotation annotation, Class<?> sqlObjectType, Method method)\n        {\n            final QueryTimeOut fs = (QueryTimeOut) annotation;\n            return q -> q.setQueryTimeout(fs.value());\n        }\n\n        @Override\n        public SqlStatementCustomizer createForType(Annotation annotation, Class<?> sqlObjectType)\n        {\n            final QueryTimeOut fs = (QueryTimeOut) annotation;\n            return q -> q.setQueryTimeout(fs.value());\n        }\n\n        @Override\n        public SqlStatementCustomizer createForParameter(Annotation annotation,\n                                                         Class<?> sqlObjectType,\n                                                         Method method,\n                                                         Parameter param,\n                                                         int index,\n                                                         Object arg)\n        {\n            final Integer va = (Integer) arg;\n            return q -> q.setQueryTimeout(va);\n        }\n    }\n\n\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizer;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\n\n/**\n * Specify the query timeout in seconds. May be used on a method or parameter, the parameter must be of an int type.\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD, ElementType.PARAMETER})\n@SqlStatementCustomizingAnnotation(QueryTimeOut.Factory.class)\npublic @interface QueryTimeOut\n{\n    int value() default Integer.MAX_VALUE;\n\n    class Factory implements SqlStatementCustomizerFactory\n    {\n        @Override\n        public SqlStatementCustomizer createForType(Annotation annotation, Class<?> sqlObjectType)\n        {\n            int queryTimeout = ((QueryTimeOut) annotation).value();\n            return stmt -> stmt.setQueryTimeout(queryTimeout);\n        }\n\n        @Override\n        public SqlStatementCustomizer createForMethod(Annotation annotation, Class<?> sqlObjectType, Method method)\n        {\n            return createForType(annotation, sqlObjectType);\n        }\n\n        @Override\n        public SqlStatementParameterCustomizer createForParameter(Annotation annotation,\n                                                                  Class<?> sqlObjectType,\n                                                                  Method method,\n                                                                  Parameter param,\n                                                                  int index)\n        {\n            return (stmt, queryTimeout) -> stmt.setQueryTimeout((Integer) queryTimeout);\n        }\n    }\n\n\n}\n","lineNo":39}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.transaction;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.core.statement.SqlStatement;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.StatementCustomizer;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizer;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizingAnnotation;\n\n/**\n * Used to specify the transaction isolation level for an object or method (via annotating the method\n * or passing it in as an annotated param). If used on a parameter, the parameter type must be a\n * {@link TransactionIsolationLevel}\n */\n@SqlStatementCustomizingAnnotation(TransactionIsolation.Factory.class)\n@Target({ElementType.PARAMETER, ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface TransactionIsolation\n{\n\n    TransactionIsolationLevel value() default TransactionIsolationLevel.UNKNOWN;\n\n    class Factory implements SqlStatementCustomizerFactory\n    {\n\n        @Override\n        public SqlStatementCustomizer createForMethod(Annotation annotation, Class<?> sqlObjectType, Method method)\n        {\n            return new MyCustomizer(((TransactionIsolation) annotation).value());\n        }\n\n        @Override\n        public SqlStatementCustomizer createForType(Annotation annotation, Class<?> sqlObjectType)\n        {\n            return new MyCustomizer(((TransactionIsolation) annotation).value());\n        }\n\n        @Override\n        public SqlStatementCustomizer createForParameter(Annotation annotation, Class<?> sqlObjectType, Method method, Parameter param, int index, Object arg)\n        {\n            assert arg instanceof TransactionIsolationLevel;\n            return new MyCustomizer((TransactionIsolationLevel) arg);\n        }\n    }\n\n    class MyCustomizer implements SqlStatementCustomizer\n    {\n\n        private final TransactionIsolationLevel level;\n\n        MyCustomizer(TransactionIsolationLevel level) { this.level = level; }\n\n        @Override\n        public void apply(SqlStatement<?> q) throws SQLException\n        {\n            final int initial_level = q.getContext().getConnection().getTransactionIsolation();\n\n            q.addCustomizer(new StatementCustomizer()\n            {\n                @Override\n                public void beforeExecution(PreparedStatement stmt, StatementContext ctx) throws SQLException\n                {\n                    setTxnIsolation(ctx, level.intValue());\n                }\n\n                @Override\n                public void afterExecution(PreparedStatement stmt, StatementContext ctx) throws SQLException\n                {\n                    setTxnIsolation(ctx, initial_level);\n                }\n\n                private void setTxnIsolation(StatementContext ctx, int level) throws SQLException\n                {\n                    final Connection c = ctx.getConnection();\n                    if (c.getTransactionIsolation() != level) {\n                        c.setTransactionIsolation(level);\n                    }\n                }\n            });\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.transaction;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.core.statement.SqlStatement;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.StatementCustomizer;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizer;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizingAnnotation;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementParameterCustomizer;\n\n/**\n * Used to specify the transaction isolation level for an object or method (via annotating the method\n * or passing it in as an annotated param). If used on a parameter, the parameter type must be a\n * {@link TransactionIsolationLevel}\n */\n@SqlStatementCustomizingAnnotation(TransactionIsolation.Factory.class)\n@Target({ElementType.PARAMETER, ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface TransactionIsolation\n{\n\n    TransactionIsolationLevel value() default TransactionIsolationLevel.UNKNOWN;\n\n    class Factory implements SqlStatementCustomizerFactory\n    {\n        @Override\n        public SqlStatementCustomizer createForType(Annotation annotation, Class<?> sqlObjectType)\n        {\n            TransactionIsolationLevel level = ((TransactionIsolation) annotation).value();\n            return stmt -> setTxnIsolation(stmt, level);\n        }\n\n        @Override\n        public SqlStatementCustomizer createForMethod(Annotation annotation, Class<?> sqlObjectType, Method method)\n        {\n            return createForType(annotation, sqlObjectType);\n        }\n\n        @Override\n        public SqlStatementParameterCustomizer createForParameter(Annotation annotation, Class<?> sqlObjectType, Method method, Parameter param, int index)\n        {\n            return (stmt, arg) -> {\n                assert arg instanceof TransactionIsolationLevel;\n                setTxnIsolation(stmt, (TransactionIsolationLevel) arg);\n            };\n        }\n\n        private void setTxnIsolation(SqlStatement<?> stmt, TransactionIsolationLevel level) throws SQLException\n        {\n            final int initialLevel = stmt.getContext().getConnection().getTransactionIsolation();\n\n            stmt.addCustomizer(new StatementCustomizer()\n            {\n                @Override\n                public void beforeExecution(PreparedStatement stmt, StatementContext ctx) throws SQLException\n                {\n                    setTxnIsolation(ctx, level.intValue());\n                }\n\n                @Override\n                public void afterExecution(PreparedStatement stmt, StatementContext ctx) throws SQLException\n                {\n                    setTxnIsolation(ctx, initialLevel);\n                }\n\n                private void setTxnIsolation(StatementContext ctx, int level) throws SQLException\n                {\n                    final Connection c = ctx.getConnection();\n                    if (c.getTransactionIsolation() != level) {\n                        c.setTransactionIsolation(level);\n                    }\n                }\n            });\n        }\n    }\n}\n","lineNo":54}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.statement.SqlStatement;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.SqlObjects;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizingAnnotation;\n\nabstract class CustomizingStatementHandler<StatementType extends SqlStatement<StatementType>> implements Handler\n{\n    private final List<FactoryAnnotationPair>           typeBasedCustomizerFactories   = new ArrayList<>();\n    private final List<FactoryAnnotationPair>           methodBasedCustomizerFactories = new ArrayList<>();\n    private final List<FactoryAnnotationParameterIndex> paramBasedCustomizerFactories  = new ArrayList<>();\n    private final Class<?> sqlObjectType;\n    private final Method method;\n\n    CustomizingStatementHandler(Class<?> sqlObjectType, Method method)\n    {\n        this.sqlObjectType = sqlObjectType;\n        this.method = method;\n\n        for (final Annotation annotation : sqlObjectType.getAnnotations()) {\n            if (annotation.annotationType().isAnnotationPresent(SqlStatementCustomizingAnnotation.class)) {\n                final SqlStatementCustomizingAnnotation a = annotation.annotationType()\n                                                                      .getAnnotation(SqlStatementCustomizingAnnotation.class);\n                final SqlStatementCustomizerFactory f;\n                try {\n                    f = a.value().newInstance();\n                }\n                catch (Exception e) {\n                    throw new IllegalStateException(\"unable to create sql statement customizer factory\", e);\n                }\n                typeBasedCustomizerFactories.add(new FactoryAnnotationPair(f, annotation));\n            }\n        }\n\n\n        for (final Annotation annotation : method.getAnnotations()) {\n            final Class<? extends Annotation> annotationType = annotation.annotationType();\n            if (annotationType.isAnnotationPresent(SqlStatementCustomizingAnnotation.class)) {\n                final SqlStatementCustomizingAnnotation scf =\n                    annotationType.getAnnotation(SqlStatementCustomizingAnnotation.class);\n                final SqlStatementCustomizerFactory f;\n                try {\n                    f = scf.value().newInstance();\n                }\n                catch (Exception e) {\n                    throw new IllegalStateException(\"unable to instantiate statement customizer factory\", e);\n                }\n                methodBasedCustomizerFactories.add(new FactoryAnnotationPair(f, annotation));\n            }\n\n        }\n\n        final Annotation[][] paramAnnotations = method.getParameterAnnotations();\n        final Parameter[] parameters = method.getParameters();\n        for (int paramIndex = 0; paramIndex < paramAnnotations.length; paramIndex++) {\n            boolean foundCustomizingAnnotations = false;\n            for (final Annotation annotation : paramAnnotations[paramIndex]) {\n                final Class<? extends Annotation> annotationType = annotation.annotationType();\n\n                if (annotationType.isAnnotationPresent(SqlStatementCustomizingAnnotation.class)) {\n                    SqlStatementCustomizingAnnotation sca = annotation.annotationType()\n                                                                      .getAnnotation(SqlStatementCustomizingAnnotation.class);\n                    final SqlStatementCustomizerFactory f;\n                    try {\n                        f = sca.value().newInstance();\n                    }\n                    catch (Exception e) {\n                        throw new IllegalStateException(\"unable to instantiate sql statement customizer factory\", e);\n                    }\n                    paramBasedCustomizerFactories.add(new FactoryAnnotationParameterIndex(f, annotation, parameters[paramIndex], paramIndex));\n                    foundCustomizingAnnotations = true;\n                }\n            }\n\n            if (!foundCustomizingAnnotations) {\n                // There are no customizing annotations on the parameter, so use default binder\n                paramBasedCustomizerFactories.add(new FactoryAnnotationParameterIndex(new Bind.Factory(), null, parameters[paramIndex], paramIndex));\n            }\n        }\n    }\n\n    @Override\n    public Object invoke(Object target, Object[] args, HandleSupplier hs) throws Exception {\n        final Handle h = hs.getHandle();\n        final String locatedSql = locateSql(h);\n        final StatementType stmt = createStatement(h, locatedSql);\n        final SqlObjectStatementConfiguration cfg = stmt.getConfig(SqlObjectStatementConfiguration.class);\n        configureReturner(stmt, cfg);\n        applyCustomizers(stmt, args);\n        return cfg.getReturner().get();\n    }\n\n    abstract void configureReturner(StatementType stmt, SqlObjectStatementConfiguration cfg);\n    abstract StatementType createStatement(Handle handle, String locatedSql);\n\n    String locateSql(final Handle h)\n    {\n        return h.getConfig(SqlObjects.class).getSqlLocator().locate(sqlObjectType, method);\n    }\n\n    void applyCustomizers(SqlStatement<?> stmt, Object[] args)\n    {\n        try {\n            for (FactoryAnnotationPair pair : typeBasedCustomizerFactories) {\n                pair.factory.createForType(pair.annotation, sqlObjectType).apply(stmt);\n            }\n\n            for (FactoryAnnotationPair pair : methodBasedCustomizerFactories) {\n                pair.factory.createForMethod(pair.annotation, sqlObjectType, method).apply(stmt);\n            }\n\n            for (FactoryAnnotationParameterIndex param : paramBasedCustomizerFactories) {\n                param.factory\n                    .createForParameter(param.annotation, sqlObjectType, method, param.parameter, param.index, args[param.index])\n                    .apply(stmt);\n            }\n        } catch (SQLException e) {\n            throw new UnableToCreateStatementException(\"unable to apply customizer\", e, stmt.getContext());\n        }\n    }\n\n    private static class FactoryAnnotationPair\n    {\n        private final SqlStatementCustomizerFactory factory;\n        private final Annotation                    annotation;\n\n        FactoryAnnotationPair(SqlStatementCustomizerFactory factory, Annotation annotation)\n        {\n            this.factory = factory;\n            this.annotation = annotation;\n        }\n    }\n\n    private static class FactoryAnnotationParameterIndex\n    {\n        private final SqlStatementCustomizerFactory factory;\n        private final Annotation                    annotation;\n        private final Parameter                     parameter;\n        private final int                           index;\n\n        FactoryAnnotationParameterIndex(SqlStatementCustomizerFactory factory,\n                                        Annotation annotation,\n                                        Parameter parameter,\n                                        int index)\n        {\n            this.factory = factory;\n            this.annotation = annotation;\n            this.parameter = parameter;\n            this.index = index;\n        }\n    }\n\n    Method getMethod()\n    {\n        return method;\n    }\n\n    static RowMapper<?> rowMapperFor(GetGeneratedKeys ggk, Type returnType)\n    {\n        if (GetGeneratedKeys.DefaultMapper.class.equals(ggk.value())) {\n            return new GetGeneratedKeys.DefaultMapper(returnType, ggk.columnName());\n        }\n        else {\n            try {\n                return ggk.value().getConstructor().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"Unable to instantiate row mapper for statement\", e, null);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.statement;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.extension.HandleSupplier;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.statement.SqlStatement;\nimport org.jdbi.v3.core.statement.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.SqlObjects;\nimport org.jdbi.v3.sqlobject.customizer.Bind;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizingAnnotation;\n\nabstract class CustomizingStatementHandler<StatementType extends SqlStatement<StatementType>> implements Handler\n{\n    private final List<FactoryAnnotationPair>           typeBasedCustomizerFactories   = new ArrayList<>();\n    private final List<FactoryAnnotationPair>           methodBasedCustomizerFactories = new ArrayList<>();\n    private final List<FactoryAnnotationParameterIndex> paramBasedCustomizerFactories  = new ArrayList<>();\n    private final Class<?> sqlObjectType;\n    private final Method method;\n\n    CustomizingStatementHandler(Class<?> sqlObjectType, Method method)\n    {\n        this.sqlObjectType = sqlObjectType;\n        this.method = method;\n\n        for (final Annotation annotation : sqlObjectType.getAnnotations()) {\n            if (annotation.annotationType().isAnnotationPresent(SqlStatementCustomizingAnnotation.class)) {\n                final SqlStatementCustomizingAnnotation a = annotation.annotationType()\n                                                                      .getAnnotation(SqlStatementCustomizingAnnotation.class);\n                final SqlStatementCustomizerFactory f;\n                try {\n                    f = a.value().newInstance();\n                }\n                catch (Exception e) {\n                    throw new IllegalStateException(\"unable to create sql statement customizer factory\", e);\n                }\n                typeBasedCustomizerFactories.add(new FactoryAnnotationPair(f, annotation));\n            }\n        }\n\n\n        for (final Annotation annotation : method.getAnnotations()) {\n            final Class<? extends Annotation> annotationType = annotation.annotationType();\n            if (annotationType.isAnnotationPresent(SqlStatementCustomizingAnnotation.class)) {\n                final SqlStatementCustomizingAnnotation scf =\n                    annotationType.getAnnotation(SqlStatementCustomizingAnnotation.class);\n                final SqlStatementCustomizerFactory f;\n                try {\n                    f = scf.value().newInstance();\n                }\n                catch (Exception e) {\n                    throw new IllegalStateException(\"unable to instantiate statement customizer factory\", e);\n                }\n                methodBasedCustomizerFactories.add(new FactoryAnnotationPair(f, annotation));\n            }\n\n        }\n\n        final Annotation[][] paramAnnotations = method.getParameterAnnotations();\n        final Parameter[] parameters = method.getParameters();\n        for (int paramIndex = 0; paramIndex < paramAnnotations.length; paramIndex++) {\n            boolean foundCustomizingAnnotations = false;\n            for (final Annotation annotation : paramAnnotations[paramIndex]) {\n                final Class<? extends Annotation> annotationType = annotation.annotationType();\n\n                if (annotationType.isAnnotationPresent(SqlStatementCustomizingAnnotation.class)) {\n                    SqlStatementCustomizingAnnotation sca = annotation.annotationType()\n                                                                      .getAnnotation(SqlStatementCustomizingAnnotation.class);\n                    final SqlStatementCustomizerFactory f;\n                    try {\n                        f = sca.value().newInstance();\n                    }\n                    catch (Exception e) {\n                        throw new IllegalStateException(\"unable to instantiate sql statement customizer factory\", e);\n                    }\n                    paramBasedCustomizerFactories.add(new FactoryAnnotationParameterIndex(f, annotation, parameters[paramIndex], paramIndex));\n                    foundCustomizingAnnotations = true;\n                }\n            }\n\n            if (!foundCustomizingAnnotations) {\n                // There are no customizing annotations on the parameter, so use default binder\n                paramBasedCustomizerFactories.add(new FactoryAnnotationParameterIndex(new Bind.Factory(), null, parameters[paramIndex], paramIndex));\n            }\n        }\n    }\n\n    @Override\n    public Object invoke(Object target, Object[] args, HandleSupplier hs) throws Exception {\n        final Handle h = hs.getHandle();\n        final String locatedSql = locateSql(h);\n        final StatementType stmt = createStatement(h, locatedSql);\n        final SqlObjectStatementConfiguration cfg = stmt.getConfig(SqlObjectStatementConfiguration.class);\n        configureReturner(stmt, cfg);\n        applyCustomizers(stmt, args);\n        return cfg.getReturner().get();\n    }\n\n    abstract void configureReturner(StatementType stmt, SqlObjectStatementConfiguration cfg);\n    abstract StatementType createStatement(Handle handle, String locatedSql);\n\n    String locateSql(final Handle h)\n    {\n        return h.getConfig(SqlObjects.class).getSqlLocator().locate(sqlObjectType, method);\n    }\n\n    void applyCustomizers(SqlStatement<?> stmt, Object[] args)\n    {\n        try {\n            for (FactoryAnnotationPair pair : typeBasedCustomizerFactories) {\n                pair.factory.createForType(pair.annotation, sqlObjectType).apply(stmt);\n            }\n\n            for (FactoryAnnotationPair pair : methodBasedCustomizerFactories) {\n                pair.factory.createForMethod(pair.annotation, sqlObjectType, method).apply(stmt);\n            }\n\n            for (FactoryAnnotationParameterIndex param : paramBasedCustomizerFactories) {\n                param.factory\n                    .createForParameter(param.annotation, sqlObjectType, method, param.parameter, param.index, args[param.index])\n                    .apply(stmt);\n            }\n        } catch (SQLException e) {\n            throw new UnableToCreateStatementException(\"unable to apply customizer\", e, stmt.getContext());\n        }\n    }\n\n    private static class FactoryAnnotationPair\n    {\n        private final SqlStatementCustomizerFactory factory;\n        private final Annotation                    annotation;\n\n        FactoryAnnotationPair(SqlStatementCustomizerFactory factory, Annotation annotation)\n        {\n            this.factory = factory;\n            this.annotation = annotation;\n        }\n    }\n\n    private static class FactoryAnnotationParameterIndex\n    {\n        private final SqlStatementCustomizerFactory factory;\n        private final Annotation                    annotation;\n        private final Parameter                     parameter;\n        private final int                           index;\n\n        FactoryAnnotationParameterIndex(SqlStatementCustomizerFactory factory,\n                                        Annotation annotation,\n                                        Parameter parameter,\n                                        int index)\n        {\n            this.factory = factory;\n            this.annotation = annotation;\n            this.parameter = parameter;\n            this.index = index;\n        }\n    }\n\n    Method getMethod()\n    {\n        return method;\n    }\n\n    static RowMapper<?> rowMapperFor(UseRowMapper annotation)\n    {\n        Class<? extends RowMapper<?>> mapperClass = annotation.value();\n        try {\n            return mapperClass.getConstructor().newInstance();\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(\"Could not create mapper \" + mapperClass.getName(), e, null);\n        }\n    }\n}\n","lineNo":187}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.transaction;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.transaction.TransactionException;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.HandlerDecorator;\nimport org.jdbi.v3.sqlobject.SqlMethodDecoratingAnnotation;\n\n/**\n * Causes the annotated method to be run in a transaction.\n * <p>\n * Nested <code>@Transaction<\/code> annotations (e.g. one method calls another method, where both methods have this\n * annotation) are collapsed into a single transaction. If the outer method annotation specifies an isolation level,\n * then the inner method must either specify the same level, or not specify any level.\n * <\/p>\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\n@SqlMethodDecoratingAnnotation(Transaction.Decorator.class)\npublic @interface Transaction {\n    TransactionIsolationLevel value() default TransactionIsolationLevel.INVALID_LEVEL;\n\n    class Decorator implements HandlerDecorator {\n        @Override\n        public Handler decorateHandler(Handler base, Class<?> sqlObjectType, Method method) {\n            final TransactionIsolationLevel isolation = method.getAnnotation(Transaction.class).value();\n\n            return (target, args, handle) -> {\n                Handle h = handle.getHandle();\n\n                if (h.isInTransaction()) {\n                    TransactionIsolationLevel currentLevel = h.getTransactionIsolationLevel();\n                    if (currentLevel == isolation || isolation == TransactionIsolationLevel.INVALID_LEVEL) {\n                        // Already in transaction. The outermost @Transaction method determines the transaction isolation level.\n                        return base.invoke(target, args, handle);\n                    } else {\n                        throw new TransactionException(\"Tried to execute nested @Transaction(\" + isolation + \"), \" +\n                                \"but already running in a transaction with isolation level \" + currentLevel + \".\");\n                    }\n                }\n\n                HandleCallback<Object, Exception> callback = th -> base.invoke(target, args, handle);\n\n                if (isolation == TransactionIsolationLevel.INVALID_LEVEL) {\n                    return h.inTransaction(callback);\n                } else {\n                    return h.inTransaction(isolation, callback);\n                }\n            };\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.transaction;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleCallback;\nimport org.jdbi.v3.core.transaction.TransactionException;\nimport org.jdbi.v3.core.transaction.TransactionIsolationLevel;\nimport org.jdbi.v3.sqlobject.Handler;\nimport org.jdbi.v3.sqlobject.HandlerDecorator;\nimport org.jdbi.v3.sqlobject.SqlMethodDecoratingAnnotation;\n\n/**\n * Causes the annotated method to be run in a transaction.\n * <p>\n * Nested <code>@Transaction<\/code> annotations (e.g. one method calls another method, where both methods have this\n * annotation) are collapsed into a single transaction. If the outer method annotation specifies an isolation level,\n * then the inner method must either specify the same level, or not specify any level.\n * <\/p>\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\n@SqlMethodDecoratingAnnotation(Transaction.Decorator.class)\npublic @interface Transaction {\n    /**\n     * @return the transaction isolation level.  If not specified, invoke with the default isolation level.\n     */\n    TransactionIsolationLevel value() default TransactionIsolationLevel.INVALID_LEVEL;\n    /**\n     * Set the connection readOnly property before the transaction starts, and restore it before it returns.\n     * Databases may use this as a performance or concurrency hint.\n     * @return whether the transaction is read only\n     */\n    boolean readOnly() default false;\n\n    class Decorator implements HandlerDecorator {\n        @Override\n        public Handler decorateHandler(Handler base, Class<?> sqlObjectType, Method method) {\n            final Transaction txnAnnotation = method.getAnnotation(Transaction.class);\n            final TransactionIsolationLevel isolation = txnAnnotation.value();\n            final boolean readOnly = txnAnnotation.readOnly();\n\n            return (target, args, handle) -> {\n                Handle h = handle.getHandle();\n\n                if (h.isInTransaction()) {\n                    // Already in transaction. The outermost @Transaction method determines the transaction isolation level.\n                    TransactionIsolationLevel currentLevel = h.getTransactionIsolationLevel();\n                    if (currentLevel != isolation && isolation != TransactionIsolationLevel.INVALID_LEVEL) {\n                        throw new TransactionException(\"Tried to execute nested @Transaction(\" + isolation + \"), \" +\n                                \"but already running in a transaction with isolation level \" + currentLevel + \".\");\n                    }\n                    if (h.isReadOnly() && !readOnly) {\n                        throw new TransactionException(\"Tried to execute a nested @Transaction(readOnly=false) \"\n                                + \"inside a readOnly transaction\");\n                    }\n                    return base.invoke(target, args, handle);\n                }\n\n                HandleCallback<Object, Exception> callback = th -> base.invoke(target, args, handle);\n\n                final boolean flipReadOnly = readOnly != h.isReadOnly();\n                if (flipReadOnly) {\n                    h.setReadOnly(readOnly);\n                }\n\n                try {\n                    if (isolation == TransactionIsolationLevel.INVALID_LEVEL) {\n                        return h.inTransaction(callback);\n                    } else {\n                        return h.inTransaction(isolation, callback);\n                    }\n                } finally {\n                    if (flipReadOnly) {\n                        h.setReadOnly(!readOnly);\n                    }\n                }\n            };\n        }\n    }\n}\n","lineNo":56}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.CallableStatement;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\n\n/**\n * Used for invoking stored procedures.\n */\npublic class Call extends SqlStatement<Call>\n{\n    private final List<OutParamArgument> params = new ArrayList<>();\n\n    public Call(Handle handle, String sql)\n    {\n        super(handle, sql);\n    }\n\n    /**\n     * Register a positional output parameter\n     * @param position the parameter position (zero-based)\n     * @param sqlType an SQL type constant as defined by {@link java.sql.Types} or by the JDBC vendor.\n     * @return self\n     */\n    public Call registerOutParameter(int position, int sqlType)\n    {\n        return registerOutParameter(position, sqlType, null);\n    }\n\n    /**\n     * Register a positional output parameter\n     * @param position the parameter position (zero-based)\n     * @param sqlType an SQL type constant as defined by {@link java.sql.Types} or by the JDBC vendor.\n     * @param mapper a mapper which converts the {@link CallableStatement} to a desired output type.\n     * @return self\n     */\n    public Call registerOutParameter(int position, int sqlType, CallableStatementMapper mapper)\n    {\n        getBinding().addPositional(position, new OutParamArgument(sqlType, mapper, null));\n        return this;\n    }\n\n    /**\n     * Register a named output parameter\n     * @param name the parameter name\n     * @param sqlType an SQL type constant as defined by {@link java.sql.Types} or by the JDBC vendor.\n     * @return self\n     */\n    public Call registerOutParameter(String name, int sqlType)\n    {\n        return registerOutParameter(name, sqlType, null);\n    }\n\n    /**\n     * Register a named output parameter\n     * @param name the parameter name\n     * @param sqlType an SQL type constant as defined by {@link java.sql.Types} or by the JDBC vendor.\n     * @param mapper a mapper which converts the {@link CallableStatement} to a desired output type.\n     * @return self\n     */\n    public Call registerOutParameter(String name, int sqlType, CallableStatementMapper mapper)\n    {\n        getBinding().addNamed(name, new OutParamArgument(sqlType, mapper, name));\n        return this;\n    }\n\n    /**\n     * Invoke the callable statement\n     * @return the output parameters resulting from the invocation.\n     */\n    public OutParameters invoke()\n    {\n        try {\n            final PreparedStatement stmt = this.internalExecute();\n            OutParameters out = new OutParameters();\n            for ( OutParamArgument param : params ) {\n                Object obj = param.map((CallableStatement)stmt);\n                out.getMap().put(param.position, obj);\n                if ( param.name != null ) {\n                    out.getMap().put(param.name, obj);\n                }\n            }\n            return out;\n        }\n        finally {\n            close();\n        }\n    }\n\n    private class OutParamArgument implements Argument\n    {\n        private final int sqlType;\n        private final CallableStatementMapper mapper;\n        private final String name;\n        private int position ;\n\n        OutParamArgument(int sqlType, CallableStatementMapper mapper, String name)\n        {\n            this.sqlType = sqlType;\n            this.mapper = mapper;\n            this.name = name;\n            params.add(this);\n        }\n\n        @Override\n        public void apply(int position, PreparedStatement statement, StatementContext ctx) throws SQLException\n        {\n            ((CallableStatement)statement).registerOutParameter(position, sqlType);\n            this.position = position;\n        }\n\n        public Object map(CallableStatement stmt)\n        {\n            try {\n                if ( mapper != null ) {\n                    return mapper.map(position, stmt);\n                }\n                switch ( sqlType ) {\n                    case Types.CLOB : case Types.VARCHAR :\n                    case Types.LONGNVARCHAR :\n                    case Types.LONGVARCHAR :\n                    case Types.NCLOB :\n                    case Types.NVARCHAR :\n                        return stmt.getString(position) ;\n                    case Types.BLOB :\n                    case Types.VARBINARY :\n                        return stmt.getBytes(position) ;\n                    case Types.SMALLINT :\n                        return stmt.getShort(position);\n                    case Types.INTEGER :\n                        return stmt.getInt(position);\n                    case Types.BIGINT :\n                        return stmt.getLong(position);\n                    case Types.TIMESTAMP : case Types.TIME :\n                        return stmt.getTimestamp(position) ;\n                    case Types.DATE :\n                        return stmt.getDate(position) ;\n                    case Types.FLOAT :\n                        return stmt.getFloat(position);\n                    case Types.DECIMAL : case Types.DOUBLE :\n                        return stmt.getDouble(position);\n                    default :\n                        return stmt.getObject(position);\n                }\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Could not get OUT parameter from statement\", e, getContext());\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.CallableStatement;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.argument.Argument;\n\n/**\n * Used for invoking stored procedures.\n */\npublic class Call extends SqlStatement<Call>\n{\n    private final List<OutParamArgument> params = new ArrayList<>();\n\n    public Call(Handle handle, String sql)\n    {\n        super(handle, sql);\n    }\n\n    /**\n     * Register a positional output parameter\n     * @param position the parameter position (zero-based)\n     * @param sqlType an SQL type constant as defined by {@link java.sql.Types} or by the JDBC vendor.\n     * @return self\n     */\n    public Call registerOutParameter(int position, int sqlType)\n    {\n        return registerOutParameter(position, sqlType, null);\n    }\n\n    /**\n     * Register a positional output parameter\n     * @param position the parameter position (zero-based)\n     * @param sqlType an SQL type constant as defined by {@link java.sql.Types} or by the JDBC vendor.\n     * @param mapper a mapper which converts the {@link CallableStatement} to a desired output type.\n     * @return self\n     */\n    public Call registerOutParameter(int position, int sqlType, CallableStatementMapper mapper)\n    {\n        getBinding().addPositional(position, new OutParamArgument(sqlType, mapper, null));\n        return this;\n    }\n\n    /**\n     * Register a named output parameter\n     * @param name the parameter name\n     * @param sqlType an SQL type constant as defined by {@link java.sql.Types} or by the JDBC vendor.\n     * @return self\n     */\n    public Call registerOutParameter(String name, int sqlType)\n    {\n        return registerOutParameter(name, sqlType, null);\n    }\n\n    /**\n     * Register a named output parameter\n     * @param name the parameter name\n     * @param sqlType an SQL type constant as defined by {@link java.sql.Types} or by the JDBC vendor.\n     * @param mapper a mapper which converts the {@link CallableStatement} to a desired output type.\n     * @return self\n     */\n    public Call registerOutParameter(String name, int sqlType, CallableStatementMapper mapper)\n    {\n        getBinding().addNamed(name, new OutParamArgument(sqlType, mapper, name));\n        return this;\n    }\n\n    /**\n     * Invoke the callable statement\n     * @return the output parameters resulting from the invocation.\n     */\n    public OutParameters invoke()\n    {\n        try {\n            final PreparedStatement stmt = this.internalExecute();\n            OutParameters out = new OutParameters();\n            for ( OutParamArgument param : params ) {\n                Object obj = param.map((CallableStatement)stmt);\n\n                // convert from JDBC 1-based position to JDBI's 0-based\n                int index = param.position - 1;\n                out.getMap().put(index, obj);\n\n                if ( param.name != null ) {\n                    out.getMap().put(param.name, obj);\n                }\n            }\n            return out;\n        }\n        finally {\n            close();\n        }\n    }\n\n    private class OutParamArgument implements Argument\n    {\n        private final int sqlType;\n        private final CallableStatementMapper mapper;\n        private final String name;\n        private int position ;\n\n        OutParamArgument(int sqlType, CallableStatementMapper mapper, String name)\n        {\n            this.sqlType = sqlType;\n            this.mapper = mapper;\n            this.name = name;\n            params.add(this);\n        }\n\n        @Override\n        public void apply(int position, PreparedStatement statement, StatementContext ctx) throws SQLException\n        {\n            ((CallableStatement)statement).registerOutParameter(position, sqlType);\n            this.position = position;\n        }\n\n        public Object map(CallableStatement stmt)\n        {\n            try {\n                if ( mapper != null ) {\n                    return mapper.map(position, stmt);\n                }\n                switch ( sqlType ) {\n                    case Types.CLOB : case Types.VARCHAR :\n                    case Types.LONGNVARCHAR :\n                    case Types.LONGVARCHAR :\n                    case Types.NCLOB :\n                    case Types.NVARCHAR :\n                        return stmt.getString(position) ;\n                    case Types.BLOB :\n                    case Types.VARBINARY :\n                        return stmt.getBytes(position) ;\n                    case Types.SMALLINT :\n                        return stmt.getShort(position);\n                    case Types.INTEGER :\n                        return stmt.getInt(position);\n                    case Types.BIGINT :\n                        return stmt.getLong(position);\n                    case Types.TIMESTAMP : case Types.TIME :\n                        return stmt.getTimestamp(position) ;\n                    case Types.DATE :\n                        return stmt.getDate(position) ;\n                    case Types.FLOAT :\n                        return stmt.getFloat(position);\n                    case Types.DECIMAL : case Types.DOUBLE :\n                        return stmt.getDouble(position);\n                    default :\n                        return stmt.getObject(position);\n                }\n            } catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Could not get OUT parameter from statement\", e, getContext());\n            }\n        }\n    }\n}\n","lineNo":99}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.result;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.function.Supplier;\n\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * Commonly used ResultProducer implementations.\n */\npublic class ResultProducers {\n    /**\n     * Result producer that eagerly executes the statement, returning the update count\n     *\n     * @return update count\n     * @see PreparedStatement#getUpdateCount()\n     */\n    public static ResultProducer<Integer> returningUpdateCount() {\n        return (statementSupplier, ctx) -> {\n            try {\n                return statementSupplier.get().getUpdateCount();\n            } finally {\n                ctx.close();\n            }\n        };\n    }\n\n    /**\n     * Result producer that returns a {@link ResultSetIterable} over the statement result rows.\n     *\n     * @return ResultSetIterable of result rows.\n     * @see PreparedStatement#getResultSet()\n     */\n    public static ResultProducer<ResultSetIterable> returningResults() {\n        return (supplier, ctx) -> ResultSetIterable.of(getResultSet(supplier, ctx), ctx);\n    }\n\n    private static Supplier<ResultSet> getResultSet(Supplier<PreparedStatement> supplier, StatementContext ctx) {\n        return () -> {\n            try {\n                ResultSet rs = supplier.get().getResultSet();\n\n                if (rs == null) {\n                    throw new NoResultsException(\"Statement returned no results\", ctx);\n                }\n\n                ctx.addCleanable(rs::close);\n\n                return rs;\n            } catch (SQLException e) {\n                throw new ResultSetException(\"Could not get result set\", e, ctx);\n            }\n        };\n    }\n\n    /**\n     * Result producer that returns a {@link ResultSetIterable} over the statement-generated keys.\n     *\n     * @param generatedKeyColumnNames optional list of generated key column names.\n     * @return ResultSetIterable of generated keys\n     * @see PreparedStatement#getGeneratedKeys()\n     */\n    public static ResultProducer<ResultSetIterable> returningGeneratedKeys(String... generatedKeyColumnNames) {\n        return (supplier, ctx) -> {\n            ctx.setReturningGeneratedKeys(true);\n\n            if (generatedKeyColumnNames.length > 0) {\n                ctx.setGeneratedKeysColumnNames(generatedKeyColumnNames);\n            }\n\n            return ResultSetIterable.of(getGeneratedKeys(supplier, ctx), ctx);\n        };\n    }\n\n    private static Supplier<ResultSet> getGeneratedKeys(Supplier<PreparedStatement> supplier, StatementContext ctx) {\n        return () -> {\n            try {\n                ResultSet rs = supplier.get().getGeneratedKeys();\n\n                if (rs == null) {\n                    throw new NoResultsException(\"Statement returned no generated keys\", ctx);\n                }\n\n                ctx.addCleanable(rs::close);\n\n                return rs;\n            } catch (SQLException e) {\n                throw new ResultSetException(\"Could not get generated keys\", e, ctx);\n            }\n        };\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.result;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.function.Supplier;\n\nimport org.jdbi.v3.core.statement.StatementConfiguration;\nimport org.jdbi.v3.core.statement.StatementContext;\n\n/**\n * Commonly used ResultProducer implementations.\n */\npublic class ResultProducers {\n    /**\n     * Result producer that eagerly executes the statement, returning the update count\n     *\n     * @return update count\n     * @see PreparedStatement#getUpdateCount()\n     */\n    public static ResultProducer<Integer> returningUpdateCount() {\n        return (statementSupplier, ctx) -> {\n            try {\n                return statementSupplier.get().getUpdateCount();\n            } finally {\n                ctx.close();\n            }\n        };\n    }\n\n    /**\n     * Result producer that returns a {@link ResultSetIterable} over the statement result rows.\n     *\n     * @return ResultSetIterable of result rows.\n     * @see PreparedStatement#getResultSet()\n     */\n    public static ResultProducer<ResultSetIterable> returningResults() {\n        return (supplier, ctx) -> ResultSetIterable.of(getResultSet(supplier, ctx), ctx);\n    }\n\n    private static Supplier<ResultSet> getResultSet(Supplier<PreparedStatement> supplier, StatementContext ctx) {\n        return () -> {\n            try {\n                ResultSet rs = supplier.get().getResultSet();\n\n                if (rs == null) {\n                    throw new NoResultsException(\"Statement returned no results\", ctx);\n                }\n\n                ctx.addCleanable(rs::close);\n\n                return rs;\n            } catch (SQLException e) {\n                throw new ResultSetException(\"Could not get result set\", e, ctx);\n            }\n        };\n    }\n\n    /**\n     * Result producer that returns a {@link ResultSetIterable} over the statement-generated keys.\n     *\n     * @param generatedKeyColumnNames optional list of generated key column names.\n     * @return ResultSetIterable of generated keys\n     * @see PreparedStatement#getGeneratedKeys()\n     */\n    public static ResultProducer<ResultSetIterable> returningGeneratedKeys(String... generatedKeyColumnNames) {\n        return (supplier, ctx) -> {\n            StatementConfiguration cfg = ctx.getConfig(StatementConfiguration.class);\n            cfg.setReturningGeneratedKeys(true);\n\n            if (generatedKeyColumnNames.length > 0) {\n                cfg.setGeneratedKeysColumnNames(generatedKeyColumnNames);\n            }\n\n            return ResultSetIterable.of(getGeneratedKeys(supplier, ctx), ctx);\n        };\n    }\n\n    private static Supplier<ResultSet> getGeneratedKeys(Supplier<PreparedStatement> supplier, StatementContext ctx) {\n        return () -> {\n            try {\n                ResultSet rs = supplier.get().getGeneratedKeys();\n\n                if (rs == null) {\n                    throw new NoResultsException(\"Statement returned no generated keys\", ctx);\n                }\n\n                ctx.addCleanable(rs::close);\n\n                return rs;\n            } catch (SQLException e) {\n                throw new ResultSetException(\"Could not get generated keys\", e, ctx);\n            }\n        };\n    }\n\n}\n","lineNo":81}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.CallableStatement;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n/**\n * A StatementBuilder which will always create a new PreparedStatement\n */\npublic class DefaultStatementBuilder implements StatementBuilder\n{\n    @Override\n    public Statement create(Connection conn, StatementContext ctx) throws SQLException\n    {\n        return conn.createStatement();\n    }\n\n    /**\n     * Create a new DefaultStatementBuilder which will always create a new PreparedStatement from\n     * the Connection\n     *\n     * @param conn Used to prepare the statement\n     * @param sql  Translated SQL statement\n     * @param ctx  Unused\n     *\n     * @return a new PreparedStatement\n     */\n    @Override\n    public PreparedStatement create(Connection conn, String sql, StatementContext ctx) throws SQLException\n    {\n        if (ctx.isReturningGeneratedKeys()) {\n            String[] columnNames = ctx.getGeneratedKeysColumnNames();\n            if (columnNames != null && columnNames.length > 0) {\n                return conn.prepareStatement(sql, columnNames);\n            }\n            return conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\n        }\n        else if (ctx.isConcurrentUpdatable()) {\n            return conn.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\n        }\n        else {\n            return conn.prepareStatement(sql);\n        }\n    }\n\n    /**\n     * Called to close an individual prepared statement created from this builder.\n     * In this case, it closes immediately\n     *\n     * @param sql  the translated SQL which was prepared\n     * @param stmt the statement\n     *\n     * @throws java.sql.SQLException if anything goes wrong closing the statement\n     */\n    @Override\n    public void close(Connection conn, String sql, Statement stmt) throws SQLException\n    {\n        if (stmt != null) {\n            stmt.close();\n        }\n    }\n\n    /**\n     * In this case, a NOOP\n     */\n    @Override\n    public void close(Connection conn)\n    {\n    }\n\n    /**\n     * Called each time a Callable statement needs to be created\n     *\n     * @param conn the JDBC Connection the statement is being created for\n     * @param sql the translated SQL which should be prepared\n     * @param ctx Statement context associated with the SqlStatement this is building for\n     */\n    @Override\n    public CallableStatement createCall(Connection conn, String sql, StatementContext ctx) throws SQLException\n    {\n        return conn.prepareCall(sql);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.CallableStatement;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n/**\n * A StatementBuilder which will always create a new PreparedStatement\n */\npublic class DefaultStatementBuilder implements StatementBuilder\n{\n    @Override\n    public Statement create(Connection conn, StatementContext ctx) throws SQLException\n    {\n        return conn.createStatement();\n    }\n\n    /**\n     * Create a new DefaultStatementBuilder which will always create a new PreparedStatement from\n     * the Connection\n     *\n     * @param conn Used to prepare the statement\n     * @param sql  Translated SQL statement\n     * @param ctx  Unused\n     *\n     * @return a new PreparedStatement\n     */\n    @Override\n    public PreparedStatement create(Connection conn, String sql, StatementContext ctx) throws SQLException\n    {\n        StatementConfiguration cfg = ctx.getConfig(StatementConfiguration.class);\n        if (cfg.isReturningGeneratedKeys()) {\n            String[] columnNames = cfg.getGeneratedKeysColumnNames();\n            if (columnNames != null && columnNames.length > 0) {\n                return conn.prepareStatement(sql, columnNames);\n            }\n            return conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\n        }\n        else if (cfg.isConcurrentUpdatable()) {\n            return conn.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\n        }\n        else {\n            return conn.prepareStatement(sql);\n        }\n    }\n\n    /**\n     * Called to close an individual prepared statement created from this builder.\n     * In this case, it closes immediately\n     *\n     * @param sql  the translated SQL which was prepared\n     * @param stmt the statement\n     *\n     * @throws java.sql.SQLException if anything goes wrong closing the statement\n     */\n    @Override\n    public void close(Connection conn, String sql, Statement stmt) throws SQLException\n    {\n        if (stmt != null) {\n            stmt.close();\n        }\n    }\n\n    /**\n     * In this case, a NOOP\n     */\n    @Override\n    public void close(Connection conn)\n    {\n    }\n\n    /**\n     * Called each time a Callable statement needs to be created\n     *\n     * @param conn the JDBC Connection the statement is being created for\n     * @param sql the translated SQL which should be prepared\n     * @param ctx Statement context associated with the SqlStatement this is building for\n     */\n    @Override\n    public CallableStatement createCall(Connection conn, String sql, StatementContext ctx) throws SQLException\n    {\n        return conn.prepareCall(sql);\n    }\n}\n","lineNo":47}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMappers;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.StatementContextAccess;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class StatementContextTest {\n\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testShouldNotBeAbleToCombineGeneratedKeysAndConcurrentUpdatable() throws Exception {\n        final StatementContext context = StatementContextAccess.createContext();\n\n        context.setReturningGeneratedKeys(true);\n        context.setConcurrentUpdatable(true);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testShouldNotBeAbleToCombineConcurrentUpdatableAndGeneratedKeys() throws Exception {\n        final StatementContext context = StatementContextAccess.createContext();\n\n        context.setConcurrentUpdatable(true);\n        context.setReturningGeneratedKeys(true);\n    }\n\n    private static class Foo {\n    }\n\n    private static class FooMapper implements ColumnMapper<Foo> {\n        @Override\n        public Foo map(ResultSet r, int columnNumber, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n\n    @Test\n    public void testMapperForDelegatesToRegistry() {\n        ColumnMapper<Foo> mapper = new FooMapper();\n\n        ConfigRegistry config = new ConfigRegistry();\n        config.get(ColumnMappers.class).register(mapper);\n\n        final StatementContext context = StatementContextAccess.createContext(config);\n\n        assertThat(context.findColumnMapperFor(Foo.class)).contains(mapper);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMappers;\nimport org.junit.Test;\n\npublic class StatementContextTest {\n\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testShouldNotBeAbleToCombineGeneratedKeysAndConcurrentUpdatable() throws Exception {\n        final StatementContext context = StatementContextAccess.createContext();\n        final StatementConfiguration cfg = context.getConfig(StatementConfiguration.class);\n\n        cfg.setReturningGeneratedKeys(true);\n        cfg.setConcurrentUpdatable(true);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testShouldNotBeAbleToCombineConcurrentUpdatableAndGeneratedKeys() throws Exception {\n        final StatementContext context = StatementContextAccess.createContext();\n        final StatementConfiguration cfg = context.getConfig(StatementConfiguration.class);\n\n        cfg.setConcurrentUpdatable(true);\n        cfg.setReturningGeneratedKeys(true);\n    }\n\n    private static class Foo {\n    }\n\n    private static class FooMapper implements ColumnMapper<Foo> {\n        @Override\n        public Foo map(ResultSet r, int columnNumber, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n\n    @Test\n    public void testMapperForDelegatesToRegistry() {\n        ColumnMapper<Foo> mapper = new FooMapper();\n\n        ConfigRegistry config = new ConfigRegistry();\n        config.get(ColumnMappers.class).register(mapper);\n\n        final StatementContext context = StatementContextAccess.createContext(config);\n\n        assertThat(context.findColumnMapperFor(Foo.class)).contains(mapper);\n    }\n}\n","lineNo":32}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMappers;\nimport org.jdbi.v3.core.statement.StatementContext;\nimport org.jdbi.v3.core.statement.StatementContextAccess;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class StatementContextTest {\n\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testShouldNotBeAbleToCombineGeneratedKeysAndConcurrentUpdatable() throws Exception {\n        final StatementContext context = StatementContextAccess.createContext();\n\n        context.setReturningGeneratedKeys(true);\n        context.setConcurrentUpdatable(true);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testShouldNotBeAbleToCombineConcurrentUpdatableAndGeneratedKeys() throws Exception {\n        final StatementContext context = StatementContextAccess.createContext();\n\n        context.setConcurrentUpdatable(true);\n        context.setReturningGeneratedKeys(true);\n    }\n\n    private static class Foo {\n    }\n\n    private static class FooMapper implements ColumnMapper<Foo> {\n        @Override\n        public Foo map(ResultSet r, int columnNumber, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n\n    @Test\n    public void testMapperForDelegatesToRegistry() {\n        ColumnMapper<Foo> mapper = new FooMapper();\n\n        ConfigRegistry config = new ConfigRegistry();\n        config.get(ColumnMappers.class).register(mapper);\n\n        final StatementContext context = StatementContextAccess.createContext(config);\n\n        assertThat(context.findColumnMapperFor(Foo.class)).contains(mapper);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.statement;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.core.config.ConfigRegistry;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMappers;\nimport org.junit.Test;\n\npublic class StatementContextTest {\n\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testShouldNotBeAbleToCombineGeneratedKeysAndConcurrentUpdatable() throws Exception {\n        final StatementContext context = StatementContextAccess.createContext();\n        final StatementConfiguration cfg = context.getConfig(StatementConfiguration.class);\n\n        cfg.setReturningGeneratedKeys(true);\n        cfg.setConcurrentUpdatable(true);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testShouldNotBeAbleToCombineConcurrentUpdatableAndGeneratedKeys() throws Exception {\n        final StatementContext context = StatementContextAccess.createContext();\n        final StatementConfiguration cfg = context.getConfig(StatementConfiguration.class);\n\n        cfg.setConcurrentUpdatable(true);\n        cfg.setReturningGeneratedKeys(true);\n    }\n\n    private static class Foo {\n    }\n\n    private static class FooMapper implements ColumnMapper<Foo> {\n        @Override\n        public Foo map(ResultSet r, int columnNumber, StatementContext ctx) throws SQLException {\n            return null;\n        }\n    }\n\n    @Test\n    public void testMapperForDelegatesToRegistry() {\n        ColumnMapper<Foo> mapper = new FooMapper();\n\n        ConfigRegistry config = new ConfigRegistry();\n        config.get(ColumnMappers.class).register(mapper);\n\n        final StatementContext context = StatementContextAccess.createContext(config);\n\n        assertThat(context.findColumnMapperFor(Foo.class)).contains(mapper);\n    }\n}\n","lineNo":41}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Collector;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Query;\nimport org.jdbi.v3.core.ResultBearing;\nimport org.jdbi.v3.core.ResultIterable;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.util.GenericTypes;\nimport org.jdbi.v3.sqlobject.customizers.UseRowMapper;\n\nabstract class ResultReturner\n{\n    public Object map(Method method, Query<?> q)\n    {\n        if (method.isAnnotationPresent(UseRowMapper.class)) {\n            final RowMapper<?> mapper;\n            try {\n                mapper = method.getAnnotation(UseRowMapper.class).value().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"unable to access mapper\", e, null);\n            }\n            return result(q.map(mapper));\n        }\n        else {\n            return result(q.mapTo(elementType(q.getContext())));\n        }\n    }\n\n    static ResultReturner forOptionalReturn(Class<?> extensionType, Method method)\n    {\n        if (method.getReturnType() == void.class) {\n            return new ResultReturner() {\n                @Override\n                protected Object result(ResultIterable<?> bearer) {\n                    bearer.stream().forEach(i -> {}); // Make sure to consume the result\n                    return null;\n                }\n                @Override\n                protected Type elementType(StatementContext ctx) {\n                    return null;\n                }\n            };\n        }\n        return forMethod(extensionType, method);\n    }\n\n    static ResultReturner forMethod(Class<?> extensionType, Method method)\n    {\n        Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), extensionType);\n        Class<?> returnClass = GenericTypes.getErasedType(returnType);\n        if (Void.TYPE.equals(returnClass)) {\n            throw new IllegalStateException(String.format(\n                    \"Method %s#%s is annotated as if it should return a value, but the method is void.\",\n                    method.getDeclaringClass().getName(),\n                    method.getName()));\n        }\n        else if (ResultBearing.class.isAssignableFrom(returnClass)) {\n            return new ResultBearingResultReturner(returnType);\n        }\n        else if (Stream.class.isAssignableFrom(returnClass)) {\n            return new StreamReturner(returnType);\n        }\n        else if (Iterator.class.isAssignableFrom(returnClass)) {\n            return new IteratorResultReturner(returnType);\n        }\n        else if (method.isAnnotationPresent(SingleValue.class)) {\n            return new SingleValueResultReturner(returnType);\n        }\n        else if (returnClass.isArray()) {\n            return new ArrayResultReturner(returnClass.getComponentType());\n        }\n        else {\n            return new DefaultResultReturner(returnType);\n        }\n    }\n\n    protected abstract Object result(ResultIterable<?> bearer);\n\n    static RowMapper<?> rowMapperFor(GetGeneratedKeys ggk, Type returnType) {\n        if (DefaultGeneratedKeyMapper.class.equals(ggk.value())) {\n            return new DefaultGeneratedKeyMapper(returnType, ggk.columnName());\n        }\n        else {\n            try {\n                return ggk.value().getConstructor().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"Unable to instantiate row mapper for statement\", e, null);\n            }\n        }\n    }\n\n    protected abstract Type elementType(StatementContext ctx);\n\n    static class StreamReturner extends ResultReturner\n    {\n        private final Type elementType;\n\n        StreamReturner(Type returnType)\n        {\n            elementType = GenericTypes.findGenericParameter(returnType, Stream.class)\n                    .orElseThrow(() -> new IllegalStateException(\n                            \"Cannot reflect Stream<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Stream<?> result(ResultIterable<?> bearer) {\n            return bearer.stream();\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n\n    static class DefaultResultReturner extends ResultReturner\n    {\n        private final Type returnType;\n\n        DefaultResultReturner(Type returnType)\n        {\n            this.returnType = returnType;\n        }\n\n        @Override\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        protected Object result(ResultIterable<?> bearer)\n        {\n            Collector collector = bearer.getContext().findCollectorFor(returnType).orElse(null);\n            if (collector != null) {\n                return bearer.collect(collector);\n            }\n            return bearer.findFirst().orElse(null);\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx)\n        {\n            // if returnType is not supported by a collector factory, assume it to be a single-value return type.\n            return ctx.findElementTypeFor(returnType).orElse(returnType);\n        }\n    }\n\n    static class SingleValueResultReturner extends ResultReturner\n    {\n        private final Type returnType;\n\n        SingleValueResultReturner(Type returnType)\n        {\n            this.returnType = returnType;\n        }\n\n        @Override\n        protected Object result(ResultIterable<?> bearer)\n        {\n            return bearer.findFirst().orElse(null);\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx)\n        {\n            return returnType;\n        }\n    }\n\n    static class ResultBearingResultReturner extends ResultReturner\n    {\n\n        private final Type elementType;\n\n        ResultBearingResultReturner(Type returnType)\n        {\n            // extract T from Query<T>\n            elementType = GenericTypes.findGenericParameter(returnType, Query.class)\n                    .orElseThrow(() -> new IllegalStateException(\n                            \"Cannot reflect Query<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Object result(ResultIterable<?> bearer)\n        {\n            return bearer;\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx)\n        {\n            return elementType;\n        }\n    }\n\n    static class IteratorResultReturner extends ResultReturner\n    {\n        private final Type elementType;\n\n        IteratorResultReturner(Type returnType)\n        {\n            this.elementType = GenericTypes.findGenericParameter(returnType, Iterator.class)\n                    .orElseThrow(() -> new IllegalStateException(\n                            \"Cannot reflect Iterator<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Object result(ResultIterable<?> bearer)\n        {\n            return bearer.iterator();\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx)\n        {\n            return elementType;\n        }\n    }\n\n    static class ArrayResultReturner extends ResultReturner\n    {\n        private final Class<?> componentType;\n\n        ArrayResultReturner(Class<?> componentType) {\n            this.componentType = componentType;\n        }\n\n        @Override\n        protected Object result(ResultIterable<?> bearer) {\n            final List<?> list = bearer.list();\n            Object result = Array.newInstance(componentType, list.size());\n            for (int i = 0; i < list.size(); i++) {\n                Array.set(result, i, list.get(i));\n            }\n            return result;\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return componentType;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Collector;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Query;\nimport org.jdbi.v3.core.ResultIterable;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.util.GenericTypes;\nimport org.jdbi.v3.sqlobject.customizers.UseRowMapper;\n\nabstract class ResultReturner\n{\n    public Object map(Method method, Query q)\n    {\n        StatementContext ctx = q.getContext();\n        if (method.isAnnotationPresent(UseRowMapper.class)) {\n            final RowMapper<?> mapper;\n            try {\n                mapper = method.getAnnotation(UseRowMapper.class).value().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"unable to access mapper\", e, null);\n            }\n            return result(q.map(mapper), ctx);\n        }\n        else {\n            return result(q.mapTo(elementType(ctx)), ctx);\n        }\n    }\n\n    static ResultReturner forOptionalReturn(Class<?> extensionType, Method method)\n    {\n        if (method.getReturnType() == void.class) {\n            return new ResultReturner() {\n                @Override\n                protected Object result(ResultIterable<?> bearer, StatementContext ctx) {\n                    bearer.stream().forEach(i -> {}); // Make sure to consume the result\n                    return null;\n                }\n                @Override\n                protected Type elementType(StatementContext ctx) {\n                    return null;\n                }\n            };\n        }\n        return forMethod(extensionType, method);\n    }\n\n    static ResultReturner forMethod(Class<?> extensionType, Method method)\n    {\n        Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), extensionType);\n        Class<?> returnClass = GenericTypes.getErasedType(returnType);\n        if (Void.TYPE.equals(returnClass)) {\n            throw new IllegalStateException(String.format(\n                    \"Method %s#%s is annotated as if it should return a value, but the method is void.\",\n                    method.getDeclaringClass().getName(),\n                    method.getName()));\n        }\n        else if (ResultIterable.class.isAssignableFrom(returnClass)) {\n            return new ResultIterableResultReturner(returnType);\n        }\n        else if (Stream.class.isAssignableFrom(returnClass)) {\n            return new StreamReturner(returnType);\n        }\n        else if (Iterator.class.isAssignableFrom(returnClass)) {\n            return new IteratorResultReturner(returnType);\n        }\n        else if (method.isAnnotationPresent(SingleValue.class)) {\n            return new SingleValueResultReturner(returnType);\n        }\n        else if (returnClass.isArray()) {\n            return new ArrayResultReturner(returnClass.getComponentType());\n        }\n        else {\n            return new DefaultResultReturner(returnType);\n        }\n    }\n\n    protected abstract Object result(ResultIterable<?> bearer, StatementContext ctx);\n\n    static RowMapper<?> rowMapperFor(GetGeneratedKeys ggk, Type returnType) {\n        if (DefaultGeneratedKeyMapper.class.equals(ggk.value())) {\n            return new DefaultGeneratedKeyMapper(returnType, ggk.columnName());\n        }\n        else {\n            try {\n                return ggk.value().getConstructor().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"Unable to instantiate row mapper for statement\", e, null);\n            }\n        }\n    }\n\n    protected abstract Type elementType(StatementContext ctx);\n\n    static class StreamReturner extends ResultReturner\n    {\n        private final Type elementType;\n\n        StreamReturner(Type returnType)\n        {\n            elementType = GenericTypes.findGenericParameter(returnType, Stream.class)\n                    .orElseThrow(() -> new IllegalStateException(\n                            \"Cannot reflect Stream<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Stream<?> result(ResultIterable<?> bearer, StatementContext ctx) {\n            return bearer.stream();\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return elementType;\n        }\n    }\n\n    static class DefaultResultReturner extends ResultReturner\n    {\n        private final Type returnType;\n\n        DefaultResultReturner(Type returnType)\n        {\n            this.returnType = returnType;\n        }\n\n        @Override\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        protected Object result(ResultIterable<?> bearer, StatementContext ctx)\n        {\n            Collector collector = ctx.findCollectorFor(returnType).orElse(null);\n            if (collector != null) {\n                return bearer.collect(collector);\n            }\n            return bearer.findFirst().orElse(null);\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx)\n        {\n            // if returnType is not supported by a collector factory, assume it to be a single-value return type.\n            return ctx.findElementTypeFor(returnType).orElse(returnType);\n        }\n    }\n\n    static class SingleValueResultReturner extends ResultReturner\n    {\n        private final Type returnType;\n\n        SingleValueResultReturner(Type returnType)\n        {\n            this.returnType = returnType;\n        }\n\n        @Override\n        protected Object result(ResultIterable<?> bearer, StatementContext ctx)\n        {\n            return bearer.findFirst().orElse(null);\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx)\n        {\n            return returnType;\n        }\n    }\n\n    static class ResultIterableResultReturner extends ResultReturner\n    {\n\n        private final Type elementType;\n\n        ResultIterableResultReturner(Type returnType)\n        {\n            // extract T from Query<T>\n            elementType = GenericTypes.findGenericParameter(returnType, ResultIterable.class)\n                    .orElseThrow(() -> new IllegalStateException(\n                            \"Cannot reflect ResultIterable<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Object result(ResultIterable<?> bearer, StatementContext ctx)\n        {\n            return bearer;\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx)\n        {\n            return elementType;\n        }\n    }\n\n    static class IteratorResultReturner extends ResultReturner\n    {\n        private final Type elementType;\n\n        IteratorResultReturner(Type returnType)\n        {\n            this.elementType = GenericTypes.findGenericParameter(returnType, Iterator.class)\n                    .orElseThrow(() -> new IllegalStateException(\n                            \"Cannot reflect Iterator<T> element type T in method return type \" + returnType));\n        }\n\n        @Override\n        protected Object result(ResultIterable<?> bearer, StatementContext ctx)\n        {\n            return bearer.iterator();\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx)\n        {\n            return elementType;\n        }\n    }\n\n    static class ArrayResultReturner extends ResultReturner\n    {\n        private final Class<?> componentType;\n\n        ArrayResultReturner(Class<?> componentType) {\n            this.componentType = componentType;\n        }\n\n        @Override\n        protected Object result(ResultIterable<?> bearer, StatementContext ctx) {\n            final List<?> list = bearer.list();\n            Object result = Array.newInstance(componentType, list.size());\n            for (int i = 0; i < list.size(); i++) {\n                Array.set(result, i, list.get(i));\n            }\n            return result;\n        }\n\n        @Override\n        protected Type elementType(StatementContext ctx) {\n            return componentType;\n        }\n    }\n}\n","lineNo":36}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.function.Function;\n\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\nimport org.jdbi.v3.core.exception.UnableToExecuteStatementException;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.rewriter.RewrittenStatement;\nimport org.jdbi.v3.core.statement.SqlStatements;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.StatementCustomizer;\nimport org.jdbi.v3.core.util.GenericType;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Represents a prepared batch statement. That is, a sql statement compiled as a prepared\n * statement, and then executed multiple times in a single batch. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch>\n{\n    private static final Logger LOG = LoggerFactory.getLogger(PreparedBatch.class);\n\n    private final List<PreparedBatchPart> parts = new ArrayList<>();\n    private Binding currentBinding;\n\n    PreparedBatch(ConfigRegistry config,\n                  Handle handle,\n                  StatementBuilder statementBuilder,\n                  String sql,\n                  StatementContext ctx,\n                  Collection<StatementCustomizer> statementCustomizers)\n    {\n        super(config, new Binding(), handle, statementBuilder, sql, ctx, statementCustomizers);\n        this.currentBinding = new Binding();\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        return (int[]) internalBatchExecute(null, null);\n    }\n\n    public ResultIterator<Integer> executeAndGetModCount() {\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                throw new UnsupportedOperationException(\"TODO XXX\");\n            }\n\n            @Override\n            public void close() {\n            }\n        };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final RowMapper<GeneratedKeyType> mapper) {\n        return (GeneratedKeys<GeneratedKeyType>) internalBatchExecute(results ->\n                new GeneratedKeys<>(mapper,\n                                    PreparedBatch.this,\n                                    results,\n                                    getContext()), null);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final RowMapper<GeneratedKeyType> mapper,\n                                                                                     String... columnNames) {\n        return (GeneratedKeys<GeneratedKeyType>) internalBatchExecute(results ->\n                new GeneratedKeys<>(mapper,\n                        PreparedBatch.this,\n                        results,\n                        getContext()), columnNames);\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final ColumnMapper<GeneratedKeyType> mapper) {\n        return executeAndGenerateKeys(new SingleColumnMapper<>(mapper));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(GenericType<GeneratedKeyType> generatedKeyType) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(Class<GeneratedKeyType> generatedKeyType) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(Class<GeneratedKeyType> generatedKeyType,\n                                                                                     String... columnNames) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType), columnNames);\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(ColumnMapper<GeneratedKeyType> mapper,\n                                                                                     String columnName) {\n        return executeAndGenerateKeys(new SingleColumnMapper<>(mapper, columnName), new String[] { columnName });\n    }\n\n    private <Result> Object internalBatchExecute(Function<PreparedStatement, Result> munger, String[] columnNames) {\n        boolean generateKeys = munger != null;\n        // short circuit empty batch\n        if (parts.size() == 0) {\n            if (generateKeys) {\n                throw new IllegalArgumentException(\"Unable generate keys for a not prepared batch\");\n            }\n            return new int[]{};\n        }\n\n        PreparedBatchPart current = parts.get(0);\n        final String rawSql = getSql();\n        final RewrittenStatement rewritten = getConfig(SqlStatements.class).getStatementRewriter().rewrite(rawSql, current.getParams(), getContext());\n        PreparedStatement stmt;\n        try {\n            try {\n                Connection connection = getHandle().getConnection();\n                if (generateKeys) {\n                    if (columnNames != null) {\n                        stmt = connection.prepareStatement(rewritten.getSql(), columnNames);\n                    } else  {\n                        stmt = connection.prepareStatement(rewritten.getSql(), Statement.RETURN_GENERATED_KEYS);\n                    }\n                } else {\n                    stmt = connection.prepareStatement(rewritten.getSql(), Statement.NO_GENERATED_KEYS);\n                }\n                addCleanable(Cleanables.forStatement(stmt));\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n\n            try {\n                for (PreparedBatchPart part : parts) {\n                    rewritten.bind(part.getParams(), stmt);\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, getContext());\n            }\n\n            beforeExecution(stmt);\n\n            try {\n                final long start = System.nanoTime();\n                final int[] rs =  stmt.executeBatch();\n                final long elapsedTime = System.nanoTime() - start;\n                LOG.trace(\"Prepared batch of {} parts executed in {}ms\", parts.size(), elapsedTime / 1000000L, rewritten.getSql());\n                getConfig(SqlStatements.class).getTimingCollector().collect(elapsedTime, getContext());\n\n                afterExecution(stmt);\n\n                return generateKeys ? munger.apply(stmt) : rs;\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), getContext());\n            }\n        }\n        finally {\n            try {\n                if (!generateKeys) {\n                    close();\n                }\n            }\n            finally {\n                this.parts.clear();\n            }\n        }\n    }\n\n    /**\n     * Add a statement (part) to this batch. You'll need to bindBinaryStream any arguments to the\n     * part.\n     *\n     * @return A part which can be used to bindBinaryStream parts to the statement\n     */\n    public PreparedBatchPart add()\n    {\n        PreparedBatchPart part = new PreparedBatchPart(getConfig(),\n                                                       this.currentBinding,\n                                                       this,\n                                                       getHandle(),\n                                                       getStatementBuilder(),\n                                                       getSql(),\n                                                       getContext());\n        parts.add(part);\n        this.currentBinding = new Binding();\n        return part;\n    }\n\n    public PreparedBatch add(Object... args)\n    {\n        PreparedBatchPart part = add();\n        for (int i = 0; i < args.length; ++i) {\n            part.bind(i, args[i]);\n        }\n        return this;\n    }\n\n\n    /**\n     * Create a new batch part by binding values looked up in <code>args<\/code> to\n     * named parameters on the statement.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     *\n     * @return the new batch part\n     */\n    public PreparedBatchPart add(Map<String, ?> args)\n    {\n        PreparedBatchPart part = add();\n        part.bindMap(args);\n        return part;\n    }\n\n    /**\n     * @return the number of statements which are in this batch\n     */\n    public int size()\n    {\n        return parts.size();\n    }\n\n    @Override\n    protected Binding getParams()\n    {\n        return this.currentBinding;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.function.Function;\n\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\nimport org.jdbi.v3.core.exception.UnableToExecuteStatementException;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.SingleColumnMapper;\nimport org.jdbi.v3.core.rewriter.RewrittenStatement;\nimport org.jdbi.v3.core.statement.SqlStatements;\nimport org.jdbi.v3.core.statement.StatementBuilder;\nimport org.jdbi.v3.core.statement.StatementCustomizer;\nimport org.jdbi.v3.core.util.GenericType;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Represents a prepared batch statement. That is, a sql statement compiled as a prepared\n * statement, and then executed multiple times in a single batch. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch>\n{\n    private static final Logger LOG = LoggerFactory.getLogger(PreparedBatch.class);\n\n    private final List<PreparedBatchPart> parts = new ArrayList<>();\n    private Binding currentBinding;\n\n    PreparedBatch(ConfigRegistry config,\n                  Handle handle,\n                  StatementBuilder statementBuilder,\n                  String sql,\n                  StatementContext ctx,\n                  Collection<StatementCustomizer> statementCustomizers)\n    {\n        super(config, new Binding(), handle, statementBuilder, sql, ctx, statementCustomizers);\n        this.currentBinding = new Binding();\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        return (int[]) internalBatchExecute(null, null);\n    }\n\n    public ResultIterator<Integer> executeAndGetModCount() {\n        final int[] modCount = execute();\n        return new ResultIterator<Integer>() {\n            int pos = 0;\n            @Override\n            public boolean hasNext() {\n                return pos < modCount.length;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return modCount[pos++];\n            }\n\n            @Override\n            public StatementContext getContext() {\n                throw new UnsupportedOperationException(\"TODO XXX\");\n            }\n\n            @Override\n            public void close() {\n            }\n        };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final RowMapper<GeneratedKeyType> mapper) {\n        return (GeneratedKeys<GeneratedKeyType>) internalBatchExecute(results ->\n                new GeneratedKeys<>(mapper,\n                                    PreparedBatch.this,\n                                    results,\n                                    getContext()), null);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final RowMapper<GeneratedKeyType> mapper,\n                                                                                     String... columnNames) {\n        return (GeneratedKeys<GeneratedKeyType>) internalBatchExecute(results ->\n                new GeneratedKeys<>(mapper,\n                        PreparedBatch.this,\n                        results,\n                        getContext()), columnNames);\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final ColumnMapper<GeneratedKeyType> mapper) {\n        return executeAndGenerateKeys(new SingleColumnMapper<>(mapper));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(GenericType<GeneratedKeyType> generatedKeyType) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(Class<GeneratedKeyType> generatedKeyType) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(Class<GeneratedKeyType> generatedKeyType,\n                                                                                     String... columnNames) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType), columnNames);\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(ColumnMapper<GeneratedKeyType> mapper,\n                                                                                     String columnName) {\n        return executeAndGenerateKeys(new SingleColumnMapper<>(mapper, columnName), new String[] { columnName });\n    }\n\n    private <Result> Object internalBatchExecute(Function<PreparedStatement, Result> munger, String[] columnNames) {\n        boolean generateKeys = munger != null;\n        // short circuit empty batch\n        if (parts.size() == 0) {\n            if (generateKeys) {\n                throw new IllegalArgumentException(\"Unable generate keys for a not prepared batch\");\n            }\n            return new int[]{};\n        }\n\n        PreparedBatchPart current = parts.get(0);\n        final String rawSql = getSql();\n        final RewrittenStatement rewritten = getConfig(SqlStatements.class).getStatementRewriter().rewrite(rawSql, current.getParams(), getContext());\n\n        getContext().setReturningGeneratedKeys(generateKeys);\n        if (columnNames != null) {\n            getContext().setGeneratedKeysColumnNames(columnNames);\n        }\n\n        try {\n            final PreparedStatement stmt;\n            String sql = rewritten.getSql();\n            try {\n                StatementBuilder statementBuilder = getStatementBuilder();\n                Connection connection = getHandle().getConnection();\n                stmt = statementBuilder.create(connection, sql, getContext());\n                addCleanable(Cleanables.forStatementBuilder(statementBuilder, connection, sql, stmt));\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n\n            try {\n                for (PreparedBatchPart part : parts) {\n                    rewritten.bind(part.getParams(), stmt);\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, getContext());\n            }\n\n            beforeExecution(stmt);\n\n            try {\n                final long start = System.nanoTime();\n                final int[] rs =  stmt.executeBatch();\n                final long elapsedTime = System.nanoTime() - start;\n                LOG.trace(\"Prepared batch of {} parts executed in {}ms\", parts.size(), elapsedTime / 1000000L, sql);\n                getConfig(SqlStatements.class).getTimingCollector().collect(elapsedTime, getContext());\n\n                afterExecution(stmt);\n\n                return generateKeys ? munger.apply(stmt) : rs;\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(Batch.mungeBatchException(e), getContext());\n            }\n        }\n        finally {\n            try {\n                if (!generateKeys) {\n                    close();\n                }\n            }\n            finally {\n                this.parts.clear();\n            }\n        }\n    }\n\n    /**\n     * Add a statement (part) to this batch. You'll need to bindBinaryStream any arguments to the\n     * part.\n     *\n     * @return A part which can be used to bindBinaryStream parts to the statement\n     */\n    public PreparedBatchPart add()\n    {\n        PreparedBatchPart part = new PreparedBatchPart(getConfig(),\n                                                       this.currentBinding,\n                                                       this,\n                                                       getHandle(),\n                                                       getStatementBuilder(),\n                                                       getSql(),\n                                                       getContext());\n        parts.add(part);\n        this.currentBinding = new Binding();\n        return part;\n    }\n\n    public PreparedBatch add(Object... args)\n    {\n        PreparedBatchPart part = add();\n        for (int i = 0; i < args.length; ++i) {\n            part.bind(i, args[i]);\n        }\n        return this;\n    }\n\n\n    /**\n     * Create a new batch part by binding values looked up in <code>args<\/code> to\n     * named parameters on the statement.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     *\n     * @return the new batch part\n     */\n    public PreparedBatchPart add(Map<String, ?> args)\n    {\n        PreparedBatchPart part = add();\n        part.bindMap(args);\n        return part;\n    }\n\n    /**\n     * @return the number of statements which are in this batch\n     */\n    public int size()\n    {\n        return parts.size();\n    }\n\n    @Override\n    protected Binding getParams()\n    {\n        return this.currentBinding;\n    }\n}\n","lineNo":162}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.PreparedBatch;\nimport org.jdbi.v3.core.PreparedBatchPart;\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.customizers.BatchChunkSize;\nimport org.jdbi.v3.sqlobject.exceptions.UnableToCreateSqlObjectException;\n\nclass BatchHandler extends CustomizingStatementHandler\n{\n    private final Class<?> sqlObjectType;\n    private final SqlBatch sqlBatch;\n    private final ChunkSizeFunction batchChunkSize;\n    private final Function<PreparedBatch, int[]> returner;\n\n    BatchHandler(Class<?> sqlObjectType, Method method)\n    {\n        super(sqlObjectType, method);\n        this.sqlObjectType = sqlObjectType;\n\n        this.sqlBatch = method.getAnnotation(SqlBatch.class);\n        this.batchChunkSize = determineBatchChunkSize(sqlObjectType, method);\n        final GetGeneratedKeys getGeneratedKeys = method.getAnnotation(GetGeneratedKeys.class);\n\n        if (getGeneratedKeys == null) {\n            if (!returnTypeIsValid(method.getReturnType()) ) {\n                throw new UnableToCreateSqlObjectException(invalidReturnTypeMessage(method));\n            }\n            returner = PreparedBatch::execute;\n        }\n        else {\n            if (getGeneratedKeys.columnName().isEmpty()) {\n                returner = batch -> toPrimitiveArray(\n                        batch.executeAndGenerateKeys(int.class).list());\n            } else {\n                returner = batch -> toPrimitiveArray(\n                        batch.executeAndGenerateKeys(int.class, getGeneratedKeys.columnName()).list());\n            }\n        }\n    }\n\n    private ChunkSizeFunction determineBatchChunkSize(Class<?> sqlObjectType, Method method)\n    {\n        // this next big if chain determines the batch chunk size. It looks from most specific\n        // scope to least, that is: as an argument, then on the method, then on the class,\n        // then default to Integer.MAX_VALUE\n\n        int batchChunkSizeParameterIndex;\n        if ((batchChunkSizeParameterIndex = indexOfBatchChunkSizeParameter(method)) >= 0) {\n            return new ParamBasedChunkSizeFunction(batchChunkSizeParameterIndex);\n        }\n        else if (method.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = method.getAnnotation(BatchChunkSize.class).value();\n            if (size <= 0) {\n                throw new IllegalArgumentException(\"Batch chunk size must be >= 0\");\n            }\n            return new ConstantChunkSizeFunction(size);\n        }\n        else if (sqlObjectType.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = sqlObjectType.getAnnotation(BatchChunkSize.class).value();\n            return new ConstantChunkSizeFunction(size);\n        }\n        else {\n            return new ConstantChunkSizeFunction(Integer.MAX_VALUE);\n        }\n    }\n\n    private int indexOfBatchChunkSizeParameter(Method method)\n    {\n        Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n        return IntStream.range(0, parameterAnnotations.length)\n                        .filter(i -> Stream.of(parameterAnnotations[i]).anyMatch(BatchChunkSize.class::isInstance))\n                        .findFirst()\n                        .orElse(-1);\n    }\n\n    @Override\n    public Object invoke(Object target, Method method, Object[] args, HandleSupplier h)\n    {\n        boolean foundIterator = false;\n        Handle handle = h.getHandle();\n\n        List<Iterator<?>> extras = new ArrayList<>();\n        for (final Object arg : args) {\n            if (arg instanceof Iterable) {\n                extras.add(((Iterable<?>) arg).iterator());\n                foundIterator = true;\n            }\n            else if (arg instanceof Iterator) {\n                extras.add((Iterator<?>) arg);\n                foundIterator = true;\n            }\n            else if (arg.getClass().isArray()) {\n                extras.add(Arrays.asList((Object[])arg).iterator());\n                foundIterator = true;\n            }\n            else {\n                extras.add(Stream.generate(() -> arg).iterator());\n            }\n        }\n\n        if (!foundIterator) {\n            throw new UnableToCreateStatementException(\"@SqlBatch method has no Iterable or array parameters,\"\n                    + \" did you mean @SqlQuery?\", null, null);\n        }\n\n        int processed = 0;\n        List<int[]> rs_parts = new ArrayList<>();\n\n        String sql = handle.getConfig(SqlObjects.class).getSqlLocator().locate(sqlObjectType, method);\n        PreparedBatch batch = handle.prepareBatch(sql);\n        applyCustomizers(batch, args);\n        Object[] _args;\n        int chunk_size = batchChunkSize.call(args);\n\n        while ((_args = next(extras)) != null) {\n            PreparedBatchPart part = batch.add();\n            applyBinders(part, _args);\n\n            if (++processed == chunk_size) {\n                // execute this chunk\n                processed = 0;\n                rs_parts.add(executeBatch(handle, batch));\n                batch = handle.prepareBatch(sql);\n                applyCustomizers(batch, args);\n            }\n        }\n\n        //execute the rest\n        rs_parts.add(executeBatch(handle, batch));\n\n        // combine results\n        int end_size = 0;\n        for (int[] rs_part : rs_parts) {\n            end_size += rs_part.length;\n        }\n        int[] rs = new int[end_size];\n        int offset = 0;\n        for (int[] rs_part : rs_parts) {\n            System.arraycopy(rs_part, 0, rs, offset, rs_part.length);\n            offset += rs_part.length;\n        }\n\n        return rs;\n    }\n\n    private int[] executeBatch(final Handle handle, final PreparedBatch batch)\n    {\n        if (!handle.isInTransaction() && sqlBatch.transactional()) {\n            // it is safe to use same prepared batch as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction((conn, status) -> returner.apply(batch));\n        }\n        else {\n            return returner.apply(batch);\n        }\n    }\n\n    private static int[] toPrimitiveArray(List<Integer> list)\n    {\n        int[] array = new int[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n\n    private static Object[] next(List<Iterator<?>> args)\n    {\n        List<Object> rs = new ArrayList<>();\n        for (Iterator<?> arg : args) {\n            if (arg.hasNext()) {\n                rs.add(arg.next());\n            }\n            else {\n                return null;\n            }\n        }\n        return rs.toArray();\n    }\n\n    private interface Returner\n    {\n        int[] value(PreparedBatch batch);\n    }\n\n    private interface ChunkSizeFunction\n    {\n        int call(Object[] args);\n    }\n\n    private static class ConstantChunkSizeFunction implements ChunkSizeFunction\n    {\n        private final int value;\n\n        ConstantChunkSizeFunction(int value) {\n            this.value = value;\n        }\n\n        @Override\n        public int call(Object[] args)\n        {\n            return value;\n        }\n    }\n\n    private static class ParamBasedChunkSizeFunction implements ChunkSizeFunction\n    {\n        private final int index;\n\n        ParamBasedChunkSizeFunction(int index) {\n            this.index = index;\n        }\n\n        @Override\n        public int call(Object[] args)\n        {\n            return (Integer)args[index];\n        }\n    }\n\n    private static boolean returnTypeIsValid(Class<?> type) {\n        return type.equals(Void.TYPE)\n                || type.isArray() && type.getComponentType().equals(Integer.TYPE);\n\n    }\n\n    private static String invalidReturnTypeMessage(Method method) {\n        return method.getDeclaringClass() + \".\" + method.getName() +\n                \" method is annotated with @SqlBatch so should return void or int[] but is returning: \" +\n                method.getReturnType();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.function.Function;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.PreparedBatch;\nimport org.jdbi.v3.core.ResultBearing;\nimport org.jdbi.v3.core.ResultIterator;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.StatementExecutor;\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.sqlobject.customizers.BatchChunkSize;\nimport org.jdbi.v3.sqlobject.exceptions.UnableToCreateSqlObjectException;\n\nclass BatchHandler extends CustomizingStatementHandler\n{\n    private final Class<?> sqlObjectType;\n    private final SqlBatch sqlBatch;\n    private final ChunkSizeFunction batchChunkSize;\n    private final Function<PreparedBatch, ResultBearing<?>> batchIntermediate;\n    private final ResultReturner magic;\n\n    BatchHandler(Class<?> sqlObjectType, Method method)\n    {\n        super(sqlObjectType, method);\n        this.sqlObjectType = sqlObjectType;\n\n        this.sqlBatch = method.getAnnotation(SqlBatch.class);\n        this.batchChunkSize = determineBatchChunkSize(sqlObjectType, method);\n        final GetGeneratedKeys getGeneratedKeys = method.getAnnotation(GetGeneratedKeys.class);\n\n        if (getGeneratedKeys == null) {\n            if (!returnTypeIsValid(method.getReturnType()) ) {\n                throw new UnableToCreateSqlObjectException(invalidReturnTypeMessage(method));\n            }\n            batchIntermediate = PreparedBatch::executeAndGetModCount;\n            magic = ResultReturner.forOptionalReturn(sqlObjectType, method);\n        }\n        else {\n            magic = ResultReturner.forMethod(sqlObjectType, method);\n            final Function<StatementContext, RowMapper<?>> mapper = ctx -> ResultReturner.rowMapperFor(getGeneratedKeys, magic.elementType(ctx));\n            if (getGeneratedKeys.columnName().isEmpty()) {\n                batchIntermediate = batch -> batch.executeAndGenerateKeys(mapper.apply(batch.getContext()));\n            } else {\n                batchIntermediate = batch -> batch.executeAndGenerateKeys(mapper.apply(batch.getContext()), getGeneratedKeys.columnName());\n            }\n        }\n    }\n\n    private ChunkSizeFunction determineBatchChunkSize(Class<?> sqlObjectType, Method method)\n    {\n        // this next big if chain determines the batch chunk size. It looks from most specific\n        // scope to least, that is: as an argument, then on the method, then on the class,\n        // then default to Integer.MAX_VALUE\n\n        int batchChunkSizeParameterIndex;\n        if ((batchChunkSizeParameterIndex = indexOfBatchChunkSizeParameter(method)) >= 0) {\n            return new ParamBasedChunkSizeFunction(batchChunkSizeParameterIndex);\n        }\n        else if (method.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = method.getAnnotation(BatchChunkSize.class).value();\n            if (size <= 0) {\n                throw new IllegalArgumentException(\"Batch chunk size must be >= 0\");\n            }\n            return new ConstantChunkSizeFunction(size);\n        }\n        else if (sqlObjectType.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = sqlObjectType.getAnnotation(BatchChunkSize.class).value();\n            return new ConstantChunkSizeFunction(size);\n        }\n        else {\n            return new ConstantChunkSizeFunction(Integer.MAX_VALUE);\n        }\n    }\n\n    private int indexOfBatchChunkSizeParameter(Method method)\n    {\n        Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n        return IntStream.range(0, parameterAnnotations.length)\n                        .filter(i -> Stream.of(parameterAnnotations[i]).anyMatch(BatchChunkSize.class::isInstance))\n                        .findFirst()\n                        .orElse(-1);\n    }\n\n    @Override\n    public Object invoke(Object target, Method method, Object[] args, HandleSupplier h)\n    {\n        final Handle handle = h.getHandle();\n        final String sql = handle.getConfig().get(SqlObjects.class)\n                .getSqlLocator().locate(sqlObjectType, method);\n        final int chunkSize = batchChunkSize.call(args);\n        final Iterator<Object[]> batchArgs = zipArgs(args);\n\n        ResultIterator<Object> result = new ResultIterator<Object>() {\n            ResultIterator<?> batchResult;\n            @Override\n            public boolean hasNext() {\n                // first, any elements already buffered?\n                if (batchResult != null) {\n                    if (batchResult.hasNext()) {\n                        return true;\n                    }\n                    // no more in this chunk, release resources\n                    batchResult.close();\n                }\n                // more chunks?\n                if (!batchArgs.hasNext()) {\n                    return false;\n                }\n                // execute a single chunk and buffer\n                PreparedBatch batch = handle.prepareBatch(sql);\n                applyCustomizers(batch, args);\n                for (int i = 0; i < chunkSize && batchArgs.hasNext(); i++) {\n                    applyBinders(batch.add(), batchArgs.next());\n                }\n                batchResult = executeBatch(handle, batch).iterator();\n                return hasNext(); // recurse to ensure we actually got elements\n            }\n\n            @Override\n            public Object next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return batchResult.next();\n            }\n\n            @Override\n            public void close() {\n                batchResult.close();\n            }\n        };\n\n\n        return magic.result(new ResultBearing<Object>() {\n            @Override\n            public <R> R execute(StatementExecutor<Object, R> executor) {\n                throw new UnsupportedOperationException(\n                        \"@SqlBatch currently does not support custom execution modes like reduce\");\n            }\n\n            @Override\n            public ResultIterator<Object> iterator() {\n                return result;\n            }\n\n            @Override\n            public StatementContext getContext() {\n                return result.getContext();\n            }\n        });\n    }\n\n    private Iterator<Object[]> zipArgs(Object[] args) {\n        boolean foundIterator = false;\n        List<Iterator<?>> extras = new ArrayList<>();\n        for (final Object arg : args) {\n            if (arg instanceof Iterable) {\n                extras.add(((Iterable<?>) arg).iterator());\n                foundIterator = true;\n            }\n            else if (arg instanceof Iterator) {\n                extras.add((Iterator<?>) arg);\n                foundIterator = true;\n            }\n            else if (arg.getClass().isArray()) {\n                extras.add(Arrays.asList((Object[])arg).iterator());\n                foundIterator = true;\n            }\n            else {\n                extras.add(Stream.generate(() -> arg).iterator());\n            }\n        }\n\n        if (!foundIterator) {\n            throw new UnableToCreateStatementException(\"@SqlBatch method has no Iterable or array parameters,\"\n                    + \" did you mean @SqlQuery?\", null, null);\n        }\n\n        final Object[] sharedArg = new Object[args.length];\n        return new Iterator<Object[]>() {\n            @Override\n            public boolean hasNext() {\n                for (Iterator<?> extra : extras) {\n                    if (!extra.hasNext()) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            @Override\n            public Object[] next() {\n                for (int i = 0; i < extras.size(); i++) {\n                    sharedArg[i] = extras.get(i).next();\n                }\n                return sharedArg;\n            }\n        };\n    }\n\n    private ResultBearing<?> executeBatch(final Handle handle, final PreparedBatch batch)\n    {\n        if (!handle.isInTransaction() && sqlBatch.transactional()) {\n            // it is safe to use same prepared batch as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction((conn, status) -> batchIntermediate.apply(batch));\n        }\n        else {\n            return batchIntermediate.apply(batch);\n        }\n    }\n\n    private interface ChunkSizeFunction\n    {\n        int call(Object[] args);\n    }\n\n    private static class ConstantChunkSizeFunction implements ChunkSizeFunction\n    {\n        private final int value;\n\n        ConstantChunkSizeFunction(int value) {\n            this.value = value;\n        }\n\n        @Override\n        public int call(Object[] args)\n        {\n            return value;\n        }\n    }\n\n    private static class ParamBasedChunkSizeFunction implements ChunkSizeFunction\n    {\n        private final int index;\n\n        ParamBasedChunkSizeFunction(int index) {\n            this.index = index;\n        }\n\n        @Override\n        public int call(Object[] args)\n        {\n            return (Integer)args[index];\n        }\n    }\n\n    private static boolean returnTypeIsValid(Class<?> type) {\n        return type.equals(Void.TYPE)\n                || type.isArray() && type.getComponentType().equals(Integer.TYPE);\n\n    }\n\n    private static String invalidReturnTypeMessage(Method method) {\n        return method.getDeclaringClass() + \".\" + method.getName() +\n                \" method is annotated with @SqlBatch so should return void or int[] but is returning: \" +\n                method.getReturnType();\n    }\n}\n","lineNo":116}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.rewriter;\n\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.COMMENT;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.DEFINE;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.DOUBLE_QUOTED_TEXT;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.EOF;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.ESCAPED_TEXT;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.LITERAL;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.QUOTED_TEXT;\n\nimport org.antlr.runtime.ANTLRStringStream;\nimport org.antlr.runtime.Token;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.internal.lexer.DefineStatementLexer;\n\nclass DefinedAttributeRewriter {\n    static String rewriteDefines(String sql, StatementContext ctx) {\n        StringBuilder b = new StringBuilder();\n        DefineStatementLexer lexer = new DefineStatementLexer(new ANTLRStringStream(sql));\n        Token t = lexer.nextToken();\n        while (t.getType() != EOF) {\n            switch (t.getType()) {\n                case COMMENT:\n                case LITERAL:\n                case QUOTED_TEXT:\n                case DOUBLE_QUOTED_TEXT:\n                    b.append(t.getText());\n                    break;\n                case DEFINE:\n                    String text = t.getText();\n                    String key = text.substring(1, text.length() - 1);\n                    Object value = ctx.getAttribute(key);\n                    if (value == null) {\n                        throw new IllegalArgumentException(\"Undefined attribute for token '\" + text + \"'\");\n                    }\n                    b.append(value);\n                    break;\n                case ESCAPED_TEXT:\n                    b.append(t.getText().substring(1));\n                    break;\n                default:\n                    break;\n            }\n            t = lexer.nextToken();\n        }\n        return b.toString();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.rewriter;\n\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.COMMENT;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.DEFINE;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.DOUBLE_QUOTED_TEXT;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.EOF;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.ESCAPED_TEXT;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.LITERAL;\nimport static org.jdbi.v3.core.internal.lexer.DefineStatementLexer.QUOTED_TEXT;\n\nimport org.antlr.runtime.ANTLRStringStream;\nimport org.antlr.runtime.Token;\nimport org.jdbi.v3.core.SqlStatementConfig;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.internal.lexer.DefineStatementLexer;\n\nclass DefinedAttributeRewriter {\n    static String rewriteDefines(String sql, StatementContext ctx) {\n        StringBuilder b = new StringBuilder();\n        SqlStatementConfig config = ctx.getConfig(SqlStatementConfig.class);\n        DefineStatementLexer lexer = new DefineStatementLexer(new ANTLRStringStream(sql));\n        Token t = lexer.nextToken();\n        while (t.getType() != EOF) {\n            switch (t.getType()) {\n                case COMMENT:\n                case LITERAL:\n                case QUOTED_TEXT:\n                case DOUBLE_QUOTED_TEXT:\n                    b.append(t.getText());\n                    break;\n                case DEFINE:\n                    String text = t.getText();\n                    String key = text.substring(1, text.length() - 1);\n                    Object value = config.getAttribute(key);\n                    if (value == null) {\n                        throw new IllegalArgumentException(\"Undefined attribute for token '\" + text + \"'\");\n                    }\n                    b.append(value);\n                    break;\n                case ESCAPED_TEXT:\n                    b.append(t.getText().substring(1));\n                    break;\n                default:\n                    break;\n            }\n            t = lexer.nextToken();\n        }\n        return b.toString();\n    }\n}\n","lineNo":33}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\n\nimport org.jdbi.v3.core.Call;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.OutParameters;\nimport org.jdbi.v3.core.util.GenericTypes;\n\nclass CallHandler extends CustomizingStatementHandler\n{\n    private final Class<?> sqlObjectType;\n    private final boolean returnOutParams;\n\n    CallHandler(Class<?> sqlObjectType, Method method)\n    {\n        super(sqlObjectType, method);\n        this.sqlObjectType = sqlObjectType;\n\n        Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), sqlObjectType);\n        Class<?> returnClass = GenericTypes.getErasedType(returnType);\n        if (Void.TYPE.equals(returnClass)) {\n            returnOutParams = false;\n        } else if (OutParameters.class.isAssignableFrom(returnClass)) {\n            returnOutParams = true;\n        } else {\n            throw new IllegalArgumentException(\"@SqlCall methods may only return null or OutParameters at present\");\n        }\n    }\n\n    @Override\n    public Object invoke(Object target, Method method, Object[] args, HandleSupplier handle)\n    {\n        String sql = handle.getConfig(SqlObjectConfig.class).getSqlLocator().locate(sqlObjectType, method);\n        Call call = handle.getHandle().createCall(sql);\n        applyCustomizers(call, args);\n        applyBinders(call, args);\n\n        OutParameters ou = call.invoke();\n\n        if (returnOutParams) {\n            return ou;\n        }\n        else {\n            return null;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\n\nimport org.jdbi.v3.core.Call;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.OutParameters;\nimport org.jdbi.v3.core.util.GenericTypes;\n\nclass CallHandler extends CustomizingStatementHandler\n{\n    private final Class<?> sqlObjectType;\n    private final boolean returnOutParams;\n\n    CallHandler(Class<?> sqlObjectType, Method method)\n    {\n        super(sqlObjectType, method);\n        this.sqlObjectType = sqlObjectType;\n\n        Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), sqlObjectType);\n        Class<?> returnClass = GenericTypes.getErasedType(returnType);\n        if (Void.TYPE.equals(returnClass)) {\n            returnOutParams = false;\n        } else if (OutParameters.class.isAssignableFrom(returnClass)) {\n            returnOutParams = true;\n        } else {\n            throw new IllegalArgumentException(\"@SqlCall methods may only return null or OutParameters at present\");\n        }\n    }\n\n    @Override\n    public Object invoke(Object target, Method method, Object[] args, HandleSupplier handle)\n    {\n        Handle h = handle.getHandle();\n        String sql = h.getConfig(SqlObjectConfig.class).getSqlLocator().locate(sqlObjectType, method);\n        Call call = h.createCall(sql);\n        applyCustomizers(call, args);\n        applyBinders(call, args);\n\n        OutParameters ou = call.invoke();\n\n        if (returnOutParams) {\n            return ou;\n        }\n        else {\n            return null;\n        }\n    }\n}\n","lineNo":49}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.Query;\n\nclass QueryHandler extends CustomizingStatementHandler\n{\n    private final Class<?> sqlObjectType;\n    private final ResultReturnThing magic;\n\n    QueryHandler(Class<?> sqlObjectType, Method method, ResultReturnThing magic)\n    {\n        super(sqlObjectType, method);\n        this.sqlObjectType = sqlObjectType;\n        this.magic = magic;\n    }\n\n    @Override\n    public Object invoke(Object target, Method method, Object[] args, HandleSupplier handle)\n    {\n        String sql = handle.getConfig(SqlObjectConfig.class).getSqlLocator().locate(sqlObjectType, method);\n        Query<?> q = handle.getHandle().createQuery(sql);\n        applyCustomizers(q, args);\n        applyBinders(q, args);\n\n        return magic.map(method, q, handle);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.Query;\n\nclass QueryHandler extends CustomizingStatementHandler\n{\n    private final Class<?> sqlObjectType;\n    private final ResultReturnThing magic;\n\n    QueryHandler(Class<?> sqlObjectType, Method method, ResultReturnThing magic)\n    {\n        super(sqlObjectType, method);\n        this.sqlObjectType = sqlObjectType;\n        this.magic = magic;\n    }\n\n    @Override\n    public Object invoke(Object target, Method method, Object[] args, HandleSupplier handle)\n    {\n        Handle h = handle.getHandle();\n        String sql = h.getConfig(SqlObjectConfig.class).getSqlLocator().locate(sqlObjectType, method);\n        Query<?> q = h.createQuery(sql);\n        applyCustomizers(q, args);\n        applyBinders(q, args);\n\n        return magic.map(method, q, handle);\n    }\n}\n","lineNo":37}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport static java.util.Collections.synchronizedMap;\nimport static java.util.stream.Collectors.toList;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.WeakHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.ToIntFunction;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.ConfigRegistry;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.sqlobject.mixins.GetHandle;\nimport org.jdbi.v3.sqlobject.mixins.Transactional;\n\npublic enum SqlObjectFactory implements ExtensionFactory {\n    INSTANCE;\n\n    private static final Object[] NO_ARGS = new Object[0];\n\n    private final Map<Method, Handler> mixinHandlers = new HashMap<>();\n    private final Map<Class<?>, Map<Method, Handler>> handlersCache = synchronizedMap(new WeakHashMap<>());\n    private final Map<Class<? extends ConfigurerFactory>, ConfigurerFactory>\n            configurerFactories = synchronizedMap(new WeakHashMap<>());\n\n    SqlObjectFactory() {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n    }\n\n    @Override\n    public boolean accepts(Class<?> extensionType) {\n        if (!extensionType.isInterface()) {\n            throw new IllegalArgumentException(\"SQL Objects are only supported for interfaces.\");\n        }\n\n        if (!Modifier.isPublic(extensionType.getModifiers())) {\n            throw new IllegalArgumentException(\"SQL Object types must be public.\");\n        }\n\n        if (GetHandle.class.isAssignableFrom(extensionType) ||\n                Transactional.class.isAssignableFrom(extensionType)) {\n            return true;\n        }\n\n        return Stream.of(extensionType.getMethods())\n                .flatMap(m -> Stream.of(m.getAnnotations()))\n                .anyMatch(a -> a.annotationType().isAnnotationPresent(SqlMethodAnnotation.class));\n    }\n\n    /**\n     * Create a sql object of the specified type bound to this handle. Any state changes to the handle, or the sql\n     * object, such as transaction status, closing it, etc, will apply to both the object and the handle.\n     *\n     * @param extensionType the type of sql object to create\n     * @param handle the Handle instance to attach ths sql object to\n     * @return the new sql object bound to this handle\n     */\n    @Override\n    public <E> E attach(Class<E> extensionType, HandleSupplier handle) {\n        Map<Method, Handler> handlers = methodHandlersFor(extensionType);\n\n        forEachConfigurerFactory(extensionType, (factory, annotation) ->\n                factory.createForType(annotation, extensionType).accept(handle.getConfig()));\n\n        InvocationHandler invocationHandler = createInvocationHandler(extensionType, handlers, handle);\n        return extensionType.cast(\n                Proxy.newProxyInstance(\n                        extensionType.getClassLoader(),\n                        new Class[]{extensionType},\n                        invocationHandler));\n    }\n\n    private Map<Method, Handler> methodHandlersFor(Class<?> sqlObjectType) {\n        return handlersCache.computeIfAbsent(sqlObjectType, type -> {\n            final Map<Method, Handler> handlers = new HashMap<>();\n\n            handlers.putAll(EqualsHandler.handler());\n            handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n            handlers.putAll(HashCodeHandler.handler());\n            handlers.putAll(FinalizeHandler.handlerFor(sqlObjectType));\n\n            for (Method method : sqlObjectType.getMethods()) {\n                handlers.computeIfAbsent(method, m -> buildMethodHandler(sqlObjectType, m));\n            }\n\n            return handlers;\n        });\n    }\n\n    private Handler buildMethodHandler(Class<?> sqlObjectType, Method method) {\n        if (mixinHandlers.containsKey(method)) {\n            return mixinHandlers.get(method);\n        }\n\n        Handler handler = buildBaseHandler(sqlObjectType, method);\n        return addDecorators(handler, sqlObjectType, method);\n    }\n\n    private Handler buildBaseHandler(Class<?> sqlObjectType, Method method) {\n        List<Class<?>> sqlMethodAnnotations = Stream.of(method.getAnnotations())\n                .map(Annotation::annotationType)\n                .filter(type -> type.isAnnotationPresent(SqlMethodAnnotation.class))\n                .collect(toList());\n\n        if (sqlMethodAnnotations.size() > 1) {\n            throw new IllegalStateException(\n                    String.format(\"Mutually exclusive annotations on method %s.%s: %s\",\n                            sqlObjectType.getName(),\n                            method.getName(),\n                            sqlMethodAnnotations));\n        }\n\n        if (method.isDefault()) {\n            if (!sqlMethodAnnotations.isEmpty()) {\n                throw new IllegalStateException(String.format(\n                        \"Default method %s.%s has @%s annotation. \" +\n                                \"SQL object methods may be default, or have a SQL method annotation, but not both.\",\n                        sqlObjectType.getSimpleName(),\n                        method.getName(),\n                        sqlMethodAnnotations.get(0).getSimpleName()));\n            }\n\n            Stream.of(method.getAnnotations()).map(Annotation::annotationType)\n                    .filter(type -> type.isAnnotationPresent(SqlStatementCustomizingAnnotation.class))\n                    .findFirst()\n                    .ifPresent(type -> {\n                        throw new IllegalStateException(String.format(\n                                \"Default method %s.%s has @%s annotation. Statement customizing annotations don't \" +\n                                        \"work on default methods.\",\n                                sqlObjectType.getSimpleName(),\n                                method.getName(),\n                                type.getSimpleName()));\n                    });\n\n            for (Parameter parameter : method.getParameters()) {\n                Stream.of(parameter.getAnnotations())\n                        .map(Annotation::annotationType)\n                        .filter(type -> type.isAnnotationPresent(SqlStatementCustomizingAnnotation.class))\n                        .findFirst()\n                        .ifPresent(type -> {\n                            throw new IllegalStateException(String.format(\n                                    \"Default method %s.%s parameter %s has @%s annotation. Statement customizing \" +\n                                            \"annotations don't work on default methods.\",\n                                    sqlObjectType.getSimpleName(),\n                                    parameter.getName(),\n                                    method.getName(),\n                                    type.getSimpleName()));\n                        });\n\n                Stream.of(parameter.getAnnotations())\n                        .map(Annotation::annotationType)\n                        .filter(type -> type.isAnnotationPresent(BindingAnnotation.class))\n                        .findFirst()\n                        .ifPresent(type -> {\n                            throw new IllegalStateException(String.format(\n                                    \"Default method %s.%s parameter %s has @%s annotation. Binding annotations \" +\n                                            \"don't work on default methods.\",\n                                    sqlObjectType.getSimpleName(),\n                                    parameter.getName(),\n                                    method.getName(),\n                                    type.getSimpleName()));\n                        });\n            }\n\n            return new DefaultMethodHandler(method);\n        }\n\n        return sqlMethodAnnotations.stream()\n                .map(type -> type.getAnnotation(SqlMethodAnnotation.class))\n                .map(a -> buildFactory(a.value()))\n                .map(factory -> factory.buildHandler(sqlObjectType, method))\n                .findFirst()\n                .orElseThrow(() -> new IllegalStateException(String.format(\n                        \"Method %s.%s must be default or be annotated with a SQL method annotation.\",\n                        sqlObjectType.getSimpleName(),\n                        method.getName())));\n    }\n\n    private Handler addDecorators(Handler handler, Class<?> sqlObjectType, Method method) {\n        List<Class<? extends Annotation>> annotationTypes = Stream.of(method.getAnnotations())\n                .map(Annotation::annotationType)\n                .filter(type -> type.isAnnotationPresent(SqlMethodDecoratingAnnotation.class))\n                .collect(toList());\n\n        Stream.of(method, sqlObjectType)\n                .map(e -> e.getAnnotation(DecoratorOrder.class))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .ifPresent(order -> {\n                    annotationTypes.sort(createDecoratorComparator(order).reversed());\n                });\n\n        List<HandlerDecorator> decorators = annotationTypes.stream()\n                .map(type -> type.getAnnotation(SqlMethodDecoratingAnnotation.class))\n                .map(a -> buildDecorator(a.value()))\n                .collect(toList());\n\n        for (HandlerDecorator decorator : decorators) {\n            handler = decorator.decorateHandler(handler, sqlObjectType, method);\n        }\n\n        return new SetExtensionMethodHandler(sqlObjectType, method, handler);\n    }\n\n    private Comparator<Class<? extends Annotation>> createDecoratorComparator(DecoratorOrder order) {\n        List<Class<? extends Annotation>> ordering = Arrays.asList(order.value());\n\n        ToIntFunction<Class<? extends Annotation>> indexOf = type -> {\n            int index = ordering.indexOf(type);\n            return index == -1 ? ordering.size() : index;\n        };\n\n        return (l, r) -> indexOf.applyAsInt(l) - indexOf.applyAsInt(r);\n    }\n\n    private static HandlerFactory buildFactory(Class<? extends HandlerFactory> factoryClazz) {\n        HandlerFactory factory;\n        try {\n            factory = factoryClazz.getConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new IllegalStateException(\"Factory class \" + factoryClazz + \"cannot be instantiated\", e);\n        }\n        return factory;\n    }\n\n    private static HandlerDecorator buildDecorator(Class<? extends HandlerDecorator> decoratorClass) {\n        HandlerDecorator decorator;\n        try {\n            decorator = decoratorClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new IllegalStateException(\"Decorator class \" + decoratorClass + \"cannot be instantiated\", e);\n        }\n        return decorator;\n    }\n\n    private InvocationHandler createInvocationHandler(Class<?> sqlObjectType,\n                                                      Map<Method, Handler> handlers,\n                                                      HandleSupplier handle) {\n        return (proxy, method, args) -> {\n            Handler handler = handlers.get(method);\n\n            ConfigRegistry methodConfig = handle.getConfig().createChild();\n            forEachConfigurerFactory(method, (factory, annotation) ->\n                    factory.createForMethod(annotation, sqlObjectType, method).accept(methodConfig));\n\n            return handle.withConfig(methodConfig,\n                    () -> handler.invoke(proxy, method, args == null ? NO_ARGS : args, handle));\n        };\n    }\n\n    private void forEachConfigurerFactory(AnnotatedElement element, BiConsumer<ConfigurerFactory, Annotation> consumer) {\n        Stream.of(element.getAnnotations())\n                .filter(a -> a.annotationType().isAnnotationPresent(ConfiguringAnnotation.class))\n                .forEach(a -> {\n                    ConfiguringAnnotation meta = a.annotationType()\n                            .getAnnotation(ConfiguringAnnotation.class);\n\n                    consumer.accept(getConfigurerFactory(meta.value()), a);\n                });\n    }\n\n    private ConfigurerFactory getConfigurerFactory(Class<? extends ConfigurerFactory> factoryClass) {\n        return configurerFactories.computeIfAbsent(factoryClass, c -> {\n            try {\n                return c.newInstance();\n            } catch (InstantiationException | IllegalAccessException e) {\n                throw new IllegalStateException(\"Unable to instantiate configurer factory class \" + factoryClass, e);\n            }\n        });\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport static java.util.Collections.synchronizedMap;\nimport static java.util.stream.Collectors.toList;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.WeakHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.ToIntFunction;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.ConfigRegistry;\nimport org.jdbi.v3.core.ExtensionMethod;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.sqlobject.mixins.GetHandle;\nimport org.jdbi.v3.sqlobject.mixins.Transactional;\n\npublic enum SqlObjectFactory implements ExtensionFactory {\n    INSTANCE;\n\n    private static final Object[] NO_ARGS = new Object[0];\n\n    private final Map<Method, Handler> mixinHandlers = new HashMap<>();\n    private final Map<Class<?>, Map<Method, Handler>> handlersCache = synchronizedMap(new WeakHashMap<>());\n    private final Map<Class<? extends ConfigurerFactory>, ConfigurerFactory>\n            configurerFactories = synchronizedMap(new WeakHashMap<>());\n\n    SqlObjectFactory() {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n    }\n\n    @Override\n    public boolean accepts(Class<?> extensionType) {\n        if (!extensionType.isInterface()) {\n            throw new IllegalArgumentException(\"SQL Objects are only supported for interfaces.\");\n        }\n\n        if (!Modifier.isPublic(extensionType.getModifiers())) {\n            throw new IllegalArgumentException(\"SQL Object types must be public.\");\n        }\n\n        if (GetHandle.class.isAssignableFrom(extensionType) ||\n                Transactional.class.isAssignableFrom(extensionType)) {\n            return true;\n        }\n\n        return Stream.of(extensionType.getMethods())\n                .flatMap(m -> Stream.of(m.getAnnotations()))\n                .anyMatch(a -> a.annotationType().isAnnotationPresent(SqlMethodAnnotation.class));\n    }\n\n    /**\n     * Create a sql object of the specified type bound to this handle. Any state changes to the handle, or the sql\n     * object, such as transaction status, closing it, etc, will apply to both the object and the handle.\n     *\n     * @param extensionType the type of sql object to create\n     * @param handle the Handle instance to attach ths sql object to\n     * @return the new sql object bound to this handle\n     */\n    @Override\n    public <E> E attach(Class<E> extensionType, HandleSupplier handle) {\n        ConfigRegistry instanceConfig = handle.getConfig().createChild();\n        Map<Method, Handler> handlers = methodHandlersFor(extensionType);\n\n        forEachConfigurerFactory(extensionType, (factory, annotation) ->\n                factory.createForType(annotation, extensionType).accept(instanceConfig));\n\n        InvocationHandler invocationHandler = createInvocationHandler(extensionType, handlers, instanceConfig, handle);\n        return extensionType.cast(\n                Proxy.newProxyInstance(\n                        extensionType.getClassLoader(),\n                        new Class[]{extensionType},\n                        invocationHandler));\n    }\n\n    private Map<Method, Handler> methodHandlersFor(Class<?> sqlObjectType) {\n        return handlersCache.computeIfAbsent(sqlObjectType, type -> {\n            final Map<Method, Handler> handlers = new HashMap<>();\n\n            handlers.putAll(EqualsHandler.handler());\n            handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n            handlers.putAll(HashCodeHandler.handler());\n            handlers.putAll(FinalizeHandler.handlerFor(sqlObjectType));\n\n            for (Method method : sqlObjectType.getMethods()) {\n                handlers.computeIfAbsent(method, m -> buildMethodHandler(sqlObjectType, m));\n            }\n\n            return handlers;\n        });\n    }\n\n    private Handler buildMethodHandler(Class<?> sqlObjectType, Method method) {\n        if (mixinHandlers.containsKey(method)) {\n            return mixinHandlers.get(method);\n        }\n\n        Handler handler = buildBaseHandler(sqlObjectType, method);\n        return addDecorators(handler, sqlObjectType, method);\n    }\n\n    private Handler buildBaseHandler(Class<?> sqlObjectType, Method method) {\n        List<Class<?>> sqlMethodAnnotations = Stream.of(method.getAnnotations())\n                .map(Annotation::annotationType)\n                .filter(type -> type.isAnnotationPresent(SqlMethodAnnotation.class))\n                .collect(toList());\n\n        if (sqlMethodAnnotations.size() > 1) {\n            throw new IllegalStateException(\n                    String.format(\"Mutually exclusive annotations on method %s.%s: %s\",\n                            sqlObjectType.getName(),\n                            method.getName(),\n                            sqlMethodAnnotations));\n        }\n\n        if (method.isDefault()) {\n            if (!sqlMethodAnnotations.isEmpty()) {\n                throw new IllegalStateException(String.format(\n                        \"Default method %s.%s has @%s annotation. \" +\n                                \"SQL object methods may be default, or have a SQL method annotation, but not both.\",\n                        sqlObjectType.getSimpleName(),\n                        method.getName(),\n                        sqlMethodAnnotations.get(0).getSimpleName()));\n            }\n\n            Stream.of(method.getAnnotations()).map(Annotation::annotationType)\n                    .filter(type -> type.isAnnotationPresent(SqlStatementCustomizingAnnotation.class))\n                    .findFirst()\n                    .ifPresent(type -> {\n                        throw new IllegalStateException(String.format(\n                                \"Default method %s.%s has @%s annotation. Statement customizing annotations don't \" +\n                                        \"work on default methods.\",\n                                sqlObjectType.getSimpleName(),\n                                method.getName(),\n                                type.getSimpleName()));\n                    });\n\n            for (Parameter parameter : method.getParameters()) {\n                Stream.of(parameter.getAnnotations())\n                        .map(Annotation::annotationType)\n                        .filter(type -> type.isAnnotationPresent(SqlStatementCustomizingAnnotation.class))\n                        .findFirst()\n                        .ifPresent(type -> {\n                            throw new IllegalStateException(String.format(\n                                    \"Default method %s.%s parameter %s has @%s annotation. Statement customizing \" +\n                                            \"annotations don't work on default methods.\",\n                                    sqlObjectType.getSimpleName(),\n                                    parameter.getName(),\n                                    method.getName(),\n                                    type.getSimpleName()));\n                        });\n\n                Stream.of(parameter.getAnnotations())\n                        .map(Annotation::annotationType)\n                        .filter(type -> type.isAnnotationPresent(BindingAnnotation.class))\n                        .findFirst()\n                        .ifPresent(type -> {\n                            throw new IllegalStateException(String.format(\n                                    \"Default method %s.%s parameter %s has @%s annotation. Binding annotations \" +\n                                            \"don't work on default methods.\",\n                                    sqlObjectType.getSimpleName(),\n                                    parameter.getName(),\n                                    method.getName(),\n                                    type.getSimpleName()));\n                        });\n            }\n\n            return new DefaultMethodHandler(method);\n        }\n\n        return sqlMethodAnnotations.stream()\n                .map(type -> type.getAnnotation(SqlMethodAnnotation.class))\n                .map(a -> buildFactory(a.value()))\n                .map(factory -> factory.buildHandler(sqlObjectType, method))\n                .findFirst()\n                .orElseThrow(() -> new IllegalStateException(String.format(\n                        \"Method %s.%s must be default or be annotated with a SQL method annotation.\",\n                        sqlObjectType.getSimpleName(),\n                        method.getName())));\n    }\n\n    private Handler addDecorators(Handler handler, Class<?> sqlObjectType, Method method) {\n        List<Class<? extends Annotation>> annotationTypes = Stream.of(method.getAnnotations())\n                .map(Annotation::annotationType)\n                .filter(type -> type.isAnnotationPresent(SqlMethodDecoratingAnnotation.class))\n                .collect(toList());\n\n        Stream.of(method, sqlObjectType)\n                .map(e -> e.getAnnotation(DecoratorOrder.class))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .ifPresent(order -> {\n                    annotationTypes.sort(createDecoratorComparator(order).reversed());\n                });\n\n        List<HandlerDecorator> decorators = annotationTypes.stream()\n                .map(type -> type.getAnnotation(SqlMethodDecoratingAnnotation.class))\n                .map(a -> buildDecorator(a.value()))\n                .collect(toList());\n\n        for (HandlerDecorator decorator : decorators) {\n            handler = decorator.decorateHandler(handler, sqlObjectType, method);\n        }\n\n        return handler;\n    }\n\n    private Comparator<Class<? extends Annotation>> createDecoratorComparator(DecoratorOrder order) {\n        List<Class<? extends Annotation>> ordering = Arrays.asList(order.value());\n\n        ToIntFunction<Class<? extends Annotation>> indexOf = type -> {\n            int index = ordering.indexOf(type);\n            return index == -1 ? ordering.size() : index;\n        };\n\n        return (l, r) -> indexOf.applyAsInt(l) - indexOf.applyAsInt(r);\n    }\n\n    private static HandlerFactory buildFactory(Class<? extends HandlerFactory> factoryClazz) {\n        HandlerFactory factory;\n        try {\n            factory = factoryClazz.getConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new IllegalStateException(\"Factory class \" + factoryClazz + \"cannot be instantiated\", e);\n        }\n        return factory;\n    }\n\n    private static HandlerDecorator buildDecorator(Class<? extends HandlerDecorator> decoratorClass) {\n        HandlerDecorator decorator;\n        try {\n            decorator = decoratorClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new IllegalStateException(\"Decorator class \" + decoratorClass + \"cannot be instantiated\", e);\n        }\n        return decorator;\n    }\n\n    private InvocationHandler createInvocationHandler(Class<?> sqlObjectType,\n                                                      Map<Method, Handler> handlers,\n                                                      ConfigRegistry instanceConfig,\n                                                      HandleSupplier handle) {\n        return (proxy, method, args) -> {\n            Handler handler = handlers.get(method);\n\n            ConfigRegistry methodConfig = instanceConfig.createChild();\n            forEachConfigurerFactory(method, (factory, annotation) ->\n                    factory.createForMethod(annotation, sqlObjectType, method).accept(methodConfig));\n\n            return handle.invokeInContext(new ExtensionMethod(sqlObjectType, method), methodConfig,\n                    () -> handler.invoke(proxy, method, args == null ? NO_ARGS : args, handle));\n        };\n    }\n\n    private void forEachConfigurerFactory(AnnotatedElement element, BiConsumer<ConfigurerFactory, Annotation> consumer) {\n        Stream.of(element.getAnnotations())\n                .filter(a -> a.annotationType().isAnnotationPresent(ConfiguringAnnotation.class))\n                .forEach(a -> {\n                    ConfiguringAnnotation meta = a.annotationType()\n                            .getAnnotation(ConfiguringAnnotation.class);\n\n                    consumer.accept(getConfigurerFactory(meta.value()), a);\n                });\n    }\n\n    private ConfigurerFactory getConfigurerFactory(Class<? extends ConfigurerFactory> factoryClass) {\n        return configurerFactories.computeIfAbsent(factoryClass, c -> {\n            try {\n                return c.newInstance();\n            } catch (InstantiationException | IllegalAccessException e) {\n                throw new IllegalStateException(\"Unable to instantiate configurer factory class \" + factoryClass, e);\n            }\n        });\n    }\n}\n","lineNo":89}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\n\nimport org.jdbi.v3.core.GeneratedKeys;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.Update;\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.util.GenericTypes;\nimport org.jdbi.v3.sqlobject.exceptions.UnableToCreateSqlObjectException;\n\nclass UpdateHandler extends CustomizingStatementHandler\n{\n    private final Class<?> sqlObjectType;\n    private final Returner returner;\n\n    UpdateHandler(Class<?> sqlObjectType, Method method)\n    {\n        super(sqlObjectType, method);\n        this.sqlObjectType = sqlObjectType;\n\n        boolean isGetGeneratedKeys = method.isAnnotationPresent(GetGeneratedKeys.class);\n\n        Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), sqlObjectType);\n        if (isGetGeneratedKeys) {\n            final ResultReturnThing magic = ResultReturnThing.forMethod(sqlObjectType, method);\n            final GetGeneratedKeys ggk = method.getAnnotation(GetGeneratedKeys.class);\n            final RowMapper<?> mapper;\n            if (DefaultGeneratedKeyMapper.class.equals(ggk.value())) {\n                mapper = new DefaultGeneratedKeyMapper(returnType, ggk.columnName());\n            }\n            else {\n                try {\n                    mapper = ggk.value().newInstance();\n                }\n                catch (Exception e) {\n                    throw new UnableToCreateStatementException(\"Unable to instantiate row mapper for statement\", e, null);\n                }\n            }\n            this.returner = (update, handle) -> {\n                GeneratedKeys<?> o = update.executeAndReturnGeneratedKeys(mapper, ggk.columnName());\n                return magic.result(o, handle);\n            };\n        } else if (isNumeric(method.getReturnType())) {\n            this.returner = (update, handle) -> update.execute();\n        } else if (isBoolean(method.getReturnType())) {\n            this.returner = (update, handle) -> update.execute() > 0;\n        } else {\n            throw new UnableToCreateSqlObjectException(invalidReturnTypeMessage(method, returnType));\n        }\n    }\n\n    @Override\n    public Object invoke(Object target, Method method, Object[] args, HandleSupplier handle)\n    {\n        String sql = handle.getConfig(SqlObjectConfig.class).getSqlLocator().locate(sqlObjectType, method);\n        Update q = handle.getHandle().createUpdate(sql);\n        applyCustomizers(q, args);\n        applyBinders(q, args);\n        return this.returner.value(q, handle);\n    }\n\n\n    private interface Returner\n    {\n        Object value(Update update, HandleSupplier handle);\n    }\n\n    private boolean isNumeric(Class<?> type) {\n        return Number.class.isAssignableFrom(type) ||\n               type.equals(int.class) ||\n               type.equals(long.class) ||\n               type.equals(void.class);\n    }\n\n    private boolean isBoolean(Class<?> type) {\n        return type.equals(boolean.class) ||\n               type.equals(Boolean.class);\n    }\n\n    private String invalidReturnTypeMessage(Method method, Type returnType) {\n        return method.getDeclaringClass().getSimpleName() + \".\" + method.getName() +\n                \" method is annotated with @SqlUpdate so should return void, boolean, or Number but is returning: \" +\n                returnType;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\n\nimport org.jdbi.v3.core.GeneratedKeys;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.Update;\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.util.GenericTypes;\nimport org.jdbi.v3.sqlobject.exceptions.UnableToCreateSqlObjectException;\n\nclass UpdateHandler extends CustomizingStatementHandler\n{\n    private final Class<?> sqlObjectType;\n    private final Returner returner;\n\n    UpdateHandler(Class<?> sqlObjectType, Method method)\n    {\n        super(sqlObjectType, method);\n        this.sqlObjectType = sqlObjectType;\n\n        boolean isGetGeneratedKeys = method.isAnnotationPresent(GetGeneratedKeys.class);\n\n        Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), sqlObjectType);\n        if (isGetGeneratedKeys) {\n            final ResultReturnThing magic = ResultReturnThing.forMethod(sqlObjectType, method);\n            final GetGeneratedKeys ggk = method.getAnnotation(GetGeneratedKeys.class);\n            final RowMapper<?> mapper;\n            if (DefaultGeneratedKeyMapper.class.equals(ggk.value())) {\n                mapper = new DefaultGeneratedKeyMapper(returnType, ggk.columnName());\n            }\n            else {\n                try {\n                    mapper = ggk.value().newInstance();\n                }\n                catch (Exception e) {\n                    throw new UnableToCreateStatementException(\"Unable to instantiate row mapper for statement\", e, null);\n                }\n            }\n            this.returner = (update, handle) -> {\n                GeneratedKeys<?> o = update.executeAndReturnGeneratedKeys(mapper, ggk.columnName());\n                return magic.result(o, handle);\n            };\n        } else if (isNumeric(method.getReturnType())) {\n            this.returner = (update, handle) -> update.execute();\n        } else if (isBoolean(method.getReturnType())) {\n            this.returner = (update, handle) -> update.execute() > 0;\n        } else {\n            throw new UnableToCreateSqlObjectException(invalidReturnTypeMessage(method, returnType));\n        }\n    }\n\n    @Override\n    public Object invoke(Object target, Method method, Object[] args, HandleSupplier handle)\n    {\n        Handle h = handle.getHandle();\n        String sql = h.getConfig(SqlObjectConfig.class).getSqlLocator().locate(sqlObjectType, method);\n        Update q = h.createUpdate(sql);\n        applyCustomizers(q, args);\n        applyBinders(q, args);\n        return this.returner.value(q, handle);\n    }\n\n\n    private interface Returner\n    {\n        Object value(Update update, HandleSupplier handle);\n    }\n\n    private boolean isNumeric(Class<?> type) {\n        return Number.class.isAssignableFrom(type) ||\n               type.equals(int.class) ||\n               type.equals(long.class) ||\n               type.equals(void.class);\n    }\n\n    private boolean isBoolean(Class<?> type) {\n        return type.equals(boolean.class) ||\n               type.equals(Boolean.class);\n    }\n\n    private String invalidReturnTypeMessage(Method method, Type returnType) {\n        return method.getDeclaringClass().getSimpleName() + \".\" + method.getName() +\n                \" method is annotated with @SqlUpdate so should return void, boolean, or Number but is returning: \" +\n                returnType;\n    }\n}\n","lineNo":72}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.jdbi.v3.core.ColumnName;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.util.GenericTypes;\nimport org.jdbi.v3.core.util.bean.ColumnNameMappingStrategy;\n\n/**\n * A row mapper which maps the fields in a result set into a constructor. The default implementation will perform a\n * case insensitive mapping between the constructor parameter names and the column labels,\n * also considering camel-case to underscores conversion.\n *\n * Currently the constructor must have exactly the same number of columns as the result set, and\n * the mapping must be one-to-one.  These restrictions may be reconsidered at a later time.\n */\npublic class ConstructorMapper<T> implements RowMapper<T>\n{\n    private final Constructor<T> constructor;\n    private final ConcurrentMap<List<String>, Factory<T>> factoryCache = new ConcurrentHashMap<>();\n    private final Collection<ColumnNameMappingStrategy> nameMappingStrategies;\n\n    private ConstructorMapper(Constructor<T> constructor, Collection<ColumnNameMappingStrategy> nameMappingStrategies)\n    {\n        this.constructor = constructor;\n        this.nameMappingStrategies = Collections.unmodifiableList(new ArrayList<>(nameMappingStrategies));\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx)\n        throws SQLException\n    {\n        final ResultSetMetaData metadata = rs.getMetaData();\n        final List<String> columnNames = new ArrayList<>(metadata.getColumnCount());\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            columnNames.add(metadata.getColumnLabel(i));\n        }\n\n        Factory<T> factory = factoryCache.computeIfAbsent(columnNames, c -> createFactory(c, ctx));\n        return factory.create(rs);\n    }\n\n    /**\n     * Compute a memoized mapping from ResultSet column labels to Constructor argument position.\n     */\n    private Factory<T> createFactory(List<String> columnNames, StatementContext ctx) {\n        final int columns = constructor.getParameterCount();\n\n        if (columns > columnNames.size()) {\n            throw new IllegalStateException(columnNames.size() +\n                    \" columns in result set, but constructor takes \" +\n                    constructor.getParameterCount());\n        }\n\n        final int[] columnMap = new int[columns];\n        final ColumnMapper<?>[] mappers = new ColumnMapper<?>[columns];\n\n        for (int i = 0; i < columns; i++) {\n            final Type type = constructor.getGenericParameterTypes()[i];\n            final String paramName = paramName(constructor.getParameters()[i]);\n            final int columnIndex = columnIndexForParameter(columnNames, paramName);\n\n            mappers[i] = ctx.findColumnMapperFor(type).orElseThrow(() ->\n                new IllegalArgumentException(String.format(\n                        \"Could not find column mapper for type '%s' of parameter \" +\n                        \"'%s' for constructor '%s'\", type, paramName, constructor)));\n            columnMap[i] = columnIndex;\n        }\n\n        return rs -> {\n            final Object[] params = new Object[columns];\n            for (int i = 0; i < columns; i++) {\n                params[i] = mappers[i].map(rs, columnMap[i] + 1, ctx);\n            }\n            try {\n                return constructor.newInstance(params);\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                if (e.getCause() instanceof RuntimeException) {\n                    throw (RuntimeException) e.getCause();\n                }\n                if (e.getCause() instanceof Error) {\n                    throw (Error) e.getCause();\n                }\n                throw new RuntimeException(e);\n            }\n        };\n    }\n\n    private int columnIndexForParameter(List<String> columnNames, String parameterName)\n    {\n        int result = -1;\n        for (int i = 0; i < columnNames.size(); i++) {\n            for (ColumnNameMappingStrategy strategy : nameMappingStrategies) {\n                if (strategy.nameMatches(parameterName, columnNames.get(i))) {\n                    if (result >= 0) {\n                        throw new IllegalArgumentException(String.format(\n                                \"Constructor '%s' parameter '%s' matches multiple \" +\n                                \"columns: '%s' (%d) and '%s' (%d)\", constructor,\n                                parameterName, columnNames.get(result), result,\n                                columnNames.get(i), i));\n                    }\n                    result = i;\n                    break;\n                }\n            }\n        }\n        if (result >= 0) {\n            return result;\n        }\n        throw new IllegalArgumentException(\"Constructor '\" + constructor + \"' parameter '\" +\n                parameterName +\n                \"' has no column in the result set.  Verify that the Java \" +\n                \"compiler is configured to emit parameter names, \" +\n                \"that your result set has the columns expected, \" +\n                \"or annotate the parameter names explicitly with @ColumnName\");\n    }\n\n    private static String paramName(Parameter parameter) {\n        ColumnName dbName = parameter.getAnnotation(ColumnName.class);\n        if (dbName != null) {\n            return dbName.value();\n        }\n        return parameter.getName();\n    }\n\n    interface Factory<T> {\n        T create(ResultSet rs) throws SQLException;\n    }\n\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T> Constructor<T> findOnlyConstructor(Class<T> type) {\n        final Constructor<?>[] constructors = type.getDeclaredConstructors();\n        if (constructors.length != 1) {\n            throw new IllegalArgumentException(type + \" must have exactly one constructor, or specify it explicitly\");\n        }\n        return (Constructor<T>) constructors[0];\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     */\n    public static RowMapperFactory of(Constructor<?> constructor) {\n        return of(constructor, BeanMapper.DEFAULT_STRATEGIES);\n    }\n\n    /**\n     * Use the only declared constructor to map a class.\n     */\n    public static RowMapperFactory of(Class<?> clazz) {\n        return of(clazz, BeanMapper.DEFAULT_STRATEGIES);\n    }\n\n    /**\n     * Use the only declared constructor to map a class, and specify the name mapping strategy.\n     */\n    public static RowMapperFactory of(Class<?> clazz, Collection<ColumnNameMappingStrategy> nameMappingStrategies) {\n        return of(findOnlyConstructor(clazz), nameMappingStrategies);\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type, and specify the name mapping strategy.\n     */\n    public static RowMapperFactory of(Constructor<?> constructor, Collection<ColumnNameMappingStrategy> nameMappingStrategies) {\n        final RowMapper<?> mapper = new ConstructorMapper<>(constructor, nameMappingStrategies);\n        return new RowMapperFactory() {\n            @Override\n            public Optional<RowMapper<?>> build(Type type, StatementContext ctx) {\n                return GenericTypes.getErasedType(type) == constructor.getDeclaringClass() ? Optional.of(mapper) : Optional.empty();\n            }\n        };\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core.mapper;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.jdbi.v3.core.ColumnName;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.util.bean.ColumnNameMappingStrategy;\n\n/**\n * A row mapper which maps the fields in a result set into a constructor. The default implementation will perform a\n * case insensitive mapping between the constructor parameter names and the column labels,\n * also considering camel-case to underscores conversion.\n *\n * Currently the constructor must have exactly the same number of columns as the result set, and\n * the mapping must be one-to-one.  These restrictions may be reconsidered at a later time.\n */\npublic class ConstructorMapper<T> implements RowMapper<T>\n{\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     */\n    public static RowMapperFactory of(Constructor<?> constructor) {\n        return of(constructor, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type.\n     */\n    public static RowMapperFactory of(Constructor<?> constructor, String prefix) {\n        return of(constructor, prefix, BeanMapper.DEFAULT_STRATEGIES);\n    }\n\n    /**\n     * Use the only declared constructor to map a class.\n     */\n    public static RowMapperFactory of(Class<?> clazz) {\n        return of(clazz, DEFAULT_PREFIX);\n    }\n\n    /**\n     * Use the only declared constructor to map a class.\n     */\n    public static RowMapperFactory of(Class<?> clazz, String prefix) {\n        return of(clazz, prefix, BeanMapper.DEFAULT_STRATEGIES);\n    }\n\n    /**\n     * Use the only declared constructor to map a class, and specify the name mapping strategy.\n     */\n    public static RowMapperFactory of(Class<?> clazz, Collection<ColumnNameMappingStrategy> nameMappingStrategies) {\n        return of(findOnlyConstructor(clazz), DEFAULT_PREFIX, nameMappingStrategies);\n    }\n\n    /**\n     * Use the only declared constructor to map a class, and specify the name mapping strategy.\n     */\n    public static RowMapperFactory of(Class<?> clazz, String prefix, Collection<ColumnNameMappingStrategy> nameMappingStrategies) {\n        return of(findOnlyConstructor(clazz), prefix, nameMappingStrategies);\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type, and specify the name mapping strategy.\n     */\n    public static RowMapperFactory of(Constructor<?> constructor, Collection<ColumnNameMappingStrategy> nameMappingStrategies) {\n        return of(constructor, DEFAULT_PREFIX, nameMappingStrategies);\n    }\n\n    /**\n     * Use a {@code Constructor<T>} to map its declaring type, and specify the name mapping strategy.\n     */\n    public static RowMapperFactory of(Constructor<?> constructor, String prefix, Collection<ColumnNameMappingStrategy> nameMappingStrategies) {\n        final Class<?> type = constructor.getDeclaringClass();\n        final RowMapper<?> mapper = new ConstructorMapper<>(constructor, prefix, nameMappingStrategies);\n        return (t, ctx) -> t == type ? Optional.of(mapper) : Optional.empty();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T> Constructor<T> findOnlyConstructor(Class<T> type) {\n        final Constructor<?>[] constructors = type.getDeclaredConstructors();\n        if (constructors.length != 1) {\n            throw new IllegalArgumentException(type + \" must have exactly one constructor, or specify it explicitly\");\n        }\n        return (Constructor<T>) constructors[0];\n    }\n\n    static final String DEFAULT_PREFIX = \"\";\n\n    private final Constructor<T> constructor;\n    private final ConcurrentMap<List<String>, Factory<T>> factoryCache = new ConcurrentHashMap<>();\n    private final String prefix;\n    private final Collection<ColumnNameMappingStrategy> nameMappingStrategies;\n\n    private ConstructorMapper(Constructor<T> constructor,\n                              String prefix,\n                              Collection<ColumnNameMappingStrategy> nameMappingStrategies)\n    {\n        this.constructor = constructor;\n        this.prefix = prefix;\n        this.nameMappingStrategies = Collections.unmodifiableList(new ArrayList<>(nameMappingStrategies));\n    }\n\n    @Override\n    public T map(ResultSet rs, StatementContext ctx)\n        throws SQLException\n    {\n        final ResultSetMetaData metadata = rs.getMetaData();\n        final List<String> columnNames = new ArrayList<>(metadata.getColumnCount());\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            columnNames.add(metadata.getColumnLabel(i));\n        }\n\n        Factory<T> factory = factoryCache.computeIfAbsent(columnNames, c -> createFactory(c, ctx));\n        return factory.create(rs);\n    }\n\n    /**\n     * Compute a memoized mapping from ResultSet column labels to Constructor argument position.\n     */\n    private Factory<T> createFactory(List<String> columnNames, StatementContext ctx) {\n        final int columns = constructor.getParameterCount();\n\n        if (columns > columnNames.size()) {\n            throw new IllegalStateException(columnNames.size() +\n                    \" columns in result set, but constructor takes \" +\n                    constructor.getParameterCount());\n        }\n\n        final int[] columnMap = new int[columns];\n        final ColumnMapper<?>[] mappers = new ColumnMapper<?>[columns];\n\n        for (int i = 0; i < columns; i++) {\n            final Type type = constructor.getGenericParameterTypes()[i];\n            final String paramName = paramName(constructor.getParameters()[i]);\n            final int columnIndex = columnIndexForParameter(columnNames, paramName);\n\n            mappers[i] = ctx.findColumnMapperFor(type).orElseThrow(() ->\n                new IllegalArgumentException(String.format(\n                        \"Could not find column mapper for type '%s' of parameter \" +\n                        \"'%s' for constructor '%s'\", type, paramName, constructor)));\n            columnMap[i] = columnIndex;\n        }\n\n        return rs -> {\n            final Object[] params = new Object[columns];\n            for (int i = 0; i < columns; i++) {\n                params[i] = mappers[i].map(rs, columnMap[i] + 1, ctx);\n            }\n            try {\n                return constructor.newInstance(params);\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                if (e.getCause() instanceof RuntimeException) {\n                    throw (RuntimeException) e.getCause();\n                }\n                if (e.getCause() instanceof Error) {\n                    throw (Error) e.getCause();\n                }\n                throw new RuntimeException(e);\n            }\n        };\n    }\n\n    private int columnIndexForParameter(List<String> columnNames, String parameterName)\n    {\n        int result = -1;\n        for (int i = 0; i < columnNames.size(); i++) {\n            String name = columnNames.get(i);\n            if (prefix.length() > 0) {\n                if (name.length() > prefix.length() &&\n                        name.regionMatches(true, 0, prefix, 0, prefix.length())) {\n                    name = name.substring(prefix.length());\n                }\n                else {\n                    continue;\n                }\n            }\n\n            for (ColumnNameMappingStrategy strategy : nameMappingStrategies) {\n                if (strategy.nameMatches(parameterName, name)) {\n                    if (result >= 0) {\n                        throw new IllegalArgumentException(String.format(\n                                \"Constructor '%s' parameter '%s' matches multiple \" +\n                                \"columns: '%s' (%d) and '%s' (%d)\", constructor,\n                                parameterName, columnNames.get(result), result,\n                                columnNames.get(i), i));\n                    }\n                    result = i;\n                    break;\n                }\n            }\n        }\n        if (result >= 0) {\n            return result;\n        }\n        throw new IllegalArgumentException(\"Constructor '\" + constructor + \"' parameter '\" +\n                parameterName +\n                \"' has no column in the result set.  Verify that the Java \" +\n                \"compiler is configured to emit parameter names, \" +\n                \"that your result set has the columns expected, \" +\n                \"or annotate the parameter names explicitly with @ColumnName\");\n    }\n\n    private static String paramName(Parameter parameter) {\n        ColumnName dbName = parameter.getAnnotation(ColumnName.class);\n        if (dbName != null) {\n            return dbName.value();\n        }\n        return parameter.getName();\n    }\n\n    interface Factory<T> {\n        T create(ResultSet rs) throws SQLException;\n    }\n}\n","lineNo":194}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizers;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport org.jdbi.v3.core.mapper.ConstructorMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.sqlobject.SqlStatementCustomizer;\nimport org.jdbi.v3.sqlobject.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.SqlStatementCustomizingAnnotation;\n\n/**\n * Used to register a constructor mapper factory for the only constructor of a type.\n */\n@SqlStatementCustomizingAnnotation(RegisterConstructorMapper.Factory.class)\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface RegisterConstructorMapper\n{\n    Class<?>[] value();\n\n    class Factory implements SqlStatementCustomizerFactory\n    {\n\n        @Override\n        public SqlStatementCustomizer createForMethod(Annotation annotation, Class<?> sqlObjectType, Method method)\n        {\n            return create((RegisterConstructorMapper) annotation);\n        }\n\n        @Override\n        public SqlStatementCustomizer createForType(Annotation annotation, Class<?> sqlObjectType)\n        {\n            return create((RegisterConstructorMapper) annotation);\n        }\n\n        private SqlStatementCustomizer create(RegisterConstructorMapper rcm) {\n            List<RowMapperFactory> mappers = Arrays.stream(rcm.value())\n                    .map(ConstructorMapper::of)\n                    .collect(Collectors.toList());\n\n            return stmt -> mappers.forEach(stmt::registerRowMapper);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject.customizers;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jdbi.v3.core.mapper.ConstructorMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.jdbi.v3.sqlobject.SqlStatementCustomizer;\nimport org.jdbi.v3.sqlobject.SqlStatementCustomizerFactory;\nimport org.jdbi.v3.sqlobject.SqlStatementCustomizingAnnotation;\n\n/**\n * Used to register a constructor mapper factory for the only constructor of a type.\n */\n@SqlStatementCustomizingAnnotation(RegisterConstructorMapper.Factory.class)\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface RegisterConstructorMapper\n{\n    /**\n     * The type to map with ConstructorMapper.\n     * @return one or more mapped types.\n     */\n    Class<?>[] value();\n\n    /**\n     * Column name prefix for each mapped type. If omitted, defaults to no prefix. If specified, must have the same\n     * number of elements as {@link #value()}. Each <code>prefix<\/code> element is applied to the <code>value<\/code>\n     * element at the same index.\n     *\n     * @return Column name prefixes corresponding pairwise to the elements in {@link #value()}.\n     */\n    String[] prefix() default {};\n\n    class Factory implements SqlStatementCustomizerFactory\n    {\n\n        @Override\n        public SqlStatementCustomizer createForMethod(Annotation annotation, Class<?> sqlObjectType, Method method)\n        {\n            return create((RegisterConstructorMapper) annotation);\n        }\n\n        @Override\n        public SqlStatementCustomizer createForType(Annotation annotation, Class<?> sqlObjectType)\n        {\n            return create((RegisterConstructorMapper) annotation);\n        }\n\n        private SqlStatementCustomizer create(RegisterConstructorMapper rcm) {\n            Class<?>[] types = rcm.value();\n            String[] prefixes = rcm.prefix();\n            List<RowMapperFactory> mappers = new ArrayList<>(types.length);\n            if (prefixes.length == 0) {\n                for (Class<?> type : types) {\n                    mappers.add(ConstructorMapper.of(type));\n                }\n            }\n            else if (prefixes.length == types.length) {\n                for (int i = 0; i < types.length; i++) {\n                    mappers.add(ConstructorMapper.of(types[i], prefixes[i]));\n                }\n            }\n            else {\n                throw new IllegalStateException(\"RegisterConstructorMapper.prefix() must have the same number of elements as value()\");\n            }\n\n            return stmt -> mappers.forEach(stmt::registerRowMapper);\n        }\n    }\n}\n","lineNo":70}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.MemberResolver;\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.ResolvedTypeWithMembers;\nimport com.fasterxml.classmate.TypeResolver;\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.CallbackFilter;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\nimport net.sf.cglib.proxy.NoOp;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.skife.jdbi.v2.SqlObjectContext;\n\nclass SqlObject\n{\n    private static final TypeResolver                                  typeResolver  = new TypeResolver();\n    private static final Map<Method, Handler>                          mixinHandlers = new HashMap<Method, Handler>();\n    private static final ConcurrentMap<Class<?>, Map<Method, Handler>> handlersCache = new ConcurrentHashMap<Class<?>, Map<Method, Handler>>();\n    private static final ConcurrentMap<Class<?>, Factory>              factories     = new ConcurrentHashMap<Class<?>, Factory>();\n\n    private static Method jdk8DefaultMethod = null;\n\n    static {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n        mixinHandlers.putAll(TransmogrifierHelper.handlers());\n\n        try {\n            SqlObject.jdk8DefaultMethod = Method.class.getMethod(\"isDefault\");\n        }\n        catch (NoSuchMethodException e) {\n            // fallthrough, expected on e.g. JDK7\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <T> T buildSqlObject(final Class<T> sqlObjectType, final HandleDing handle)\n    {\n        Factory f;\n        if (factories.containsKey(sqlObjectType)) {\n            f = factories.get(sqlObjectType);\n        }\n        else {\n            Enhancer e = new Enhancer();\n            e.setClassLoader(sqlObjectType.getClassLoader());\n\n            List<Class> interfaces = new ArrayList<Class>();\n            interfaces.add(CloseInternalDoNotUseThisClass.class);\n            if (sqlObjectType.isInterface()) {\n                interfaces.add(sqlObjectType);\n            }\n            else {\n                e.setSuperclass(sqlObjectType);\n            }\n            e.setInterfaces(interfaces.toArray(new Class[interfaces.size()]));\n            final SqlObject so = new SqlObject(sqlObjectType, buildHandlersFor(sqlObjectType), handle);\n\n            e.setCallbackFilter(new CallbackFilter() {\n\n                @Override\n                public int accept(Method method) {\n                    if (jdk8DefaultMethod == null) {\n                        return 0;\n                    }\n                    else {\n                        try {\n                            Boolean result = (Boolean) jdk8DefaultMethod.invoke(method);\n                            return Boolean.TRUE.equals(result) ? 1 : 0;\n                        } catch (IllegalArgumentException e) {\n                            return 0;\n                        } catch (IllegalAccessException e) {\n                            return 0;\n                        } catch (InvocationTargetException e) {\n                            return 0;\n                        }\n                    }\n                }\n\n            });\n\n            e.setCallbacks(new Callback[] {\n                    new MethodInterceptor() {\n                        @Override\n                        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                            return so.invoke(o, method, objects, methodProxy);\n                        }\n                    },\n                    NoOp.INSTANCE\n            });\n            T t = (T) e.create();\n            T actual = (T) factories.putIfAbsent(sqlObjectType, (Factory) t);\n            if (actual == null) {\n                return t;\n            }\n            f = (Factory) actual;\n        }\n\n        final SqlObject so = new SqlObject(sqlObjectType, buildHandlersFor(sqlObjectType), handle);\n        return (T) f.newInstance(new Callback[] {\n                new MethodInterceptor() {\n                    @Override\n                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                        return so.invoke(o, method, objects, methodProxy);\n                    }\n                },\n                NoOp.INSTANCE\n        });\n    }\n\n    private static Map<Method, Handler> buildHandlersFor(Class<?> sqlObjectType)\n    {\n        if (handlersCache.containsKey(sqlObjectType)) {\n            return handlersCache.get(sqlObjectType);\n        }\n\n        final MemberResolver mr = new MemberResolver(typeResolver);\n        final ResolvedType sql_object_type = typeResolver.resolve(sqlObjectType);\n\n        final ResolvedTypeWithMembers d = mr.resolve(sql_object_type, null, null);\n\n        final Map<Method, Handler> handlers = new HashMap<Method, Handler>();\n        for (final ResolvedMethod method : d.getMemberMethods()) {\n            final Method raw_method = method.getRawMember();\n\n            if (raw_method.isAnnotationPresent(SqlQuery.class)) {\n                handlers.put(raw_method, new QueryHandler(sqlObjectType, method, ResultReturnThing.forType(method)));\n            }\n            else if (raw_method.isAnnotationPresent(SqlUpdate.class)) {\n                handlers.put(raw_method, new UpdateHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlBatch.class)) {\n                handlers.put(raw_method, new BatchHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlCall.class)) {\n                handlers.put(raw_method, new CallHandler(sqlObjectType, method));\n            }\n            else if(raw_method.isAnnotationPresent(CreateSqlObject.class)) {\n                handlers.put(raw_method, new CreateSqlObjectHandler(raw_method.getReturnType()));\n            }\n            else if (method.getName().equals(\"close\") && method.getRawMember().getParameterTypes().length == 0) {\n                handlers.put(raw_method, new CloseHandler());\n            }\n            else if (method.getName().equals(\"finalize\") && method.getRawMember().getParameterTypes().length == 0) {\n                // no handler for finalize()\n            }\n            else if (raw_method.isAnnotationPresent(Transaction.class)) {\n                handlers.put(raw_method, new PassThroughTransactionHandler(raw_method.getAnnotation(Transaction.class)));\n            }\n            else if (mixinHandlers.containsKey(raw_method)) {\n                handlers.put(raw_method, mixinHandlers.get(raw_method));\n            }\n            else {\n                handlers.put(raw_method, new PassThroughHandler(raw_method));\n            }\n        }\n\n        // this is an implicit mixin, not an explicit one, so we need to *always* add it\n        handlers.putAll(CloseInternalDoNotUseThisClass.Helper.handlers());\n\n        handlers.putAll(EqualsHandler.handler());\n        handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n        handlers.putAll(HashCodeHandler.handler());\n\n        handlersCache.put(sqlObjectType, handlers);\n\n        return handlers;\n    }\n\n    private final Class<?>             sqlObjectType;\n    private final Map<Method, Handler> handlers;\n    private final HandleDing           ding;\n\n    SqlObject(Class<?> sqlObjectType, Map<Method, Handler> handlers, HandleDing ding)\n    {\n        this.sqlObjectType = sqlObjectType;\n        this.handlers = handlers;\n        this.ding = ding;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args, MethodProxy mp) throws Throwable\n    {\n        final Handler handler = handlers.get(method);\n\n        // If there is no handler, pretend we are just an Object and don't open a connection (Issue #82)\n        if (handler == null) {\n            return mp.invokeSuper(proxy, args);\n        }\n\n        Throwable doNotMask = null;\n        String methodName = method.toString();\n        SqlObjectContext oldContext = ding.setContext(new SqlObjectContext(sqlObjectType, method));\n        try {\n            ding.retain(methodName);\n            return handler.invoke(ding, proxy, args, mp);\n        }\n        catch (Throwable e) {\n            doNotMask = e;\n            throw e;\n        }\n        finally {\n            ding.setContext(oldContext);\n            try {\n                ding.release(methodName);\n            }\n            catch (Throwable e) {\n                if (doNotMask==null) {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public static void close(Object sqlObject)\n    {\n        if (!(sqlObject instanceof CloseInternalDoNotUseThisClass)) {\n            throw new IllegalArgumentException(sqlObject + \" is not a sql object\");\n        }\n        CloseInternalDoNotUseThisClass closer = (CloseInternalDoNotUseThisClass) sqlObject;\n        closer.___jdbi_close___();\n    }\n\n    static String getSql(SqlCall q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport static java.util.Collections.synchronizedMap;\n\nimport com.fasterxml.classmate.MemberResolver;\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.ResolvedTypeWithMembers;\nimport com.fasterxml.classmate.TypeResolver;\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.CallbackFilter;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\nimport net.sf.cglib.proxy.NoOp;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\nimport org.skife.jdbi.v2.SqlObjectContext;\n\nclass SqlObject\n{\n    private static final TypeResolver                        typeResolver  = new TypeResolver();\n    private static final Map<Method, Handler>                mixinHandlers = new HashMap<Method, Handler>();\n    private static final Map<Class<?>, Map<Method, Handler>> handlersCache = synchronizedMap(new WeakHashMap<Class<?>, Map<Method, Handler>>());\n    private static final Map<Class<?>, Factory>              factories     = synchronizedMap(new WeakHashMap<Class<?>, Factory>());\n\n    private static Method jdk8DefaultMethod = null;\n\n    static {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n        mixinHandlers.putAll(TransmogrifierHelper.handlers());\n\n        try {\n            SqlObject.jdk8DefaultMethod = Method.class.getMethod(\"isDefault\");\n        }\n        catch (NoSuchMethodException e) {\n            // fallthrough, expected on e.g. JDK7\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <T> T buildSqlObject(final Class<T> sqlObjectType, final HandleDing handle)\n    {\n        Factory f;\n        if (factories.containsKey(sqlObjectType)) {\n            f = factories.get(sqlObjectType);\n        }\n        else {\n            Enhancer e = new Enhancer();\n            e.setClassLoader(sqlObjectType.getClassLoader());\n\n            List<Class> interfaces = new ArrayList<Class>();\n            interfaces.add(CloseInternalDoNotUseThisClass.class);\n            if (sqlObjectType.isInterface()) {\n                interfaces.add(sqlObjectType);\n            }\n            else {\n                e.setSuperclass(sqlObjectType);\n            }\n            e.setInterfaces(interfaces.toArray(new Class[interfaces.size()]));\n            final SqlObject so = new SqlObject(sqlObjectType, buildHandlersFor(sqlObjectType), handle);\n\n            e.setCallbackFilter(new CallbackFilter() {\n\n                @Override\n                public int accept(Method method) {\n                    if (jdk8DefaultMethod == null) {\n                        return 0;\n                    }\n                    else {\n                        try {\n                            Boolean result = (Boolean) jdk8DefaultMethod.invoke(method);\n                            return Boolean.TRUE.equals(result) ? 1 : 0;\n                        } catch (IllegalArgumentException e) {\n                            return 0;\n                        } catch (IllegalAccessException e) {\n                            return 0;\n                        } catch (InvocationTargetException e) {\n                            return 0;\n                        }\n                    }\n                }\n\n            });\n\n            e.setCallbacks(new Callback[] {\n                    new MethodInterceptor() {\n                        @Override\n                        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                            return so.invoke(o, method, objects, methodProxy);\n                        }\n                    },\n                    NoOp.INSTANCE\n            });\n            T t = (T) e.create();\n\n            synchronized (factories) {\n                f = factories.get(sqlObjectType);\n                if (f == null) {\n                    f = (Factory) t;\n                    factories.put(sqlObjectType, f);\n                }\n            }\n        }\n\n        final SqlObject so = new SqlObject(sqlObjectType, buildHandlersFor(sqlObjectType), handle);\n        return (T) f.newInstance(new Callback[] {\n                new MethodInterceptor() {\n                    @Override\n                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                        return so.invoke(o, method, objects, methodProxy);\n                    }\n                },\n                NoOp.INSTANCE\n        });\n    }\n\n    private static Map<Method, Handler> buildHandlersFor(Class<?> sqlObjectType)\n    {\n        if (handlersCache.containsKey(sqlObjectType)) {\n            return handlersCache.get(sqlObjectType);\n        }\n\n        final MemberResolver mr = new MemberResolver(typeResolver);\n        final ResolvedType sql_object_type = typeResolver.resolve(sqlObjectType);\n\n        final ResolvedTypeWithMembers d = mr.resolve(sql_object_type, null, null);\n\n        final Map<Method, Handler> handlers = new HashMap<Method, Handler>();\n        for (final ResolvedMethod method : d.getMemberMethods()) {\n            final Method raw_method = method.getRawMember();\n\n            if (raw_method.isAnnotationPresent(SqlQuery.class)) {\n                handlers.put(raw_method, new QueryHandler(sqlObjectType, method, ResultReturnThing.forType(method)));\n            }\n            else if (raw_method.isAnnotationPresent(SqlUpdate.class)) {\n                handlers.put(raw_method, new UpdateHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlBatch.class)) {\n                handlers.put(raw_method, new BatchHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlCall.class)) {\n                handlers.put(raw_method, new CallHandler(sqlObjectType, method));\n            }\n            else if(raw_method.isAnnotationPresent(CreateSqlObject.class)) {\n                handlers.put(raw_method, new CreateSqlObjectHandler(raw_method.getReturnType()));\n            }\n            else if (method.getName().equals(\"close\") && method.getRawMember().getParameterTypes().length == 0) {\n                handlers.put(raw_method, new CloseHandler());\n            }\n            else if (method.getName().equals(\"finalize\") && method.getRawMember().getParameterTypes().length == 0) {\n                // no handler for finalize()\n            }\n            else if (raw_method.isAnnotationPresent(Transaction.class)) {\n                handlers.put(raw_method, new PassThroughTransactionHandler(raw_method.getAnnotation(Transaction.class)));\n            }\n            else if (mixinHandlers.containsKey(raw_method)) {\n                handlers.put(raw_method, mixinHandlers.get(raw_method));\n            }\n            else {\n                handlers.put(raw_method, new PassThroughHandler(raw_method));\n            }\n        }\n\n        // this is an implicit mixin, not an explicit one, so we need to *always* add it\n        handlers.putAll(CloseInternalDoNotUseThisClass.Helper.handlers());\n\n        handlers.putAll(EqualsHandler.handler());\n        handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n        handlers.putAll(HashCodeHandler.handler());\n\n        handlersCache.put(sqlObjectType, handlers);\n\n        return handlers;\n    }\n\n    private final Class<?>             sqlObjectType;\n    private final Map<Method, Handler> handlers;\n    private final HandleDing           ding;\n\n    SqlObject(Class<?> sqlObjectType, Map<Method, Handler> handlers, HandleDing ding)\n    {\n        this.sqlObjectType = sqlObjectType;\n        this.handlers = handlers;\n        this.ding = ding;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args, MethodProxy mp) throws Throwable\n    {\n        final Handler handler = handlers.get(method);\n\n        // If there is no handler, pretend we are just an Object and don't open a connection (Issue #82)\n        if (handler == null) {\n            return mp.invokeSuper(proxy, args);\n        }\n\n        Throwable doNotMask = null;\n        String methodName = method.toString();\n        SqlObjectContext oldContext = ding.setContext(new SqlObjectContext(sqlObjectType, method));\n        try {\n            ding.retain(methodName);\n            return handler.invoke(ding, proxy, args, mp);\n        }\n        catch (Throwable e) {\n            doNotMask = e;\n            throw e;\n        }\n        finally {\n            ding.setContext(oldContext);\n            try {\n                ding.release(methodName);\n            }\n            catch (Throwable e) {\n                if (doNotMask==null) {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public static void close(Object sqlObject)\n    {\n        if (!(sqlObject instanceof CloseInternalDoNotUseThisClass)) {\n            throw new IllegalArgumentException(sqlObject + \" is not a sql object\");\n        }\n        CloseInternalDoNotUseThisClass closer = (CloseInternalDoNotUseThisClass) sqlObject;\n        closer.___jdbi_close___();\n    }\n\n    static String getSql(SqlCall q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n}\n","lineNo":66}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage jdbi.doc;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.H2DatabaseRule;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMapperFactory;\nimport org.jdbi.v3.core.mapper.ConstructorMapper;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class ResultsTest {\n    @Rule\n    public H2DatabaseRule db = new H2DatabaseRule();\n    private Handle handle;\n\n    @Before\n    public void getHandle() {\n        handle = db.getSharedHandle();\n    }\n\n    // tag::headlineExample[]\n    public static class User {\n        final int id;\n        final String name;\n\n        public User(int id, String name) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        handle.execute(\"CREATE TABLE user (id INTEGER PRIMARY KEY AUTO_INCREMENT, name VARCHAR)\");\n        for (String name : Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"Data\")) {\n            handle.execute(\"INSERT INTO user(name) VALUES (?)\", name);\n        }\n    }\n\n    @Test\n    public void findBob() {\n        User u = findUserById(2).orElseThrow(() -> new AssertionError(\"No user found\"));\n        assertThat(u.id).isEqualTo(2);\n        assertThat(u.name).isEqualTo(\"Bob\");\n    }\n\n    public Optional<User> findUserById(long id) {\n        return handle.createQuery(\"SELECT * FROM user WHERE id=:id\")\n            .bind(\"id\", id)\n            .map((rs, ctx) -> new User(rs.getInt(\"id\"), rs.getString(\"name\")))\n            .findFirst();\n    }\n    // end::headlineExample[]\n\n    // tag::rowMapper[]\n    static final String SELECT_ALL_USERS = \"SELECT * FROM user ORDER BY id ASC\";\n\n    static final class UserMapper implements RowMapper<User> {\n        @Override\n        public User map(ResultSet r, StatementContext ctx) throws SQLException {\n            return new User(r.getInt(\"id\"), r.getString(\"name\"));\n        }\n    }\n\n    @Test\n    public void rowMapper() {\n        List<User> users = handle.createQuery(SELECT_ALL_USERS)\n            .map(new UserMapper())\n            .list();\n\n        assertThat(users).hasSize(4);\n        assertThat(users.get(3).name).isEqualTo(\"Data\");\n    }\n    // end::rowMapper[]\n\n    // tag::rowMapperFactory[]\n    @Test\n    public void rowMapperFactory() {\n        handle.registerRowMapper(new RowMapperFactory() {\n            @Override\n            public Optional<RowMapper<?>> build(Type type, StatementContext ctx) {\n                return type == User.class ?\n                        Optional.of(new UserMapper()) :\n                            Optional.empty();\n            }\n        });\n\n        try (Stream<User> s = handle.createQuery(SELECT_ALL_USERS)\n            .mapTo(User.class)\n            .stream())\n        {\n            assertThat(s.filter(u -> u.id > 2)\n                .map(u -> u.name)\n                .findFirst()).contains(\"Charlie\");\n        }\n    }\n    // end::rowMapperFactory[]\n\n    // tag::constructorMapper[]\n    @Test\n    public void constructorMapper() {\n        handle.registerRowMapper(ConstructorMapper.of(User.class));\n        Set<User> userSet = handle.createQuery(SELECT_ALL_USERS)\n            .mapTo(User.class)\n            .collect(Collectors.toSet());\n\n        assertThat(userSet).hasSize(4);\n    }\n    // end::constructorMapper[]\n\n    // tag::columnMapper[]\n    public static class UserName {\n        final String name;\n\n        public UserName(String name) {\n            this.name = name;\n        }\n    }\n\n    public static class NamedUser {\n        final int id;\n        final UserName name;\n\n        public NamedUser(int id, UserName name) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n\n    static class UserNameColumnMapperFactory implements ColumnMapperFactory {\n        @Override\n        public Optional<ColumnMapper<?>> build(Type type, StatementContext ctx) {\n            return type == UserName.class ?\n                    Optional.of((rs, index, cx) -> new UserName(rs.getString(index))) :\n                        Optional.empty();\n        }\n    }\n\n    @Test\n    public void columnMapper() {\n        handle.registerColumnMapper(new UserNameColumnMapperFactory());\n        handle.registerRowMapper(ConstructorMapper.of(NamedUser.class));\n\n        NamedUser bob = handle.createQuery(\"SELECT id, name FROM user WHERE name = :name\")\n            .bind(\"name\", \"Bob\")\n            .mapTo(NamedUser.class)\n            .findOnly();\n\n        assertThat(bob.name.name).isEqualTo(\"Bob\");\n    }\n    // end::columnMapper[]\n\n    // tag::beanMapper[]\n    public static class UserBean {\n        private int id;\n        private String name;\n\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n    @Test\n    public void beanMapper() {\n        UserBean charlie = handle.createQuery(\"SELECT id, name FROM user WHERE name = :name\")\n            .bind(\"name\", \"Charlie\")\n            .mapToBean(UserBean.class)\n            .findOnly();\n\n        assertThat(charlie.getName()).isEqualTo(\"Charlie\");\n    }\n    // end::beanMapper[]\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage jdbi.doc;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.H2DatabaseRule;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMapperFactory;\nimport org.jdbi.v3.core.mapper.ConstructorMapper;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class ResultsTest {\n    @Rule\n    public H2DatabaseRule db = new H2DatabaseRule();\n    private Handle handle;\n\n    @Before\n    public void getHandle() {\n        handle = db.getSharedHandle();\n    }\n\n    // tag::headlineExample[]\n    public static class User {\n        final int id;\n        final String name;\n\n        public User(int id, String name) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        handle.execute(\"CREATE TABLE user (id INTEGER PRIMARY KEY AUTO_INCREMENT, name VARCHAR)\");\n        for (String name : Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"Data\")) {\n            handle.execute(\"INSERT INTO user(name) VALUES (?)\", name);\n        }\n    }\n\n    @Test\n    public void findBob() {\n        User u = findUserById(2).orElseThrow(() -> new AssertionError(\"No user found\"));\n        assertThat(u.id).isEqualTo(2);\n        assertThat(u.name).isEqualTo(\"Bob\");\n    }\n\n    public Optional<User> findUserById(long id) {\n        RowMapper<User> userMapper =\n                (rs, ctx) -> new User(rs.getInt(\"id\"), rs.getString(\"name\"));\n        return handle.createQuery(\"SELECT * FROM user WHERE id=:id\")\n            .bind(\"id\", id)\n            .map(userMapper)\n            .findFirst();\n    }\n    // end::headlineExample[]\n\n    // tag::rowMapper[]\n    static final String SELECT_ALL_USERS = \"SELECT * FROM user ORDER BY id ASC\";\n\n    static final class UserMapper implements RowMapper<User> {\n        @Override\n        public User map(ResultSet r, StatementContext ctx) throws SQLException {\n            return new User(r.getInt(\"id\"), r.getString(\"name\"));\n        }\n    }\n\n    @Test\n    public void rowMapper() {\n        List<User> users = handle.createQuery(SELECT_ALL_USERS)\n            .map(new UserMapper())\n            .list();\n\n        assertThat(users).hasSize(4);\n        assertThat(users.get(3).name).isEqualTo(\"Data\");\n    }\n    // end::rowMapper[]\n\n    // tag::rowMapperFactory[]\n    @Test\n    public void rowMapperFactory() {\n        handle.registerRowMapper(new RowMapperFactory() {\n            @Override\n            public Optional<RowMapper<?>> build(Type type, StatementContext ctx) {\n                return type == User.class ?\n                        Optional.of(new UserMapper()) :\n                            Optional.empty();\n            }\n        });\n\n        try (Stream<User> s = handle.createQuery(SELECT_ALL_USERS)\n            .mapTo(User.class)\n            .stream())\n        {\n            assertThat(s.filter(u -> u.id > 2)\n                .map(u -> u.name)\n                .findFirst()).contains(\"Charlie\");\n        }\n    }\n    // end::rowMapperFactory[]\n\n    // tag::constructorMapper[]\n    @Test\n    public void constructorMapper() {\n        handle.registerRowMapper(ConstructorMapper.of(User.class));\n        Set<User> userSet = handle.createQuery(SELECT_ALL_USERS)\n            .mapTo(User.class)\n            .collect(Collectors.toSet());\n\n        assertThat(userSet).hasSize(4);\n    }\n    // end::constructorMapper[]\n\n    // tag::columnMapper[]\n    public static class UserName {\n        final String name;\n\n        public UserName(String name) {\n            this.name = name;\n        }\n    }\n\n    public static class NamedUser {\n        final int id;\n        final UserName name;\n\n        public NamedUser(int id, UserName name) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n\n    static class UserNameColumnMapperFactory implements ColumnMapperFactory {\n        @Override\n        public Optional<ColumnMapper<?>> build(Type type, StatementContext ctx) {\n            return type == UserName.class ?\n                    Optional.of((rs, index, cx) -> new UserName(rs.getString(index))) :\n                        Optional.empty();\n        }\n    }\n\n    @Test\n    public void columnMapper() {\n        handle.registerColumnMapper(new UserNameColumnMapperFactory());\n        handle.registerRowMapper(ConstructorMapper.of(NamedUser.class));\n\n        NamedUser bob = handle.createQuery(\"SELECT id, name FROM user WHERE name = :name\")\n            .bind(\"name\", \"Bob\")\n            .mapTo(NamedUser.class)\n            .findOnly();\n\n        assertThat(bob.name.name).isEqualTo(\"Bob\");\n    }\n    // end::columnMapper[]\n\n    // tag::beanMapper[]\n    public static class UserBean {\n        private int id;\n        private String name;\n\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n    @Test\n    public void beanMapper() {\n        UserBean charlie = handle.createQuery(\"SELECT id, name FROM user WHERE name = :name\")\n            .bind(\"name\", \"Charlie\")\n            .mapToBean(UserBean.class)\n            .findOnly();\n\n        assertThat(charlie.getName()).isEqualTo(\"Charlie\");\n    }\n    // end::beanMapper[]\n}\n","lineNo":77}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage jdbi.doc;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.H2DatabaseRule;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMapperFactory;\nimport org.jdbi.v3.core.mapper.ConstructorMapper;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class ResultsTest {\n    @Rule\n    public H2DatabaseRule db = new H2DatabaseRule();\n    private Handle handle;\n\n    @Before\n    public void getHandle() {\n        handle = db.getSharedHandle();\n    }\n\n    // tag::headlineExample[]\n    public static class User {\n        final int id;\n        final String name;\n\n        public User(int id, String name) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        handle.execute(\"CREATE TABLE user (id INTEGER PRIMARY KEY AUTO_INCREMENT, name VARCHAR)\");\n        for (String name : Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"Data\")) {\n            handle.execute(\"INSERT INTO user(name) VALUES (?)\", name);\n        }\n    }\n\n    @Test\n    public void findBob() {\n        User u = findUserById(2).orElseThrow(() -> new AssertionError(\"No user found\"));\n        assertThat(u.id).isEqualTo(2);\n        assertThat(u.name).isEqualTo(\"Bob\");\n    }\n\n    public Optional<User> findUserById(long id) {\n        return handle.createQuery(\"SELECT * FROM user WHERE id=:id\")\n            .bind(\"id\", id)\n            .map((rs, ctx) -> new User(rs.getInt(\"id\"), rs.getString(\"name\")))\n            .findFirst();\n    }\n    // end::headlineExample[]\n\n    // tag::rowMapper[]\n    static final String SELECT_ALL_USERS = \"SELECT * FROM user ORDER BY id ASC\";\n\n    static final class UserMapper implements RowMapper<User> {\n        @Override\n        public User map(ResultSet r, StatementContext ctx) throws SQLException {\n            return new User(r.getInt(\"id\"), r.getString(\"name\"));\n        }\n    }\n\n    @Test\n    public void rowMapper() {\n        List<User> users = handle.createQuery(SELECT_ALL_USERS)\n            .map(new UserMapper())\n            .list();\n\n        assertThat(users).hasSize(4);\n        assertThat(users.get(3).name).isEqualTo(\"Data\");\n    }\n    // end::rowMapper[]\n\n    // tag::rowMapperFactory[]\n    @Test\n    public void rowMapperFactory() {\n        handle.registerRowMapper(new RowMapperFactory() {\n            @Override\n            public Optional<RowMapper<?>> build(Type type, StatementContext ctx) {\n                return type == User.class ?\n                        Optional.of(new UserMapper()) :\n                            Optional.empty();\n            }\n        });\n\n        try (Stream<User> s = handle.createQuery(SELECT_ALL_USERS)\n            .mapTo(User.class)\n            .stream())\n        {\n            assertThat(s.filter(u -> u.id > 2)\n                .map(u -> u.name)\n                .findFirst()).contains(\"Charlie\");\n        }\n    }\n    // end::rowMapperFactory[]\n\n    // tag::constructorMapper[]\n    @Test\n    public void constructorMapper() {\n        handle.registerRowMapper(ConstructorMapper.of(User.class));\n        Set<User> userSet = handle.createQuery(SELECT_ALL_USERS)\n            .mapTo(User.class)\n            .collect(Collectors.toSet());\n\n        assertThat(userSet).hasSize(4);\n    }\n    // end::constructorMapper[]\n\n    // tag::columnMapper[]\n    public static class UserName {\n        final String name;\n\n        public UserName(String name) {\n            this.name = name;\n        }\n    }\n\n    public static class NamedUser {\n        final int id;\n        final UserName name;\n\n        public NamedUser(int id, UserName name) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n\n    static class UserNameColumnMapperFactory implements ColumnMapperFactory {\n        @Override\n        public Optional<ColumnMapper<?>> build(Type type, StatementContext ctx) {\n            return type == UserName.class ?\n                    Optional.of((rs, index, cx) -> new UserName(rs.getString(index))) :\n                        Optional.empty();\n        }\n    }\n\n    @Test\n    public void columnMapper() {\n        handle.registerColumnMapper(new UserNameColumnMapperFactory());\n        handle.registerRowMapper(ConstructorMapper.of(NamedUser.class));\n\n        NamedUser bob = handle.createQuery(\"SELECT id, name FROM user WHERE name = :name\")\n            .bind(\"name\", \"Bob\")\n            .mapTo(NamedUser.class)\n            .findOnly();\n\n        assertThat(bob.name.name).isEqualTo(\"Bob\");\n    }\n    // end::columnMapper[]\n\n    // tag::beanMapper[]\n    public static class UserBean {\n        private int id;\n        private String name;\n\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n    @Test\n    public void beanMapper() {\n        UserBean charlie = handle.createQuery(\"SELECT id, name FROM user WHERE name = :name\")\n            .bind(\"name\", \"Charlie\")\n            .mapToBean(UserBean.class)\n            .findOnly();\n\n        assertThat(charlie.getName()).isEqualTo(\"Charlie\");\n    }\n    // end::beanMapper[]\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage jdbi.doc;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.core.H2DatabaseRule;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.StatementContext;\nimport org.jdbi.v3.core.mapper.ColumnMapper;\nimport org.jdbi.v3.core.mapper.ColumnMapperFactory;\nimport org.jdbi.v3.core.mapper.ConstructorMapper;\nimport org.jdbi.v3.core.mapper.RowMapper;\nimport org.jdbi.v3.core.mapper.RowMapperFactory;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class ResultsTest {\n    @Rule\n    public H2DatabaseRule db = new H2DatabaseRule();\n    private Handle handle;\n\n    @Before\n    public void getHandle() {\n        handle = db.getSharedHandle();\n    }\n\n    // tag::headlineExample[]\n    public static class User {\n        final int id;\n        final String name;\n\n        public User(int id, String name) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        handle.execute(\"CREATE TABLE user (id INTEGER PRIMARY KEY AUTO_INCREMENT, name VARCHAR)\");\n        for (String name : Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"Data\")) {\n            handle.execute(\"INSERT INTO user(name) VALUES (?)\", name);\n        }\n    }\n\n    @Test\n    public void findBob() {\n        User u = findUserById(2).orElseThrow(() -> new AssertionError(\"No user found\"));\n        assertThat(u.id).isEqualTo(2);\n        assertThat(u.name).isEqualTo(\"Bob\");\n    }\n\n    public Optional<User> findUserById(long id) {\n        RowMapper<User> userMapper =\n                (rs, ctx) -> new User(rs.getInt(\"id\"), rs.getString(\"name\"));\n        return handle.createQuery(\"SELECT * FROM user WHERE id=:id\")\n            .bind(\"id\", id)\n            .map(userMapper)\n            .findFirst();\n    }\n    // end::headlineExample[]\n\n    // tag::rowMapper[]\n    static final String SELECT_ALL_USERS = \"SELECT * FROM user ORDER BY id ASC\";\n\n    static final class UserMapper implements RowMapper<User> {\n        @Override\n        public User map(ResultSet r, StatementContext ctx) throws SQLException {\n            return new User(r.getInt(\"id\"), r.getString(\"name\"));\n        }\n    }\n\n    @Test\n    public void rowMapper() {\n        List<User> users = handle.createQuery(SELECT_ALL_USERS)\n            .map(new UserMapper())\n            .list();\n\n        assertThat(users).hasSize(4);\n        assertThat(users.get(3).name).isEqualTo(\"Data\");\n    }\n    // end::rowMapper[]\n\n    // tag::rowMapperFactory[]\n    @Test\n    public void rowMapperFactory() {\n        handle.registerRowMapper(new RowMapperFactory() {\n            @Override\n            public Optional<RowMapper<?>> build(Type type, StatementContext ctx) {\n                return type == User.class ?\n                        Optional.of(new UserMapper()) :\n                            Optional.empty();\n            }\n        });\n\n        try (Stream<User> s = handle.createQuery(SELECT_ALL_USERS)\n            .mapTo(User.class)\n            .stream())\n        {\n            assertThat(s.filter(u -> u.id > 2)\n                .map(u -> u.name)\n                .findFirst()).contains(\"Charlie\");\n        }\n    }\n    // end::rowMapperFactory[]\n\n    // tag::constructorMapper[]\n    @Test\n    public void constructorMapper() {\n        handle.registerRowMapper(ConstructorMapper.of(User.class));\n        Set<User> userSet = handle.createQuery(SELECT_ALL_USERS)\n            .mapTo(User.class)\n            .collect(Collectors.toSet());\n\n        assertThat(userSet).hasSize(4);\n    }\n    // end::constructorMapper[]\n\n    // tag::columnMapper[]\n    public static class UserName {\n        final String name;\n\n        public UserName(String name) {\n            this.name = name;\n        }\n    }\n\n    public static class NamedUser {\n        final int id;\n        final UserName name;\n\n        public NamedUser(int id, UserName name) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n\n    static class UserNameColumnMapperFactory implements ColumnMapperFactory {\n        @Override\n        public Optional<ColumnMapper<?>> build(Type type, StatementContext ctx) {\n            return type == UserName.class ?\n                    Optional.of((rs, index, cx) -> new UserName(rs.getString(index))) :\n                        Optional.empty();\n        }\n    }\n\n    @Test\n    public void columnMapper() {\n        handle.registerColumnMapper(new UserNameColumnMapperFactory());\n        handle.registerRowMapper(ConstructorMapper.of(NamedUser.class));\n\n        NamedUser bob = handle.createQuery(\"SELECT id, name FROM user WHERE name = :name\")\n            .bind(\"name\", \"Bob\")\n            .mapTo(NamedUser.class)\n            .findOnly();\n\n        assertThat(bob.name.name).isEqualTo(\"Bob\");\n    }\n    // end::columnMapper[]\n\n    // tag::beanMapper[]\n    public static class UserBean {\n        private int id;\n        private String name;\n\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n    @Test\n    public void beanMapper() {\n        UserBean charlie = handle.createQuery(\"SELECT id, name FROM user WHERE name = :name\")\n            .bind(\"name\", \"Charlie\")\n            .mapToBean(UserBean.class)\n            .findOnly();\n\n        assertThat(charlie.getName()).isEqualTo(\"Charlie\");\n    }\n    // end::beanMapper[]\n}\n","lineNo":77}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport static java.util.Arrays.asList;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.jdbi.v3.core.ExtraMatchers.equalsOneOf;\nimport static org.junit.Assert.assertThat;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport org.jdbi.v3.core.Jdbi;\nimport org.jdbi.v3.core.H2DatabaseRule;\nimport org.jdbi.v3.core.Handle;\nimport org.jdbi.v3.core.Query;\nimport org.jdbi.v3.core.Something;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.sqlobject.customizers.BatchChunkSize;\nimport org.jdbi.v3.sqlobject.customizers.UseRowMapper;\nimport org.jdbi.v3.sqlobject.customizers.RegisterRowMapper;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class TestDocumentation\n{\n    @Rule\n    public H2DatabaseRule db = new H2DatabaseRule().withPlugin(new SqlObjectPlugin());\n\n    @Test\n    public void testFiveMinuteFluentApi() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.execute(\"insert into something (id, name) values (?, ?)\", 1, \"Brian\");\n\n            String name = h.createQuery(\"select name from something where id = :id\")\n                .bind(\"id\", 1)\n                .mapTo(String.class)\n                .findOnly();\n            assertThat(name, equalTo(\"Brian\"));\n        }\n    }\n\n    public interface MyDAO\n    {\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        void insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n\n        @SqlQuery(\"select name from something where id = :id\")\n        String findNameById(@Bind(\"id\") int id);\n    }\n\n    @Test\n    public void testFiveMinuteSqlObjectExample() throws Exception\n    {\n        db.getJdbi().useExtension(MyDAO.class, dao -> {\n            dao.insert(2, \"Aaron\");\n\n            String name = dao.findNameById(2);\n\n            assertThat(name, equalTo(\"Aaron\"));\n        });\n    }\n\n\n    @Test\n    public void testObtainHandleViaOpen() throws Exception\n    {\n        try (Handle handle = db.getJdbi().open()) { }\n    }\n\n    @Test\n    public void testObtainHandleInCallback() throws Exception\n    {\n        Jdbi dbi = Jdbi.create(\"jdbc:h2:mem:\" + UUID.randomUUID());\n        dbi.useHandle(handle -> handle.execute(\"create table silly (id int)\"));\n    }\n\n    @Test\n    public void testExecuteSomeStatements() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.execute(\"insert into something (id, name) values (?, ?)\", 3, \"Patrick\");\n\n            List<Map<String, Object>> rs = h.select(\"select id, name from something\");\n            assertThat(rs.size(), equalTo(1));\n\n            Map<String, Object> row = rs.get(0);\n            assertThat(row.get(\"id\"), equalTo(3L));\n            assertThat(row.get(\"name\"), equalTo(\"Patrick\"));\n        }\n    }\n\n    @Test\n    public void testFluentUpdate() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.createStatement(\"insert into something(id, name) values (:id, :name)\")\n                .bind(\"id\", 4)\n                .bind(\"name\", \"Martin\")\n                .execute();\n        }\n    }\n\n    @Test\n    public void testMappingExampleChainedIterator2() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.execute(\"insert into something (id, name) values (1, 'Brian')\");\n            h.execute(\"insert into something (id, name) values (2, 'Keith')\");\n\n            Iterator<String> rs = h.createQuery(\"select name from something order by id\")\n                .mapTo(String.class)\n                .iterator();\n\n            assertThat(rs.next(), equalTo(\"Brian\"));\n            assertThat(rs.next(), equalTo(\"Keith\"));\n            assertThat(rs.hasNext(), equalTo(false));\n        }\n    }\n\n    @Test\n    public void testMappingExampleChainedIterator3() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.execute(\"insert into something (id, name) values (1, 'Brian')\");\n            h.execute(\"insert into something (id, name) values (2, 'Keith')\");\n\n            for (String name : h.createQuery(\"select name from something order by id\").mapTo(String.class)) {\n                assertThat(name, equalsOneOf(\"Brian\", \"Keith\"));\n            }\n        }\n    }\n\n    @Test\n    public void testAttachToObject() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            MyDAO dao = h.attach(MyDAO.class);\n            dao.insert(1, \"test\");\n        }\n    }\n\n    @Test\n    public void testOnDemandDao() throws Exception\n    {\n        MyDAO dao = db.getJdbi().onDemand(MyDAO.class);\n        dao.insert(2, \"test\");\n    }\n\n    public interface SomeQueries\n    {\n        @SqlQuery(\"select name from something where id = :id\")\n        String findName(@Bind(\"id\") int id);\n\n        @SqlQuery(\"select name from something where id > :from and id < :to order by id\")\n        List<String> findNamesBetween(@Bind(\"from\") int from, @Bind(\"to\") int to);\n\n        @SqlQuery(\"select name from something order by id\")\n        Iterator<String> findAllNames();\n    }\n\n    @Test\n    public void testSomeQueriesWorkCorrectly() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.prepareBatch(\"insert into something (id, name) values (:id, :name)\")\n                .add().bind(\"id\", 1).bind(\"name\", \"Brian\")\n                .next().bind(\"id\", 2).bind(\"name\", \"Robert\")\n                .next().bind(\"id\", 3).bind(\"name\", \"Patrick\")\n                .next().bind(\"id\", 4).bind(\"name\", \"Maniax\")\n                .submit().execute();\n\n            SomeQueries sq = h.attach(SomeQueries.class);\n            assertThat(sq.findName(2), equalTo(\"Robert\"));\n            assertThat(sq.findNamesBetween(1, 4), equalTo(Arrays.asList(\"Robert\", \"Patrick\")));\n\n            Iterator<String> names = sq.findAllNames();\n            assertThat(names.next(), equalTo(\"Brian\"));\n            assertThat(names.next(), equalTo(\"Robert\"));\n            assertThat(names.next(), equalTo(\"Patrick\"));\n            assertThat(names.next(), equalTo(\"Maniax\"));\n            assertThat(names.hasNext(), equalTo(false));\n        }\n    }\n\n    @RegisterRowMapper(SomethingMapper.class)\n    public interface AnotherQuery\n    {\n        @SqlQuery(\"select id, name from something where id = :id\")\n        Something findById(@Bind(\"id\") int id);\n    }\n\n    public interface YetAnotherQuery\n    {\n        @SqlQuery(\"select id, name from something where id = :id\")\n        @UseRowMapper(SomethingMapper.class)\n        Something findById(@Bind(\"id\") int id);\n    }\n\n    public interface BatchInserter\n    {\n        @SqlBatch(\"insert into something (id, name) values (:id, :name)\")\n        void insert(@BindBean Something... somethings);\n    }\n\n    @Test\n    public void testAnotherCoupleInterfaces() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.attach(BatchInserter.class).insert(new Something(1, \"Brian\"),\n                    new Something(3, \"Patrick\"),\n                    new Something(2, \"Robert\"));\n\n            AnotherQuery aq = h.attach(AnotherQuery.class);\n            YetAnotherQuery yaq = h.attach(YetAnotherQuery.class);\n\n            assertThat(yaq.findById(3), equalTo(new Something(3, \"Patrick\")));\n            assertThat(aq.findById(2), equalTo(new Something(2, \"Robert\")));\n        }\n    }\n\n    public interface QueryReturningQuery\n    {\n        @SqlQuery(\"select name from something where id = :id\")\n        Query<String> findById(@Bind(\"id\") int id);\n    }\n\n    @Test\n    public void testFoo() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.attach(BatchInserter.class).insert(new Something(1, \"Brian\"),\n                                                 new Something(3, \"Patrick\"),\n                                                 new Something(2, \"Robert\"));\n\n            QueryReturningQuery qrq = h.attach(QueryReturningQuery.class);\n\n            Query<String> q = qrq.findById(1);\n            q.setMaxFieldSize(100);\n            assertThat(q.findOnly(), equalTo(\"Brian\"));\n        }\n    }\n\n    public interface Update\n    {\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        int insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n\n        @SqlUpdate(\"update something set name = :name where id = :id\")\n        int update(@BindBean Something s);\n    }\n\n    @Test\n    public void testUpdateAPI() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            Update u = h.attach(Update.class);\n            u.insert(17, \"David\");\n            u.update(new Something(17, \"David P.\"));\n\n            String name = h.createQuery(\"select name from something where id = 17\")\n                .mapTo(String.class)\n                .findOnly();\n            assertThat(name, equalTo(\"David P.\"));\n        }\n    }\n\n    public interface BatchExample\n    {\n        @SqlBatch(\"insert into something (id, name) values (:id, :first || ' ' || :last)\")\n        void insertFamily(@Bind(\"id\") List<Integer> ids,\n                          @Bind(\"first\") Iterator<String> firstNames,\n                          @Bind(\"last\") String lastName);\n\n\n        @SqlQuery(\"select name from something where id = :id\")\n        String findNameById(@Bind(\"id\") int id);\n    }\n\n    @Test\n    public void testBatchExample() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            BatchExample b = h.attach(BatchExample.class);\n\n            List<Integer> ids = asList(1, 2, 3, 4, 5);\n            Iterator<String> first_names = asList(\"Tip\", \"Jane\", \"Brian\", \"Keith\", \"Eric\").iterator();\n\n            b.insertFamily(ids, first_names, \"McCallister\");\n\n            assertThat(b.findNameById(1), equalTo(\"Tip McCallister\"));\n            assertThat(b.findNameById(2), equalTo(\"Jane McCallister\"));\n            assertThat(b.findNameById(3), equalTo(\"Brian McCallister\"));\n            assertThat(b.findNameById(4), equalTo(\"Keith McCallister\"));\n            assertThat(b.findNameById(5), equalTo(\"Eric McCallister\"));\n        }\n    }\n\n    public interface ChunkedBatchExample\n    {\n        @SqlBatch(\"insert into something (id, name) values (:id, :first || ' ' || :last)\")\n        @BatchChunkSize(2)\n        void insertFamily(@Bind(\"id\") List<Integer> ids,\n                          @Bind(\"first\") Iterator<String> firstNames,\n                          @Bind(\"last\") String lastName);\n\n        @SqlUpdate(\"create table something(id int primary key, name varchar(32))\")\n        void createSomethingTable();\n\n        @SqlQuery(\"select name from something where id = :id\")\n        String findNameById(@Bind(\"id\") int id);\n    }\n\n    public interface BindExamples\n    {\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        void insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n\n        @SqlUpdate(\"delete from something where name = :it\")\n        void deleteByName(@Bind String name);\n    }\n\n    public interface BindBeanExample\n    {\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        void insert(@BindBean Something s);\n\n        @SqlUpdate(\"update something set name = :s.name where id = :s.id\")\n        void update(@BindBean(\"s\") Something something);\n    }\n}\n\n\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport static java.util.Arrays.asList;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport org.jdbi.v3.core.*;\nimport org.jdbi.v3.core.mapper.SomethingMapper;\nimport org.jdbi.v3.sqlobject.customizers.BatchChunkSize;\nimport org.jdbi.v3.sqlobject.customizers.UseRowMapper;\nimport org.jdbi.v3.sqlobject.customizers.RegisterRowMapper;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class TestDocumentation\n{\n    @Rule\n    public H2DatabaseRule db = new H2DatabaseRule().withPlugin(new SqlObjectPlugin());\n\n    @Test\n    public void testFiveMinuteFluentApi() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.execute(\"insert into something (id, name) values (?, ?)\", 1, \"Brian\");\n\n            String name = h.createQuery(\"select name from something where id = :id\")\n                .bind(\"id\", 1)\n                .mapTo(String.class)\n                .findOnly();\n            assertThat(name).isEqualTo(\"Brian\");\n        }\n    }\n\n    public interface MyDAO\n    {\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        void insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n\n        @SqlQuery(\"select name from something where id = :id\")\n        String findNameById(@Bind(\"id\") int id);\n    }\n\n    @Test\n    public void testFiveMinuteSqlObjectExample() throws Exception\n    {\n        db.getJdbi().useExtension(MyDAO.class, dao -> {\n            dao.insert(2, \"Aaron\");\n\n            String name = dao.findNameById(2);\n\n            assertThat(name).isEqualTo(\"Aaron\");\n        });\n    }\n\n\n    @Test\n    public void testObtainHandleViaOpen() throws Exception\n    {\n        try (Handle handle = db.getJdbi().open()) { }\n    }\n\n    @Test\n    public void testObtainHandleInCallback() throws Exception\n    {\n        Jdbi dbi = Jdbi.create(\"jdbc:h2:mem:\" + UUID.randomUUID());\n        dbi.useHandle(handle -> handle.execute(\"create table silly (id int)\"));\n    }\n\n    @Test\n    public void testExecuteSomeStatements() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.execute(\"insert into something (id, name) values (?, ?)\", 3, \"Patrick\");\n\n            List<Map<String, Object>> rs = h.select(\"select id, name from something\");\n            assertThat(rs).containsExactlyElementsOf(ImmutableList.of(ImmutableMap.of(\"id\", 3L, \"name\", \"Patrick\")));\n         }\n    }\n\n    @Test\n    public void testFluentUpdate() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.createStatement(\"insert into something(id, name) values (:id, :name)\")\n                .bind(\"id\", 4)\n                .bind(\"name\", \"Martin\")\n                .execute();\n        }\n    }\n\n    @Test\n    public void testMappingExampleChainedIterator2() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.execute(\"insert into something (id, name) values (1, 'Brian')\");\n            h.execute(\"insert into something (id, name) values (2, 'Keith')\");\n\n            Iterator<String> rs = h.createQuery(\"select name from something order by id\")\n                .mapTo(String.class)\n                .iterator();\n\n            assertThat(rs.next()).isEqualTo(\"Brian\");\n            assertThat(rs.next()).isEqualTo(\"Keith\");\n            assertThat(rs.hasNext()).isFalse();\n        }\n    }\n\n    @Test\n    public void testMappingExampleChainedIterator3() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.execute(\"insert into something (id, name) values (1, 'Brian')\");\n            h.execute(\"insert into something (id, name) values (2, 'Keith')\");\n\n            Query<String> names = h.createQuery(\"select name from something order by id\").mapTo(String.class);\n            assertThat(names.iterator()).containsExactly(\"Brian\", \"Keith\");\n        }\n    }\n\n    @Test\n    public void testAttachToObject() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            MyDAO dao = h.attach(MyDAO.class);\n            dao.insert(1, \"test\");\n        }\n    }\n\n    @Test\n    public void testOnDemandDao() throws Exception\n    {\n        MyDAO dao = db.getJdbi().onDemand(MyDAO.class);\n        dao.insert(2, \"test\");\n    }\n\n    public interface SomeQueries\n    {\n        @SqlQuery(\"select name from something where id = :id\")\n        String findName(@Bind(\"id\") int id);\n\n        @SqlQuery(\"select name from something where id > :from and id < :to order by id\")\n        List<String> findNamesBetween(@Bind(\"from\") int from, @Bind(\"to\") int to);\n\n        @SqlQuery(\"select name from something order by id\")\n        Iterator<String> findAllNames();\n    }\n\n    @Test\n    public void testSomeQueriesWorkCorrectly() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.prepareBatch(\"insert into something (id, name) values (:id, :name)\")\n                .add().bind(\"id\", 1).bind(\"name\", \"Brian\")\n                .next().bind(\"id\", 2).bind(\"name\", \"Robert\")\n                .next().bind(\"id\", 3).bind(\"name\", \"Patrick\")\n                .next().bind(\"id\", 4).bind(\"name\", \"Maniax\")\n                .submit().execute();\n\n            SomeQueries sq = h.attach(SomeQueries.class);\n            assertThat(sq.findName(2)).isEqualTo(\"Robert\");\n            assertThat(sq.findNamesBetween(1, 4)).containsExactly(\"Robert\", \"Patrick\");\n\n            Iterator<String> names = sq.findAllNames();\n            assertThat(names).containsExactly(\"Brian\", \"Robert\", \"Patrick\", \"Maniax\");\n        }\n    }\n\n    @RegisterRowMapper(SomethingMapper.class)\n    public interface AnotherQuery\n    {\n        @SqlQuery(\"select id, name from something where id = :id\")\n        Something findById(@Bind(\"id\") int id);\n    }\n\n    public interface YetAnotherQuery\n    {\n        @SqlQuery(\"select id, name from something where id = :id\")\n        @UseRowMapper(SomethingMapper.class)\n        Something findById(@Bind(\"id\") int id);\n    }\n\n    public interface BatchInserter\n    {\n        @SqlBatch(\"insert into something (id, name) values (:id, :name)\")\n        void insert(@BindBean Something... somethings);\n    }\n\n    @Test\n    public void testAnotherCoupleInterfaces() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.attach(BatchInserter.class).insert(new Something(1, \"Brian\"),\n                    new Something(3, \"Patrick\"),\n                    new Something(2, \"Robert\"));\n\n            AnotherQuery aq = h.attach(AnotherQuery.class);\n            YetAnotherQuery yaq = h.attach(YetAnotherQuery.class);\n\n            assertThat(yaq.findById(3)).isEqualTo(new Something(3, \"Patrick\"));\n            assertThat(aq.findById(2)).isEqualTo(new Something(2, \"Robert\"));\n        }\n    }\n\n    public interface QueryReturningQuery\n    {\n        @SqlQuery(\"select name from something where id = :id\")\n        Query<String> findById(@Bind(\"id\") int id);\n    }\n\n    @Test\n    public void testFoo() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            h.attach(BatchInserter.class).insert(new Something(1, \"Brian\"),\n                                                 new Something(3, \"Patrick\"),\n                                                 new Something(2, \"Robert\"));\n\n            QueryReturningQuery qrq = h.attach(QueryReturningQuery.class);\n\n            Query<String> q = qrq.findById(1);\n            q.setMaxFieldSize(100);\n            assertThat(q.findOnly()).isEqualTo(\"Brian\");\n        }\n    }\n\n    public interface Update\n    {\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        int insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n\n        @SqlUpdate(\"update something set name = :name where id = :id\")\n        int update(@BindBean Something s);\n    }\n\n    @Test\n    public void testUpdateAPI() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            Update u = h.attach(Update.class);\n            u.insert(17, \"David\");\n            u.update(new Something(17, \"David P.\"));\n\n            String name = h.createQuery(\"select name from something where id = 17\")\n                .mapTo(String.class)\n                .findOnly();\n            assertThat(name).isEqualTo(\"David P.\");\n        }\n    }\n\n    public interface BatchExample\n    {\n        @SqlBatch(\"insert into something (id, name) values (:id, :first || ' ' || :last)\")\n        void insertFamily(@Bind(\"id\") List<Integer> ids,\n                          @Bind(\"first\") Iterator<String> firstNames,\n                          @Bind(\"last\") String lastName);\n\n\n        @SqlQuery(\"select name from something where id = :id\")\n        String findNameById(@Bind(\"id\") int id);\n    }\n\n    @Test\n    public void testBatchExample() throws Exception\n    {\n        try (Handle h = db.openHandle()) {\n            BatchExample b = h.attach(BatchExample.class);\n\n            List<Integer> ids = asList(1, 2, 3, 4, 5);\n            Iterator<String> first_names = asList(\"Tip\", \"Jane\", \"Brian\", \"Keith\", \"Eric\").iterator();\n\n            b.insertFamily(ids, first_names, \"McCallister\");\n\n            assertThat(b.findNameById(1)).isEqualTo(\"Tip McCallister\");\n            assertThat(b.findNameById(2)).isEqualTo(\"Jane McCallister\");\n            assertThat(b.findNameById(3)).isEqualTo(\"Brian McCallister\");\n            assertThat(b.findNameById(4)).isEqualTo(\"Keith McCallister\");\n            assertThat(b.findNameById(5)).isEqualTo(\"Eric McCallister\");\n        }\n    }\n\n    public interface ChunkedBatchExample\n    {\n        @SqlBatch(\"insert into something (id, name) values (:id, :first || ' ' || :last)\")\n        @BatchChunkSize(2)\n        void insertFamily(@Bind(\"id\") List<Integer> ids,\n                          @Bind(\"first\") Iterator<String> firstNames,\n                          @Bind(\"last\") String lastName);\n\n        @SqlUpdate(\"create table something(id int primary key, name varchar(32))\")\n        void createSomethingTable();\n\n        @SqlQuery(\"select name from something where id = :id\")\n        String findNameById(@Bind(\"id\") int id);\n    }\n\n    public interface BindExamples\n    {\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        void insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n\n        @SqlUpdate(\"delete from something where name = :it\")\n        void deleteByName(@Bind String name);\n    }\n\n    public interface BindBeanExample\n    {\n        @SqlUpdate(\"insert into something (id, name) values (:id, :name)\")\n        void insert(@BindBean Something s);\n\n        @SqlUpdate(\"update something set name = :s.name where id = :s.id\")\n        void update(@BindBean(\"s\") Something something);\n    }\n}\n\n\n","lineNo":135}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\n\nclass BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private final StatementContext ctx;\n    private BeanInfo info;\n\n    BeanPropertyArguments(String prefix, Object bean, StatementContext ctx)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        this.ctx = ctx;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e, ctx);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    try\n                    {\n                        return ctx.findArgumentFor(\n                                descriptor.getReadMethod().getGenericReturnType(),\n                                descriptor.getReadMethod().invoke(bean));\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\n\nclass BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private final StatementContext ctx;\n    private BeanInfo info;\n\n    BeanPropertyArguments(String prefix, Object bean, StatementContext ctx)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        this.ctx = ctx;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e, ctx);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    Method getter = descriptor.getReadMethod();\n                    if (getter == null)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"No getter method found for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), ctx);\n                    }\n\n                    try\n                    {\n                        return ctx.findArgumentFor(getter.getGenericReturnType(), getter.invoke(bean));\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","lineNo":60}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\n\nclass BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final Object bean;\n    private final StatementContext ctx;\n    private final ArgumentRegistry argumentRegistry;\n    private BeanInfo info;\n\n    BeanPropertyArguments(Object bean, StatementContext ctx, ArgumentRegistry argumentRegistry)\n    {\n        this.bean = bean;\n        this.ctx = ctx;\n        this.argumentRegistry = argumentRegistry;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed ot be used to\" +\n                                                       \" set named args for a statement via JavaBean properties\", e, ctx);\n        }\n\n    }\n\n    @Override\n    public Optional<Argument> find(String name)\n    {\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n        {\n            if (descriptor.getName().equals(name))\n            {\n                try\n                {\n                    return argumentRegistry.findArgumentFor(\n                            descriptor.getReadMethod().getGenericReturnType(),\n                            descriptor.getReadMethod().invoke(bean),\n                            ctx);\n                }\n                catch (IllegalAccessException e)\n                {\n                    throw new UnableToCreateStatementException(String.format(\"Access excpetion invoking getter for \" +\n                                                                             \"bean property [%s] on [%s]\",\n                                                                             name, bean), e, ctx);\n                }\n                catch (InvocationTargetException e)\n                {\n                    throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                                                             \"getter for bean property [%s] on [%s]\",\n                                                                             name, bean), e, ctx);\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean proprty arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.core;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Optional;\n\nimport org.jdbi.v3.core.argument.Argument;\nimport org.jdbi.v3.core.argument.NamedArgumentFinder;\nimport org.jdbi.v3.core.exception.UnableToCreateStatementException;\n\nclass BeanPropertyArguments implements NamedArgumentFinder\n{\n    private final String prefix;\n    private final Object bean;\n    private final StatementContext ctx;\n    private BeanInfo info;\n\n    BeanPropertyArguments(String prefix, Object bean, StatementContext ctx)\n    {\n        this.prefix = (prefix == null || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        this.bean = bean;\n        this.ctx = ctx;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed to be used to \" +\n                                                       \"set named args for a statement via JavaBean properties\", e, ctx);\n        }\n    }\n\n    @Override\n    public Optional<Argument> find(String name)\n    {\n        if (name.startsWith(prefix)) {\n            String propertyName = name.substring(prefix.length());\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n            {\n                if (propertyName.equals(descriptor.getName()))\n                {\n                    try\n                    {\n                        return ctx.findArgumentFor(\n                                descriptor.getReadMethod().getGenericReturnType(),\n                                descriptor.getReadMethod().invoke(bean));\n                    }\n                    catch (IllegalAccessException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Access exception invoking getter for \" +\n                                        \"bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                    catch (InvocationTargetException e)\n                    {\n                        throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                        \"getter for bean property [%s] on [%s]\",\n                                propertyName, bean), e, ctx);\n                    }\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"{lazy bean property arguments \\\"\" + bean + \"\\\"\";\n    }\n}\n","lineNo":54}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.BiConsumer;\nimport java.util.stream.Stream;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\n\nimport org.jdbi.v3.core.ExtensionMethod;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.sqlobject.mixins.GetHandle;\nimport org.jdbi.v3.sqlobject.mixins.Transactional;\n\npublic enum SqlObjectFactory implements ExtensionFactory<SqlObjectConfig> {\n    INSTANCE;\n\n    private static final MethodInterceptor NO_OP = (proxy, method, args, methodProxy) -> null;\n\n    private final Map<Method, Handler> mixinHandlers = new HashMap<>();\n    private final ConcurrentMap<Class<?>, Map<Method, Handler>> handlersCache = new ConcurrentHashMap<>();\n    private final ConcurrentMap<Class<?>, Factory> factories = new ConcurrentHashMap<>();\n    private final ConcurrentMap<Class<? extends SqlObjectConfigurerFactory>, SqlObjectConfigurerFactory>\n            configurerFactories = new ConcurrentHashMap<>();\n\n    SqlObjectFactory() {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n    }\n\n    @Override\n    public SqlObjectConfig createConfig() {\n        return new SqlObjectConfig();\n    }\n\n    @Override\n    public boolean accepts(Class<?> extensionType) {\n        if (GetHandle.class.isAssignableFrom(extensionType) ||\n                Transactional.class.isAssignableFrom(extensionType)) {\n            return true;\n        }\n\n        return Stream.of(extensionType.getMethods())\n                .flatMap(m -> Stream.of(m.getAnnotations()))\n                .anyMatch(a -> a.annotationType().isAnnotationPresent(SqlMethodAnnotation.class));\n    }\n\n    /**\n     * Create a sql object of the specified type bound to this handle. Any state changes to the handle, or the sql\n     * object, such as transaction status, closing it, etc, will apply to both the object and the handle.\n     *\n     * @param extensionType the type of sql object to create\n     * @param handle the Handle instance to attach ths sql object to\n     * @return the new sql object bound to this handle\n     */\n    @Override\n    public <E> E attach(Class<E> extensionType, SqlObjectConfig config, HandleSupplier handle) {\n        Factory f = factories.computeIfAbsent(extensionType, type -> {\n            Enhancer e = new Enhancer();\n            e.setClassLoader(extensionType.getClassLoader());\n\n            List<Class<?>> interfaces = new ArrayList<>();\n            if (extensionType.isInterface()) {\n                interfaces.add(extensionType);\n            }\n            else {\n                e.setSuperclass(extensionType);\n            }\n            e.setInterfaces(interfaces.toArray(new Class[interfaces.size()]));\n            e.setCallback(NO_OP);\n\n            return (Factory) e.create();\n        });\n\n\n        Map<Method, Handler> handlers = buildHandlersFor(extensionType);\n        MethodInterceptor interceptor = createMethodInterceptor(extensionType, config, handlers, handle);\n        return extensionType.cast(f.newInstance(interceptor));\n    }\n\n    private Map<Method, Handler> buildHandlersFor(Class<?> sqlObjectType) {\n        return handlersCache.computeIfAbsent(sqlObjectType, type -> {\n            final Map<Method, Handler> handlers = new HashMap<>();\n\n            handlers.putAll(EqualsHandler.handler());\n            handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n            handlers.putAll(HashCodeHandler.handler());\n            handlers.putAll(FinalizeHandler.handlerFor(sqlObjectType));\n\n            for (Method method : sqlObjectType.getMethods()) {\n                handlers.computeIfAbsent(method, m -> buildMethodHandler(sqlObjectType, m));\n            }\n\n            return handlers;\n        });\n    }\n\n    private Handler buildMethodHandler(Class<?> sqlObjectType, Method method) {\n        if (mixinHandlers.containsKey(method)) {\n            return mixinHandlers.get(method);\n        }\n\n        Handler handler = buildBaseHandler(sqlObjectType, method);\n        return addDecorators(handler, sqlObjectType, method);\n    }\n\n    private Handler buildBaseHandler(Class<?> sqlObjectType, Method method) {\n        Set<Class<?>> sqlMethodAnnotations = Stream.of(method.getAnnotations())\n                .map(Annotation::annotationType)\n                .filter(type -> type.isAnnotationPresent(SqlMethodAnnotation.class))\n                .collect(toSet());\n\n        if (sqlMethodAnnotations.size() > 1) {\n            throw new IllegalStateException(\n                    String.format(\"Mutually exclusive annotations on method %s.%s: %s\",\n                            sqlObjectType.getName(),\n                            method.getName(),\n                            sqlMethodAnnotations));\n        }\n\n        return sqlMethodAnnotations.stream()\n                .map(type -> type.getAnnotation(SqlMethodAnnotation.class))\n                .map(a -> buildFactory(a.value()))\n                .map(factory -> factory.buildHandler(sqlObjectType, method))\n                .findFirst()\n                .orElseGet(PassThroughHandler::new);\n    }\n\n    private Handler addDecorators(Handler handler, Class<?> sqlObjectType, Method method) {\n        List<HandlerDecorator> decorators = Stream.of(method.getAnnotations())\n                .map(a -> a.annotationType().getAnnotation(SqlMethodDecoratingAnnotation.class))\n                .filter(Objects::nonNull)\n                .map(a -> buildDecorator(a.value()))\n                .collect(toList());\n\n        for (HandlerDecorator decorator : decorators) {\n            handler = decorator.decorateHandler(handler, sqlObjectType, method);\n        }\n\n        return handler;\n    }\n\n    private static HandlerFactory buildFactory(Class<? extends HandlerFactory> factoryClazz) {\n        HandlerFactory factory;\n        try {\n            factory = factoryClazz.getConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new IllegalStateException(\"Factory class \" + factoryClazz + \"cannot be instantiated\", e);\n        }\n        return factory;\n    }\n\n    private static HandlerDecorator buildDecorator(Class<? extends HandlerDecorator> decoratorClass) {\n        HandlerDecorator decorator;\n        try {\n            decorator = decoratorClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new IllegalStateException(\"Decorator class \" + decoratorClass + \"cannot be instantiated\", e);\n        }\n        return decorator;\n    }\n\n    private MethodInterceptor createMethodInterceptor(Class<?> sqlObjectType,\n                                                      SqlObjectConfig baseConfig,\n                                                      Map<Method, Handler> handlers,\n                                                      HandleSupplier handle) {\n        return (proxy, method, args, methodProxy) -> {\n            ExtensionMethod oldMethod = handle.getExtensionMethod();\n            handle.setExtensionMethod(new ExtensionMethod(sqlObjectType, method));\n\n            try {\n                Handler handler = handlers.get(method);\n\n                // If there is no handler, pretend we are just an Object and don't open a connection (Issue #82)\n                if (handler == null) {\n                    return methodProxy.invokeSuper(proxy, args);\n                }\n\n                SqlObjectConfig config = baseConfig.createCopy();\n                forEachConfigurerFactory(sqlObjectType, (factory, annotation) ->\n                        factory.createForType(annotation, sqlObjectType).accept(config));\n                forEachConfigurerFactory(method, (factory, annotation) ->\n                        factory.createForMethod(annotation, sqlObjectType, method).accept(config));\n\n                return handler.invoke(handle, config, proxy, args, method);\n            }\n            finally {\n                handle.setExtensionMethod(oldMethod);\n            }\n        };\n    }\n\n    private void forEachConfigurerFactory(AnnotatedElement element, BiConsumer<SqlObjectConfigurerFactory, Annotation> consumer) {\n        Stream.of(element.getAnnotations())\n                .filter(a -> a.annotationType().isAnnotationPresent(SqlObjectConfiguringAnnotation.class))\n                .forEach(a -> {\n                    SqlObjectConfiguringAnnotation meta = a.annotationType()\n                            .getAnnotation(SqlObjectConfiguringAnnotation.class);\n\n                    consumer.accept(getConfigurerFactory(meta.value()), a);\n                });\n    }\n\n    private SqlObjectConfigurerFactory getConfigurerFactory(Class<? extends SqlObjectConfigurerFactory> factoryClass) {\n        return configurerFactories.computeIfAbsent(factoryClass, c -> {\n            try {\n                return c.newInstance();\n            } catch (InstantiationException | IllegalAccessException e) {\n                throw new IllegalStateException(\"Unable to instantiate configurer factory class \" + factoryClass, e);\n            }\n        });\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.BiConsumer;\nimport java.util.stream.Stream;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\n\nimport org.jdbi.v3.core.ExtensionMethod;\nimport org.jdbi.v3.core.HandleSupplier;\nimport org.jdbi.v3.core.extension.ExtensionFactory;\nimport org.jdbi.v3.sqlobject.mixins.GetHandle;\nimport org.jdbi.v3.sqlobject.mixins.Transactional;\n\npublic enum SqlObjectFactory implements ExtensionFactory<SqlObjectConfig> {\n    INSTANCE;\n\n    private static final MethodInterceptor NO_OP = (proxy, method, args, methodProxy) -> null;\n\n    private final Map<Method, Handler> mixinHandlers = new HashMap<>();\n    private final ConcurrentMap<Class<?>, Map<Method, Handler>> handlersCache = new ConcurrentHashMap<>();\n    private final ConcurrentMap<Class<?>, Factory> factories = new ConcurrentHashMap<>();\n    private final ConcurrentMap<Class<? extends SqlObjectConfigurerFactory>, SqlObjectConfigurerFactory>\n            configurerFactories = new ConcurrentHashMap<>();\n\n    SqlObjectFactory() {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n    }\n\n    @Override\n    public SqlObjectConfig createConfig() {\n        return new SqlObjectConfig();\n    }\n\n    @Override\n    public boolean accepts(Class<?> extensionType) {\n        if (GetHandle.class.isAssignableFrom(extensionType) ||\n                Transactional.class.isAssignableFrom(extensionType)) {\n            return true;\n        }\n\n        return Stream.of(extensionType.getMethods())\n                .flatMap(m -> Stream.of(m.getAnnotations()))\n                .anyMatch(a -> a.annotationType().isAnnotationPresent(SqlMethodAnnotation.class));\n    }\n\n    /**\n     * Create a sql object of the specified type bound to this handle. Any state changes to the handle, or the sql\n     * object, such as transaction status, closing it, etc, will apply to both the object and the handle.\n     *\n     * @param extensionType the type of sql object to create\n     * @param handle the Handle instance to attach ths sql object to\n     * @return the new sql object bound to this handle\n     */\n    @Override\n    public <E> E attach(Class<E> extensionType, SqlObjectConfig config, HandleSupplier handle) {\n        Factory f = factories.computeIfAbsent(extensionType, type -> {\n            Enhancer e = new Enhancer();\n            e.setClassLoader(extensionType.getClassLoader());\n\n            List<Class<?>> interfaces = new ArrayList<>();\n            if (extensionType.isInterface()) {\n                interfaces.add(extensionType);\n            }\n            else {\n                e.setSuperclass(extensionType);\n            }\n            e.setInterfaces(interfaces.toArray(new Class[interfaces.size()]));\n            e.setCallback(NO_OP);\n\n            return (Factory) e.create();\n        });\n\n        SqlObjectConfig instanceConfig = config.createCopy();\n        forEachConfigurerFactory(extensionType, (factory, annotation) ->\n                factory.createForType(annotation, extensionType).accept(instanceConfig));\n\n        Map<Method, Handler> handlers = buildHandlersFor(extensionType);\n        MethodInterceptor interceptor = createMethodInterceptor(extensionType, instanceConfig, handlers, handle);\n        return extensionType.cast(f.newInstance(interceptor));\n    }\n\n    private Map<Method, Handler> buildHandlersFor(Class<?> sqlObjectType) {\n        return handlersCache.computeIfAbsent(sqlObjectType, type -> {\n            final Map<Method, Handler> handlers = new HashMap<>();\n\n            handlers.putAll(EqualsHandler.handler());\n            handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n            handlers.putAll(HashCodeHandler.handler());\n            handlers.putAll(FinalizeHandler.handlerFor(sqlObjectType));\n\n            for (Method method : sqlObjectType.getMethods()) {\n                handlers.computeIfAbsent(method, m -> buildMethodHandler(sqlObjectType, m));\n            }\n\n            return handlers;\n        });\n    }\n\n    private Handler buildMethodHandler(Class<?> sqlObjectType, Method method) {\n        if (mixinHandlers.containsKey(method)) {\n            return mixinHandlers.get(method);\n        }\n\n        Handler handler = buildBaseHandler(sqlObjectType, method);\n        return addDecorators(handler, sqlObjectType, method);\n    }\n\n    private Handler buildBaseHandler(Class<?> sqlObjectType, Method method) {\n        Set<Class<?>> sqlMethodAnnotations = Stream.of(method.getAnnotations())\n                .map(Annotation::annotationType)\n                .filter(type -> type.isAnnotationPresent(SqlMethodAnnotation.class))\n                .collect(toSet());\n\n        if (sqlMethodAnnotations.size() > 1) {\n            throw new IllegalStateException(\n                    String.format(\"Mutually exclusive annotations on method %s.%s: %s\",\n                            sqlObjectType.getName(),\n                            method.getName(),\n                            sqlMethodAnnotations));\n        }\n\n        return sqlMethodAnnotations.stream()\n                .map(type -> type.getAnnotation(SqlMethodAnnotation.class))\n                .map(a -> buildFactory(a.value()))\n                .map(factory -> factory.buildHandler(sqlObjectType, method))\n                .findFirst()\n                .orElseGet(PassThroughHandler::new);\n    }\n\n    private Handler addDecorators(Handler handler, Class<?> sqlObjectType, Method method) {\n        List<HandlerDecorator> decorators = Stream.of(method.getAnnotations())\n                .map(a -> a.annotationType().getAnnotation(SqlMethodDecoratingAnnotation.class))\n                .filter(Objects::nonNull)\n                .map(a -> buildDecorator(a.value()))\n                .collect(toList());\n\n        for (HandlerDecorator decorator : decorators) {\n            handler = decorator.decorateHandler(handler, sqlObjectType, method);\n        }\n\n        return handler;\n    }\n\n    private static HandlerFactory buildFactory(Class<? extends HandlerFactory> factoryClazz) {\n        HandlerFactory factory;\n        try {\n            factory = factoryClazz.getConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new IllegalStateException(\"Factory class \" + factoryClazz + \"cannot be instantiated\", e);\n        }\n        return factory;\n    }\n\n    private static HandlerDecorator buildDecorator(Class<? extends HandlerDecorator> decoratorClass) {\n        HandlerDecorator decorator;\n        try {\n            decorator = decoratorClass.getConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new IllegalStateException(\"Decorator class \" + decoratorClass + \"cannot be instantiated\", e);\n        }\n        return decorator;\n    }\n\n    private MethodInterceptor createMethodInterceptor(Class<?> sqlObjectType,\n                                                      SqlObjectConfig instanceConfig,\n                                                      Map<Method, Handler> handlers,\n                                                      HandleSupplier handle) {\n        return (proxy, method, args, methodProxy) -> {\n            ExtensionMethod oldMethod = handle.getExtensionMethod();\n            handle.setExtensionMethod(new ExtensionMethod(sqlObjectType, method));\n\n            try {\n                Handler handler = handlers.get(method);\n\n                // If there is no handler, pretend we are just an Object and don't open a connection (Issue #82)\n                if (handler == null) {\n                    return methodProxy.invokeSuper(proxy, args);\n                }\n\n                SqlObjectConfig config = instanceConfig.createCopy();\n                forEachConfigurerFactory(method, (factory, annotation) ->\n                        factory.createForMethod(annotation, sqlObjectType, method).accept(config));\n\n                return handler.invoke(proxy, method, args, config, handle);\n            }\n            finally {\n                handle.setExtensionMethod(oldMethod);\n            }\n        };\n    }\n\n    private void forEachConfigurerFactory(AnnotatedElement element, BiConsumer<SqlObjectConfigurerFactory, Annotation> consumer) {\n        Stream.of(element.getAnnotations())\n                .filter(a -> a.annotationType().isAnnotationPresent(SqlObjectConfiguringAnnotation.class))\n                .forEach(a -> {\n                    SqlObjectConfiguringAnnotation meta = a.annotationType()\n                            .getAnnotation(SqlObjectConfiguringAnnotation.class);\n\n                    consumer.accept(getConfigurerFactory(meta.value()), a);\n                });\n    }\n\n    private SqlObjectConfigurerFactory getConfigurerFactory(Class<? extends SqlObjectConfigurerFactory> factoryClass) {\n        return configurerFactories.computeIfAbsent(factoryClass, c -> {\n            try {\n                return c.newInstance();\n            } catch (InstantiationException | IllegalAccessException e) {\n                throw new IllegalStateException(\"Unable to instantiate configurer factory class \" + factoryClass, e);\n            }\n        });\n    }\n}\n","lineNo":103}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.IDBI;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass OnDemandHandleDing implements HandleDing\n{\n    private final IDBI dbi;\n    private final ThreadLocal<LocalDing> threadDing = new ThreadLocal<LocalDing>();\n\n    OnDemandHandleDing(IDBI dbi)\n    {\n        this.dbi = dbi;\n    }\n\n    @Override\n    public Handle getHandle()\n    {\n        if (threadDing.get() == null) {\n            threadDing.set(new LocalDing(dbi.open()));\n        }\n        return threadDing.get().getHandle();\n    }\n\n    @Override\n    public void retain(String name)\n    {\n        getHandle(); // need to ensure the local ding has been created as this is called before getHandle sometimes.\n        threadDing.get().retain(name);\n    }\n\n    @Override\n    public void release(String name)\n    {\n        LocalDing ding = threadDing.get();\n        if (ding == null) {\n            return;\n        }\n        ding.release(name);\n\n    }\n\n    class LocalDing implements HandleDing {\n\n        private final Set<String> retentions = new HashSet<String>();\n        private final Handle handle;\n\n        LocalDing(Handle handle)\n        {\n            this.handle = handle;\n        }\n\n        @Override\n        public Handle getHandle()\n        {\n            return handle;\n        }\n\n        @Override\n        public void release(String name)\n        {\n            retentions.remove(name);\n            if (retentions.isEmpty()) {\n                threadDing.set(null);\n                handle.close();\n            }\n        }\n\n        @Override\n        public void retain(String name)\n        {\n            retentions.add(name);\n        }\n\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.IDBI;\nimport org.skife.jdbi.v2.SqlObjectContext;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass OnDemandHandleDing implements HandleDing\n{\n    private final IDBI dbi;\n    private final ThreadLocal<LocalDing> threadDing = new ThreadLocal<LocalDing>();\n    private final ThreadLocal<SqlObjectContext> threadContext = new ThreadLocal<SqlObjectContext>() {\n        @Override\n        protected SqlObjectContext initialValue() {\n            return new SqlObjectContext();\n        }\n    };\n\n    OnDemandHandleDing(IDBI dbi)\n    {\n        this.dbi = dbi;\n    }\n\n    @Override\n    public SqlObjectContext setContext(SqlObjectContext context) {\n        LocalDing ding = threadDing.get();\n        if (ding == null) {\n            SqlObjectContext oldContext = threadContext.get();\n            threadContext.set(context);\n            return oldContext;\n        }\n        else {\n            return ding.setContext(context);\n        }\n    }\n\n    @Override\n    public Handle getHandle()\n    {\n        return getOrCreateLocalDing().getHandle();\n    }\n\n    @Override\n    public void retain(String name)\n    {\n        // need to ensure the local ding has been created as this is called before getHandle sometimes.\n        getOrCreateLocalDing().retain(name);\n    }\n\n    private LocalDing getOrCreateLocalDing() {\n        if (threadDing.get() == null) {\n            Handle handle = dbi.open();\n            SqlObjectContext context = threadContext.get();\n            handle.setSqlObjectContext(context == null ? new SqlObjectContext() : context);\n            threadContext.remove();\n            threadDing.set(new LocalDing(handle));\n        }\n        return threadDing.get();\n    }\n\n    @Override\n    public void release(String name)\n    {\n        LocalDing ding = threadDing.get();\n        if (ding == null) {\n            return;\n        }\n        ding.release(name);\n\n    }\n\n    class LocalDing implements HandleDing {\n\n        private final Set<String> retentions = new HashSet<String>();\n        private final Handle handle;\n\n        LocalDing(Handle handle)\n        {\n            this.handle = handle;\n        }\n\n        @Override\n        public SqlObjectContext setContext(SqlObjectContext context) {\n            SqlObjectContext oldContext = handle.getSqlObjectContext();\n            handle.setSqlObjectContext(context);\n            return oldContext;\n        }\n\n        @Override\n        public Handle getHandle()\n        {\n            return handle;\n        }\n\n        @Override\n        public void release(String name)\n        {\n            retentions.remove(name);\n            if (retentions.isEmpty()) {\n                threadDing.set(null);\n                threadContext.set(handle.getSqlObjectContext());\n                handle.close();\n            }\n        }\n\n        @Override\n        public void retain(String name)\n        {\n            retentions.add(name);\n        }\n\n    }\n}\n","lineNo":67}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.MemberResolver;\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.ResolvedTypeWithMembers;\nimport com.fasterxml.classmate.TypeResolver;\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.CallbackFilter;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\nimport net.sf.cglib.proxy.NoOp;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nclass SqlObject\n{\n    private static final TypeResolver                                  typeResolver  = new TypeResolver();\n    private static final Map<Method, Handler>                          mixinHandlers = new HashMap<Method, Handler>();\n    private static final ConcurrentMap<Class<?>, Map<Method, Handler>> handlersCache = new ConcurrentHashMap<Class<?>, Map<Method, Handler>>();\n    private static final ConcurrentMap<Class<?>, Factory>              factories     = new ConcurrentHashMap<Class<?>, Factory>();\n\n    private static Method jdk8DefaultMethod = null;\n\n    static {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n        mixinHandlers.putAll(TransmogrifierHelper.handlers());\n\n        try {\n            SqlObject.jdk8DefaultMethod = Method.class.getMethod(\"isDefault\");\n        }\n        catch (NoSuchMethodException e) {\n            // fallthrough, expected on e.g. JDK7\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <T> T buildSqlObject(final Class<T> sqlObjectType, final HandleDing handle)\n    {\n        Factory f;\n        if (factories.containsKey(sqlObjectType)) {\n            f = factories.get(sqlObjectType);\n        }\n        else {\n            Enhancer e = new Enhancer();\n            e.setClassLoader(sqlObjectType.getClassLoader());\n\n            List<Class> interfaces = new ArrayList<Class>();\n            interfaces.add(CloseInternalDoNotUseThisClass.class);\n            if (sqlObjectType.isInterface()) {\n                interfaces.add(sqlObjectType);\n            }\n            else {\n                e.setSuperclass(sqlObjectType);\n            }\n            e.setInterfaces(interfaces.toArray(new Class[interfaces.size()]));\n            final SqlObject so = new SqlObject(buildHandlersFor(sqlObjectType), handle);\n\n            e.setCallbackFilter(new CallbackFilter() {\n\n                @Override\n                public int accept(Method method) {\n                    if (jdk8DefaultMethod == null) {\n                        return 0;\n                    }\n                    else {\n                        try {\n                            Boolean result = (Boolean) jdk8DefaultMethod.invoke(method);\n                            return Boolean.TRUE.equals(result) ? 1 : 0;\n                        } catch (IllegalArgumentException e) {\n                            return 0;\n                        } catch (IllegalAccessException e) {\n                            return 0;\n                        } catch (InvocationTargetException e) {\n                            return 0;\n                        }\n                    }\n                }\n\n            });\n\n            e.setCallbacks(new Callback[] {\n                    new MethodInterceptor() {\n                        @Override\n                        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                            return so.invoke(o, method, objects, methodProxy);\n                        }\n                    },\n                    NoOp.INSTANCE\n            });\n            T t = (T) e.create();\n            T actual = (T) factories.putIfAbsent(sqlObjectType, (Factory) t);\n            if (actual == null) {\n                return t;\n            }\n            f = (Factory) actual;\n        }\n\n        final SqlObject so = new SqlObject(buildHandlersFor(sqlObjectType), handle);\n        return (T) f.newInstance(new Callback[] {\n                new MethodInterceptor() {\n                    @Override\n                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                        return so.invoke(o, method, objects, methodProxy);\n                    }\n                },\n                NoOp.INSTANCE\n        });\n    }\n\n    private static Map<Method, Handler> buildHandlersFor(Class<?> sqlObjectType)\n    {\n        if (handlersCache.containsKey(sqlObjectType)) {\n            return handlersCache.get(sqlObjectType);\n        }\n\n        final MemberResolver mr = new MemberResolver(typeResolver);\n        final ResolvedType sql_object_type = typeResolver.resolve(sqlObjectType);\n\n        final ResolvedTypeWithMembers d = mr.resolve(sql_object_type, null, null);\n\n        final Map<Method, Handler> handlers = new HashMap<Method, Handler>();\n        for (final ResolvedMethod method : d.getMemberMethods()) {\n            final Method raw_method = method.getRawMember();\n\n            if (raw_method.isAnnotationPresent(SqlQuery.class)) {\n                handlers.put(raw_method, new QueryHandler(sqlObjectType, method, ResultReturnThing.forType(method)));\n            }\n            else if (raw_method.isAnnotationPresent(SqlUpdate.class)) {\n                handlers.put(raw_method, new UpdateHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlBatch.class)) {\n                handlers.put(raw_method, new BatchHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlCall.class)) {\n                handlers.put(raw_method, new CallHandler(sqlObjectType, method));\n            }\n            else if(raw_method.isAnnotationPresent(CreateSqlObject.class)) {\n                handlers.put(raw_method, new CreateSqlObjectHandler(raw_method.getReturnType()));\n            }\n            else if (method.getName().equals(\"close\") && method.getRawMember().getParameterTypes().length == 0) {\n                handlers.put(raw_method, new CloseHandler());\n            }\n            else if (method.getName().equals(\"finalize\") && method.getRawMember().getParameterTypes().length == 0) {\n                // no handler for finalize()\n            }\n            else if (raw_method.isAnnotationPresent(Transaction.class)) {\n                handlers.put(raw_method, new PassThroughTransactionHandler(raw_method, raw_method.getAnnotation(Transaction.class)));\n            }\n            else if (mixinHandlers.containsKey(raw_method)) {\n                handlers.put(raw_method, mixinHandlers.get(raw_method));\n            }\n            else {\n                handlers.put(raw_method, new PassThroughHandler(raw_method));\n            }\n        }\n\n        // this is an implicit mixin, not an explicit one, so we need to *always* add it\n        handlers.putAll(CloseInternalDoNotUseThisClass.Helper.handlers());\n\n        handlers.putAll(EqualsHandler.handler());\n        handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n        handlers.putAll(HashCodeHandler.handler());\n\n        handlersCache.put(sqlObjectType, handlers);\n\n        return handlers;\n    }\n\n\n    private final Map<Method, Handler> handlers;\n    private final HandleDing           ding;\n\n    SqlObject(Map<Method, Handler> handlers, HandleDing ding)\n    {\n        this.handlers = handlers;\n        this.ding = ding;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args, MethodProxy mp) throws Throwable\n    {\n        final Handler handler = handlers.get(method);\n\n        // If there is no handler, pretend we are just an Object and don't open a connection (Issue #82)\n        if (handler == null) {\n            return mp.invokeSuper(proxy, args);\n        }\n\n        Throwable doNotMask = null;\n        try {\n            ding.retain(method.toString());\n            return handler.invoke(ding, proxy, args, mp);\n        }\n        catch (Throwable e) {\n            doNotMask = e;\n            throw e;\n        }\n        finally {\n            try {\n                ding.release(method.toString());\n            }\n            catch (Throwable e) {\n                if (doNotMask==null) {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public static void close(Object sqlObject)\n    {\n        if (!(sqlObject instanceof CloseInternalDoNotUseThisClass)) {\n            throw new IllegalArgumentException(sqlObject + \" is not a sql object\");\n        }\n        CloseInternalDoNotUseThisClass closer = (CloseInternalDoNotUseThisClass) sqlObject;\n        closer.___jdbi_close___();\n    }\n\n    static String getSql(SqlCall q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.MemberResolver;\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.ResolvedTypeWithMembers;\nimport com.fasterxml.classmate.TypeResolver;\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.CallbackFilter;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\nimport net.sf.cglib.proxy.NoOp;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nclass SqlObject\n{\n    private static final TypeResolver                                  typeResolver  = new TypeResolver();\n    private static final Map<Method, Handler>                          mixinHandlers = new HashMap<Method, Handler>();\n    private static final ConcurrentMap<Class<?>, Map<Method, Handler>> handlersCache = new ConcurrentHashMap<Class<?>, Map<Method, Handler>>();\n    private static final ConcurrentMap<Class<?>, Factory>              factories     = new ConcurrentHashMap<Class<?>, Factory>();\n\n    private static Method jdk8DefaultMethod = null;\n\n    static {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n        mixinHandlers.putAll(TransmogrifierHelper.handlers());\n\n        try {\n            SqlObject.jdk8DefaultMethod = Method.class.getMethod(\"isDefault\");\n        }\n        catch (NoSuchMethodException e) {\n            // fallthrough, expected on e.g. JDK7\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <T> T buildSqlObject(final Class<T> sqlObjectType, final HandleDing handle)\n    {\n        Factory f;\n        if (factories.containsKey(sqlObjectType)) {\n            f = factories.get(sqlObjectType);\n        }\n        else {\n            Enhancer e = new Enhancer();\n            e.setClassLoader(sqlObjectType.getClassLoader());\n\n            List<Class> interfaces = new ArrayList<Class>();\n            interfaces.add(CloseInternalDoNotUseThisClass.class);\n            if (sqlObjectType.isInterface()) {\n                interfaces.add(sqlObjectType);\n            }\n            else {\n                e.setSuperclass(sqlObjectType);\n            }\n            e.setInterfaces(interfaces.toArray(new Class[interfaces.size()]));\n            final SqlObject so = new SqlObject(buildHandlersFor(sqlObjectType), handle);\n\n            e.setCallbackFilter(new CallbackFilter() {\n\n                @Override\n                public int accept(Method method) {\n                    if (jdk8DefaultMethod == null) {\n                        return 0;\n                    }\n                    else {\n                        try {\n                            Boolean result = (Boolean) jdk8DefaultMethod.invoke(method);\n                            return Boolean.TRUE.equals(result) ? 1 : 0;\n                        } catch (IllegalArgumentException e) {\n                            return 0;\n                        } catch (IllegalAccessException e) {\n                            return 0;\n                        } catch (InvocationTargetException e) {\n                            return 0;\n                        }\n                    }\n                }\n\n            });\n\n            e.setCallbacks(new Callback[] {\n                    new MethodInterceptor() {\n                        @Override\n                        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                            return so.invoke(o, method, objects, methodProxy);\n                        }\n                    },\n                    NoOp.INSTANCE\n            });\n            T t = (T) e.create();\n            T actual = (T) factories.putIfAbsent(sqlObjectType, (Factory) t);\n            if (actual == null) {\n                return t;\n            }\n            f = (Factory) actual;\n        }\n\n        final SqlObject so = new SqlObject(buildHandlersFor(sqlObjectType), handle);\n        return (T) f.newInstance(new Callback[] {\n                new MethodInterceptor() {\n                    @Override\n                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                        return so.invoke(o, method, objects, methodProxy);\n                    }\n                },\n                NoOp.INSTANCE\n        });\n    }\n\n    private static Map<Method, Handler> buildHandlersFor(Class<?> sqlObjectType)\n    {\n        if (handlersCache.containsKey(sqlObjectType)) {\n            return handlersCache.get(sqlObjectType);\n        }\n\n        final MemberResolver mr = new MemberResolver(typeResolver);\n        final ResolvedType sql_object_type = typeResolver.resolve(sqlObjectType);\n\n        final ResolvedTypeWithMembers d = mr.resolve(sql_object_type, null, null);\n\n        final Map<Method, Handler> handlers = new HashMap<Method, Handler>();\n        for (final ResolvedMethod method : d.getMemberMethods()) {\n            final Method raw_method = method.getRawMember();\n\n            if (raw_method.isAnnotationPresent(SqlQuery.class)) {\n                handlers.put(raw_method, new QueryHandler(sqlObjectType, method, ResultReturnThing.forType(method)));\n            }\n            else if (raw_method.isAnnotationPresent(SqlUpdate.class)) {\n                handlers.put(raw_method, new UpdateHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlBatch.class)) {\n                handlers.put(raw_method, new BatchHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlCall.class)) {\n                handlers.put(raw_method, new CallHandler(sqlObjectType, method));\n            }\n            else if(raw_method.isAnnotationPresent(CreateSqlObject.class)) {\n                handlers.put(raw_method, new CreateSqlObjectHandler(raw_method.getReturnType()));\n            }\n            else if (method.getName().equals(\"close\") && method.getRawMember().getParameterTypes().length == 0) {\n                handlers.put(raw_method, new CloseHandler());\n            }\n            else if (method.getName().equals(\"finalize\") && method.getRawMember().getParameterTypes().length == 0) {\n                // no handler for finalize()\n            }\n            else if (raw_method.isAnnotationPresent(Transaction.class)) {\n                handlers.put(raw_method, new PassThroughTransactionHandler(raw_method, raw_method.getAnnotation(Transaction.class)));\n            }\n            else if (mixinHandlers.containsKey(raw_method)) {\n                handlers.put(raw_method, mixinHandlers.get(raw_method));\n            }\n            else {\n                handlers.put(raw_method, new PassThroughHandler(raw_method));\n            }\n        }\n\n        // this is an implicit mixin, not an explicit one, so we need to *always* add it\n        handlers.putAll(CloseInternalDoNotUseThisClass.Helper.handlers());\n\n        handlers.putAll(EqualsHandler.handler());\n        handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n        handlers.putAll(HashCodeHandler.handler());\n\n        handlersCache.put(sqlObjectType, handlers);\n\n        return handlers;\n    }\n\n\n    private final Map<Method, Handler> handlers;\n    private final HandleDing           ding;\n\n    SqlObject(Map<Method, Handler> handlers, HandleDing ding)\n    {\n        this.handlers = handlers;\n        this.ding = ding;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args, MethodProxy mp) throws Throwable\n    {\n        final Handler handler = handlers.get(method);\n\n        // If there is no handler, pretend we are just an Object and don't open a connection (Issue #82)\n        if (handler == null) {\n            return mp.invokeSuper(proxy, args);\n        }\n\n        Throwable doNotMask = null;\n        String methodName = method.toString();\n        try {\n            ding.retain(methodName);\n            return handler.invoke(ding, proxy, args, mp);\n        }\n        catch (Throwable e) {\n            doNotMask = e;\n            throw e;\n        }\n        finally {\n            try {\n                ding.release(methodName);\n            }\n            catch (Throwable e) {\n                if (doNotMask==null) {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public static void close(Object sqlObject)\n    {\n        if (!(sqlObject instanceof CloseInternalDoNotUseThisClass)) {\n            throw new IllegalArgumentException(sqlObject + \" is not a sql object\");\n        }\n        CloseInternalDoNotUseThisClass closer = (CloseInternalDoNotUseThisClass) sqlObject;\n        closer.___jdbi_close___();\n    }\n\n    static String getSql(SqlCall q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n}\n","lineNo":213}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.Token;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.regex.Matcher;\n\n/**\n * looks for [name], then [name].sql on the classpath\n */\npublic class ClasspathStatementLocator implements StatementLocator\n{\n    private final Map<Object, String> found = Collections.synchronizedMap(new WeakHashMap<Object, String>());\n\n    /**\n     * Very basic sanity test to see if a string looks like it might be sql\n     */\n    public static boolean looksLikeSql(String sql)\n    {\n        final String local = left(stripStart(sql), 8).toLowerCase();\n        return local.startsWith(\"insert \")\n               || local.startsWith(\"update \")\n               || local.startsWith(\"select \")\n               || local.startsWith(\"call \")\n               || local.startsWith(\"delete \")\n               || local.startsWith(\"create \")\n               || local.startsWith(\"alter \")\n               || local.startsWith(\"merge \")\n               || local.startsWith(\"replace \")\n               || local.startsWith(\"drop \");\n    }\n\n    /**\n     * If the passed in name doesn't look like SQL it will search the classpath for a file\n     * which looks like the provided name.\n     * <p/>\n     * The \"looks like\" algorithm is not very sophisticated, it basically looks for the string\n     * to begin with insert, update, select, call, delete, create, alter, or drop followed\n     * by a space.\n     * <p/>\n     * If no resource is found using the passed in string, the string s returned as-is\n     *\n     * @param name Name or statement literal\n     *\n     * @return SQL to execute (which will go to a StatementRRewrter first)\n     *\n     * @throws UnableToCreateStatementException\n     *          if an IOException occurs reading a found resource\n     */\n    @Override\n    @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n    @SuppressFBWarnings(\"DM_STRING_CTOR\")\n    public String locate(String name, StatementContext ctx)\n    {\n        final Object cache_key;\n        boolean isSqlObjectMethod = false;\n        if (ctx.getSqlObjectType() != null) {\n            if (ctx.getSqlObjectMethod() != null) {\n                isSqlObjectMethod = true;\n                cache_key = ctx.getSqlObjectMethod();\n            } else {\n                cache_key = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n            }\n        }\n        else {\n            cache_key = name;\n        }\n\n        String cached = found.get(cache_key);\n        if (cached != null) {\n            return cached;\n        }\n\n\n        if (looksLikeSql(name)) {\n            // No need to cache individual SQL statements that don't cause us to search the classpath\n            // But for static SQL object methods caching decreases GC pressure and not threatens memory leaks.\n            if (isSqlObjectMethod) {\n                found.put(cache_key, name);\n            }\n            return name;\n        }\n        final ClassLoader loader = selectClassLoader();\n        InputStream in_stream = null;\n        try {\n            in_stream = loader.getResourceAsStream(name);\n            if (in_stream == null) {\n                in_stream = loader.getResourceAsStream(name + \".sql\");\n            }\n\n            if (in_stream == null && ctx.getSqlObjectType() != null) {\n                String filename = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n                in_stream = loader.getResourceAsStream(filename);\n                if (in_stream == null) {\n                    in_stream = ctx.getSqlObjectType().getResourceAsStream(filename);\n                }\n            }\n\n            if (in_stream == null) {\n                // Ensure we don't store an identity map entry which has a hard reference\n                // to the key (through the value) by copying the value, avoids potential memory leak.\n                found.put(cache_key, name == cache_key ? new String(name) : name);\n                return name;\n            }\n            String sql;\n            try {\n                sql = SQL_SCRIPT_PARSER.parse(new ANTLRInputStream(in_stream));\n            } catch (IOException e) {\n                throw new UnableToCreateStatementException(e.getMessage(), e, ctx);\n            }\n\n            found.put(cache_key, sql);\n            return sql;\n        }\n        finally {\n            try {\n                if (in_stream != null) {\n                    in_stream.close();\n                }\n            }\n            catch (IOException e) {\n                // nothing we can do here :-(\n            }\n        }\n    }\n\n    /**\n     * There *must* be a better place to put this without creating a helpers class just for it\n     */\n    private static ClassLoader selectClassLoader()\n    {\n        ClassLoader loader;\n        if (Thread.currentThread().getContextClassLoader() != null) {\n            loader = Thread.currentThread().getContextClassLoader();\n        }\n        else {\n            loader = ClasspathStatementLocator.class.getClassLoader();\n        }\n        return loader;\n    }\n\n    private static boolean isComment(final String line)\n    {\n        return line.startsWith(\"#\") || line.startsWith(\"--\") || line.startsWith(\"//\");\n    }\n\n    private static final String SEP = \"/\"; // *Not* System.getProperty(\"file.separator\"), which breaks in jars\n\n    private static String mungify(String path)\n    {\n        return path.replaceAll(\"\\\\.\", Matcher.quoteReplacement(SEP));\n    }\n\n\n    // (scs) Logic copied from commons-lang3 3.1 with minor edits, per discussion on commit 023a14ade2d33bf8ccfa0f68294180455233ad52\n    private static String stripStart(String str)\n    {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return \"\";\n        }\n        int start = 0;\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        return str.substring(start);\n    }\n\n    private static String left(String str, int len)\n    {\n        if (str == null || len < 0) {\n            return \"\";\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    private static final SqlScriptParser SQL_SCRIPT_PARSER = new SqlScriptParser(new SqlScriptParser.TokenHandler() {\n        @Override\n        public void handle(Token t, StringBuilder sb) {\n            sb.append(t.getText());\n        }\n    });\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.Token;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.regex.Matcher;\n\n/**\n * looks for [name], then [name].sql on the classpath\n */\npublic class ClasspathStatementLocator implements StatementLocator\n{\n    private static class CacheKey {\n        final String name;\n        final Class<?> sqlObjectType;\n        final Method sqlObjectMethod;\n\n        public CacheKey(String name, Class<?> sqlObjectType, Method sqlObjectMethod) {\n            this.name = name;\n            this.sqlObjectType = sqlObjectType;\n            this.sqlObjectMethod = sqlObjectMethod;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            CacheKey cacheKey = (CacheKey) o;\n\n            if (name != null ? !name.equals(cacheKey.name) : cacheKey.name != null) return false;\n            if (sqlObjectType != null ? !sqlObjectType.equals(cacheKey.sqlObjectType) : cacheKey.sqlObjectType != null)\n                return false;\n            return sqlObjectMethod != null ? sqlObjectMethod.equals(cacheKey.sqlObjectMethod) : cacheKey.sqlObjectMethod == null;\n\n        }\n\n        @Override\n        public int hashCode() {\n            int result = name != null ? name.hashCode() : 0;\n            result = 31 * result + (sqlObjectType != null ? sqlObjectType.hashCode() : 0);\n            result = 31 * result + (sqlObjectMethod != null ? sqlObjectMethod.hashCode() : 0);\n            return result;\n        }\n    }\n\n    private final Map<CacheKey, String> found = Collections.synchronizedMap(new WeakHashMap<CacheKey, String>());\n\n    /**\n     * Very basic sanity test to see if a string looks like it might be sql\n     */\n    public static boolean looksLikeSql(String sql)\n    {\n        final String local = left(stripStart(sql), 8).toLowerCase();\n        return local.startsWith(\"insert \")\n               || local.startsWith(\"update \")\n               || local.startsWith(\"select \")\n               || local.startsWith(\"call \")\n               || local.startsWith(\"delete \")\n               || local.startsWith(\"create \")\n               || local.startsWith(\"alter \")\n               || local.startsWith(\"merge \")\n               || local.startsWith(\"replace \")\n               || local.startsWith(\"drop \");\n    }\n\n    /**\n     * If the passed in name doesn't look like SQL it will search the classpath for a file\n     * which looks like the provided name.\n     * <p/>\n     * The \"looks like\" algorithm is not very sophisticated, it basically looks for the string\n     * to begin with insert, update, select, call, delete, create, alter, or drop followed\n     * by a space.\n     * <p/>\n     * If no resource is found using the passed in string, the string s returned as-is\n     *\n     * @param name Name or statement literal\n     *\n     * @return SQL to execute (which will go to a StatementRRewrter first)\n     *\n     * @throws UnableToCreateStatementException\n     *          if an IOException occurs reading a found resource\n     */\n    @Override\n    @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n    @SuppressFBWarnings(\"DM_STRING_CTOR\")\n    public String locate(String name, StatementContext ctx)\n    {\n        final CacheKey cache_key = new CacheKey(name, ctx.getSqlObjectType(), ctx.getSqlObjectMethod());\n        boolean isSqlObjectMethod = ctx.getSqlObjectType() != null && ctx.getSqlObjectMethod() != null;\n\n\n        String cached = found.get(cache_key);\n        if (cached != null) {\n            return cached;\n        }\n\n\n        if (looksLikeSql(name)) {\n            // No need to cache individual SQL statements that don't cause us to search the classpath\n            // But for static SQL object methods caching decreases GC pressure and not threatens memory leaks.\n            if (isSqlObjectMethod) {\n                found.put(cache_key, name);\n            }\n            return name;\n        }\n        final ClassLoader loader = selectClassLoader();\n        InputStream in_stream = null;\n        try {\n            in_stream = loader.getResourceAsStream(name);\n            if (in_stream == null) {\n                in_stream = loader.getResourceAsStream(name + \".sql\");\n            }\n\n            if (in_stream == null && ctx.getSqlObjectType() != null) {\n                String filename = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n                in_stream = loader.getResourceAsStream(filename);\n                if (in_stream == null) {\n                    in_stream = ctx.getSqlObjectType().getResourceAsStream(filename);\n                }\n            }\n\n            if (in_stream == null) {\n                // Ensure we don't store an identity map entry which has a hard reference\n                // to the key (through the value) by copying the value, avoids potential memory leak.\n                found.put(cache_key, isSqlObjectMethod ? name : new String(name));\n                return name;\n            }\n            String sql;\n            try {\n                sql = SQL_SCRIPT_PARSER.parse(new ANTLRInputStream(in_stream));\n            } catch (IOException e) {\n                throw new UnableToCreateStatementException(e.getMessage(), e, ctx);\n            }\n\n            found.put(cache_key, sql);\n            return sql;\n        }\n        finally {\n            try {\n                if (in_stream != null) {\n                    in_stream.close();\n                }\n            }\n            catch (IOException e) {\n                // nothing we can do here :-(\n            }\n        }\n    }\n\n    /**\n     * There *must* be a better place to put this without creating a helpers class just for it\n     */\n    private static ClassLoader selectClassLoader()\n    {\n        ClassLoader loader;\n        if (Thread.currentThread().getContextClassLoader() != null) {\n            loader = Thread.currentThread().getContextClassLoader();\n        }\n        else {\n            loader = ClasspathStatementLocator.class.getClassLoader();\n        }\n        return loader;\n    }\n\n    private static boolean isComment(final String line)\n    {\n        return line.startsWith(\"#\") || line.startsWith(\"--\") || line.startsWith(\"//\");\n    }\n\n    private static final String SEP = \"/\"; // *Not* System.getProperty(\"file.separator\"), which breaks in jars\n\n    private static String mungify(String path)\n    {\n        return path.replaceAll(\"\\\\.\", Matcher.quoteReplacement(SEP));\n    }\n\n\n    // (scs) Logic copied from commons-lang3 3.1 with minor edits, per discussion on commit 023a14ade2d33bf8ccfa0f68294180455233ad52\n    private static String stripStart(String str)\n    {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return \"\";\n        }\n        int start = 0;\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        return str.substring(start);\n    }\n\n    private static String left(String str, int len)\n    {\n        if (str == null || len < 0) {\n            return \"\";\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    private static final SqlScriptParser SQL_SCRIPT_PARSER = new SqlScriptParser(new SqlScriptParser.TokenHandler() {\n        @Override\n        public void handle(Token t, StringBuilder sb) {\n            sb.append(t.getText());\n        }\n    });\n}\n","lineNo":114}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.Token;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.WeakHashMap;\nimport java.util.regex.Matcher;\n\n/**\n * looks for [name], then [name].sql on the classpath\n */\npublic class ClasspathStatementLocator implements StatementLocator\n{\n    private final Map<String, String> found = Collections.synchronizedMap(new WeakHashMap<String, String>());\n\n    /**\n     * Very basic sanity test to see if a string looks like it might be sql\n     */\n    public static boolean looksLikeSql(String sql)\n    {\n        final String local = left(stripStart(sql), 8).toLowerCase();\n        return local.startsWith(\"insert \")\n               || local.startsWith(\"update \")\n               || local.startsWith(\"select \")\n               || local.startsWith(\"call \")\n               || local.startsWith(\"delete \")\n               || local.startsWith(\"create \")\n               || local.startsWith(\"alter \")\n               || local.startsWith(\"merge \")\n               || local.startsWith(\"replace \")\n               || local.startsWith(\"drop \");\n    }\n\n    /**\n     * If the passed in name doesn't look like SQL it will search the classpath for a file\n     * which looks like the provided name.\n     * <p/>\n     * The \"looks like\" algorithm is not very sophisticated, it basically looks for the string\n     * to begin with insert, update, select, call, delete, create, alter, or drop followed\n     * by a space.\n     * <p/>\n     * If no resource is found using the passed in string, the string s returned as-is\n     *\n     * @param name Name or statement literal\n     *\n     * @return SQL to execute (which will go to a StatementRRewrter first)\n     *\n     * @throws UnableToCreateStatementException\n     *          if an IOException occurs reading a found resource\n     */\n    @Override\n    @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n    @SuppressFBWarnings(\"DM_STRING_CTOR\")\n    public String locate(String name, StatementContext ctx)\n    {\n        final String cache_key;\n        if (ctx.getSqlObjectType() != null) {\n            cache_key = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n        }\n        else {\n            cache_key = name;\n        }\n\n        if (found.containsKey(cache_key)) {\n            return found.get(cache_key);\n        }\n\n        if (looksLikeSql(name)) {\n            // No need to cache individual SQL statements that don't cause us to search the classpath\n            return name;\n        }\n        final ClassLoader loader = selectClassLoader();\n        InputStream in_stream = null;\n        try {\n            in_stream = loader.getResourceAsStream(name);\n            if (in_stream == null) {\n                in_stream = loader.getResourceAsStream(name + \".sql\");\n            }\n\n            if (in_stream == null && ctx.getSqlObjectType() != null) {\n                String filename = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n                in_stream = loader.getResourceAsStream(filename);\n                if (in_stream == null) {\n                    in_stream = ctx.getSqlObjectType().getResourceAsStream(filename);\n                }\n            }\n\n            if (in_stream == null) {\n                // Ensure we don't store an identity map entry which has a hard reference\n                // to the key (through the value) by copying the value, avoids potential memory leak.\n                found.put(cache_key, name == cache_key ? new String(name) : name);\n                return name;\n            }\n            String sql;\n            try {\n                sql = SQL_SCRIPT_PARSER.parse(new ANTLRInputStream(in_stream));\n            } catch (IOException e) {\n                throw new UnableToCreateStatementException(e.getMessage(), e, ctx);\n            }\n\n            found.put(cache_key, sql);\n            return sql;\n        }\n        finally {\n            try {\n                if (in_stream != null) {\n                    in_stream.close();\n                }\n            }\n            catch (IOException e) {\n                // nothing we can do here :-(\n            }\n        }\n    }\n\n    /**\n     * There *must* be a better place to put this without creating a helpers class just for it\n     */\n    private static ClassLoader selectClassLoader()\n    {\n        ClassLoader loader;\n        if (Thread.currentThread().getContextClassLoader() != null) {\n            loader = Thread.currentThread().getContextClassLoader();\n        }\n        else {\n            loader = ClasspathStatementLocator.class.getClassLoader();\n        }\n        return loader;\n    }\n\n    private static boolean isComment(final String line)\n    {\n        return line.startsWith(\"#\") || line.startsWith(\"--\") || line.startsWith(\"//\");\n    }\n\n    private static final String SEP = \"/\"; // *Not* System.getProperty(\"file.separator\"), which breaks in jars\n\n    private static String mungify(String path)\n    {\n        return path.replaceAll(\"\\\\.\", Matcher.quoteReplacement(SEP));\n    }\n\n\n    // (scs) Logic copied from commons-lang3 3.1 with minor edits, per discussion on commit 023a14ade2d33bf8ccfa0f68294180455233ad52\n    private static String stripStart(String str)\n    {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return \"\";\n        }\n        int start = 0;\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        return str.substring(start);\n    }\n\n    private static String left(String str, int len)\n    {\n        if (str == null || len < 0) {\n            return \"\";\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    private static final SqlScriptParser SQL_SCRIPT_PARSER = new SqlScriptParser(new SqlScriptParser.TokenHandler() {\n        @Override\n        public void handle(Token t, StringBuilder sb) {\n            sb.append(t.getText());\n        }\n    });\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.Token;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.regex.Matcher;\n\n/**\n * looks for [name], then [name].sql on the classpath\n */\npublic class ClasspathStatementLocator implements StatementLocator\n{\n    private final Map<Object, String> found = Collections.synchronizedMap(new WeakHashMap<Object, String>());\n\n    /**\n     * Very basic sanity test to see if a string looks like it might be sql\n     */\n    public static boolean looksLikeSql(String sql)\n    {\n        final String local = left(stripStart(sql), 8).toLowerCase();\n        return local.startsWith(\"insert \")\n               || local.startsWith(\"update \")\n               || local.startsWith(\"select \")\n               || local.startsWith(\"call \")\n               || local.startsWith(\"delete \")\n               || local.startsWith(\"create \")\n               || local.startsWith(\"alter \")\n               || local.startsWith(\"merge \")\n               || local.startsWith(\"replace \")\n               || local.startsWith(\"drop \");\n    }\n\n    /**\n     * If the passed in name doesn't look like SQL it will search the classpath for a file\n     * which looks like the provided name.\n     * <p/>\n     * The \"looks like\" algorithm is not very sophisticated, it basically looks for the string\n     * to begin with insert, update, select, call, delete, create, alter, or drop followed\n     * by a space.\n     * <p/>\n     * If no resource is found using the passed in string, the string s returned as-is\n     *\n     * @param name Name or statement literal\n     *\n     * @return SQL to execute (which will go to a StatementRRewrter first)\n     *\n     * @throws UnableToCreateStatementException\n     *          if an IOException occurs reading a found resource\n     */\n    @Override\n    @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n    @SuppressFBWarnings(\"DM_STRING_CTOR\")\n    public String locate(String name, StatementContext ctx)\n    {\n        final Object cache_key;\n        boolean isSqlObjectMethod = false;\n        if (ctx.getSqlObjectType() != null) {\n            if (ctx.getSqlObjectMethod() != null) {\n                isSqlObjectMethod = true;\n                cache_key = ctx.getSqlObjectMethod();\n            } else {\n                cache_key = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n            }\n        }\n        else {\n            cache_key = name;\n        }\n\n        String cached = found.get(cache_key);\n        if (cached != null) {\n            return cached;\n        }\n\n\n        if (looksLikeSql(name)) {\n            // No need to cache individual SQL statements that don't cause us to search the classpath\n            // But for static SQL object methods caching decreases GC pressure and not threatens memory leaks.\n            if (isSqlObjectMethod) {\n                found.put(cache_key, name);\n            }\n            return name;\n        }\n        final ClassLoader loader = selectClassLoader();\n        InputStream in_stream = null;\n        try {\n            in_stream = loader.getResourceAsStream(name);\n            if (in_stream == null) {\n                in_stream = loader.getResourceAsStream(name + \".sql\");\n            }\n\n            if (in_stream == null && ctx.getSqlObjectType() != null) {\n                String filename = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n                in_stream = loader.getResourceAsStream(filename);\n                if (in_stream == null) {\n                    in_stream = ctx.getSqlObjectType().getResourceAsStream(filename);\n                }\n            }\n\n            if (in_stream == null) {\n                // Ensure we don't store an identity map entry which has a hard reference\n                // to the key (through the value) by copying the value, avoids potential memory leak.\n                found.put(cache_key, name == cache_key ? new String(name) : name);\n                return name;\n            }\n            String sql;\n            try {\n                sql = SQL_SCRIPT_PARSER.parse(new ANTLRInputStream(in_stream));\n            } catch (IOException e) {\n                throw new UnableToCreateStatementException(e.getMessage(), e, ctx);\n            }\n\n            found.put(cache_key, sql);\n            return sql;\n        }\n        finally {\n            try {\n                if (in_stream != null) {\n                    in_stream.close();\n                }\n            }\n            catch (IOException e) {\n                // nothing we can do here :-(\n            }\n        }\n    }\n\n    /**\n     * There *must* be a better place to put this without creating a helpers class just for it\n     */\n    private static ClassLoader selectClassLoader()\n    {\n        ClassLoader loader;\n        if (Thread.currentThread().getContextClassLoader() != null) {\n            loader = Thread.currentThread().getContextClassLoader();\n        }\n        else {\n            loader = ClasspathStatementLocator.class.getClassLoader();\n        }\n        return loader;\n    }\n\n    private static boolean isComment(final String line)\n    {\n        return line.startsWith(\"#\") || line.startsWith(\"--\") || line.startsWith(\"//\");\n    }\n\n    private static final String SEP = \"/\"; // *Not* System.getProperty(\"file.separator\"), which breaks in jars\n\n    private static String mungify(String path)\n    {\n        return path.replaceAll(\"\\\\.\", Matcher.quoteReplacement(SEP));\n    }\n\n\n    // (scs) Logic copied from commons-lang3 3.1 with minor edits, per discussion on commit 023a14ade2d33bf8ccfa0f68294180455233ad52\n    private static String stripStart(String str)\n    {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return \"\";\n        }\n        int start = 0;\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        return str.substring(start);\n    }\n\n    private static String left(String str, int len)\n    {\n        if (str == null || len < 0) {\n            return \"\";\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    private static final SqlScriptParser SQL_SCRIPT_PARSER = new SqlScriptParser(new SqlScriptParser.TokenHandler() {\n        @Override\n        public void handle(Token t, StringBuilder sb) {\n            sb.append(t.getText());\n        }\n    });\n}\n","lineNo":92}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.Token;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.regex.Matcher;\n\n/**\n * looks for [name], then [name].sql on the classpath\n */\npublic class ClasspathStatementLocator implements StatementLocator\n{\n    private final Map<Object, String> found = Collections.synchronizedMap(new WeakHashMap<Object, String>());\n\n    /**\n     * Very basic sanity test to see if a string looks like it might be sql\n     */\n    public static boolean looksLikeSql(String sql)\n    {\n        final String local = left(stripStart(sql), 8).toLowerCase();\n        return local.startsWith(\"insert \")\n               || local.startsWith(\"update \")\n               || local.startsWith(\"select \")\n               || local.startsWith(\"call \")\n               || local.startsWith(\"delete \")\n               || local.startsWith(\"create \")\n               || local.startsWith(\"alter \")\n               || local.startsWith(\"merge \")\n               || local.startsWith(\"replace \")\n               || local.startsWith(\"drop \");\n    }\n\n    /**\n     * If the passed in name doesn't look like SQL it will search the classpath for a file\n     * which looks like the provided name.\n     * <p/>\n     * The \"looks like\" algorithm is not very sophisticated, it basically looks for the string\n     * to begin with insert, update, select, call, delete, create, alter, or drop followed\n     * by a space.\n     * <p/>\n     * If no resource is found using the passed in string, the string s returned as-is\n     *\n     * @param name Name or statement literal\n     *\n     * @return SQL to execute (which will go to a StatementRRewrter first)\n     *\n     * @throws UnableToCreateStatementException\n     *          if an IOException occurs reading a found resource\n     */\n    @Override\n    @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n    @SuppressFBWarnings(\"DM_STRING_CTOR\")\n    public String locate(String name, StatementContext ctx)\n    {\n        final Object cache_key;\n        boolean isSqlObjectMethod = false;\n        if (ctx.getSqlObjectType() != null) {\n            if (ctx.getSqlObjectMethod() != null) {\n                isSqlObjectMethod = true;\n                cache_key = ctx.getSqlObjectMethod();\n            } else {\n                cache_key = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n            }\n        }\n        else {\n            cache_key = name;\n        }\n\n        String cached = found.get(cache_key);\n        if (cached != null) {\n            return cached;\n        }\n\n\n        if (looksLikeSql(name)) {\n            // No need to cache individual SQL statements that don't cause us to search the classpath\n            // But for static SQL object methods caching decreases GC pressure and not threatens memory leaks.\n            if (isSqlObjectMethod) {\n                found.put(cache_key, name);\n            }\n            return name;\n        }\n        final ClassLoader loader = selectClassLoader();\n        InputStream in_stream = null;\n        try {\n            in_stream = loader.getResourceAsStream(name);\n            if (in_stream == null) {\n                in_stream = loader.getResourceAsStream(name + \".sql\");\n            }\n\n            if (in_stream == null && ctx.getSqlObjectType() != null) {\n                String filename = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n                in_stream = loader.getResourceAsStream(filename);\n                if (in_stream == null) {\n                    in_stream = ctx.getSqlObjectType().getResourceAsStream(filename);\n                }\n            }\n\n            if (in_stream == null) {\n                // Ensure we don't store an identity map entry which has a hard reference\n                // to the key (through the value) by copying the value, avoids potential memory leak.\n                found.put(cache_key, name == cache_key ? new String(name) : name);\n                return name;\n            }\n            String sql;\n            try {\n                sql = SQL_SCRIPT_PARSER.parse(new ANTLRInputStream(in_stream));\n            } catch (IOException e) {\n                throw new UnableToCreateStatementException(e.getMessage(), e, ctx);\n            }\n\n            found.put(cache_key, sql);\n            return sql;\n        }\n        finally {\n            try {\n                if (in_stream != null) {\n                    in_stream.close();\n                }\n            }\n            catch (IOException e) {\n                // nothing we can do here :-(\n            }\n        }\n    }\n\n    /**\n     * There *must* be a better place to put this without creating a helpers class just for it\n     */\n    private static ClassLoader selectClassLoader()\n    {\n        ClassLoader loader;\n        if (Thread.currentThread().getContextClassLoader() != null) {\n            loader = Thread.currentThread().getContextClassLoader();\n        }\n        else {\n            loader = ClasspathStatementLocator.class.getClassLoader();\n        }\n        return loader;\n    }\n\n    private static boolean isComment(final String line)\n    {\n        return line.startsWith(\"#\") || line.startsWith(\"--\") || line.startsWith(\"//\");\n    }\n\n    private static final String SEP = \"/\"; // *Not* System.getProperty(\"file.separator\"), which breaks in jars\n\n    private static String mungify(String path)\n    {\n        return path.replaceAll(\"\\\\.\", Matcher.quoteReplacement(SEP));\n    }\n\n\n    // (scs) Logic copied from commons-lang3 3.1 with minor edits, per discussion on commit 023a14ade2d33bf8ccfa0f68294180455233ad52\n    private static String stripStart(String str)\n    {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return \"\";\n        }\n        int start = 0;\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        return str.substring(start);\n    }\n\n    private static String left(String str, int len)\n    {\n        if (str == null || len < 0) {\n            return \"\";\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    private static final SqlScriptParser SQL_SCRIPT_PARSER = new SqlScriptParser(new SqlScriptParser.TokenHandler() {\n        @Override\n        public void handle(Token t, StringBuilder sb) {\n            sb.append(t.getText());\n        }\n    });\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.Token;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.regex.Matcher;\n\n/**\n * looks for [name], then [name].sql on the classpath\n */\npublic class ClasspathStatementLocator implements StatementLocator\n{\n    private static class CacheKey {\n        final String name;\n        final Class<?> sqlObjectType;\n        final Method sqlObjectMethod;\n\n        public CacheKey(String name, Class<?> sqlObjectType, Method sqlObjectMethod) {\n            this.name = name;\n            this.sqlObjectType = sqlObjectType;\n            this.sqlObjectMethod = sqlObjectMethod;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            CacheKey cacheKey = (CacheKey) o;\n\n            if (name != null ? !name.equals(cacheKey.name) : cacheKey.name != null) return false;\n            if (sqlObjectType != null ? !sqlObjectType.equals(cacheKey.sqlObjectType) : cacheKey.sqlObjectType != null)\n                return false;\n            return sqlObjectMethod != null ? sqlObjectMethod.equals(cacheKey.sqlObjectMethod) : cacheKey.sqlObjectMethod == null;\n\n        }\n\n        @Override\n        public int hashCode() {\n            int result = name != null ? name.hashCode() : 0;\n            result = 31 * result + (sqlObjectType != null ? sqlObjectType.hashCode() : 0);\n            result = 31 * result + (sqlObjectMethod != null ? sqlObjectMethod.hashCode() : 0);\n            return result;\n        }\n    }\n\n    private final Map<CacheKey, String> found = Collections.synchronizedMap(new WeakHashMap<CacheKey, String>());\n\n    /**\n     * Very basic sanity test to see if a string looks like it might be sql\n     */\n    public static boolean looksLikeSql(String sql)\n    {\n        final String local = left(stripStart(sql), 8).toLowerCase();\n        return local.startsWith(\"insert \")\n               || local.startsWith(\"update \")\n               || local.startsWith(\"select \")\n               || local.startsWith(\"call \")\n               || local.startsWith(\"delete \")\n               || local.startsWith(\"create \")\n               || local.startsWith(\"alter \")\n               || local.startsWith(\"merge \")\n               || local.startsWith(\"replace \")\n               || local.startsWith(\"drop \");\n    }\n\n    /**\n     * If the passed in name doesn't look like SQL it will search the classpath for a file\n     * which looks like the provided name.\n     * <p/>\n     * The \"looks like\" algorithm is not very sophisticated, it basically looks for the string\n     * to begin with insert, update, select, call, delete, create, alter, or drop followed\n     * by a space.\n     * <p/>\n     * If no resource is found using the passed in string, the string s returned as-is\n     *\n     * @param name Name or statement literal\n     *\n     * @return SQL to execute (which will go to a StatementRRewrter first)\n     *\n     * @throws UnableToCreateStatementException\n     *          if an IOException occurs reading a found resource\n     */\n    @Override\n    @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n    @SuppressFBWarnings(\"DM_STRING_CTOR\")\n    public String locate(String name, StatementContext ctx)\n    {\n        final CacheKey cache_key = new CacheKey(name, ctx.getSqlObjectType(), ctx.getSqlObjectMethod());\n        boolean isSqlObjectMethod = ctx.getSqlObjectType() != null && ctx.getSqlObjectMethod() != null;\n\n\n        String cached = found.get(cache_key);\n        if (cached != null) {\n            return cached;\n        }\n\n\n        if (looksLikeSql(name)) {\n            // No need to cache individual SQL statements that don't cause us to search the classpath\n            // But for static SQL object methods caching decreases GC pressure and not threatens memory leaks.\n            if (isSqlObjectMethod) {\n                found.put(cache_key, name);\n            }\n            return name;\n        }\n        final ClassLoader loader = selectClassLoader();\n        InputStream in_stream = null;\n        try {\n            in_stream = loader.getResourceAsStream(name);\n            if (in_stream == null) {\n                in_stream = loader.getResourceAsStream(name + \".sql\");\n            }\n\n            if (in_stream == null && ctx.getSqlObjectType() != null) {\n                String filename = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n                in_stream = loader.getResourceAsStream(filename);\n                if (in_stream == null) {\n                    in_stream = ctx.getSqlObjectType().getResourceAsStream(filename);\n                }\n            }\n\n            if (in_stream == null) {\n                // Ensure we don't store an identity map entry which has a hard reference\n                // to the key (through the value) by copying the value, avoids potential memory leak.\n                found.put(cache_key, isSqlObjectMethod ? name : new String(name));\n                return name;\n            }\n            String sql;\n            try {\n                sql = SQL_SCRIPT_PARSER.parse(new ANTLRInputStream(in_stream));\n            } catch (IOException e) {\n                throw new UnableToCreateStatementException(e.getMessage(), e, ctx);\n            }\n\n            found.put(cache_key, sql);\n            return sql;\n        }\n        finally {\n            try {\n                if (in_stream != null) {\n                    in_stream.close();\n                }\n            }\n            catch (IOException e) {\n                // nothing we can do here :-(\n            }\n        }\n    }\n\n    /**\n     * There *must* be a better place to put this without creating a helpers class just for it\n     */\n    private static ClassLoader selectClassLoader()\n    {\n        ClassLoader loader;\n        if (Thread.currentThread().getContextClassLoader() != null) {\n            loader = Thread.currentThread().getContextClassLoader();\n        }\n        else {\n            loader = ClasspathStatementLocator.class.getClassLoader();\n        }\n        return loader;\n    }\n\n    private static boolean isComment(final String line)\n    {\n        return line.startsWith(\"#\") || line.startsWith(\"--\") || line.startsWith(\"//\");\n    }\n\n    private static final String SEP = \"/\"; // *Not* System.getProperty(\"file.separator\"), which breaks in jars\n\n    private static String mungify(String path)\n    {\n        return path.replaceAll(\"\\\\.\", Matcher.quoteReplacement(SEP));\n    }\n\n\n    // (scs) Logic copied from commons-lang3 3.1 with minor edits, per discussion on commit 023a14ade2d33bf8ccfa0f68294180455233ad52\n    private static String stripStart(String str)\n    {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return \"\";\n        }\n        int start = 0;\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        return str.substring(start);\n    }\n\n    private static String left(String str, int len)\n    {\n        if (str == null || len < 0) {\n            return \"\";\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    private static final SqlScriptParser SQL_SCRIPT_PARSER = new SqlScriptParser(new SqlScriptParser.TokenHandler() {\n        @Override\n        public void handle(Token t, StringBuilder sb) {\n            sb.append(t.getText());\n        }\n    });\n}\n","lineNo":114}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.Token;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.WeakHashMap;\nimport java.util.regex.Matcher;\n\n/**\n * looks for [name], then [name].sql on the classpath\n */\npublic class ClasspathStatementLocator implements StatementLocator\n{\n    private final Map<String, String> found = Collections.synchronizedMap(new WeakHashMap<String, String>());\n\n    /**\n     * Very basic sanity test to see if a string looks like it might be sql\n     */\n    public static boolean looksLikeSql(String sql)\n    {\n        final String local = left(stripStart(sql), 8).toLowerCase();\n        return local.startsWith(\"insert \")\n               || local.startsWith(\"update \")\n               || local.startsWith(\"select \")\n               || local.startsWith(\"call \")\n               || local.startsWith(\"delete \")\n               || local.startsWith(\"create \")\n               || local.startsWith(\"alter \")\n               || local.startsWith(\"merge \")\n               || local.startsWith(\"replace \")\n               || local.startsWith(\"drop \");\n    }\n\n    /**\n     * If the passed in name doesn't look like SQL it will search the classpath for a file\n     * which looks like the provided name.\n     * <p/>\n     * The \"looks like\" algorithm is not very sophisticated, it basically looks for the string\n     * to begin with insert, update, select, call, delete, create, alter, or drop followed\n     * by a space.\n     * <p/>\n     * If no resource is found using the passed in string, the string s returned as-is\n     *\n     * @param name Name or statement literal\n     *\n     * @return SQL to execute (which will go to a StatementRRewrter first)\n     *\n     * @throws UnableToCreateStatementException\n     *          if an IOException occurs reading a found resource\n     */\n    @Override\n    @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n    @SuppressFBWarnings(\"DM_STRING_CTOR\")\n    public String locate(String name, StatementContext ctx)\n    {\n        final String cache_key;\n        if (ctx.getSqlObjectType() != null) {\n            cache_key = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n        }\n        else {\n            cache_key = name;\n        }\n\n        if (found.containsKey(cache_key)) {\n            return found.get(cache_key);\n        }\n\n        if (looksLikeSql(name)) {\n            // No need to cache individual SQL statements that don't cause us to search the classpath\n            return name;\n        }\n        final ClassLoader loader = selectClassLoader();\n        InputStream in_stream = null;\n        try {\n            in_stream = loader.getResourceAsStream(name);\n            if (in_stream == null) {\n                in_stream = loader.getResourceAsStream(name + \".sql\");\n            }\n\n            if (in_stream == null && ctx.getSqlObjectType() != null) {\n                String filename = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n                in_stream = loader.getResourceAsStream(filename);\n                if (in_stream == null) {\n                    in_stream = ctx.getSqlObjectType().getResourceAsStream(filename);\n                }\n            }\n\n            if (in_stream == null) {\n                // Ensure we don't store an identity map entry which has a hard reference\n                // to the key (through the value) by copying the value, avoids potential memory leak.\n                found.put(cache_key, name == cache_key ? new String(name) : name);\n                return name;\n            }\n            String sql;\n            try {\n                sql = SQL_SCRIPT_PARSER.parse(new ANTLRInputStream(in_stream));\n            } catch (IOException e) {\n                throw new UnableToCreateStatementException(e.getMessage(), e, ctx);\n            }\n\n            found.put(cache_key, sql);\n            return sql;\n        }\n        finally {\n            try {\n                if (in_stream != null) {\n                    in_stream.close();\n                }\n            }\n            catch (IOException e) {\n                // nothing we can do here :-(\n            }\n        }\n    }\n\n    /**\n     * There *must* be a better place to put this without creating a helpers class just for it\n     */\n    private static ClassLoader selectClassLoader()\n    {\n        ClassLoader loader;\n        if (Thread.currentThread().getContextClassLoader() != null) {\n            loader = Thread.currentThread().getContextClassLoader();\n        }\n        else {\n            loader = ClasspathStatementLocator.class.getClassLoader();\n        }\n        return loader;\n    }\n\n    private static boolean isComment(final String line)\n    {\n        return line.startsWith(\"#\") || line.startsWith(\"--\") || line.startsWith(\"//\");\n    }\n\n    private static final String SEP = \"/\"; // *Not* System.getProperty(\"file.separator\"), which breaks in jars\n\n    private static String mungify(String path)\n    {\n        return path.replaceAll(\"\\\\.\", Matcher.quoteReplacement(SEP));\n    }\n\n\n    // (scs) Logic copied from commons-lang3 3.1 with minor edits, per discussion on commit 023a14ade2d33bf8ccfa0f68294180455233ad52\n    private static String stripStart(String str)\n    {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return \"\";\n        }\n        int start = 0;\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        return str.substring(start);\n    }\n\n    private static String left(String str, int len)\n    {\n        if (str == null || len < 0) {\n            return \"\";\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    private static final SqlScriptParser SQL_SCRIPT_PARSER = new SqlScriptParser(new SqlScriptParser.TokenHandler() {\n        @Override\n        public void handle(Token t, StringBuilder sb) {\n            sb.append(t.getText());\n        }\n    });\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.antlr.runtime.ANTLRInputStream;\nimport org.antlr.runtime.Token;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.regex.Matcher;\n\n/**\n * looks for [name], then [name].sql on the classpath\n */\npublic class ClasspathStatementLocator implements StatementLocator\n{\n    private final Map<Object, String> found = Collections.synchronizedMap(new WeakHashMap<Object, String>());\n\n    /**\n     * Very basic sanity test to see if a string looks like it might be sql\n     */\n    public static boolean looksLikeSql(String sql)\n    {\n        final String local = left(stripStart(sql), 8).toLowerCase();\n        return local.startsWith(\"insert \")\n               || local.startsWith(\"update \")\n               || local.startsWith(\"select \")\n               || local.startsWith(\"call \")\n               || local.startsWith(\"delete \")\n               || local.startsWith(\"create \")\n               || local.startsWith(\"alter \")\n               || local.startsWith(\"merge \")\n               || local.startsWith(\"replace \")\n               || local.startsWith(\"drop \");\n    }\n\n    /**\n     * If the passed in name doesn't look like SQL it will search the classpath for a file\n     * which looks like the provided name.\n     * <p/>\n     * The \"looks like\" algorithm is not very sophisticated, it basically looks for the string\n     * to begin with insert, update, select, call, delete, create, alter, or drop followed\n     * by a space.\n     * <p/>\n     * If no resource is found using the passed in string, the string s returned as-is\n     *\n     * @param name Name or statement literal\n     *\n     * @return SQL to execute (which will go to a StatementRRewrter first)\n     *\n     * @throws UnableToCreateStatementException\n     *          if an IOException occurs reading a found resource\n     */\n    @Override\n    @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n    @SuppressFBWarnings(\"DM_STRING_CTOR\")\n    public String locate(String name, StatementContext ctx)\n    {\n        final Object cache_key;\n        boolean isSqlObjectMethod = false;\n        if (ctx.getSqlObjectType() != null) {\n            if (ctx.getSqlObjectMethod() != null) {\n                isSqlObjectMethod = true;\n                cache_key = ctx.getSqlObjectMethod();\n            } else {\n                cache_key = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n            }\n        }\n        else {\n            cache_key = name;\n        }\n\n        String cached = found.get(cache_key);\n        if (cached != null) {\n            return cached;\n        }\n\n\n        if (looksLikeSql(name)) {\n            // No need to cache individual SQL statements that don't cause us to search the classpath\n            // But for static SQL object methods caching decreases GC pressure and not threatens memory leaks.\n            if (isSqlObjectMethod) {\n                found.put(cache_key, name);\n            }\n            return name;\n        }\n        final ClassLoader loader = selectClassLoader();\n        InputStream in_stream = null;\n        try {\n            in_stream = loader.getResourceAsStream(name);\n            if (in_stream == null) {\n                in_stream = loader.getResourceAsStream(name + \".sql\");\n            }\n\n            if (in_stream == null && ctx.getSqlObjectType() != null) {\n                String filename = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n                in_stream = loader.getResourceAsStream(filename);\n                if (in_stream == null) {\n                    in_stream = ctx.getSqlObjectType().getResourceAsStream(filename);\n                }\n            }\n\n            if (in_stream == null) {\n                // Ensure we don't store an identity map entry which has a hard reference\n                // to the key (through the value) by copying the value, avoids potential memory leak.\n                found.put(cache_key, name == cache_key ? new String(name) : name);\n                return name;\n            }\n            String sql;\n            try {\n                sql = SQL_SCRIPT_PARSER.parse(new ANTLRInputStream(in_stream));\n            } catch (IOException e) {\n                throw new UnableToCreateStatementException(e.getMessage(), e, ctx);\n            }\n\n            found.put(cache_key, sql);\n            return sql;\n        }\n        finally {\n            try {\n                if (in_stream != null) {\n                    in_stream.close();\n                }\n            }\n            catch (IOException e) {\n                // nothing we can do here :-(\n            }\n        }\n    }\n\n    /**\n     * There *must* be a better place to put this without creating a helpers class just for it\n     */\n    private static ClassLoader selectClassLoader()\n    {\n        ClassLoader loader;\n        if (Thread.currentThread().getContextClassLoader() != null) {\n            loader = Thread.currentThread().getContextClassLoader();\n        }\n        else {\n            loader = ClasspathStatementLocator.class.getClassLoader();\n        }\n        return loader;\n    }\n\n    private static boolean isComment(final String line)\n    {\n        return line.startsWith(\"#\") || line.startsWith(\"--\") || line.startsWith(\"//\");\n    }\n\n    private static final String SEP = \"/\"; // *Not* System.getProperty(\"file.separator\"), which breaks in jars\n\n    private static String mungify(String path)\n    {\n        return path.replaceAll(\"\\\\.\", Matcher.quoteReplacement(SEP));\n    }\n\n\n    // (scs) Logic copied from commons-lang3 3.1 with minor edits, per discussion on commit 023a14ade2d33bf8ccfa0f68294180455233ad52\n    private static String stripStart(String str)\n    {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return \"\";\n        }\n        int start = 0;\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        return str.substring(start);\n    }\n\n    private static String left(String str, int len)\n    {\n        if (str == null || len < 0) {\n            return \"\";\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    private static final SqlScriptParser SQL_SCRIPT_PARSER = new SqlScriptParser(new SqlScriptParser.TokenHandler() {\n        @Override\n        public void handle(Token t, StringBuilder sb) {\n            sb.append(t.getText());\n        }\n    });\n}\n","lineNo":92}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Function;\n\nimport org.jdbi.v3.exception.UnableToCreateStatementException;\nimport org.jdbi.v3.exception.UnableToExecuteStatementException;\nimport org.jdbi.v3.mapper.ColumnMapper;\nimport org.jdbi.v3.mapper.RowMapper;\nimport org.jdbi.v3.rewriter.RewrittenStatement;\nimport org.jdbi.v3.statement.StatementBuilder;\nimport org.jdbi.v3.statement.StatementCustomizer;\nimport org.jdbi.v3.util.GenericType;\nimport org.jdbi.v3.util.SingleColumnMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Represents a prepared batch statement. That is, a sql statement compiled as a prepared\n * statement, and then executed multiple times in a single batch. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch>\n{\n    private static final Logger LOG = LoggerFactory.getLogger(PreparedBatch.class);\n\n    private final List<PreparedBatchPart> parts = new ArrayList<>();\n    private Binding currentBinding;\n\n    PreparedBatch(JdbiConfig config,\n                  Handle handle,\n                  StatementBuilder statementBuilder,\n                  String sql,\n                  StatementContext ctx,\n                  Collection<StatementCustomizer> statementCustomizers)\n    {\n        super(config, new Binding(), handle, statementBuilder, sql, ctx, statementCustomizers);\n        this.currentBinding = new Binding();\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    @Override\n    public PreparedBatch define(String key, Object value)\n    {\n        getContext().setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Adds all key/value pairs in the Map to the {@link StatementContext}.\n     *\n     * @param values containing key/value pairs.\n     * @return this\n     */\n    @Override\n    public PreparedBatch define(final Map<String, ?> values)\n    {\n        if (values != null) {\n            for (Map.Entry<String, ?> entry: values.entrySet())\n            {\n                getContext().setAttribute(entry.getKey(), entry.getValue());\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        return (int[]) internalBatchExecute(null, null);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final RowMapper<GeneratedKeyType> mapper) {\n        return (GeneratedKeys<GeneratedKeyType>) internalBatchExecute(results ->\n                new GeneratedKeys<>(mapper,\n                                    PreparedBatch.this,\n                                    results,\n                                    getContext()), null);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final RowMapper<GeneratedKeyType> mapper,\n                                                                                     String... columnNames) {\n        return (GeneratedKeys<GeneratedKeyType>) internalBatchExecute(results ->\n                new GeneratedKeys<>(mapper,\n                        PreparedBatch.this,\n                        results,\n                        getContext()), columnNames);\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final ColumnMapper<GeneratedKeyType> mapper) {\n        return executeAndGenerateKeys(new SingleColumnMapper<>(mapper));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(GenericType<GeneratedKeyType> generatedKeyType) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(Class<GeneratedKeyType> generatedKeyType) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(Class<GeneratedKeyType> generatedKeyType,\n                                                                                     String... columnNames) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType), columnNames);\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(ColumnMapper<GeneratedKeyType> mapper,\n                                                                                     String columnName) {\n        return executeAndGenerateKeys(new SingleColumnMapper<>(mapper, columnName), new String[] { columnName });\n    }\n\n    private <Result> Object internalBatchExecute(Function<PreparedStatement, Result> munger, String[] columnNames) {\n        boolean generateKeys = munger != null;\n        // short circuit empty batch\n        if (parts.size() == 0) {\n            if (generateKeys) {\n                throw new IllegalArgumentException(\"Unable generate keys for a not prepared batch\");\n            }\n            return new int[]{};\n        }\n\n        PreparedBatchPart current = parts.get(0);\n        final String my_sql ;\n        try {\n            my_sql = getStatementLocator().locate(getSql(), getContext());\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(String.format(\"Exception while locating statement for [%s]\",\n                                                                     getSql()), e, getContext());\n        }\n        final RewrittenStatement rewritten = getRewriter().rewrite(my_sql, current.getParams(), getContext());\n        PreparedStatement stmt;\n        try {\n            try {\n                Connection connection = getHandle().getConnection();\n                if (generateKeys) {\n                    if (columnNames != null) {\n                        stmt = connection.prepareStatement(rewritten.getSql(), columnNames);\n                    } else  {\n                        stmt = connection.prepareStatement(rewritten.getSql(), Statement.RETURN_GENERATED_KEYS);\n                    }\n                } else {\n                    stmt = connection.prepareStatement(rewritten.getSql(), Statement.NO_GENERATED_KEYS);\n                }\n                addCleanable(Cleanables.forStatement(stmt));\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n\n            try {\n                for (PreparedBatchPart part : parts) {\n                    rewritten.bind(part.getParams(), stmt);\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, getContext());\n            }\n\n            beforeExecution(stmt);\n\n            try {\n                final long start = System.nanoTime();\n                final int[] rs =  stmt.executeBatch();\n                final long elapsedTime = System.nanoTime() - start;\n                LOG.trace(\"Prepared batch of {} parts executed in {}ms\", parts.size(), elapsedTime / 1000000L, rewritten.getSql());\n                getTimingCollector().collect(elapsedTime, getContext());\n\n                afterExecution(stmt);\n\n                return generateKeys ? munger.apply(stmt) : rs;\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, getContext());\n            }\n        }\n        finally {\n            try {\n                if (!generateKeys) {\n                    cleanup();\n                }\n            }\n            finally {\n                this.parts.clear();\n            }\n        }\n    }\n\n    /**\n     * Add a statement (part) to this batch. You'll need to bindBinaryStream any arguments to the\n     * part.\n     *\n     * @return A part which can be used to bindBinaryStream parts to the statement\n     */\n    public PreparedBatchPart add()\n    {\n        PreparedBatchPart part = new PreparedBatchPart(config,\n                                                       this.currentBinding,\n                                                       this,\n                                                       getHandle(),\n                                                       getStatementBuilder(),\n                                                       getSql(),\n                                                       getContext());\n        parts.add(part);\n        this.currentBinding = new Binding();\n        return part;\n    }\n\n    public PreparedBatch add(Object... args)\n    {\n        PreparedBatchPart part = add();\n        for (int i = 0; i < args.length; ++i) {\n            part.bind(i, args[i]);\n        }\n        return this;\n    }\n\n\n    /**\n     * Create a new batch part by binding values looked up in <code>args<\/code> to\n     * named parameters on the statement.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     *\n     * @return the new batch part\n     */\n    public PreparedBatchPart add(Map<String, ?> args)\n    {\n        PreparedBatchPart part = add();\n        part.bindFromMap(args);\n        return part;\n    }\n\n    /**\n     * @return the number of statements which are in this batch\n     */\n    public int size()\n    {\n        return parts.size();\n    }\n\n    @Override\n    protected Binding getParams()\n    {\n        return this.currentBinding;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Function;\n\nimport org.jdbi.v3.exception.UnableToCreateStatementException;\nimport org.jdbi.v3.exception.UnableToExecuteStatementException;\nimport org.jdbi.v3.mapper.ColumnMapper;\nimport org.jdbi.v3.mapper.RowMapper;\nimport org.jdbi.v3.rewriter.RewrittenStatement;\nimport org.jdbi.v3.statement.StatementBuilder;\nimport org.jdbi.v3.statement.StatementCustomizer;\nimport org.jdbi.v3.util.GenericType;\nimport org.jdbi.v3.util.SingleColumnMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Represents a prepared batch statement. That is, a sql statement compiled as a prepared\n * statement, and then executed multiple times in a single batch. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n */\npublic class PreparedBatch extends SqlStatement<PreparedBatch>\n{\n    private static final Logger LOG = LoggerFactory.getLogger(PreparedBatch.class);\n\n    private final List<PreparedBatchPart> parts = new ArrayList<>();\n    private Binding currentBinding;\n\n    PreparedBatch(JdbiConfig config,\n                  Handle handle,\n                  StatementBuilder statementBuilder,\n                  String sql,\n                  StatementContext ctx,\n                  Collection<StatementCustomizer> statementCustomizers)\n    {\n        super(config, new Binding(), handle, statementBuilder, sql, ctx, statementCustomizers);\n        this.currentBinding = new Binding();\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    @Override\n    public PreparedBatch define(String key, Object value)\n    {\n        getContext().setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Adds all key/value pairs in the Map to the {@link StatementContext}.\n     *\n     * @param values containing key/value pairs.\n     * @return this\n     */\n    @Override\n    public PreparedBatch define(final Map<String, ?> values)\n    {\n        if (values != null) {\n            for (Map.Entry<String, ?> entry: values.entrySet())\n            {\n                getContext().setAttribute(entry.getKey(), entry.getValue());\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute() {\n        return (int[]) internalBatchExecute(null, null);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final RowMapper<GeneratedKeyType> mapper) {\n        return (GeneratedKeys<GeneratedKeyType>) internalBatchExecute(results ->\n                new GeneratedKeys<>(mapper,\n                                    PreparedBatch.this,\n                                    results,\n                                    getContext()), null);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final RowMapper<GeneratedKeyType> mapper,\n                                                                                     String... columnNames) {\n        return (GeneratedKeys<GeneratedKeyType>) internalBatchExecute(results ->\n                new GeneratedKeys<>(mapper,\n                        PreparedBatch.this,\n                        results,\n                        getContext()), columnNames);\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(final ColumnMapper<GeneratedKeyType> mapper) {\n        return executeAndGenerateKeys(new SingleColumnMapper<>(mapper));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(GenericType<GeneratedKeyType> generatedKeyType) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(Class<GeneratedKeyType> generatedKeyType) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType));\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(Class<GeneratedKeyType> generatedKeyType,\n                                                                                     String... columnNames) {\n        return executeAndGenerateKeys(rowMapperForType(generatedKeyType), columnNames);\n    }\n\n    public <GeneratedKeyType> GeneratedKeys<GeneratedKeyType> executeAndGenerateKeys(ColumnMapper<GeneratedKeyType> mapper,\n                                                                                     String columnName) {\n        return executeAndGenerateKeys(new SingleColumnMapper<>(mapper, columnName), new String[] { columnName });\n    }\n\n    private <Result> Object internalBatchExecute(Function<PreparedStatement, Result> munger, String[] columnNames) {\n        boolean generateKeys = munger != null;\n        // short circuit empty batch\n        if (parts.size() == 0) {\n            if (generateKeys) {\n                throw new IllegalArgumentException(\"Unable generate keys for a not prepared batch\");\n            }\n            return new int[]{};\n        }\n\n        PreparedBatchPart current = parts.get(0);\n        final String rawSql = getSql();\n        final RewrittenStatement rewritten = getRewriter().rewrite(rawSql, current.getParams(), getContext());\n        PreparedStatement stmt;\n        try {\n            try {\n                Connection connection = getHandle().getConnection();\n                if (generateKeys) {\n                    if (columnNames != null) {\n                        stmt = connection.prepareStatement(rewritten.getSql(), columnNames);\n                    } else  {\n                        stmt = connection.prepareStatement(rewritten.getSql(), Statement.RETURN_GENERATED_KEYS);\n                    }\n                } else {\n                    stmt = connection.prepareStatement(rewritten.getSql(), Statement.NO_GENERATED_KEYS);\n                }\n                addCleanable(Cleanables.forStatement(stmt));\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, getContext());\n            }\n\n\n            try {\n                for (PreparedBatchPart part : parts) {\n                    rewritten.bind(part.getParams(), stmt);\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, getContext());\n            }\n\n            beforeExecution(stmt);\n\n            try {\n                final long start = System.nanoTime();\n                final int[] rs =  stmt.executeBatch();\n                final long elapsedTime = System.nanoTime() - start;\n                LOG.trace(\"Prepared batch of {} parts executed in {}ms\", parts.size(), elapsedTime / 1000000L, rewritten.getSql());\n                getTimingCollector().collect(elapsedTime, getContext());\n\n                afterExecution(stmt);\n\n                return generateKeys ? munger.apply(stmt) : rs;\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, getContext());\n            }\n        }\n        finally {\n            try {\n                if (!generateKeys) {\n                    cleanup();\n                }\n            }\n            finally {\n                this.parts.clear();\n            }\n        }\n    }\n\n    /**\n     * Add a statement (part) to this batch. You'll need to bindBinaryStream any arguments to the\n     * part.\n     *\n     * @return A part which can be used to bindBinaryStream parts to the statement\n     */\n    public PreparedBatchPart add()\n    {\n        PreparedBatchPart part = new PreparedBatchPart(config,\n                                                       this.currentBinding,\n                                                       this,\n                                                       getHandle(),\n                                                       getStatementBuilder(),\n                                                       getSql(),\n                                                       getContext());\n        parts.add(part);\n        this.currentBinding = new Binding();\n        return part;\n    }\n\n    public PreparedBatch add(Object... args)\n    {\n        PreparedBatchPart part = add();\n        for (int i = 0; i < args.length; ++i) {\n            part.bind(i, args[i]);\n        }\n        return this;\n    }\n\n\n    /**\n     * Create a new batch part by binding values looked up in <code>args<\/code> to\n     * named parameters on the statement.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     *\n     * @return the new batch part\n     */\n    public PreparedBatchPart add(Map<String, ?> args)\n    {\n        PreparedBatchPart part = add();\n        part.bindFromMap(args);\n        return part;\n    }\n\n    /**\n     * @return the number of statements which are in this batch\n     */\n    public int size()\n    {\n        return parts.size();\n    }\n\n    @Override\n    protected Binding getParams()\n    {\n        return this.currentBinding;\n    }\n}\n","lineNo":153}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport org.jdbi.v3.Handle;\nimport org.jdbi.v3.extension.ExtensionFactory;\nimport org.jdbi.v3.sqlobject.mixins.GetHandle;\nimport org.jdbi.v3.sqlobject.mixins.Transactional;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\n\npublic enum SqlObjectFactory implements ExtensionFactory<SqlObject> {\n    INSTANCE;\n\n    private static final MethodInterceptor NO_OP = (proxy, method, args, methodProxy) -> null;\n\n    private final Map<Method, Handler> mixinHandlers = new HashMap<>();\n    private final ConcurrentMap<Class<?>, Map<Method, Handler>> handlersCache = new ConcurrentHashMap<>();\n    private final ConcurrentMap<Class<?>, Factory> factories = new ConcurrentHashMap<>();\n\n    SqlObjectFactory() {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n    }\n\n    @Override\n    public SqlObject createConfig() {\n        return new SqlObject();\n    }\n\n    @Override\n    public boolean accepts(Class<?> extensionType) {\n        if (GetHandle.class.isAssignableFrom(extensionType) ||\n                Transactional.class.isAssignableFrom(extensionType)) {\n            return true;\n        }\n\n        return Stream.of(extensionType.getMethods())\n                .flatMap(m -> Stream.of(m.getAnnotations()))\n                .anyMatch(a -> a.annotationType().isAnnotationPresent(SqlMethodAnnotation.class));\n    }\n\n    /**\n     * Create a sql object of the specified type bound to this handle. Any state changes to the handle, or the sql\n     * object, such as transaction status, closing it, etc, will apply to both the object and the handle.\n     *\n     * @param extensionType the type of sql object to create\n     * @param handle the Handle instance to attach ths sql object to\n     * @return the new sql object bound to this handle\n     */\n    @Override\n    public <E> E attach(Class<E> extensionType, SqlObject config, Supplier<Handle> handle) {\n        Factory f = factories.computeIfAbsent(extensionType, type -> {\n            Enhancer e = new Enhancer();\n            e.setClassLoader(extensionType.getClassLoader());\n\n            List<Class<?>> interfaces = new ArrayList<>();\n            if (extensionType.isInterface()) {\n                interfaces.add(extensionType);\n            }\n            else {\n                e.setSuperclass(extensionType);\n            }\n            e.setInterfaces(interfaces.toArray(new Class[interfaces.size()]));\n            e.setCallback(NO_OP);\n\n            return (Factory) e.create();\n        });\n\n        Map<Method, Handler> handlers = buildHandlersFor(extensionType, config);\n        MethodInterceptor interceptor = createMethodInterceptor(handlers, handle);\n        return extensionType.cast(f.newInstance(interceptor));\n    }\n\n    private Map<Method, Handler> buildHandlersFor(Class<?> sqlObjectType, SqlObject config) {\n        return handlersCache.computeIfAbsent(sqlObjectType, type -> {\n\n            final Map<Method, Handler> handlers = new HashMap<>();\n            for (Method method : sqlObjectType.getMethods()) {\n                Optional<? extends Class<? extends HandlerFactory>> factoryClass = Stream.of(method.getAnnotations())\n                        .map(a -> a.annotationType().getAnnotation(SqlMethodAnnotation.class))\n                        .filter(Objects::nonNull)\n                        .map(a -> a.value())\n                        .findFirst();\n\n                if (factoryClass.isPresent()) {\n                    HandlerFactory factory = buildFactory(factoryClass.get());\n                    Handler handler = factory.buildHandler(sqlObjectType, method, config);\n                    handlers.put(method, handler);\n                }\n                else if (mixinHandlers.containsKey(method)) {\n                    handlers.put(method, mixinHandlers.get(method));\n                }\n                else {\n                    handlers.put(method, new PassThroughHandler());\n                }\n            }\n\n            handlers.putAll(EqualsHandler.handler());\n            handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n            handlers.putAll(HashCodeHandler.handler());\n            handlers.putAll(FinalizeHandler.handlerFor(sqlObjectType));\n\n            return handlers;\n        });\n    }\n\n    private HandlerFactory buildFactory(Class<? extends HandlerFactory> factoryClazz) {\n        HandlerFactory factory;\n        try {\n            factory = factoryClazz.newInstance();\n        } catch (InstantiationException | IllegalAccessException e) {\n            throw new IllegalStateException(\"Factory class \" + factoryClazz + \"cannot be instantiated\", e);\n        }\n        return factory;\n    }\n\n    private MethodInterceptor createMethodInterceptor(Map<Method, Handler> handlers, Supplier<Handle> handle) {\n        return (proxy, method, args, methodProxy) -> {\n            Handler handler = handlers.get(method);\n\n            // If there is no handler, pretend we are just an Object and don't open a connection (Issue #82)\n            if (handler == null) {\n                return methodProxy.invokeSuper(proxy, args);\n            }\n\n            return handler.invoke(handle, proxy, args, method);\n        };\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\n\nimport org.jdbi.v3.Handle;\nimport org.jdbi.v3.extension.ExtensionFactory;\nimport org.jdbi.v3.sqlobject.mixins.GetHandle;\nimport org.jdbi.v3.sqlobject.mixins.Transactional;\n\npublic enum SqlObjectFactory implements ExtensionFactory<SqlObject> {\n    INSTANCE;\n\n    private static final MethodInterceptor NO_OP = (proxy, method, args, methodProxy) -> null;\n\n    private final Map<Method, Handler> mixinHandlers = new HashMap<>();\n    private final ConcurrentMap<Class<?>, Map<Method, Handler>> handlersCache = new ConcurrentHashMap<>();\n    private final ConcurrentMap<Class<?>, Factory> factories = new ConcurrentHashMap<>();\n    private final ConcurrentMap<Class<? extends SqlObjectConfigurerFactory>, SqlObjectConfigurerFactory>\n            configurerFactories = new ConcurrentHashMap<>();\n\n    SqlObjectFactory() {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n    }\n\n    @Override\n    public SqlObject createConfig() {\n        return new SqlObject();\n    }\n\n    @Override\n    public boolean accepts(Class<?> extensionType) {\n        if (GetHandle.class.isAssignableFrom(extensionType) ||\n                Transactional.class.isAssignableFrom(extensionType)) {\n            return true;\n        }\n\n        return Stream.of(extensionType.getMethods())\n                .flatMap(m -> Stream.of(m.getAnnotations()))\n                .anyMatch(a -> a.annotationType().isAnnotationPresent(SqlMethodAnnotation.class));\n    }\n\n    /**\n     * Create a sql object of the specified type bound to this handle. Any state changes to the handle, or the sql\n     * object, such as transaction status, closing it, etc, will apply to both the object and the handle.\n     *\n     * @param extensionType the type of sql object to create\n     * @param handle the Handle instance to attach ths sql object to\n     * @return the new sql object bound to this handle\n     */\n    @Override\n    public <E> E attach(Class<E> extensionType, SqlObject config, Supplier<Handle> handle) {\n        Factory f = factories.computeIfAbsent(extensionType, type -> {\n            Enhancer e = new Enhancer();\n            e.setClassLoader(extensionType.getClassLoader());\n\n            List<Class<?>> interfaces = new ArrayList<>();\n            if (extensionType.isInterface()) {\n                interfaces.add(extensionType);\n            }\n            else {\n                e.setSuperclass(extensionType);\n            }\n            e.setInterfaces(interfaces.toArray(new Class[interfaces.size()]));\n            e.setCallback(NO_OP);\n\n            return (Factory) e.create();\n        });\n\n        forEachConfigurerFactory(extensionType, (factory, annotation) ->\n                factory.createForType(annotation, extensionType).apply(config));\n\n        Map<Method, Handler> handlers = buildHandlersFor(extensionType, config);\n        MethodInterceptor interceptor = createMethodInterceptor(handlers, handle);\n        return extensionType.cast(f.newInstance(interceptor));\n    }\n\n    private Map<Method, Handler> buildHandlersFor(Class<?> sqlObjectType, SqlObject config) {\n        return handlersCache.computeIfAbsent(sqlObjectType, type -> {\n\n            final Map<Method, Handler> handlers = new HashMap<>();\n            for (Method method : sqlObjectType.getMethods()) {\n                // FIXME will applying configurers here and caching config create problems?\n                SqlObject methodConfig = config.createCopy();\n                forEachConfigurerFactory(method, (factory, annotation) ->\n                        factory.createForMethod(annotation, sqlObjectType, method).apply(methodConfig));\n\n                Optional<? extends Class<? extends HandlerFactory>> factoryClass = Stream.of(method.getAnnotations())\n                        .map(a -> a.annotationType().getAnnotation(SqlMethodAnnotation.class))\n                        .filter(Objects::nonNull)\n                        .map(a -> a.value())\n                        .findFirst();\n\n                if (factoryClass.isPresent()) {\n                    HandlerFactory factory = buildFactory(factoryClass.get());\n                    Handler handler = factory.buildHandler(sqlObjectType, method, methodConfig);\n                    handlers.put(method, handler);\n                }\n                else if (mixinHandlers.containsKey(method)) {\n                    handlers.put(method, mixinHandlers.get(method));\n                }\n                else {\n                    handlers.put(method, new PassThroughHandler());\n                }\n            }\n\n            handlers.putAll(EqualsHandler.handler());\n            handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n            handlers.putAll(HashCodeHandler.handler());\n            handlers.putAll(FinalizeHandler.handlerFor(sqlObjectType));\n\n            return handlers;\n        });\n    }\n\n    private HandlerFactory buildFactory(Class<? extends HandlerFactory> factoryClazz) {\n        HandlerFactory factory;\n        try {\n            factory = factoryClazz.newInstance();\n        } catch (InstantiationException | IllegalAccessException e) {\n            throw new IllegalStateException(\"Factory class \" + factoryClazz + \"cannot be instantiated\", e);\n        }\n        return factory;\n    }\n\n    private MethodInterceptor createMethodInterceptor(Map<Method, Handler> handlers, Supplier<Handle> handle) {\n        return (proxy, method, args, methodProxy) -> {\n            Handler handler = handlers.get(method);\n\n            // If there is no handler, pretend we are just an Object and don't open a connection (Issue #82)\n            if (handler == null) {\n                return methodProxy.invokeSuper(proxy, args);\n            }\n\n            return handler.invoke(handle, proxy, args, method);\n        };\n    }\n\n    public void forEachConfigurerFactory(AnnotatedElement element, BiConsumer<SqlObjectConfigurerFactory, Annotation> consumer) {\n        Stream.of(element.getAnnotations())\n                .filter(a -> a.annotationType().isAnnotationPresent(SqlObjectConfiguringAnnotation.class))\n                .forEach(a -> {\n                    SqlObjectConfiguringAnnotation meta = a.annotationType()\n                            .getAnnotation(SqlObjectConfiguringAnnotation.class);\n\n                    consumer.accept(getConfigurerFactory(meta.value()), a);\n                });\n    }\n\n    public SqlObjectConfigurerFactory getConfigurerFactory(Class<? extends SqlObjectConfigurerFactory> factoryClass) {\n        return configurerFactories.computeIfAbsent(factoryClass, c -> {\n            try {\n                return c.newInstance();\n            } catch (InstantiationException | IllegalAccessException e) {\n                throw new IllegalStateException(\"Unable to instantiate configurer factory class \" + factoryClass, e);\n            }\n        });\n    }\n}\n","lineNo":114}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nclass SqlAnnotations {\n    static String getSql(SqlCall q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nclass SqlAnnotations {\n    static String getSql(SqlCall q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n}\n","lineNo":20}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nclass SqlAnnotations {\n    static String getSql(SqlCall q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nclass SqlAnnotations {\n    static String getSql(SqlCall q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n}\n","lineNo":29}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nclass SqlAnnotations {\n    static String getSql(SqlCall q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nclass SqlAnnotations {\n    static String getSql(SqlCall q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n}\n","lineNo":38}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nclass SqlAnnotations {\n    static String getSql(SqlCall q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m) {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        } else {\n            return q.value();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nclass SqlAnnotations {\n    static String getSql(SqlCall q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m) {\n        String value = q.value();\n        if (value.isEmpty()) {\n            return m.getName();\n        } else {\n            return value;\n        }\n    }\n}\n","lineNo":47}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.pg;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.UUID;\n\nimport org.jdbi.v3.Handle;\nimport org.jdbi.v3.sqlobject.SqlQuery;\nimport org.jdbi.v3.sqlobject.SqlUpdate;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\n\n@Ignore // XXX: this doesn't work yet!\npublic class TestSqlArrays {\n    private static final String U_SELECT = \"SELECT u FROM uuids\";\n    private static final String U_INSERT = \"INSERT INTO uuids VALUES(:uuids, NULL)\";\n    private static final String I_SELECT = \"SELECT i FROM uuids\";\n    private static final String I_INSERT = \"INSERT INTO uuids VALUES(NULL, :ints)\";\n\n    @Rule\n    public PostgresDbRule db = new PostgresDbRule();\n    private Handle h;\n    private ArrayObject ao;\n\n    @Before\n    public void setUp() {\n        h = db.getSharedHandle();\n        h.execute(\"CREATE TABLE uuids (u UUID[], i INT[])\");\n        ao = h.attach(ArrayObject.class);\n    }\n\n    private final UUID[] testUuids = new UUID[] {\n        UUID.randomUUID(), UUID.randomUUID(), UUID.randomUUID(), UUID.randomUUID(), UUID.randomUUID()\n    };\n\n    private final int[] testInts = new int[] {\n        5, 4, -6, 1, 9, Integer.MAX_VALUE, Integer.MIN_VALUE\n    };\n\n    @Test\n    public void testUuidArray() throws Exception {\n        ao.insertUuidArray(testUuids);\n        assertArrayEquals(testUuids, ao.fetchUuidArray());\n    }\n\n    @Test\n    public void testUuidList() throws Exception {\n        ao.insertUuidList(Arrays.asList(testUuids));\n        assertEquals(Arrays.asList(testUuids), ao.fetchUuidList());\n    }\n\n    @Test\n    public void testIntArray() throws Exception {\n        ao.insertIntArray(testInts);\n        assertArrayEquals(testInts, ao.fetchIntArray());\n    }\n\n    @Test\n    public void testIntList() throws Exception {\n        List<Integer> testIntList = new ArrayList<Integer>();\n        Arrays.stream(testInts).forEach(testIntList::add);\n        ao.insertIntList(testIntList);\n        assertEquals(testIntList, ao.fetchIntList());\n    }\n\n    interface ArrayObject {\n        @SqlQuery(U_SELECT)\n        UUID[] fetchUuidArray();\n\n        @SqlUpdate(U_INSERT)\n        void insertUuidArray(UUID[] u);\n\n        @SqlQuery(U_SELECT)\n        List<UUID> fetchUuidList();\n\n        @SqlUpdate(U_INSERT)\n        void insertUuidList(List<UUID> u);\n\n\n        @SqlQuery(I_SELECT)\n        int[] fetchIntArray();\n\n        @SqlQuery(I_SELECT)\n        Integer[] fetchBoxedIntArray();\n\n        @SqlUpdate(I_INSERT)\n        void insertIntArray(int[] u);\n\n        @SqlQuery(I_SELECT)\n        List<Integer> fetchIntList();\n\n        @SqlUpdate(I_INSERT)\n        void insertIntList(List<Integer> u);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.pg;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.stream.IntStream;\nimport org.jdbi.v3.Handle;\nimport org.jdbi.v3.sqlobject.Bind;\nimport org.jdbi.v3.sqlobject.SqlQuery;\nimport org.jdbi.v3.sqlobject.SqlUpdate;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class TestSqlArrays {\n    private static final String U_SELECT = \"SELECT u FROM uuids\";\n    private static final String U_INSERT = \"INSERT INTO uuids VALUES(:uuids, NULL)\";\n    private static final String I_SELECT = \"SELECT i FROM uuids\";\n    private static final String I_INSERT = \"INSERT INTO uuids VALUES(NULL, :ints)\";\n\n    @Rule\n    public PostgresDbRule db = new PostgresDbRule();\n    private Handle h;\n    private ArrayObject ao;\n\n    @Before\n    public void setUp() {\n        h = db.getSharedHandle();\n        h.execute(\"CREATE TABLE uuids (u UUID[], i INT[])\");\n        ao = h.attach(ArrayObject.class);\n    }\n\n    private final UUID[] testUuids = new UUID[] {\n        UUID.randomUUID(), UUID.randomUUID(), UUID.randomUUID(), UUID.randomUUID(), UUID.randomUUID()\n    };\n\n    private final int[] testInts = new int[] {\n        5, 4, -6, 1, 9, Integer.MAX_VALUE, Integer.MIN_VALUE\n    };\n\n    @Test\n    public void testUuidArray() throws Exception {\n        ao.insertUuidArray(testUuids);\n        assertArrayEquals(testUuids, ao.fetchUuidArray());\n    }\n\n    @Test\n    @Ignore(\"Inserting lists to arrays is not supported\")\n    public void testUuidList() throws Exception {\n        ao.insertUuidList(Arrays.asList(testUuids));\n        assertEquals(Arrays.asList(testUuids), ao.fetchUuidList());\n    }\n\n    @Test\n    public void testIntArray() throws Exception {\n        ao.insertIntArray(testInts);\n        int[] actuals = ao.fetchIntArray();\n        assertArrayEquals(testInts, actuals);\n    }\n\n    @Test\n    public void testBoxedIntArray() throws Exception {\n        Integer[] source = IntStream.of(testInts).mapToObj(Integer::valueOf).toArray(Integer[]::new);\n        ao.insertBoxedIntArray(source);\n        Integer[] actuals = ao.fetchBoxedIntArray();\n        assertArrayEquals(source, actuals);\n    }\n\n    @Test\n    @Ignore(\"Inserting lists to arrays is not supported\")\n    public void testIntList() throws Exception {\n        List<Integer> testIntList = new ArrayList<Integer>();\n        Arrays.stream(testInts).forEach(testIntList::add);\n        ao.insertIntList(testIntList);\n        assertEquals(testIntList, ao.fetchIntList());\n    }\n\n    interface ArrayObject {\n        @SqlQuery(U_SELECT)\n        UUID[] fetchUuidArray();\n\n        @SqlUpdate(U_INSERT)\n        void insertUuidArray(UUID[] uuids);\n\n        @SqlQuery(U_SELECT)\n        List<UUID> fetchUuidList();\n\n        @SqlUpdate(U_INSERT)\n        void insertUuidList(List<UUID> u);\n\n\n        @SqlQuery(I_SELECT)\n        int[] fetchIntArray();\n\n        @SqlQuery(I_SELECT)\n        Integer[] fetchBoxedIntArray();\n\n        @SqlUpdate(I_INSERT)\n        void insertIntArray(int[] ints);\n\n        @SqlUpdate(I_INSERT)\n        void insertBoxedIntArray(Integer[] ints);\n\n        @SqlQuery(I_SELECT)\n        List<Integer> fetchIntList();\n\n        @SqlUpdate(I_INSERT)\n        void insertIntList(List<Integer> u);\n    }\n}\n","lineNo":75}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.pg;\n\nimport java.lang.reflect.Type;\nimport java.util.Collections;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.UUID;\n\nimport org.jdbi.v3.StatementContext;\nimport org.jdbi.v3.Types;\nimport org.jdbi.v3.tweak.Argument;\nimport org.jdbi.v3.tweak.ArgumentFactory;\n\npublic class SqlArrayArgumentFactory implements ArgumentFactory {\n\n    @Override\n    public Optional<Argument> build(Type type, Object value, StatementContext ctx) {\n        return Types.getErasedType(type).isArray() ?\n                Optional.of(new ArrayArgument(guessSqlType((Object[]) value), value)) : Optional.empty();\n    }\n\n    private static final Map<Class<?>, String> BEST_GUESS;\n    static {\n        final Map<Class<?>, String> map = new IdentityHashMap<>();\n        map.put(int.class, \"integer\");\n        map.put(long.class, \"bigint\");\n        map.put(String.class, \"varchar\");\n        map.put(UUID.class, \"uuid\");\n        map.put(float.class, \"real\");\n        map.put(double.class, \"double precision\");\n        BEST_GUESS = Collections.unmodifiableMap(map);\n    }\n\n    /**\n     * Look at a Java array and attempt to determine an appropriate\n     * SQL type to pass to the driver.\n     */\n    static final String guessSqlType(Object[] array) {\n        String guess = BEST_GUESS.get(array.getClass().getComponentType());\n        if (array.length == 0 || guess == null) {\n            return \"varchar\";\n        }\n        return guess;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.pg;\n\nimport java.lang.reflect.Type;\nimport java.util.Collections;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.UUID;\n\nimport org.jdbi.v3.StatementContext;\nimport org.jdbi.v3.Types;\nimport org.jdbi.v3.tweak.Argument;\nimport org.jdbi.v3.tweak.ArgumentFactory;\n\npublic class SqlArrayArgumentFactory implements ArgumentFactory {\n\n    @Override\n    public Optional<Argument> build(Type type, Object value, StatementContext ctx) {\n        return Types.getErasedType(type).isArray() ?\n                Optional.of(ArrayArgument.fromAnyArray(guessSqlType(value), value)) :\n                    Optional.empty();\n    }\n\n    private static final Map<Class<?>, String> BEST_GUESS;\n    static {\n        final Map<Class<?>, String> map = new IdentityHashMap<>();\n        map.put(int.class, \"integer\");\n        map.put(long.class, \"bigint\");\n        map.put(String.class, \"varchar\");\n        map.put(UUID.class, \"uuid\");\n        map.put(float.class, \"real\");\n        map.put(double.class, \"double precision\");\n        BEST_GUESS = Collections.unmodifiableMap(map);\n    }\n\n    /**\n     * Look at a Java array and attempt to determine an appropriate\n     * SQL type to pass to the driver.\n     */\n    static final String guessSqlType(Object array) {\n        final Class<?> klass = array.getClass();\n        if (!klass.isArray()) {\n            throw new IllegalArgumentException(\"not an array: \" + klass);\n        }\n        String guess = BEST_GUESS.get(klass.getComponentType());\n        if (((Object[]) array).length == 0 || guess == null) {\n            return \"varchar\";\n        }\n        return guess;\n    }\n}\n","lineNo":54}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.jdbi.v3.exceptions.UnableToCreateStatementException;\nimport org.jdbi.v3.tweak.RewrittenStatement;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\npublic class TestColonStatementRewriter\n{\n    private ColonPrefixNamedParamStatementRewriter rw;\n\n    @Before\n    public void setUp() throws Exception\n    {\n        this.rw = new ColonPrefixNamedParamStatementRewriter();\n    }\n\n    private RewrittenStatement rewrite(String sql)\n    {\n        return rw.rewrite(sql,\n                new Binding(),\n                new StatementContext());\n    }\n\n    @Test\n    public void testNewlinesOkay() throws Exception\n    {\n        RewrittenStatement rws = rewrite(\"select * from something\\n where id = :id\");\n        assertEquals(\"select * from something\\n where id = ?\", rws.getSql());\n    }\n\n    @Test\n    public void testOddCharacters() throws Exception\n    {\n        RewrittenStatement rws = rewrite(\"~* :boo ':nope' _%&^& *@ :id\");\n        assertEquals(\"~* ? ':nope' _%&^& *@ ?\", rws.getSql());\n    }\n\n    @Test\n    public void testNumbers() throws Exception\n    {\n        RewrittenStatement rws = rewrite(\":bo0 ':nope' _%&^& *@ :id\");\n        assertEquals(\"? ':nope' _%&^& *@ ?\", rws.getSql());\n    }\n\n    @Test\n    public void testDollarSignOkay() throws Exception\n    {\n        RewrittenStatement rws = rewrite(\"select * from v$session\");\n        assertEquals(\"select * from v$session\", rws.getSql());\n    }\n\n    @Test\n    public void testHashInColumnNameOkay() throws Exception\n    {\n       RewrittenStatement rws = rewrite(\"select column# from thetable where id = :id\");\n       assertEquals(\"select column# from thetable where id = ?\", rws.getSql());\n    }\n\n    @Test\n    public void testBacktickOkay() throws Exception\n    {\n        RewrittenStatement rws = rewrite(\"select * from `v$session\");\n        assertEquals(\"select * from `v$session\", rws.getSql());\n    }\n\n    @Test(expected = UnableToCreateStatementException.class)\n    public void testBailsOutOnInvalidInput() throws Exception\n    {\n        rewrite(\"select * from something\\n where id = :\\u0087\\u008e\\u0092\\u0097\\u009c\");\n        Assert.fail(\"Expected 'UnableToCreateStatementException' but got none\");\n    }\n\n    @Test\n    public void testCachesRewrittenStatements() throws Exception\n    {\n        final AtomicInteger ctr = new AtomicInteger(0);\n        rw = new ColonPrefixNamedParamStatementRewriter()\n        {\n            @Override\n            ParsedStatement parseString(final String sql) throws IllegalArgumentException\n            {\n                ctr.incrementAndGet();\n                return super.parseString(sql);\n            }\n        };\n\n        rewrite(\"insert into something (id, name) values (:id, :name)\");\n\n        assertEquals(1, ctr.get());\n\n        rewrite(\"insert into something (id, name) values (:id, :name)\");\n\n        assertEquals(1, ctr.get());\n    }\n\n    public void testCommentQuote() throws Exception\n    {\n        rewrite(\"select 1 /* ' \\\" */\");\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport com.google.common.collect.ImmutableMap;\n\nimport org.jdbi.v3.exceptions.UnableToCreateStatementException;\nimport org.jdbi.v3.tweak.RewrittenStatement;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\npublic class TestColonStatementRewriter\n{\n    private ColonPrefixNamedParamStatementRewriter rw;\n\n    @Before\n    public void setUp() throws Exception\n    {\n        this.rw = new ColonPrefixNamedParamStatementRewriter();\n    }\n\n    private RewrittenStatement rewrite(String sql)\n    {\n        return rewrite(sql, Collections.emptyMap());\n    }\n\n    private RewrittenStatement rewrite(String sql, Map<String, Object> attributes) {\n        StatementContext ctx = new StatementContext();\n        attributes.forEach(ctx::setAttribute);\n\n        return rw.rewrite(sql, new Binding(), ctx);\n    }\n\n    @Test\n    public void testNewlinesOkay() throws Exception\n    {\n        RewrittenStatement rws = rewrite(\"select * from something\\n where id = :id\");\n        assertEquals(\"select * from something\\n where id = ?\", rws.getSql());\n    }\n\n    @Test\n    public void testOddCharacters() throws Exception\n    {\n        RewrittenStatement rws = rewrite(\"~* :boo ':nope' _%&^& *@ :id\");\n        assertEquals(\"~* ? ':nope' _%&^& *@ ?\", rws.getSql());\n    }\n\n    @Test\n    public void testNumbers() throws Exception\n    {\n        RewrittenStatement rws = rewrite(\":bo0 ':nope' _%&^& *@ :id\");\n        assertEquals(\"? ':nope' _%&^& *@ ?\", rws.getSql());\n    }\n\n    @Test\n    public void testDollarSignOkay() throws Exception\n    {\n        RewrittenStatement rws = rewrite(\"select * from v$session\");\n        assertEquals(\"select * from v$session\", rws.getSql());\n    }\n\n    @Test\n    public void testHashInColumnNameOkay() throws Exception\n    {\n       RewrittenStatement rws = rewrite(\"select column# from thetable where id = :id\");\n       assertEquals(\"select column# from thetable where id = ?\", rws.getSql());\n    }\n\n    @Test\n    public void testBacktickOkay() throws Exception\n    {\n        RewrittenStatement rws = rewrite(\"select * from `v$session\");\n        assertEquals(\"select * from `v$session\", rws.getSql());\n    }\n\n    @Test(expected = UnableToCreateStatementException.class)\n    public void testBailsOutOnInvalidInput() throws Exception\n    {\n        rewrite(\"select * from something\\n where id = :\\u0087\\u008e\\u0092\\u0097\\u009c\");\n        Assert.fail(\"Expected 'UnableToCreateStatementException' but got none\");\n    }\n\n    @Test\n    public void testSubstitutesAttributesForAngleBracketTokens() throws Exception\n    {\n        Map<String, Object> attributes = ImmutableMap.of(\n                \"column\", \"foo\",\n                \"table\", \"bar\",\n                \"condition\", \"baz\");\n        RewrittenStatement rws = rewrite(\"select <column> from <table> where <column> = :someValue\", attributes);\n        assertEquals(\"select foo from bar where foo = ?\", rws.getSql());\n    }\n\n    @Test(expected = UnableToCreateStatementException.class)\n    public void testMissingAttributeForAngleBracketToken() throws Exception\n    {\n        rewrite(\"select * from <table>\", Collections.emptyMap());\n    }\n    \n    @Test\n    public void testCachesRewrittenStatements() throws Exception\n    {\n        final AtomicInteger ctr = new AtomicInteger(0);\n        rw = new ColonPrefixNamedParamStatementRewriter()\n        {\n            @Override\n            ParsedStatement parseString(final String sql) throws IllegalArgumentException\n            {\n                ctr.incrementAndGet();\n                return super.parseString(sql);\n            }\n        };\n\n        rewrite(\"insert into something (id, name) values (:id, :name)\");\n\n        assertEquals(1, ctr.get());\n\n        rewrite(\"insert into something (id, name) values (:id, :name)\");\n\n        assertEquals(1, ctr.get());\n    }\n\n    public void testCommentQuote() throws Exception\n    {\n        rewrite(\"select 1 /* ' \\\" */\");\n    }\n}\n","lineNo":47}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport net.sf.cglib.proxy.MethodProxy;\nimport org.skife.jdbi.v2.ConcreteStatementContext;\nimport org.skife.jdbi.v2.GeneratedKeys;\nimport org.skife.jdbi.v2.Update;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateSqlObjectException;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\n\nclass UpdateHandler extends CustomizingStatementHandler\n{\n    private final String sql;\n    private final Returner returner;\n\n    UpdateHandler(Class<?> sqlObjectType, ResolvedMethod method)\n    {\n        super(sqlObjectType, method);\n\n        if(returnTypeIsInvalid(method.getRawMember().getReturnType()) ) {\n            throw new UnableToCreateSqlObjectException(invalidReturnTypeMessage(method));\n        }\n        this.sql = SqlObject.getSql(method.getRawMember().getAnnotation(SqlUpdate.class), method.getRawMember());\n        if (method.getRawMember().isAnnotationPresent(GetGeneratedKeys.class)) {\n\n            final ResultReturnThing magic = ResultReturnThing.forType(method);\n            final GetGeneratedKeys ggk = method.getRawMember().getAnnotation(GetGeneratedKeys.class);\n            final ResultSetMapper mapper;\n            try {\n                mapper = ggk.value().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"Unable to instantiate result set mapper for statement\", e);\n            }\n            this.returner = new Returner()\n            {\n                @Override\n                public Object value(Update update, HandleDing baton)\n                {\n                    GeneratedKeys o = update.executeAndReturnGeneratedKeys(mapper, ggk.columnName());\n                    return magic.result(o, baton);\n                }\n            };\n        }\n        else {\n            this.returner = new Returner()\n            {\n                @Override\n                public Object value(Update update, HandleDing baton)\n                {\n                    return update.execute();\n                }\n            };\n        }\n    }\n\n    @Override\n    public Object invoke(HandleDing h, Object target, Object[] args, MethodProxy mp)\n    {\n        Update q = h.getHandle().createStatement(sql);\n        populateSqlObjectData((ConcreteStatementContext)q.getContext());\n        applyCustomizers(q, args);\n        applyBinders(q, args);\n        return this.returner.value(q, h);\n    }\n\n\n    private interface Returner\n    {\n        Object value(Update update, HandleDing baton);\n    }\n\n    private boolean returnTypeIsInvalid(Class<?> type) {\n        return !Number.class.isAssignableFrom(type) &&\n                !type.equals(Integer.TYPE) &&\n                !type.equals(Long.TYPE) &&\n                !type.equals(Void.TYPE);\n    }\n\n    private String invalidReturnTypeMessage(ResolvedMethod method) {\n        return method.getDeclaringType() + \".\" + method +\n                \" method is annotated with @SqlUpdate so should return void or Number but is returning: \" +\n                method.getReturnType();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport net.sf.cglib.proxy.MethodProxy;\nimport org.skife.jdbi.v2.ConcreteStatementContext;\nimport org.skife.jdbi.v2.GeneratedKeys;\nimport org.skife.jdbi.v2.Update;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateSqlObjectException;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\n\nclass UpdateHandler extends CustomizingStatementHandler\n{\n    private final String sql;\n    private final Returner returner;\n\n    UpdateHandler(Class<?> sqlObjectType, ResolvedMethod method)\n    {\n        super(sqlObjectType, method);\n\n        boolean isGetGeneratedKeys = method.getRawMember().isAnnotationPresent(GetGeneratedKeys.class);\n\n        if (!isGetGeneratedKeys && returnTypeIsInvalid(method.getRawMember().getReturnType()) ) {\n            throw new UnableToCreateSqlObjectException(invalidReturnTypeMessage(method));\n        }\n        this.sql = SqlObject.getSql(method.getRawMember().getAnnotation(SqlUpdate.class), method.getRawMember());\n\n        if (isGetGeneratedKeys) {\n\n            final ResultReturnThing magic = ResultReturnThing.forType(method);\n            final GetGeneratedKeys ggk = method.getRawMember().getAnnotation(GetGeneratedKeys.class);\n            final ResultSetMapper mapper;\n            try {\n                mapper = ggk.value().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"Unable to instantiate result set mapper for statement\", e);\n            }\n            this.returner = new Returner()\n            {\n                @Override\n                public Object value(Update update, HandleDing baton)\n                {\n                    GeneratedKeys o = update.executeAndReturnGeneratedKeys(mapper, ggk.columnName());\n                    return magic.result(o, baton);\n                }\n            };\n        }\n        else {\n            this.returner = new Returner()\n            {\n                @Override\n                public Object value(Update update, HandleDing baton)\n                {\n                    return update.execute();\n                }\n            };\n        }\n    }\n\n    @Override\n    public Object invoke(HandleDing h, Object target, Object[] args, MethodProxy mp)\n    {\n        Update q = h.getHandle().createStatement(sql);\n        populateSqlObjectData((ConcreteStatementContext)q.getContext());\n        applyCustomizers(q, args);\n        applyBinders(q, args);\n        return this.returner.value(q, h);\n    }\n\n\n    private interface Returner\n    {\n        Object value(Update update, HandleDing baton);\n    }\n\n    private boolean returnTypeIsInvalid(Class<?> type) {\n        return !Number.class.isAssignableFrom(type) &&\n                !type.equals(Integer.TYPE) &&\n                !type.equals(Long.TYPE) &&\n                !type.equals(Void.TYPE);\n    }\n\n    private String invalidReturnTypeMessage(ResolvedMethod method) {\n        return method.getDeclaringType() + \".\" + method +\n                \" method is annotated with @SqlUpdate so should return void or Number but is returning: \" +\n                method.getReturnType();\n    }\n}\n","lineNo":34}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport org.jdbi.v3.Handle;\nimport org.jdbi.v3.TransactionIsolationLevel;\nimport org.jdbi.v3.exceptions.TransactionException;\n\nclass PassThroughTransactionHandler implements Handler\n{\n    private final TransactionIsolationLevel isolation;\n\n    PassThroughTransactionHandler(Method m, Transaction tx)\n    {\n        this.isolation = tx.value();\n    }\n\n    @Override\n    public Object invoke(HandleDing ding, final Object target, final Object[] args, final MethodProxy mp)\n    {\n        ding.retain(\"pass-through-transaction\");\n        try {\n            Handle h = ding.getHandle();\n\n            if (h.isInTransaction()) {\n                throw new TransactionException(\"Nested @Transaction detected - this is currently not supported.\");\n            }\n\n            if (isolation == TransactionIsolationLevel.INVALID_LEVEL) {\n                return h.inTransaction((conn, status) -> {\n                    try {\n                        return mp.invokeSuper(target, args);\n                    }\n                    catch (Throwable throwable) {\n                        if (throwable instanceof Exception) {\n                            throw (Exception) throwable;\n                        }\n                        else {\n                            throw new RuntimeException(throwable);\n                        }\n                    }\n                });\n            }\n            else {\n                return h.inTransaction(isolation, (conn, status) -> {\n                    try {\n                        return mp.invokeSuper(target, args);\n                    }\n                    catch (Throwable throwable) {\n                        if (throwable instanceof Exception) {\n                            throw (Exception) throwable;\n                        }\n                        else {\n                            throw new RuntimeException(throwable);\n                        }\n                    }\n                });\n\n            }\n        }\n\n        finally {\n            ding.release(\"pass-through-transaction\");\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\n\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport org.jdbi.v3.Handle;\nimport org.jdbi.v3.TransactionCallback;\nimport org.jdbi.v3.TransactionIsolationLevel;\nimport org.jdbi.v3.exceptions.TransactionException;\n\nclass PassThroughTransactionHandler implements Handler\n{\n    private final TransactionIsolationLevel isolation;\n\n    PassThroughTransactionHandler(Method m, Transaction tx)\n    {\n        this.isolation = tx.value();\n    }\n\n    @Override\n    public Object invoke(HandleDing ding, final Object target, final Object[] args, final MethodProxy mp)\n    {\n        ding.retain(\"pass-through-transaction\");\n        try {\n            Handle h = ding.getHandle();\n\n            if (h.isInTransaction()) {\n                throw new TransactionException(\"Nested @Transaction detected - this is currently not supported.\");\n            }\n\n            TransactionCallback<Object> callback = (conn, status) -> {\n                try {\n                    return mp.invokeSuper(target, args);\n                }\n                catch (Throwable throwable) {\n                    if (throwable instanceof Exception) {\n                        throw (Exception) throwable;\n                    }\n                    else {\n                        throw new RuntimeException(throwable);\n                    }\n                }\n            };\n\n            if (isolation == TransactionIsolationLevel.INVALID_LEVEL) {\n                return h.inTransaction(callback);\n            }\n            else {\n                return h.inTransaction(isolation, callback);\n            }\n        }\n\n        finally {\n            ding.release(\"pass-through-transaction\");\n        }\n    }\n}\n","lineNo":45}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\npublic interface ResultBearing<T> extends Iterable<T>\n{\n    @Override\n    ResultIterator<T> iterator();\n\n    /**\n     * Get the only row in the result set.\n     * @throws IllegalStateException if zero or multiple rows are returned\n     * @return the object mapped from the singular row in the results\n     */\n    default T findOnly() {\n        try (ResultIterator<T> iter = iterator()) {\n            if (!iter.hasNext()) {\n                throw new IllegalStateException(\"No element found in 'only'\");\n            }\n\n            final T r = iter.next();\n\n            if (iter.hasNext()) {\n                throw new IllegalStateException(\"Multiple elements found in 'only'\");\n            }\n\n            return r;\n        }\n    }\n\n    /**\n     * Get the first row in the result set, if present.\n     */\n    default Optional<T> findFirst() {\n        try (ResultIterator<T> iter = iterator()) {\n            return iter.hasNext() ? Optional.of(iter.next()) : Optional.empty();\n        }\n    }\n\n    default Stream<T> stream() {\n        return StreamSupport.stream(spliterator(), false);\n    }\n\n    default List<T> list() {\n        return collect(Collectors.toList());\n    }\n\n    /**\n     * Collect the query results into a container specified by a collector.\n     *\n     * @param collector       the collector\n     * @param <R>             the generic type of the container\n     * @return the container with the query result\n     */\n    default <R> R collect(Collector<T, ?, R> collector) {\n        try (Stream<T> stream = stream()) {\n            return stream.collect(collector);\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport static java.util.Spliterators.spliteratorUnknownSize;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\npublic interface ResultBearing<T> extends Iterable<T>\n{\n    @Override\n    ResultIterator<T> iterator();\n\n    /**\n     * Get the only row in the result set.\n     * @throws IllegalStateException if zero or multiple rows are returned\n     * @return the object mapped from the singular row in the results\n     */\n    default T findOnly() {\n        try (ResultIterator<T> iter = iterator()) {\n            if (!iter.hasNext()) {\n                throw new IllegalStateException(\"No element found in 'only'\");\n            }\n\n            final T r = iter.next();\n\n            if (iter.hasNext()) {\n                throw new IllegalStateException(\"Multiple elements found in 'only'\");\n            }\n\n            return r;\n        }\n    }\n\n    /**\n     * Get the first row in the result set, if present.\n     */\n    default Optional<T> findFirst() {\n        try (ResultIterator<T> iter = iterator()) {\n            return iter.hasNext() ? Optional.of(iter.next()) : Optional.empty();\n        }\n    }\n\n    /**\n     * Executes the SQL statement and returns the stream of results.\n     *\n     * <p>\n     * Note: the returned stream owns database resources, and must be closed via a call to {@link Stream#close()}, or\n     * by using the stream in a try-with-resources block:\n     * <\/p>\n     *\n     * <pre>\n     * try (Stream&lt;T> stream = query.stream()) {\n     *   // do stuff with stream\n     * }\n     * <\/pre>\n     */\n    default Stream<T> stream() {\n        ResultIterator<T> iterator = iterator();\n        return StreamSupport.stream(spliteratorUnknownSize(iterator, 0), false)\n                .onClose(iterator::close);\n    }\n\n    default List<T> list() {\n        return collect(Collectors.toList());\n    }\n\n    /**\n     * Collect the query results into a container specified by a collector.\n     *\n     * @param collector       the collector\n     * @param <R>             the generic type of the container\n     * @return the container with the query result\n     */\n    default <R> R collect(Collector<T, ?, R> collector) {\n        try (Stream<T> stream = stream()) {\n            return stream.collect(collector);\n        }\n    }\n\n}\n","lineNo":75}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        CollectorFactoryRegistry queryCollectors = collectorFactoryRegistry.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman, queryCollectors),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                queryCollectors);\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        CollectorFactoryRegistry updateCollectors = collectorFactoryRegistry.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman, updateCollectors),\n                          timingCollector,\n                          updateForeman,\n                          updateCollectors);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        CollectorFactoryRegistry callCollectors = collectorFactoryRegistry.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman, callCollectors),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        callCollectors);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        CollectorFactoryRegistry batchCollectors = collectorFactoryRegistry.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, batchCollectors),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 batchCollectors);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, collectorFactoryRegistry.createChild()),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild(),\n                        collectorFactoryRegistry.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        CollectorFactoryRegistry queryCollectors = collectorFactoryRegistry.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman, queryCollectors),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                queryCollectors);\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        MappingRegistry updateMappingRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        CollectorFactoryRegistry updateCollectors = collectorFactoryRegistry.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, updateMappingRegistry, updateForeman, updateCollectors),\n                          timingCollector,\n                          updateForeman,\n                          updateMappingRegistry,\n                          updateCollectors);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        CollectorFactoryRegistry callCollectors = collectorFactoryRegistry.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman, callCollectors),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        callCollectors);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        MappingRegistry batchMappingRegistry = MappingRegistry.copyOf(mappingRegistry);\n        CollectorFactoryRegistry batchCollectors = collectorFactoryRegistry.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, batchMappingRegistry, batchForeman, batchCollectors),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 batchMappingRegistry,\n                                 batchCollectors);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, collectorFactoryRegistry.createChild()),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild(),\n                        collectorFactoryRegistry.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":249}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        CollectorFactoryRegistry queryCollectors = collectorFactoryRegistry.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman, queryCollectors),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                queryCollectors);\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        CollectorFactoryRegistry updateCollectors = collectorFactoryRegistry.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman, updateCollectors),\n                          timingCollector,\n                          updateForeman,\n                          updateCollectors);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        CollectorFactoryRegistry callCollectors = collectorFactoryRegistry.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman, callCollectors),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        callCollectors);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        CollectorFactoryRegistry batchCollectors = collectorFactoryRegistry.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, batchCollectors),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 batchCollectors);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, collectorFactoryRegistry.createChild()),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild(),\n                        collectorFactoryRegistry.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        CollectorFactoryRegistry queryCollectors = collectorFactoryRegistry.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman, queryCollectors),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                queryCollectors);\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        MappingRegistry updateMappingRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        CollectorFactoryRegistry updateCollectors = collectorFactoryRegistry.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, updateMappingRegistry, updateForeman, updateCollectors),\n                          timingCollector,\n                          updateForeman,\n                          updateMappingRegistry,\n                          updateCollectors);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        CollectorFactoryRegistry callCollectors = collectorFactoryRegistry.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman, callCollectors),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        callCollectors);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        MappingRegistry batchMappingRegistry = MappingRegistry.copyOf(mappingRegistry);\n        CollectorFactoryRegistry batchCollectors = collectorFactoryRegistry.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, batchMappingRegistry, batchForeman, batchCollectors),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 batchMappingRegistry,\n                                 batchCollectors);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, collectorFactoryRegistry.createChild()),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild(),\n                        collectorFactoryRegistry.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":301}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.tweak.ResultSetMapper;\n\nclass RegisteredMapper<T> implements ResultSetMapper<T>\n{\n\n    private final Type type;\n    private final MappingRegistry registry;\n\n    RegisteredMapper(Type type, MappingRegistry registry) {\n        this.type = type;\n        this.registry = registry;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T map(int index, ResultSet r, StatementContext ctx) throws SQLException\n    {\n        return (T) registry.mapperFor(type, ctx).map(index, r, ctx);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.tweak.ResultSetMapper;\n\nclass RegisteredMapper<T> implements ResultSetMapper<T>\n{\n\n    private final Type type;\n    private final MappingRegistry registry;\n\n    RegisteredMapper(Type type, MappingRegistry registry) {\n        this.type = type;\n        this.registry = registry;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T map(int index, ResultSet r, StatementContext ctx) throws SQLException\n    {\n        ResultSetMapper<?> mapper = registry.mapperFor(type, ctx)\n                .orElseThrow(() -> new UnsupportedOperationException(\"No mapper registered for \" + type));\n        return (T) mapper.map(index, r, ctx);\n    }\n}\n","lineNo":37}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport static org.jdbi.v3.Types.getErasedType;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\n\nimport org.jdbi.v3.H2DatabaseRule;\nimport org.jdbi.v3.ResultSetMapperFactory;\nimport org.jdbi.v3.StatementContext;\nimport org.jdbi.v3.sqlobject.TestRegisterMapperFactory.Foo.FooMapper;\nimport org.jdbi.v3.sqlobject.customizers.RegisterMapperFactory;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.junit.Assert;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class TestRegisterMapperFactory\n{\n    @Rule\n    public H2DatabaseRule db = new H2DatabaseRule();\n\n    @Test\n    public void testSimple() throws Exception\n    {\n        FooDao fooDao = SqlObjectBuilder.onDemand(db.getDbi(), FooDao.class);\n\n        List<Foo> foos = fooDao.select();\n        Assert.assertNotNull(foos);\n        Assert.assertEquals(0, foos.size());\n\n        fooDao.insert(1, \"John Doe\");\n        fooDao.insert(2, \"Jane Doe\");\n        List<Foo> foos2 = fooDao.select();\n        Assert.assertNotNull(foos2);\n        Assert.assertEquals(2, foos2.size());\n\n    }\n\n    @RegisterMapperFactory(MyFactory.class)\n    public interface FooDao\n    {\n        @SqlQuery(\"select * from something\")\n        List<Foo> select();\n\n        @SqlUpdate(\"insert into something (id, name) VALUES (:id, :name)\")\n        void insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n    }\n\n\n    public static class MyFactory implements ResultSetMapperFactory\n    {\n\n        @Override\n        public boolean accepts(Type type, StatementContext ctx)\n        {\n            return getErasedType(type).isAnnotationPresent(MapWith.class);\n        }\n\n        @Override\n        public ResultSetMapper<?> mapperFor(Type type, StatementContext ctx)\n        {\n\n            MapWith rm = getErasedType(type).getAnnotation(MapWith.class);\n            try {\n                return rm.value().newInstance();\n            }\n            catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    @MapWith(FooMapper.class)\n    public static class Foo\n    {\n        private final int    id;\n        private final String name;\n\n        Foo(final int id, final String name)\n        {\n            this.id = id;\n            this.name = name;\n        }\n\n        public int getId()\n        {\n            return id;\n        }\n\n        public String getName()\n        {\n            return name;\n        }\n\n        public static class FooMapper implements ResultSetMapper<Foo>\n        {\n            @Override\n            public Foo map(final int index, final ResultSet r, final StatementContext ctx) throws SQLException\n            {\n                return new Foo(r.getInt(\"id\"), r.getString(\"name\"));\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport static org.jdbi.v3.Types.getErasedType;\n\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.Optional;\n\nimport org.jdbi.v3.H2DatabaseRule;\nimport org.jdbi.v3.ResultSetMapperFactory;\nimport org.jdbi.v3.StatementContext;\nimport org.jdbi.v3.sqlobject.TestRegisterMapperFactory.Foo.FooMapper;\nimport org.jdbi.v3.sqlobject.customizers.RegisterMapperFactory;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.junit.Assert;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class TestRegisterMapperFactory\n{\n    @Rule\n    public H2DatabaseRule db = new H2DatabaseRule();\n\n    @Test\n    public void testSimple() throws Exception\n    {\n        FooDao fooDao = SqlObjectBuilder.onDemand(db.getDbi(), FooDao.class);\n\n        List<Foo> foos = fooDao.select();\n        Assert.assertNotNull(foos);\n        Assert.assertEquals(0, foos.size());\n\n        fooDao.insert(1, \"John Doe\");\n        fooDao.insert(2, \"Jane Doe\");\n        List<Foo> foos2 = fooDao.select();\n        Assert.assertNotNull(foos2);\n        Assert.assertEquals(2, foos2.size());\n\n    }\n\n    @RegisterMapperFactory(MyFactory.class)\n    public interface FooDao\n    {\n        @SqlQuery(\"select * from something\")\n        List<Foo> select();\n\n        @SqlUpdate(\"insert into something (id, name) VALUES (:id, :name)\")\n        void insert(@Bind(\"id\") int id, @Bind(\"name\") String name);\n    }\n\n\n    public static class MyFactory implements ResultSetMapperFactory\n    {\n        @Override\n        public Optional<ResultSetMapper<?>> build(Type type, StatementContext ctx) {\n            Class<?> erasedType = getErasedType(type);\n            try {\n                MapWith mapWith = erasedType.getAnnotation(MapWith.class);\n                return mapWith == null\n                        ? Optional.empty()\n                        : Optional.of(mapWith.value().newInstance());\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    @MapWith(FooMapper.class)\n    public static class Foo\n    {\n        private final int    id;\n        private final String name;\n\n        Foo(final int id, final String name)\n        {\n            this.id = id;\n            this.name = name;\n        }\n\n        public int getId()\n        {\n            return id;\n        }\n\n        public String getName()\n        {\n            return name;\n        }\n\n        public static class FooMapper implements ResultSetMapper<Foo>\n        {\n            @Override\n            public Foo map(final int index, final ResultSet r, final StatementContext ctx) throws SQLException\n            {\n                return new Foo(r.getInt(\"id\"), r.getString(\"name\"));\n            }\n        }\n    }\n}\n","lineNo":71}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.jpa;\n\nimport static org.jdbi.v3.Types.getErasedType;\n\nimport java.lang.reflect.Type;\n\nimport org.jdbi.v3.ResultSetMapperFactory;\nimport org.jdbi.v3.StatementContext;\n\npublic class JpaMapperFactory implements ResultSetMapperFactory {\n\n    @Override\n    public boolean accepts(Type type, StatementContext ctx) {\n        return JpaMapper.accept(getErasedType(type));\n    }\n\n    @Override\n    public JpaMapper<?> mapperFor(Type type, StatementContext ctx) {\n        return JpaMapper.get(getErasedType(type));\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.jpa;\n\nimport static org.jdbi.v3.Types.getErasedType;\n\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\nimport javax.persistence.Entity;\n\nimport org.jdbi.v3.ResultSetMapperFactory;\nimport org.jdbi.v3.StatementContext;\nimport org.jdbi.v3.tweak.ResultSetMapper;\n\npublic class JpaMapperFactory implements ResultSetMapperFactory {\n    @Override\n    public Optional<ResultSetMapper<?>> build(Type type, StatementContext ctx) {\n        Class<?> clazz = getErasedType(type);\n        return clazz.isAnnotationPresent(Entity.class)\n                ? Optional.of(new JpaMapper<>(clazz))\n                : Optional.empty();\n    }\n}\n","lineNo":30}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman),\n                          timingCollector,\n                          updateForeman,\n                          collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        CollectorFactoryRegistry queryCollectors = collectorFactoryRegistry.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman, queryCollectors),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                queryCollectors);\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        CollectorFactoryRegistry updateCollectors = collectorFactoryRegistry.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman, updateCollectors),\n                          timingCollector,\n                          updateForeman,\n                          updateCollectors);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        CollectorFactoryRegistry callCollectors = collectorFactoryRegistry.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman, callCollectors),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        callCollectors);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        CollectorFactoryRegistry batchCollectors = collectorFactoryRegistry.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, batchCollectors),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 batchCollectors);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, collectorFactoryRegistry.createChild()),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild(),\n                        collectorFactoryRegistry.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":85}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman),\n                          timingCollector,\n                          updateForeman,\n                          collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        CollectorFactoryRegistry queryCollectors = collectorFactoryRegistry.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman, queryCollectors),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                queryCollectors);\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        CollectorFactoryRegistry updateCollectors = collectorFactoryRegistry.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman, updateCollectors),\n                          timingCollector,\n                          updateForeman,\n                          updateCollectors);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        CollectorFactoryRegistry callCollectors = collectorFactoryRegistry.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman, callCollectors),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        callCollectors);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        CollectorFactoryRegistry batchCollectors = collectorFactoryRegistry.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, batchCollectors),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 batchCollectors);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, collectorFactoryRegistry.createChild()),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild(),\n                        collectorFactoryRegistry.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":249}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman),\n                          timingCollector,\n                          updateForeman,\n                          collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        CollectorFactoryRegistry queryCollectors = collectorFactoryRegistry.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman, queryCollectors),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                queryCollectors);\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        CollectorFactoryRegistry updateCollectors = collectorFactoryRegistry.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman, updateCollectors),\n                          timingCollector,\n                          updateForeman,\n                          updateCollectors);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        CollectorFactoryRegistry callCollectors = collectorFactoryRegistry.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman, callCollectors),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        callCollectors);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        CollectorFactoryRegistry batchCollectors = collectorFactoryRegistry.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, batchCollectors),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 batchCollectors);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, collectorFactoryRegistry.createChild()),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild(),\n                        collectorFactoryRegistry.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":265}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman),\n                          timingCollector,\n                          updateForeman,\n                          collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 collectorFactoryRegistry.createChild());\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        CollectorFactoryRegistry queryCollectors = collectorFactoryRegistry.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman, queryCollectors),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                queryCollectors);\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        CollectorFactoryRegistry updateCollectors = collectorFactoryRegistry.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman, updateCollectors),\n                          timingCollector,\n                          updateForeman,\n                          updateCollectors);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        CollectorFactoryRegistry callCollectors = collectorFactoryRegistry.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman, callCollectors),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        callCollectors);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        CollectorFactoryRegistry batchCollectors = collectorFactoryRegistry.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, batchCollectors),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 batchCollectors);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman, collectorFactoryRegistry.createChild()),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild(),\n                        collectorFactoryRegistry.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":299}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.TypeBindings;\nimport com.fasterxml.classmate.members.ResolvedMethod;\n\nimport org.jdbi.v3.Query;\nimport org.jdbi.v3.ResultBearing;\nimport org.jdbi.v3.ResultIterator;\nimport org.jdbi.v3.exceptions.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.customizers.Mapper;\nimport org.jdbi.v3.sqlobject.customizers.SingleValueResult;\nimport org.jdbi.v3.tweak.ResultSetMapper;\n\nabstract class ResultReturnThing\n{\n    public Object map(ResolvedMethod method, Query<?> q, HandleDing h)\n    {\n        if (method.getRawMember().isAnnotationPresent(Mapper.class)) {\n            final ResultSetMapper<?> mapper;\n            try {\n                mapper = method.getRawMember().getAnnotation(Mapper.class).value().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"unable to access mapper\", e, null);\n            }\n            return result(q.map(mapper), h);\n        }\n        else {\n            return result(q.mapTo(mapTo(method)), h);\n        }\n    }\n\n    static ResultReturnThing forType(ResolvedMethod method)\n    {\n        ResolvedType return_type = method.getReturnType();\n        if (return_type == null) {\n            throw new IllegalStateException(String.format(\n                    \"Method %s#%s is annotated as if it should return a value, but the method is void.\",\n                    method.getDeclaringType().getErasedType().getName(),\n                    method.getName()));\n        } else if (return_type.isInstanceOf(ResultBearing.class)) {\n            return new ResultBearingResultReturnThing(method);\n        }\n        else if (return_type.isInstanceOf(Iterable.class)) {\n            return new IterableReturningThing(method);\n        }\n        else if (return_type.isInstanceOf(Iterator.class)) {\n            return new IteratorResultReturnThing(method);\n        }\n        else {\n            return new SingleValueResultReturnThing(method);\n        }\n    }\n\n    protected abstract Object result(ResultBearing<?> q, HandleDing baton);\n\n    protected abstract Class<?> mapTo(ResolvedMethod method);\n\n\n    static class SingleValueResultReturnThing extends ResultReturnThing\n    {\n        private final Class<?> returnType;\n        private final Class<?> containerType;\n\n        SingleValueResultReturnThing(ResolvedMethod method)\n        {\n            if (method.getRawMember().isAnnotationPresent(SingleValueResult.class)) {\n                SingleValueResult svr = method.getRawMember().getAnnotation(SingleValueResult.class);\n                // try to guess generic type\n                if(SingleValueResult.Default.class == svr.value()){\n                    TypeBindings typeBindings = method.getReturnType().getTypeBindings();\n                    if(typeBindings.size() == 1){\n                        this.returnType = typeBindings.getBoundType(0).getErasedType();\n                    }else{\n                        throw new IllegalArgumentException(\"Ambiguous generic information. SingleValueResult type could not be fetched.\");\n                    }\n\n                }else{\n                    this.returnType = svr.value();\n                }\n                this.containerType = method.getReturnType().getErasedType();\n            }\n            else {\n                this.returnType = method.getReturnType().getErasedType();\n                this.containerType = null;\n            }\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            if (containerType != null) {\n                return q.collectInto(containerType);\n            }\n            return q.findFirst().orElse(null);\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return returnType;\n        }\n    }\n\n    static class ResultBearingResultReturnThing extends ResultReturnThing\n    {\n\n        private final ResolvedType resolvedType;\n\n        ResultBearingResultReturnThing(ResolvedMethod method)\n        {\n            // extract T from Query<T>\n            ResolvedType query_type = method.getReturnType();\n            List<ResolvedType> query_return_types = query_type.typeParametersFor(org.jdbi.v3.Query.class);\n            this.resolvedType = query_return_types.get(0);\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            return q;\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return resolvedType.getErasedType();\n        }\n    }\n\n    static class IteratorResultReturnThing extends ResultReturnThing\n    {\n        private final ResolvedType resolvedType;\n\n        IteratorResultReturnThing(ResolvedMethod method)\n        {\n            ResolvedType query_type = method.getReturnType();\n            List<ResolvedType> query_return_types = query_type.typeParametersFor(Iterator.class);\n            this.resolvedType = query_return_types.get(0);\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, final HandleDing baton)\n        {\n            final ResultIterator<?> itty = q.iterator();\n\n            final boolean isEmpty = !itty.hasNext();\n            if (isEmpty) {\n                itty.close();\n            } else {\n                baton.retain(\"iterator\");\n            }\n\n            return new ResultIterator<Object>()\n            {\n                private boolean closed = isEmpty;\n                private boolean hasNext = !isEmpty;\n\n                @Override\n                public void close()\n                {\n                    if (!closed) {\n                        closed = true;\n                        try {\n                            itty.close();\n                        }\n                        finally {\n                            baton.release(\"iterator\");\n                        }\n                    }\n                }\n\n                @Override\n                public boolean hasNext()\n                {\n                    return hasNext;\n                }\n\n                @Override\n                public Object next()\n                {\n                    Object rs;\n                    try {\n                        rs = itty.next();\n                        hasNext = itty.hasNext();\n                    }\n                    catch (RuntimeException e) {\n                        closeIgnoreException();\n                        throw e;\n                    }\n                    if (!hasNext) {\n                        close();\n                    }\n                    return rs;\n                }\n\n                @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n                public void closeIgnoreException() {\n                    try {\n                        close();\n                    } catch (RuntimeException ex) {}\n                }\n\n                @Override\n                public void remove()\n                {\n                    itty.remove();\n                }\n            };\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return resolvedType.getErasedType();\n        }\n    }\n\n    static class IterableReturningThing extends ResultReturnThing\n    {\n        private final Class<?> iterableType;\n        private final Class<?> elementType;\n\n        IterableReturningThing(ResolvedMethod method)\n        {\n            // extract T from List<T>\n            ResolvedType returnType = method.getReturnType();\n            this.iterableType = returnType.getErasedType();\n            this.elementType = returnType.typeParametersFor(Iterable.class).get(0).getErasedType();\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            if (q instanceof Query) {\n                return q.collectInto(iterableType);\n            } else {\n                throw new UnsupportedOperationException(\"Collect is not supported for \" + q);\n            }\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return elementType;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Collector;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.TypeBindings;\nimport com.fasterxml.classmate.members.ResolvedMethod;\n\nimport org.jdbi.v3.Query;\nimport org.jdbi.v3.ResultBearing;\nimport org.jdbi.v3.ResultIterator;\nimport org.jdbi.v3.exceptions.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.customizers.Mapper;\nimport org.jdbi.v3.sqlobject.customizers.SingleValueResult;\nimport org.jdbi.v3.tweak.ResultSetMapper;\n\nabstract class ResultReturnThing\n{\n    public Object map(ResolvedMethod method, Query<?> q, HandleDing h)\n    {\n        if (method.getRawMember().isAnnotationPresent(Mapper.class)) {\n            final ResultSetMapper<?> mapper;\n            try {\n                mapper = method.getRawMember().getAnnotation(Mapper.class).value().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"unable to access mapper\", e, null);\n            }\n            return result(q.map(mapper), h);\n        }\n        else {\n            return result(q.mapTo(mapTo(method)), h);\n        }\n    }\n\n    static ResultReturnThing forType(ResolvedMethod method)\n    {\n        ResolvedType return_type = method.getReturnType();\n        if (return_type == null) {\n            throw new IllegalStateException(String.format(\n                    \"Method %s#%s is annotated as if it should return a value, but the method is void.\",\n                    method.getDeclaringType().getErasedType().getName(),\n                    method.getName()));\n        } else if (return_type.isInstanceOf(ResultBearing.class)) {\n            return new ResultBearingResultReturnThing(method);\n        }\n        else if (return_type.isInstanceOf(Iterable.class)) {\n            return new IterableReturningThing(method);\n        }\n        else if (return_type.isInstanceOf(Iterator.class)) {\n            return new IteratorResultReturnThing(method);\n        }\n        else {\n            return new SingleValueResultReturnThing(method);\n        }\n    }\n\n    protected abstract Object result(ResultBearing<?> q, HandleDing baton);\n\n    protected abstract Class<?> mapTo(ResolvedMethod method);\n\n\n    static class SingleValueResultReturnThing extends ResultReturnThing\n    {\n        private final Class<?> returnType;\n        private final Class<?> containerType;\n\n        SingleValueResultReturnThing(ResolvedMethod method)\n        {\n            if (method.getRawMember().isAnnotationPresent(SingleValueResult.class)) {\n                SingleValueResult svr = method.getRawMember().getAnnotation(SingleValueResult.class);\n                // try to guess generic type\n                if(SingleValueResult.Default.class == svr.value()){\n                    TypeBindings typeBindings = method.getReturnType().getTypeBindings();\n                    if(typeBindings.size() == 1){\n                        this.returnType = typeBindings.getBoundType(0).getErasedType();\n                    }else{\n                        throw new IllegalArgumentException(\"Ambiguous generic information. SingleValueResult type could not be fetched.\");\n                    }\n\n                }else{\n                    this.returnType = svr.value();\n                }\n                this.containerType = method.getReturnType().getErasedType();\n            }\n            else {\n                this.returnType = method.getReturnType().getErasedType();\n                this.containerType = null;\n            }\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            if (containerType != null) {\n                Collector collector = ((Query)q).getContext().collectorFor(containerType);\n                return q.collect(collector);\n            }\n            return q.findFirst().orElse(null);\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return returnType;\n        }\n    }\n\n    static class ResultBearingResultReturnThing extends ResultReturnThing\n    {\n\n        private final ResolvedType resolvedType;\n\n        ResultBearingResultReturnThing(ResolvedMethod method)\n        {\n            // extract T from Query<T>\n            ResolvedType query_type = method.getReturnType();\n            List<ResolvedType> query_return_types = query_type.typeParametersFor(org.jdbi.v3.Query.class);\n            this.resolvedType = query_return_types.get(0);\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            return q;\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return resolvedType.getErasedType();\n        }\n    }\n\n    static class IteratorResultReturnThing extends ResultReturnThing\n    {\n        private final ResolvedType resolvedType;\n\n        IteratorResultReturnThing(ResolvedMethod method)\n        {\n            ResolvedType query_type = method.getReturnType();\n            List<ResolvedType> query_return_types = query_type.typeParametersFor(Iterator.class);\n            this.resolvedType = query_return_types.get(0);\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, final HandleDing baton)\n        {\n            final ResultIterator<?> itty = q.iterator();\n\n            final boolean isEmpty = !itty.hasNext();\n            if (isEmpty) {\n                itty.close();\n            } else {\n                baton.retain(\"iterator\");\n            }\n\n            return new ResultIterator<Object>()\n            {\n                private boolean closed = isEmpty;\n                private boolean hasNext = !isEmpty;\n\n                @Override\n                public void close()\n                {\n                    if (!closed) {\n                        closed = true;\n                        try {\n                            itty.close();\n                        }\n                        finally {\n                            baton.release(\"iterator\");\n                        }\n                    }\n                }\n\n                @Override\n                public boolean hasNext()\n                {\n                    return hasNext;\n                }\n\n                @Override\n                public Object next()\n                {\n                    Object rs;\n                    try {\n                        rs = itty.next();\n                        hasNext = itty.hasNext();\n                    }\n                    catch (RuntimeException e) {\n                        closeIgnoreException();\n                        throw e;\n                    }\n                    if (!hasNext) {\n                        close();\n                    }\n                    return rs;\n                }\n\n                @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n                public void closeIgnoreException() {\n                    try {\n                        close();\n                    } catch (RuntimeException ex) {}\n                }\n\n                @Override\n                public void remove()\n                {\n                    itty.remove();\n                }\n            };\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return resolvedType.getErasedType();\n        }\n    }\n\n    static class IterableReturningThing extends ResultReturnThing\n    {\n        private final Class<?> iterableType;\n        private final Class<?> elementType;\n\n        IterableReturningThing(ResolvedMethod method)\n        {\n            // extract T from List<T>\n            ResolvedType returnType = method.getReturnType();\n            this.iterableType = returnType.getErasedType();\n            this.elementType = returnType.typeParametersFor(Iterable.class).get(0).getErasedType();\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            if (q instanceof Query) {\n                Collector collector = ((Query) q).getContext().collectorFor(iterableType);\n                return q.collect(collector);\n            } else {\n                throw new UnsupportedOperationException(\"Collect is not supported for \" + q);\n            }\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return elementType;\n        }\n    }\n}\n","lineNo":112}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.TypeBindings;\nimport com.fasterxml.classmate.members.ResolvedMethod;\n\nimport org.jdbi.v3.Query;\nimport org.jdbi.v3.ResultBearing;\nimport org.jdbi.v3.ResultIterator;\nimport org.jdbi.v3.exceptions.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.customizers.Mapper;\nimport org.jdbi.v3.sqlobject.customizers.SingleValueResult;\nimport org.jdbi.v3.tweak.ResultSetMapper;\n\nabstract class ResultReturnThing\n{\n    public Object map(ResolvedMethod method, Query<?> q, HandleDing h)\n    {\n        if (method.getRawMember().isAnnotationPresent(Mapper.class)) {\n            final ResultSetMapper<?> mapper;\n            try {\n                mapper = method.getRawMember().getAnnotation(Mapper.class).value().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"unable to access mapper\", e, null);\n            }\n            return result(q.map(mapper), h);\n        }\n        else {\n            return result(q.mapTo(mapTo(method)), h);\n        }\n    }\n\n    static ResultReturnThing forType(ResolvedMethod method)\n    {\n        ResolvedType return_type = method.getReturnType();\n        if (return_type == null) {\n            throw new IllegalStateException(String.format(\n                    \"Method %s#%s is annotated as if it should return a value, but the method is void.\",\n                    method.getDeclaringType().getErasedType().getName(),\n                    method.getName()));\n        } else if (return_type.isInstanceOf(ResultBearing.class)) {\n            return new ResultBearingResultReturnThing(method);\n        }\n        else if (return_type.isInstanceOf(Iterable.class)) {\n            return new IterableReturningThing(method);\n        }\n        else if (return_type.isInstanceOf(Iterator.class)) {\n            return new IteratorResultReturnThing(method);\n        }\n        else {\n            return new SingleValueResultReturnThing(method);\n        }\n    }\n\n    protected abstract Object result(ResultBearing<?> q, HandleDing baton);\n\n    protected abstract Class<?> mapTo(ResolvedMethod method);\n\n\n    static class SingleValueResultReturnThing extends ResultReturnThing\n    {\n        private final Class<?> returnType;\n        private final Class<?> containerType;\n\n        SingleValueResultReturnThing(ResolvedMethod method)\n        {\n            if (method.getRawMember().isAnnotationPresent(SingleValueResult.class)) {\n                SingleValueResult svr = method.getRawMember().getAnnotation(SingleValueResult.class);\n                // try to guess generic type\n                if(SingleValueResult.Default.class == svr.value()){\n                    TypeBindings typeBindings = method.getReturnType().getTypeBindings();\n                    if(typeBindings.size() == 1){\n                        this.returnType = typeBindings.getBoundType(0).getErasedType();\n                    }else{\n                        throw new IllegalArgumentException(\"Ambiguous generic information. SingleValueResult type could not be fetched.\");\n                    }\n\n                }else{\n                    this.returnType = svr.value();\n                }\n                this.containerType = method.getReturnType().getErasedType();\n            }\n            else {\n                this.returnType = method.getReturnType().getErasedType();\n                this.containerType = null;\n            }\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            if (containerType != null) {\n                return q.collectInto(containerType);\n            }\n            return q.findFirst().orElse(null);\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return returnType;\n        }\n    }\n\n    static class ResultBearingResultReturnThing extends ResultReturnThing\n    {\n\n        private final ResolvedType resolvedType;\n\n        ResultBearingResultReturnThing(ResolvedMethod method)\n        {\n            // extract T from Query<T>\n            ResolvedType query_type = method.getReturnType();\n            List<ResolvedType> query_return_types = query_type.typeParametersFor(org.jdbi.v3.Query.class);\n            this.resolvedType = query_return_types.get(0);\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            return q;\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return resolvedType.getErasedType();\n        }\n    }\n\n    static class IteratorResultReturnThing extends ResultReturnThing\n    {\n        private final ResolvedType resolvedType;\n\n        IteratorResultReturnThing(ResolvedMethod method)\n        {\n            ResolvedType query_type = method.getReturnType();\n            List<ResolvedType> query_return_types = query_type.typeParametersFor(Iterator.class);\n            this.resolvedType = query_return_types.get(0);\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, final HandleDing baton)\n        {\n            final ResultIterator<?> itty = q.iterator();\n\n            final boolean isEmpty = !itty.hasNext();\n            if (isEmpty) {\n                itty.close();\n            } else {\n                baton.retain(\"iterator\");\n            }\n\n            return new ResultIterator<Object>()\n            {\n                private boolean closed = isEmpty;\n                private boolean hasNext = !isEmpty;\n\n                @Override\n                public void close()\n                {\n                    if (!closed) {\n                        closed = true;\n                        try {\n                            itty.close();\n                        }\n                        finally {\n                            baton.release(\"iterator\");\n                        }\n                    }\n                }\n\n                @Override\n                public boolean hasNext()\n                {\n                    return hasNext;\n                }\n\n                @Override\n                public Object next()\n                {\n                    Object rs;\n                    try {\n                        rs = itty.next();\n                        hasNext = itty.hasNext();\n                    }\n                    catch (RuntimeException e) {\n                        closeIgnoreException();\n                        throw e;\n                    }\n                    if (!hasNext) {\n                        close();\n                    }\n                    return rs;\n                }\n\n                @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n                public void closeIgnoreException() {\n                    try {\n                        close();\n                    } catch (RuntimeException ex) {}\n                }\n\n                @Override\n                public void remove()\n                {\n                    itty.remove();\n                }\n            };\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return resolvedType.getErasedType();\n        }\n    }\n\n    static class IterableReturningThing extends ResultReturnThing\n    {\n        private final Class<?> iterableType;\n        private final Class<?> elementType;\n\n        IterableReturningThing(ResolvedMethod method)\n        {\n            // extract T from List<T>\n            ResolvedType returnType = method.getReturnType();\n            this.iterableType = returnType.getErasedType();\n            this.elementType = returnType.typeParametersFor(Iterable.class).get(0).getErasedType();\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            if (q instanceof Query) {\n                return q.collectInto(iterableType);\n            } else {\n                throw new UnsupportedOperationException(\"Collect is not supported for \" + q);\n            }\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return elementType;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Collector;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.TypeBindings;\nimport com.fasterxml.classmate.members.ResolvedMethod;\n\nimport org.jdbi.v3.Query;\nimport org.jdbi.v3.ResultBearing;\nimport org.jdbi.v3.ResultIterator;\nimport org.jdbi.v3.exceptions.UnableToCreateStatementException;\nimport org.jdbi.v3.sqlobject.customizers.Mapper;\nimport org.jdbi.v3.sqlobject.customizers.SingleValueResult;\nimport org.jdbi.v3.tweak.ResultSetMapper;\n\nabstract class ResultReturnThing\n{\n    public Object map(ResolvedMethod method, Query<?> q, HandleDing h)\n    {\n        if (method.getRawMember().isAnnotationPresent(Mapper.class)) {\n            final ResultSetMapper<?> mapper;\n            try {\n                mapper = method.getRawMember().getAnnotation(Mapper.class).value().newInstance();\n            }\n            catch (Exception e) {\n                throw new UnableToCreateStatementException(\"unable to access mapper\", e, null);\n            }\n            return result(q.map(mapper), h);\n        }\n        else {\n            return result(q.mapTo(mapTo(method)), h);\n        }\n    }\n\n    static ResultReturnThing forType(ResolvedMethod method)\n    {\n        ResolvedType return_type = method.getReturnType();\n        if (return_type == null) {\n            throw new IllegalStateException(String.format(\n                    \"Method %s#%s is annotated as if it should return a value, but the method is void.\",\n                    method.getDeclaringType().getErasedType().getName(),\n                    method.getName()));\n        } else if (return_type.isInstanceOf(ResultBearing.class)) {\n            return new ResultBearingResultReturnThing(method);\n        }\n        else if (return_type.isInstanceOf(Iterable.class)) {\n            return new IterableReturningThing(method);\n        }\n        else if (return_type.isInstanceOf(Iterator.class)) {\n            return new IteratorResultReturnThing(method);\n        }\n        else {\n            return new SingleValueResultReturnThing(method);\n        }\n    }\n\n    protected abstract Object result(ResultBearing<?> q, HandleDing baton);\n\n    protected abstract Class<?> mapTo(ResolvedMethod method);\n\n\n    static class SingleValueResultReturnThing extends ResultReturnThing\n    {\n        private final Class<?> returnType;\n        private final Class<?> containerType;\n\n        SingleValueResultReturnThing(ResolvedMethod method)\n        {\n            if (method.getRawMember().isAnnotationPresent(SingleValueResult.class)) {\n                SingleValueResult svr = method.getRawMember().getAnnotation(SingleValueResult.class);\n                // try to guess generic type\n                if(SingleValueResult.Default.class == svr.value()){\n                    TypeBindings typeBindings = method.getReturnType().getTypeBindings();\n                    if(typeBindings.size() == 1){\n                        this.returnType = typeBindings.getBoundType(0).getErasedType();\n                    }else{\n                        throw new IllegalArgumentException(\"Ambiguous generic information. SingleValueResult type could not be fetched.\");\n                    }\n\n                }else{\n                    this.returnType = svr.value();\n                }\n                this.containerType = method.getReturnType().getErasedType();\n            }\n            else {\n                this.returnType = method.getReturnType().getErasedType();\n                this.containerType = null;\n            }\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            if (containerType != null) {\n                Collector collector = ((Query)q).getContext().collectorFor(containerType);\n                return q.collect(collector);\n            }\n            return q.findFirst().orElse(null);\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return returnType;\n        }\n    }\n\n    static class ResultBearingResultReturnThing extends ResultReturnThing\n    {\n\n        private final ResolvedType resolvedType;\n\n        ResultBearingResultReturnThing(ResolvedMethod method)\n        {\n            // extract T from Query<T>\n            ResolvedType query_type = method.getReturnType();\n            List<ResolvedType> query_return_types = query_type.typeParametersFor(org.jdbi.v3.Query.class);\n            this.resolvedType = query_return_types.get(0);\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            return q;\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return resolvedType.getErasedType();\n        }\n    }\n\n    static class IteratorResultReturnThing extends ResultReturnThing\n    {\n        private final ResolvedType resolvedType;\n\n        IteratorResultReturnThing(ResolvedMethod method)\n        {\n            ResolvedType query_type = method.getReturnType();\n            List<ResolvedType> query_return_types = query_type.typeParametersFor(Iterator.class);\n            this.resolvedType = query_return_types.get(0);\n\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, final HandleDing baton)\n        {\n            final ResultIterator<?> itty = q.iterator();\n\n            final boolean isEmpty = !itty.hasNext();\n            if (isEmpty) {\n                itty.close();\n            } else {\n                baton.retain(\"iterator\");\n            }\n\n            return new ResultIterator<Object>()\n            {\n                private boolean closed = isEmpty;\n                private boolean hasNext = !isEmpty;\n\n                @Override\n                public void close()\n                {\n                    if (!closed) {\n                        closed = true;\n                        try {\n                            itty.close();\n                        }\n                        finally {\n                            baton.release(\"iterator\");\n                        }\n                    }\n                }\n\n                @Override\n                public boolean hasNext()\n                {\n                    return hasNext;\n                }\n\n                @Override\n                public Object next()\n                {\n                    Object rs;\n                    try {\n                        rs = itty.next();\n                        hasNext = itty.hasNext();\n                    }\n                    catch (RuntimeException e) {\n                        closeIgnoreException();\n                        throw e;\n                    }\n                    if (!hasNext) {\n                        close();\n                    }\n                    return rs;\n                }\n\n                @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n                public void closeIgnoreException() {\n                    try {\n                        close();\n                    } catch (RuntimeException ex) {}\n                }\n\n                @Override\n                public void remove()\n                {\n                    itty.remove();\n                }\n            };\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return resolvedType.getErasedType();\n        }\n    }\n\n    static class IterableReturningThing extends ResultReturnThing\n    {\n        private final Class<?> iterableType;\n        private final Class<?> elementType;\n\n        IterableReturningThing(ResolvedMethod method)\n        {\n            // extract T from List<T>\n            ResolvedType returnType = method.getReturnType();\n            this.iterableType = returnType.getErasedType();\n            this.elementType = returnType.typeParametersFor(Iterable.class).get(0).getErasedType();\n        }\n\n        @Override\n        protected Object result(ResultBearing<?> q, HandleDing baton)\n        {\n            if (q instanceof Query) {\n                Collector collector = ((Query) q).getContext().collectorFor(iterableType);\n                return q.collect(collector);\n            } else {\n                throw new UnsupportedOperationException(\"Collect is not supported for \" + q);\n            }\n        }\n\n        @Override\n        protected Class<?> mapTo(ResolvedMethod method)\n        {\n            return elementType;\n        }\n    }\n}\n","lineNo":258}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertSame;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.tweak.Argument;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.junit.Test;\n\npublic class TestForeman\n{\n    @Test\n    public void testWaffling()\n    {\n        final Foreman foreman = new Foreman();\n\n        final Argument longArgument = foreman.waffle(Object.class, new Long(3L), null);\n        assertSame(LongArgument.class, longArgument.getClass());\n\n        final Argument shortArgument = foreman.waffle(Object.class, (short) 2000, null);\n        assertSame(ShortArgument.class, shortArgument.getClass());\n\n        final Argument stringArgument = foreman.waffle(Object.class, \"I am a String!\", null);\n        assertSame(StringArgument.class, stringArgument.getClass());\n    }\n\n    @Test\n    public void testExplicitWaffling()\n    {\n        final Foreman foreman = new Foreman();\n\n        final Argument longArgument = foreman.waffle(Long.class, new Long(3L), null);\n        assertSame(LongArgument.class, longArgument.getClass());\n\n        final Argument shortArgument = foreman.waffle(short.class, (short) 2000, null);\n        assertSame(ShortArgument.class, shortArgument.getClass());\n\n        final Argument stringArgument = foreman.waffle(String.class, \"I am a String!\", null);\n        assertSame(StringArgument.class, stringArgument.getClass());\n    }\n\n    @Test\n    public void testPull88WeirdClassArgumentFactory()\n    {\n        final Foreman foreman = new Foreman();\n        foreman.register(new WeirdClassArgumentFactory());\n\n        // Pull Request #88 changes the outcome of this waffle call from ObjectArgument to WeirdArgument\n        // when using SqlStatement#bind(..., Object) and the Object is != null\n        assertEquals(WeirdArgument.class, foreman.waffle(Weird.class, new Weird(), null).getClass());\n\n        assertEquals(ObjectArgument.class, foreman.waffle(Object.class, new Weird(), null).getClass());\n    }\n\n    @Test\n    public void testPull88NullClassArgumentFactory()\n    {\n        final Foreman foreman = new Foreman();\n        foreman.register(new WeirdClassArgumentFactory());\n\n        assertEquals(WeirdArgument.class, foreman.waffle(Weird.class, null, null).getClass());\n        assertEquals(ObjectArgument.class, foreman.waffle(Object.class, null, null).getClass());\n    }\n\n    @Test\n    public void testPull88WeirdValueArgumentFactory()\n    {\n        final Foreman foreman = new Foreman();\n        foreman.register(new WeirdValueArgumentFactory());\n\n        // Pull Request #88 changes the outcome of this waffle call from ObjectArgument to WeirdArgument\n        // when using SqlStatement#bind(..., Object) and the Object is != null\n        assertEquals(WeirdArgument.class, foreman.waffle(Weird.class, new Weird(), null).getClass());\n        assertEquals(WeirdArgument.class, foreman.waffle(Object.class, new Weird(), null).getClass());\n    }\n\n    @Test\n    public void testPull88NullValueArgumentFactory()\n    {\n        final Foreman foreman = new Foreman();\n        foreman.register(new WeirdValueArgumentFactory());\n\n        assertEquals(ObjectArgument.class, foreman.waffle(Weird.class, null, null).getClass());\n        assertEquals(ObjectArgument.class, foreman.waffle(Object.class, null, null).getClass());\n    }\n\n    private static class Weird\n    {\n    }\n\n    private static class WeirdClassArgumentFactory implements ArgumentFactory<Weird>\n    {\n        @Override\n        public boolean accepts(Class<?> expectedType, Object value, StatementContext ctx)\n        {\n            return expectedType == Weird.class;\n        }\n\n        @Override\n        public Argument build(Class<?> expectedType, Weird value, StatementContext ctx)\n        {\n            return new WeirdArgument();\n        }\n    }\n\n    private static class WeirdValueArgumentFactory implements ArgumentFactory<Weird>\n    {\n        @Override\n        public boolean accepts(Class<?> expectedType, Object value, StatementContext ctx)\n        {\n            return value instanceof Weird;\n        }\n\n        @Override\n        public Argument build(Class<?> expectedType, Weird value, StatementContext ctx)\n        {\n            return new WeirdArgument();\n        }\n    }\n\n    private static class WeirdArgument implements Argument\n    {\n\n        @Override\n        public void apply(int position, PreparedStatement statement, StatementContext ctx) throws SQLException\n        {\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.verify;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Types;\n\nimport org.jdbi.v3.tweak.Argument;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnit;\nimport org.mockito.junit.MockitoRule;\n\npublic class TestForeman\n{\n    @Rule\n    public MockitoRule mockito = MockitoJUnit.rule();\n\n    private static final String I_AM_A_STRING = \"I am a String\";\n\n    private final Foreman foreman = new Foreman();\n\n    @Mock\n    public PreparedStatement stmt;\n\n    @Test\n    public void testWaffleLong() throws Exception\n    {\n        foreman.waffle(Object.class, new Long(3L), null).apply(1, stmt, null);\n        verify(stmt).setLong(1, 3);\n    }\n\n    @Test\n    public void testWaffleShort() throws Exception\n    {\n        foreman.waffle(Object.class, (short) 2000, null).apply(2, stmt, null);\n        verify(stmt).setShort(2, (short) 2000);\n    }\n\n    @Test\n    public void testWaffleString() throws Exception {\n        foreman.waffle(Object.class, I_AM_A_STRING, null).apply(3, stmt, null);\n        verify(stmt).setString(3, I_AM_A_STRING);\n    }\n\n    @Test\n    public void testExplicitWaffleLong() throws Exception {\n        foreman.waffle(Long.class, new Long(3L), null).apply(1, stmt, null);\n        verify(stmt).setLong(1, 3);\n    }\n\n    @Test\n    public void testExplicitWaffleShort() throws Exception {\n        foreman.waffle(short.class, (short) 2000, null).apply(2, stmt, null);\n        verify(stmt).setShort(2, (short) 2000);\n    }\n\n    @Test\n    public void testExplicitWaffleString() throws Exception {\n        foreman.waffle(String.class, I_AM_A_STRING, null).apply(3, stmt, null);\n        verify(stmt).setString(3, I_AM_A_STRING);\n    }\n\n    @Test\n    public void testPull88WeirdClassArgumentFactory() throws Exception\n    {\n        final Foreman foreman = new Foreman();\n        foreman.register(new WeirdClassArgumentFactory());\n\n        // Pull Request #88 changes the outcome of this waffle call from ObjectArgument to WeirdArgument\n        // when using SqlStatement#bind(..., Object) and the Object is != null\n        final Weird weird = new Weird();\n        assertEquals(WeirdArgument.class, foreman.waffle(Weird.class, weird, null).getClass());\n\n        foreman.waffle(Object.class, weird, null).apply(2, stmt, null);\n        verify(stmt).setObject(2, weird);\n    }\n\n    @Test\n    public void testPull88NullClassArgumentFactory() throws Exception\n    {\n        final Foreman foreman = new Foreman();\n        foreman.register(new WeirdClassArgumentFactory());\n\n        assertEquals(WeirdArgument.class, foreman.waffle(Weird.class, null, null).getClass());\n\n        foreman.waffle(Object.class, null, null).apply(3, stmt, null);\n        verify(stmt).setNull(3, Types.NULL);\n    }\n\n    @Test\n    public void testPull88WeirdValueArgumentFactory()\n    {\n        final Foreman foreman = new Foreman();\n        foreman.register(new WeirdValueArgumentFactory());\n\n        // Pull Request #88 changes the outcome of this waffle call from ObjectArgument to WeirdArgument\n        // when using SqlStatement#bind(..., Object) and the Object is != null\n        assertEquals(WeirdArgument.class, foreman.waffle(Weird.class, new Weird(), null).getClass());\n        assertEquals(WeirdArgument.class, foreman.waffle(Object.class, new Weird(), null).getClass());\n    }\n\n    @Test\n    public void testPull88NullValueArgumentFactory() throws Exception\n    {\n        final Foreman foreman = new Foreman();\n        foreman.register(new WeirdValueArgumentFactory());\n\n        foreman.waffle(Weird.class, null, null).apply(3, stmt, null);\n        verify(stmt).setNull(3, Types.NULL);\n\n        foreman.waffle(Object.class, null, null).apply(5, stmt, null);\n        verify(stmt).setNull(5, Types.NULL);\n    }\n\n    private static class Weird\n    {\n    }\n\n    private static class WeirdClassArgumentFactory implements ArgumentFactory<Weird>\n    {\n        @Override\n        public boolean accepts(Class<?> expectedType, Object value, StatementContext ctx)\n        {\n            return expectedType == Weird.class;\n        }\n\n        @Override\n        public Argument build(Class<?> expectedType, Weird value, StatementContext ctx)\n        {\n            return new WeirdArgument();\n        }\n    }\n\n    private static class WeirdValueArgumentFactory implements ArgumentFactory<Weird>\n    {\n        @Override\n        public boolean accepts(Class<?> expectedType, Object value, StatementContext ctx)\n        {\n            return value instanceof Weird;\n        }\n\n        @Override\n        public Argument build(Class<?> expectedType, Weird value, StatementContext ctx)\n        {\n            return new WeirdArgument();\n        }\n    }\n\n    private static class WeirdArgument implements Argument\n    {\n\n        @Override\n        public void apply(int position, PreparedStatement statement, StatementContext ctx) throws SQLException\n        {\n        }\n    }\n}\n","lineNo":89}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.lang.reflect.Field;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.TypeResolver;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.util.bean.ColumnNameMappingStrategy;\n\n\n/**\n * A result set mapper which maps the fields in a statement into an object. This uses\n * the reflection to set the fields on the object including its super class fields,\n * it does not support nested properties.\n *\n * The class must have a default constructor.\n */\npublic class FieldMapper<T> implements ResultSetMapper<T>\n{\n    private final Class<T> type;\n    private final ConcurrentMap<String, Optional<Field>> fieldByNameCache = new ConcurrentHashMap<>();\n    private final Collection<ColumnNameMappingStrategy> nameMappingStrategies;\n\n    public FieldMapper(Class<T> type)\n    {\n        this(type, BeanMapper.DEFAULT_STRATEGIES);\n    }\n\n    public FieldMapper(Class<T> type, Collection<ColumnNameMappingStrategy> nameMappingStrategies)\n    {\n        this.type = type;\n        this.nameMappingStrategies = Collections.unmodifiableList(new ArrayList<>(nameMappingStrategies));\n    }\n\n    @Override\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public T map(int row, ResultSet rs, StatementContext ctx)\n            throws SQLException\n    {\n        T bean;\n        try {\n            bean = type.newInstance();\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \" +\n                    \"which was not instantiable\", type.getName()), e);\n        }\n\n        ResultSetMetaData metadata = rs.getMetaData();\n        TypeResolver typeResolver = new TypeResolver();\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            String name = metadata.getColumnLabel(i).toLowerCase();\n\n            Optional<Field> maybeField = fieldByNameCache.computeIfAbsent(name, this::fieldByColumn);\n\n            if (!maybeField.isPresent()) {\n                continue;\n            }\n\n            final Field field = maybeField.get();\n            final ResolvedType type = typeResolver.resolve(field.getGenericType());\n            final Object value;\n            final ResultColumnMapper mapper = ctx.columnMapperFor(type);\n\n            if (mapper != null) {\n                value = mapper.mapColumn(rs, i, ctx);\n            }\n            else {\n                value = rs.getObject(i);\n            }\n\n            try\n            {\n                field.setAccessible(true);\n                field.set(bean, value);\n            }\n            catch (IllegalAccessException e) {\n                throw new IllegalArgumentException(String.format(\"Unable to access \" +\n                        \"property, %s\", name), e);\n            }\n        }\n\n        return bean;\n    }\n\n    private Optional<Field> fieldByColumn(String columnName)\n    {\n        Class<?> aClass = type;\n        while(aClass != null) {\n            for (Field field : aClass.getDeclaredFields()) {\n                for (ColumnNameMappingStrategy strategy : nameMappingStrategies) {\n                    if (strategy.nameMatches(field.getName(), columnName)) {\n                        return Optional.of(field);\n                    }\n                }\n            }\n            aClass = aClass.getSuperclass();\n        }\n        return Optional.empty();\n    }\n}\n\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.util.bean.ColumnNameMappingStrategy;\n\n/**\n * A result set mapper which maps the fields in a statement into an object. This uses\n * the reflection to set the fields on the object including its super class fields,\n * it does not support nested properties.\n *\n * The class must have a default constructor.\n */\npublic class FieldMapper<T> implements ResultSetMapper<T>\n{\n    private final Class<T> type;\n    private final ConcurrentMap<String, Optional<Field>> fieldByNameCache = new ConcurrentHashMap<>();\n    private final Collection<ColumnNameMappingStrategy> nameMappingStrategies;\n\n    public FieldMapper(Class<T> type)\n    {\n        this(type, BeanMapper.DEFAULT_STRATEGIES);\n    }\n\n    public FieldMapper(Class<T> type, Collection<ColumnNameMappingStrategy> nameMappingStrategies)\n    {\n        this.type = type;\n        this.nameMappingStrategies = Collections.unmodifiableList(new ArrayList<>(nameMappingStrategies));\n    }\n\n    @Override\n    @SuppressWarnings({\"rawtypes\"})\n    public T map(int row, ResultSet rs, StatementContext ctx)\n            throws SQLException\n    {\n        T bean;\n        try {\n            bean = type.newInstance();\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \" +\n                    \"which was not instantiable\", type.getName()), e);\n        }\n\n        ResultSetMetaData metadata = rs.getMetaData();\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            String name = metadata.getColumnLabel(i).toLowerCase();\n\n            Optional<Field> maybeField = fieldByNameCache.computeIfAbsent(name, this::fieldByColumn);\n\n            if (!maybeField.isPresent()) {\n                continue;\n            }\n\n            final Field field = maybeField.get();\n            final Type type = field.getGenericType();\n            final Object value;\n            final ResultColumnMapper mapper = ctx.columnMapperFor(type);\n\n            if (mapper != null) {\n                value = mapper.mapColumn(rs, i, ctx);\n            }\n            else {\n                value = rs.getObject(i);\n            }\n\n            try\n            {\n                field.setAccessible(true);\n                field.set(bean, value);\n            }\n            catch (IllegalAccessException e) {\n                throw new IllegalArgumentException(String.format(\"Unable to access \" +\n                        \"property, %s\", name), e);\n            }\n        }\n\n        return bean;\n    }\n\n    private Optional<Field> fieldByColumn(String columnName)\n    {\n        Class<?> aClass = type;\n        while(aClass != null) {\n            for (Field field : aClass.getDeclaredFields()) {\n                for (ColumnNameMappingStrategy strategy : nameMappingStrategies) {\n                    if (strategy.nameMatches(field.getName(), columnName)) {\n                        return Optional.of(field);\n                    }\n                }\n            }\n            aClass = aClass.getSuperclass();\n        }\n        return Optional.empty();\n    }\n}\n\n","lineNo":82}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.TypeResolver;\nimport org.jdbi.v3.StatementContext;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\n\nclass FigureItOutResultSetMapper implements ResultSetMapper<Object> {\n    @Override\n    public Object map(int index, ResultSet r, StatementContext ctx) throws SQLException {\n        Method m = ctx.getSqlObjectMethod();\n        ResolvedType type = new TypeResolver().resolve(m.getGenericReturnType());\n        GetGeneratedKeys ggk = m.getAnnotation(GetGeneratedKeys.class);\n        String keyColumn = ggk.columnName();\n\n        ResultColumnMapper<?> columnMapper = ctx.columnMapperFor(type);\n\n        if (\"\".equals(keyColumn)) {\n            return columnMapper.mapColumn(r, 1, ctx);\n        }\n\n        return columnMapper.mapColumn(r, keyColumn, ctx);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.jdbi.v3.StatementContext;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\n\nclass FigureItOutResultSetMapper implements ResultSetMapper<Object> {\n    @Override\n    public Object map(int index, ResultSet r, StatementContext ctx) throws SQLException {\n        Method m = ctx.getSqlObjectMethod();\n        Type type = m.getGenericReturnType();\n        GetGeneratedKeys ggk = m.getAnnotation(GetGeneratedKeys.class);\n        String keyColumn = ggk.columnName();\n\n        ResultColumnMapper<?> columnMapper = ctx.columnMapperFor(type);\n\n        if (\"\".equals(keyColumn)) {\n            return columnMapper.mapColumn(r, 1, ctx);\n        }\n\n        return columnMapper.mapColumn(r, keyColumn, ctx);\n    }\n}\n","lineNo":29}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport org.skife.jdbi.v2.SQLStatement;\n\nimport java.beans.BeanInfo;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nclass BindBeanFactory implements BinderFactory\n{\n    @Override\n    public Binder build(Annotation annotation)\n    {\n        return new Binder<BindBean, Object>()\n        {\n            @Override\n            public void bind(SQLStatement q, BindBean bind, Object arg)\n            {\n                final String prefix;\n                if (BindBean.BARE_BINDING.equals(bind.value())) {\n                    prefix = \"\";\n                }\n                else {\n                    prefix = bind.value() + \".\";\n                }\n\n                try {\n                    BeanInfo infos = Introspector.getBeanInfo(arg.getClass());\n                    PropertyDescriptor[] props = infos.getPropertyDescriptors();\n                    for (PropertyDescriptor prop : props) {\n                        Method readMethod = prop.getReadMethod();\n                        if (readMethod != null) {\n                            q.dynamicBind(readMethod.getReturnType(), prefix + prop.getName(), readMethod.invoke(arg));\n                        }\n                    }\n                }\n                catch (Exception e) {\n                    throw new IllegalStateException(\"unable to bind bean properties\", e);\n                }\n\n\n            }\n        };\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport org.skife.jdbi.v2.SQLStatement;\n\nimport java.beans.BeanInfo;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nclass BindBeanFactory implements BinderFactory\n{\n    @Override\n    public Binder build(Annotation annotation)\n    {\n        return new Binder<BindBean, Object>()\n        {\n            @Override\n            public void bind(SQLStatement q, BindBean bind, Object arg)\n            {\n                final String prefix;\n                if (BindBean.BARE_BINDING.equals(bind.value())) {\n                    prefix = \"\";\n                }\n                else {\n                    prefix = bind.value() + \".\";\n                }\n\n                try {\n                    Class<?> beanType = bind.type().equals(BindBean.Default.class)\n                        ? arg.getClass()\n                        : bind.type();\n\n                    BeanInfo infos = Introspector.getBeanInfo(beanType);\n                    PropertyDescriptor[] props = infos.getPropertyDescriptors();\n                    for (PropertyDescriptor prop : props) {\n                        Method readMethod = prop.getReadMethod();\n                        if (readMethod != null) {\n                            q.dynamicBind(readMethod.getReturnType(), prefix + prop.getName(), readMethod.invoke(arg));\n                        }\n                    }\n                }\n                catch (Exception e) {\n                    throw new IllegalStateException(\"unable to bind bean properties\", e);\n                }\n\n\n            }\n        };\n    }\n}\n","lineNo":43}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        return new Query<Map<String, Object>>(new Binding(),\n                                              new DefaultMapper(),\n                                              statementLocator,\n                                              statementRewriter,\n                                              this,\n                                              statementBuilder,\n                                              sql,\n                                              new ConcreteStatementContext(globalStatementAttributes, queryRegistry),\n                                              timingCollector,\n                                              Collections.<StatementCustomizer>emptyList(),\n                                              queryRegistry,\n                                              foreman.createChild(),\n                                              collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                          timingCollector,\n                          foreman,\n                          collectorFactoryRegistry);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        foreman,\n                collectorFactoryRegistry);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 foreman,\n                collectorFactoryRegistry);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                         timingCollector,\n                         foreman.createChild());\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name, new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory<?, ?> factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman),\n                          timingCollector,\n                          updateForeman,\n                          collectorFactoryRegistry);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        collectorFactoryRegistry);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 collectorFactoryRegistry);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory<?, ?> factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":84}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        return new Query<Map<String, Object>>(new Binding(),\n                                              new DefaultMapper(),\n                                              statementLocator,\n                                              statementRewriter,\n                                              this,\n                                              statementBuilder,\n                                              sql,\n                                              new ConcreteStatementContext(globalStatementAttributes, queryRegistry),\n                                              timingCollector,\n                                              Collections.<StatementCustomizer>emptyList(),\n                                              queryRegistry,\n                                              foreman.createChild(),\n                                              collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                          timingCollector,\n                          foreman,\n                          collectorFactoryRegistry);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        foreman,\n                collectorFactoryRegistry);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 foreman,\n                collectorFactoryRegistry);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                         timingCollector,\n                         foreman.createChild());\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name, new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory<?, ?> factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman),\n                          timingCollector,\n                          updateForeman,\n                          collectorFactoryRegistry);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        collectorFactoryRegistry);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 collectorFactoryRegistry);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory<?, ?> factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":247}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        return new Query<Map<String, Object>>(new Binding(),\n                                              new DefaultMapper(),\n                                              statementLocator,\n                                              statementRewriter,\n                                              this,\n                                              statementBuilder,\n                                              sql,\n                                              new ConcreteStatementContext(globalStatementAttributes, queryRegistry),\n                                              timingCollector,\n                                              Collections.<StatementCustomizer>emptyList(),\n                                              queryRegistry,\n                                              foreman.createChild(),\n                                              collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                          timingCollector,\n                          foreman,\n                          collectorFactoryRegistry);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        foreman,\n                collectorFactoryRegistry);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 foreman,\n                collectorFactoryRegistry);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                         timingCollector,\n                         foreman.createChild());\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name, new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory<?, ?> factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman),\n                          timingCollector,\n                          updateForeman,\n                          collectorFactoryRegistry);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        collectorFactoryRegistry);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 collectorFactoryRegistry);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory<?, ?> factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":262}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        return new Query<Map<String, Object>>(new Binding(),\n                                              new DefaultMapper(),\n                                              statementLocator,\n                                              statementRewriter,\n                                              this,\n                                              statementBuilder,\n                                              sql,\n                                              new ConcreteStatementContext(globalStatementAttributes, queryRegistry),\n                                              timingCollector,\n                                              Collections.<StatementCustomizer>emptyList(),\n                                              queryRegistry,\n                                              foreman.createChild(),\n                                              collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                          timingCollector,\n                          foreman,\n                          collectorFactoryRegistry);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        foreman,\n                collectorFactoryRegistry);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 foreman,\n                collectorFactoryRegistry);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                         timingCollector,\n                         foreman.createChild());\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name, new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory<?, ?> factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman),\n                          timingCollector,\n                          updateForeman,\n                          collectorFactoryRegistry);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        collectorFactoryRegistry);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 collectorFactoryRegistry);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory<?, ?> factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":295}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        return new Query<Map<String, Object>>(new Binding(),\n                                              new DefaultMapper(),\n                                              statementLocator,\n                                              statementRewriter,\n                                              this,\n                                              statementBuilder,\n                                              sql,\n                                              new ConcreteStatementContext(globalStatementAttributes, queryRegistry),\n                                              timingCollector,\n                                              Collections.<StatementCustomizer>emptyList(),\n                                              queryRegistry,\n                                              foreman.createChild(),\n                                              collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                          timingCollector,\n                          foreman,\n                          collectorFactoryRegistry);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        foreman,\n                collectorFactoryRegistry);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 foreman,\n                collectorFactoryRegistry);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)),\n                         timingCollector,\n                         foreman.createChild());\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name, new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry)));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory<?, ?> factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jdbi.v3.exceptions.UnableToCloseResourceException;\nimport org.jdbi.v3.exceptions.UnableToManipulateTransactionIsolationLevelException;\nimport org.jdbi.v3.tweak.ArgumentFactory;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.tweak.ResultSetMapper;\nimport org.jdbi.v3.tweak.StatementBuilder;\nimport org.jdbi.v3.tweak.StatementCustomizer;\nimport org.jdbi.v3.tweak.StatementLocator;\nimport org.jdbi.v3.tweak.StatementRewriter;\nimport org.jdbi.v3.tweak.TransactionHandler;\nimport org.jdbi.v3.tweak.CollectorFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass BasicHandle implements Handle\n{\n    private static final Logger LOG = LoggerFactory.getLogger(BasicHandle.class);\n\n    private StatementRewriter statementRewriter;\n    private StatementLocator  statementLocator;\n    private TimingCollector   timingCollector;\n    private StatementBuilder  statementBuilder;\n\n    private boolean closed = false;\n\n    private final Map<String, Object>      globalStatementAttributes;\n    private final MappingRegistry          mappingRegistry;\n    private final CollectorFactoryRegistry collectorFactoryRegistry;\n    private final Foreman                  foreman;\n    private final TransactionHandler       transactions;\n    private final Connection               connection;\n\n\n    BasicHandle(TransactionHandler transactions,\n                StatementLocator statementLocator,\n                StatementBuilder preparedStatementCache,\n                StatementRewriter statementRewriter,\n                Connection connection,\n                Map<String, Object> globalStatementAttributes,\n                TimingCollector timingCollector,\n                MappingRegistry mappingRegistry,\n                Foreman foreman,\n                CollectorFactoryRegistry collectorFactoryRegistry)\n    {\n        this.statementBuilder = preparedStatementCache;\n        this.statementRewriter = statementRewriter;\n        this.transactions = transactions;\n        this.connection = connection;\n        this.statementLocator = statementLocator;\n        this.timingCollector = timingCollector;\n        this.mappingRegistry = mappingRegistry;\n        this.foreman = foreman;\n        this.globalStatementAttributes = new HashMap<String, Object>();\n        this.globalStatementAttributes.putAll(globalStatementAttributes);\n        this.collectorFactoryRegistry = collectorFactoryRegistry.createChild();\n    }\n\n    @Override\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        MappingRegistry queryRegistry = MappingRegistry.copyOf(this.mappingRegistry);\n        Foreman queryForeman = foreman.createChild();\n        return new Query<>(\n                new Binding(),\n                new DefaultMapper(),\n                statementLocator,\n                statementRewriter,\n                this,\n                statementBuilder,\n                sql,\n                new ConcreteStatementContext(globalStatementAttributes, queryRegistry, queryForeman),\n                timingCollector,\n                Collections.<StatementCustomizer>emptyList(),\n                queryRegistry,\n                queryForeman,\n                collectorFactoryRegistry.createChild());\n    }\n\n    /**\n     * Get the JDBC Connection this Handle uses\n     *\n     * @return the JDBC Connection this Handle uses\n     */\n    @Override\n    public Connection getConnection()\n    {\n        return this.connection;\n    }\n\n    @Override\n    public void close()\n    {\n        if (!closed) {\n            try {\n                statementBuilder.close(getConnection());\n            } finally {\n                try {\n                    connection.close();\n                }\n                catch (SQLException e) {\n                    throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n                } finally {\n                    LOG.trace(\"Handle [{}] released\", this);\n                    closed = true;\n                }\n            }\n        }\n    }\n\n    boolean isClosed()\n    {\n        return closed;\n    }\n\n    @Override\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * Start a transaction\n     */\n    @Override\n    public Handle begin()\n    {\n        transactions.begin(this);\n        LOG.trace(\"Handle [{}] begin transaction\", this);\n        return this;\n    }\n\n    /**\n     * Commit a transaction\n     */\n    @Override\n    public Handle commit()\n    {\n        final long start = System.nanoTime();\n        transactions.commit(this);\n        LOG.trace(\"Handle [{}] commit transaction in {}ms\", this, (System.nanoTime() - start) / 1000000L);\n        return this;\n    }\n\n    /**\n     * Rollback a transaction\n     */\n    @Override\n    public Handle rollback()\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this);\n        LOG.trace(\"Handle [{}] rollback transaction in {}ms\", this, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    /**\n     * Create a transaction checkpoint (savepoint in JDBC terminology) with the name provided.\n     *\n     * @param name The name of the checkpoint\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle checkpoint(String name)\n    {\n        transactions.checkpoint(this, name);\n        LOG.trace(\"Handle [{}] checkpoint \\\"{}\\\"\", this, name);\n        return this;\n    }\n\n    /**\n     * Release the named checkpoint, making rollback to it not possible.\n     *\n     * @return The same handle\n     */\n    @Override\n    public Handle release(String checkpointName)\n    {\n        transactions.release(this, checkpointName);\n        LOG.trace(\"Handle [{}] release checkpoint \\\"{}\\\"\", this, checkpointName);\n        return this;\n    }\n\n    @Override\n    public void setStatementBuilder(StatementBuilder builder)\n    {\n        this.statementBuilder = builder;\n    }\n\n    @Override\n    public void setTimingCollector(final TimingCollector timingCollector)\n    {\n        if (timingCollector == null) {\n            this.timingCollector = TimingCollector.NOP_TIMING_COLLECTOR;\n        }\n        else {\n            this.timingCollector = timingCollector;\n        }\n    }\n\n\n    /**\n     * Rollback a transaction to a named checkpoint\n     *\n     * @param checkpointName the name of the checkpoint, previously declared with {@see Handle#checkpoint}\n     */\n    @Override\n    public Handle rollback(String checkpointName)\n    {\n        final long start = System.nanoTime();\n        transactions.rollback(this, checkpointName);\n        LOG.trace(\"Handle [{}] rollback to checkpoint \\\"{}\\\" in {}ms\", this, checkpointName, ((System.nanoTime() - start) / 1000000L));\n        return this;\n    }\n\n    @Override\n    public boolean isInTransaction()\n    {\n        return transactions.isInTransaction(this);\n    }\n\n    @Override\n    public Update createStatement(String sql)\n    {\n        Foreman updateForeman = foreman.createChild();\n        return new Update(this,\n                          statementLocator,\n                          statementRewriter,\n                          statementBuilder,\n                          sql,\n                          new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), updateForeman),\n                          timingCollector,\n                          updateForeman,\n                          collectorFactoryRegistry);\n    }\n\n    @Override\n    public Call createCall(String sql)\n    {\n        Foreman callForeman = foreman.createChild();\n        return new Call(this,\n                        statementLocator,\n                        statementRewriter,\n                        statementBuilder,\n                        sql,\n                        new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), callForeman),\n                        timingCollector,\n                        Collections.<StatementCustomizer>emptyList(),\n                        callForeman,\n                        collectorFactoryRegistry);\n    }\n\n    @Override\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    @Override\n    public int update(String sql, Object... args)\n    {\n        Update stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args) {\n            stmt.bind(position++, arg);\n        }\n        return stmt.execute();\n    }\n\n    @Override\n    public PreparedBatch prepareBatch(String sql)\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new PreparedBatch(statementLocator,\n                                 statementRewriter,\n                                 this,\n                                 statementBuilder,\n                                 sql,\n                                 new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                                 timingCollector,\n                                 Collections.<StatementCustomizer>emptyList(),\n                                 batchForeman,\n                                 collectorFactoryRegistry);\n    }\n\n    @Override\n    public Batch createBatch()\n    {\n        Foreman batchForeman = foreman.createChild();\n        return new Batch(this.statementRewriter,\n                         this.connection,\n                         new ConcreteStatementContext(globalStatementAttributes, MappingRegistry.copyOf(mappingRegistry), batchForeman),\n                         timingCollector,\n                         batchForeman);\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionCallback<ReturnType> callback)\n    {\n        return transactions.inTransaction(this, callback);\n    }\n\n    @Override\n    public void useTransaction(final TransactionConsumer callback)\n    {\n        transactions.inTransaction(this, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public <ReturnType> ReturnType inTransaction(TransactionIsolationLevel level,\n                                                 TransactionCallback<ReturnType> callback)\n    {\n        final TransactionIsolationLevel initial = getTransactionIsolationLevel();\n        boolean failed = true;\n        try {\n            setTransactionIsolation(level);\n\n            ReturnType result = transactions.inTransaction(this, level, callback);\n            failed = false;\n\n            return result;\n        }\n        finally {\n            try {\n                setTransactionIsolation(initial);\n            }\n            catch (RuntimeException e) {\n                if (! failed) {\n                    throw e;\n                }\n\n                // Ignore, there was already an exceptional condition and we don't want to clobber it.\n            }\n        }\n    }\n\n    @Override\n    public void useTransaction(TransactionIsolationLevel level, final TransactionConsumer callback)\n    {\n        inTransaction(level, (handle, status) -> {\n            callback.useTransaction(handle, status);\n            return null;\n        });\n    }\n\n    @Override\n    public List<Map<String, Object>> select(String sql, Object... args)\n    {\n        Query<Map<String, Object>> query = this.createQuery(sql);\n        int position = 0;\n        for (Object arg : args) {\n            query.bind(position++, arg);\n        }\n        return query.list();\n    }\n\n    @Override\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.statementLocator = locator;\n    }\n\n    @Override\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        this.statementRewriter = rewriter;\n    }\n\n    @Override\n    public Script createScript(String name)\n    {\n        return new Script(this, statementLocator, name,\n                new ConcreteStatementContext(\n                        globalStatementAttributes,\n                        MappingRegistry.copyOf(mappingRegistry),\n                        foreman.createChild()));\n    }\n\n    @Override\n    public void execute(String sql, Object... args)\n    {\n        this.update(sql, args);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapper<?> mapper)\n    {\n        mappingRegistry.addMapper(mapper);\n    }\n\n    @Override\n    public void registerMapper(ResultSetMapperFactory factory)\n    {\n        mappingRegistry.addMapper(factory);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapper<?> mapper) {\n        mappingRegistry.addColumnMapper(mapper);\n    }\n\n    @Override\n    public void registerColumnMapper(ResultColumnMapperFactory factory) {\n        mappingRegistry.addColumnMapper(factory);\n    }\n\n    @Override\n    public <SqlObjectType> SqlObjectType attach(Class<SqlObjectType> sqlObjectType)\n    {\n        return SqlObjectBuilderBridge.attach(this, sqlObjectType);\n    }\n\n    @Override\n    public void setTransactionIsolation(TransactionIsolationLevel level)\n    {\n        setTransactionIsolation(level.intValue());\n    }\n\n    @Override\n    public void setTransactionIsolation(int level)\n    {\n        try {\n            if (connection.getTransactionIsolation() == level) {\n                // already set, noop\n                return;\n            }\n            connection.setTransactionIsolation(level);\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(level, e);\n        }\n    }\n\n    @Override\n    public TransactionIsolationLevel getTransactionIsolationLevel()\n    {\n        try {\n            return TransactionIsolationLevel.valueOf(connection.getTransactionIsolation());\n        }\n        catch (SQLException e) {\n            throw new UnableToManipulateTransactionIsolationLevelException(\"unable to access current setting\", e);\n        }\n    }\n\n    @Override\n    public void registerArgumentFactory(ArgumentFactory<?> argumentFactory)\n    {\n        this.foreman.register(argumentFactory);\n    }\n\n    @Override\n    public void registerCollectorFactory(CollectorFactory<?, ?> factory) {\n        this.collectorFactoryRegistry.register(factory);\n    }\n}\n","lineNo":311}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.util.BigDecimalColumnMapper;\nimport org.jdbi.v3.util.BooleanColumnMapper;\nimport org.jdbi.v3.util.ByteArrayColumnMapper;\nimport org.jdbi.v3.util.ByteColumnMapper;\nimport org.jdbi.v3.util.DoubleColumnMapper;\nimport org.jdbi.v3.util.EnumColumnMapper;\nimport org.jdbi.v3.util.FloatColumnMapper;\nimport org.jdbi.v3.util.IntegerColumnMapper;\nimport org.jdbi.v3.util.LongColumnMapper;\nimport org.jdbi.v3.util.ShortColumnMapper;\nimport org.jdbi.v3.util.StringColumnMapper;\nimport org.jdbi.v3.util.TimestampColumnMapper;\nimport org.jdbi.v3.util.URLColumnMapper;\n\n/**\n * Result column mapper factory which knows how to map standard JDBC-recognized types.\n */\npublic class PrimitivesColumnMapperFactory implements ResultColumnMapperFactory {\n    private static final Map<Class<?>, ResultColumnMapper<?>> mappers = new HashMap<>();\n\n    static {\n        mappers.put(boolean.class, BooleanColumnMapper.PRIMITIVE);\n        mappers.put(byte.class, ByteColumnMapper.PRIMITIVE);\n        mappers.put(short.class, ShortColumnMapper.PRIMITIVE);\n        mappers.put(int.class, IntegerColumnMapper.PRIMITIVE);\n        mappers.put(long.class, LongColumnMapper.PRIMITIVE);\n        mappers.put(float.class, FloatColumnMapper.PRIMITIVE);\n        mappers.put(double.class, DoubleColumnMapper.PRIMITIVE);\n\n        mappers.put(Boolean.class, BooleanColumnMapper.WRAPPER);\n        mappers.put(Byte.class, ByteColumnMapper.WRAPPER);\n        mappers.put(Short.class, ShortColumnMapper.WRAPPER);\n        mappers.put(Integer.class, IntegerColumnMapper.WRAPPER);\n        mappers.put(Long.class, LongColumnMapper.WRAPPER);\n        mappers.put(Float.class, FloatColumnMapper.WRAPPER);\n        mappers.put(Double.class, DoubleColumnMapper.WRAPPER);\n\n        mappers.put(BigDecimal.class, BigDecimalColumnMapper.INSTANCE);\n\n        mappers.put(String.class, StringColumnMapper.INSTANCE);\n\n        mappers.put(byte[].class, ByteArrayColumnMapper.INSTANCE);\n\n        mappers.put(Timestamp.class, TimestampColumnMapper.INSTANCE);\n\n        mappers.put(URL.class, URLColumnMapper.INSTANCE);\n    }\n\n    @Override\n    public boolean accepts(Class<?> type, StatementContext ctx) {\n        return type.isEnum() || mappers.containsKey(type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> ResultColumnMapper<? extends T> columnMapperFor(Class<T> type, StatementContext ctx) {\n        if (type.isEnum()) {\n            return (ResultColumnMapper<? extends T>) EnumColumnMapper.byName(type.asSubclass(Enum.class));\n        }\n        return (ResultColumnMapper<? extends T>) mappers.get(type);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.google.common.reflect.TypeToken;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.util.BigDecimalColumnMapper;\nimport org.jdbi.v3.util.BooleanColumnMapper;\nimport org.jdbi.v3.util.ByteArrayColumnMapper;\nimport org.jdbi.v3.util.ByteColumnMapper;\nimport org.jdbi.v3.util.DoubleColumnMapper;\nimport org.jdbi.v3.util.EnumColumnMapper;\nimport org.jdbi.v3.util.FloatColumnMapper;\nimport org.jdbi.v3.util.IntegerColumnMapper;\nimport org.jdbi.v3.util.LongColumnMapper;\nimport org.jdbi.v3.util.ShortColumnMapper;\nimport org.jdbi.v3.util.StringColumnMapper;\nimport org.jdbi.v3.util.TimestampColumnMapper;\nimport org.jdbi.v3.util.URLColumnMapper;\n\n/**\n * Result column mapper factory which knows how to map standard JDBC-recognized types.\n */\npublic class PrimitivesColumnMapperFactory implements ResultColumnMapperFactory {\n    private static final Map<Class<?>, ResultColumnMapper<?>> mappers = new HashMap<>();\n\n    static {\n        mappers.put(boolean.class, BooleanColumnMapper.PRIMITIVE);\n        mappers.put(byte.class, ByteColumnMapper.PRIMITIVE);\n        mappers.put(short.class, ShortColumnMapper.PRIMITIVE);\n        mappers.put(int.class, IntegerColumnMapper.PRIMITIVE);\n        mappers.put(long.class, LongColumnMapper.PRIMITIVE);\n        mappers.put(float.class, FloatColumnMapper.PRIMITIVE);\n        mappers.put(double.class, DoubleColumnMapper.PRIMITIVE);\n\n        mappers.put(Boolean.class, BooleanColumnMapper.WRAPPER);\n        mappers.put(Byte.class, ByteColumnMapper.WRAPPER);\n        mappers.put(Short.class, ShortColumnMapper.WRAPPER);\n        mappers.put(Integer.class, IntegerColumnMapper.WRAPPER);\n        mappers.put(Long.class, LongColumnMapper.WRAPPER);\n        mappers.put(Float.class, FloatColumnMapper.WRAPPER);\n        mappers.put(Double.class, DoubleColumnMapper.WRAPPER);\n\n        mappers.put(BigDecimal.class, BigDecimalColumnMapper.INSTANCE);\n\n        mappers.put(String.class, StringColumnMapper.INSTANCE);\n\n        mappers.put(byte[].class, ByteArrayColumnMapper.INSTANCE);\n\n        mappers.put(Timestamp.class, TimestampColumnMapper.INSTANCE);\n\n        mappers.put(URL.class, URLColumnMapper.INSTANCE);\n    }\n\n    @Override\n    public boolean accepts(TypeToken<?> type, StatementContext ctx) {\n        Class<?> rawType = type.getRawType();\n        return rawType.isEnum() || mappers.containsKey(rawType);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> ResultColumnMapper<? extends T> columnMapperFor(TypeToken<T> type, StatementContext ctx) {\n        Class<? super T> rawType = type.getRawType();\n        if (rawType.isEnum()) {\n            return (ResultColumnMapper<? extends T>) EnumColumnMapper.byName(\n                    (Class<? extends Enum>) rawType.asSubclass(Enum.class));\n        }\n        return (ResultColumnMapper<? extends T>) mappers.get(rawType);\n    }\n}\n","lineNo":74}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.util.BigDecimalColumnMapper;\nimport org.jdbi.v3.util.BooleanColumnMapper;\nimport org.jdbi.v3.util.ByteArrayColumnMapper;\nimport org.jdbi.v3.util.ByteColumnMapper;\nimport org.jdbi.v3.util.DoubleColumnMapper;\nimport org.jdbi.v3.util.EnumColumnMapper;\nimport org.jdbi.v3.util.FloatColumnMapper;\nimport org.jdbi.v3.util.IntegerColumnMapper;\nimport org.jdbi.v3.util.LongColumnMapper;\nimport org.jdbi.v3.util.ShortColumnMapper;\nimport org.jdbi.v3.util.StringColumnMapper;\nimport org.jdbi.v3.util.TimestampColumnMapper;\nimport org.jdbi.v3.util.URLColumnMapper;\n\n/**\n * Result column mapper factory which knows how to map standard JDBC-recognized types.\n */\npublic class PrimitivesColumnMapperFactory implements ResultColumnMapperFactory {\n    private static final Map<Class<?>, ResultColumnMapper<?>> mappers = new HashMap<>();\n\n    static {\n        mappers.put(boolean.class, BooleanColumnMapper.PRIMITIVE);\n        mappers.put(byte.class, ByteColumnMapper.PRIMITIVE);\n        mappers.put(short.class, ShortColumnMapper.PRIMITIVE);\n        mappers.put(int.class, IntegerColumnMapper.PRIMITIVE);\n        mappers.put(long.class, LongColumnMapper.PRIMITIVE);\n        mappers.put(float.class, FloatColumnMapper.PRIMITIVE);\n        mappers.put(double.class, DoubleColumnMapper.PRIMITIVE);\n\n        mappers.put(Boolean.class, BooleanColumnMapper.WRAPPER);\n        mappers.put(Byte.class, ByteColumnMapper.WRAPPER);\n        mappers.put(Short.class, ShortColumnMapper.WRAPPER);\n        mappers.put(Integer.class, IntegerColumnMapper.WRAPPER);\n        mappers.put(Long.class, LongColumnMapper.WRAPPER);\n        mappers.put(Float.class, FloatColumnMapper.WRAPPER);\n        mappers.put(Double.class, DoubleColumnMapper.WRAPPER);\n\n        mappers.put(BigDecimal.class, BigDecimalColumnMapper.INSTANCE);\n\n        mappers.put(String.class, StringColumnMapper.INSTANCE);\n\n        mappers.put(byte[].class, ByteArrayColumnMapper.INSTANCE);\n\n        mappers.put(Timestamp.class, TimestampColumnMapper.INSTANCE);\n\n        mappers.put(URL.class, URLColumnMapper.INSTANCE);\n    }\n\n    @Override\n    public boolean accepts(Class<?> type, StatementContext ctx) {\n        return type.isEnum() || mappers.containsKey(type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> ResultColumnMapper<? extends T> columnMapperFor(Class<T> type, StatementContext ctx) {\n        if (type.isEnum()) {\n            return (ResultColumnMapper<? extends T>) EnumColumnMapper.byName(type.asSubclass(Enum.class));\n        }\n        return (ResultColumnMapper<? extends T>) mappers.get(type);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.google.common.reflect.TypeToken;\nimport org.jdbi.v3.tweak.ResultColumnMapper;\nimport org.jdbi.v3.util.BigDecimalColumnMapper;\nimport org.jdbi.v3.util.BooleanColumnMapper;\nimport org.jdbi.v3.util.ByteArrayColumnMapper;\nimport org.jdbi.v3.util.ByteColumnMapper;\nimport org.jdbi.v3.util.DoubleColumnMapper;\nimport org.jdbi.v3.util.EnumColumnMapper;\nimport org.jdbi.v3.util.FloatColumnMapper;\nimport org.jdbi.v3.util.IntegerColumnMapper;\nimport org.jdbi.v3.util.LongColumnMapper;\nimport org.jdbi.v3.util.ShortColumnMapper;\nimport org.jdbi.v3.util.StringColumnMapper;\nimport org.jdbi.v3.util.TimestampColumnMapper;\nimport org.jdbi.v3.util.URLColumnMapper;\n\n/**\n * Result column mapper factory which knows how to map standard JDBC-recognized types.\n */\npublic class PrimitivesColumnMapperFactory implements ResultColumnMapperFactory {\n    private static final Map<Class<?>, ResultColumnMapper<?>> mappers = new HashMap<>();\n\n    static {\n        mappers.put(boolean.class, BooleanColumnMapper.PRIMITIVE);\n        mappers.put(byte.class, ByteColumnMapper.PRIMITIVE);\n        mappers.put(short.class, ShortColumnMapper.PRIMITIVE);\n        mappers.put(int.class, IntegerColumnMapper.PRIMITIVE);\n        mappers.put(long.class, LongColumnMapper.PRIMITIVE);\n        mappers.put(float.class, FloatColumnMapper.PRIMITIVE);\n        mappers.put(double.class, DoubleColumnMapper.PRIMITIVE);\n\n        mappers.put(Boolean.class, BooleanColumnMapper.WRAPPER);\n        mappers.put(Byte.class, ByteColumnMapper.WRAPPER);\n        mappers.put(Short.class, ShortColumnMapper.WRAPPER);\n        mappers.put(Integer.class, IntegerColumnMapper.WRAPPER);\n        mappers.put(Long.class, LongColumnMapper.WRAPPER);\n        mappers.put(Float.class, FloatColumnMapper.WRAPPER);\n        mappers.put(Double.class, DoubleColumnMapper.WRAPPER);\n\n        mappers.put(BigDecimal.class, BigDecimalColumnMapper.INSTANCE);\n\n        mappers.put(String.class, StringColumnMapper.INSTANCE);\n\n        mappers.put(byte[].class, ByteArrayColumnMapper.INSTANCE);\n\n        mappers.put(Timestamp.class, TimestampColumnMapper.INSTANCE);\n\n        mappers.put(URL.class, URLColumnMapper.INSTANCE);\n    }\n\n    @Override\n    public boolean accepts(TypeToken<?> type, StatementContext ctx) {\n        Class<?> rawType = type.getRawType();\n        return rawType.isEnum() || mappers.containsKey(rawType);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> ResultColumnMapper<? extends T> columnMapperFor(TypeToken<T> type, StatementContext ctx) {\n        Class<? super T> rawType = type.getRawType();\n        if (rawType.isEnum()) {\n            return (ResultColumnMapper<? extends T>) EnumColumnMapper.byName(\n                    (Class<? extends Enum>) rawType.asSubclass(Enum.class));\n        }\n        return (ResultColumnMapper<? extends T>) mappers.get(rawType);\n    }\n}\n","lineNo":81}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.lang.reflect.Constructor;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\n\nimport org.jdbi.v3.tweak.Argument;\nimport org.jdbi.v3.tweak.ArgumentFactory;\n\npublic class BuiltInArgumentFactory<T> implements ArgumentFactory<T> {\n\n    public static final ArgumentFactory<?> INSTANCE = new BuiltInArgumentFactory<Object>();\n\n    private static final Map<Class<?>, P> b = new IdentityHashMap<>();\n\n    static {\n        b.put(BigDecimal.class, new P(BigDecimalArgument.class));\n        b.put(Blob.class, new P(BlobArgument.class));\n        b.put(Boolean.class, new P(BooleanArgument.class));\n        b.put(boolean.class, new P(BooleanArgument.class));\n        b.put(Byte.class, new P(ByteArgument.class));\n        b.put(byte.class, new P(ByteArgument.class));\n        b.put(byte[].class, new P(ByteArrayArgument.class));\n        b.put(Character.class, new P(CharacterArgument.class));\n        b.put(char.class, new P(CharacterArgument.class));\n        b.put(Clob.class, new P(ClobArgument.class));\n        b.put(Double.class, new P(DoubleArgument.class));\n        b.put(double.class, new P(DoubleArgument.class));\n        b.put(Float.class, new P(FloatArgument.class));\n        b.put(float.class, new P(FloatArgument.class));\n        b.put(Integer.class, new P(IntegerArgument.class));\n        b.put(int.class, new P(IntegerArgument.class));\n        b.put(java.util.Date.class, new P(JavaDateArgument.class));\n        b.put(Long.class, new P(LongArgument.class));\n        b.put(long.class, new P(LongArgument.class));\n        b.put(Object.class, new P(ObjectArgument.class));\n        b.put(Short.class, new P(ShortArgument.class));\n        b.put(short.class, new P(ShortArgument.class));\n        b.put(java.sql.Date.class, new P(SqlDateArgument.class));\n        b.put(String.class, new P(StringArgument.class));\n        b.put(Time.class, new P(TimeArgument.class));\n        b.put(Timestamp.class, new P(TimestampArgument.class));\n        b.put(URL.class, new P(URLArgument.class));\n    }\n\n    @Override\n    public boolean accepts(Class<?> expectedType, Object value, StatementContext ctx)\n    {\n        return b.containsKey(expectedType) || value == null || value.getClass().isEnum();\n    }\n\n    @Override\n    public Argument build(Class<?> expectedType, T value, StatementContext ctx)\n    {\n        P p = b.get(expectedType);\n\n        if (value != null && expectedType == Object.class) {\n            P v = b.get(value.getClass());\n            if (v != null) {\n                return v.build(value);\n            }\n\n            if (value.getClass().isEnum()) {\n                return new StringArgument(((Enum<?>)value).name());\n            }\n        }\n\n        if (p != null) {\n            return p.build(value);\n        }\n\n        // Enums must be bound as VARCHAR.\n        if (expectedType.isEnum()) {\n            return new StringArgument(value.toString());\n        }\n\n        // Fallback to generic ObjectArgument\n        return new ObjectArgument(value);\n    }\n\n    private static class P\n    {\n        private final Constructor<?> ctor;\n        P(Class<? extends Argument> argType)\n        {\n            this.ctor = argType.getDeclaredConstructors()[0];\n        }\n\n        public Argument build(Object value)\n        {\n            try {\n                return (Argument) ctor.newInstance(value);\n            }\n            catch (Exception e) {\n                throw new IllegalStateException(e);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3;\n\nimport java.lang.reflect.Constructor;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\n\nimport com.google.common.reflect.TypeToken;\nimport org.jdbi.v3.tweak.Argument;\nimport org.jdbi.v3.tweak.ArgumentFactory;\n\npublic class BuiltInArgumentFactory<T> implements ArgumentFactory<T> {\n\n    public static final ArgumentFactory<?> INSTANCE = new BuiltInArgumentFactory<Object>();\n\n    private static final Map<Class<?>, P> b = new IdentityHashMap<>();\n\n    static {\n        b.put(BigDecimal.class, new P(BigDecimalArgument.class));\n        b.put(Blob.class, new P(BlobArgument.class));\n        b.put(Boolean.class, new P(BooleanArgument.class));\n        b.put(boolean.class, new P(BooleanArgument.class));\n        b.put(Byte.class, new P(ByteArgument.class));\n        b.put(byte.class, new P(ByteArgument.class));\n        b.put(byte[].class, new P(ByteArrayArgument.class));\n        b.put(Character.class, new P(CharacterArgument.class));\n        b.put(char.class, new P(CharacterArgument.class));\n        b.put(Clob.class, new P(ClobArgument.class));\n        b.put(Double.class, new P(DoubleArgument.class));\n        b.put(double.class, new P(DoubleArgument.class));\n        b.put(Float.class, new P(FloatArgument.class));\n        b.put(float.class, new P(FloatArgument.class));\n        b.put(Integer.class, new P(IntegerArgument.class));\n        b.put(int.class, new P(IntegerArgument.class));\n        b.put(java.util.Date.class, new P(JavaDateArgument.class));\n        b.put(Long.class, new P(LongArgument.class));\n        b.put(long.class, new P(LongArgument.class));\n        b.put(Object.class, new P(ObjectArgument.class));\n        b.put(Short.class, new P(ShortArgument.class));\n        b.put(short.class, new P(ShortArgument.class));\n        b.put(java.sql.Date.class, new P(SqlDateArgument.class));\n        b.put(String.class, new P(StringArgument.class));\n        b.put(Time.class, new P(TimeArgument.class));\n        b.put(Timestamp.class, new P(TimestampArgument.class));\n        b.put(URL.class, new P(URLArgument.class));\n    }\n\n    @Override\n    public boolean accepts(TypeToken<?> expectedType, Object value, StatementContext ctx)\n    {\n        return b.containsKey(expectedType.getRawType()) || value == null || value.getClass().isEnum();\n    }\n\n    @Override\n    public Argument build(TypeToken<?> expectedType, T value, StatementContext ctx)\n    {\n        Class<?> expectedClass = expectedType.getRawType();\n        P p = b.get(expectedClass);\n\n        if (value != null && expectedClass == Object.class) {\n            P v = b.get(value.getClass());\n            if (v != null) {\n                return v.build(value);\n            }\n\n            if (value.getClass().isEnum()) {\n                return new StringArgument(((Enum<?>)value).name());\n            }\n        }\n\n        if (p != null) {\n            return p.build(value);\n        }\n\n        // Enums must be bound as VARCHAR.\n        if (expectedClass.isEnum()) {\n            return new StringArgument(value.toString());\n        }\n\n        // Fallback to generic ObjectArgument\n        return new ObjectArgument(value);\n    }\n\n    private static class P\n    {\n        private final Constructor<?> ctor;\n        P(Class<? extends Argument> argType)\n        {\n            this.ctor = argType.getDeclaredConstructors()[0];\n        }\n\n        public Argument build(Object value)\n        {\n            try {\n                return (Argument) ctor.newInstance(value);\n            }\n            catch (Exception e) {\n                throw new IllegalStateException(e);\n            }\n        }\n    }\n}\n","lineNo":75}
{"Smelly Sample":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.Closeable;\nimport java.util.UUID;\n\nimport org.h2.jdbcx.JdbcDataSource;\nimport org.jdbi.v3.DBI;\nimport org.jdbi.v3.Handle;\nimport org.jdbi.v3.Something;\nimport org.jdbi.v3.sqlobject.mixins.GetHandle;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\npublic class TestNewApiOnDbiAndHandle\n{\n    private DBI    dbi;\n    private Handle handle;\n\n    @Before\n    public void setUp() throws Exception\n    {\n        JdbcDataSource ds = new JdbcDataSource();\n        ds.setURL(\"jdbc:h2:mem:\" + UUID.randomUUID());\n        dbi = new DBI(ds);\n        dbi.registerMapper(new SomethingMapper());\n        handle = dbi.open();\n\n        handle.execute(\"create table something (id int primary key, name varchar(100))\");\n    }\n\n    @After\n    public void tearDown() throws Exception\n    {\n        handle.execute(\"drop table something\");\n        handle.close();\n    }\n\n    @Test\n    public void testOpenNewSpiffy() throws Exception\n    {\n        Spiffy spiffy = SqlObjectBuilder.open(dbi, Spiffy.class);\n        try {\n            spiffy.insert(new Something(1, \"Tim\"));\n            spiffy.insert(new Something(2, \"Diego\"));\n\n            assertEquals(\"Diego\", spiffy.findNameById(2));\n        }\n        finally {\n            spiffy.close();\n        }\n        assertTrue(spiffy.getHandle().getConnection().isClosed());\n    }\n\n    @Test\n    public void testOnDemandSpiffy() throws Exception\n    {\n        Spiffy spiffy = SqlObjectBuilder.attach(handle, Spiffy.class);\n\n        spiffy.insert(new Something(1, \"Tim\"));\n        spiffy.insert(new Something(2, \"Diego\"));\n\n        assertEquals(\"Diego\", spiffy.findNameById(2));\n    }\n\n    @Test\n    public void testAttach() throws Exception\n    {\n        Spiffy spiffy = SqlObjectBuilder.attach(handle, Spiffy.class);\n\n        spiffy.insert(new Something(1, \"Tim\"));\n        spiffy.insert(new Something(2, \"Diego\"));\n\n        assertEquals(\"Diego\", spiffy.findNameById(2));\n    }\n\n\n    static interface Spiffy extends GetHandle, Closeable\n    {\n        @SqlUpdate(\"insert into something (id, name) values (:it.id, :it.name)\")\n        void insert(@Bind(value = \"it\", binder = SomethingBinderAgainstBind.class) Something s);\n\n        @SqlQuery(\"select name from something where id = :id\")\n        String findNameById(@Bind(\"id\") int id);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.Closeable;\nimport java.sql.Connection;\nimport java.util.UUID;\n\nimport org.h2.jdbcx.JdbcDataSource;\nimport org.jdbi.v3.DBI;\nimport org.jdbi.v3.Handle;\nimport org.jdbi.v3.Something;\nimport org.jdbi.v3.sqlobject.mixins.GetHandle;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\npublic class TestNewApiOnDbiAndHandle\n{\n    private DBI    dbi;\n    private Handle handle;\n\n    @Before\n    public void setUp() throws Exception\n    {\n        JdbcDataSource ds = new JdbcDataSource();\n        ds.setURL(\"jdbc:h2:mem:\" + UUID.randomUUID());\n        dbi = new DBI(ds);\n        dbi.registerMapper(new SomethingMapper());\n        handle = dbi.open();\n\n        handle.execute(\"create table something (id int primary key, name varchar(100))\");\n    }\n\n    @After\n    public void tearDown() throws Exception\n    {\n        handle.execute(\"drop table something\");\n        handle.close();\n    }\n\n    @Test\n    public void testOpenNewSpiffy() throws Exception\n    {\n        final Connection c;\n        try (Spiffy spiffy = SqlObjectBuilder.open(dbi, Spiffy.class)) {\n            spiffy.insert(new Something(1, \"Tim\"));\n            spiffy.insert(new Something(2, \"Diego\"));\n\n            assertEquals(\"Diego\", spiffy.findNameById(2));\n            c = spiffy.getHandle().getConnection();\n        }\n        assertTrue(c.isClosed());\n    }\n\n    @Test\n    public void testOnDemandSpiffy() throws Exception\n    {\n        Spiffy spiffy = SqlObjectBuilder.attach(handle, Spiffy.class);\n\n        spiffy.insert(new Something(1, \"Tim\"));\n        spiffy.insert(new Something(2, \"Diego\"));\n\n        assertEquals(\"Diego\", spiffy.findNameById(2));\n    }\n\n    @Test\n    public void testAttach() throws Exception\n    {\n        Spiffy spiffy = SqlObjectBuilder.attach(handle, Spiffy.class);\n\n        spiffy.insert(new Something(1, \"Tim\"));\n        spiffy.insert(new Something(2, \"Diego\"));\n\n        assertEquals(\"Diego\", spiffy.findNameById(2));\n    }\n\n\n    static interface Spiffy extends GetHandle, Closeable\n    {\n        @SqlUpdate(\"insert into something (id, name) values (:it.id, :it.name)\")\n        void insert(@Bind(value = \"it\", binder = SomethingBinderAgainstBind.class) Something s);\n\n        @SqlQuery(\"select name from something where id = :id\")\n        String findNameById(@Bind(\"id\") int id);\n    }\n}\n","lineNo":60}
{"Smelly Sample":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.math.BigDecimal;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A result set mapper which maps the fields in a statement into a JavaBean. This uses\n * the JDK's built in bean mapping facilities, so it does not support nested properties.\n */\npublic class BeanMapper<T> implements ResultSetMapper<T>\n{\n    private final Class<T> type;\n    private final Map<String, PropertyDescriptor> properties = new HashMap<String, PropertyDescriptor>();\n\n    public BeanMapper(Class<T> type)\n    {\n        this.type = type;\n        try {\n            BeanInfo info = Introspector.getBeanInfo(type);\n\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors()) {\n                properties.put(descriptor.getName().toLowerCase(), descriptor);\n            }\n        }\n        catch (IntrospectionException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public T map(int row, ResultSet rs, StatementContext ctx)\n        throws SQLException\n    {\n        T bean;\n        try {\n            bean = type.newInstance();\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \" +\n                                                             \"which was not instantiable\", type.getName()), e);\n        }\n\n        ResultSetMetaData metadata = rs.getMetaData();\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            String name = metadata.getColumnLabel(i).toLowerCase();\n\n            PropertyDescriptor descriptor = properties.get(name);\n\n            if (descriptor != null) {\n                Class type = descriptor.getPropertyType();\n\n                Object value;\n\n                if (type.isAssignableFrom(Boolean.class) || type.isAssignableFrom(boolean.class)) {\n                    value = rs.getBoolean(i);\n                }\n                else if (type.isAssignableFrom(Byte.class) || type.isAssignableFrom(byte.class)) {\n                    value = rs.getByte(i);\n                }\n                else if (type.isAssignableFrom(Short.class) || type.isAssignableFrom(short.class)) {\n                    value = rs.getShort(i);\n                }\n                else if (type.isAssignableFrom(Integer.class) || type.isAssignableFrom(int.class)) {\n                    value = rs.getInt(i);\n                }\n                else if (type.isAssignableFrom(Long.class) || type.isAssignableFrom(long.class)) {\n                    value = rs.getLong(i);\n                }\n                else if (type.isAssignableFrom(Float.class) || type.isAssignableFrom(float.class)) {\n                    value = rs.getFloat(i);\n                }\n                else if (type.isAssignableFrom(Double.class) || type.isAssignableFrom(double.class)) {\n                    value = rs.getDouble(i);\n                }\n                else if (type.isAssignableFrom(BigDecimal.class)) {\n                    value = rs.getBigDecimal(i);\n                }\n                else if (type.isAssignableFrom(Timestamp.class)) {\n                    value = rs.getTimestamp(i);\n                }\n                else if (type.isAssignableFrom(Time.class)) {\n                    value = rs.getTime(i);\n                }\n                else if (type.isAssignableFrom(Date.class)) {\n                    value = rs.getDate(i);\n                }\n                else if (type.isAssignableFrom(String.class)) {\n                    value = rs.getString(i);\n                }\n                else if (type.isEnum()) {\n                    value = Enum.valueOf(type, rs.getString(i));\n                }\n                else {\n                    value = rs.getObject(i);\n                }\n\n                if (rs.wasNull() && !type.isPrimitive()) {\n                    value = null;\n                }\n\n                try\n                {\n                    descriptor.getWriteMethod().invoke(bean, value);\n                }\n                catch (IllegalAccessException e) {\n                    throw new IllegalArgumentException(String.format(\"Unable to access setter for \" +\n                                                                     \"property, %s\", name), e);\n                }\n                catch (InvocationTargetException e) {\n                    throw new IllegalArgumentException(String.format(\"Invocation target exception trying to \" +\n                                                                     \"invoker setter for the %s property\", name), e);\n                }\n                catch (NullPointerException e) {\n                    throw new IllegalArgumentException(String.format(\"No appropriate method to \" +\n                                                                     \"write property %s\", name), e);\n                }\n\n            }\n        }\n\n        return bean;\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.math.BigDecimal;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A result set mapper which maps the fields in a statement into a JavaBean. This uses\n * the JDK's built in bean mapping facilities, so it does not support nested properties.\n */\npublic class BeanMapper<T> implements ResultSetMapper<T>\n{\n    private final Class<T> type;\n    private final Map<String, PropertyDescriptor> properties = new HashMap<String, PropertyDescriptor>();\n\n    public BeanMapper(Class<T> type)\n    {\n        this.type = type;\n        try {\n            BeanInfo info = Introspector.getBeanInfo(type);\n\n            for (PropertyDescriptor descriptor : info.getPropertyDescriptors()) {\n                properties.put(descriptor.getName().toLowerCase(), descriptor);\n            }\n        }\n        catch (IntrospectionException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public T map(int row, ResultSet rs, StatementContext ctx)\n        throws SQLException\n    {\n        T bean;\n        try {\n            bean = type.newInstance();\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \" +\n                                                             \"which was not instantiable\", type.getName()), e);\n        }\n\n        ResultSetMetaData metadata = rs.getMetaData();\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            String name = metadata.getColumnLabel(i).toLowerCase();\n\n            PropertyDescriptor descriptor = properties.get(name);\n\n            if (descriptor != null) {\n                Class type = descriptor.getPropertyType();\n\n                Object value;\n\n                if (type.isAssignableFrom(Boolean.class) || type.isAssignableFrom(boolean.class)) {\n                    value = rs.getBoolean(i);\n                }\n                else if (type.isAssignableFrom(Byte.class) || type.isAssignableFrom(byte.class)) {\n                    value = rs.getByte(i);\n                }\n                else if (type.isAssignableFrom(Short.class) || type.isAssignableFrom(short.class)) {\n                    value = rs.getShort(i);\n                }\n                else if (type.isAssignableFrom(Integer.class) || type.isAssignableFrom(int.class)) {\n                    value = rs.getInt(i);\n                }\n                else if (type.isAssignableFrom(Long.class) || type.isAssignableFrom(long.class)) {\n                    value = rs.getLong(i);\n                }\n                else if (type.isAssignableFrom(Float.class) || type.isAssignableFrom(float.class)) {\n                    value = rs.getFloat(i);\n                }\n                else if (type.isAssignableFrom(Double.class) || type.isAssignableFrom(double.class)) {\n                    value = rs.getDouble(i);\n                }\n                else if (type.isAssignableFrom(BigDecimal.class)) {\n                    value = rs.getBigDecimal(i);\n                }\n                else if (type.isAssignableFrom(Timestamp.class)) {\n                    value = rs.getTimestamp(i);\n                }\n                else if (type.isAssignableFrom(Time.class)) {\n                    value = rs.getTime(i);\n                }\n                else if (type.isAssignableFrom(Date.class)) {\n                    value = rs.getDate(i);\n                }\n                else if (type.isAssignableFrom(String.class)) {\n                    value = rs.getString(i);\n                }\n                else if (type.isEnum()) {\n                    String str = rs.getString(i);\n                    value = str != null ? Enum.valueOf(type, str) : null;\n                }\n                else {\n                    value = rs.getObject(i);\n                }\n\n                if (rs.wasNull() && !type.isPrimitive()) {\n                    value = null;\n                }\n\n                try\n                {\n                    descriptor.getWriteMethod().invoke(bean, value);\n                }\n                catch (IllegalAccessException e) {\n                    throw new IllegalArgumentException(String.format(\"Unable to access setter for \" +\n                                                                     \"property, %s\", name), e);\n                }\n                catch (InvocationTargetException e) {\n                    throw new IllegalArgumentException(String.format(\"Invocation target exception trying to \" +\n                                                                     \"invoker setter for the %s property\", name), e);\n                }\n                catch (NullPointerException e) {\n                    throw new IllegalArgumentException(String.format(\"No appropriate method to \" +\n                                                                     \"write property %s\", name), e);\n                }\n\n            }\n        }\n\n        return bean;\n    }\n}\n\n","lineNo":121}
{"Smelly Sample":"package org.skife.jdbi.v2;\n\n/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\n\nimport java.lang.reflect.Field;\nimport java.math.BigDecimal;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Date;\n\n\n/**\n * A result set mapper which maps the fields in a statement into a JavaBean. This uses\n * the reflection to set the fields, it does not support nested properties.\n */\npublic class ReflectionBeanMapper<T> implements ResultSetMapper<T>\n{\n    private final Class<T> type;\n    private final Map<String, Field> properties = new HashMap<String, Field>();\n\n    public ReflectionBeanMapper(Class<T> type)\n    {\n        this.type = type;\n        for (Field field : type.getDeclaredFields()) {\n            properties.put(field.getName().toLowerCase(), field);\n        }\n\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public T map(int row, ResultSet rs, StatementContext ctx)\n            throws SQLException\n    {\n        T bean;\n        try {\n            bean = type.newInstance();\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \" +\n                    \"which was not instantiable\", type.getName()), e);\n        }\n\n        ResultSetMetaData metadata = rs.getMetaData();\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            String name = metadata.getColumnLabel(i).toLowerCase();\n\n            Field field = properties.get(name);\n\n            if (field != null) {\n                Class type = field.getType();\n\n                Object value;\n\n                if (type.isAssignableFrom(Boolean.class) || type.isAssignableFrom(boolean.class)) {\n                    value = rs.getBoolean(i);\n                }\n                else if (type.isAssignableFrom(Byte.class) || type.isAssignableFrom(byte.class)) {\n                    value = rs.getByte(i);\n                }\n                else if (type.isAssignableFrom(Short.class) || type.isAssignableFrom(short.class)) {\n                    value = rs.getShort(i);\n                }\n                else if (type.isAssignableFrom(Integer.class) || type.isAssignableFrom(int.class)) {\n                    value = rs.getInt(i);\n                }\n                else if (type.isAssignableFrom(Long.class) || type.isAssignableFrom(long.class)) {\n                    value = rs.getLong(i);\n                }\n                else if (type.isAssignableFrom(Float.class) || type.isAssignableFrom(float.class)) {\n                    value = rs.getFloat(i);\n                }\n                else if (type.isAssignableFrom(Double.class) || type.isAssignableFrom(double.class)) {\n                    value = rs.getDouble(i);\n                }\n                else if (type.isAssignableFrom(BigDecimal.class)) {\n                    value = rs.getBigDecimal(i);\n                }\n                else if (type.isAssignableFrom(Timestamp.class)) {\n                    value = rs.getTimestamp(i);\n                }\n                else if (type.isAssignableFrom(Time.class)) {\n                    value = rs.getTime(i);\n                }\n                else if (type.isAssignableFrom(Date.class)) {\n                    value = rs.getDate(i);\n                }\n                else if (type.isAssignableFrom(String.class)) {\n                    value = rs.getString(i);\n                }\n                else if (type.isEnum()) {\n                    value = Enum.valueOf(type, rs.getString(i));\n                }\n                else {\n                    value = rs.getObject(i);\n                }\n\n                if (rs.wasNull() && !type.isPrimitive()) {\n                    value = null;\n                }\n\n                try\n                {\n                    field.setAccessible(true);\n                    field.set(bean, value);\n                }\n                catch (IllegalAccessException e) {\n                    throw new IllegalArgumentException(String.format(\"Unable to access \" +\n                            \"property, %s\", name), e);\n                }\n            }\n        }\n\n        return bean;\n    }\n}\n\n","Method after Refactoring":"package org.skife.jdbi.v2;\n\n/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\n\nimport java.lang.reflect.Field;\nimport java.math.BigDecimal;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Date;\n\n\n/**\n * A result set mapper which maps the fields in a statement into a JavaBean. This uses\n * the reflection to set the fields on the bean including its super class fields, it does not support nested properties.\n */\npublic class ReflectionBeanMapper<T> implements ResultSetMapper<T>\n{\n    private final Class<T> type;\n    private final Map<String, Field> properties = new HashMap<String, Field>();\n\n    public ReflectionBeanMapper(Class<T> type)\n    {\n        this.type = type;\n        cacheAllFieldsIncludingSuperClass(type);\n    }\n\n    private void cacheAllFieldsIncludingSuperClass(Class<T> type) {\n        Class aClass = type;\n        while(aClass != null) {\n            for (Field field : aClass.getDeclaredFields()) {\n                properties.put(field.getName().toLowerCase(), field);\n            }\n            aClass = aClass.getSuperclass();\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public T map(int row, ResultSet rs, StatementContext ctx)\n            throws SQLException\n    {\n        T bean;\n        try {\n            bean = type.newInstance();\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"A bean, %s, was mapped \" +\n                    \"which was not instantiable\", type.getName()), e);\n        }\n\n        ResultSetMetaData metadata = rs.getMetaData();\n\n        for (int i = 1; i <= metadata.getColumnCount(); ++i) {\n            String name = metadata.getColumnLabel(i).toLowerCase();\n\n            Field field = properties.get(name);\n\n            if (field != null) {\n                Class type = field.getType();\n\n                Object value;\n\n                if (type.isAssignableFrom(Boolean.class) || type.isAssignableFrom(boolean.class)) {\n                    value = rs.getBoolean(i);\n                }\n                else if (type.isAssignableFrom(Byte.class) || type.isAssignableFrom(byte.class)) {\n                    value = rs.getByte(i);\n                }\n                else if (type.isAssignableFrom(Short.class) || type.isAssignableFrom(short.class)) {\n                    value = rs.getShort(i);\n                }\n                else if (type.isAssignableFrom(Integer.class) || type.isAssignableFrom(int.class)) {\n                    value = rs.getInt(i);\n                }\n                else if (type.isAssignableFrom(Long.class) || type.isAssignableFrom(long.class)) {\n                    value = rs.getLong(i);\n                }\n                else if (type.isAssignableFrom(Float.class) || type.isAssignableFrom(float.class)) {\n                    value = rs.getFloat(i);\n                }\n                else if (type.isAssignableFrom(Double.class) || type.isAssignableFrom(double.class)) {\n                    value = rs.getDouble(i);\n                }\n                else if (type.isAssignableFrom(BigDecimal.class)) {\n                    value = rs.getBigDecimal(i);\n                }\n                else if (type.isAssignableFrom(Timestamp.class)) {\n                    value = rs.getTimestamp(i);\n                }\n                else if (type.isAssignableFrom(Time.class)) {\n                    value = rs.getTime(i);\n                }\n                else if (type.isAssignableFrom(Date.class)) {\n                    value = rs.getDate(i);\n                }\n                else if (type.isAssignableFrom(String.class)) {\n                    value = rs.getString(i);\n                }\n                else if (type.isEnum()) {\n                    value = Enum.valueOf(type, rs.getString(i));\n                }\n                else {\n                    value = rs.getObject(i);\n                }\n\n                if (rs.wasNull() && !type.isPrimitive()) {\n                    value = null;\n                }\n\n                try\n                {\n                    field.setAccessible(true);\n                    field.set(bean, value);\n                }\n                catch (IllegalAccessException e) {\n                    throw new IllegalArgumentException(String.format(\"Unable to access \" +\n                            \"property, %s\", name), e);\n                }\n            }\n        }\n\n        return bean;\n    }\n}\n\n","lineNo":49}
{"Smelly Sample":"/*\n * Copyright (C) 2004 - 2013 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport org.jdbi.v3.SQLStatement;\n\nclass DefaultObjectBinder implements Binder<Bind, Object>\n{\n    public void bind(SQLStatement q, Bind b, Object arg)\n    {\n        q.bind(b.value(), arg);\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2004 - 2013 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jdbi.v3.sqlobject;\n\nimport java.lang.reflect.Parameter;\n\nimport org.jdbi.v3.SQLStatement;\n\nclass DefaultObjectBinder implements Binder<Bind, Object>\n{\n    @Override\n    public void bind(SQLStatement q, Parameter param, Bind b, Object arg)\n    {\n        String value = b.value();\n\n        if (value.equals(Bind.USE_PARAM_NAME)) {\n            if (!param.isNamePresent()) {\n                throw new UnsupportedOperationException(\"A parameter was annotated with @Bind \"\n                        + \"but no name was specified, and parameter name data is not present \"\n                        + \"in the class file.  \" + param.getDeclaringExecutable() + \" :: \" + param);\n            }\n            value = param.getName();\n        }\n\n        q.bind(value, arg);\n    }\n}\n","lineNo":27}
{"Smelly Sample":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.tweak.Argument;\nimport org.skife.jdbi.v2.tweak.NamedArgumentFinder;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * Binds all fields of a map as arguments.\n */\nclass MapArguments implements NamedArgumentFinder\n{\n    private final Foreman foreman;\n    private final StatementContext ctx;\n    private final Map<String, ? extends Object> args;\n\n    MapArguments(Foreman foreman, StatementContext ctx, Map<String, ? extends Object> args)\n    {\n        this.foreman = foreman;\n        this.ctx = ctx;\n        this.args = args;\n    }\n\n    @Override\n    public Argument find(String name)\n    {\n        if (args.containsKey(name))\n        {\n            return foreman.waffle(args.get(name).getClass(), args.get(name), ctx);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        return new LinkedHashMap<String, Object>(args).toString();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.tweak.Argument;\nimport org.skife.jdbi.v2.tweak.NamedArgumentFinder;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * Binds all fields of a map as arguments.\n */\nclass MapArguments implements NamedArgumentFinder\n{\n    private final Foreman foreman;\n    private final StatementContext ctx;\n    private final Map<String, ? extends Object> args;\n\n    MapArguments(Foreman foreman, StatementContext ctx, Map<String, ? extends Object> args)\n    {\n        this.foreman = foreman;\n        this.ctx = ctx;\n        this.args = args;\n    }\n\n    @Override\n    public Argument find(String name)\n    {\n        if (args.containsKey(name))\n        {\n            final Object argument = args.get(name);\n            final Class<? extends Object> argumentClass =\n                    argument == null ? Object.class : argument.getClass();\n            return foreman.waffle(argumentClass, argument, ctx);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        return new LinkedHashMap<String, Object>(args).toString();\n    }\n}\n","lineNo":45}
{"Smelly Sample":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.tweak.Argument;\nimport org.skife.jdbi.v2.tweak.NamedArgumentFinder;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * Binds all fields of a map as arguments.\n */\nclass MapArguments implements NamedArgumentFinder\n{\n    private final Foreman foreman;\n    private final StatementContext ctx;\n    private final Map<String, ? extends Object> args;\n\n    MapArguments(Foreman foreman, StatementContext ctx, Map<String, ? extends Object> args)\n    {\n        this.foreman = foreman;\n        this.ctx = ctx;\n        this.args = args;\n    }\n\n    @Override\n    public Argument find(String name)\n    {\n        if (args.containsKey(name))\n        {\n            return foreman.waffle(args.get(name).getClass(), args.get(name), ctx);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        return new LinkedHashMap<String, Object>(args).toString();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.tweak.Argument;\nimport org.skife.jdbi.v2.tweak.NamedArgumentFinder;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * Binds all fields of a map as arguments.\n */\nclass MapArguments implements NamedArgumentFinder\n{\n    private final Foreman foreman;\n    private final StatementContext ctx;\n    private final Map<String, ? extends Object> args;\n\n    MapArguments(Foreman foreman, StatementContext ctx, Map<String, ? extends Object> args)\n    {\n        this.foreman = foreman;\n        this.ctx = ctx;\n        this.args = args;\n    }\n\n    @Override\n    public Argument find(String name)\n    {\n        if (args.containsKey(name))\n        {\n            final Object argument = args.get(name);\n            final Class<? extends Object> argumentClass =\n                    argument == null ? Object.class : argument.getClass();\n            return foreman.waffle(argumentClass, argument, ctx);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        return new LinkedHashMap<String, Object>(args).toString();\n    }\n}\n","lineNo":46}
{"Smelly Sample":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.BaseStatementCustomizer;\nimport org.skife.jdbi.v2.tweak.StatementCustomizer;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nabstract class BaseStatement\n{\n    private final Collection<StatementCustomizer> customizers = new ArrayList<StatementCustomizer>();\n    private final ConcreteStatementContext context;\n    private final Foreman                  foreman;\n\n    protected BaseStatement(final ConcreteStatementContext context, Foreman foreman)\n    {\n        this.context = context;\n        this.foreman = foreman.createChild();\n        addCustomizer(new StatementCleaningCustomizer());\n    }\n\n    protected final Foreman getForeman() {\n        return foreman;\n    }\n\n    protected final ConcreteStatementContext getConcreteContext()\n    {\n        return this.context;\n    }\n\n    /**\n     * Obtain the statement context associated with this statement\n     */\n    public final StatementContext getContext()\n    {\n        return context;\n    }\n\n    protected void addCustomizers(final Collection<StatementCustomizer> customizers)\n    {\n        this.customizers.addAll(customizers);\n    }\n\n    protected void addCustomizer(final StatementCustomizer customizer)\n    {\n        this.customizers.add(customizer);\n    }\n\n    protected Collection<StatementCustomizer> getStatementCustomizers()\n    {\n        return this.customizers;\n    }\n\n    protected final void beforeExecution(final PreparedStatement stmt)\n    {\n        for (StatementCustomizer customizer : customizers) {\n            try {\n                customizer.beforeExecution(stmt, context);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e, context);\n            }\n        }\n    }\n\n    protected final void afterExecution(final PreparedStatement stmt)\n    {\n        for (StatementCustomizer customizer : customizers) {\n            try {\n                customizer.afterExecution(stmt, context);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e, context);\n            }\n        }\n    }\n\n    protected final void cleanup()\n    {\n        for (StatementCustomizer customizer : customizers) {\n            try {\n                customizer.cleanup(context);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Could not clean up\", e, context);\n            }\n        }\n    }\n\n    protected void addCleanable(final Cleanable cleanable)\n    {\n        this.context.getCleanables().add(cleanable);\n    }\n\n    class StatementCleaningCustomizer extends BaseStatementCustomizer\n    {\n        @Override\n        public final void cleanup(final StatementContext ctx)\n            throws SQLException\n        {\n            final List<SQLException> exceptions = new ArrayList<SQLException>();\n            try {\n                Collections.reverse(context.getCleanables());\n                for (Cleanable cleanable : context.getCleanables()) {\n                    try {\n                        cleanable.cleanup();\n                    }\n                    catch (SQLException sqlException) {\n                        exceptions.add(sqlException);\n                    }\n                }\n                context.getCleanables().clear();\n            }\n            finally {\n                if (exceptions.size() > 1) {\n                    // Chain multiple SQLExceptions together to be one big exceptions.\n                    // (Wonder if that actually works...)\n                    for (int i = 0; i < (exceptions.size() - 1); i++) {\n                        exceptions.get(i).setNextException(exceptions.get(i + 1));\n                    }\n                }\n                if (exceptions.size() > 0) {\n                    throw exceptions.get(0);\n                }\n            }\n        }\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.BaseStatementCustomizer;\nimport org.skife.jdbi.v2.tweak.StatementCustomizer;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nabstract class BaseStatement\n{\n    private final Collection<StatementCustomizer> customizers = new ArrayList<StatementCustomizer>();\n    private final ConcreteStatementContext context;\n    private final Foreman                  foreman;\n\n    protected BaseStatement(final ConcreteStatementContext context, Foreman foreman)\n    {\n        this.context = context;\n        this.foreman = foreman.createChild();\n        addCustomizer(new StatementCleaningCustomizer());\n    }\n\n    protected final Foreman getForeman() {\n        return foreman;\n    }\n\n    protected final ConcreteStatementContext getConcreteContext()\n    {\n        return this.context;\n    }\n\n    /**\n     * Obtain the statement context associated with this statement\n     */\n    public final StatementContext getContext()\n    {\n        return context;\n    }\n\n    protected void addCustomizers(final Collection<StatementCustomizer> customizers)\n    {\n        this.customizers.addAll(customizers);\n    }\n\n    protected void addCustomizer(final StatementCustomizer customizer)\n    {\n        this.customizers.add(customizer);\n    }\n\n    protected Collection<StatementCustomizer> getStatementCustomizers()\n    {\n        return this.customizers;\n    }\n\n    protected final void beforeExecution(final PreparedStatement stmt)\n    {\n        for (StatementCustomizer customizer : customizers) {\n            try {\n                customizer.beforeExecution(stmt, context);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e, context);\n            }\n        }\n    }\n\n    protected final void afterExecution(final PreparedStatement stmt)\n    {\n        for (StatementCustomizer customizer : customizers) {\n            try {\n                customizer.afterExecution(stmt, context);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e, context);\n            }\n        }\n    }\n\n    protected final void cleanup()\n    {\n        for (StatementCustomizer customizer : customizers) {\n            try {\n                customizer.cleanup(context);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Could not clean up\", e, context);\n            }\n        }\n    }\n\n    protected void addCleanable(final Cleanable cleanable)\n    {\n        this.context.getCleanables().add(cleanable);\n    }\n\n    class StatementCleaningCustomizer extends BaseStatementCustomizer\n    {\n        @Override\n        public final void cleanup(final StatementContext ctx)\n            throws SQLException\n        {\n            final List<SQLException> exceptions = new ArrayList<SQLException>();\n            try {\n                List<Cleanable> cleanables = new ArrayList<Cleanable>(context.getCleanables());\n                Collections.reverse(cleanables);\n                for (Cleanable cleanable : cleanables) {\n                    try {\n                        cleanable.cleanup();\n                    }\n                    catch (SQLException sqlException) {\n                        exceptions.add(sqlException);\n                    }\n                }\n                context.getCleanables().clear();\n            }\n            finally {\n                if (exceptions.size() > 1) {\n                    // Chain multiple SQLExceptions together to be one big exceptions.\n                    // (Wonder if that actually works...)\n                    for (int i = 0; i < (exceptions.size() - 1); i++) {\n                        exceptions.get(i).setNextException(exceptions.get(i + 1));\n                    }\n                }\n                if (exceptions.size() > 0) {\n                    throw exceptions.get(0);\n                }\n            }\n        }\n    }\n}\n\n","lineNo":123}
{"Smelly Sample":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport java.sql.Date;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents output from a Call (CallableStatement)\n * @see org.skife.jdbi.v2.Call\n */\npublic class OutParameters\n{\n    private final Map<Object, Object> map = new HashMap<Object, Object>();\n\n    /**\n     * Type-casting convenience method which obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n    public <T> T getObject(String name, Class<T> type) {\n        return type.cast(getObject(name));\n    }\n\n    /**\n     * Obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(String name) {\n        return map.get(name);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the the results positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param position The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(int position) {\n        return map.get(position);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the map positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param pos The out parameter position\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n\n    public <T> T getObject(int pos, Class<T> type) {\n        return type.cast(getObject(pos));\n    }\n\n    public String getString(String name) {\n        Object obj = map.get(name);\n        if (obj != null) {\n            return obj.toString();\n        }\n        throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n    }\n\n    public String getString(int pos) {\n        Object obj = map.get(pos);\n        if (obj != null) {\n            return obj.toString();\n        }\n        throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n    }\n\n    public byte[] getBytes(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not byte[] but %s\", name, obj.getClass()));\n        }\n    }\n\n    public byte[] getBytes(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not byte[] but %s\", pos, obj.getClass()));\n        }\n    }\n\n    public Integer getInt(String name) {\n        return getNumber(name).intValue();\n    }\n\n    public Integer getInt(int pos) {\n        return getNumber(pos).intValue();\n    }\n\n    public Long getLong(String name) {\n        return getNumber(name).longValue();\n    }\n\n    public Long getLong(int pos) {\n        return getNumber(pos).longValue();\n    }\n\n    public Short getShort(String name) {\n        return getNumber(name).shortValue();\n    }\n\n    public Short getShort(int pos) {\n        return getNumber(pos).shortValue();\n    }\n\n    public Date getDate(String name) {\n        return new Date(getEpoch(name));\n    }\n\n    public Date getDate(int pos) {\n        return new Date(getEpoch(pos));\n    }\n\n    public Timestamp getTimestamp(String name) {\n        return new Timestamp(getEpoch(name));\n    }\n\n    public Timestamp getTimestamp(int pos) {\n        return new Timestamp(getEpoch(pos));\n    }\n\n    public Double getDouble(String name) {\n        return getNumber(name).doubleValue();\n    }\n\n    public Double getDouble(int pos) {\n        return getNumber(pos).doubleValue();\n    }\n\n    public Float getFloat(String name) {\n        return getNumber(name).floatValue();\n    }\n\n    public Float getFloat(int pos) {\n        return getNumber(pos).floatValue();\n    }\n\n    private Number getNumber(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not a number but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Number getNumber(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not a number but %s\", pos, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not Date but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not Date but %s\", pos, obj.getClass()));\n        }\n    }\n\n    Map<Object, Object> getMap() {\n        return map;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport java.sql.Date;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents output from a Call (CallableStatement)\n * @see org.skife.jdbi.v2.Call\n */\npublic class OutParameters\n{\n    private final Map<Object, Object> map = new HashMap<Object, Object>();\n\n    /**\n     * Type-casting convenience method which obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n    public <T> T getObject(String name, Class<T> type) {\n        return type.cast(getObject(name));\n    }\n\n    /**\n     * Obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(String name) {\n        return map.get(name);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the the results positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param position The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(int position) {\n        return map.get(position);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the map positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param pos The out parameter position\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n\n    public <T> T getObject(int pos, Class<T> type) {\n        return type.cast(getObject(pos));\n    }\n\n    public String getString(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        return obj.toString();\n    }\n\n    public String getString(int pos) {\n        Object obj = map.get(pos);\n\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n\n        return obj.toString();\n    }\n\n    public byte[] getBytes(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n           }\n\n            return null;\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not byte[] but %s\", name, obj.getClass()));\n        }\n    }\n\n    public byte[] getBytes(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n           }\n\n            return null;\n        }\n\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not byte[] but %s\", pos, obj.getClass()));\n        }\n    }\n\n    public Integer getInt(String name) {\n        return getNumber(name).intValue();\n    }\n\n    public Integer getInt(int pos) {\n        return getNumber(pos).intValue();\n    }\n\n    public Long getLong(String name) {\n        return getNumber(name).longValue();\n    }\n\n    public Long getLong(int pos) {\n        return getNumber(pos).longValue();\n    }\n\n    public Short getShort(String name) {\n        return getNumber(name).shortValue();\n    }\n\n    public Short getShort(int pos) {\n        return getNumber(pos).shortValue();\n    }\n\n    public Date getDate(String name) {\n        Long epoch = getEpoch(name);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Date(epoch);\n    }\n\n    public Date getDate(int pos) {\n        Long epoch = getEpoch(pos);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Date(epoch);\n    }\n\n    public Timestamp getTimestamp(String name) {\n        Long epoch = getEpoch(name);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Timestamp(epoch);\n    }\n\n    public Timestamp getTimestamp(int pos) {\n        Long epoch = getEpoch(pos);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Timestamp(epoch);\n    }\n\n    public Double getDouble(String name) {\n        return getNumber(name).doubleValue();\n    }\n\n    public Double getDouble(int pos) {\n        return getNumber(pos).doubleValue();\n    }\n\n    public Float getFloat(String name) {\n        return getNumber(name).floatValue();\n    }\n\n    public Float getFloat(int pos) {\n        return getNumber(pos).floatValue();\n    }\n\n    private Number getNumber(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not a number but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Number getNumber(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not a number but %s\", pos, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(String name) {\n        Object obj = map.get(name);\n\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not Date but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not Date but %s\", pos, obj.getClass()));\n        }\n    }\n\n    Map<Object, Object> getMap() {\n        return map;\n    }\n}\n","lineNo":165}
{"Smelly Sample":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport java.sql.Date;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents output from a Call (CallableStatement)\n * @see org.skife.jdbi.v2.Call\n */\npublic class OutParameters\n{\n    private final Map<Object, Object> map = new HashMap<Object, Object>();\n\n    /**\n     * Type-casting convenience method which obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n    public <T> T getObject(String name, Class<T> type) {\n        return type.cast(getObject(name));\n    }\n\n    /**\n     * Obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(String name) {\n        return map.get(name);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the the results positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param position The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(int position) {\n        return map.get(position);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the map positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param pos The out parameter position\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n\n    public <T> T getObject(int pos, Class<T> type) {\n        return type.cast(getObject(pos));\n    }\n\n    public String getString(String name) {\n        Object obj = map.get(name);\n        if (obj != null) {\n            return obj.toString();\n        }\n        throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n    }\n\n    public String getString(int pos) {\n        Object obj = map.get(pos);\n        if (obj != null) {\n            return obj.toString();\n        }\n        throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n    }\n\n    public byte[] getBytes(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not byte[] but %s\", name, obj.getClass()));\n        }\n    }\n\n    public byte[] getBytes(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not byte[] but %s\", pos, obj.getClass()));\n        }\n    }\n\n    public Integer getInt(String name) {\n        return getNumber(name).intValue();\n    }\n\n    public Integer getInt(int pos) {\n        return getNumber(pos).intValue();\n    }\n\n    public Long getLong(String name) {\n        return getNumber(name).longValue();\n    }\n\n    public Long getLong(int pos) {\n        return getNumber(pos).longValue();\n    }\n\n    public Short getShort(String name) {\n        return getNumber(name).shortValue();\n    }\n\n    public Short getShort(int pos) {\n        return getNumber(pos).shortValue();\n    }\n\n    public Date getDate(String name) {\n        return new Date(getEpoch(name));\n    }\n\n    public Date getDate(int pos) {\n        return new Date(getEpoch(pos));\n    }\n\n    public Timestamp getTimestamp(String name) {\n        return new Timestamp(getEpoch(name));\n    }\n\n    public Timestamp getTimestamp(int pos) {\n        return new Timestamp(getEpoch(pos));\n    }\n\n    public Double getDouble(String name) {\n        return getNumber(name).doubleValue();\n    }\n\n    public Double getDouble(int pos) {\n        return getNumber(pos).doubleValue();\n    }\n\n    public Float getFloat(String name) {\n        return getNumber(name).floatValue();\n    }\n\n    public Float getFloat(int pos) {\n        return getNumber(pos).floatValue();\n    }\n\n    private Number getNumber(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not a number but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Number getNumber(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not a number but %s\", pos, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not Date but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not Date but %s\", pos, obj.getClass()));\n        }\n    }\n\n    Map<Object, Object> getMap() {\n        return map;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport java.sql.Date;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents output from a Call (CallableStatement)\n * @see org.skife.jdbi.v2.Call\n */\npublic class OutParameters\n{\n    private final Map<Object, Object> map = new HashMap<Object, Object>();\n\n    /**\n     * Type-casting convenience method which obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n    public <T> T getObject(String name, Class<T> type) {\n        return type.cast(getObject(name));\n    }\n\n    /**\n     * Obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(String name) {\n        return map.get(name);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the the results positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param position The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(int position) {\n        return map.get(position);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the map positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param pos The out parameter position\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n\n    public <T> T getObject(int pos, Class<T> type) {\n        return type.cast(getObject(pos));\n    }\n\n    public String getString(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        return obj.toString();\n    }\n\n    public String getString(int pos) {\n        Object obj = map.get(pos);\n\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n\n        return obj.toString();\n    }\n\n    public byte[] getBytes(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n           }\n\n            return null;\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not byte[] but %s\", name, obj.getClass()));\n        }\n    }\n\n    public byte[] getBytes(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n           }\n\n            return null;\n        }\n\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not byte[] but %s\", pos, obj.getClass()));\n        }\n    }\n\n    public Integer getInt(String name) {\n        return getNumber(name).intValue();\n    }\n\n    public Integer getInt(int pos) {\n        return getNumber(pos).intValue();\n    }\n\n    public Long getLong(String name) {\n        return getNumber(name).longValue();\n    }\n\n    public Long getLong(int pos) {\n        return getNumber(pos).longValue();\n    }\n\n    public Short getShort(String name) {\n        return getNumber(name).shortValue();\n    }\n\n    public Short getShort(int pos) {\n        return getNumber(pos).shortValue();\n    }\n\n    public Date getDate(String name) {\n        Long epoch = getEpoch(name);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Date(epoch);\n    }\n\n    public Date getDate(int pos) {\n        Long epoch = getEpoch(pos);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Date(epoch);\n    }\n\n    public Timestamp getTimestamp(String name) {\n        Long epoch = getEpoch(name);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Timestamp(epoch);\n    }\n\n    public Timestamp getTimestamp(int pos) {\n        Long epoch = getEpoch(pos);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Timestamp(epoch);\n    }\n\n    public Double getDouble(String name) {\n        return getNumber(name).doubleValue();\n    }\n\n    public Double getDouble(int pos) {\n        return getNumber(pos).doubleValue();\n    }\n\n    public Float getFloat(String name) {\n        return getNumber(name).floatValue();\n    }\n\n    public Float getFloat(int pos) {\n        return getNumber(pos).floatValue();\n    }\n\n    private Number getNumber(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not a number but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Number getNumber(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not a number but %s\", pos, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(String name) {\n        Object obj = map.get(name);\n\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not Date but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not Date but %s\", pos, obj.getClass()));\n        }\n    }\n\n    Map<Object, Object> getMap() {\n        return map;\n    }\n}\n","lineNo":175}
{"Smelly Sample":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport java.sql.Date;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents output from a Call (CallableStatement)\n * @see org.skife.jdbi.v2.Call\n */\npublic class OutParameters\n{\n    private final Map<Object, Object> map = new HashMap<Object, Object>();\n\n    /**\n     * Type-casting convenience method which obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n    public <T> T getObject(String name, Class<T> type) {\n        return type.cast(getObject(name));\n    }\n\n    /**\n     * Obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(String name) {\n        return map.get(name);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the the results positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param position The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(int position) {\n        return map.get(position);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the map positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param pos The out parameter position\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n\n    public <T> T getObject(int pos, Class<T> type) {\n        return type.cast(getObject(pos));\n    }\n\n    public String getString(String name) {\n        Object obj = map.get(name);\n        if (obj != null) {\n            return obj.toString();\n        }\n        throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n    }\n\n    public String getString(int pos) {\n        Object obj = map.get(pos);\n        if (obj != null) {\n            return obj.toString();\n        }\n        throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n    }\n\n    public byte[] getBytes(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not byte[] but %s\", name, obj.getClass()));\n        }\n    }\n\n    public byte[] getBytes(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not byte[] but %s\", pos, obj.getClass()));\n        }\n    }\n\n    public Integer getInt(String name) {\n        return getNumber(name).intValue();\n    }\n\n    public Integer getInt(int pos) {\n        return getNumber(pos).intValue();\n    }\n\n    public Long getLong(String name) {\n        return getNumber(name).longValue();\n    }\n\n    public Long getLong(int pos) {\n        return getNumber(pos).longValue();\n    }\n\n    public Short getShort(String name) {\n        return getNumber(name).shortValue();\n    }\n\n    public Short getShort(int pos) {\n        return getNumber(pos).shortValue();\n    }\n\n    public Date getDate(String name) {\n        return new Date(getEpoch(name));\n    }\n\n    public Date getDate(int pos) {\n        return new Date(getEpoch(pos));\n    }\n\n    public Timestamp getTimestamp(String name) {\n        return new Timestamp(getEpoch(name));\n    }\n\n    public Timestamp getTimestamp(int pos) {\n        return new Timestamp(getEpoch(pos));\n    }\n\n    public Double getDouble(String name) {\n        return getNumber(name).doubleValue();\n    }\n\n    public Double getDouble(int pos) {\n        return getNumber(pos).doubleValue();\n    }\n\n    public Float getFloat(String name) {\n        return getNumber(name).floatValue();\n    }\n\n    public Float getFloat(int pos) {\n        return getNumber(pos).floatValue();\n    }\n\n    private Number getNumber(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not a number but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Number getNumber(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not a number but %s\", pos, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not Date but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not Date but %s\", pos, obj.getClass()));\n        }\n    }\n\n    Map<Object, Object> getMap() {\n        return map;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport java.sql.Date;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents output from a Call (CallableStatement)\n * @see org.skife.jdbi.v2.Call\n */\npublic class OutParameters\n{\n    private final Map<Object, Object> map = new HashMap<Object, Object>();\n\n    /**\n     * Type-casting convenience method which obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n    public <T> T getObject(String name, Class<T> type) {\n        return type.cast(getObject(name));\n    }\n\n    /**\n     * Obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(String name) {\n        return map.get(name);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the the results positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param position The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(int position) {\n        return map.get(position);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the map positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param pos The out parameter position\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n\n    public <T> T getObject(int pos, Class<T> type) {\n        return type.cast(getObject(pos));\n    }\n\n    public String getString(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        return obj.toString();\n    }\n\n    public String getString(int pos) {\n        Object obj = map.get(pos);\n\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n\n        return obj.toString();\n    }\n\n    public byte[] getBytes(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n           }\n\n            return null;\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not byte[] but %s\", name, obj.getClass()));\n        }\n    }\n\n    public byte[] getBytes(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n           }\n\n            return null;\n        }\n\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not byte[] but %s\", pos, obj.getClass()));\n        }\n    }\n\n    public Integer getInt(String name) {\n        return getNumber(name).intValue();\n    }\n\n    public Integer getInt(int pos) {\n        return getNumber(pos).intValue();\n    }\n\n    public Long getLong(String name) {\n        return getNumber(name).longValue();\n    }\n\n    public Long getLong(int pos) {\n        return getNumber(pos).longValue();\n    }\n\n    public Short getShort(String name) {\n        return getNumber(name).shortValue();\n    }\n\n    public Short getShort(int pos) {\n        return getNumber(pos).shortValue();\n    }\n\n    public Date getDate(String name) {\n        Long epoch = getEpoch(name);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Date(epoch);\n    }\n\n    public Date getDate(int pos) {\n        Long epoch = getEpoch(pos);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Date(epoch);\n    }\n\n    public Timestamp getTimestamp(String name) {\n        Long epoch = getEpoch(name);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Timestamp(epoch);\n    }\n\n    public Timestamp getTimestamp(int pos) {\n        Long epoch = getEpoch(pos);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Timestamp(epoch);\n    }\n\n    public Double getDouble(String name) {\n        return getNumber(name).doubleValue();\n    }\n\n    public Double getDouble(int pos) {\n        return getNumber(pos).doubleValue();\n    }\n\n    public Float getFloat(String name) {\n        return getNumber(name).floatValue();\n    }\n\n    public Float getFloat(int pos) {\n        return getNumber(pos).floatValue();\n    }\n\n    private Number getNumber(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not a number but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Number getNumber(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not a number but %s\", pos, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(String name) {\n        Object obj = map.get(name);\n\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not Date but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not Date but %s\", pos, obj.getClass()));\n        }\n    }\n\n    Map<Object, Object> getMap() {\n        return map;\n    }\n}\n","lineNo":185}
{"Smelly Sample":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport java.sql.Date;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents output from a Call (CallableStatement)\n * @see org.skife.jdbi.v2.Call\n */\npublic class OutParameters\n{\n    private final Map<Object, Object> map = new HashMap<Object, Object>();\n\n    /**\n     * Type-casting convenience method which obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n    public <T> T getObject(String name, Class<T> type) {\n        return type.cast(getObject(name));\n    }\n\n    /**\n     * Obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(String name) {\n        return map.get(name);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the the results positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param position The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(int position) {\n        return map.get(position);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the map positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param pos The out parameter position\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n\n    public <T> T getObject(int pos, Class<T> type) {\n        return type.cast(getObject(pos));\n    }\n\n    public String getString(String name) {\n        Object obj = map.get(name);\n        if (obj != null) {\n            return obj.toString();\n        }\n        throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n    }\n\n    public String getString(int pos) {\n        Object obj = map.get(pos);\n        if (obj != null) {\n            return obj.toString();\n        }\n        throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n    }\n\n    public byte[] getBytes(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not byte[] but %s\", name, obj.getClass()));\n        }\n    }\n\n    public byte[] getBytes(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not byte[] but %s\", pos, obj.getClass()));\n        }\n    }\n\n    public Integer getInt(String name) {\n        return getNumber(name).intValue();\n    }\n\n    public Integer getInt(int pos) {\n        return getNumber(pos).intValue();\n    }\n\n    public Long getLong(String name) {\n        return getNumber(name).longValue();\n    }\n\n    public Long getLong(int pos) {\n        return getNumber(pos).longValue();\n    }\n\n    public Short getShort(String name) {\n        return getNumber(name).shortValue();\n    }\n\n    public Short getShort(int pos) {\n        return getNumber(pos).shortValue();\n    }\n\n    public Date getDate(String name) {\n        return new Date(getEpoch(name));\n    }\n\n    public Date getDate(int pos) {\n        return new Date(getEpoch(pos));\n    }\n\n    public Timestamp getTimestamp(String name) {\n        return new Timestamp(getEpoch(name));\n    }\n\n    public Timestamp getTimestamp(int pos) {\n        return new Timestamp(getEpoch(pos));\n    }\n\n    public Double getDouble(String name) {\n        return getNumber(name).doubleValue();\n    }\n\n    public Double getDouble(int pos) {\n        return getNumber(pos).doubleValue();\n    }\n\n    public Float getFloat(String name) {\n        return getNumber(name).floatValue();\n    }\n\n    public Float getFloat(int pos) {\n        return getNumber(pos).floatValue();\n    }\n\n    private Number getNumber(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not a number but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Number getNumber(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not a number but %s\", pos, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n        }\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not Date but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n        }\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not Date but %s\", pos, obj.getClass()));\n        }\n    }\n\n    Map<Object, Object> getMap() {\n        return map;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2004 - 2014 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport java.sql.Date;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents output from a Call (CallableStatement)\n * @see org.skife.jdbi.v2.Call\n */\npublic class OutParameters\n{\n    private final Map<Object, Object> map = new HashMap<Object, Object>();\n\n    /**\n     * Type-casting convenience method which obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n    public <T> T getObject(String name, Class<T> type) {\n        return type.cast(getObject(name));\n    }\n\n    /**\n     * Obtains an object from the map, the\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param name The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(String name) {\n        return map.get(name);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the the results positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param position The out parameter name\n     * @return the output of name as type T\n     */\n    public Object getObject(int position) {\n        return map.get(position);\n    }\n\n    /**\n     * Type-casting convenience method which obtains an object from the map positionally\n     * object obtained should have been created with {@link org.skife.jdbi.v2.CallableStatementMapper}\n     *\n     * @param pos The out parameter position\n     * @param type The java type to obtain\n     * @return the output of name as type T\n     */\n\n    public <T> T getObject(int pos, Class<T> type) {\n        return type.cast(getObject(pos));\n    }\n\n    public String getString(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        return obj.toString();\n    }\n\n    public String getString(int pos) {\n        Object obj = map.get(pos);\n\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n\n        return obj.toString();\n    }\n\n    public byte[] getBytes(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n           }\n\n            return null;\n        }\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not byte[] but %s\", name, obj.getClass()));\n        }\n    }\n\n    public byte[] getBytes(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n           }\n\n            return null;\n        }\n\n        if (obj instanceof byte[]) {\n            return (byte[]) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not byte[] but %s\", pos, obj.getClass()));\n        }\n    }\n\n    public Integer getInt(String name) {\n        return getNumber(name).intValue();\n    }\n\n    public Integer getInt(int pos) {\n        return getNumber(pos).intValue();\n    }\n\n    public Long getLong(String name) {\n        return getNumber(name).longValue();\n    }\n\n    public Long getLong(int pos) {\n        return getNumber(pos).longValue();\n    }\n\n    public Short getShort(String name) {\n        return getNumber(name).shortValue();\n    }\n\n    public Short getShort(int pos) {\n        return getNumber(pos).shortValue();\n    }\n\n    public Date getDate(String name) {\n        Long epoch = getEpoch(name);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Date(epoch);\n    }\n\n    public Date getDate(int pos) {\n        Long epoch = getEpoch(pos);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Date(epoch);\n    }\n\n    public Timestamp getTimestamp(String name) {\n        Long epoch = getEpoch(name);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Timestamp(epoch);\n    }\n\n    public Timestamp getTimestamp(int pos) {\n        Long epoch = getEpoch(pos);\n\n        if (epoch == null) {\n            return null;\n        }\n\n        return new Timestamp(epoch);\n    }\n\n    public Double getDouble(String name) {\n        return getNumber(name).doubleValue();\n    }\n\n    public Double getDouble(int pos) {\n        return getNumber(pos).doubleValue();\n    }\n\n    public Float getFloat(String name) {\n        return getNumber(name).floatValue();\n    }\n\n    public Float getFloat(int pos) {\n        return getNumber(pos).floatValue();\n    }\n\n    private Number getNumber(String name) {\n        Object obj = map.get(name);\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not a number but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Number getNumber(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n        if (obj instanceof Number) {\n            return (Number) obj;\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not a number but %s\", pos, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(String name) {\n        Object obj = map.get(name);\n\n        if (obj == null) {\n            if (!map.containsKey(name)) {\n                throw new IllegalArgumentException(String.format(\"Parameter %s does not exist\", name));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter %s is not Date but %s\", name, obj.getClass()));\n        }\n    }\n\n    private Long getEpoch(int pos) {\n        Object obj = map.get(pos);\n        if (obj == null) {\n            if (!map.containsKey(pos)) {\n                throw new IllegalArgumentException(String.format(\"Parameter at %d does not exist\", pos));\n            }\n\n            return null;\n        }\n\n        if (obj instanceof java.util.Date) {\n            return ((java.util.Date) obj).getTime();\n        }\n        else {\n            throw new IllegalArgumentException(String.format(\"Parameter at %d is not Date but %s\", pos, obj.getClass()));\n        }\n    }\n\n    Map<Object, Object> getMap() {\n        return map;\n    }\n}\n","lineNo":195}
{"Smelly Sample":"/*\n * Copyright (C) 2004 - 2013 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.MemberResolver;\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.ResolvedTypeWithMembers;\nimport com.fasterxml.classmate.TypeResolver;\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nclass SqlObject\n{\n    private static final TypeResolver                                  typeResolver  = new TypeResolver();\n    private static final Map<Method, Handler>                          mixinHandlers = new HashMap<Method, Handler>();\n    private static final ConcurrentMap<Class<?>, Map<Method, Handler>> handlersCache = new ConcurrentHashMap<Class<?>, Map<Method, Handler>>();\n    private static final ConcurrentMap<Class<?>, Factory>              factories     = new ConcurrentHashMap<Class<?>, Factory>();\n\n    static {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n        mixinHandlers.putAll(TransmogrifierHelper.handlers());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <T> T buildSqlObject(final Class<T> sqlObjectType, final HandleDing handle)\n    {\n        Factory f;\n        if (factories.containsKey(sqlObjectType)) {\n            f = factories.get(sqlObjectType);\n        }\n        else {\n            Enhancer e = new Enhancer();\n            e.setClassLoader(sqlObjectType.getClassLoader());\n\n            List<Class> interfaces = new ArrayList<Class>();\n            interfaces.add(CloseInternalDoNotUseThisClass.class);\n            if (sqlObjectType.isInterface()) {\n                interfaces.add(sqlObjectType);\n            }\n            else {\n                e.setSuperclass(sqlObjectType);\n            }\n            e.setInterfaces(interfaces.toArray(new Class[interfaces.size()]));\n            final SqlObject so = new SqlObject(buildHandlersFor(sqlObjectType), handle);\n            e.setCallback(new MethodInterceptor()\n            {\n                @Override\n                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable\n                {\n                    return so.invoke(o, method, objects, methodProxy);\n                }\n            });\n            T t = (T) e.create();\n            T actual = (T) factories.putIfAbsent(sqlObjectType, (Factory) t);\n            return actual != null ? actual : t;\n        }\n\n        final SqlObject so = new SqlObject(buildHandlersFor(sqlObjectType), handle);\n        return (T) f.newInstance(new MethodInterceptor()\n        {\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable\n            {\n                return so.invoke(o, method, objects, methodProxy);\n            }\n        });\n    }\n\n    private static Map<Method, Handler> buildHandlersFor(Class<?> sqlObjectType)\n    {\n        if (handlersCache.containsKey(sqlObjectType)) {\n            return handlersCache.get(sqlObjectType);\n        }\n\n        final MemberResolver mr = new MemberResolver(typeResolver);\n        final ResolvedType sql_object_type = typeResolver.resolve(sqlObjectType);\n\n        final ResolvedTypeWithMembers d = mr.resolve(sql_object_type, null, null);\n\n        final Map<Method, Handler> handlers = new HashMap<Method, Handler>();\n        for (final ResolvedMethod method : d.getMemberMethods()) {\n            final Method raw_method = method.getRawMember();\n\n            if (raw_method.isAnnotationPresent(SqlQuery.class)) {\n                handlers.put(raw_method, new QueryHandler(sqlObjectType, method, ResultReturnThing.forType(method)));\n            }\n            else if (raw_method.isAnnotationPresent(SqlUpdate.class)) {\n                handlers.put(raw_method, new UpdateHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlBatch.class)) {\n                handlers.put(raw_method, new BatchHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlCall.class)) {\n                handlers.put(raw_method, new CallHandler(sqlObjectType, method));\n            }\n            else if(raw_method.isAnnotationPresent(CreateSqlObject.class)) {\n                handlers.put(raw_method, new CreateSqlObjectHandler(raw_method.getReturnType()));\n            }\n            else if (method.getName().equals(\"close\") && method.getRawMember().getParameterTypes().length == 0) {\n                handlers.put(raw_method, new CloseHandler());\n            }\n            else if (raw_method.isAnnotationPresent(Transaction.class)) {\n                handlers.put(raw_method, new PassThroughTransactionHandler(raw_method, raw_method.getAnnotation(Transaction.class)));\n            }\n            else if (mixinHandlers.containsKey(raw_method)) {\n                handlers.put(raw_method, mixinHandlers.get(raw_method));\n            }\n            else {\n                handlers.put(raw_method, new PassThroughHandler(raw_method));\n            }\n        }\n\n        // this is an implicit mixin, not an explicit one, so we need to *always* add it\n        handlers.putAll(CloseInternalDoNotUseThisClass.Helper.handlers());\n\n        handlers.putAll(EqualsHandler.handler());\n        handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n        handlers.putAll(HashCodeHandler.handler());\n\n        return handlers;\n    }\n\n\n    private final Map<Method, Handler> handlers;\n    private final HandleDing           ding;\n\n    public SqlObject(Map<Method, Handler> handlers, HandleDing ding)\n    {\n        this.handlers = handlers;\n        this.ding = ding;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args, MethodProxy mp) throws Throwable\n    {\n        try {\n            ding.retain(method.toString());\n            return handlers.get(method).invoke(ding, proxy, args, mp);\n        }\n        finally {\n            ding.release(method.toString());\n        }\n    }\n\n    public static void close(Object sqlObject)\n    {\n        if (!(sqlObject instanceof CloseInternalDoNotUseThisClass)) {\n            throw new IllegalArgumentException(sqlObject + \" is not a sql object\");\n        }\n        CloseInternalDoNotUseThisClass closer = (CloseInternalDoNotUseThisClass) sqlObject;\n        closer.___jdbi_close___();\n    }\n\n    static String getSql(SqlCall q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2004 - 2013 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.MemberResolver;\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.ResolvedTypeWithMembers;\nimport com.fasterxml.classmate.TypeResolver;\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nclass SqlObject\n{\n    private static final TypeResolver                                  typeResolver  = new TypeResolver();\n    private static final Map<Method, Handler>                          mixinHandlers = new HashMap<Method, Handler>();\n    private static final ConcurrentMap<Class<?>, Map<Method, Handler>> handlersCache = new ConcurrentHashMap<Class<?>, Map<Method, Handler>>();\n    private static final ConcurrentMap<Class<?>, Factory>              factories     = new ConcurrentHashMap<Class<?>, Factory>();\n\n    static {\n        mixinHandlers.putAll(TransactionalHelper.handlers());\n        mixinHandlers.putAll(GetHandleHelper.handlers());\n        mixinHandlers.putAll(TransmogrifierHelper.handlers());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <T> T buildSqlObject(final Class<T> sqlObjectType, final HandleDing handle)\n    {\n        Factory f;\n        if (factories.containsKey(sqlObjectType)) {\n            f = factories.get(sqlObjectType);\n        }\n        else {\n            Enhancer e = new Enhancer();\n            e.setClassLoader(sqlObjectType.getClassLoader());\n\n            List<Class> interfaces = new ArrayList<Class>();\n            interfaces.add(CloseInternalDoNotUseThisClass.class);\n            if (sqlObjectType.isInterface()) {\n                interfaces.add(sqlObjectType);\n            }\n            else {\n                e.setSuperclass(sqlObjectType);\n            }\n            e.setInterfaces(interfaces.toArray(new Class[interfaces.size()]));\n            final SqlObject so = new SqlObject(buildHandlersFor(sqlObjectType), handle);\n            e.setCallback(new MethodInterceptor()\n            {\n                @Override\n                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable\n                {\n                    return so.invoke(o, method, objects, methodProxy);\n                }\n            });\n            T t = (T) e.create();\n            T actual = (T) factories.putIfAbsent(sqlObjectType, (Factory) t);\n            return actual != null ? actual : t;\n        }\n\n        final SqlObject so = new SqlObject(buildHandlersFor(sqlObjectType), handle);\n        return (T) f.newInstance(new MethodInterceptor()\n        {\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable\n            {\n                return so.invoke(o, method, objects, methodProxy);\n            }\n        });\n    }\n\n    private static Map<Method, Handler> buildHandlersFor(Class<?> sqlObjectType)\n    {\n        if (handlersCache.containsKey(sqlObjectType)) {\n            return handlersCache.get(sqlObjectType);\n        }\n\n        final MemberResolver mr = new MemberResolver(typeResolver);\n        final ResolvedType sql_object_type = typeResolver.resolve(sqlObjectType);\n\n        final ResolvedTypeWithMembers d = mr.resolve(sql_object_type, null, null);\n\n        final Map<Method, Handler> handlers = new HashMap<Method, Handler>();\n        for (final ResolvedMethod method : d.getMemberMethods()) {\n            final Method raw_method = method.getRawMember();\n\n            if (raw_method.isAnnotationPresent(SqlQuery.class)) {\n                handlers.put(raw_method, new QueryHandler(sqlObjectType, method, ResultReturnThing.forType(method)));\n            }\n            else if (raw_method.isAnnotationPresent(SqlUpdate.class)) {\n                handlers.put(raw_method, new UpdateHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlBatch.class)) {\n                handlers.put(raw_method, new BatchHandler(sqlObjectType, method));\n            }\n            else if (raw_method.isAnnotationPresent(SqlCall.class)) {\n                handlers.put(raw_method, new CallHandler(sqlObjectType, method));\n            }\n            else if(raw_method.isAnnotationPresent(CreateSqlObject.class)) {\n                handlers.put(raw_method, new CreateSqlObjectHandler(raw_method.getReturnType()));\n            }\n            else if (method.getName().equals(\"close\") && method.getRawMember().getParameterTypes().length == 0) {\n                handlers.put(raw_method, new CloseHandler());\n            }\n            else if (raw_method.isAnnotationPresent(Transaction.class)) {\n                handlers.put(raw_method, new PassThroughTransactionHandler(raw_method, raw_method.getAnnotation(Transaction.class)));\n            }\n            else if (mixinHandlers.containsKey(raw_method)) {\n                handlers.put(raw_method, mixinHandlers.get(raw_method));\n            }\n            else {\n                handlers.put(raw_method, new PassThroughHandler(raw_method));\n            }\n        }\n\n        // this is an implicit mixin, not an explicit one, so we need to *always* add it\n        handlers.putAll(CloseInternalDoNotUseThisClass.Helper.handlers());\n\n        handlers.putAll(EqualsHandler.handler());\n        handlers.putAll(ToStringHandler.handler(sqlObjectType.getName()));\n        handlers.putAll(HashCodeHandler.handler());\n\n        return handlers;\n    }\n\n\n    private final Map<Method, Handler> handlers;\n    private final HandleDing           ding;\n\n    public SqlObject(Map<Method, Handler> handlers, HandleDing ding)\n    {\n        this.handlers = handlers;\n        this.ding = ding;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args, MethodProxy mp) throws Throwable\n    {\n        final Handler handler = handlers.get(method);\n\n        // If there is no handler, pretend we are just an Object and don't open a connection (Issue #82)\n        if (handler == null) {\n            return mp.invokeSuper(proxy, args);\n        }\n\n        try {\n            ding.retain(method.toString());\n            return handler.invoke(ding, proxy, args, mp);\n        }\n        finally {\n            ding.release(method.toString());\n        }\n    }\n\n    public static void close(Object sqlObject)\n    {\n        if (!(sqlObject instanceof CloseInternalDoNotUseThisClass)) {\n            throw new IllegalArgumentException(sqlObject + \" is not a sql object\");\n        }\n        CloseInternalDoNotUseThisClass closer = (CloseInternalDoNotUseThisClass) sqlObject;\n        closer.___jdbi_close___();\n    }\n\n    static String getSql(SqlCall q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlQuery q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlUpdate q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n\n    static String getSql(SqlBatch q, Method m)\n    {\n        if (SqlQuery.DEFAULT_VALUE.equals(q.value())) {\n            return m.getName();\n        }\n        else {\n            return q.value();\n        }\n    }\n}\n","lineNo":160}
{"Smelly Sample":"package org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.tweak.Argument;\nimport org.skife.jdbi.v2.tweak.ArgumentFactory;\n\nimport java.lang.reflect.Constructor;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nclass Foreman\n{\n\n    private final List<ArgumentFactory> factories = new CopyOnWriteArrayList<ArgumentFactory>();\n\n    public Foreman()\n    {\n        factories.add(BUILT_INS);\n    }\n\n    public Foreman(List<ArgumentFactory> factories)\n    {\n        this.factories.addAll(factories);\n    }\n\n    Argument waffle(Class expectedType, Object it, StatementContext ctx)\n    {\n        for (int i = factories.size() - 1; i >= 0; i--) {\n            ArgumentFactory factory = factories.get(i);\n            if (factory.accepts(expectedType, it, ctx)) {\n                return factory.build(expectedType, it, ctx);\n            }\n        }\n        throw new IllegalStateException(\"Unbindable argument passed: \" + String.valueOf(it));\n    }\n\n    private static final ArgumentFactory BUILT_INS = new BuiltInArgumentFactory();\n\n    public void register(ArgumentFactory<?> argumentFactory)\n    {\n        factories.add(argumentFactory);\n    }\n\n    public Foreman createChild()\n    {\n        return new Foreman(factories);\n    }\n\n    private static final class BuiltInArgumentFactory implements ArgumentFactory\n    {\n        private static final Map<Class, P> b = new IdentityHashMap<Class, P>();\n\n        static {\n            b.put(BigDecimal.class, new P(BigDecimalArgument.class));\n            b.put(Blob.class, new P(BlobArgument.class));\n            b.put(Boolean.class, new P(BooleanArgument.class));\n            b.put(boolean.class, new P(BooleanArgument.class));\n            b.put(Byte.class, new P(ByteArgument.class));\n            b.put(byte.class, new P(ByteArgument.class));\n            b.put(byte[].class, new P(ByteArrayArgument.class));\n            b.put(Character.class, new P(CharacterArgument.class));\n            b.put(char.class, new P(CharacterArgument.class));\n            b.put(Clob.class, new P(ClobArgument.class));\n            b.put(Double.class, new P(DoubleArgument.class));\n            b.put(double.class, new P(DoubleArgument.class));\n            b.put(Float.class, new P(FloatArgument.class));\n            b.put(float.class, new P(FloatArgument.class));\n            b.put(Integer.class, new P(IntegerArgument.class));\n            b.put(int.class, new P(IntegerArgument.class));\n            b.put(java.util.Date.class, new P(JavaDateArgument.class));\n            b.put(Long.class, new P(LongArgument.class));\n            b.put(long.class, new P(LongArgument.class));\n            b.put(Object.class, new P(ObjectArgument.class));\n            b.put(Short.class, new P(ShortArgument.class));\n            b.put(short.class, new P(ShortArgument.class));\n            b.put(java.sql.Date.class, new P(SqlDateArgument.class));\n            b.put(String.class, new P(StringArgument.class));\n            b.put(Time.class, new P(TimeArgument.class));\n            b.put(Timestamp.class, new P(TimestampArgument.class));\n            b.put(URL.class, new P(URLArgument.class));\n        }\n\n        public boolean accepts(Class expectedType, Object value, StatementContext ctx)\n        {\n            return b.containsKey(expectedType);\n        }\n\n        public Argument build(Class expectedType, Object value, StatementContext ctx)\n        {\n            return b.get(expectedType).build(value);\n        }\n\n        private static class P\n        {\n            private final Constructor<?> ctor;\n\n            public P(Class<? extends Argument> argType)\n            {\n                this.ctor = argType.getDeclaredConstructors()[0];\n            }\n\n            public Argument build(Object value)\n            {\n                try {\n                    return (Argument) ctor.newInstance(value);\n                }\n                catch (Exception e) {\n                    throw new IllegalStateException(e);\n                }\n            }\n        }\n\n\n    }\n}\n","Method after Refactoring":"package org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.tweak.Argument;\nimport org.skife.jdbi.v2.tweak.ArgumentFactory;\n\nimport java.lang.reflect.Constructor;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nclass Foreman\n{\n\n    private final List<ArgumentFactory> factories = new CopyOnWriteArrayList<ArgumentFactory>();\n\n    public Foreman()\n    {\n        factories.add(BUILT_INS);\n    }\n\n    public Foreman(List<ArgumentFactory> factories)\n    {\n        this.factories.addAll(factories);\n    }\n\n    Argument waffle(Class expectedType, Object it, StatementContext ctx)\n    {\n        ArgumentFactory candidate = null;\n\n        for (int i = factories.size() - 1; i >= 0; i--) {\n            ArgumentFactory factory = factories.get(i);\n            if (factory.accepts(expectedType, it, ctx)) {\n                return factory.build(expectedType, it, ctx);\n            }\n            // Fall back to any factory accepting Object if necessary but\n            // prefer any more specific factory first.\n            if (candidate == null && factory.accepts(Object.class, it, ctx)) {\n                candidate = factory;\n            }\n        }\n        if (candidate != null) {\n            return candidate.build(Object.class, it, ctx);\n        }\n\n        throw new IllegalStateException(\"Unbindable argument passed: \" + String.valueOf(it));\n    }\n\n    private static final ArgumentFactory BUILT_INS = new BuiltInArgumentFactory();\n\n    public void register(ArgumentFactory<?> argumentFactory)\n    {\n        factories.add(argumentFactory);\n    }\n\n    public Foreman createChild()\n    {\n        return new Foreman(factories);\n    }\n\n    private static final class BuiltInArgumentFactory implements ArgumentFactory\n    {\n        private static final Map<Class, P> b = new IdentityHashMap<Class, P>();\n\n        static {\n            b.put(BigDecimal.class, new P(BigDecimalArgument.class));\n            b.put(Blob.class, new P(BlobArgument.class));\n            b.put(Boolean.class, new P(BooleanArgument.class));\n            b.put(boolean.class, new P(BooleanArgument.class));\n            b.put(Byte.class, new P(ByteArgument.class));\n            b.put(byte.class, new P(ByteArgument.class));\n            b.put(byte[].class, new P(ByteArrayArgument.class));\n            b.put(Character.class, new P(CharacterArgument.class));\n            b.put(char.class, new P(CharacterArgument.class));\n            b.put(Clob.class, new P(ClobArgument.class));\n            b.put(Double.class, new P(DoubleArgument.class));\n            b.put(double.class, new P(DoubleArgument.class));\n            b.put(Float.class, new P(FloatArgument.class));\n            b.put(float.class, new P(FloatArgument.class));\n            b.put(Integer.class, new P(IntegerArgument.class));\n            b.put(int.class, new P(IntegerArgument.class));\n            b.put(java.util.Date.class, new P(JavaDateArgument.class));\n            b.put(Long.class, new P(LongArgument.class));\n            b.put(long.class, new P(LongArgument.class));\n            b.put(Object.class, new P(ObjectArgument.class));\n            b.put(Short.class, new P(ShortArgument.class));\n            b.put(short.class, new P(ShortArgument.class));\n            b.put(java.sql.Date.class, new P(SqlDateArgument.class));\n            b.put(String.class, new P(StringArgument.class));\n            b.put(Time.class, new P(TimeArgument.class));\n            b.put(Timestamp.class, new P(TimestampArgument.class));\n            b.put(URL.class, new P(URLArgument.class));\n        }\n\n        public boolean accepts(Class expectedType, Object value, StatementContext ctx)\n        {\n            return b.containsKey(expectedType);\n        }\n\n        public Argument build(Class expectedType, Object value, StatementContext ctx)\n        {\n            P p = b.get(expectedType);\n\n            if (value != null && expectedType == Object.class) {\n                P v = b.get(value.getClass());\n                if (v != null) {\n                    return v.build(value);\n                }\n            }\n            return p.build(value);\n        }\n\n        private static class P\n        {\n            private final Constructor<?> ctor;\n\n            public P(Class<? extends Argument> argType)\n            {\n                this.ctor = argType.getDeclaredConstructors()[0];\n            }\n\n            public Argument build(Object value)\n            {\n                try {\n                    return (Argument) ctor.newInstance(value);\n                }\n                catch (Exception e) {\n                    throw new IllegalStateException(e);\n                }\n            }\n        }\n\n\n    }\n}\n","lineNo":108}
{"Smelly Sample":"package org.skife.jdbi.v2.sqlobject;\n\nimport org.skife.jdbi.v2.SQLStatement;\n\nimport java.beans.BeanInfo;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.annotation.Annotation;\n\nclass BindBeanFactory implements BinderFactory\n{\n    public Binder build(Annotation annotation)\n    {\n        return new Binder<BindBean, Object>()\n        {\n            public void bind(SQLStatement q, BindBean bind, Object arg)\n            {\n                final String prefix;\n                if (\"___jdbi_bare___\".equals(bind.value())) {\n                    prefix = \"\";\n                }\n                else {\n                    prefix = bind.value() + \".\";\n                }\n\n                try {\n                    BeanInfo infos = Introspector.getBeanInfo(arg.getClass());\n                    PropertyDescriptor[] props = infos.getPropertyDescriptors();\n                    for (PropertyDescriptor prop : props) {\n                        q.bind(prefix + prop.getName(), prop.getReadMethod().invoke(arg));\n                    }\n                }\n                catch (Exception e) {\n                    throw new IllegalStateException(\"unable to bind bean properties\", e);\n                }\n\n\n            }\n        };\n    }\n}\n","Method after Refactoring":"package org.skife.jdbi.v2.sqlobject;\n\nimport org.skife.jdbi.v2.SQLStatement;\n\nimport java.beans.BeanInfo;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nclass BindBeanFactory implements BinderFactory\n{\n    public Binder build(Annotation annotation)\n    {\n        return new Binder<BindBean, Object>()\n        {\n            public void bind(SQLStatement q, BindBean bind, Object arg)\n            {\n                final String prefix;\n                if (\"___jdbi_bare___\".equals(bind.value())) {\n                    prefix = \"\";\n                }\n                else {\n                    prefix = bind.value() + \".\";\n                }\n\n                try {\n                    BeanInfo infos = Introspector.getBeanInfo(arg.getClass());\n                    PropertyDescriptor[] props = infos.getPropertyDescriptors();\n                    for (PropertyDescriptor prop : props) {\n                        Method readMethod = prop.getReadMethod();\n                        if (readMethod != null) {\n                            q.bind(prefix + prop.getName(), readMethod.invoke(arg));\n                        }\n                    }\n                }\n                catch (Exception e) {\n                    throw new IllegalStateException(\"unable to bind bean properties\", e);\n                }\n\n\n            }\n        };\n    }\n}\n","lineNo":31}
{"Smelly Sample":"/*\n * Copyright 2004 - 2011 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.regex.Matcher;\n\n/**\n * looks for [name], then [name].sql on the classpath\n */\npublic class ClasspathStatementLocator implements StatementLocator\n{\n    private final ConcurrentMap<String, String> found = new ConcurrentHashMap<String, String>();\n\n    /**\n     * Very basic sanity test to see if a string looks like it might be sql\n     */\n    public static boolean looksLikeSql(String sql) {\n        final String local = left(stripStart(sql), 7).toLowerCase();\n        return local.startsWith(\"insert \")\n               || local.startsWith(\"update \")\n               || local.startsWith(\"select \")\n               || local.startsWith(\"call \")\n               || local.startsWith(\"delete \")\n               || local.startsWith(\"create \")\n               || local.startsWith(\"alter \")\n               || local.startsWith(\"drop \");\n    }\n\n    /**\n     * If the passed in name doesn't look like SQL it will search the classpath for a file\n     * which looks like the provided name.\n     * <p/>\n     * The \"looks like\" algorithm is not very sophisticated, it basically looks for the string\n     * to begin with insert, update, select, call, delete, create, alter, or drop followed\n     * by a space.\n     * <p/>\n     * If no resource is found using the passed in string, the string s returned as-is\n     *\n     * @param name Name or statement literal\n     *\n     * @return SQL to execute (which will go to a StatementRRewrter first)\n     *\n     * @throws UnableToCreateStatementException\n     *          if an IOException occurs reading a found resource\n     */\n    public String locate(String name, StatementContext ctx) {\n        if (found.containsKey(name)) {\n            return found.get(name);\n        }\n\n        if (looksLikeSql(name)) {\n            return name;\n        }\n        final ClassLoader loader = selectClassLoader();\n        BufferedReader reader = null;\n        try {\n            InputStream in_stream = loader.getResourceAsStream(name);\n            if (in_stream == null) {\n                in_stream = loader.getResourceAsStream(name + \".sql\");\n            }\n\n            if ((in_stream == null) && (ctx.getSqlObjectType() != null)) {\n                String filename = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n                in_stream = loader.getResourceAsStream(filename);\n            }\n\n            if (in_stream == null) {\n                return name;\n            }\n\n            final StringBuffer buffer = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(in_stream));\n            String line;\n            try {\n                while ((line = reader.readLine()) != null) {\n                    if (isComment(line)) {\n                        // comment\n                        continue;\n                    }\n                    buffer.append(line).append(\" \");\n                }\n            }\n            catch (IOException e) {\n                throw new UnableToCreateStatementException(e.getMessage(), e, ctx);\n            }\n\n            String sql = buffer.toString();\n            found.putIfAbsent(name, sql);\n            return buffer.toString();\n        }\n        finally {\n            try {\n                if (reader != null) {\n                    reader.close();\n                }\n            }\n            catch (IOException e) {\n                // nothing we can do here :-(\n            }\n        }\n    }\n\n    /**\n     * There *must* be a better place to put this without creating a helpers class just for it\n     */\n    private static ClassLoader selectClassLoader() {\n        ClassLoader loader;\n        if (Thread.currentThread().getContextClassLoader() != null) {\n            loader = Thread.currentThread().getContextClassLoader();\n        }\n        else {\n            loader = ClasspathStatementLocator.class.getClassLoader();\n        }\n        return loader;\n    }\n\n    private static boolean isComment(final String line) {\n        return line.startsWith(\"#\") || line.startsWith(\"--\") || line.startsWith(\"//\");\n    }\n\n    private final static String sep = \"/\"; // *Not* System.getProperty(\"file.separator\"), which breaks in jars\n\n    private static String mungify(String path) {\n        return path.replaceAll(\"\\\\.\", Matcher.quoteReplacement(sep));\n    }\n\n\n    // (scs) Logic copied from commons-lang3 3.1 with minor edits, per discussion on commit 023a14ade2d33bf8ccfa0f68294180455233ad52\n    private static String stripStart(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return \"\";\n        }\n        int start = 0;\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        return str.substring(start);\n    }\n\n    private static String left(String str, int len) {\n        if (str == null || len < 0) {\n            return \"\";\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2004 - 2011 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.regex.Matcher;\n\n/**\n * looks for [name], then [name].sql on the classpath\n */\npublic class ClasspathStatementLocator implements StatementLocator\n{\n    private final ConcurrentMap<String, String> found = new ConcurrentHashMap<String, String>();\n\n    /**\n     * Very basic sanity test to see if a string looks like it might be sql\n     */\n    public static boolean looksLikeSql(String sql)\n    {\n        final String local = left(stripStart(sql), 7).toLowerCase();\n        return local.startsWith(\"insert \")\n               || local.startsWith(\"update \")\n               || local.startsWith(\"select \")\n               || local.startsWith(\"call \")\n               || local.startsWith(\"delete \")\n               || local.startsWith(\"create \")\n               || local.startsWith(\"alter \")\n               || local.startsWith(\"drop \");\n    }\n\n    /**\n     * If the passed in name doesn't look like SQL it will search the classpath for a file\n     * which looks like the provided name.\n     * <p/>\n     * The \"looks like\" algorithm is not very sophisticated, it basically looks for the string\n     * to begin with insert, update, select, call, delete, create, alter, or drop followed\n     * by a space.\n     * <p/>\n     * If no resource is found using the passed in string, the string s returned as-is\n     *\n     * @param name Name or statement literal\n     *\n     * @return SQL to execute (which will go to a StatementRRewrter first)\n     *\n     * @throws UnableToCreateStatementException\n     *          if an IOException occurs reading a found resource\n     */\n    public String locate(String name, StatementContext ctx)\n    {\n        final String cache_key;\n        if (ctx.getSqlObjectType() != null) {\n            cache_key = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n        }\n        else {\n            cache_key = name;\n        }\n\n        if (found.containsKey(cache_key)) {\n            return found.get(cache_key);\n        }\n\n        if (looksLikeSql(name)) {\n            found.putIfAbsent(cache_key, name);\n            return name;\n        }\n        final ClassLoader loader = selectClassLoader();\n        BufferedReader reader = null;\n        try {\n            InputStream in_stream = loader.getResourceAsStream(name);\n            if (in_stream == null) {\n                in_stream = loader.getResourceAsStream(name + \".sql\");\n            }\n\n            if ((in_stream == null) && (ctx.getSqlObjectType() != null)) {\n                String filename = '/' + mungify(ctx.getSqlObjectType().getName() + '.' + name) + \".sql\";\n                in_stream = loader.getResourceAsStream(filename);\n                if (in_stream == null) {\n                    in_stream = ctx.getSqlObjectType().getResourceAsStream(filename);\n                }\n            }\n\n            if (in_stream == null) {\n                return name;\n            }\n\n            final StringBuffer buffer = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(in_stream));\n            String line;\n            try {\n                while ((line = reader.readLine()) != null) {\n                    if (isComment(line)) {\n                        // comment\n                        continue;\n                    }\n                    buffer.append(line).append(\" \");\n                }\n            }\n            catch (IOException e) {\n                throw new UnableToCreateStatementException(e.getMessage(), e, ctx);\n            }\n\n            String sql = buffer.toString();\n            found.putIfAbsent(cache_key, sql);\n            return buffer.toString();\n        }\n        finally {\n            try {\n                if (reader != null) {\n                    reader.close();\n                }\n            }\n            catch (IOException e) {\n                // nothing we can do here :-(\n            }\n        }\n    }\n\n    /**\n     * There *must* be a better place to put this without creating a helpers class just for it\n     */\n    private static ClassLoader selectClassLoader()\n    {\n        ClassLoader loader;\n        if (Thread.currentThread().getContextClassLoader() != null) {\n            loader = Thread.currentThread().getContextClassLoader();\n        }\n        else {\n            loader = ClasspathStatementLocator.class.getClassLoader();\n        }\n        return loader;\n    }\n\n    private static boolean isComment(final String line)\n    {\n        return line.startsWith(\"#\") || line.startsWith(\"--\") || line.startsWith(\"//\");\n    }\n\n    private final static String sep = \"/\"; // *Not* System.getProperty(\"file.separator\"), which breaks in jars\n\n    private static String mungify(String path)\n    {\n        return path.replaceAll(\"\\\\.\", Matcher.quoteReplacement(sep));\n    }\n\n\n    // (scs) Logic copied from commons-lang3 3.1 with minor edits, per discussion on commit 023a14ade2d33bf8ccfa0f68294180455233ad52\n    private static String stripStart(String str)\n    {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return \"\";\n        }\n        int start = 0;\n        while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        return str.substring(start);\n    }\n\n    private static String left(String str, int len)\n    {\n        if (str == null || len < 0) {\n            return \"\";\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n}\n","lineNo":72}
{"Smelly Sample":"package org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport com.sun.xml.internal.ws.handler.HandlerException;\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.PreparedBatch;\nimport org.skife.jdbi.v2.PreparedBatchPart;\nimport org.skife.jdbi.v2.TransactionCallback;\nimport org.skife.jdbi.v2.TransactionStatus;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.sqlobject.customizers.BatchChunkSize;\nimport sun.text.normalizer.IntTrie;\n\nimport java.lang.reflect.Method;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class BatchHandler extends CustomizingStatementHandler\n{\n    private final String  sql;\n    private final boolean transactional;\n    private final int     batchChunkSize;\n\n    public BatchHandler(Class sqlObjectType, ResolvedMethod method)\n    {\n        super(sqlObjectType, method);\n        Method raw_method = method.getRawMember();\n        SqlBatch anno = raw_method.getAnnotation(SqlBatch.class);\n        this.sql = SqlObject.getSql(anno, raw_method);\n        this.transactional = anno.transactional();\n        if (method.getRawMember().isAnnotationPresent(BatchChunkSize.class)) {\n            this.batchChunkSize = raw_method.getAnnotation(BatchChunkSize.class).value();\n            if (this.batchChunkSize <= 0) {\n                throw new IllegalArgumentException(\"Batch chunk size must be >= 0\");\n            }\n        }\n        else {\n            // TODO check for batch chunk size on argument\n\n\n            this.batchChunkSize = Integer.MAX_VALUE;\n        }\n    }\n\n    public Object invoke(HandleDing h, Object target, Object[] args)\n    {\n        Handle handle = h.getHandle();\n\n        List<Iterator> extras = new ArrayList<Iterator>();\n        for (final Object arg : args) {\n            if (arg instanceof Iterable) {\n                extras.add(((Iterable) arg).iterator());\n            }\n            else if (arg instanceof Iterator) {\n                extras.add((Iterator) arg);\n            }\n            else {\n                extras.add(new Iterator()\n                {\n                    public boolean hasNext()\n                    {\n                        return true;\n                    }\n\n                    public Object next()\n                    {\n                        return arg;\n                    }\n\n                    public void remove()\n                    {\n                        // NOOP\n                    }\n                }\n                );\n            }\n        }\n\n        int processed = 0;\n        List<int[]> rs_parts = new ArrayList<int[]>();\n\n        PreparedBatch batch = handle.prepareBatch(sql);\n        Object[] _args = null;\n        while ((_args = next(extras)) != null) {\n            PreparedBatchPart part = batch.add();\n            applyBinders(part, _args);\n            applyCustomizers(part, _args);\n            applySqlStatementCustomizers(part, _args);\n\n            if (++processed == batchChunkSize) {\n                // execute this chunk\n                processed = 0;\n                rs_parts.add(executeBatch(handle, batch));\n                batch = handle.prepareBatch(sql);\n            }\n        }\n\n        //execute the rest\n        rs_parts.add(executeBatch(handle, batch));\n\n        // combine results\n        int end_size = 0;\n        for (int[] rs_part : rs_parts) {\n            end_size += rs_part.length;\n        }\n        int[] rs = new int[end_size];\n        int offset = 0;\n        for (int[] rs_part : rs_parts) {\n            System.arraycopy(rs_part, 0, rs, offset, rs_part.length);\n            offset += rs_part.length;\n        }\n\n        return rs;\n    }\n\n    private int[] executeBatch(final Handle handle, final PreparedBatch batch)\n    {\n        if (transactional) {\n            // it is safe to use same prepared batch as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction(new TransactionCallback<int[]>()\n            {\n                public int[] inTransaction(Handle conn, TransactionStatus status) throws Exception\n                {\n                    return batch.execute();\n                }\n            });\n        }\n        else {\n            return batch.execute();\n        }\n    }\n\n    private static Object[] next(List<Iterator> args)\n    {\n        List<Object> rs = new ArrayList<Object>();\n        for (Iterator arg : args) {\n            if (arg.hasNext()) {\n                rs.add(arg.next());\n            }\n            else {\n                return null;\n            }\n        }\n        return rs.toArray();\n    }\n}\n","Method after Refactoring":"package org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport com.sun.xml.internal.ws.handler.HandlerException;\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.OutParameters;\nimport org.skife.jdbi.v2.PreparedBatch;\nimport org.skife.jdbi.v2.PreparedBatchPart;\nimport org.skife.jdbi.v2.TransactionCallback;\nimport org.skife.jdbi.v2.TransactionStatus;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.sqlobject.customizers.BatchChunkSize;\nimport sun.reflect.annotation.AnnotationParser;\nimport sun.text.normalizer.IntTrie;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.jar.JarEntry;\n\nclass BatchHandler extends CustomizingStatementHandler\n{\n    private final String  sql;\n    private final boolean transactional;\n    private final F       batchChunkSize;\n\n    public BatchHandler(Class sqlObjectType, ResolvedMethod method)\n    {\n        super(sqlObjectType, method);\n        Method raw_method = method.getRawMember();\n        SqlBatch anno = raw_method.getAnnotation(SqlBatch.class);\n        this.sql = SqlObject.getSql(anno, raw_method);\n        this.transactional = anno.transactional();\n\n        // this next big if chain determines the batch chunk size.\n        int index_of_batch_chunk_size_annotation_on_parameter;\n\n        if ((index_of_batch_chunk_size_annotation_on_parameter = findBatchChunkSizeFromParam(raw_method)) >= 0) {\n            final int idx = index_of_batch_chunk_size_annotation_on_parameter;\n            this.batchChunkSize = new F()\n            {\n                public int call(Object[] args)\n                {\n                    return (Integer) args[idx];\n                }\n            };\n        }\n        else if (method.getRawMember().isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = raw_method.getAnnotation(BatchChunkSize.class).value();\n            if (size <= 0) {\n                throw new IllegalArgumentException(\"Batch chunk size must be >= 0\");\n            }\n            batchChunkSize = new F()\n            {\n                public int call(Object[] args)\n                {\n                    return size;\n                }\n            };\n        }\n        else if (sqlObjectType.isAnnotationPresent(BatchChunkSize.class)) {\n            final int size = BatchChunkSize.class.cast(sqlObjectType.getAnnotation(BatchChunkSize.class)).value();\n            this.batchChunkSize = new F()\n            {\n                public int call(Object[] args)\n                {\n                    return size;\n                }\n            };\n        }\n        else {\n            this.batchChunkSize = new F()\n            {\n                public int call(Object[] args)\n                {\n                    return Integer.MAX_VALUE;\n                }\n            };\n        }\n    }\n\n    private int findBatchChunkSizeFromParam(Method raw_method)\n    {\n        Annotation[][] param_annos = raw_method.getParameterAnnotations();\n        for (int i = 0; i < param_annos.length; i++) {\n            Annotation[] annos = param_annos[i];\n            for (Annotation anno : annos) {\n                if (anno.annotationType().isAssignableFrom(BatchChunkSize.class)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    public Object invoke(HandleDing h, Object target, Object[] args)\n    {\n        Handle handle = h.getHandle();\n\n        List<Iterator> extras = new ArrayList<Iterator>();\n        for (final Object arg : args) {\n            if (arg instanceof Iterable) {\n                extras.add(((Iterable) arg).iterator());\n            }\n            else if (arg instanceof Iterator) {\n                extras.add((Iterator) arg);\n            }\n            else {\n                extras.add(new Iterator()\n                {\n                    public boolean hasNext()\n                    {\n                        return true;\n                    }\n\n                    public Object next()\n                    {\n                        return arg;\n                    }\n\n                    public void remove()\n                    {\n                        // NOOP\n                    }\n                }\n                );\n            }\n        }\n\n        int processed = 0;\n        List<int[]> rs_parts = new ArrayList<int[]>();\n\n        PreparedBatch batch = handle.prepareBatch(sql);\n        Object[] _args;\n        int chunk_size = batchChunkSize.call(args);\n        while ((_args = next(extras)) != null) {\n            PreparedBatchPart part = batch.add();\n            applyBinders(part, _args);\n            applyCustomizers(part, _args);\n            applySqlStatementCustomizers(part, _args);\n\n            if (++processed == chunk_size) {\n                // execute this chunk\n                processed = 0;\n                rs_parts.add(executeBatch(handle, batch));\n                batch = handle.prepareBatch(sql);\n            }\n        }\n\n        //execute the rest\n        rs_parts.add(executeBatch(handle, batch));\n\n        // combine results\n        int end_size = 0;\n        for (int[] rs_part : rs_parts) {\n            end_size += rs_part.length;\n        }\n        int[] rs = new int[end_size];\n        int offset = 0;\n        for (int[] rs_part : rs_parts) {\n            System.arraycopy(rs_part, 0, rs, offset, rs_part.length);\n            offset += rs_part.length;\n        }\n\n        return rs;\n    }\n\n    private int[] executeBatch(final Handle handle, final PreparedBatch batch)\n    {\n        if (transactional) {\n            // it is safe to use same prepared batch as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction(new TransactionCallback<int[]>()\n            {\n                public int[] inTransaction(Handle conn, TransactionStatus status) throws Exception\n                {\n                    return batch.execute();\n                }\n            });\n        }\n        else {\n            return batch.execute();\n        }\n    }\n\n    private static Object[] next(List<Iterator> args)\n    {\n        List<Object> rs = new ArrayList<Object>();\n        for (Iterator arg : args) {\n            if (arg.hasNext()) {\n                rs.add(arg.next());\n            }\n            else {\n                return null;\n            }\n        }\n        return rs.toArray();\n    }\n\n    private static interface F\n    {\n        int call(Object[] args);\n    }\n}\n","lineNo":139}
{"Smelly Sample":"package org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.PreparedBatch;\nimport org.skife.jdbi.v2.PreparedBatchPart;\nimport org.skife.jdbi.v2.TransactionCallback;\nimport org.skife.jdbi.v2.TransactionStatus;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport sun.text.normalizer.IntTrie;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class BatchHandler extends CustomizingStatementHandler\n{\n    private final String sql;\n    private final boolean transactional;\n\n    public BatchHandler(Class sqlObjectType, ResolvedMethod method)\n    {\n        super(sqlObjectType, method);\n        SqlBatch anno = method.getRawMember().getAnnotation(SqlBatch.class);\n        this.sql = SqlObject.getSql(anno, method.getRawMember());\n        this.transactional = anno.transactional();\n    }\n\n    public Object invoke(HandleDing h, Object target, Object[] args)\n    {\n        Handle handle = h.getHandle();\n        final PreparedBatch batch = handle.prepareBatch(sql);\n\n        List<Iterator> extras = new ArrayList<Iterator>();\n        for (final Object arg : args) {\n            if (arg instanceof Iterable) {\n                extras.add(((Iterable) arg).iterator());\n            }\n            else if (arg instanceof Iterator) {\n                extras.add((Iterator)arg);\n            }\n            else {\n                extras.add(new Iterator()\n                {\n                    public boolean hasNext()\n                    {\n                        return true;\n                    }\n\n                    public Object next()\n                    {\n                        return arg;\n                    }\n\n                    public void remove()\n                    {\n                        // NOOP\n                    }\n                }\n                );\n            }\n        }\n\n        Object[] _args = null;\n        while ((_args = next(extras)) != null) {\n            PreparedBatchPart part = batch.add();\n            applyBinders(part, _args);\n            applyCustomizers(part, _args);\n            try {\n                applySqlStatementCustomizers(part, _args);\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(\"exception raised in statement customizer application\", e);\n            }\n        }\n        if (transactional) {\n            // it is safe to use same prepared batch as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction(new TransactionCallback<int[]>() {\n                public int[] inTransaction(Handle conn, TransactionStatus status) throws Exception\n                {\n                    return batch.execute();\n                }\n            });\n        }\n        else {\n            return batch.execute();\n        }\n\n    }\n\n    private static Object[] next(List<Iterator> args)\n    {\n        List<Object> rs = new ArrayList<Object>();\n        for (Iterator arg : args) {\n            if (arg.hasNext()) {\n                rs.add(arg.next());\n            }\n            else {\n                return null;\n            }\n        }\n        return rs.toArray();\n    }\n}\n","Method after Refactoring":"package org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport com.sun.xml.internal.ws.handler.HandlerException;\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.PreparedBatch;\nimport org.skife.jdbi.v2.PreparedBatchPart;\nimport org.skife.jdbi.v2.TransactionCallback;\nimport org.skife.jdbi.v2.TransactionStatus;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.sqlobject.customizers.BatchChunkSize;\nimport sun.text.normalizer.IntTrie;\n\nimport java.lang.reflect.Method;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class BatchHandler extends CustomizingStatementHandler\n{\n    private final String sql;\n    private final boolean transactional;\n    private final int batchChunkSize;\n\n    public BatchHandler(Class sqlObjectType, ResolvedMethod method)\n    {\n        super(sqlObjectType, method);\n        Method raw_method = method.getRawMember();\n        SqlBatch anno = raw_method.getAnnotation(SqlBatch.class);\n        this.sql = SqlObject.getSql(anno, raw_method);\n        this.transactional = anno.transactional();\n        if (method.getRawMember().isAnnotationPresent(BatchChunkSize.class)) {\n            this.batchChunkSize = raw_method.getAnnotation(BatchChunkSize.class).value();\n            if (this.batchChunkSize <= 0) {\n                throw new IllegalArgumentException(\"Batch chunk size must be >= 0\");\n            }\n        }\n        else {\n            // TODO check for batch chunk size on argument\n\n\n            this.batchChunkSize = Integer.MAX_VALUE;\n        }\n    }\n\n    public Object invoke(HandleDing h, Object target, Object[] args)\n    {\n        Handle handle = h.getHandle();\n\n        List<Iterator> extras = new ArrayList<Iterator>();\n        for (final Object arg : args) {\n            if (arg instanceof Iterable) {\n                extras.add(((Iterable) arg).iterator());\n            }\n            else if (arg instanceof Iterator) {\n                extras.add((Iterator)arg);\n            }\n            else {\n                extras.add(new Iterator()\n                {\n                    public boolean hasNext()\n                    {\n                        return true;\n                    }\n\n                    public Object next()\n                    {\n                        return arg;\n                    }\n\n                    public void remove()\n                    {\n                        // NOOP\n                    }\n                }\n                );\n            }\n        }\n\n        int processed = 0;\n        List<int[]> rs_parts = new ArrayList<int[]>();\n        PreparedBatch batch = handle.prepareBatch(sql);\n        Object[] _args = null;\n        while ((_args = next(extras)) != null) {\n            PreparedBatchPart part = batch.add();\n            applyBinders(part, _args);\n            applyCustomizers(part, _args);\n            try {\n                applySqlStatementCustomizers(part, _args);\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(\"exception raised in statement customizer application\", e);\n            }\n\n            if (++processed == batchChunkSize) {\n                // execute this chunk\n                processed = 0;\n                rs_parts.add(executeBatch(handle, batch));\n                batch = handle.prepareBatch(sql);\n            }\n        }\n\n        //execute the rest\n        rs_parts.add(executeBatch(handle, batch));\n\n        // combine results\n        int end_size = 0;\n        for (int[] rs_part : rs_parts) {\n            end_size += rs_part.length;\n        }\n        int[] rs = new int[end_size];\n        int offset = 0;\n        for (int[] rs_part : rs_parts) {\n            System.arraycopy(rs_part, 0, rs, offset, rs_part.length);\n            offset += rs_part.length;\n        }\n\n        return rs;\n    }\n\n    private int[] executeBatch(final Handle handle, final PreparedBatch batch)\n    {\n        if (transactional) {\n            // it is safe to use same prepared batch as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction(new TransactionCallback<int[]>() {\n                public int[] inTransaction(Handle conn, TransactionStatus status) throws Exception\n                {\n                    return batch.execute();\n                }\n            });\n        }\n        else {\n            return batch.execute();\n        }\n    }\n\n    private static Object[] next(List<Iterator> args)\n    {\n        List<Object> rs = new ArrayList<Object>();\n        for (Iterator arg : args) {\n            if (arg.hasNext()) {\n                rs.add(arg.next());\n            }\n            else {\n                return null;\n            }\n        }\n        return rs.toArray();\n    }\n}\n","lineNo":29}
{"Smelly Sample":"package org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport org.skife.jdbi.v2.PreparedBatch;\nimport org.skife.jdbi.v2.PreparedBatchPart;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class BatchHandler extends CustomizingStatementHandler\n{\n    private final String sql;\n\n    public BatchHandler(Class sqlObjectType, ResolvedMethod method)\n    {\n        super(sqlObjectType, method);\n        this.sql = SqlObject.getSql(method.getRawMember().getAnnotation(SqlBatch.class), method.getRawMember());\n\n    }\n\n    public Object invoke(HandleDing h, Object target, Object[] args)\n    {\n        PreparedBatch batch = h.getHandle().prepareBatch(sql);\n\n        List<Iterator> extras = new ArrayList<Iterator>();\n        for (final Object arg : args) {\n            if (arg instanceof Iterable) {\n                extras.add(((Iterable) arg).iterator());\n            }\n            else if (arg instanceof Iterator) {\n                extras.add((Iterator)arg);\n            }\n            else {\n                extras.add(new Iterator()\n                {\n                    public boolean hasNext()\n                    {\n                        return true;\n                    }\n\n                    public Object next()\n                    {\n                        return arg;\n                    }\n\n                    public void remove()\n                    {\n                        // NOOP\n                    }\n                }\n                );\n            }\n        }\n\n        Object[] _args = null;\n        while ((_args = next(extras)) != null) {\n            PreparedBatchPart part = batch.add();\n            applyBinders(part, _args);\n            applyCustomizers(part, _args);\n            try {\n                applySqlStatementCustomizers(part, _args);\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(\"exception raised in statement customizer application\", e);\n            }\n        }\n\n\n        return batch.execute();\n    }\n\n    private static Object[] next(List<Iterator> args)\n    {\n        List<Object> rs = new ArrayList<Object>();\n        for (Iterator arg : args) {\n            if (arg.hasNext()) {\n                rs.add(arg.next());\n            }\n            else {\n                return null;\n            }\n        }\n        return rs.toArray();\n    }\n}\n","Method after Refactoring":"package org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.PreparedBatch;\nimport org.skife.jdbi.v2.PreparedBatchPart;\nimport org.skife.jdbi.v2.TransactionCallback;\nimport org.skife.jdbi.v2.TransactionStatus;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport sun.text.normalizer.IntTrie;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class BatchHandler extends CustomizingStatementHandler\n{\n    private final String sql;\n    private final boolean transactional;\n\n    public BatchHandler(Class sqlObjectType, ResolvedMethod method)\n    {\n        super(sqlObjectType, method);\n        SqlBatch anno = method.getRawMember().getAnnotation(SqlBatch.class);\n        this.sql = SqlObject.getSql(anno, method.getRawMember());\n        this.transactional = anno.transactional();\n    }\n\n    public Object invoke(HandleDing h, Object target, Object[] args)\n    {\n        Handle handle = h.getHandle();\n        final PreparedBatch batch = handle.prepareBatch(sql);\n\n        List<Iterator> extras = new ArrayList<Iterator>();\n        for (final Object arg : args) {\n            if (arg instanceof Iterable) {\n                extras.add(((Iterable) arg).iterator());\n            }\n            else if (arg instanceof Iterator) {\n                extras.add((Iterator)arg);\n            }\n            else {\n                extras.add(new Iterator()\n                {\n                    public boolean hasNext()\n                    {\n                        return true;\n                    }\n\n                    public Object next()\n                    {\n                        return arg;\n                    }\n\n                    public void remove()\n                    {\n                        // NOOP\n                    }\n                }\n                );\n            }\n        }\n\n        Object[] _args = null;\n        while ((_args = next(extras)) != null) {\n            PreparedBatchPart part = batch.add();\n            applyBinders(part, _args);\n            applyCustomizers(part, _args);\n            try {\n                applySqlStatementCustomizers(part, _args);\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(\"exception raised in statement customizer application\", e);\n            }\n        }\n        if (transactional) {\n            // it is safe to use same prepared batch as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction(new TransactionCallback<int[]>() {\n                public int[] inTransaction(Handle conn, TransactionStatus status) throws Exception\n                {\n                    return batch.execute();\n                }\n            });\n        }\n        else {\n            return batch.execute();\n        }\n\n    }\n\n    private static Object[] next(List<Iterator> args)\n    {\n        List<Object> rs = new ArrayList<Object>();\n        for (Iterator arg : args) {\n            if (arg.hasNext()) {\n                rs.add(arg.next());\n            }\n            else {\n                return null;\n            }\n        }\n        return rs.toArray();\n    }\n}\n","lineNo":25}
{"Smelly Sample":"package org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport org.skife.jdbi.v2.PreparedBatch;\nimport org.skife.jdbi.v2.PreparedBatchPart;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class BatchHandler extends CustomizingStatementHandler\n{\n    private final String sql;\n\n    public BatchHandler(Class sqlObjectType, ResolvedMethod method)\n    {\n        super(sqlObjectType, method);\n        this.sql = SqlObject.getSql(method.getRawMember().getAnnotation(SqlBatch.class), method.getRawMember());\n\n    }\n\n    public Object invoke(HandleDing h, Object target, Object[] args)\n    {\n        PreparedBatch batch = h.getHandle().prepareBatch(sql);\n\n        List<Iterator> extras = new ArrayList<Iterator>();\n        for (final Object arg : args) {\n            if (arg instanceof Iterable) {\n                extras.add(((Iterable) arg).iterator());\n            }\n            else if (arg instanceof Iterator) {\n                extras.add((Iterator)arg);\n            }\n            else {\n                extras.add(new Iterator()\n                {\n                    public boolean hasNext()\n                    {\n                        return true;\n                    }\n\n                    public Object next()\n                    {\n                        return arg;\n                    }\n\n                    public void remove()\n                    {\n                        // NOOP\n                    }\n                }\n                );\n            }\n        }\n\n        Object[] _args = null;\n        while ((_args = next(extras)) != null) {\n            PreparedBatchPart part = batch.add();\n            applyBinders(part, _args);\n            applyCustomizers(part, _args);\n            try {\n                applySqlStatementCustomizers(part, _args);\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(\"exception raised in statement customizer application\", e);\n            }\n        }\n\n\n        return batch.execute();\n    }\n\n    private static Object[] next(List<Iterator> args)\n    {\n        List<Object> rs = new ArrayList<Object>();\n        for (Iterator arg : args) {\n            if (arg.hasNext()) {\n                rs.add(arg.next());\n            }\n            else {\n                return null;\n            }\n        }\n        return rs.toArray();\n    }\n}\n","Method after Refactoring":"package org.skife.jdbi.v2.sqlobject;\n\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.PreparedBatch;\nimport org.skife.jdbi.v2.PreparedBatchPart;\nimport org.skife.jdbi.v2.TransactionCallback;\nimport org.skife.jdbi.v2.TransactionStatus;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport sun.text.normalizer.IntTrie;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class BatchHandler extends CustomizingStatementHandler\n{\n    private final String sql;\n    private final boolean transactional;\n\n    public BatchHandler(Class sqlObjectType, ResolvedMethod method)\n    {\n        super(sqlObjectType, method);\n        SqlBatch anno = method.getRawMember().getAnnotation(SqlBatch.class);\n        this.sql = SqlObject.getSql(anno, method.getRawMember());\n        this.transactional = anno.transactional();\n    }\n\n    public Object invoke(HandleDing h, Object target, Object[] args)\n    {\n        Handle handle = h.getHandle();\n        final PreparedBatch batch = handle.prepareBatch(sql);\n\n        List<Iterator> extras = new ArrayList<Iterator>();\n        for (final Object arg : args) {\n            if (arg instanceof Iterable) {\n                extras.add(((Iterable) arg).iterator());\n            }\n            else if (arg instanceof Iterator) {\n                extras.add((Iterator)arg);\n            }\n            else {\n                extras.add(new Iterator()\n                {\n                    public boolean hasNext()\n                    {\n                        return true;\n                    }\n\n                    public Object next()\n                    {\n                        return arg;\n                    }\n\n                    public void remove()\n                    {\n                        // NOOP\n                    }\n                }\n                );\n            }\n        }\n\n        Object[] _args = null;\n        while ((_args = next(extras)) != null) {\n            PreparedBatchPart part = batch.add();\n            applyBinders(part, _args);\n            applyCustomizers(part, _args);\n            try {\n                applySqlStatementCustomizers(part, _args);\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(\"exception raised in statement customizer application\", e);\n            }\n        }\n        if (transactional) {\n            // it is safe to use same prepared batch as the inTransaction passes in the same\n            // Handle instance.\n            return handle.inTransaction(new TransactionCallback<int[]>() {\n                public int[] inTransaction(Handle conn, TransactionStatus status) throws Exception\n                {\n                    return batch.execute();\n                }\n            });\n        }\n        else {\n            return batch.execute();\n        }\n\n    }\n\n    private static Object[] next(List<Iterator> args)\n    {\n        List<Object> rs = new ArrayList<Object>();\n        for (Iterator arg : args) {\n            if (arg.hasNext()) {\n                rs.add(arg.next());\n            }\n            else {\n                return null;\n            }\n        }\n        return rs.toArray();\n    }\n}\n","lineNo":32}
{"Smelly Sample":"/*\n * Copyright 2004 - 2011 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport org.skife.jdbi.v2.exceptions.DBIException;\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\nimport org.skife.jdbi.v2.unstable.eod.InferredMapperFactory;\nimport org.skife.jdbi.v2.unstable.eod.Mapper;\n\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class MappingRegistry\n{\n    private final List<ResultSetMapperFactory> factories = new CopyOnWriteArrayList<ResultSetMapperFactory>();\n\n    private final ConcurrentHashMap<ResolvedType, ResultSetMapper> cache = new ConcurrentHashMap<ResolvedType, ResultSetMapper>();\n\n    /**\n     * Copy Constructor\n     */\n    public MappingRegistry(MappingRegistry parent)\n    {\n        factories.addAll(parent.factories);\n        cache.clear();\n    }\n\n    public MappingRegistry() {\n\n    }\n\n    public void add(ResultSetMapper mapper)\n    {\n        this.add(new InferredMapperFactory(mapper));\n    }\n\n    public void add(ResultSetMapperFactory factory)\n    {\n        factories.add(factory);\n        cache.clear();\n    }\n\n    public ResultSetMapper mapperFor(Class type) {\n        for (ResultSetMapperFactory factory : factories) {\n            if (factory.accepts(type)) {\n                return factory.mapperFor(type);\n            }\n        }\n        throw new DBIException(\"No mapper registered for \" + type.getName()) {};\n    }\n\n    public ResultSetMapper mapperFor(ResolvedMethod method, ResolvedType returnType)\n    {\n        if (method.getRawMember().isAnnotationPresent(Mapper.class)) {\n            Mapper mapper = method.getRawMember().getAnnotation(Mapper.class);\n            try {\n                return mapper.value().newInstance();\n            }\n            catch (Exception e) {\n                throw new RuntimeException(\"unable to invoke default ctor on \" + method, e);\n            }\n        }\n\n\n        ResultSetMapper cached_mapper = cache.get(returnType);\n        if (cached_mapper != null) {\n            return cached_mapper;\n        }\n\n        if (method.getRawMember().isAnnotationPresent(Mapper.class)) {\n            Mapper mapper = method.getRawMember().getAnnotation(Mapper.class);\n            try {\n                final ResultSetMapper rsm = mapper.value().newInstance();\n                cache.put(returnType, rsm);\n                return rsm;\n            }\n            catch (Exception e) {\n                throw new RuntimeException(\"unable to invoke default ctor on \" + method, e);\n            }\n        }\n\n\n        for (ResultSetMapperFactory factory : factories) {\n            if (factory.accepts(returnType.getErasedType())) {\n                final ResultSetMapper mapper = factory.mapperFor(returnType.getErasedType());\n                cache.put(returnType, mapper);\n                return mapper;\n            }\n        }\n\n        throw new UnsupportedOperationException(\"Not Yet Implemented!\");\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2004 - 2011 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.DBIException;\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\nimport org.skife.jdbi.v2.unstable.eod.InferredMapperFactory;\n\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class MappingRegistry\n{\n    private final List<ResultSetMapperFactory> factories = new CopyOnWriteArrayList<ResultSetMapperFactory>();\n    private final ConcurrentHashMap<Class, ResultSetMapper> cache = new ConcurrentHashMap<Class, ResultSetMapper>();\n\n    /**\n     * Copy Constructor\n     */\n    public MappingRegistry(MappingRegistry parent)\n    {\n        factories.addAll(parent.factories);\n        cache.putAll(parent.cache);\n    }\n\n    public MappingRegistry() {\n\n    }\n\n    public void add(ResultSetMapper mapper)\n    {\n        this.add(new InferredMapperFactory(mapper));\n    }\n\n    public void add(ResultSetMapperFactory factory)\n    {\n        factories.add(factory);\n        cache.clear();\n    }\n\n    public ResultSetMapper mapperFor(Class type) {\n        if (cache.containsKey(type)) {\n            ResultSetMapper mapper = cache.get(type);\n            if (mapper != null) {\n                return mapper;\n            }\n        }\n\n        for (ResultSetMapperFactory factory : factories) {\n            if (factory.accepts(type)) {\n                ResultSetMapper mapper =  factory.mapperFor(type);\n                cache.put(type, mapper);\n                return mapper;\n            }\n        }\n        throw new DBIException(\"No mapper registered for \" + type.getName()) {};\n    }\n}\n","lineNo":66}
{"Smelly Sample":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.Argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n *\n */\nclass BeanPropertyArguments implements LazyArguments\n{\n    private final Object bean;\n    private final StatementContext ctx;\n    private BeanInfo info;\n\n    BeanPropertyArguments(Object bean, StatementContext ctx)\n    {\n        this.bean = bean;\n        this.ctx = ctx;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed ot be used to\" +\n                                                       \" set named args for a statement via JavaBean properties\", e, ctx);\n        }\n\n    }\n\n    public Argument find(String name)\n    {\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n        {\n            if (descriptor.getName().equals(name))\n            {\n                try\n                {\n                    return new ObjectArgument(descriptor.getReadMethod().invoke(bean));\n                }\n                catch (IllegalAccessException e)\n                {\n                    throw new UnableToCreateStatementException(String.format(\"Access excpetion invoking getter for \" +\n                                                                             \"bean property [%s] on [%s]\",\n                                                                             name, bean), e, ctx);\n                }\n                catch (InvocationTargetException e)\n                {\n                    throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                                                             \"getter for bean property [%s] on [%s]\",\n                                                                             name, bean), e, ctx);\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        return new StringBuilder().append(\"{lazy bean proprty arguments \\\"\").append(bean).append(\"\\\"\").toString();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.tweak.Argument;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.sql.Types;\n\n/**\n *\n */\nclass BeanPropertyArguments implements LazyArguments\n{\n    private final Object bean;\n    private final StatementContext ctx;\n    private BeanInfo info;\n\n    BeanPropertyArguments(Object bean, StatementContext ctx)\n    {\n        this.bean = bean;\n        this.ctx = ctx;\n        try\n        {\n            this.info = Introspector.getBeanInfo(bean.getClass());\n        }\n        catch (IntrospectionException e)\n        {\n            throw new UnableToCreateStatementException(\"Failed to introspect object which is supposed ot be used to\" +\n                                                       \" set named args for a statement via JavaBean properties\", e, ctx);\n        }\n\n    }\n\n    public Argument find(String name)\n    {\n        for (PropertyDescriptor descriptor : info.getPropertyDescriptors())\n        {\n            if (descriptor.getName().equals(name))\n            {\n                try\n                {\n                    final Object result = descriptor.getReadMethod().invoke(bean);\n                    if (result == null) {\n                        return new NullArgument(Types.VARCHAR);\n                    }\n                    else if (result instanceof Argument) {\n                        return (Argument) result;\n                    }\n                    else {\n                        return new ObjectArgument(result);\n                    }\n                }\n                catch (IllegalAccessException e)\n                {\n                    throw new UnableToCreateStatementException(String.format(\"Access excpetion invoking getter for \" +\n                                                                             \"bean property [%s] on [%s]\",\n                                                                             name, bean), e, ctx);\n                }\n                catch (InvocationTargetException e)\n                {\n                    throw new UnableToCreateStatementException(String.format(\"Invocation target exception invoking \" +\n                                                                             \"getter for bean property [%s] on [%s]\",\n                                                                             name, bean), e, ctx);\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        return new StringBuilder().append(\"{lazy bean proprty arguments \\\"\").append(bean).append(\"\\\"\").toString();\n    }\n}\n","lineNo":62}
{"Smelly Sample":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.SQLLog;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents a group of non-prepared statements to be sent to the RDMBS in one \"request\"\n */\npublic class Batch\n{\n    private List<String> parts = new ArrayList<String>();\n    private final StatementRewriter rewriter;\n    private final Connection connection;\n    private final SQLLog log;\n    private final StatementContext context;\n\n    Batch(StatementRewriter rewriter, Connection connection, Map<String, Object> globalStatementAttributes, SQLLog log)\n    {\n        this.rewriter = rewriter;\n        this.connection = connection;\n        this.log = log;\n        this.context = new StatementContext(globalStatementAttributes);\n    }\n\n    /**\n     * Add a statement to the batch\n     *\n     * @param sql SQL to be added to the batch, possibly a named statement\n     * @return the same Batch statement\n     */\n    public Batch add(String sql)\n    {\n        parts.add(sql);\n        return this;\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    public Batch define(String key, Object value) {\n        this.context.setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Execute all the queued up statements\n     *\n     * @return an array of integers representing the return values from each statement's execution\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) return new int[] {};\n\n        Binding empty = new Binding();\n        Statement stmt = null;\n        try\n        {\n            try\n            {\n                stmt = connection.createStatement();\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToCreateStatementException(e, context);\n            }\n\n            final SQLLog.BatchLogger logger = log.logBatch();\n            try\n            {\n                for (String part : parts)\n                {\n                    final String sql= rewriter.rewrite(part, empty, context).getSql();\n                    logger.add(sql);\n                    stmt.addBatch(sql);\n                }\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(\"Unable to configure JDBC statement\", e, context);\n            }\n\n            try\n            {\n                final long start = System.nanoTime();\n                final int[] rs = stmt.executeBatch();\n                logger.log((System.nanoTime() - start) / 1000000L);\n                return rs;\n\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(e, context);\n            }\n        }\n        finally\n        {\n            QueryPostMungeCleanup.CLOSE_RESOURCES_QUIETLY.cleanup(null, stmt, null);\n        }\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.SQLLog;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents a group of non-prepared statements to be sent to the RDMBS in one \"request\"\n */\npublic class Batch\n{\n    private List<String> parts = new ArrayList<String>();\n    private final StatementRewriter rewriter;\n    private final Connection connection;\n    private final SQLLog log;\n    private final StatementContext context;\n    private final TimingCollector timingCollector;\n\n    Batch(StatementRewriter rewriter, Connection connection, Map<String, Object> globalStatementAttributes, SQLLog log, TimingCollector timingCollector)\n    {\n        this.rewriter = rewriter;\n        this.connection = connection;\n        this.log = log;\n        this.timingCollector = timingCollector;\n        this.context = new StatementContext(globalStatementAttributes);\n    }\n\n    /**\n     * Add a statement to the batch\n     *\n     * @param sql SQL to be added to the batch, possibly a named statement\n     * @return the same Batch statement\n     */\n    public Batch add(String sql)\n    {\n        parts.add(sql);\n        return this;\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    public Batch define(String key, Object value) {\n        this.context.setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Execute all the queued up statements\n     *\n     * @return an array of integers representing the return values from each statement's execution\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) return new int[] {};\n\n        Binding empty = new Binding();\n        Statement stmt = null;\n        try\n        {\n            try\n            {\n                stmt = connection.createStatement();\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToCreateStatementException(e, context);\n            }\n\n            final SQLLog.BatchLogger logger = log.logBatch();\n            try\n            {\n                for (String part : parts)\n                {\n                    final String sql= rewriter.rewrite(part, empty, context).getSql();\n                    logger.add(sql);\n                    stmt.addBatch(sql);\n                }\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(\"Unable to configure JDBC statement\", e, context);\n            }\n\n            try\n            {\n                final long start = System.nanoTime();\n                final int[] rs = stmt.executeBatch();\n                final long elapsedTime = (System.nanoTime() - start);\n                logger.log(elapsedTime / 1000000L);\n                // Null for statement, because for batches, we don't really have a good way to keep the sql around.\n                timingCollector.collect(null, context, elapsedTime);\n                return rs;\n\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(e, context);\n            }\n        }\n        finally\n        {\n            QueryPostMungeCleanup.CLOSE_RESOURCES_QUIETLY.cleanup(null, stmt, null);\n        }\n\n    }\n\n}\n","lineNo":116}
{"Smelly Sample":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.RewrittenStatement;\nimport org.skife.jdbi.v2.tweak.SQLLog;\nimport org.skife.jdbi.v2.tweak.StatementBuilder;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents a prepared batch statement. That is, a sql statement compiled as a prepared\n * statement, and then executed multiple times in a single batch. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n */\npublic class PreparedBatch\n{\n    private List<PreparedBatchPart> parts = new ArrayList<PreparedBatchPart>();\n    private final StatementLocator locator;\n    private final StatementRewriter rewriter;\n    private final Connection connection;\n    private final StatementBuilder preparedStatementCache;\n    private final String sql;\n    private final SQLLog log;\n    private final StatementContext context;\n\n    PreparedBatch(StatementLocator locator,\n                  StatementRewriter rewriter,\n                  Connection connection,\n                  StatementBuilder preparedStatementCache,\n                  String sql,\n                  Map<String, Object> globalStatementAttributes,\n                  SQLLog log)\n    {\n        this.locator = locator;\n        this.rewriter = rewriter;\n        this.connection = connection;\n        this.preparedStatementCache = preparedStatementCache;\n        this.sql = sql;\n        this.log = log;\n        this.context = new StatementContext(globalStatementAttributes);\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    public PreparedBatch define(String key, Object value)\n    {\n        context.setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) return new int[]{};\n\n        PreparedBatchPart current = parts.get(0);\n        final String my_sql ;\n        try {\n            my_sql = locator.locate(sql, context);\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(String.format(\"Exception while locating statement for [%s]\",\n                                                                     sql), e, context);\n        }\n        final RewrittenStatement rewritten = rewriter.rewrite(my_sql, current.getParameters(), context);\n        PreparedStatement stmt = null;\n        try {\n            try {\n                stmt = connection.prepareStatement(rewritten.getSql());\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, context);\n            }\n\n            try {\n                for (PreparedBatchPart part : parts) {\n                    rewritten.bind(part.getParameters(), stmt);\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, context);\n            }\n\n            try {\n                final long start = System.nanoTime();\n                final int[] rs =  stmt.executeBatch();\n                log.logPreparedBatch((System.nanoTime() - start) / 1000000L,  rewritten.getSql(), parts.size());\n                return rs;\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, context);\n            }\n        }\n        finally {\n            QueryPostMungeCleanup.CLOSE_RESOURCES_QUIETLY.cleanup(null, stmt, null);\n            this.parts.clear();\n        }\n    }\n\n    /**\n     * Add a statement (part) to this batch. You'll need to bindBinaryStream any arguments to the\n     * part.\n     *\n     * @return A part which can be used to bindBinaryStream parts to the statement\n     */\n    public PreparedBatchPart add()\n    {\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log);\n        parts.add(part);\n        return part;\n    }\n\n\tpublic PreparedBatch add(Object... args)\n\t{\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log);\n\n\t\tfor (int i = 0; i < args.length; ++i) {\n\t\t\tpart.bind(i, args[i]);\n\t\t}\n\n\t\tparts.add(part);\n\n\t\treturn this;\n\t}\n\n\n    /**\n     * Create a new batch part by binding values looked up in <code>args<\/code> to\n     * named parameters on the statement.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     *\n     * @return the new batch part\n     */\n    public PreparedBatchPart add(Map<String, ? extends Object> args)\n    {\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log);\n        parts.add(part);\n        part.bindFromMap(args);\n        return part;\n    }\n\n    /**\n     * The number of statements which are in this batch\n     */\n    public int getSize()\n    {\n        return parts.size();\n    }\n\n    /**\n     * The number of statements which are in this batch\n     */\n    public int size()\n    {\n        return parts.size();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.RewrittenStatement;\nimport org.skife.jdbi.v2.tweak.SQLLog;\nimport org.skife.jdbi.v2.tweak.StatementBuilder;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents a prepared batch statement. That is, a sql statement compiled as a prepared\n * statement, and then executed multiple times in a single batch. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n */\npublic class PreparedBatch\n{\n    private List<PreparedBatchPart> parts = new ArrayList<PreparedBatchPart>();\n    private final StatementLocator locator;\n    private final StatementRewriter rewriter;\n    private final Connection connection;\n    private final StatementBuilder preparedStatementCache;\n    private final String sql;\n    private final SQLLog log;\n    private final TimingCollector timingCollector;\n    private final StatementContext context;\n\n    PreparedBatch(StatementLocator locator,\n                  StatementRewriter rewriter,\n                  Connection connection,\n                  StatementBuilder preparedStatementCache,\n                  String sql,\n                  Map<String, Object> globalStatementAttributes,\n                  SQLLog log,\n                  TimingCollector timingCollector)\n    {\n        this.locator = locator;\n        this.rewriter = rewriter;\n        this.connection = connection;\n        this.preparedStatementCache = preparedStatementCache;\n        this.sql = sql;\n        this.log = log;\n        this.timingCollector = timingCollector;\n        this.context = new StatementContext(globalStatementAttributes);\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    public PreparedBatch define(String key, Object value)\n    {\n        context.setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) return new int[]{};\n\n        PreparedBatchPart current = parts.get(0);\n        final String my_sql ;\n        try {\n            my_sql = locator.locate(sql, context);\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(String.format(\"Exception while locating statement for [%s]\",\n                                                                     sql), e, context);\n        }\n        final RewrittenStatement rewritten = rewriter.rewrite(my_sql, current.getParameters(), context);\n        PreparedStatement stmt = null;\n        try {\n            try {\n                stmt = connection.prepareStatement(rewritten.getSql());\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e, context);\n            }\n\n            try {\n                for (PreparedBatchPart part : parts) {\n                    rewritten.bind(part.getParameters(), stmt);\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e, context);\n            }\n\n            try {\n                final long start = System.nanoTime();\n                final int[] rs =  stmt.executeBatch();\n                final long elapsedTime = (System.nanoTime() - start);\n                log.logPreparedBatch(elapsedTime / 1000000L,  rewritten.getSql(), parts.size());\n                timingCollector.collect(rewritten.getSql(), context, elapsedTime);\n                return rs;\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, context);\n            }\n        }\n        finally {\n            QueryPostMungeCleanup.CLOSE_RESOURCES_QUIETLY.cleanup(null, stmt, null);\n            this.parts.clear();\n        }\n    }\n\n    /**\n     * Add a statement (part) to this batch. You'll need to bindBinaryStream any arguments to the\n     * part.\n     *\n     * @return A part which can be used to bindBinaryStream parts to the statement\n     */\n    public PreparedBatchPart add()\n    {\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log, timingCollector);\n        parts.add(part);\n        return part;\n    }\n\n\tpublic PreparedBatch add(Object... args)\n\t{\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log, timingCollector);\n\n\t\tfor (int i = 0; i < args.length; ++i) {\n\t\t\tpart.bind(i, args[i]);\n\t\t}\n\n\t\tparts.add(part);\n\n\t\treturn this;\n\t}\n\n\n    /**\n     * Create a new batch part by binding values looked up in <code>args<\/code> to\n     * named parameters on the statement.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     *\n     * @return the new batch part\n     */\n    public PreparedBatchPart add(Map<String, ? extends Object> args)\n    {\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log, timingCollector);\n        parts.add(part);\n        part.bindFromMap(args);\n        return part;\n    }\n\n    /**\n     * The number of statements which are in this batch\n     */\n    public int getSize()\n    {\n        return parts.size();\n    }\n\n    /**\n     * The number of statements which are in this batch\n     */\n    public int size()\n    {\n        return parts.size();\n    }\n}\n","lineNo":124}
{"Smelly Sample":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\n\nimport org.skife.jdbi.v2.exceptions.ResultSetException;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.Argument;\nimport org.skife.jdbi.v2.tweak.RewrittenStatement;\nimport org.skife.jdbi.v2.tweak.SQLLog;\nimport org.skife.jdbi.v2.tweak.StatementBuilder;\nimport org.skife.jdbi.v2.tweak.StatementCustomizer;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SQLStatement<SelfType extends SQLStatement<SelfType>>\n{\n    private final Binding params;\n    private final Connection connection;\n    private final String sql;\n    private final StatementRewriter rewriter;\n    private final StatementBuilder statementBuilder;\n    private final StatementLocator locator;\n    private final Collection<StatementCustomizer> customizers = new ArrayList<StatementCustomizer>();\n    private final StatementContext context;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private RewrittenStatement rewritten;\n    private PreparedStatement stmt;\n    private final SQLLog log;\n\n    SQLStatement(Binding params,\n                 StatementLocator locator,\n                 StatementRewriter rewriter,\n                 Connection conn,\n                 StatementBuilder preparedStatementCache,\n                 String sql,\n                 StatementContext ctx,\n                 SQLLog log)\n    {\n        this.log = log;\n        assert (verifyOurNastyDowncastIsOkay());\n        this.context = ctx;\n        this.statementBuilder = preparedStatementCache;\n        this.rewriter = rewriter;\n        this.connection = conn;\n        this.sql = sql;\n        this.params = params;\n        this.locator = locator;\n\n        ctx.setConnection(conn);\n        ctx.setRawSql(sql);\n        ctx.setBinding(params);\n    }\n\n\n    /**\n     * Define a value on the {@link StatementContext}\n     *\n     * @param key Key to acces this value from the StatementContext\n     * @param value Value to setAttribute on the StatementContext\n     * @return this\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType define(String key, Object value)\n    {\n        getContext().setAttribute(key, value);\n        return (SelfType)this;\n    }\n\n    /**\n     * Obtain the statement context associated with this statement\n     */\n    public StatementContext getContext() {\n        return context;\n    }\n\n    /**\n     * Provides a means for custom statement modification. Common cusotmizations\n     * have their own methods, such as {@link Query#setMaxRows(int)}\n     *\n     * @param customizer instance to be used to cstomize a statement\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType addStatementCustomizer(StatementCustomizer customizer)\n    {\n        this.customizers.add(customizer);\n        return (SelfType) this;\n    }\n\n    private boolean verifyOurNastyDowncastIsOkay()\n    {\n        if (this.getClass().getTypeParameters().length == 0) {\n            return true;\n        }\n        else {\n            Class<?> parameterized_type = this.getClass().getTypeParameters()[0].getGenericDeclaration();\n            return parameterized_type.isAssignableFrom(this.getClass());\n        }\n    }\n\n    protected StatementBuilder getStatementBuilder()\n    {\n        return statementBuilder;\n    }\n\n    protected StatementLocator getStatementLocator()\n    {\n        return this.locator;\n    }\n\n    protected StatementRewriter getRewriter()\n    {\n        return rewriter;\n    }\n\n    protected Binding getParams()\n    {\n        return params;\n    }\n\n    protected Connection getConnection()\n    {\n        return connection;\n    }\n\n    /**\n     * The un-translated SQL used to create this statement\n     * @return\n     */\n    protected String getSql()\n    {\n        return sql;\n    }\n\n    protected Binding getParameters()\n    {\n        return params;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bind(int position, Argument argument)\n    {\n        params.addPositional(position, argument);\n        return (SelfType) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bind(String name, Argument argument)\n    {\n        params.addNamed(name, argument);\n        return (SelfType) this;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on o.\n     *\n     * @param o source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bindFromProperties(Object o)\n    {\n        params.addLazyNamedArguments(new BeanPropertyArguments(o, context));\n        return (SelfType) this;\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param args map where keys are matched to named parameters in order to bind arguments\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bindFromMap(Map<String, ? extends Object> args)\n    {\n        params.addLazyNamedArguments(new MapArguments(args));\n        return (SelfType) this;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Character value)\n    {\n        if (value != null) {\n            return bind(position, new CharacterArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.VARCHAR));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Character value)\n    {\n        if (value != null) {\n            return bind(name, new CharacterArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.VARCHAR));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, String value)\n    {\n        return bind(position, new StringArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, String value)\n    {\n        return bind(name, new StringArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, int value)\n    {\n        return bind(position, new IntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Integer value)\n    {\n        if (value != null) {\n            return bind(position, new IntegerArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.INTEGER));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, int value)\n    {\n        return bind(name, new IntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Integer value)\n    {\n        if (value != null) {\n            return bind(name, new IntegerArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.INTEGER));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, char value)\n    {\n        return bind(position, new CharacterArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, char value)\n    {\n        return bind(name, new CharacterArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindASCIIStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindASCIIStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, BigDecimal value)\n    {\n        return bind(position, new BigDecimalArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, BigDecimal value)\n    {\n        return bind(name, new BigDecimalArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindBinaryStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindBinaryStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Blob value)\n    {\n        return bind(position, new BlobArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Blob value)\n    {\n        return bind(name, new BlobArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, boolean value)\n    {\n        return bind(position, new BooleanArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Boolean value)\n    {\n        if (value != null) {\n            return bind(position, new BooleanArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.BOOLEAN));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, boolean value)\n    {\n        return bind(name, new BooleanArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Boolean value)\n    {\n        if (value != null) {\n            return bind(name, new BooleanArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.BOOLEAN));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindAsInt(int position, boolean value)\n    {\n        return bind(position, new BooleanIntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindAsInt(int position, Boolean value)\n    {\n        if (value != null) {\n            return bind(position, new BooleanIntegerArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.INTEGER));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindAsInt(String name, boolean value)\n    {\n        return bind(name, new BooleanIntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindAsInt(String name, Boolean value)\n    {\n        if (value != null) {\n            return bind(name, new BooleanIntegerArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.INTEGER));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, byte value)\n    {\n        return bind(position, new ByteArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Byte value)\n    {\n        if (value != null) {\n            return bind(position, new ByteArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.TINYINT));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, byte value)\n    {\n        return bind(name, new ByteArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Byte value)\n    {\n        if (value != null) {\n            return bind(name, new ByteArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.TINYINT));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, byte[] value)\n    {\n        return bind(position, new ByteArrayArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, byte[] value)\n    {\n        return bind(name, new ByteArrayArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Reader value, int length)\n    {\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Reader value, int length)\n    {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Clob value)\n    {\n        return bind(position, new ClobArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Clob value)\n    {\n        return bind(name, new ClobArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, java.sql.Date value)\n    {\n        return bind(position, new SqlDateArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, java.sql.Date value)\n    {\n        return bind(name, new SqlDateArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, java.util.Date value)\n    {\n        return bind(position, new JavaDateArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, java.util.Date value)\n    {\n        return bind(name, new JavaDateArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, double value)\n    {\n        return bind(position, new DoubleArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Double value)\n    {\n        if (value != null) {\n            return bind(position, new DoubleArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.DOUBLE));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, double value)\n    {\n        return bind(name, new DoubleArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Double value)\n    {\n        if (value != null) {\n            return bind(name, new DoubleArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.DOUBLE));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, float value)\n    {\n        return bind(position, new FloatArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Float value)\n    {\n        if (value != null) {\n            return bind(position, new FloatArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.FLOAT));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, float value)\n    {\n        return bind(name, new FloatArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Float value)\n    {\n        if (value != null) {\n            return bind(name, new FloatArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.FLOAT));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, long value)\n    {\n        return bind(position, new LongArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Long value)\n    {\n        if (value != null) {\n            return bind(position, new LongArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.BIGINT));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, long value)\n    {\n        return bind(name, new LongArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Long value)\n    {\n        if (value != null) {\n            return bind(name, new LongArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.BIGINT));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Short value)\n    {\n        if (value != null) {\n            return bind(position, new ShortArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.SMALLINT));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, short value)\n    {\n        return bind(position, new ShortArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, short value)\n    {\n        return bind(name, new ShortArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Short value)\n    {\n        if (value != null) {\n            return bind(name, new ShortArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.SMALLINT));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Object value)\n    {\n        return bind(position, new ObjectArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Object value)\n    {\n        return bind(name, new ObjectArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Time value)\n    {\n        return bind(position, new TimeArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Time value)\n    {\n        return bind(name, new TimeArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Timestamp value)\n    {\n        return bind(position, new TimestampArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Timestamp value)\n    {\n        return bind(name, new TimestampArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, URL value)\n    {\n        return bind(position, new URLArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, URL value)\n    {\n        return bind(name, new URLArgument(value));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     * @return the same statement instance\n     */\n    public final SelfType bindNull(String name, int sqlType) {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     * @return the same statement instance\n     */\n    public final SelfType bindNull(int position, int sqlType) {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name Named parameter to bind at\n     * @param value Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     * @return self\n     */\n    public final SelfType bindBySqlType(String name, Object value, int sqlType) {\n        return bind(name, new SqlTypeArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     * @return self\n     */\n    public final SelfType bindBySqlType(int position, Object value, int sqlType) {\n        return bind(position, new SqlTypeArgument(value, sqlType));\n    }\n\n    private String wrapLookup(String sql)\n    {\n        try {\n            return locator.locate(sql, this.getContext());\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(\"Exception thrown while looking for statement\", e, context);\n        }\n    }\n\n    protected <Result> Result internalExecute(final QueryPreperator prep,\n                                              final QueryResultMunger<Result> munger,\n                                              final QueryPostMungeCleanup cleanup)\n    {\n        final String located_sql = wrapLookup(sql);\n        this.context.setLocatedSql(located_sql);\n        rewritten = rewriter.rewrite(located_sql, getParameters(), this.context);\n        this.context.setRewrittenSql(rewritten.getSql());\n        ResultSet rs = null;\n        try {\n            try {\n\t            if (getClass().isAssignableFrom(Call.class)) {\n\t\t            stmt = statementBuilder.createCall(this.getConnection(), rewritten.getSql(), context);\n\t            }\n\t            else {\n                    stmt = statementBuilder.create(this.getConnection(), rewritten.getSql(), context);\n\t            }\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e,context);\n            }\n\n            this.context.setStatement(stmt);\n            try {\n                rewritten.bind(getParameters(), stmt);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Unable to bind parameters to query\", e, context);\n            }\n\n            try {\n                prep.prepare(stmt);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Unable to prepare JDBC statement\", e, context);\n            }\n\n            for (StatementCustomizer customizer : customizers) {\n                try {\n                    customizer.beforeExecution(stmt, context);\n                }\n                catch (SQLException e) {\n                    throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e, context);\n                }\n            }\n\n            try {\n                final long start = System.nanoTime();\n                stmt.execute();\n                log.logSQL((System.nanoTime() - start) / 1000000L,  rewritten.getSql());\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, context);\n            }\n\n            for (StatementCustomizer customizer : customizers) {\n                try {\n                    customizer.afterExecution(stmt, context);\n                }\n                catch (SQLException e) {\n                    throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e, context);\n                }\n            }\n\n            try {\n                rs = stmt.getResultSet();\n                return munger.munge(stmt);\n            }\n            catch (SQLException e) {\n                throw new ResultSetException(\"Exception thrown while attempting to traverse the result set\", e, context);\n            }\n        }\n        finally {\n            cleanup.cleanup(this, null, rs);\n        }\n    }\n\n    void close() throws SQLException\n    {\n        this.statementBuilder.close(getConnection(), rewritten.getSql(), stmt);\n    }\n\n    protected SQLLog getLog()\n    {\n        return log;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\n\nimport org.skife.jdbi.v2.exceptions.ResultSetException;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.Argument;\nimport org.skife.jdbi.v2.tweak.RewrittenStatement;\nimport org.skife.jdbi.v2.tweak.SQLLog;\nimport org.skife.jdbi.v2.tweak.StatementBuilder;\nimport org.skife.jdbi.v2.tweak.StatementCustomizer;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SQLStatement<SelfType extends SQLStatement<SelfType>>\n{\n    private final Binding params;\n    private final Connection connection;\n    private final String sql;\n    private final StatementRewriter rewriter;\n    private final StatementBuilder statementBuilder;\n    private final StatementLocator locator;\n    private final Collection<StatementCustomizer> customizers = new ArrayList<StatementCustomizer>();\n    private final StatementContext context;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private RewrittenStatement rewritten;\n    private PreparedStatement stmt;\n    private final SQLLog log;\n    private final TimingCollector timingCollector;\n\n    SQLStatement(Binding params,\n                 StatementLocator locator,\n                 StatementRewriter rewriter,\n                 Connection conn,\n                 StatementBuilder preparedStatementCache,\n                 String sql,\n                 StatementContext ctx,\n                 SQLLog log,\n                 TimingCollector timingCollector)\n    {\n        this.log = log;\n        assert (verifyOurNastyDowncastIsOkay());\n        this.context = ctx;\n        this.statementBuilder = preparedStatementCache;\n        this.rewriter = rewriter;\n        this.connection = conn;\n        this.sql = sql;\n        this.timingCollector = timingCollector;\n        this.params = params;\n        this.locator = locator;\n\n        ctx.setConnection(conn);\n        ctx.setRawSql(sql);\n        ctx.setBinding(params);\n    }\n\n\n    /**\n     * Define a value on the {@link StatementContext}\n     *\n     * @param key Key to acces this value from the StatementContext\n     * @param value Value to setAttribute on the StatementContext\n     * @return this\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType define(String key, Object value)\n    {\n        getContext().setAttribute(key, value);\n        return (SelfType)this;\n    }\n\n    /**\n     * Obtain the statement context associated with this statement\n     */\n    public StatementContext getContext() {\n        return context;\n    }\n\n    /**\n     * Provides a means for custom statement modification. Common cusotmizations\n     * have their own methods, such as {@link Query#setMaxRows(int)}\n     *\n     * @param customizer instance to be used to cstomize a statement\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType addStatementCustomizer(StatementCustomizer customizer)\n    {\n        this.customizers.add(customizer);\n        return (SelfType) this;\n    }\n\n    private boolean verifyOurNastyDowncastIsOkay()\n    {\n        if (this.getClass().getTypeParameters().length == 0) {\n            return true;\n        }\n        else {\n            Class<?> parameterized_type = this.getClass().getTypeParameters()[0].getGenericDeclaration();\n            return parameterized_type.isAssignableFrom(this.getClass());\n        }\n    }\n\n    protected StatementBuilder getStatementBuilder()\n    {\n        return statementBuilder;\n    }\n\n    protected StatementLocator getStatementLocator()\n    {\n        return this.locator;\n    }\n\n    protected StatementRewriter getRewriter()\n    {\n        return rewriter;\n    }\n\n    protected Binding getParams()\n    {\n        return params;\n    }\n\n    protected Connection getConnection()\n    {\n        return connection;\n    }\n\n    /**\n     * The un-translated SQL used to create this statement\n     * @return\n     */\n    protected String getSql()\n    {\n        return sql;\n    }\n\n    protected Binding getParameters()\n    {\n        return params;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bind(int position, Argument argument)\n    {\n        params.addPositional(position, argument);\n        return (SelfType) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bind(String name, Argument argument)\n    {\n        params.addNamed(name, argument);\n        return (SelfType) this;\n    }\n\n    /**\n     * Binds named parameters from JavaBean properties on o.\n     *\n     * @param o source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bindFromProperties(Object o)\n    {\n        params.addLazyNamedArguments(new BeanPropertyArguments(o, context));\n        return (SelfType) this;\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param args map where keys are matched to named parameters in order to bind arguments\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bindFromMap(Map<String, ? extends Object> args)\n    {\n        params.addLazyNamedArguments(new MapArguments(args));\n        return (SelfType) this;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Character value)\n    {\n        if (value != null) {\n            return bind(position, new CharacterArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.VARCHAR));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Character value)\n    {\n        if (value != null) {\n            return bind(name, new CharacterArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.VARCHAR));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, String value)\n    {\n        return bind(position, new StringArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, String value)\n    {\n        return bind(name, new StringArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, int value)\n    {\n        return bind(position, new IntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Integer value)\n    {\n        if (value != null) {\n            return bind(position, new IntegerArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.INTEGER));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, int value)\n    {\n        return bind(name, new IntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Integer value)\n    {\n        if (value != null) {\n            return bind(name, new IntegerArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.INTEGER));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, char value)\n    {\n        return bind(position, new CharacterArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, char value)\n    {\n        return bind(name, new CharacterArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindASCIIStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindASCIIStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, BigDecimal value)\n    {\n        return bind(position, new BigDecimalArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, BigDecimal value)\n    {\n        return bind(name, new BigDecimalArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindBinaryStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindBinaryStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Blob value)\n    {\n        return bind(position, new BlobArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Blob value)\n    {\n        return bind(name, new BlobArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, boolean value)\n    {\n        return bind(position, new BooleanArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Boolean value)\n    {\n        if (value != null) {\n            return bind(position, new BooleanArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.BOOLEAN));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, boolean value)\n    {\n        return bind(name, new BooleanArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Boolean value)\n    {\n        if (value != null) {\n            return bind(name, new BooleanArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.BOOLEAN));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindAsInt(int position, boolean value)\n    {\n        return bind(position, new BooleanIntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindAsInt(int position, Boolean value)\n    {\n        if (value != null) {\n            return bind(position, new BooleanIntegerArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.INTEGER));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindAsInt(String name, boolean value)\n    {\n        return bind(name, new BooleanIntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindAsInt(String name, Boolean value)\n    {\n        if (value != null) {\n            return bind(name, new BooleanIntegerArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.INTEGER));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, byte value)\n    {\n        return bind(position, new ByteArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Byte value)\n    {\n        if (value != null) {\n            return bind(position, new ByteArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.TINYINT));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, byte value)\n    {\n        return bind(name, new ByteArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Byte value)\n    {\n        if (value != null) {\n            return bind(name, new ByteArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.TINYINT));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, byte[] value)\n    {\n        return bind(position, new ByteArrayArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, byte[] value)\n    {\n        return bind(name, new ByteArrayArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Reader value, int length)\n    {\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Reader value, int length)\n    {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Clob value)\n    {\n        return bind(position, new ClobArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Clob value)\n    {\n        return bind(name, new ClobArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, java.sql.Date value)\n    {\n        return bind(position, new SqlDateArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, java.sql.Date value)\n    {\n        return bind(name, new SqlDateArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, java.util.Date value)\n    {\n        return bind(position, new JavaDateArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, java.util.Date value)\n    {\n        return bind(name, new JavaDateArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, double value)\n    {\n        return bind(position, new DoubleArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Double value)\n    {\n        if (value != null) {\n            return bind(position, new DoubleArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.DOUBLE));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, double value)\n    {\n        return bind(name, new DoubleArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Double value)\n    {\n        if (value != null) {\n            return bind(name, new DoubleArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.DOUBLE));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, float value)\n    {\n        return bind(position, new FloatArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Float value)\n    {\n        if (value != null) {\n            return bind(position, new FloatArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.FLOAT));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, float value)\n    {\n        return bind(name, new FloatArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Float value)\n    {\n        if (value != null) {\n            return bind(name, new FloatArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.FLOAT));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, long value)\n    {\n        return bind(position, new LongArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Long value)\n    {\n        if (value != null) {\n            return bind(position, new LongArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.BIGINT));\n        }\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, long value)\n    {\n        return bind(name, new LongArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Long value)\n    {\n        if (value != null) {\n            return bind(name, new LongArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.BIGINT));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Short value)\n    {\n        if (value != null) {\n            return bind(position, new ShortArgument(value));\n        }\n        else {\n            return bind(position, new NullArgument(Types.SMALLINT));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, short value)\n    {\n        return bind(position, new ShortArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, short value)\n    {\n        return bind(name, new ShortArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Short value)\n    {\n        if (value != null) {\n            return bind(name, new ShortArgument(value));\n        }\n        else {\n            return bind(name, new NullArgument(Types.SMALLINT));\n        }\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Object value)\n    {\n        return bind(position, new ObjectArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Object value)\n    {\n        return bind(name, new ObjectArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Time value)\n    {\n        return bind(position, new TimeArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Time value)\n    {\n        return bind(name, new TimeArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Timestamp value)\n    {\n        return bind(position, new TimestampArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Timestamp value)\n    {\n        return bind(name, new TimestampArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, URL value)\n    {\n        return bind(position, new URLArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, URL value)\n    {\n        return bind(name, new URLArgument(value));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     * @return the same statement instance\n     */\n    public final SelfType bindNull(String name, int sqlType) {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     * @return the same statement instance\n     */\n    public final SelfType bindNull(int position, int sqlType) {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name Named parameter to bind at\n     * @param value Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     * @return self\n     */\n    public final SelfType bindBySqlType(String name, Object value, int sqlType) {\n        return bind(name, new SqlTypeArgument(value, sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param value Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     * @return self\n     */\n    public final SelfType bindBySqlType(int position, Object value, int sqlType) {\n        return bind(position, new SqlTypeArgument(value, sqlType));\n    }\n\n    private String wrapLookup(String sql)\n    {\n        try {\n            return locator.locate(sql, this.getContext());\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(\"Exception thrown while looking for statement\", e, context);\n        }\n    }\n\n    protected <Result> Result internalExecute(final QueryPreperator prep,\n                                              final QueryResultMunger<Result> munger,\n                                              final QueryPostMungeCleanup cleanup)\n    {\n        final String located_sql = wrapLookup(sql);\n        this.context.setLocatedSql(located_sql);\n        rewritten = rewriter.rewrite(located_sql, getParameters(), this.context);\n        this.context.setRewrittenSql(rewritten.getSql());\n        ResultSet rs = null;\n        try {\n            try {\n\t            if (getClass().isAssignableFrom(Call.class)) {\n\t\t            stmt = statementBuilder.createCall(this.getConnection(), rewritten.getSql(), context);\n\t            }\n\t            else {\n                    stmt = statementBuilder.create(this.getConnection(), rewritten.getSql(), context);\n\t            }\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e,context);\n            }\n\n            this.context.setStatement(stmt);\n            try {\n                rewritten.bind(getParameters(), stmt);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Unable to bind parameters to query\", e, context);\n            }\n\n            try {\n                prep.prepare(stmt);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Unable to prepare JDBC statement\", e, context);\n            }\n\n            for (StatementCustomizer customizer : customizers) {\n                try {\n                    customizer.beforeExecution(stmt, context);\n                }\n                catch (SQLException e) {\n                    throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e, context);\n                }\n            }\n\n            try {\n                final long start = System.nanoTime();\n                stmt.execute();\n                final long elapsedTime = System.nanoTime() - start;\n                log.logSQL(elapsedTime / 1000000L,  rewritten.getSql());\n                timingCollector.collect(rewritten.getSql(), context, elapsedTime);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e, context);\n            }\n\n            for (StatementCustomizer customizer : customizers) {\n                try {\n                    customizer.afterExecution(stmt, context);\n                }\n                catch (SQLException e) {\n                    throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e, context);\n                }\n            }\n\n            try {\n                rs = stmt.getResultSet();\n                return munger.munge(stmt);\n            }\n            catch (SQLException e) {\n                throw new ResultSetException(\"Exception thrown while attempting to traverse the result set\", e, context);\n            }\n        }\n        finally {\n            cleanup.cleanup(this, null, rs);\n        }\n    }\n\n    void close() throws SQLException\n    {\n        this.statementBuilder.close(getConnection(), rewritten.getSql(), stmt);\n    }\n\n    protected SQLLog getLog()\n    {\n        return log;\n    }\n\n    protected TimingCollector getTimingCollector()\n    {\n        return timingCollector;\n    }\n}\n","lineNo":1276}
{"Smelly Sample":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.ResultSetException;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.Argument;\nimport org.skife.jdbi.v2.tweak.RewrittenStatement;\nimport org.skife.jdbi.v2.tweak.StatementBuilder;\nimport org.skife.jdbi.v2.tweak.StatementCustomizer;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.SQLLog;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SQLStatement<SelfType extends SQLStatement<SelfType>>\n{\n    private final Binding params;\n    private final Connection connection;\n    private final String sql;\n    private final StatementRewriter rewriter;\n    private final StatementBuilder statementBuilder;\n    private final StatementLocator locator;\n    private final Collection<StatementCustomizer> customizers = new ArrayList<StatementCustomizer>();\n    private final StatementContext context;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private RewrittenStatement rewritten;\n    private PreparedStatement stmt;\n    private final SQLLog log;\n\n    SQLStatement(Binding params,\n                 StatementLocator locator,\n                 StatementRewriter rewriter,\n                 Connection conn,\n                 StatementBuilder preparedStatementCache,\n                 String sql,\n                 StatementContext ctx,\n                 SQLLog log)\n    {\n        this.log = log;\n        assert (verifyOurNastyDowncastIsOkay());\n        this.context = ctx;\n        this.statementBuilder = preparedStatementCache;\n        this.rewriter = rewriter;\n        this.connection = conn;\n        this.sql = sql;\n        this.params = params;\n        this.locator = locator;\n    }\n\n\n    /**\n     * Define a value on the {@link StatementContext}\n     *\n     * @param key Key to acces this value from the StatementContext\n     * @param value Value to setAttribute on the StatementContext\n     * @return this\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType define(String key, Object value)\n    {\n        getContext().setAttribute(key, value);\n        return (SelfType)this;\n    }\n\n    /**\n     * Obtain the statement context associated with this statement\n     */\n    public StatementContext getContext() {\n        return context;\n    }\n\n    /**\n     * Provides a means for custom statement modification. Common cusotmizations\n     * have their own methods, such as {@link Query#setMaxRows(int)}\n     *\n     * @param customizer instance to be used to cstomize a statement\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType addStatementCustomizer(StatementCustomizer customizer)\n    {\n        this.customizers.add(customizer);\n        return (SelfType) this;\n    }\n\n    private boolean verifyOurNastyDowncastIsOkay()\n    {\n        if (this.getClass().getTypeParameters().length == 0) {\n            return true;\n        }\n        else {\n            Class parameterized_type = this.getClass().getTypeParameters()[0].getGenericDeclaration();\n            return parameterized_type.isAssignableFrom(this.getClass());\n        }\n    }\n\n    protected StatementBuilder getStatementBuilder()\n    {\n        return statementBuilder;\n    }\n\n    protected StatementLocator getStatementLocator()\n    {\n        return this.locator;\n    }\n\n    protected StatementRewriter getRewriter()\n    {\n        return rewriter;\n    }\n\n    protected Binding getParams()\n    {\n        return params;\n    }\n\n    protected Connection getConnection()\n    {\n        return connection;\n    }\n\n    /**\n     * The un-translated SQL used to create this statement\n     * @return\n     */\n    protected String getSql()\n    {\n        return sql;\n    }\n\n    protected Binding getParameters()\n    {\n        return params;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bind(int position, Argument argument)\n    {\n        params.addPositional(position, argument);\n        return (SelfType) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bind(String name, Argument argument)\n    {\n        params.addNamed(name, argument);\n        return (SelfType) this;\n    }\n\n    /**\n     * Binds named parameters from JavaBean propertues on o\n     *\n     * @param o source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bindFromProperties(Object o)\n    {\n        params.addLazyNamedArguments(new BeanPropertyArguments(o));\n        return (SelfType) this;\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param args map where keys are matched to named parameters in order to bind arguments\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bindFromMap(Map<String, ? extends Object> args)\n    {\n        params.addLazyNamedArguments(new MapArguments(args));\n        return (SelfType) this;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Character value)\n    {\n        return bind(position, new CharacterArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Character value)\n    {\n        return bind(name, new CharacterArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, String value)\n    {\n        return bind(position, new StringArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, String value)\n    {\n        return bind(name, new StringArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, int value)\n    {\n        return bind(position, new IntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, int value)\n    {\n        return bind(name, new IntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindASCIIStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindASCIIStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, BigDecimal value)\n    {\n        return bind(position, new BigDecimalArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, BigDecimal value)\n    {\n        return bind(name, new BigDecimalArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindBinaryStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindBinaryStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Blob value)\n    {\n        return bind(position, new BlobArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Blob value)\n    {\n        return bind(name, new BlobArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, boolean value)\n    {\n        return bind(position, new BooleanArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, boolean value)\n    {\n        return bind(name, new BooleanArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, byte value)\n    {\n        return bind(position, new ByteArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, byte value)\n    {\n        return bind(name, new ByteArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, byte[] value)\n    {\n        return bind(position, new ByteArrayArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, byte[] value)\n    {\n        return bind(name, new ByteArrayArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Reader value, int length)\n    {\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Reader value, int length)\n    {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Clob value)\n    {\n        return bind(position, new ClobArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Clob value)\n    {\n        return bind(name, new ClobArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, java.sql.Date value)\n    {\n        return bind(position, new SqlDateArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, java.sql.Date value)\n    {\n        return bind(name, new SqlDateArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, java.util.Date value)\n    {\n        return bind(position, new JavaDateArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, java.util.Date value)\n    {\n        return bind(name, new JavaDateArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Double value)\n    {\n        return bind(position, new DoubleArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Double value)\n    {\n        return bind(name, new DoubleArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Float value)\n    {\n        return bind(position, new FloatArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Float value)\n    {\n        return bind(name, new FloatArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, long value)\n    {\n        return bind(position, new LongArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, long value)\n    {\n        return bind(name, new LongArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Object value)\n    {\n        return bind(position, new ObjectArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Object value)\n    {\n        return bind(name, new ObjectArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Time value)\n    {\n        return bind(position, new TimeArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Time value)\n    {\n        return bind(name, new TimeArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Timestamp value)\n    {\n        return bind(position, new TimestampArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Timestamp value)\n    {\n        return bind(name, new TimestampArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, URL value)\n    {\n        return bind(position, new URLArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, URL value)\n    {\n        return bind(name, new URLArgument(value));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     * @return the same statement instance\n     */\n    public final SelfType bindNull(String name, int sqlType) {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     * @return the same statement instance\n     */\n    public final SelfType bindNull(int position, int sqlType) {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name Named parameter to bind at\n     * @param value Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     * @return self\n     */\n    public final SelfType bindBySqlType(String name, Object value, int sqlType) {\n        return bind(name, new SqlTypeArgument(value, sqlType));\n    }\n\n    private String wrapLookup(String sql)\n    {\n        try {\n            return locator.locate(sql, this.getContext());\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(\"Exception thrown while looking for statement\", e);\n        }\n    }\n\n    protected <Result> Result internalExecute(final QueryPreperator prep,\n                                              final QueryResultMunger<Result> munger,\n                                              final QueryPostMungeCleanup cleanup)\n    {\n        rewritten = rewriter.rewrite(wrapLookup(sql), getParameters(), this.context);\n        ResultSet rs = null;\n        try {\n            try {\n\t            if (getClass().equals(Call.class)) {\n\t\t            stmt = statementBuilder.createCall(this.getConnection(), rewritten.getSql(), context);   \n\t            }\n\t            else {\n                    stmt = statementBuilder.create(this.getConnection(), rewritten.getSql(), context);\n\t            }\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e);\n            }\n\n            try {\n                rewritten.bind(getParameters(), stmt);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Unable to bind parameters to query\", e);\n            }\n\n            try {\n                prep.prepare(stmt);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Unable to prepare JDBC statement\", e);\n            }\n\n            for (StatementCustomizer customizer : customizers) {\n                try {\n                    customizer.beforeExecution(stmt, context);\n                }\n                catch (SQLException e) {\n                    throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e);\n                }\n            }\n\n            try {\n                final long start = System.currentTimeMillis();\n                stmt.execute();\n                log.logSQL(System.currentTimeMillis() - start,  rewritten.getSql());\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e);\n            }\n\n            for (StatementCustomizer customizer : customizers) {\n                try {\n                    customizer.afterExecution(stmt, context);\n                }\n                catch (SQLException e) {\n                    throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e);\n                }\n            }\n\n            try {\n                rs = stmt.getResultSet();\n                return munger.munge(stmt);\n            }\n            catch (SQLException e) {\n                throw new ResultSetException(\"Exception thrown while attempting to traverse the result set\", e);\n            }\n        }\n        finally {\n            cleanup.cleanup(this, null, rs);\n        }\n    }\n\n    void close() throws SQLException\n    {\n        this.statementBuilder.close(getConnection(), rewritten.getSql(), stmt);\n    }\n\n    protected SQLLog getLog()\n    {\n        return log;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.ResultSetException;\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.Argument;\nimport org.skife.jdbi.v2.tweak.RewrittenStatement;\nimport org.skife.jdbi.v2.tweak.StatementBuilder;\nimport org.skife.jdbi.v2.tweak.StatementCustomizer;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.SQLLog;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\n\n/**\n * This class provides the common functions between <code>Query<\/code> and\n * <code>Update<\/code>. It defines most of the argument binding functions\n * used by its subclasses.\n */\npublic abstract class SQLStatement<SelfType extends SQLStatement<SelfType>>\n{\n    private final Binding params;\n    private final Connection connection;\n    private final String sql;\n    private final StatementRewriter rewriter;\n    private final StatementBuilder statementBuilder;\n    private final StatementLocator locator;\n    private final Collection<StatementCustomizer> customizers = new ArrayList<StatementCustomizer>();\n    private final StatementContext context;\n\n    /**\n     * This will be set on execution, not before\n     */\n    private RewrittenStatement rewritten;\n    private PreparedStatement stmt;\n    private final SQLLog log;\n\n    SQLStatement(Binding params,\n                 StatementLocator locator,\n                 StatementRewriter rewriter,\n                 Connection conn,\n                 StatementBuilder preparedStatementCache,\n                 String sql,\n                 StatementContext ctx,\n                 SQLLog log)\n    {\n        this.log = log;\n        assert (verifyOurNastyDowncastIsOkay());\n        this.context = ctx;\n        this.statementBuilder = preparedStatementCache;\n        this.rewriter = rewriter;\n        this.connection = conn;\n        this.sql = sql;\n        this.params = params;\n        this.locator = locator;\n\n        ctx.setConnection(conn);\n        ctx.setRawSql(sql);\n    }\n\n\n    /**\n     * Define a value on the {@link StatementContext}\n     *\n     * @param key Key to acces this value from the StatementContext\n     * @param value Value to setAttribute on the StatementContext\n     * @return this\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType define(String key, Object value)\n    {\n        getContext().setAttribute(key, value);\n        return (SelfType)this;\n    }\n\n    /**\n     * Obtain the statement context associated with this statement\n     */\n    public StatementContext getContext() {\n        return context;\n    }\n\n    /**\n     * Provides a means for custom statement modification. Common cusotmizations\n     * have their own methods, such as {@link Query#setMaxRows(int)}\n     *\n     * @param customizer instance to be used to cstomize a statement\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType addStatementCustomizer(StatementCustomizer customizer)\n    {\n        this.customizers.add(customizer);\n        return (SelfType) this;\n    }\n\n    private boolean verifyOurNastyDowncastIsOkay()\n    {\n        if (this.getClass().getTypeParameters().length == 0) {\n            return true;\n        }\n        else {\n            Class parameterized_type = this.getClass().getTypeParameters()[0].getGenericDeclaration();\n            return parameterized_type.isAssignableFrom(this.getClass());\n        }\n    }\n\n    protected StatementBuilder getStatementBuilder()\n    {\n        return statementBuilder;\n    }\n\n    protected StatementLocator getStatementLocator()\n    {\n        return this.locator;\n    }\n\n    protected StatementRewriter getRewriter()\n    {\n        return rewriter;\n    }\n\n    protected Binding getParams()\n    {\n        return params;\n    }\n\n    protected Connection getConnection()\n    {\n        return connection;\n    }\n\n    /**\n     * The un-translated SQL used to create this statement\n     * @return\n     */\n    protected String getSql()\n    {\n        return sql;\n    }\n\n    protected Binding getParameters()\n    {\n        return params;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param position position to bindBinaryStream this argument, starting at 0\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bind(int position, Argument argument)\n    {\n        params.addPositional(position, argument);\n        return (SelfType) this;\n    }\n\n    /**\n     * Used if you need to have some exotic parameter bound.\n     *\n     * @param name     name to bindBinaryStream this argument\n     * @param argument exotic argument factory\n     *\n     * @return the same Query instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bind(String name, Argument argument)\n    {\n        params.addNamed(name, argument);\n        return (SelfType) this;\n    }\n\n    /**\n     * Binds named parameters from JavaBean propertues on o\n     *\n     * @param o source of named parameter values to use as arguments\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bindFromProperties(Object o)\n    {\n        params.addLazyNamedArguments(new BeanPropertyArguments(o));\n        return (SelfType) this;\n    }\n\n    /**\n     * Binds named parameters from a map of String to Object instances\n     *\n     * @param args map where keys are matched to named parameters in order to bind arguments\n     *\n     * @return modified statement\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SelfType bindFromMap(Map<String, ? extends Object> args)\n    {\n        params.addLazyNamedArguments(new MapArguments(args));\n        return (SelfType) this;\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Character value)\n    {\n        return bind(position, new CharacterArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the parameter to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Character value)\n    {\n        return bind(name, new CharacterArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, String value)\n    {\n        return bind(position, new StringArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, String value)\n    {\n        return bind(name, new StringArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, int value)\n    {\n        return bind(position, new IntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, int value)\n    {\n        return bind(name, new IntegerArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     * @param length   how long is the stream being bound?\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindASCIIStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindASCIIStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, true));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, BigDecimal value)\n    {\n        return bind(position, new BigDecimalArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, BigDecimal value)\n    {\n        return bind(name, new BigDecimalArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindBinaryStream(int position, InputStream value, int length)\n    {\n        return bind(position, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length bytes to read from value\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bindBinaryStream(String name, InputStream value, int length)\n    {\n        return bind(name, new InputStreamArgument(value, length, false));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Blob value)\n    {\n        return bind(position, new BlobArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Blob value)\n    {\n        return bind(name, new BlobArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, boolean value)\n    {\n        return bind(position, new BooleanArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, boolean value)\n    {\n        return bind(name, new BooleanArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, byte value)\n    {\n        return bind(position, new ByteArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, byte value)\n    {\n        return bind(name, new ByteArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, byte[] value)\n    {\n        return bind(position, new ByteArrayArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, byte[] value)\n    {\n        return bind(name, new ByteArrayArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     * @param length   number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Reader value, int length)\n    {\n        return bind(position, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name   token name to bind the paramater to\n     * @param value  to bind\n     * @param length number of characters to read\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Reader value, int length)\n    {\n        return bind(name, new CharacterStreamArgument(value, length));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Clob value)\n    {\n        return bind(position, new ClobArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Clob value)\n    {\n        return bind(name, new ClobArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, java.sql.Date value)\n    {\n        return bind(position, new SqlDateArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, java.sql.Date value)\n    {\n        return bind(name, new SqlDateArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, java.util.Date value)\n    {\n        return bind(position, new JavaDateArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, java.util.Date value)\n    {\n        return bind(name, new JavaDateArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Double value)\n    {\n        return bind(position, new DoubleArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Double value)\n    {\n        return bind(name, new DoubleArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Float value)\n    {\n        return bind(position, new FloatArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Float value)\n    {\n        return bind(name, new FloatArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, long value)\n    {\n        return bind(position, new LongArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, long value)\n    {\n        return bind(name, new LongArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Object value)\n    {\n        return bind(position, new ObjectArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Object value)\n    {\n        return bind(name, new ObjectArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Time value)\n    {\n        return bind(position, new TimeArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Time value)\n    {\n        return bind(name, new TimeArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, Timestamp value)\n    {\n        return bind(position, new TimestampArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, Timestamp value)\n    {\n        return bind(name, new TimestampArgument(value));\n    }\n\n    /**\n     * Bind an argument positionally\n     *\n     * @param position position to bind the paramater at, starting at 0\n     * @param value    to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(int position, URL value)\n    {\n        return bind(position, new URLArgument(value));\n    }\n\n    /**\n     * Bind an argument by name\n     *\n     * @param name  token name to bind the paramater to\n     * @param value to bind\n     *\n     * @return the same Query instance\n     */\n    public final SelfType bind(String name, URL value)\n    {\n        return bind(name, new URLArgument(value));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param name Named parameter to bind to\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     * @return the same statement instance\n     */\n    public final SelfType bindNull(String name, int sqlType) {\n        return bind(name, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind NULL to be set for a given argument.\n     *\n     * @param position position to bind NULL to, starting at 0\n     * @param sqlType The sqlType must be set and is a value from <code>java.sql.Types<\/code>\n     * @return the same statement instance\n     */\n    public final SelfType bindNull(int position, int sqlType) {\n        return bind(position, new NullArgument(sqlType));\n    }\n\n    /**\n     * Bind a value using a specific type from <code>java.sql.Types<\/code> via\n     * PreparedStatement#setObject(int, Object, int)\n     *\n     * @param name Named parameter to bind at\n     * @param value Value to bind\n     * @param sqlType The sqlType from java.sql.Types\n     * @return self\n     */\n    public final SelfType bindBySqlType(String name, Object value, int sqlType) {\n        return bind(name, new SqlTypeArgument(value, sqlType));\n    }\n\n    private String wrapLookup(String sql)\n    {\n        try {\n            return locator.locate(sql, this.getContext());\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(\"Exception thrown while looking for statement\", e);\n        }\n    }\n\n    protected <Result> Result internalExecute(final QueryPreperator prep,\n                                              final QueryResultMunger<Result> munger,\n                                              final QueryPostMungeCleanup cleanup)\n    {\n        final String located_sql = wrapLookup(sql);\n        this.context.setLocatedSql(located_sql);\n        rewritten = rewriter.rewrite(located_sql, getParameters(), this.context);\n        this.context.setRewrittenSql(rewritten.getSql());\n        ResultSet rs = null;\n        try {\n            try {\n\t            if (getClass().isAssignableFrom(Call.class)) {\n\t\t            stmt = statementBuilder.createCall(this.getConnection(), rewritten.getSql(), context);\n\t            }\n\t            else {\n                    stmt = statementBuilder.create(this.getConnection(), rewritten.getSql(), context);\n\t            }\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e);\n            }\n\n            this.context.setStatement(stmt);\n            try {\n                rewritten.bind(getParameters(), stmt);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Unable to bind parameters to query\", e);\n            }\n\n            try {\n                prep.prepare(stmt);\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Unable to prepare JDBC statement\", e);\n            }\n\n            for (StatementCustomizer customizer : customizers) {\n                try {\n                    customizer.beforeExecution(stmt, context);\n                }\n                catch (SQLException e) {\n                    throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e);\n                }\n            }\n\n            try {\n                final long start = System.currentTimeMillis();\n                stmt.execute();\n                log.logSQL(System.currentTimeMillis() - start,  rewritten.getSql());\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e);\n            }\n\n            for (StatementCustomizer customizer : customizers) {\n                try {\n                    customizer.afterExecution(stmt, context);\n                }\n                catch (SQLException e) {\n                    throw new UnableToExecuteStatementException(\"Exception thrown in statement customization\", e);\n                }\n            }\n\n            try {\n                rs = stmt.getResultSet();\n                return munger.munge(stmt);\n            }\n            catch (SQLException e) {\n                throw new ResultSetException(\"Exception thrown while attempting to traverse the result set\", e);\n            }\n        }\n        finally {\n            cleanup.cleanup(this, null, rs);\n        }\n    }\n\n    void close() throws SQLException\n    {\n        this.statementBuilder.close(getConnection(), rewritten.getSql(), stmt);\n    }\n\n    protected SQLLog getLog()\n    {\n        return log;\n    }\n}\n","lineNo":837}
{"Smelly Sample":"package org.skife.jdbi.v2;\n\nimport org.skife.jdbi.derby.Tools;\n\nimport java.sql.Types;\nimport java.sql.CallableStatement;\nimport java.sql.SQLException;\nimport java.util.Map;\n\npublic class TestCallable extends DBITestCase\n{\n    private BasicHandle h;\n\n    public void setUp() throws Exception\n    {\n        super.setUp();\n        h = openHandle();\n\t    try {\n\t\t    h.execute(\"drop function to_degrees\");\n\t    }\n\t    catch (Exception e) {\n\t    }\n\t    h.execute(\"CREATE FUNCTION TO_DEGREES(RADIANS DOUBLE) RETURNS DOUBLE\\n\" +\n\t\t\t    \"PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA\\n\" +\n\t\t\t    \"EXTERNAL NAME 'java.lang.Math.toDegrees'\");\n    }\n\n    public void tearDown() throws Exception\n    {\n\t    try {\n\t\t    h.execute(\"drop function to_degrees\");\n\t    }\n\t    catch (Exception e) {\n\t    }\n        if (h != null) h.close();\n        Tools.stop();\n    }\n\n    public void testStatement() throws Exception\n    {\n\t    Call.OutParameters ret = h.createCall(\"? = CALL TO_DEGREES(?)\")\n\t\t\t    .registerOutParameter(0, Types.DOUBLE)\n\t\t\t    .bind(1, 100.0d)\n\t\t\t    .invoke();\n\n\t    // JDBI oddity : register or bind is 0-indexed, which JDBC is 1-indexed.\n\t    assertEquals(Math.toDegrees(100.0d), ret.getDouble(1));\n    }\n\n\tpublic void testStatementWithNamedParam() throws Exception\n\t{\n\t\tCall.OutParameters ret = h.createCall(\":x = CALL TO_DEGREES(:y)\")\n\t\t\t\t.registerOutParameter(\"x\", Types.DOUBLE)\n\t\t\t\t.bind(\"y\", 100.0d)\n\t\t\t\t.invoke();\n\n\t\tassertEquals(Math.toDegrees(100.0d), ret.getDouble(\"x\"));\n\t}\n\n}\n","Method after Refactoring":"package org.skife.jdbi.v2;\n\nimport org.skife.jdbi.derby.Tools;\n\nimport java.sql.Types;\nimport java.sql.CallableStatement;\nimport java.sql.SQLException;\nimport java.util.Map;\n\npublic class TestCallable extends DBITestCase\n{\n    private BasicHandle h;\n\n    public void setUp() throws Exception\n    {\n        super.setUp();\n        h = openHandle();\n\t    try {\n\t\t    h.execute(\"drop function to_degrees\");\n\t    }\n\t    catch (Exception e) {\n\t    }\n\t    h.execute(\"CREATE FUNCTION TO_DEGREES(RADIANS DOUBLE) RETURNS DOUBLE\\n\" +\n\t\t\t    \"PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA\\n\" +\n\t\t\t    \"EXTERNAL NAME 'java.lang.Math.toDegrees'\");\n    }\n\n    public void tearDown() throws Exception\n    {\n\t    try {\n\t\t    h.execute(\"drop function to_degrees\");\n\t    }\n\t    catch (Exception e) {\n\t    }\n        if (h != null) h.close();\n        Tools.stop();\n    }\n\n    public void testStatement() throws Exception\n    {\n\t    Call.OutParameters ret = h.createCall(\"? = CALL TO_DEGREES(?)\")\n\t\t\t    .registerOutParameter(0, Types.DOUBLE)\n\t\t\t    .bind(1, 100.0d)\n\t\t\t    .invoke();\n\n\t    // JDBI oddity : register or bind is 0-indexed, which JDBC is 1-indexed.\n\t    Double expected = Math.toDegrees(100.0d);\n\t    assertEquals(expected, ret.getDouble(1));\n\t    assertEquals(expected.longValue(), ret.getLong(1).longValue());\n\t    assertEquals(expected.shortValue(), ret.getShort(1).shortValue());\n\t    assertEquals(expected.intValue(), ret.getInt(1).intValue());\n\t    assertEquals(expected.floatValue(), ret.getFloat(1).floatValue());\n    }\n\n\tpublic void testStatementWithNamedParam() throws Exception\n\t{\n\t\tCall.OutParameters ret = h.createCall(\":x = CALL TO_DEGREES(:y)\")\n\t\t\t\t.registerOutParameter(\"x\", Types.DOUBLE)\n\t\t\t\t.bind(\"y\", 100.0d)\n\t\t\t\t.invoke();\n\n\t\tDouble expected = Math.toDegrees(100.0d);\n\t\tassertEquals(expected, ret.getDouble(\"x\"));\n\t\tassertEquals(expected.longValue(), ret.getLong(\"x\").longValue());\n\t\tassertEquals(expected.shortValue(), ret.getShort(\"x\").shortValue());\n\t\tassertEquals(expected.intValue(), ret.getInt(\"x\").intValue());\n\t\tassertEquals(expected.floatValue(), ret.getFloat(\"x\").floatValue());\n\t}\n\n}\n","lineNo":47}
{"Smelly Sample":"package org.skife.jdbi.v2;\n\nimport org.skife.jdbi.derby.Tools;\n\nimport java.sql.Types;\nimport java.sql.CallableStatement;\nimport java.sql.SQLException;\nimport java.util.Map;\n\npublic class TestCallable extends DBITestCase\n{\n    private BasicHandle h;\n\n    public void setUp() throws Exception\n    {\n        super.setUp();\n        h = openHandle();\n\t    try {\n\t\t    h.execute(\"drop function to_degrees\");\n\t    }\n\t    catch (Exception e) {\n\t    }\n\t    h.execute(\"CREATE FUNCTION TO_DEGREES(RADIANS DOUBLE) RETURNS DOUBLE\\n\" +\n\t\t\t    \"PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA\\n\" +\n\t\t\t    \"EXTERNAL NAME 'java.lang.Math.toDegrees'\");\n    }\n\n    public void tearDown() throws Exception\n    {\n\t    try {\n\t\t    h.execute(\"drop function to_degrees\");\n\t    }\n\t    catch (Exception e) {\n\t    }\n        if (h != null) h.close();\n        Tools.stop();\n    }\n\n    public void testStatement() throws Exception\n    {\n\t    Call.OutParameters ret = h.createCall(\"? = CALL TO_DEGREES(?)\")\n\t\t\t    .registerOutParameter(0, Types.DOUBLE)\n\t\t\t    .bind(1, 100.0d)\n\t\t\t    .invoke();\n\n\t    // JDBI oddity : register or bind is 0-indexed, which JDBC is 1-indexed.\n\t    assertEquals(Math.toDegrees(100.0d), ret.getDouble(1));\n    }\n\n\tpublic void testStatementWithNamedParam() throws Exception\n\t{\n\t\tCall.OutParameters ret = h.createCall(\":x = CALL TO_DEGREES(:y)\")\n\t\t\t\t.registerOutParameter(\"x\", Types.DOUBLE)\n\t\t\t\t.bind(\"y\", 100.0d)\n\t\t\t\t.invoke();\n\n\t\tassertEquals(Math.toDegrees(100.0d), ret.getDouble(\"x\"));\n\t}\n\n}\n","Method after Refactoring":"package org.skife.jdbi.v2;\n\nimport org.skife.jdbi.derby.Tools;\n\nimport java.sql.Types;\nimport java.sql.CallableStatement;\nimport java.sql.SQLException;\nimport java.util.Map;\n\npublic class TestCallable extends DBITestCase\n{\n    private BasicHandle h;\n\n    public void setUp() throws Exception\n    {\n        super.setUp();\n        h = openHandle();\n\t    try {\n\t\t    h.execute(\"drop function to_degrees\");\n\t    }\n\t    catch (Exception e) {\n\t    }\n\t    h.execute(\"CREATE FUNCTION TO_DEGREES(RADIANS DOUBLE) RETURNS DOUBLE\\n\" +\n\t\t\t    \"PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA\\n\" +\n\t\t\t    \"EXTERNAL NAME 'java.lang.Math.toDegrees'\");\n    }\n\n    public void tearDown() throws Exception\n    {\n\t    try {\n\t\t    h.execute(\"drop function to_degrees\");\n\t    }\n\t    catch (Exception e) {\n\t    }\n        if (h != null) h.close();\n        Tools.stop();\n    }\n\n    public void testStatement() throws Exception\n    {\n\t    Call.OutParameters ret = h.createCall(\"? = CALL TO_DEGREES(?)\")\n\t\t\t    .registerOutParameter(0, Types.DOUBLE)\n\t\t\t    .bind(1, 100.0d)\n\t\t\t    .invoke();\n\n\t    // JDBI oddity : register or bind is 0-indexed, which JDBC is 1-indexed.\n\t    Double expected = Math.toDegrees(100.0d);\n\t    assertEquals(expected, ret.getDouble(1));\n\t    assertEquals(expected.longValue(), ret.getLong(1).longValue());\n\t    assertEquals(expected.shortValue(), ret.getShort(1).shortValue());\n\t    assertEquals(expected.intValue(), ret.getInt(1).intValue());\n\t    assertEquals(expected.floatValue(), ret.getFloat(1).floatValue());\n    }\n\n\tpublic void testStatementWithNamedParam() throws Exception\n\t{\n\t\tCall.OutParameters ret = h.createCall(\":x = CALL TO_DEGREES(:y)\")\n\t\t\t\t.registerOutParameter(\"x\", Types.DOUBLE)\n\t\t\t\t.bind(\"y\", 100.0d)\n\t\t\t\t.invoke();\n\n\t\tDouble expected = Math.toDegrees(100.0d);\n\t\tassertEquals(expected, ret.getDouble(\"x\"));\n\t\tassertEquals(expected.longValue(), ret.getLong(\"x\").longValue());\n\t\tassertEquals(expected.shortValue(), ret.getShort(\"x\").shortValue());\n\t\tassertEquals(expected.intValue(), ret.getInt(\"x\").intValue());\n\t\tassertEquals(expected.floatValue(), ret.getFloat(\"x\").floatValue());\n\t}\n\n}\n","lineNo":62}
{"Smelly Sample":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.SQLLog;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents a group of non-prepared statements to be sent to the RDMBS in one \"request\"\n */\npublic class Batch\n{\n    private List<String> parts = new ArrayList<String>();\n    private final StatementRewriter rewriter;\n    private final Connection connection;\n    private final SQLLog log;\n    private final StatementContext context;\n\n    Batch(StatementRewriter rewriter, Connection connection, Map<String, Object> globalStatementAttributes, SQLLog log)\n    {\n        this.rewriter = rewriter;\n        this.connection = connection;\n        this.log = log;\n        this.context = new StatementContext(globalStatementAttributes);\n    }\n\n    /**\n     * Add a statement to the batch\n     *\n     * @param sql SQL to be added to the batch, possibly a named statement\n     * @return the same Batch statement\n     */\n    public Batch add(String sql)\n    {\n        parts.add(sql);\n        return this;\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    public Batch define(String key, Object value) {\n        this.context.setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Execute all the queued up statements\n     *\n     * @return an array of integers representing the return values from each statement's execution\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) return new int[] {};\n\n        Binding empty = new Binding();\n        Statement stmt = null;\n        try\n        {\n            try\n            {\n                stmt = connection.createStatement();\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToCreateStatementException(e);\n            }\n\n            final SQLLog.BatchLogger logger = log.logBatch();\n            try\n            {\n                for (String part : parts)\n                {\n                    final String sql= rewriter.rewrite(part, empty, context).getSql();\n                    logger.add(sql);\n                    stmt.addBatch(sql);\n                }\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(\"Unable to configure JDBC statement\", e);\n            }\n\n            try\n            {\n                logger.log();\n                return stmt.executeBatch();\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(e);\n            }\n        }\n        finally\n        {\n            QueryPostMungeCleanup.CLOSE_RESOURCES_QUIETLY.cleanup(null, stmt, null);\n        }\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.SQLLog;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents a group of non-prepared statements to be sent to the RDMBS in one \"request\"\n */\npublic class Batch\n{\n    private List<String> parts = new ArrayList<String>();\n    private final StatementRewriter rewriter;\n    private final Connection connection;\n    private final SQLLog log;\n    private final StatementContext context;\n\n    Batch(StatementRewriter rewriter, Connection connection, Map<String, Object> globalStatementAttributes, SQLLog log)\n    {\n        this.rewriter = rewriter;\n        this.connection = connection;\n        this.log = log;\n        this.context = new StatementContext(globalStatementAttributes);\n    }\n\n    /**\n     * Add a statement to the batch\n     *\n     * @param sql SQL to be added to the batch, possibly a named statement\n     * @return the same Batch statement\n     */\n    public Batch add(String sql)\n    {\n        parts.add(sql);\n        return this;\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    public Batch define(String key, Object value) {\n        this.context.setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Execute all the queued up statements\n     *\n     * @return an array of integers representing the return values from each statement's execution\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) return new int[] {};\n\n        Binding empty = new Binding();\n        Statement stmt = null;\n        try\n        {\n            try\n            {\n                stmt = connection.createStatement();\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToCreateStatementException(e);\n            }\n\n            final SQLLog.BatchLogger logger = log.logBatch();\n            try\n            {\n                for (String part : parts)\n                {\n                    final String sql= rewriter.rewrite(part, empty, context).getSql();\n                    logger.add(sql);\n                    stmt.addBatch(sql);\n                }\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(\"Unable to configure JDBC statement\", e);\n            }\n\n            try\n            {\n                final long start = System.currentTimeMillis();\n                final int[] rs = stmt.executeBatch();\n                logger.log(System.currentTimeMillis() - start);\n                return rs;\n\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(e);\n            }\n        }\n        finally\n        {\n            QueryPostMungeCleanup.CLOSE_RESOURCES_QUIETLY.cleanup(null, stmt, null);\n        }\n\n    }\n\n}\n","lineNo":113}
{"Smelly Sample":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.RewrittenStatement;\nimport org.skife.jdbi.v2.tweak.StatementBuilder;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.SQLLog;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents a prepared batch statement. That is, a sql statement compiled as a prepared\n * statement, and then executed multiple times in a single batch. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n */\npublic class PreparedBatch\n{\n    private List<PreparedBatchPart> parts = new ArrayList<PreparedBatchPart>();\n    private final StatementLocator locator;\n    private final StatementRewriter rewriter;\n    private final Connection connection;\n    private final StatementBuilder preparedStatementCache;\n    private final String sql;\n    private final SQLLog log;\n    private final StatementContext context;\n\n    PreparedBatch(StatementLocator locator,\n                  StatementRewriter rewriter,\n                  Connection connection,\n                  StatementBuilder preparedStatementCache,\n                  String sql,\n                  Map<String, Object> globalStatementAttributes,\n                  SQLLog log)\n    {\n        this.locator = locator;\n        this.rewriter = rewriter;\n        this.connection = connection;\n        this.preparedStatementCache = preparedStatementCache;\n        this.sql = sql;\n        this.log = log;\n        this.context = new StatementContext(globalStatementAttributes);\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    public PreparedBatch define(String key, Object value)\n    {\n        context.setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) return new int[]{};\n\n        PreparedBatchPart current = parts.get(0);\n        final String my_sql ;\n        try {\n            my_sql = locator.locate(sql, context);\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(String.format(\"Exception while locating statement for [%s]\",\n                                                                     sql), e);\n        }\n        final RewrittenStatement rewritten = rewriter.rewrite(my_sql, current.getParameters(), context);\n        PreparedStatement stmt = null;\n        try {\n            try {\n                stmt = connection.prepareStatement(rewritten.getSql());\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e);\n            }\n\n            try {\n                for (PreparedBatchPart part : parts) {\n                    rewritten.bind(part.getParameters(), stmt);\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e);\n            }\n\n            try {\n                log.logPreparedBatch(rewritten.getSql(), parts.size());\n                return stmt.executeBatch();\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e);\n            }\n        }\n        finally {\n            QueryPostMungeCleanup.CLOSE_RESOURCES_QUIETLY.cleanup(null, stmt, null);\n            this.parts.clear();\n        }\n    }\n\n    /**\n     * Add a statement (part) to this batch. You'll need to bindBinaryStream any arguments to the\n     * part.\n     *\n     * @return A part which can be used to bindBinaryStream parts to the statement\n     */\n    public PreparedBatchPart add()\n    {\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log);\n        parts.add(part);\n        return part;\n    }\n\n\tpublic PreparedBatch add(Object... args)\n\t{\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log);\n\n\t\tfor (int i = 0; i < args.length; ++i) {\n\t\t\tpart.bind(i, args[i]);\n\t\t}\n\n\t\tparts.add(part);\n\n\t\treturn this;\n\t}\n\n\n    /**\n     * Create a new batch part by binding values looked up in <code>args<\/code> to\n     * named parameters on the statement.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     *\n     * @return the new batch part\n     */\n    public PreparedBatchPart add(Map<String, ? extends Object> args)\n    {\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log);\n        parts.add(part);\n        part.bindFromMap(args);\n        return part;\n    }\n\n    /**\n     * The number of statements which are in this batch\n     */\n    public int getSize()\n    {\n        return parts.size();\n    }\n\n    /**\n     * The number of statements which are in this batch\n     */\n    public int size()\n    {\n        return parts.size();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.RewrittenStatement;\nimport org.skife.jdbi.v2.tweak.StatementBuilder;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.SQLLog;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents a prepared batch statement. That is, a sql statement compiled as a prepared\n * statement, and then executed multiple times in a single batch. This is, generally,\n * a very efficient way to execute large numbers of the same statement where\n * the statement only varies by the arguments bound to it.\n */\npublic class PreparedBatch\n{\n    private List<PreparedBatchPart> parts = new ArrayList<PreparedBatchPart>();\n    private final StatementLocator locator;\n    private final StatementRewriter rewriter;\n    private final Connection connection;\n    private final StatementBuilder preparedStatementCache;\n    private final String sql;\n    private final SQLLog log;\n    private final StatementContext context;\n\n    PreparedBatch(StatementLocator locator,\n                  StatementRewriter rewriter,\n                  Connection connection,\n                  StatementBuilder preparedStatementCache,\n                  String sql,\n                  Map<String, Object> globalStatementAttributes,\n                  SQLLog log)\n    {\n        this.locator = locator;\n        this.rewriter = rewriter;\n        this.connection = connection;\n        this.preparedStatementCache = preparedStatementCache;\n        this.sql = sql;\n        this.log = log;\n        this.context = new StatementContext(globalStatementAttributes);\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    public PreparedBatch define(String key, Object value)\n    {\n        context.setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Execute the batch\n     *\n     * @return the number of rows modified or inserted per batch part.\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) return new int[]{};\n\n        PreparedBatchPart current = parts.get(0);\n        final String my_sql ;\n        try {\n            my_sql = locator.locate(sql, context);\n        }\n        catch (Exception e) {\n            throw new UnableToCreateStatementException(String.format(\"Exception while locating statement for [%s]\",\n                                                                     sql), e);\n        }\n        final RewrittenStatement rewritten = rewriter.rewrite(my_sql, current.getParameters(), context);\n        PreparedStatement stmt = null;\n        try {\n            try {\n                stmt = connection.prepareStatement(rewritten.getSql());\n            }\n            catch (SQLException e) {\n                throw new UnableToCreateStatementException(e);\n            }\n\n            try {\n                for (PreparedBatchPart part : parts) {\n                    rewritten.bind(part.getParameters(), stmt);\n                    stmt.addBatch();\n                }\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(\"Exception while binding parameters\", e);\n            }\n\n            try {\n                final long start = System.currentTimeMillis();\n                final int[] rs =  stmt.executeBatch();\n                log.logPreparedBatch(System.currentTimeMillis() - start,  rewritten.getSql(), parts.size());\n                return rs;\n            }\n            catch (SQLException e) {\n                throw new UnableToExecuteStatementException(e);\n            }\n        }\n        finally {\n            QueryPostMungeCleanup.CLOSE_RESOURCES_QUIETLY.cleanup(null, stmt, null);\n            this.parts.clear();\n        }\n    }\n\n    /**\n     * Add a statement (part) to this batch. You'll need to bindBinaryStream any arguments to the\n     * part.\n     *\n     * @return A part which can be used to bindBinaryStream parts to the statement\n     */\n    public PreparedBatchPart add()\n    {\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log);\n        parts.add(part);\n        return part;\n    }\n\n\tpublic PreparedBatch add(Object... args)\n\t{\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log);\n\n\t\tfor (int i = 0; i < args.length; ++i) {\n\t\t\tpart.bind(i, args[i]);\n\t\t}\n\n\t\tparts.add(part);\n\n\t\treturn this;\n\t}\n\n\n    /**\n     * Create a new batch part by binding values looked up in <code>args<\/code> to\n     * named parameters on the statement.\n     *\n     * @param args map to bind arguments from for named parameters on the statement\n     *\n     * @return the new batch part\n     */\n    public PreparedBatchPart add(Map<String, ? extends Object> args)\n    {\n        PreparedBatchPart part = new PreparedBatchPart(this, locator, rewriter, connection, preparedStatementCache, sql, context, log);\n        parts.add(part);\n        part.bindFromMap(args);\n        return part;\n    }\n\n    /**\n     * The number of statements which are in this batch\n     */\n    public int getSize()\n    {\n        return parts.size();\n    }\n\n    /**\n     * The number of statements which are in this batch\n     */\n    public int size()\n    {\n        return parts.size();\n    }\n}\n","lineNo":120}
{"Smelly Sample":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.CallbackFailedException;\nimport org.skife.jdbi.v2.exceptions.UnableToObtainConnectionException;\nimport org.skife.jdbi.v2.tweak.ConnectionFactory;\nimport org.skife.jdbi.v2.tweak.HandleCallback;\nimport org.skife.jdbi.v2.tweak.StatementBuilder;\nimport org.skife.jdbi.v2.tweak.StatementBuilderFactory;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.TransactionHandler;\nimport org.skife.jdbi.v2.tweak.SQLLog;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\nimport org.skife.jdbi.v2.logging.NoOpLog;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * This class  provides the access point for jDBI. Use it to obtain Handle instances\n * and provide \"global\" configuration for all handles obtained from it.\n */\npublic class DBI implements IDBI\n{\n    private final ConnectionFactory connectionFactory;\n    private StatementRewriter statementRewriter = new ColonPrefixNamedParamStatementRewriter();\n    private StatementLocator statementLocator = new ClasspathStatementLocator();\n    private TransactionHandler transactionhandler = new LocalTransactionHandler();\n    private StatementBuilderFactory statementBuilderFactory = new DefaultStatementBuilderFactory();\n    private final Map<String, Object> globalStatementAttributes = new ConcurrentHashMap<String, Object>();\n    private SQLLog log = new NoOpLog();\n\n    /**\n     * Constructor for use with a DataSource which will provide\n     *\n     * @param dataSource\n     */\n    public DBI(DataSource dataSource)\n    {\n        this(new DataSourceConnectionFactory(dataSource));\n        assert (dataSource != null);\n    }\n\n    /**\n     * Constructor used to allow for obtaining a Connection in a customized manner.\n     * <p/>\n     * The {@link org.skife.jdbi.v2.tweak.ConnectionFactory#openConnection()} method will\n     * be invoked to obtain a connection instance whenever a Handle is opened.\n     *\n     * @param connectionFactory PrvidesJDBC connections to Handle instances\n     */\n    public DBI(ConnectionFactory connectionFactory)\n    {\n        assert (connectionFactory != null);\n        this.connectionFactory = connectionFactory;\n    }\n\n    /**\n     * Create a DBI which directly uses the DriverManager\n     *\n     * @param url JDBC URL for connections\n     */\n    public DBI(final String url)\n    {\n        this(new ConnectionFactory()\n        {\n            public Connection openConnection() throws SQLException\n            {\n                return DriverManager.getConnection(url);\n            }\n        });\n    }\n\n    /**\n     * Create a DBI which directly uses the DriverManager\n     *\n     * @param url   JDBC URL for connections\n     * @param props Properties to pass to DriverManager.getConnection(url, props) for each new handle\n     */\n    public DBI(final String url, final Properties props)\n    {\n        this(new ConnectionFactory()\n        {\n            public Connection openConnection() throws SQLException\n            {\n                return DriverManager.getConnection(url, props);\n            }\n        });\n    }\n\n    /**\n     * Create a DBI which directly uses the DriverManager\n     *\n     * @param url      JDBC URL for connections\n     * @param username User name for connection authentication\n     * @param password Password for connection authentication\n     */\n    public DBI(final String url, final String username, final String password)\n    {\n        this(new ConnectionFactory()\n        {\n            public Connection openConnection() throws SQLException\n            {\n                return DriverManager.getConnection(url, username, password);\n            }\n        });\n    }\n\n    /**\n     * Use a non-standard StatementLocator to look up named statements for all\n     * handles created from this DBi instance.\n     *\n     * @param locator StatementLocator which will be used by all Handle instances\n     *                created from this DBI\n     */\n    public void setStatementLocator(StatementLocator locator)\n    {\n        assert (locator != null);\n        this.statementLocator = locator;\n    }\n\n    /**\n     * Use a non-standard StatementRewriter to transform SQL for all Handle instances\n     * created by this DBI.\n     *\n     * @param rewriter StatementRewriter to use on all Handle instances\n     */\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        assert (rewriter != null);\n        this.statementRewriter = rewriter;\n    }\n\n    /**\n     * Specify the TransactionHandler instance to use. This allows overriding\n     * transaction semantics, or mapping into different transaction\n     * management systems.\n     * <p/>\n     * The default version uses local transactions on the database Connection\n     * instances obtained.\n     *\n     * @param handler The TransactionHandler to use for all Handle instances obtained\n     *                from this DBI\n     */\n    public void setTransactionHandler(TransactionHandler handler)\n    {\n        assert (handler != null);\n        this.transactionhandler = handler;\n    }\n\n    /**\n     * Obtain a Handle to the data source wrapped by this DBI instance\n     *\n     * @return an open Handle instance\n     */\n    public Handle open()\n    {\n        try {\n            Connection conn = connectionFactory.openConnection();\n            StatementBuilder cache = statementBuilderFactory.createStatementBuilder(conn);\n            return new BasicHandle(transactionhandler,\n                                   statementLocator,\n                                   cache,\n                                   statementRewriter,\n                                   conn,\n                                   globalStatementAttributes,\n                                   log);\n        }\n        catch (SQLException e) {\n            throw new UnableToObtainConnectionException(e);\n        }\n    }\n\n    /**\n     * Define an attribute on every {@link StatementContext} for every statement created\n     * from a handle obtained from this DBI instance.\n     *\n     * @param key The key for the attribute\n     * @param value the value for the attribute\n     */\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param callback A callback which will receive an open Handle\n     * @return the value returned by callback\n     * @throws CallbackFailedException Will be thrown if callback raises an exception. This exception will\n     *                                 wrap the exception thrown by the callback.\n     */\n    public <ReturnType> ReturnType withHandle(HandleCallback<ReturnType> callback) throws CallbackFailedException\n    {\n        final Handle h = this.open();\n        try {\n            return callback.withHandle(h);\n        }\n        catch (Exception e) {\n            throw new CallbackFailedException(e);\n        }\n        finally {\n            h.close();\n        }\n    }\n\n    /**\n     * Convenience methd used to obtain a handle from a specific data source\n     *\n     * @param dataSource\n     *\n     * @return Handle using a Connection obtained from the provided DataSource\n     */\n    public static Handle open(DataSource dataSource)\n    {\n        assert (dataSource != null);\n        return new DBI(dataSource).open();\n    }\n\n    /**\n     * Create a Handle wrapping a particular JDBC Connection\n     *\n     * @param connection\n     *\n     * @return Handle bound to connection\n     */\n    public static Handle open(final Connection connection)\n    {\n        assert (connection != null);\n        return new DBI(new ConnectionFactory()\n        {\n            public Connection openConnection()\n            {\n                return connection;\n            }\n        }).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url JDBC Url\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url)\n    {\n        assert (url != null);\n        return new DBI(url).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url      JDBC Url\n     * @param username JDBC username for authentication\n     * @param password JDBC password for authentication\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final String username, final String password)\n    {\n        assert (url != null);\n        return new DBI(url, username, password).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url   JDBC Url\n     * @param props JDBC properties\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final Properties props)\n    {\n        assert (url != null);\n        return new DBI(url, props).open();\n    }\n\n    /**\n     * Allows customization of how prepared statements are created. When a Handle is created\n     * against this DBI instance the factory will be used to create a StatementBuilder for\n     * that specific handle. When the handle is closed, the StatementBuilder's close method\n     * will be invoked.\n     */\n    public void setStatementBuilderFactory(StatementBuilderFactory factory)\n    {\n        this.statementBuilderFactory = factory;\n    }\n\n    /**\n     * Specify the class used to log sql statements. Will be passed to all handles created from\n     * this instance\n     */\n    public void setSQLLog(SQLLog log)\n    {\n        this.log = log;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2007 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.CallbackFailedException;\nimport org.skife.jdbi.v2.exceptions.UnableToObtainConnectionException;\nimport org.skife.jdbi.v2.tweak.ConnectionFactory;\nimport org.skife.jdbi.v2.tweak.HandleCallback;\nimport org.skife.jdbi.v2.tweak.StatementBuilder;\nimport org.skife.jdbi.v2.tweak.StatementBuilderFactory;\nimport org.skife.jdbi.v2.tweak.StatementLocator;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.TransactionHandler;\nimport org.skife.jdbi.v2.tweak.SQLLog;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\nimport org.skife.jdbi.v2.logging.NoOpLog;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * This class  provides the access point for jDBI. Use it to obtain Handle instances\n * and provide \"global\" configuration for all handles obtained from it.\n */\npublic class DBI implements IDBI\n{\n    private final ConnectionFactory connectionFactory;\n    private StatementRewriter statementRewriter = new ColonPrefixNamedParamStatementRewriter();\n    private StatementLocator statementLocator = new ClasspathStatementLocator();\n    private TransactionHandler transactionhandler = new LocalTransactionHandler();\n    private StatementBuilderFactory statementBuilderFactory = new DefaultStatementBuilderFactory();\n    private final Map<String, Object> globalStatementAttributes = new ConcurrentHashMap<String, Object>();\n    private SQLLog log = new NoOpLog();\n\n    /**\n     * Constructor for use with a DataSource which will provide\n     *\n     * @param dataSource\n     */\n    public DBI(DataSource dataSource)\n    {\n        this(new DataSourceConnectionFactory(dataSource));\n        assert (dataSource != null);\n    }\n\n    /**\n     * Constructor used to allow for obtaining a Connection in a customized manner.\n     * <p/>\n     * The {@link org.skife.jdbi.v2.tweak.ConnectionFactory#openConnection()} method will\n     * be invoked to obtain a connection instance whenever a Handle is opened.\n     *\n     * @param connectionFactory PrvidesJDBC connections to Handle instances\n     */\n    public DBI(ConnectionFactory connectionFactory)\n    {\n        assert (connectionFactory != null);\n        this.connectionFactory = connectionFactory;\n    }\n\n    /**\n     * Create a DBI which directly uses the DriverManager\n     *\n     * @param url JDBC URL for connections\n     */\n    public DBI(final String url)\n    {\n        this(new ConnectionFactory()\n        {\n            public Connection openConnection() throws SQLException\n            {\n                return DriverManager.getConnection(url);\n            }\n        });\n    }\n\n    /**\n     * Create a DBI which directly uses the DriverManager\n     *\n     * @param url   JDBC URL for connections\n     * @param props Properties to pass to DriverManager.getConnection(url, props) for each new handle\n     */\n    public DBI(final String url, final Properties props)\n    {\n        this(new ConnectionFactory()\n        {\n            public Connection openConnection() throws SQLException\n            {\n                return DriverManager.getConnection(url, props);\n            }\n        });\n    }\n\n    /**\n     * Create a DBI which directly uses the DriverManager\n     *\n     * @param url      JDBC URL for connections\n     * @param username User name for connection authentication\n     * @param password Password for connection authentication\n     */\n    public DBI(final String url, final String username, final String password)\n    {\n        this(new ConnectionFactory()\n        {\n            public Connection openConnection() throws SQLException\n            {\n                return DriverManager.getConnection(url, username, password);\n            }\n        });\n    }\n\n    /**\n     * Use a non-standard StatementLocator to look up named statements for all\n     * handles created from this DBi instance.\n     *\n     * @param locator StatementLocator which will be used by all Handle instances\n     *                created from this DBI\n     */\n    public void setStatementLocator(StatementLocator locator)\n    {\n        assert (locator != null);\n        this.statementLocator = locator;\n    }\n\n    /**\n     * Use a non-standard StatementRewriter to transform SQL for all Handle instances\n     * created by this DBI.\n     *\n     * @param rewriter StatementRewriter to use on all Handle instances\n     */\n    public void setStatementRewriter(StatementRewriter rewriter)\n    {\n        assert (rewriter != null);\n        this.statementRewriter = rewriter;\n    }\n\n    /**\n     * Specify the TransactionHandler instance to use. This allows overriding\n     * transaction semantics, or mapping into different transaction\n     * management systems.\n     * <p/>\n     * The default version uses local transactions on the database Connection\n     * instances obtained.\n     *\n     * @param handler The TransactionHandler to use for all Handle instances obtained\n     *                from this DBI\n     */\n    public void setTransactionHandler(TransactionHandler handler)\n    {\n        assert (handler != null);\n        this.transactionhandler = handler;\n    }\n\n    /**\n     * Obtain a Handle to the data source wrapped by this DBI instance\n     *\n     * @return an open Handle instance\n     */\n    public Handle open()\n    {\n        try {\n            Connection conn = connectionFactory.openConnection();\n            StatementBuilder cache = statementBuilderFactory.createStatementBuilder(conn);\n            Handle h = new BasicHandle(transactionhandler,\n                                       statementLocator,\n                                       cache,\n                                       statementRewriter,\n                                       conn,\n                                       globalStatementAttributes,\n                                       log);\n            log.logObtainHandle(h);\n            return h;\n        }\n        catch (SQLException e) {\n            throw new UnableToObtainConnectionException(e);\n        }\n    }\n\n    /**\n     * Define an attribute on every {@link StatementContext} for every statement created\n     * from a handle obtained from this DBI instance.\n     *\n     * @param key   The key for the attribute\n     * @param value the value for the attribute\n     */\n    public void define(String key, Object value)\n    {\n        this.globalStatementAttributes.put(key, value);\n    }\n\n    /**\n     * A convenience function which manages the lifecycle of a handle and yields it to a callback\n     * for use by clients.\n     *\n     * @param callback A callback which will receive an open Handle\n     *\n     * @return the value returned by callback\n     *\n     * @throws CallbackFailedException Will be thrown if callback raises an exception. This exception will\n     *                                 wrap the exception thrown by the callback.\n     */\n    public <ReturnType> ReturnType withHandle(HandleCallback<ReturnType> callback) throws CallbackFailedException\n    {\n        final Handle h = this.open();\n        try {\n            return callback.withHandle(h);\n        }\n        catch (Exception e) {\n            throw new CallbackFailedException(e);\n        }\n        finally {\n            h.close();\n        }\n    }\n\n    /**\n     * Convenience methd used to obtain a handle from a specific data source\n     *\n     * @param dataSource\n     *\n     * @return Handle using a Connection obtained from the provided DataSource\n     */\n    public static Handle open(DataSource dataSource)\n    {\n        assert (dataSource != null);\n        return new DBI(dataSource).open();\n    }\n\n    /**\n     * Create a Handle wrapping a particular JDBC Connection\n     *\n     * @param connection\n     *\n     * @return Handle bound to connection\n     */\n    public static Handle open(final Connection connection)\n    {\n        assert (connection != null);\n        return new DBI(new ConnectionFactory()\n        {\n            public Connection openConnection()\n            {\n                return connection;\n            }\n        }).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url JDBC Url\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url)\n    {\n        assert (url != null);\n        return new DBI(url).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url      JDBC Url\n     * @param username JDBC username for authentication\n     * @param password JDBC password for authentication\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final String username, final String password)\n    {\n        assert (url != null);\n        return new DBI(url, username, password).open();\n    }\n\n    /**\n     * Obtain a handle with just a JDBC URL\n     *\n     * @param url   JDBC Url\n     * @param props JDBC properties\n     *\n     * @return newly opened Handle\n     */\n    public static Handle open(final String url, final Properties props)\n    {\n        assert (url != null);\n        return new DBI(url, props).open();\n    }\n\n    /**\n     * Allows customization of how prepared statements are created. When a Handle is created\n     * against this DBI instance the factory will be used to create a StatementBuilder for\n     * that specific handle. When the handle is closed, the StatementBuilder's close method\n     * will be invoked.\n     */\n    public void setStatementBuilderFactory(StatementBuilderFactory factory)\n    {\n        this.statementBuilderFactory = factory;\n    }\n\n    /**\n     * Specify the class used to log sql statements. Will be passed to all handles created from\n     * this instance\n     */\n    public void setSQLLog(SQLLog log)\n    {\n        this.log = log;\n    }\n}\n","lineNo":182}
{"Smelly Sample":"/*\n * Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents a group of non-prepared statements to be sent to the RDMBS in one \"request\"\n */\npublic class Batch\n{\n    private List<String> parts = new ArrayList<String>();\n    private final StatementRewriter rewriter;\n    private final Connection connection;\n    private final StatementContext context;\n\n    Batch(StatementRewriter rewriter, Connection connection, Map<String, Object> globalStatementAttributes)\n    {\n        this.rewriter = rewriter;\n        this.connection = connection;\n        this.context = new StatementContext(globalStatementAttributes);\n    }\n\n    /**\n     * Add a statement to the batch\n     *\n     * @param sql SQL to be added to the batch, possibly a named statement\n     * @return the same Batch statement\n     */\n    public Batch add(String sql)\n    {\n        parts.add(sql);\n        return this;\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    public Batch define(String key, Object value) {\n        this.context.setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Execute all the queued up statements\n     *\n     * @return an array of integers representing the return values from each statement's execution\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) return new int[] {};\n\n        Binding empty = new Binding();\n        Statement stmt = null;\n        try\n        {\n            try\n            {\n                stmt = connection.createStatement();\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToCreateStatementException(e);\n            }\n\n            try\n            {\n                for (String part : parts)\n                {\n                    stmt.addBatch( rewriter.rewrite(part, empty, context).getSql());\n                }\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(\"Unable to configure JDBC statement\", e);\n            }\n\n            try\n            {\n                return stmt.executeBatch();\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(e);\n            }\n        }\n        finally\n        {\n            QueryPostMungeCleanup.CLOSE_RESOURCES_QUIETLY.cleanup(null, stmt, null);\n        }\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCreateStatementException;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.SQLLog;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Represents a group of non-prepared statements to be sent to the RDMBS in one \"request\"\n */\npublic class Batch\n{\n    private List<String> parts = new ArrayList<String>();\n    private final StatementRewriter rewriter;\n    private final Connection connection;\n    private final SQLLog log;\n    private final StatementContext context;\n\n    Batch(StatementRewriter rewriter, Connection connection, Map<String, Object> globalStatementAttributes, SQLLog log)\n    {\n        this.rewriter = rewriter;\n        this.connection = connection;\n        this.log = log;\n        this.context = new StatementContext(globalStatementAttributes);\n    }\n\n    /**\n     * Add a statement to the batch\n     *\n     * @param sql SQL to be added to the batch, possibly a named statement\n     * @return the same Batch statement\n     */\n    public Batch add(String sql)\n    {\n        parts.add(sql);\n        return this;\n    }\n\n    /**\n     * Specify a value on the statement context for this batch\n     *\n     * @return self\n     */\n    public Batch define(String key, Object value) {\n        this.context.setAttribute(key, value);\n        return this;\n    }\n\n    /**\n     * Execute all the queued up statements\n     *\n     * @return an array of integers representing the return values from each statement's execution\n     */\n    public int[] execute()\n    {\n        // short circuit empty batch\n        if (parts.size() == 0) return new int[] {};\n\n        Binding empty = new Binding();\n        Statement stmt = null;\n        try\n        {\n            try\n            {\n                stmt = connection.createStatement();\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToCreateStatementException(e);\n            }\n\n            final SQLLog.BatchLogger logger = log.logBatch();\n            try\n            {\n                for (String part : parts)\n                {\n                    final String sql= rewriter.rewrite(part, empty, context).getSql();\n                    logger.add(sql);\n                    stmt.addBatch(sql);\n                }\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(\"Unable to configure JDBC statement\", e);\n            }\n\n            try\n            {\n                logger.log();\n                return stmt.executeBatch();\n            }\n            catch (SQLException e)\n            {\n                throw new UnableToExecuteStatementException(e);\n            }\n        }\n        finally\n        {\n            QueryPostMungeCleanup.CLOSE_RESOURCES_QUIETLY.cleanup(null, stmt, null);\n        }\n\n    }\n\n}\n","lineNo":100}
{"Smelly Sample":"/*\n * Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2.tweak.transactions;\n\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.exceptions.TransactionException;\nimport org.skife.jdbi.v2.tweak.TransactionHandler;\n\nimport java.sql.SQLException;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * This <code>TransactionHandler<\/code> uses local JDBC transactions\n * demarcated explicitely on the handle and passed through to be handled\n * directly on the JDBC Connection instance.\n */\npublic class LocalTransactionHandler implements TransactionHandler\n{\n    private ConcurrentHashMap<Handle, Boolean> initialAutoCommits = new ConcurrentHashMap<Handle, Boolean>();\n\n    /**\n     * Called when a transaction is started\n     */\n    public void begin(Handle handle)\n    {\n        try\n        {\n            boolean initial = handle.getConnection().getAutoCommit();\n            initialAutoCommits.put(handle, initial);\n            handle.getConnection().setAutoCommit(false);\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to start transaction\", e);\n        }\n    }\n\n    /**\n     * Called when a transaction is committed\n     */\n    public void commit(Handle handle)\n    {\n        try\n        {\n            handle.getConnection().commit();\n            handle.getConnection().setAutoCommit(initialAutoCommits.remove(handle));\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to commit transaction\", e);\n        }\n        finally\n        {\n            // prevent memory leak if commit throws an exception\n            if (initialAutoCommits.containsKey(handle)) {\n                initialAutoCommits.remove(handle);\n            }\n        }\n    }\n\n    /**\n     * Called when a transaction is rolled back\n     */\n    public void rollback(Handle handle)\n    {\n        try\n        {\n            handle.getConnection().rollback();\n            handle.getConnection().setAutoCommit(initialAutoCommits.remove(handle));\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to rollback transaction\", e);\n        }\n        finally\n        {\n            // prevent memory leak if rollback throws an exception\n            if (initialAutoCommits.containsKey(handle)) {\n                initialAutoCommits.remove(handle);\n            }\n        }\n    }\n\n    /**\n     * Called to test if a handle is in a transaction\n     */\n    public boolean isInTransaction(Handle handle)\n    {\n        try\n        {\n            return !handle.getConnection().getAutoCommit();\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to test for transaction status\", e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2.tweak.transactions;\n\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.exceptions.TransactionException;\nimport org.skife.jdbi.v2.tweak.TransactionHandler;\n\nimport java.sql.SQLException;\nimport java.sql.Connection;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * This <code>TransactionHandler<\/code> uses local JDBC transactions\n * demarcated explicitely on the handle and passed through to be handled\n * directly on the JDBC Connection instance.\n */\npublic class LocalTransactionHandler implements TransactionHandler\n{\n    private ConcurrentHashMap<Handle, Boolean> initialAutoCommits = new ConcurrentHashMap<Handle, Boolean>();\n\n    /**\n     * Called when a transaction is started\n     */\n    public void begin(Handle handle)\n    {\n        try\n        {\n            boolean initial = handle.getConnection().getAutoCommit();\n            initialAutoCommits.put(handle, initial);\n            handle.getConnection().setAutoCommit(false);\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to start transaction\", e);\n        }\n    }\n\n    /**\n     * Called when a transaction is committed\n     */\n    public void commit(Handle handle)\n    {\n        try\n        {\n            handle.getConnection().commit();\n            final Boolean auto = initialAutoCommits.remove(handle);\n            if (auto != null) {\n                handle.getConnection().setAutoCommit(auto);\n            }\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to commit transaction\", e);\n        }\n        finally\n        {\n            // prevent memory leak if commit throws an exception\n            if (initialAutoCommits.containsKey(handle)) {\n                initialAutoCommits.remove(handle);\n            }\n        }\n    }\n\n    /**\n     * Called when a transaction is rolled back\n     */\n    public void rollback(Handle handle)\n    {\n        try\n        {\n            handle.getConnection().rollback();\n            final Boolean auto = initialAutoCommits.remove(handle);\n            if (auto != null) {\n                handle.getConnection().setAutoCommit(auto);\n            }\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to rollback transaction\", e);\n        }\n        finally\n        {\n            // prevent memory leak if rollback throws an exception\n            if (initialAutoCommits.containsKey(handle)) {\n                initialAutoCommits.remove(handle);\n            }\n        }\n    }\n\n    /**\n     * Called to test if a handle is in a transaction\n     */\n    public boolean isInTransaction(Handle handle)\n    {\n        try\n        {\n            return !handle.getConnection().getAutoCommit();\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to test for transaction status\", e);\n        }\n    }\n}\n","lineNo":61}
{"Smelly Sample":"/*\n * Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2.tweak.transactions;\n\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.exceptions.TransactionException;\nimport org.skife.jdbi.v2.tweak.TransactionHandler;\n\nimport java.sql.SQLException;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * This <code>TransactionHandler<\/code> uses local JDBC transactions\n * demarcated explicitely on the handle and passed through to be handled\n * directly on the JDBC Connection instance.\n */\npublic class LocalTransactionHandler implements TransactionHandler\n{\n    private ConcurrentHashMap<Handle, Boolean> initialAutoCommits = new ConcurrentHashMap<Handle, Boolean>();\n\n    /**\n     * Called when a transaction is started\n     */\n    public void begin(Handle handle)\n    {\n        try\n        {\n            boolean initial = handle.getConnection().getAutoCommit();\n            initialAutoCommits.put(handle, initial);\n            handle.getConnection().setAutoCommit(false);\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to start transaction\", e);\n        }\n    }\n\n    /**\n     * Called when a transaction is committed\n     */\n    public void commit(Handle handle)\n    {\n        try\n        {\n            handle.getConnection().commit();\n            handle.getConnection().setAutoCommit(initialAutoCommits.remove(handle));\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to commit transaction\", e);\n        }\n        finally\n        {\n            // prevent memory leak if commit throws an exception\n            if (initialAutoCommits.containsKey(handle)) {\n                initialAutoCommits.remove(handle);\n            }\n        }\n    }\n\n    /**\n     * Called when a transaction is rolled back\n     */\n    public void rollback(Handle handle)\n    {\n        try\n        {\n            handle.getConnection().rollback();\n            handle.getConnection().setAutoCommit(initialAutoCommits.remove(handle));\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to rollback transaction\", e);\n        }\n        finally\n        {\n            // prevent memory leak if rollback throws an exception\n            if (initialAutoCommits.containsKey(handle)) {\n                initialAutoCommits.remove(handle);\n            }\n        }\n    }\n\n    /**\n     * Called to test if a handle is in a transaction\n     */\n    public boolean isInTransaction(Handle handle)\n    {\n        try\n        {\n            return !handle.getConnection().getAutoCommit();\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to test for transaction status\", e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.skife.jdbi.v2.tweak.transactions;\n\nimport org.skife.jdbi.v2.Handle;\nimport org.skife.jdbi.v2.exceptions.TransactionException;\nimport org.skife.jdbi.v2.tweak.TransactionHandler;\n\nimport java.sql.SQLException;\nimport java.sql.Connection;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * This <code>TransactionHandler<\/code> uses local JDBC transactions\n * demarcated explicitely on the handle and passed through to be handled\n * directly on the JDBC Connection instance.\n */\npublic class LocalTransactionHandler implements TransactionHandler\n{\n    private ConcurrentHashMap<Handle, Boolean> initialAutoCommits = new ConcurrentHashMap<Handle, Boolean>();\n\n    /**\n     * Called when a transaction is started\n     */\n    public void begin(Handle handle)\n    {\n        try\n        {\n            boolean initial = handle.getConnection().getAutoCommit();\n            initialAutoCommits.put(handle, initial);\n            handle.getConnection().setAutoCommit(false);\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to start transaction\", e);\n        }\n    }\n\n    /**\n     * Called when a transaction is committed\n     */\n    public void commit(Handle handle)\n    {\n        try\n        {\n            handle.getConnection().commit();\n            final Boolean auto = initialAutoCommits.remove(handle);\n            if (auto != null) {\n                handle.getConnection().setAutoCommit(auto);\n            }\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to commit transaction\", e);\n        }\n        finally\n        {\n            // prevent memory leak if commit throws an exception\n            if (initialAutoCommits.containsKey(handle)) {\n                initialAutoCommits.remove(handle);\n            }\n        }\n    }\n\n    /**\n     * Called when a transaction is rolled back\n     */\n    public void rollback(Handle handle)\n    {\n        try\n        {\n            handle.getConnection().rollback();\n            final Boolean auto = initialAutoCommits.remove(handle);\n            if (auto != null) {\n                handle.getConnection().setAutoCommit(auto);\n            }\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to rollback transaction\", e);\n        }\n        finally\n        {\n            // prevent memory leak if rollback throws an exception\n            if (initialAutoCommits.containsKey(handle)) {\n                initialAutoCommits.remove(handle);\n            }\n        }\n    }\n\n    /**\n     * Called to test if a handle is in a transaction\n     */\n    public boolean isInTransaction(Handle handle)\n    {\n        try\n        {\n            return !handle.getConnection().getAutoCommit();\n        }\n        catch (SQLException e)\n        {\n            throw new TransactionException(\"Failed to test for transaction status\", e);\n        }\n    }\n}\n","lineNo":87}
{"Smelly Sample":"/* Copyright 2004-2005 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToObtainConnectionException;\nimport org.skife.jdbi.v2.tweak.ConnectionFactory;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\n\npublic class DBI\n{\n    private final ConnectionFactory connectionFactory;\n    private StatementRewriter statementRewriter = new NamedParameterStatementRewriter();\n\n    public DBI(DataSource dataSource)\n    {\n        this(new DataSourceConnectionFactory(dataSource));\n        assert(dataSource != null);\n    }\n\n    public DBI(ConnectionFactory connectionFactory)\n    {\n        assert(connectionFactory != null);\n        this.connectionFactory = connectionFactory;\n    }\n\n    public Handle open()\n    {\n        try\n        {\n            return new BasicHandle(new LocalTransactionHandler(),\n                                   statementRewriter,\n                                   connectionFactory.openConnection());\n        }\n        catch (SQLException e)\n        {\n            throw new UnableToObtainConnectionException(e);\n        }\n    }\n\n    public static Handle open(DataSource dataSource)\n    {\n        return new DBI(dataSource).open();\n    }\n}\n","Method after Refactoring":"/* Copyright 2004-2005 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToObtainConnectionException;\nimport org.skife.jdbi.v2.tweak.ConnectionFactory;\nimport org.skife.jdbi.v2.tweak.StatementRewriter;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.sql.Connection;\n\npublic class DBI\n{\n    private final ConnectionFactory connectionFactory;\n    private StatementRewriter statementRewriter = new NamedParameterStatementRewriter();\n\n    public DBI(DataSource dataSource)\n    {\n        this(new DataSourceConnectionFactory(dataSource));\n        assert(dataSource != null);\n    }\n\n    public DBI(ConnectionFactory connectionFactory)\n    {\n        assert(connectionFactory != null);\n        this.connectionFactory = connectionFactory;\n    }\n\n    public Handle open()\n    {\n        try\n        {\n            Connection conn = connectionFactory.openConnection();\n            PreparedStatementCache cache = new PreparedStatementCache(conn);\n            return new BasicHandle(new LocalTransactionHandler(),\n                                   cache,\n                                   statementRewriter,\n                                   conn);\n        }\n        catch (SQLException e)\n        {\n            throw new UnableToObtainConnectionException(e);\n        }\n    }\n\n    public static Handle open(DataSource dataSource)\n    {\n        return new DBI(dataSource).open();\n    }\n}\n","lineNo":47}
{"Smelly Sample":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport junit.framework.TestCase;\nimport org.skife.jdbi.derby.Tools;\nimport org.skife.jdbi.v2.tweak.TransactionHandler;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.ExecutorService;\nimport java.sql.SQLException;\n\n/**\n * \n */\npublic abstract class DBITestCase extends TestCase\n{\n    private final List<BasicHandle> handles = new ArrayList<BasicHandle>();\n    private ExecutorService executor;\n\n    public void setUp() throws Exception\n    {\n        Tools.start();\n        Tools.dropAndCreateSomething();\n    }\n\n    public void tearDown() throws Exception\n    {\n        for (BasicHandle handle : handles)\n        {\n            handle.close();\n        }\n        Tools.stop();\n    }\n\n    protected BasicHandle openHandle() throws SQLException\n    {\n        BasicHandle h = new BasicHandle(getTransactionHandler(),\n                                        new NamedParameterStatementRewriter(),\n                                        Tools.getConnection());\n        handles.add(h);\n        return h;\n    }\n\n    protected TransactionHandler getTransactionHandler()\n    {\n        return new LocalTransactionHandler();\n    }\n\n    protected <T> Future<T> run(Callable<T> it)\n    {\n        if (this.executor == null) {\n            this.executor = Executors.newCachedThreadPool();\n        }\n        return executor.submit(it);    \n    }\n\n}\n","Method after Refactoring":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport junit.framework.TestCase;\nimport org.skife.jdbi.derby.Tools;\nimport org.skife.jdbi.v2.tweak.TransactionHandler;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.ExecutorService;\nimport java.sql.SQLException;\nimport java.sql.Connection;\n\n/**\n * \n */\npublic abstract class DBITestCase extends TestCase\n{\n    private final List<BasicHandle> handles = new ArrayList<BasicHandle>();\n    private ExecutorService executor;\n\n    public void setUp() throws Exception\n    {\n        Tools.start();\n        Tools.dropAndCreateSomething();\n    }\n\n    public void tearDown() throws Exception\n    {\n        for (BasicHandle handle : handles)\n        {\n            handle.close();\n        }\n        Tools.stop();\n    }\n\n    protected BasicHandle openHandle() throws SQLException\n    {\n        Connection conn = Tools.getConnection();\n        BasicHandle h = new BasicHandle(getTransactionHandler(),\n                                        new PreparedStatementCache(conn),\n                                        new NamedParameterStatementRewriter(),\n                                        conn);\n        handles.add(h);\n        return h;\n    }\n\n    protected TransactionHandler getTransactionHandler()\n    {\n        return new LocalTransactionHandler();\n    }\n\n    protected <T> Future<T> run(Callable<T> it)\n    {\n        if (this.executor == null) {\n            this.executor = Executors.newCachedThreadPool();\n        }\n        return executor.submit(it);\n    }\n\n}\n","lineNo":56}
{"Smelly Sample":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport junit.framework.TestCase;\nimport org.skife.jdbi.derby.Tools;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\n\n/**\n * \n */\npublic class TestPositionalParameterBinding extends TestCase\n{\n    private BasicHandle h;\n\n    public void setUp() throws Exception\n    {\n        Tools.start();\n        Tools.dropAndCreateSomething();\n        h = new BasicHandle(new LocalTransactionHandler(),\n                            new NamedParameterStatementRewriter(),\n                            Tools.getConnection());\n    }\n\n    public void tearDown() throws Exception\n    {\n        if (h != null) h.close();\n        Tools.stop();\n    }\n\n    public void testSetPositionalString() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        Something eric = h.createQuery(\"select * from something where name = ?\")\n                .bind(0, \"eric\")\n                .map(Something.class)\n                .list()\n                .get(0);\n        assertEquals(1, eric.getId());\n    }\n\n    public void testSetPositionalInteger() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        Something eric = h.createQuery(\"select * from something where id = ?\")\n                .bind(0, 1)\n                .map(Something.class)\n                .list().get(0);\n        assertEquals(1, eric.getId());\n    }\n\n    public void testBehaviorOnBadBinding1() throws Exception\n    {\n        Query<Something> q = h.createQuery(\"select * from something where id = ? and name = ?\")\n                .bind(0, 1)\n                .map(Something.class);\n\n        try\n        {\n            q.list();\n            fail(\"should have thrown exception\");\n        }\n        catch (UnableToExecuteStatementException e)\n        {\n            assertTrue(\"Execution goes through here\", true);\n        }\n        catch (Exception e)\n        {\n            fail(\"Threw an incorrect exception type\");\n        }\n    }\n\n     public void testBehaviorOnBadBinding2() throws Exception\n    {\n        Query<Something> q = h.createQuery(\"select * from something where id = ?\")\n                .bind(1, 1)\n                .bind(2, \"Hi\")\n                .map(Something.class);\n\n        try\n        {\n            q.list();\n            fail(\"should have thrown exception\");\n        }\n        catch (UnableToExecuteStatementException e)\n        {\n            assertTrue(\"Execution goes through here\", true);\n        }\n        catch (Exception e)\n        {\n            fail(\"Threw an incorrect exception type\");\n        }\n    }\n\n    public void testInsertParamBinding() throws Exception\n    {\n        int count = h.createStatement(\"insert into something (id, name) values (?, 'eric')\")\n                .bind(0, 1)\n                .execute();\n\n        assertEquals(1, count);\n    }\n\n    public void testPositionalConvenienceInsert() throws Exception\n    {\n        int count = h.insert(\"insert into something (id, name) values (?, ?)\", 1, \"eric\");\n\n        assertEquals(1, count);\n    }\n}\n","Method after Refactoring":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport junit.framework.TestCase;\nimport org.skife.jdbi.derby.Tools;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\n\nimport java.sql.Connection;\n\n/**\n * \n */\npublic class TestPositionalParameterBinding extends TestCase\n{\n    private BasicHandle h;\n\n    public void setUp() throws Exception\n    {\n        Tools.start();\n        Tools.dropAndCreateSomething();\n        Connection conn = Tools.getConnection();\n        h = new BasicHandle(new LocalTransactionHandler(),\n                            new PreparedStatementCache(conn),\n                            new NamedParameterStatementRewriter(),\n                            conn);\n    }\n\n    public void tearDown() throws Exception\n    {\n        if (h != null) h.close();\n        Tools.stop();\n    }\n\n    public void testSetPositionalString() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        Something eric = h.createQuery(\"select * from something where name = ?\")\n                .bind(0, \"eric\")\n                .map(Something.class)\n                .list()\n                .get(0);\n        assertEquals(1, eric.getId());\n    }\n\n    public void testSetPositionalInteger() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        Something eric = h.createQuery(\"select * from something where id = ?\")\n                .bind(0, 1)\n                .map(Something.class)\n                .list().get(0);\n        assertEquals(1, eric.getId());\n    }\n\n    public void testBehaviorOnBadBinding1() throws Exception\n    {\n        Query<Something> q = h.createQuery(\"select * from something where id = ? and name = ?\")\n                .bind(0, 1)\n                .map(Something.class);\n\n        try\n        {\n            q.list();\n            fail(\"should have thrown exception\");\n        }\n        catch (UnableToExecuteStatementException e)\n        {\n            assertTrue(\"Execution goes through here\", true);\n        }\n        catch (Exception e)\n        {\n            fail(\"Threw an incorrect exception type\");\n        }\n    }\n\n     public void testBehaviorOnBadBinding2() throws Exception\n    {\n        Query<Something> q = h.createQuery(\"select * from something where id = ?\")\n                .bind(1, 1)\n                .bind(2, \"Hi\")\n                .map(Something.class);\n\n        try\n        {\n            q.list();\n            fail(\"should have thrown exception\");\n        }\n        catch (UnableToExecuteStatementException e)\n        {\n            assertTrue(\"Execution goes through here\", true);\n        }\n        catch (Exception e)\n        {\n            fail(\"Threw an incorrect exception type\");\n        }\n    }\n\n    public void testInsertParamBinding() throws Exception\n    {\n        int count = h.createStatement(\"insert into something (id, name) values (?, 'eric')\")\n                .bind(0, 1)\n                .execute();\n\n        assertEquals(1, count);\n    }\n\n    public void testPositionalConvenienceInsert() throws Exception\n    {\n        int count = h.insert(\"insert into something (id, name) values (?, ?)\", 1, \"eric\");\n\n        assertEquals(1, count);\n    }\n}\n","lineNo":35}
{"Smelly Sample":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport junit.framework.TestCase;\nimport org.skife.jdbi.derby.Tools;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.Map;\n\npublic class TestQueries extends TestCase\n{\n    private BasicHandle h;\n\n    public void setUp() throws Exception\n    {\n        Tools.start();\n        Tools.dropAndCreateSomething();\n        h = new BasicHandle(new LocalTransactionHandler(),\n                            new NamedParameterStatementRewriter(),\n                            Tools.getConnection());\n    }\n\n    public void tearDown() throws Exception\n    {\n        if (h != null) h.close();\n        Tools.stop();\n    }\n\n    public void testCreateQueryObject() throws Exception\n    {\n        h.createStatement(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createStatement(\"insert into something (id, name) values (2, 'brian')\").execute();\n\n        List<Map<String, Object>> results = h.createQuery(\"select * from something order by id\").list();\n        assertEquals(2, results.size());\n        Map<String, Object> first_row = results.get(0);\n        assertEquals(\"eric\", first_row.get(\"name\"));\n    }\n\n    public void testMappedQueryObject() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        Query<Something> query = h.createQuery(\"select * from something order by id\").map(Something.class);\n\n        List<Something> r = query.list();\n        Something eric = r.get(0);\n        assertEquals(\"eric\", eric.getName());\n        assertEquals(1, eric.getId());\n    }\n\n    public void testMapper() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        Query<String> query = h.createQuery(\"select name from something order by id\").map(new ResultSetMapper<String>()\n        {\n            public String map(int index, ResultSet r) throws SQLException\n            {\n                return r.getString(1);\n            }\n        });\n\n        String name = query.list().get(0);\n        assertEquals(\"eric\", name);\n    }\n\n    public void testConvenienceMethod() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        List<Map<String, Object>> r = h.query(\"select * from something order by id\");\n        assertEquals(2, r.size());\n        assertEquals(\"eric\", r.get(0).get(\"name\"));\n    }\n\n    public void testConvenienceMethodWithParam() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        List<Map<String, Object>> r = h.query(\"select * from something where id = ?\", 1);\n        assertEquals(1, r.size());\n        assertEquals(\"eric\", r.get(0).get(\"name\"));\n    }\n\n    public void testPositionalArgWithNamedParam() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        List<Something> r = h.createQuery(\"select * from something where name = :name\")\n                .bind(0, \"eric\")\n                .map(Something.class)\n                .list();\n\n        assertEquals(1, r.size());\n        assertEquals(\"eric\", r.get(0).getName());\n    }\n\n    public void testMixedSetting() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        List<Something> r = h.createQuery(\"select * from something where name = :name and id = :id\")\n                .bind(0, \"eric\")\n                .bind(\"id\", 1)\n                .map(Something.class)\n                .list();\n\n        assertEquals(1, r.size());\n        assertEquals(\"eric\", r.get(0).getName());\n    }\n\n    public void testHelpfulErrorOnNothingSet() throws Exception\n    {\n        try\n        {\n            h.createQuery(\"select * from something where name = :name\").list();\n            fail(\"should have raised exception\");\n        }\n        catch (UnableToExecuteStatementException e)\n        {\n            assertTrue(\"execution goes through here\", true);\n        }\n        catch (Exception e)\n        {\n            fail(\"Raised incorrect exception\");\n        }\n    }\n\n    public void testFirstResult() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        Something r = h.createQuery(\"select * from something order by id\")\n                .map(Something.class)\n                .first();\n\n        assertNotNull(r);\n        assertEquals(\"eric\", r.getName());\n    }\n\n//    public void testIteratedResult() throws Exception\n//    {\n//        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n//        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n//\n//        Iterator<Something> i = h.createQuery(\"select * from something order by id\")\n//                .map(Something.class)\n//                .iterate();\n//\n//    }\n}\n","Method after Refactoring":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport junit.framework.TestCase;\nimport org.skife.jdbi.derby.Tools;\nimport org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException;\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Connection;\nimport java.util.List;\nimport java.util.Map;\n\npublic class TestQueries extends TestCase\n{\n    private BasicHandle h;\n\n    public void setUp() throws Exception\n    {\n        Tools.start();\n        Tools.dropAndCreateSomething();\n        Connection conn = Tools.getConnection();\n        h = new BasicHandle(new LocalTransactionHandler(),\n                            new PreparedStatementCache(conn),\n                            new NamedParameterStatementRewriter(),\n                            conn);\n    }\n\n    public void tearDown() throws Exception\n    {\n        if (h != null) h.close();\n        Tools.stop();\n    }\n\n    public void testCreateQueryObject() throws Exception\n    {\n        h.createStatement(\"insert into something (id, name) values (1, 'eric')\").execute();\n        h.createStatement(\"insert into something (id, name) values (2, 'brian')\").execute();\n\n        List<Map<String, Object>> results = h.createQuery(\"select * from something order by id\").list();\n        assertEquals(2, results.size());\n        Map<String, Object> first_row = results.get(0);\n        assertEquals(\"eric\", first_row.get(\"name\"));\n    }\n\n    public void testMappedQueryObject() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        Query<Something> query = h.createQuery(\"select * from something order by id\").map(Something.class);\n\n        List<Something> r = query.list();\n        Something eric = r.get(0);\n        assertEquals(\"eric\", eric.getName());\n        assertEquals(1, eric.getId());\n    }\n\n    public void testMapper() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        Query<String> query = h.createQuery(\"select name from something order by id\").map(new ResultSetMapper<String>()\n        {\n            public String map(int index, ResultSet r) throws SQLException\n            {\n                return r.getString(1);\n            }\n        });\n\n        String name = query.list().get(0);\n        assertEquals(\"eric\", name);\n    }\n\n    public void testConvenienceMethod() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        List<Map<String, Object>> r = h.query(\"select * from something order by id\");\n        assertEquals(2, r.size());\n        assertEquals(\"eric\", r.get(0).get(\"name\"));\n    }\n\n    public void testConvenienceMethodWithParam() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        List<Map<String, Object>> r = h.query(\"select * from something where id = ?\", 1);\n        assertEquals(1, r.size());\n        assertEquals(\"eric\", r.get(0).get(\"name\"));\n    }\n\n    public void testPositionalArgWithNamedParam() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        List<Something> r = h.createQuery(\"select * from something where name = :name\")\n                .bind(0, \"eric\")\n                .map(Something.class)\n                .list();\n\n        assertEquals(1, r.size());\n        assertEquals(\"eric\", r.get(0).getName());\n    }\n\n    public void testMixedSetting() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        List<Something> r = h.createQuery(\"select * from something where name = :name and id = :id\")\n                .bind(0, \"eric\")\n                .bind(\"id\", 1)\n                .map(Something.class)\n                .list();\n\n        assertEquals(1, r.size());\n        assertEquals(\"eric\", r.get(0).getName());\n    }\n\n    public void testHelpfulErrorOnNothingSet() throws Exception\n    {\n        try\n        {\n            h.createQuery(\"select * from something where name = :name\").list();\n            fail(\"should have raised exception\");\n        }\n        catch (UnableToExecuteStatementException e)\n        {\n            assertTrue(\"execution goes through here\", true);\n        }\n        catch (Exception e)\n        {\n            fail(\"Raised incorrect exception\");\n        }\n    }\n\n    public void testFirstResult() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n\n        Something r = h.createQuery(\"select * from something order by id\")\n                .map(Something.class)\n                .first();\n\n        assertNotNull(r);\n        assertEquals(\"eric\", r.getName());\n    }\n\n//    public void testIteratedResult() throws Exception\n//    {\n//        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n//        h.insert(\"insert into something (id, name) values (2, 'brian')\");\n//\n//        Iterator<Something> i = h.createQuery(\"select * from something order by id\")\n//                .map(Something.class)\n//                .iterate();\n//\n//    }\n}\n","lineNo":37}
{"Smelly Sample":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport junit.framework.TestCase;\nimport org.skife.jdbi.derby.Tools;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\n\n/**\n * \n */\npublic class TestStatements extends TestCase\n{\n    private BasicHandle h;\n\n    public void setUp() throws Exception\n    {\n        Tools.start();\n        Tools.dropAndCreateSomething();\n        h = new BasicHandle(new LocalTransactionHandler(),\n                            new NamedParameterStatementRewriter(),\n                            Tools.getConnection());\n    }\n\n    public void tearDown() throws Exception\n    {\n        if (h != null) h.close();\n        Tools.stop();\n    }\n\n    public void testStatement() throws Exception\n    {\n        int rows = h.createStatement(\"insert into something (id, name) values (1, 'eric')\").execute();\n        assertEquals(1, rows);\n    }\n\n    public void testSimpleInsert() throws Exception\n    {\n        int c = h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        assertEquals(1, c);\n    }\n\n    public void testUpdate() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.createStatement(\"update something set name = 'ERIC' where id = 1\").execute();\n        Something eric = h.createQuery(\"select * from something where id = 1\").map(Something.class).list().get(0);\n        assertEquals(\"ERIC\", eric.getName());\n    }\n\n    public void testSimpleUpdate() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.update(\"update something set name = 'cire' where id = 1\");\n        Something eric = h.createQuery(\"select * from something where id = 1\").map(Something.class).list().get(0);\n        assertEquals(\"cire\", eric.getName());\n    }\n\n}\n","Method after Refactoring":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport junit.framework.TestCase;\nimport org.skife.jdbi.derby.Tools;\nimport org.skife.jdbi.v2.tweak.transactions.LocalTransactionHandler;\n\nimport java.sql.Connection;\n\n/**\n * \n */\npublic class TestStatements extends TestCase\n{\n    private BasicHandle h;\n\n    public void setUp() throws Exception\n    {\n        Tools.start();\n        Tools.dropAndCreateSomething();\n        Connection conn = Tools.getConnection();\n        h = new BasicHandle(new LocalTransactionHandler(),\n                            new PreparedStatementCache(conn),\n                            new NamedParameterStatementRewriter(),\n                            conn);\n    }\n\n    public void tearDown() throws Exception\n    {\n        if (h != null) h.close();\n        Tools.stop();\n    }\n\n    public void testStatement() throws Exception\n    {\n        int rows = h.createStatement(\"insert into something (id, name) values (1, 'eric')\").execute();\n        assertEquals(1, rows);\n    }\n\n    public void testSimpleInsert() throws Exception\n    {\n        int c = h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        assertEquals(1, c);\n    }\n\n    public void testUpdate() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.createStatement(\"update something set name = 'ERIC' where id = 1\").execute();\n        Something eric = h.createQuery(\"select * from something where id = 1\").map(Something.class).list().get(0);\n        assertEquals(\"ERIC\", eric.getName());\n    }\n\n    public void testSimpleUpdate() throws Exception\n    {\n        h.insert(\"insert into something (id, name) values (1, 'eric')\");\n        h.update(\"update something set name = 'cire' where id = 1\");\n        Something eric = h.createQuery(\"select * from something where id = 1\").map(Something.class).list().get(0);\n        assertEquals(\"cire\", eric.getName());\n    }\n\n}\n","lineNo":34}
{"Smelly Sample":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.tweak.*;\n\nimport java.util.List;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class TestPreparedBatch extends DBITestCase\n{\n    public void testDesignApi() throws Exception\n    {\n        Handle h = openHandle();\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        b = b.setInteger(\"id\", 1).setString(\"name\", \"Eric\").add();\n        b.setInteger(\"id\", 2).setString(\"name\", \"Brian\").add()\n                .setInteger(\"id\", 3).setString(\"name\", \"Keith\");\n\n        b.execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").map(Something.class).list();\n        assertEquals(3, r.size());\n        assertEquals(\"Keith\", r.get(2).getName());\n    }\n\n    public void testBigBatch() throws Exception\n    {\n        Handle h = openHandle();\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        int count = 1000;\n        for (int i = 0; i < count; ++i)\n        {\n            b.add();\n            b.setInteger(\"id\", i);\n            b.setString(\"name\", \"A Name\");\n        }\n        b.execute();\n\n        int row_count = h.createQuery(\"select count(id) from something\").map(new ResultSetMapper<Integer>()\n        {\n            public Integer map(int index, ResultSet r) throws SQLException\n            {\n                return r.getInt(1);\n            }\n        }).first();\n\n        assertEquals(count, row_count);\n    }\n}\n","Method after Refactoring":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.tweak.ResultSetMapper;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\n\npublic class TestPreparedBatch extends DBITestCase\n{\n    public void testDesignApi() throws Exception\n    {\n        Handle h = openHandle();\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        PreparedBatchPart p = b.add();\n        p = p.setInteger(\"id\", 1).setString(\"name\", \"Eric\").another();\n        p.setInteger(\"id\", 2).setString(\"name\", \"Brian\").another()\n                .setInteger(\"id\", 3).setString(\"name\", \"Keith\");\n        b.execute();\n\n        List<Something> r = h.createQuery(\"select * from something order by id\").map(Something.class).list();\n        assertEquals(3, r.size());\n        assertEquals(\"Keith\", r.get(2).getName());\n    }\n\n    public void testBigBatch() throws Exception\n    {\n        Handle h = openHandle();\n        PreparedBatch b = h.prepareBatch(\"insert into something (id, name) values (:id, :name)\");\n\n        int count = 1000;\n        for (int i = 0; i < count; ++i)\n        {\n            b.add().setInteger(\"id\", i).setString(\"name\", \"A Name\");\n\n        }\n        b.execute();\n\n        int row_count = h.createQuery(\"select count(id) from something\").map(new ResultSetMapper<Integer>()\n        {\n            public Integer map(int index, ResultSet r) throws SQLException\n            {\n                return r.getInt(1);\n            }\n        }).first();\n\n        assertEquals(count, row_count);\n    }\n}\n","lineNo":30}
{"Smelly Sample":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCloseResourceException;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Map;\n\npublic class BasicHandle implements Handle\n{\n    private final Connection connection;\n\n    public BasicHandle(Connection connection)\n    {\n        this.connection = connection;\n    }\n\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        return new Query<Map<String, Object>>(new DefaultMapper(),\n                                              connection,\n                                              sql);\n    }\n\n\n\n    public void close()\n    {\n        try\n        {\n            connection.close();\n        }\n        catch (SQLException e)\n        {\n            throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n        }\n    }\n\n    public SQLStatement createStatement(String sql)\n    {\n        return new SQLStatement(connection, sql);\n    }\n\n    public int insert(String sql)\n    {\n        return update(sql);\n    }\n\n    public int update(String sql)\n    {\n        return createStatement(sql).execute();\n    }\n}\n","Method after Refactoring":"/* Copyright 2004-2006 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi.v2;\n\nimport org.skife.jdbi.v2.exceptions.UnableToCloseResourceException;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Map;\n\npublic class BasicHandle implements Handle\n{\n    private final Connection connection;\n\n    public BasicHandle(Connection connection)\n    {\n        this.connection = connection;\n    }\n\n    public Query<Map<String, Object>> createQuery(String sql)\n    {\n        return new Query<Map<String, Object>>(new DefaultMapper(),\n                                              connection,\n                                              sql);\n    }\n\n\n\n    public void close()\n    {\n        try\n        {\n            connection.close();\n        }\n        catch (SQLException e)\n        {\n            throw new UnableToCloseResourceException(\"Unable to close Connection\", e);\n        }\n    }\n\n    public SQLStatement createStatement(String sql)\n    {\n        return new SQLStatement(connection, sql);\n    }\n\n    public int insert(String sql, Object... args)\n    {\n        return update(sql, args);\n    }\n\n    public int update(String sql, Object... args)\n    {\n        SQLStatement stmt = createStatement(sql);\n        int position = 0;\n        for (Object arg : args)\n        {\n            stmt.setObject(position++, arg);\n        }\n        return stmt.execute();\n    }\n}\n","lineNo":65}
{"Smelly Sample":"/* Copyright 2004-2005 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi;\n\nimport org.skife.jdbi.tweak.ConnectionTransactionHandler;\nimport org.skife.jdbi.tweak.TransactionHandler;\nimport org.skife.jdbi.unstable.decorator.HandleDecorator;\n\nimport javax.naming.InitialContext;\nimport javax.sql.DataSource;\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Entry point for operations. May act as a configured bean, or provide handles\n * via static functions.\n */\npublic class DBI implements IDBI\n{\n    private final NamedStatementRepository repository;\n    private final ConnectionFactory factory;\n    private HandleDecorator handleDecorator = new NullHandleDecorator();\n    private TransactionHandler transactionHandler = new ConnectionTransactionHandler();\n\n    /**\n     * Attempt to auto-configure a DBi instance\n     * <p/>\n     * It first looks for an <code>org.skife.jdbi.properties-file<\/code> system property which\n     * represents a properties file to be loaded via the classpath. If that is not found, it looks\n     * for <code>jdbi.properties<\/code>, then <code>jdbc.properties<\/code>, then\n     * <code>dbi.properties<\/code>, then finally <code>database.properties<\/code> on the classpath.\n     * It will use the first it finds and stop looking for others once it finds one.\n     * <p/>\n     * Once a suitable configuration properties file has been loaded, jDBI will look for various\n     * properties used to configure it. There are multiple possible values for each logical\n     * property, and the order of preference if it should find multiple is the order listed here:\n     * <\/p>\n     * <table>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.url<\/li>\n     * <li>jdbc.url<\/li>\n     * <li>connection.string<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * JDBC Connection URL, ie <code>jdbc:derby:my_database<\/code>,\n     * required\n     * <\/td>\n     * <\/tr>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.driver<\/li>\n     * <li>jdbc.driver<\/li>\n     * <li>driver<\/li>\n     * <li>drive<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * JDBC Driver class name, ie <code>org.apache.derby.jdbc.EmbeddedDriver<\/code>,\n     * required\n     * <\/td>\n     * <\/tr>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.username<\/li>\n     * <li>jdbi.user<\/li>\n     * <li>jdbc.username<\/li>\n     * <li>jdbc.user<\/li>\n     * <li>username<\/li>\n     * <li>user<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * Username to be used when obtaining connections from the database, optional\n     * <\/td>\n     * <\/tr>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.password<\/li>\n     * <li>jdbi.pass<\/li>\n     * <li>jdbc.password<\/li>\n     * <li>jdbc.pass<\/li>\n     * <li>password<\/li>\n     * <li>pass<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * Password to be used when obtaining connections from the database, optional\n     * <\/td>\n     * <\/tr>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.handle-decorator-builder<\/li>\n     * <li>jdbi.handle-decorator-builder<\/li>\n     * <li>handle-decorator-builder<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * <b>Unstable Feature<\/b> class name of a <code>HandleDecorator<\/code>\n     * to be used to decorate <code>Handle<\/code> instances obtained from the\n     * <code>DBI<\/code> instance instantiated. This feature is functionally stable,\n     * but the specific api may change somewhat while it remains offically unstable.\n     * Please read the notes regarding the <code>org.skife.jdbi.unstable<\/code> package\n     * before using this. Optional.\n     * <\/td>\n     * <\/tr>\n     * <\/table>\n     *\n     * @throws IOException on error loading jdbi.properties\n     * @throws DBIError    if the properties file exists but is invalid\n     */\n    public DBI() throws IOException\n    {\n        repository = new NamedStatementRepository();\n        final AutoConfigurator auto = new AutoConfigurator();\n        factory = auto.getConnectionFactory();\n        try\n        {\n            handleDecorator = auto.getHandleDecoratorBuilder();\n        }\n        catch (Exception e)\n        {\n            throw new DBIError(\"Unable to instantiate handle decorator builder :\" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * If <code>wombat<\/code> begins \"jdbc:\" the string will be treated as a jdbc driver\n     * otherwise it will be used as the key for a jndi lookup to findInternal a <code>DataSrouce<\/code>.\n     * If neither works, will throw a <code>DBIError<\/code>\n     *\n     * @param wombat jdbc connection string or jndi lookup\n     * @throws DBIError if anything untoward happens.\n     */\n    public DBI(final String wombat)\n    {\n        repository = new NamedStatementRepository();\n        if (wombat.startsWith(\"jdbc:\"))\n        {\n            factory = new ConnectionFactory()\n            {\n                public Connection getConnection() throws SQLException\n                {\n                    return DriverManager.getConnection(wombat);\n                }\n            };\n        }\n        else\n        {\n            try\n            {\n                final InitialContext ctx = new InitialContext();\n                final DataSource source = (DataSource) ctx.lookup(wombat);\n                this.factory = new ConnectionFactory()\n                {\n                    public Connection getConnection() throws SQLException\n                    {\n                        return source.getConnection();\n                    }\n                };\n            }\n            catch (Exception e)\n            {\n                throw new DBIError(\"connection string is not a jdbc connection string, not a valid \" +\n                                   \"jndi lookup wombat to a DataSource instance: [\" + wombat + \"]\");\n            }\n        }\n    }\n\n    /**\n     * If <code>wombat<\/code> begins \"jdbc:\" the string will be treated as a jdbc driver\n     * otherwise it will be used as the key for a jndi lookup to findInternal a <code>DataSrouce<\/code>.\n     * If neither works, will throw a <code>DBIError<\/code>\n     *\n     * @param wombat jdbc connection string or jndi lookup\n     * @param name   username for grabbing connections\n     * @param pass   password for grabbing connections\n     * @throws DBIError if anything untoward happens.\n     */\n    public DBI(final String wombat, final String name, final String pass)\n    {\n        repository = new NamedStatementRepository();\n        if (wombat.startsWith(\"jdbc:\"))\n        {\n            factory = new ConnectionFactory()\n            {\n                public Connection getConnection() throws SQLException\n                {\n                    return DriverManager.getConnection(wombat, name, pass);\n                }\n            };\n        }\n        else\n        {\n            try\n            {\n                final InitialContext ctx = new InitialContext();\n                final DataSource source = (DataSource) ctx.lookup(wombat);\n                this.factory = new ConnectionFactory()\n                {\n                    public Connection getConnection() throws SQLException\n                    {\n                        return source.getConnection(name, pass);\n                    }\n                };\n            }\n            catch (Exception e)\n            {\n                throw new DBIError(\"connection string is not a jdbc connection string, not a valid \" +\n                                   \"jndi lookup wombat to a DataSource instance: [\" + wombat + \"]\");\n            }\n        }\n    }\n\n    /**\n     * Obtain a new DBI instance\n     *\n     * @param source DataSource provided by client\n     */\n    public DBI(final DataSource source)\n    {\n        this(new ConnectionFactory()\n        {\n            public Connection getConnection() throws SQLException\n            {\n                return source.getConnection();\n            }\n        });\n    }\n\n    /**\n     * Obtain a new DBI instance\n     *\n     * @param source DataSource provided by client\n     * @param name   jdbc username\n     * @param pass   jdbc user password\n     */\n    public DBI(final DataSource source, final String name, final String pass)\n    {\n        this(new ConnectionFactory()\n        {\n            public Connection getConnection() throws SQLException\n            {\n                return source.getConnection(name, pass);\n            }\n        });\n    }\n\n    /**\n     * Use a custom implementation of <code>ConnectionFactory<\/code> to obtain\n     * JDBC connections for handles created by this DBI\n     */\n    public DBI(ConnectionFactory factory)\n    {\n        this.repository = new NamedStatementRepository();\n        this.factory = factory;\n    }\n\n    /* Operational methods */\n\n    /**\n     * Obtain a new Handle instance\n     *\n     * @return an open Handle\n     * @throws DBIException\n     */\n    public Handle open() throws DBIException\n    {\n        try\n        {\n            return handleDecorator.decorate(this, new ConnectionHandle(factory.getConnection(),\n                                                                       repository,\n                                                                       transactionHandler));\n        }\n        catch (SQLException e)\n        {\n            throw new DBIException(\"Unable to obtain JDBC Connection: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Execute the callback with an open handle, closing, and cleaning up resources,\n     * after the callback exits or excepts\n     *\n     * @throws DBIException if exception is thrown from the callback, or\n     *                      an exception occurs with the database\n     * @throws DBIError     if an Error is thrown from the callback\n     */\n    public void open(HandleCallback callback) throws DBIException\n    {\n        Handle handle = null;\n        try\n        {\n            handle = this.open();\n            callback.withHandle(handle);\n        }\n        catch (DBIException e)\n        {\n            if (handle != null)\n            {\n                if (handle.isInTransaction())\n                {\n                    handle.rollback();\n                }\n            }\n            throw e;\n        }\n        catch (Exception e)\n        {\n            if (handle != null)\n            {\n                if (handle.isInTransaction())\n                {\n                    handle.rollback();\n                }\n            }\n            throw new DBIException(\"Exception thrown from callback, see nested exception\", e);\n        }\n        catch (Error e)\n        {\n            if (handle != null)\n            {\n                if (handle.isInTransaction())\n                {\n                    handle.rollback();\n                }\n            }\n            throw new DBIError(\"Error thrown from callback, see wrapped error\", e);\n        }\n        finally\n        {\n            if (handle != null)\n            {\n                if (handle.isOpen())\n                {\n                    if (handle.isInTransaction())\n                    {\n                        handle.commit();\n                    }\n                    handle.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Obtain an unmodifiable map of all the named statements known to this\n     * DBI instance.\n     */\n    public Map getNamedStatements()\n    {\n        return Collections.unmodifiableMap(new HashMap(repository.getStore()));\n    }\n\n    /**\n     * Prepared a named sql statement\n     *\n     * @param name      name to issue query under\n     * @param statement sql string to use as query\n     * @throws DBIException if there is a problem preparing the statement\n     */\n    public void name(final String name, final String statement) throws DBIException\n    {\n        Handle handle = null;\n        try\n        {\n            handle = this.open();\n            handle.name(name, statement);\n        }\n        finally\n        {\n            if (handle != null) handle.close();\n        }\n    }\n\n    /**\n     * Eagerly load a named query from the filesystem. The name will be <code>name<\/code>\n     * and it will look for a file named <code>[name].sql<\/code> in the classpath which\n     * contains a single sql statement.\n     *\n     * @param name name of query to load, such as \"foo\" which will be store din foo.sql\n     * @throws IOException\n     */\n    public void load(final String name) throws DBIException, IOException\n    {\n        Handle handle = null;\n        try\n        {\n            handle = this.open();\n            handle.load(name);\n        }\n        finally\n        {\n            if (handle != null) handle.close();\n        }\n    }\n\n    public void setTransactionHandler(TransactionHandler handler)\n    {\n        this.transactionHandler = handler;\n    }\n\n    /**\n     * Specify a decorator builder to decorate all handles created by this DBI instance\n     */\n    public void setHandleDecorator(HandleDecorator builder)\n    {\n        this.handleDecorator = builder;\n    }\n\n    /**\n     * Obtain a handle directly from a datasource\n     */\n    public static Handle open(final String connString) throws DBIException\n    {\n        return new DBI(connString).open();\n    }\n\n    /**\n     * Obtain a handle directly from a datasource\n     */\n    public static Handle open(final String wombat, final String name, final String pass) throws DBIException\n    {\n        return new DBI(wombat, name, pass).open();\n    }\n\n    public static Handle open(final DataSource source) throws DBIException\n    {\n        return new DBI(source).open();\n    }\n\n    /**\n     * Obtain a handle directly from a datasource\n     */\n    public static Handle open(final DataSource source, final String name, final String pass) throws DBIException\n    {\n        return new DBI(source, name, pass).open();\n    }\n\n    /**\n     * Execute <code>callback<\/code> with an opened handle, closing the handle, and cleaning\n     * up resources when the callback finishes.\n     */\n    public static void open(final String connString, final HandleCallback callback) throws DBIException\n    {\n        new DBI(connString).open(callback);\n    }\n\n    /**\n     * Execute <code>callback<\/code> with an opened handle, closing the handle, and cleaning\n     * up resources when the callback finishes.\n     */\n    public static void open(final String wombat,\n                            final String name,\n                            final String pass,\n                            final HandleCallback callback) throws DBIException\n    {\n        new DBI(wombat, name, pass).open(callback);\n    }\n\n    /**\n     * Execute <code>callback<\/code> with an opened handle, closing the handle, and cleaning\n     * up resources when the callback finishes.\n     */\n    public static void open(final DataSource source, final HandleCallback callback) throws DBIException\n    {\n        new DBI(source).open(callback);\n    }\n\n    /**\n     * Execute <code>callback<\/code> with an opened handle, closing the handle, and cleaning\n     * up resources when the callback finishes.\n     */\n    public static void open(final DataSource source,\n                            final String name,\n                            final String pass,\n                            final HandleCallback callback) throws DBIException\n    {\n        new DBI(source, name, pass).open(callback);\n    }\n}\n","Method after Refactoring":"/* Copyright 2004-2005 Brian McCallister\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.skife.jdbi;\n\nimport org.skife.jdbi.tweak.ConnectionTransactionHandler;\nimport org.skife.jdbi.tweak.StatementLocator;\nimport org.skife.jdbi.tweak.TransactionHandler;\nimport org.skife.jdbi.unstable.decorator.HandleDecorator;\n\nimport javax.naming.InitialContext;\nimport javax.sql.DataSource;\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Entry point for operations. May act as a configured bean, or provide handles\n * via static functions.\n */\npublic class DBI implements IDBI\n{\n    private final NamedStatementRepository repository;\n    private final ConnectionFactory factory;\n    private HandleDecorator handleDecorator = new NullHandleDecorator();\n    private TransactionHandler transactionHandler = new ConnectionTransactionHandler();\n\n    /**\n     * Attempt to auto-configure a DBi instance\n     * <p/>\n     * It first looks for an <code>org.skife.jdbi.properties-file<\/code> system property which\n     * represents a properties file to be loaded via the classpath. If that is not found, it looks\n     * for <code>jdbi.properties<\/code>, then <code>jdbc.properties<\/code>, then\n     * <code>dbi.properties<\/code>, then finally <code>database.properties<\/code> on the classpath.\n     * It will use the first it finds and stop looking for others once it finds one.\n     * <p/>\n     * Once a suitable configuration properties file has been loaded, jDBI will look for various\n     * properties used to configure it. There are multiple possible values for each logical\n     * property, and the order of preference if it should find multiple is the order listed here:\n     * <\/p>\n     * <table>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.url<\/li>\n     * <li>jdbc.url<\/li>\n     * <li>connection.string<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * JDBC Connection URL, ie <code>jdbc:derby:my_database<\/code>,\n     * required\n     * <\/td>\n     * <\/tr>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.driver<\/li>\n     * <li>jdbc.driver<\/li>\n     * <li>driver<\/li>\n     * <li>drive<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * JDBC Driver class name, ie <code>org.apache.derby.jdbc.EmbeddedDriver<\/code>,\n     * required\n     * <\/td>\n     * <\/tr>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.username<\/li>\n     * <li>jdbi.user<\/li>\n     * <li>jdbc.username<\/li>\n     * <li>jdbc.user<\/li>\n     * <li>username<\/li>\n     * <li>user<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * Username to be used when obtaining connections from the database, optional\n     * <\/td>\n     * <\/tr>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.password<\/li>\n     * <li>jdbi.pass<\/li>\n     * <li>jdbc.password<\/li>\n     * <li>jdbc.pass<\/li>\n     * <li>password<\/li>\n     * <li>pass<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * Password to be used when obtaining connections from the database, optional\n     * <\/td>\n     * <\/tr>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.handle-decorator-builder<\/li>\n     * <li>jdbc.handle-decorator-builder<\/li>\n     * <li>handle-decorator-builder<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * <b>Unstable Feature<\/b> class name of a <code>HandleDecorator<\/code>\n     * to be used to decorate <code>Handle<\/code> instances obtained from the\n     * <code>DBI<\/code> instance instantiated. This feature is functionally stable,\n     * but the specific api may change somewhat while it remains offically unstable.\n     * Please read the notes regarding the <code>org.skife.jdbi.unstable<\/code> package\n     * before using this. Optional.\n     * <\/td>\n     * <\/tr>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.transaction-handler<\/li>\n     * <li>jdbc.transaction-handler<\/li>\n     * <li>transaction-handler<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * <b>OPTIONAL<\/b> class name of a <code>TransactionHandler<\/code> which should\n     * be used to override default transaction handling. Must supply a no-arg constructor. Optional.\n     * <\/td>\n     * <\/tr>\n     * <tr>\n     * <td>\n     * <ul>\n     * <li>jdbi.statement-locator<\/li>\n     * <li>jdbc.statement-locator<\/li>\n     * <li>statement-locator<\/li>\n     * <\/ul>\n     * <\/td>\n     * <td>\n     * <b>OPTIONAL<\/b> class name of a <code>StatementLocator<\/code> which should\n     * be used to override default (cached from classpath) external sql statement locating. Optional.\n     * <\/td>\n     * <\/tr>\n     * <\/table>\n     *\n     * @throws IOException on error loading jdbi.properties\n     * @throws DBIError    if the properties file exists but is invalid\n     */\n    public DBI() throws IOException\n    {\n        repository = new NamedStatementRepository();\n        final AutoConfigurator auto = new AutoConfigurator();\n        factory = auto.getConnectionFactory();\n        try\n        {\n            final HandleDecorator d = auto.getHandleDecoratorBuilder();\n            if (d != null)\n            {\n                handleDecorator = d;\n            }\n            final TransactionHandler h = auto.getTransactionHandler();\n            if (h != null)\n            {\n                transactionHandler = h;\n            }\n            final StatementLocator l = auto.getStatementLocator();\n            if (l != null)\n            {\n                repository.setLocator(l);\n            }\n        }\n        catch (Exception e)\n        {\n            throw new DBIError(\"Unable to instantiate handle decorator builder :\" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * If <code>wombat<\/code> begins \"jdbc:\" the string will be treated as a jdbc driver\n     * otherwise it will be used as the key for a jndi lookup to findInternal a <code>DataSrouce<\/code>.\n     * If neither works, will throw a <code>DBIError<\/code>\n     *\n     * @param wombat jdbc connection string or jndi lookup\n     * @throws DBIError if anything untoward happens.\n     */\n    public DBI(final String wombat)\n    {\n        repository = new NamedStatementRepository();\n        if (wombat.startsWith(\"jdbc:\"))\n        {\n            factory = new ConnectionFactory()\n            {\n                public Connection getConnection() throws SQLException\n                {\n                    return DriverManager.getConnection(wombat);\n                }\n            };\n        }\n        else\n        {\n            try\n            {\n                final InitialContext ctx = new InitialContext();\n                final DataSource source = (DataSource) ctx.lookup(wombat);\n                this.factory = new ConnectionFactory()\n                {\n                    public Connection getConnection() throws SQLException\n                    {\n                        return source.getConnection();\n                    }\n                };\n            }\n            catch (Exception e)\n            {\n                throw new DBIError(\"connection string is not a jdbc connection string, not a valid \" +\n                                   \"jndi lookup wombat to a DataSource instance: [\" + wombat + \"]\");\n            }\n        }\n    }\n\n    /**\n     * If <code>wombat<\/code> begins \"jdbc:\" the string will be treated as a jdbc driver\n     * otherwise it will be used as the key for a jndi lookup to findInternal a <code>DataSrouce<\/code>.\n     * If neither works, will throw a <code>DBIError<\/code>\n     *\n     * @param wombat jdbc connection string or jndi lookup\n     * @param name   username for grabbing connections\n     * @param pass   password for grabbing connections\n     * @throws DBIError if anything untoward happens.\n     */\n    public DBI(final String wombat, final String name, final String pass)\n    {\n        repository = new NamedStatementRepository();\n        if (wombat.startsWith(\"jdbc:\"))\n        {\n            factory = new ConnectionFactory()\n            {\n                public Connection getConnection() throws SQLException\n                {\n                    return DriverManager.getConnection(wombat, name, pass);\n                }\n            };\n        }\n        else\n        {\n            try\n            {\n                final InitialContext ctx = new InitialContext();\n                final DataSource source = (DataSource) ctx.lookup(wombat);\n                this.factory = new ConnectionFactory()\n                {\n                    public Connection getConnection() throws SQLException\n                    {\n                        return source.getConnection(name, pass);\n                    }\n                };\n            }\n            catch (Exception e)\n            {\n                throw new DBIError(\"connection string is not a jdbc connection string, not a valid \" +\n                                   \"jndi lookup wombat to a DataSource instance: [\" + wombat + \"]\");\n            }\n        }\n    }\n\n    /**\n     * Obtain a new DBI instance\n     *\n     * @param source DataSource provided by client\n     */\n    public DBI(final DataSource source)\n    {\n        this(new ConnectionFactory()\n        {\n            public Connection getConnection() throws SQLException\n            {\n                return source.getConnection();\n            }\n        });\n    }\n\n    /**\n     * Obtain a new DBI instance\n     *\n     * @param source DataSource provided by client\n     * @param name   jdbc username\n     * @param pass   jdbc user password\n     */\n    public DBI(final DataSource source, final String name, final String pass)\n    {\n        this(new ConnectionFactory()\n        {\n            public Connection getConnection() throws SQLException\n            {\n                return source.getConnection(name, pass);\n            }\n        });\n    }\n\n    /**\n     * Use a custom implementation of <code>ConnectionFactory<\/code> to obtain\n     * JDBC connections for handles created by this DBI\n     */\n    public DBI(ConnectionFactory factory)\n    {\n        this.repository = new NamedStatementRepository();\n        this.factory = factory;\n    }\n\n    /* Operational methods */\n\n    /**\n     * Obtain a new Handle instance\n     *\n     * @return an open Handle\n     * @throws DBIException\n     */\n    public Handle open() throws DBIException\n    {\n        try\n        {\n            return handleDecorator.decorate(this, new ConnectionHandle(factory.getConnection(),\n                                                                       repository,\n                                                                       transactionHandler));\n        }\n        catch (SQLException e)\n        {\n            throw new DBIException(\"Unable to obtain JDBC Connection: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Execute the callback with an open handle, closing, and cleaning up resources,\n     * after the callback exits or excepts\n     *\n     * @throws DBIException if exception is thrown from the callback, or\n     *                      an exception occurs with the database\n     * @throws DBIError     if an Error is thrown from the callback\n     */\n    public void open(HandleCallback callback) throws DBIException\n    {\n        Handle handle = null;\n        try\n        {\n            handle = this.open();\n            callback.withHandle(handle);\n        }\n        catch (DBIException e)\n        {\n            if (handle != null)\n            {\n                if (handle.isInTransaction())\n                {\n                    handle.rollback();\n                }\n            }\n            throw e;\n        }\n        catch (Exception e)\n        {\n            if (handle != null)\n            {\n                if (handle.isInTransaction())\n                {\n                    handle.rollback();\n                }\n            }\n            throw new DBIException(\"Exception thrown from callback, see nested exception\", e);\n        }\n        catch (Error e)\n        {\n            if (handle != null)\n            {\n                if (handle.isInTransaction())\n                {\n                    handle.rollback();\n                }\n            }\n            throw new DBIError(\"Error thrown from callback, see wrapped error\", e);\n        }\n        finally\n        {\n            if (handle != null)\n            {\n                if (handle.isOpen())\n                {\n                    if (handle.isInTransaction())\n                    {\n                        handle.commit();\n                    }\n                    handle.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Obtain an unmodifiable map of all the named statements known to this\n     * DBI instance.\n     */\n    public Map getNamedStatements()\n    {\n        return Collections.unmodifiableMap(new HashMap(repository.getStore()));\n    }\n\n    /**\n     * Prepared a named sql statement\n     *\n     * @param name      name to issue query under\n     * @param statement sql string to use as query\n     * @throws DBIException if there is a problem preparing the statement\n     */\n    public void name(final String name, final String statement) throws DBIException\n    {\n        Handle handle = null;\n        try\n        {\n            handle = this.open();\n            handle.name(name, statement);\n        }\n        finally\n        {\n            if (handle != null) handle.close();\n        }\n    }\n\n    /**\n     * Eagerly load a named query from the filesystem. The name will be <code>name<\/code>\n     * and it will look for a file named <code>[name].sql<\/code> in the classpath which\n     * contains a single sql statement.\n     *\n     * @param name name of query to load, such as \"foo\" which will be store din foo.sql\n     * @throws IOException\n     */\n    public void load(final String name) throws DBIException, IOException\n    {\n        Handle handle = null;\n        try\n        {\n            handle = this.open();\n            handle.load(name);\n        }\n        finally\n        {\n            if (handle != null) handle.close();\n        }\n    }\n\n    /**\n     * Specify a non-standard <code>TransactionHandler<\/code> which should be\n     * used for all <code>Handle<\/code> instances created from this dbi.\n     * <p />\n     * The default handler, if you specify none, will explicitely manage\n     * transactions on the underlying JDBC connection.\n     *\n     * @see org.skife.jdbi.tweak.ConnectionTransactionHandler\n     * @see org.skife.jdbi.tweak.CMTConnectionTransactionHandler\n     */\n    public void setTransactionHandler(TransactionHandler handler)\n    {\n        this.transactionHandler = handler;\n    }\n\n    /**\n     * Specify a non-standard statement locator.\n     *\n     * @param locator used to find externalized sql\n     */\n    public void setStatementLocator(StatementLocator locator)\n    {\n        this.repository.setLocator(locator);\n    }\n\n    /**\n     * Specify a decorator builder to decorate all handles created by this DBI instance\n     */\n    public void setHandleDecorator(HandleDecorator builder)\n    {\n        this.handleDecorator = builder;\n    }\n\n    /**\n     * Obtain a handle directly from a datasource\n     */\n    public static Handle open(final String connString) throws DBIException\n    {\n        return new DBI(connString).open();\n    }\n\n    /**\n     * Obtain a handle directly from a datasource\n     */\n    public static Handle open(final String wombat, final String name, final String pass) throws DBIException\n    {\n        return new DBI(wombat, name, pass).open();\n    }\n\n    public static Handle open(final DataSource source) throws DBIException\n    {\n        return new DBI(source).open();\n    }\n\n    /**\n     * Obtain a handle directly from a datasource\n     */\n    public static Handle open(final DataSource source, final String name, final String pass) throws DBIException\n    {\n        return new DBI(source, name, pass).open();\n    }\n\n    /**\n     * Execute <code>callback<\/code> with an opened handle, closing the handle, and cleaning\n     * up resources when the callback finishes.\n     */\n    public static void open(final String connString, final HandleCallback callback) throws DBIException\n    {\n        new DBI(connString).open(callback);\n    }\n\n    /**\n     * Execute <code>callback<\/code> with an opened handle, closing the handle, and cleaning\n     * up resources when the callback finishes.\n     */\n    public static void open(final String wombat,\n                            final String name,\n                            final String pass,\n                            final HandleCallback callback) throws DBIException\n    {\n        new DBI(wombat, name, pass).open(callback);\n    }\n\n    /**\n     * Execute <code>callback<\/code> with an opened handle, closing the handle, and cleaning\n     * up resources when the callback finishes.\n     */\n    public static void open(final DataSource source, final HandleCallback callback) throws DBIException\n    {\n        new DBI(source).open(callback);\n    }\n\n    /**\n     * Execute <code>callback<\/code> with an opened handle, closing the handle, and cleaning\n     * up resources when the callback finishes.\n     */\n    public static void open(final DataSource source,\n                            final String name,\n                            final String pass,\n                            final HandleCallback callback) throws DBIException\n    {\n        new DBI(source, name, pass).open(callback);\n    }\n}\n","lineNo":169}
