{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeUnwrapped;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ArrayLiteral extends Literal implements MustBeUnwrapped {\n\n\tprivate FunctionCall outerCall = null;\n\tprivate int outerArgIndex = -1;\n\t\n\t//private static Type defaultType = NullLiteral.type;\n\tprivate static Type defaultType = null;\n\tprivate Type innerType = null;\n\tprivate Type type = defaultType;\n\t\n\tprotected NodeList<Expression> elements;\n\t\n\tpublic ArrayLiteral(Token startToken) {\n\t\tsuper(startToken);\n\t\telements = new NodeList<Expression>(startToken);\n\t}\n\t\n\t@Override\n\tpublic Expression getGenericOperand() {\n\t\tSystem.out.println(\"Should get genericOperand of arrlit \"+this);\n\t\treturn super.getGenericOperand();\n\t}\n\t\n\tpublic int getDepth() {\n\t\tif(elements.isEmpty() || !(elements.getFirst() instanceof ArrayLiteral)) return 1;\n\t\treturn 1 + ((ArrayLiteral) elements.getFirst()).getDepth();\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == type) {\n\t\t\ttype = (Type) kiddo;\n\t\t\treturn true;\n\t\t} else if(oldie == innerType) {\n\t\t\tinnerType = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\t\n\tpublic Type getInnerType() {\n\t\treturn innerType;\n\t}\n\t\n\tpublic NodeList<Expression> getElements() {\n\t\treturn elements;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif(type != null) type.accept(visitor);\n\t\telements.accept(visitor);\n\t}\n\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn type != defaultType && super.isResolved();\n\t}\n\t\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(type != defaultType) return Response.OK;\n\t\t\n\t\tif(!elements.isEmpty()) {\n\t\t\t\n\t\t\tIterator<Expression> iter = elements.iterator();\n\t\t\t\n\t\t\t// try to determine the innerType from an outer call\n\t\t\tif(outerCall != null && outerArgIndex != -1) {\n\t\t\t\tFunctionDecl impl = outerCall.getImpl();\n\t\t\t\tif(impl == null) {\n\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of an array literal because\" +\n\t\t\t\t\t\t\t\t\" the function call it's in hasn't been resolved.\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\tArgument arg = impl.getArguments().get(outerArgIndex);\n\t\t\t\t\n\t\t\t\tArrayLiteral lit = this;\n\t\t\t\tint pointerLevel = 0;\n\t\t\t\twhile(lit != null) {\n\t\t\t\t\tNode first = lit.getElements().getFirst();\n\t\t\t\t\tif(first instanceof ArrayLiteral) {\n\t\t\t\t\t\tlit = (ArrayLiteral) first;\n\t\t\t\t\t\tpointerLevel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlit = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinnerType = new Type(arg.getType().getName(), arg.getType().startToken);\n\t\t\t\tinnerType.setPointerLevel(pointerLevel);\n\t\t\t}\n\t\t\t\n\t\t\t// try to determine the innerType from the first element\n\t\t\tif(innerType == null) {\n\t\t\t\tExpression first = iter.next();\n\t\t\t\tinnerType = first.getType();\n\t\t\t}\n\t\t\t\n\t\t\t// if we didn't resolve it && fatal, we're screwed :/ \n\t\t\tif(innerType == null) {\n\t\t\t\tif(fatal) {\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of an array literal\");\n\t\t\t\t}\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\t\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tExpression element = iter.next();\n\t\t\t\tif(element.getType() == null) {\n\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\tthrow new OocCompilationError(element, stack, \"Couldn't resolve type of \"\n\t\t\t\t\t\t\t\t+element+\" in an \"+innerType+\" array literal\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\tif(!element.getType().fitsIn(innerType)) {\n\t\t\t\t\tthrow new OocCompilationError(element, stack, \"Encountered a \"\n\t\t\t\t\t\t\t+element.getType()+\" in a \"+innerType+\"[] array literal.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.type = new Type(innerType.name, innerType.pointerLevel + 1, startToken);\n\t\t\ttype.getTypeParams().addAll(innerType.getTypeParams());\n\t\t\ttype.setArray(true);\n\t\t\tstack.push(this);\n\t\t\ttype.resolve(stack, res, fatal);\n\t\t\tinnerType.resolve(stack, res, fatal);\n\t\t\tstack.pop(this);\n\t\t}\n\t\t\n\t\tif(type == defaultType && fatal) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out type of ArrayLiteral with elements \"+elements);\n\t\t}\n\t\treturn (type == defaultType) ? Response.LOOP : super.resolve(stack, res, fatal);\n\t\t\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean unwrap(NodeList<Node> stack) throws IOException {\n\n\t\t// try to determine the innerType from the outer requirements\n\t\tif(outerCall == null || outerArgIndex == -1) {\n\t\t\tArrayLiteral lit = this;\n\t\t\tint litIndex = stack.find(ArrayLiteral.class);\n\t\t\tint callIndex = stack.find(FunctionCall.class);\n\t\t\tif(callIndex != -1) {\n\t\t\t\tif(litIndex != -1 && litIndex > callIndex) {\n\t\t\t\t\tlit = (ArrayLiteral) stack.get(litIndex);\n\t\t\t\t}\n\t\t\t\touterCall = (FunctionCall) stack.get(callIndex);\n\t\t\t\touterArgIndex = ((NodeList<Node>) stack.get(callIndex + 1)).indexOf(lit);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(stack.peek() instanceof Cast || stack.peek() instanceof Foreach) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(stack.peek(2) instanceof ArrayLiteral) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\t\n\t\t// if stack.size() - varDeclIndex > 3, we're nested in another varDecl\n\t\t//, thus we need to unwrap\n\t\tif(varDeclIndex == -1 || (stack.size() - varDeclIndex) > 3) {\n\t\t\tstack.peek().replace(this, new VariableDecl(\n\t\t\t\t\tnull, generateTempName(\"array\", stack), this, startToken, stack.getModule()));\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('[');\n\t\tboolean isFirst = true;\n\t\tfor(Statement element : elements) {\n\t\t\tif(isFirst) isFirst = false;\n\t\t\telse        sb.append(\", \");\n\t\t\tsb.append(element.toString());\n\t\t}\n\t\tsb.append(']');\n\t\treturn sb.toString();\n\t}\n\t\n\t@Override\n\tpublic boolean isConstant() {\n\t\treturn false;\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeUnwrapped;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ArrayLiteral extends Literal implements MustBeUnwrapped {\n\n\tprivate FunctionCall outerCall = null;\n\tprivate int outerArgIndex = -1;\n\t\n\t//private static Type defaultType = NullLiteral.type;\n\tprivate static Type defaultType = null;\n\tprivate Type innerType = null;\n\tprivate Type type = defaultType;\n\t\n\tprotected NodeList<Expression> elements;\n\t\n\tpublic ArrayLiteral(Token startToken) {\n\t\tsuper(startToken);\n\t\telements = new NodeList<Expression>(startToken);\n\t}\n\t\n\t@Override\n\tpublic Expression getGenericOperand() {\n\t\tSystem.out.println(\"Should get genericOperand of arrlit \"+this);\n\t\treturn super.getGenericOperand();\n\t}\n\t\n\tpublic int getDepth() {\n\t\tif(elements.isEmpty() || !(elements.getFirst() instanceof ArrayLiteral)) return 1;\n\t\treturn 1 + ((ArrayLiteral) elements.getFirst()).getDepth();\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == type) {\n\t\t\ttype = (Type) kiddo;\n\t\t\treturn true;\n\t\t} else if(oldie == innerType) {\n\t\t\tinnerType = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\t\n\tpublic Type getInnerType() {\n\t\treturn innerType;\n\t}\n\t\n\tpublic NodeList<Expression> getElements() {\n\t\treturn elements;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif(type != null) type.accept(visitor);\n\t\telements.accept(visitor);\n\t}\n\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn type != defaultType && super.isResolved();\n\t}\n\t\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(type != defaultType) return Response.OK;\n\t\t\n\t\tif(!elements.isEmpty()) {\n\t\t\t\n\t\t\tIterator<Expression> iter = elements.iterator();\n\t\t\t\n\t\t\t// try to determine the innerType from an outer call\n\t\t\tif(outerCall != null && outerArgIndex != -1) {\n\t\t\t\tFunctionDecl impl = outerCall.getImpl();\n\t\t\t\tif(impl == null) {\n\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of an array literal because\" +\n\t\t\t\t\t\t\t\t\" the function call it's in hasn't been resolved.\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\tArgument arg = impl.getArguments().get(outerArgIndex);\n\t\t\t\t\n\t\t\t\tArrayLiteral lit = this;\n\t\t\t\tint pointerLevel = 0;\n\t\t\t\twhile(lit != null) {\n\t\t\t\t\tNode first = lit.getElements().getFirst();\n\t\t\t\t\tif(first instanceof ArrayLiteral) {\n\t\t\t\t\t\tlit = (ArrayLiteral) first;\n\t\t\t\t\t\tpointerLevel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlit = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinnerType = new Type(arg.getType().getName(), arg.getType().startToken);\n\t\t\t\tinnerType.setPointerLevel(pointerLevel);\n\t\t\t}\n\t\t\t\n\t\t\t// try to determine the innerType from the first element\n\t\t\tif(innerType == null) {\n\t\t\t\tExpression first = iter.next();\n\t\t\t\tinnerType = first.getType();\n\t\t\t}\n\t\t\t\n\t\t\t// if we didn't resolve it && fatal, we're screwed :/ \n\t\t\tif(innerType == null) {\n\t\t\t\tif(fatal) {\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of an array literal\");\n\t\t\t\t}\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\t\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tExpression element = iter.next();\n\t\t\t\tif(element.getType() == null) {\n\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\tthrow new OocCompilationError(element, stack, \"Couldn't resolve type of \"\n\t\t\t\t\t\t\t\t+element+\" in an \"+innerType+\" array literal\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\tif(!element.getType().fitsIn(innerType)) {\n\t\t\t\t\tthrow new OocCompilationError(element, stack, \"Encountered a \"\n\t\t\t\t\t\t\t+element.getType()+\" in a \"+innerType+\"[] array literal.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.type = new Type(innerType.name, innerType.pointerLevel + 1, startToken);\n\t\t\ttype.getTypeParams().addAll(innerType.getTypeParams());\n\t\t\ttype.setArray(true);\n\t\t\tstack.push(this);\n\t\t\ttype.resolve(stack, res, fatal);\n\t\t\tinnerType.resolve(stack, res, fatal);\n\t\t\tstack.pop(this);\n\t\t}\n\t\t\n\t\tif(type == defaultType && fatal) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out type of ArrayLiteral with elements \"+elements);\n\t\t}\n\t\treturn (type == defaultType) ? Response.LOOP : super.resolve(stack, res, fatal);\n\t\t\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean unwrap(NodeList<Node> stack) throws IOException {\n\n\t\t// try to determine the innerType from the outer requirements\n\t\tif(outerCall == null || outerArgIndex == -1) {\n\t\t\tArrayLiteral lit = this;\n\t\t\tint litIndex = stack.find(ArrayLiteral.class);\n\t\t\tint callIndex = stack.find(FunctionCall.class);\n\t\t\tif(callIndex != -1) {\n\t\t\t\tif(litIndex != -1 && litIndex > callIndex) {\n\t\t\t\t\tlit = (ArrayLiteral) stack.get(litIndex);\n\t\t\t\t}\n\t\t\t\touterCall = (FunctionCall) stack.get(callIndex);\n\t\t\t\touterArgIndex = ((NodeList<Node>) stack.get(callIndex + 1)).indexOf(lit);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(stack.peek() instanceof Cast || stack.peek() instanceof Foreach) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(stack.peek(2) instanceof ArrayLiteral) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\t\n\t\t// if stack.size() - varDeclIndex > 3, we're nested in another varDecl\n\t\t//, thus we need to unwrap\n\t\tif(varDeclIndex == -1 || (stack.size() - varDeclIndex) > 3) {\n\t\t\tstack.peek().replace(this, new VariableDecl(\n\t\t\t\t\tnull, generateTempName(\"array\", stack), this, startToken, stack.getModule()));\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('[');\n\t\tboolean isFirst = true;\n\t\tfor(Statement element : elements) {\n\t\t\tif(isFirst) isFirst = false;\n\t\t\telse        sb.append(\", \");\n\t\t\tsb.append(element.toString());\n\t\t}\n\t\tsb.append(']');\n\t\treturn sb.toString();\n\t}\n\t\n\t@Override\n\tpublic boolean isConstant() {\n\t\tboolean isConstant = true;\n\t\tfor(Expression element : elements) {\n\t\t\tif(!element.isConstant()) {\n\t\t\t\tisConstant = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn isConstant;\n\t}\n\n}\n","lineNo":219}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VersionNodes.VersionName;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\nimport org.ubi.CompilationFailedError;\n\npublic class ClassDecl extends TypeDecl {\n\n\tpublic static final String DESTROY_FUNC_NAME = \"__destroy__\";\n\tpublic static final String DEFAULTS_FUNC_NAME = \"__defaults__\";\n\tpublic static final String LOAD_FUNC_NAME = \"__load__\";\n\t\n\tprotected boolean hasRegisteredFinalizer = false;\n\t\n\tprotected boolean isAbstract;\n\t\n\tprotected OocDocComment comment;\n\t\n\tprotected FunctionDecl defaultInit = null;\n\t\n\tpublic ClassDecl(String name, Type superType, boolean isAbstract, Module module, Token startToken) {\n\t\tsuper(name, (superType == null && !name.equals(\"Object\")) ?\n\t\t\t\tnew Type(\"Object\", Token.defaultToken) : superType, module, startToken);\n\t\tthis.isAbstract = isAbstract;\n\t\t\n\t\taddFunction(new FunctionDecl(LOAD_FUNC_NAME,     \"\", false,  true, false, false, startToken, module));\n\t\taddFunction(new FunctionDecl(DEFAULTS_FUNC_NAME, \"\", false, false, false, false, startToken, module));\n\t\taddFunction(new FunctionDecl(DESTROY_FUNC_NAME,  \"\", false, false, false, false, startToken, module));\n\t}\n\t\n\t@Override\n\tpublic ClassDecl getSuperRef() {\n\t\tTypeDecl ref = super.getSuperRef();\n\t\tif(ref != null && !(ref instanceof ClassDecl)) {\n\t\t\tthrow new CompilationFailedError(null, \"Huh your class '\"+getName()\n\t\t\t\t\t+\"' in '\"+(module != null ? module.getFullName() : \"<unknown module>\")\n\t\t\t\t\t+\"' extends \"+ref.getName()+\" which isn't a ClassDecl but a \"\n\t\t\t\t\t+ref.getClass().getSimpleName());\n\t\t}\n\t\treturn (ClassDecl) ref;\n\t}\n\n\tpublic boolean isObjectClass() {\n\t\treturn name.equals(\"Object\");\n\t}\n\t\n\tpublic boolean isClassClass() {\n\t\treturn name.equals(\"Class\");\n\t}\n\t\n\tpublic boolean isRootClass() {\n\t\treturn isObjectClass() || isClassClass();\n\t}\n\t\n\tpublic OocDocComment getComment() {\n\t\treturn comment;\n\t}\n\t\n\tpublic void setComment(OocDocComment comment) {\n\t\tthis.comment = comment;\n\t}\n\t\n\tpublic boolean isAbstract() {\n\t\treturn isAbstract;\n\t}\n\t\n\tpublic void setAbstract(boolean isAbstract) {\n\t\tthis.isAbstract = isAbstract;\n\t}\n\t\n\t@Override\n\tpublic void addFunction(FunctionDecl decl) {\n\t\t\n\t\tif(decl.getName().equals(\"init\")) {\n\t\t\taddInit(decl);\n\t\t} else if(decl.getName().equals(\"new\")) {\n\t\t\tFunctionDecl already = getFunction(decl.getName(), decl.getSuffix(), null);\n\t\t\tif(already != null) { functions.remove(already); }\n\t\t}\n\t\t\n\t\tsuper.addFunction(decl);\n\t}\n\t\n\tpublic void addDefaultInit() {\n\t\tif(!isAbstract && defaultInit == null) {\n\t\t\tFunctionDecl init = new FunctionDecl(\"init\", \"\", false, false, false, false, startToken, module);\n\t\t\taddFunction(init);\n\t\t\tdefaultInit = init;\n\t\t}\n\t}\n\n\tprivate void addInit(FunctionDecl decl) {\n\t\tif(defaultInit != null) {\n\t\t\tFunctionDecl newFunc = getFunction(\"new\", \"\", null);\n\t\t\tfunctions.remove(defaultInit);\n\t\t\tfunctions.remove(newFunc);\n\t\t\tdefaultInit = null;\n\t\t}\n\t\t\n\t\tFunctionDecl constructor = new FunctionDecl(\"new\", decl.getSuffix(), false, true, false, false, decl.startToken, module);\n\t\tType retType = getType().clone();\n\t\tretType.getTypeParams().clear();\n\t\t\n\t\tconstructor.getArguments().addAll(decl.getArguments());\n\t\tconstructor.getTypeParams().putAll(getTypeParams());\n\t\t\n\t\tVariableAccess thisTypeAccess = new VariableAccess(name, decl.startToken);\n\t\tthisTypeAccess.setRef(this);\n\t\tVariableAccess classAccess = new MemberAccess(thisTypeAccess, \"class\", decl.startToken);\n\t\tMemberCall allocCall = new MemberCall(classAccess, \"alloc\", \"\", decl.startToken);\n\t\tCast cast = new Cast(allocCall, getType(), decl.startToken);\n\t\tVariableDecl vdfe = new VariableDecl(null, \"this\", cast, decl.startToken, module);\n\t\tconstructor.getBody().add(new Line(vdfe));\n\t\t\n\t\tfor(TypeParam genType: typeParams.values()) {\n\t\t\tVariableAccess e = new VariableAccess(genType.getName(), constructor.startToken);\n\t\t\tretType.getTypeParams().add(e);\n\t\t\t\n\t\t\tconstructor.getBody().add(new Line(new Assignment(\n\t\t\t\t\tnew MemberAccess(genType.getName(), startToken), e, constructor.startToken))\n\t\t\t);\n\t\t}\n\t\tconstructor.setReturnType(retType);\n\n\t\tVariableAccess thisAccess = new VariableAccess(vdfe, decl.startToken);\n\t\tthisAccess.setRef(vdfe);\n\t\t\n\t\tMemberCall defaultsCall = new MemberCall(thisAccess, \"__defaults__\", \"\", decl.startToken);\n\t\tconstructor.getBody().add(new Line(defaultsCall));\n\t\t\n\t\tFunctionCall initCall = new FunctionCall(decl, decl.startToken);\n\t\tfor(Argument arg: constructor.getArguments()) {\n\t\t\tinitCall.getArguments().add(new VariableAccess(arg, decl.startToken));\n\t\t}\n\t\tconstructor.getBody().add(new Line(new MemberCall(thisAccess, initCall, decl.startToken)));\n\t\tconstructor.getBody().add(new Line(new ValuedReturn(thisAccess, decl.startToken)));\n\t\t\n\t\taddFunction(constructor);\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tsuper.getVariables(variables);\n\t\tif(getSuperRef() != null) getSuperRef().getVariables(variables);\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tResponse response = super.resolve(stack, res, fatal);\n\t\tif(response != Response.OK) return response;\n\t\t\n\t\tif(isResolved()) return Response.OK;\n\n\t\tif(getSuperType() != null && !(super.getSuperRef() instanceof ClassDecl)) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Trying to extends a \"\n\t\t\t\t\t+getSuperRef().getClass().getSimpleName()+\". You can only extend classes.\");\n\t\t}\n\t\tif (getSuperType() != null) {\n\t\t\tif(getSuperRef() == null) {\n\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Super-type \"\n\t\t\t\t\t\t+getSuperType()+\" of class \"+getType()+\" couldn't be resolved\");\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\tif(defaultInit == null) {\n\t\t\t\tFunctionDecl superInit = getSuperRef().getFunction(\"init\", \"\", null);\n\t\t\t\tif(superInit != null && superInit == getSuperRef().defaultInit) {\n\t\t\t\t\taddDefaultInit();\n\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!hasRegisteredFinalizer) {\n\t\t\tFunctionDecl finalizer = getFunction(DESTROY_FUNC_NAME, null, null);\n\t\t\tif(finalizer != null && !finalizer.getBody().isEmpty()) {\n\t\t\t\tFunctionDecl defaults = getFunction(DEFAULTS_FUNC_NAME, null, null);\n\t\t\t\tFunctionCall call = new FunctionCall(\"gc_register_finalizer\", finalizer.startToken);\n\t\t\t\tNodeList<Expression> args = call.getArguments();\n\t\t\t\t/*\n\t\t\t\t * void GC_debug_register_finalizer (GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n\t\t  \t\t * GC_finalization_proc *ofn, GC_PTR *ocd);\n\t\t\t\t */\n\t\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", finalizer.startToken);\n\t\t\t\targs.add(thisAccess); // for object \"this\"\n\t\t\t\t\n\t\t\t\tVariableAccess destroyAccess = new MemberAccess(thisAccess, \"__destroy__\", finalizer.startToken);\n\t\t\t\targs.add(destroyAccess); // call the finalizer\n\t\t\t\t\n\t\t\t\tNullLiteral nil = new NullLiteral(finalizer.startToken);\n\t\t\t\targs.add(nil); // cd (no argument to apss)\n\t\t\t\targs.add(nil); // ofn (we don't care)\n\t\t\t\targs.add(nil); // ocd (we don't care)\n\t\t\t\t\n\t\t\t\tVersionBlock vBlock = new VersionBlock(new VersionName(\"gc\"), finalizer.startToken);\n\t\t\t\tvBlock.getBody().add(new Line(call));\n\t\t\t\tdefaults.getBody().add(0, new Line(vBlock));\n\t\t\t\t\n\t\t\t\thasRegisteredFinalizer = true;\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tpublic ClassDecl getBaseClass(FunctionDecl decl) {\n\t\tif(getSuperRef() != null) {\n\t\t\tClassDecl base = getSuperRef().getBaseClass(decl);\n\t\t\tif(base != null) return base;\n\t\t}\n\t\tif(getFunction(decl.getName(), decl.getSuffix(), null, false) != null) return this;\n\t\treturn null;\n\t}\n\t\n\tpublic boolean isChildOf(String candidate) {\n\t\tif(getName().equals(candidate)) return true;\n\t\tif(getSuperRef() != null) return getSuperRef().isChildOf(candidate);\n\t\treturn false;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VersionNodes.VersionName;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\nimport org.ubi.CompilationFailedError;\n\npublic class ClassDecl extends TypeDecl {\n\n\tpublic static final String DESTROY_FUNC_NAME = \"__destroy__\";\n\tpublic static final String DEFAULTS_FUNC_NAME = \"__defaults__\";\n\tpublic static final String LOAD_FUNC_NAME = \"__load__\";\n\t\n\tprotected boolean hasRegisteredFinalizer = false;\n\t\n\tprotected boolean isAbstract;\n\t\n\tprotected OocDocComment comment;\n\t\n\tprotected FunctionDecl defaultInit = null;\n\t\n\tpublic ClassDecl(String name, Type superType, boolean isAbstract, Module module, Token startToken) {\n\t\tsuper(name, (superType == null && !name.equals(\"Object\")) ?\n\t\t\t\tnew Type(\"Object\", Token.defaultToken) : superType, module, startToken);\n\t\tthis.isAbstract = isAbstract;\n\t\t\n\t\taddFunction(new FunctionDecl(LOAD_FUNC_NAME,     \"\", false,  true, false, false, startToken, module));\n\t\taddFunction(new FunctionDecl(DEFAULTS_FUNC_NAME, \"\", false, false, false, false, startToken, module));\n\t\taddFunction(new FunctionDecl(DESTROY_FUNC_NAME,  \"\", false, false, false, false, startToken, module));\n\t}\n\t\n\t@Override\n\tpublic ClassDecl getSuperRef() {\n\t\tTypeDecl ref = super.getSuperRef();\n\t\tif(ref != null && !(ref instanceof ClassDecl)) {\n\t\t\tthrow new CompilationFailedError(null, \"Huh your class '\"+getName()\n\t\t\t\t\t+\"' in '\"+(module != null ? module.getFullName() : \"<unknown module>\")\n\t\t\t\t\t+\"' extends \"+ref.getName()+\" which isn't a ClassDecl but a \"\n\t\t\t\t\t+ref.getClass().getSimpleName());\n\t\t}\n\t\treturn (ClassDecl) ref;\n\t}\n\n\tpublic boolean isObjectClass() {\n\t\treturn name.equals(\"Object\");\n\t}\n\t\n\tpublic boolean isClassClass() {\n\t\treturn name.equals(\"Class\");\n\t}\n\t\n\tpublic boolean isRootClass() {\n\t\treturn isObjectClass() || isClassClass();\n\t}\n\t\n\tpublic OocDocComment getComment() {\n\t\treturn comment;\n\t}\n\t\n\tpublic void setComment(OocDocComment comment) {\n\t\tthis.comment = comment;\n\t}\n\t\n\tpublic boolean isAbstract() {\n\t\treturn isAbstract;\n\t}\n\t\n\tpublic void setAbstract(boolean isAbstract) {\n\t\tthis.isAbstract = isAbstract;\n\t}\n\t\n\t@Override\n\tpublic void addFunction(FunctionDecl decl) {\n\t\t\n\t\tif(decl.getName().equals(\"init\")) {\n\t\t\taddInit(decl);\n\t\t} else if(decl.getName().equals(\"new\")) {\n\t\t\tFunctionDecl already = getFunction(decl.getName(), decl.getSuffix(), null);\n\t\t\tif(already != null) { functions.remove(already); }\n\t\t}\n\t\t\n\t\tsuper.addFunction(decl);\n\t}\n\t\n\tpublic void addDefaultInit() {\n\t\tif(!isAbstract && defaultInit == null) {\n\t\t\tFunctionDecl init = new FunctionDecl(\"init\", \"\", false, false, false, false, startToken, module);\n\t\t\taddFunction(init);\n\t\t\tdefaultInit = init;\n\t\t}\n\t}\n\n\tprivate void addInit(FunctionDecl decl) {\n\t\tif(defaultInit != null) {\n\t\t\tFunctionDecl newFunc = getFunction(\"new\", \"\", null);\n\t\t\tfunctions.remove(defaultInit);\n\t\t\tfunctions.remove(newFunc);\n\t\t\tdefaultInit = null;\n\t\t}\n\t\t\n\t\tFunctionDecl constructor = new FunctionDecl(\"new\", decl.getSuffix(), false, true, false, false, decl.startToken, module);\n\t\tType retType = getType().clone();\n\t\tretType.getTypeParams().clear();\n\t\t\n\t\tconstructor.getArguments().addAll(decl.getArguments());\n\t\tconstructor.getTypeParams().putAll(getTypeParams());\n\t\t\n\t\tVariableAccess thisTypeAccess = new VariableAccess(name, decl.startToken);\n\t\tthisTypeAccess.setRef(this);\n\t\tVariableAccess classAccess = new MemberAccess(thisTypeAccess, \"class\", decl.startToken);\n\t\tMemberCall allocCall = new MemberCall(classAccess, \"alloc\", \"\", decl.startToken);\n\t\tCast cast = new Cast(allocCall, getType(), decl.startToken);\n\t\tVariableDecl vdfe = new VariableDecl(null, \"this\", cast, decl.startToken, module);\n\t\tconstructor.getBody().add(new Line(vdfe));\n\t\t\n\t\tfor(TypeParam genType: typeParams.values()) {\n\t\t\tVariableAccess e = new VariableAccess(genType.getName(), constructor.startToken);\n\t\t\tretType.getTypeParams().add(e);\n\t\t\t\n\t\t\tMemberAccess membAcc = new MemberAccess(genType.getName(), startToken);\n\t\t\tmembAcc.isMarked = true;\n\t\t\tconstructor.getBody().add(new Line(new Assignment(\n\t\t\t\t\tmembAcc, e, constructor.startToken))\n\t\t\t);\n\t\t}\n\t\tconstructor.setReturnType(retType);\n\n\t\tVariableAccess thisAccess = new VariableAccess(vdfe, decl.startToken);\n\t\tthisAccess.setRef(vdfe);\n\t\t\n\t\tMemberCall defaultsCall = new MemberCall(thisAccess, \"__defaults__\", \"\", decl.startToken);\n\t\tconstructor.getBody().add(new Line(defaultsCall));\n\t\t\n\t\tFunctionCall initCall = new FunctionCall(decl, decl.startToken);\n\t\tfor(Argument arg: constructor.getArguments()) {\n\t\t\tinitCall.getArguments().add(new VariableAccess(arg, decl.startToken));\n\t\t}\n\t\tconstructor.getBody().add(new Line(new MemberCall(thisAccess, initCall, decl.startToken)));\n\t\tconstructor.getBody().add(new Line(new ValuedReturn(thisAccess, decl.startToken)));\n\t\t\n\t\taddFunction(constructor);\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tsuper.getVariables(variables);\n\t\tif(getSuperRef() != null) getSuperRef().getVariables(variables);\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tResponse response = super.resolve(stack, res, fatal);\n\t\tif(response != Response.OK) return response;\n\t\t\n\t\tif(isResolved()) return Response.OK;\n\n\t\tif(getSuperType() != null && !(super.getSuperRef() instanceof ClassDecl)) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Trying to extends a \"\n\t\t\t\t\t+getSuperRef().getClass().getSimpleName()+\". You can only extend classes.\");\n\t\t}\n\t\tif (getSuperType() != null) {\n\t\t\tif(getSuperRef() == null) {\n\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Super-type \"\n\t\t\t\t\t\t+getSuperType()+\" of class \"+getType()+\" couldn't be resolved\");\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\tif(defaultInit == null) {\n\t\t\t\tFunctionDecl superInit = getSuperRef().getFunction(\"init\", \"\", null);\n\t\t\t\tif(superInit != null && superInit == getSuperRef().defaultInit) {\n\t\t\t\t\taddDefaultInit();\n\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!hasRegisteredFinalizer) {\n\t\t\tFunctionDecl finalizer = getFunction(DESTROY_FUNC_NAME, null, null);\n\t\t\tif(finalizer != null && !finalizer.getBody().isEmpty()) {\n\t\t\t\tFunctionDecl defaults = getFunction(DEFAULTS_FUNC_NAME, null, null);\n\t\t\t\tFunctionCall call = new FunctionCall(\"gc_register_finalizer\", finalizer.startToken);\n\t\t\t\tNodeList<Expression> args = call.getArguments();\n\t\t\t\t/*\n\t\t\t\t * void GC_debug_register_finalizer (GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n\t\t  \t\t * GC_finalization_proc *ofn, GC_PTR *ocd);\n\t\t\t\t */\n\t\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", finalizer.startToken);\n\t\t\t\targs.add(thisAccess); // for object \"this\"\n\t\t\t\t\n\t\t\t\tVariableAccess destroyAccess = new MemberAccess(thisAccess, \"__destroy__\", finalizer.startToken);\n\t\t\t\targs.add(destroyAccess); // call the finalizer\n\t\t\t\t\n\t\t\t\tNullLiteral nil = new NullLiteral(finalizer.startToken);\n\t\t\t\targs.add(nil); // cd (no argument to apss)\n\t\t\t\targs.add(nil); // ofn (we don't care)\n\t\t\t\targs.add(nil); // ocd (we don't care)\n\t\t\t\t\n\t\t\t\tVersionBlock vBlock = new VersionBlock(new VersionName(\"gc\"), finalizer.startToken);\n\t\t\t\tvBlock.getBody().add(new Line(call));\n\t\t\t\tdefaults.getBody().add(0, new Line(vBlock));\n\t\t\t\t\n\t\t\t\thasRegisteredFinalizer = true;\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tpublic ClassDecl getBaseClass(FunctionDecl decl) {\n\t\tif(getSuperRef() != null) {\n\t\t\tClassDecl base = getSuperRef().getBaseClass(decl);\n\t\t\tif(base != null) return base;\n\t\t}\n\t\tif(getFunction(decl.getName(), decl.getSuffix(), null, false) != null) return this;\n\t\treturn null;\n\t}\n\t\n\tpublic boolean isChildOf(String candidate) {\n\t\tif(getName().equals(candidate)) return true;\n\t\tif(getSuperRef() != null) return getSuperRef().isChildOf(candidate);\n\t\treturn false;\n\t}\n\t\n}\n","lineNo":124}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected boolean dead = false;\n\t\n\tprotected boolean superCall;\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected Expression returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, Token startToken) {\n\t\tthis(name, null, startToken);\n\t}\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\t\n\tpublic boolean isSuperCall() {\n\t\treturn superCall;\n\t}\n\t\n\tpublic void setSuperCall(boolean superCall) {\n\t\tthis.superCall = superCall;\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic Expression getReturnArg() {\n\t\treturn returnArg;\n\t}\n\t\n\tpublic void setReturnArg(Expression returnArg) {\n\t\tthis.returnArg = returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\n\t\tType type = getRealType(typeArg, stack, res, true);\n\t\tif(type == null) {\n\t\t\ttype = typeArg.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t\tif(realType != null) realType.accept(visitor);\n\t\tif(returnArg != null) returnArg.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tResponse response = resolveRegular(stack, res, fatal);\n\t\t\t\tif(response != Response.OK) return response;\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"No such function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n \t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\n\t\tboolean andedSomearg = false;\n\t\tint argOffset = impl.hasThis() ? 1 : 0;\n\t\tfor(int j = 0; j < impl.getArguments().size() - argOffset; j++) {\n\t\t\tArgument implArg = impl.getArguments().get(j + argOffset);\n\t\t\t\n\t\t\tif(implArg instanceof VarArg) { continue; }\n            if(implArg.getType() == null || !implArg.getType().isResolved()) {\n                // need ref arg type, we'll do it later\n            \treturn Response.LOOP;\n            }\n            if(!(implArg.getType().isGeneric() &&\n                 implArg.getType().getPointerLevel() == 0 &&\n                 implArg.getType().getReferenceLevel() == 0)) { continue; }\n\t\t\t\n\t\t\tExpression callArg = arguments.get(j);\n\t\t\tif(callArg.getType() == null || !callArg.getType().isResolved()) {\n\t\t\t\t// need call arg type\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\t\n            if(!(callArg instanceof AddressOf) && !callArg.getType().isGeneric()) {\n            \targuments.set(j, new AddressOf(callArg, callArg.startToken));\n                andedSomearg = true;\n            }\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName(), res);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\t//return Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(!retType.isResolved()) {\n\t\t\t\t// should know if it's generic or not\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tif(debugCondition()) System.out.println(\"[KALAMAZOO] Realtypizing retType \"+retType);\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\tif(debugCondition()) System.out.println(\"[KALAMAZOO] Got candidate \"+candidate);\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Unwrap if needed */\n\t\t{\n\t\t\tResponse response = unwrapIfNeeded(stack);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\n\t\t/* Resolve returnArg */\n\t\tif(returnArg != null) {\n \t\t\tif(returnArg instanceof MustBeResolved && !((MustBeResolved) returnArg).isResolved()) {\n \t\t\t\t// need returnArg to be resolved\n \t\t\t\treturn Response.LOOP;\n \t\t\t}\n \t\t\tif(!(returnArg instanceof AddressOf)) {\n \t\t\t\treturnArg = returnArg.getGenericOperand();\n \t\t\t}\n        }\n\t\t\n\t\tif(andedSomearg) return Response.LOOP;\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate Response unwrapIfNeeded(final NodeList<Node> stack) {\n\t\tNode parent = stack.peek();\n        \n        if(impl == null || impl.getReturnType() == null) {\n            // need ref and refType\n            return Response.LOOP;\n        }\n        \n        Cast cast = null;\n        \n        int idx = 1;\n        while(parent instanceof Cast) {\n        \tcast = (Cast) parent;\n        \tidx += 1;\n            parent = stack.peek(idx);\n        }\n        \n\t\tif(impl.getReturnType().isGeneric() && !isFriendlyHost(parent)) {\n\t\t\tVariableDecl vDecl = new VariableDecl(getType(), generateTempName(\"genCall\", stack), startToken, stack.getModule());\n            stack.addBeforeLine(stack, vDecl);\n            VariableAccess varAcc = new VariableAccess(vDecl, startToken);\n            setReturnArg(varAcc);\n            \n            CommaSequence seq = new CommaSequence(startToken);\n            seq.getBody().add(this);\n            seq.getBody().add(cast != null ? new Cast(varAcc, cast.getType(), varAcc.startToken) : varAcc);\n            \n            stack.peek().replace(this, seq);\n            \n            // just unwrapped\n            return Response.LOOP;\n        }\n\t\t\n\t\treturn Response.OK;\n\t}\n\t\n\t/**\n\t * In some cases, a generic function call needs to be unwrapped,\n\t * e.g. when it's used as an expression in another call, etc.\n\t * However, some nodes are 'friendly' parents to us, e.g.\n\t * they handle things themselves and we don't need to unwrap.\n\t * @return true if the node is friendly, false if it is not and we\n\t * need to unwrap\n\t */\n    private boolean isFriendlyHost (Node node) {\n    \treturn  (node instanceof Line) ||\n\t\t\t\t(node instanceof CommaSequence) ||\n\t\t\t\t(node instanceof VariableDecl) ||\n\t\t\t\t(node instanceof Assignment);\n    }\n\n\tprotected final Type getRealType(Type typeArg, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tExpression realExpr = getRealExpr(typeArg.getName(), stack, res, fatal);\n\t\tif(realExpr == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif(realExpr instanceof VariableAccess && ((VariableAccess) realExpr).getName().equals(typeArg.getName())) {\n\t\t\treturn typeArg.clone();\n\t\t}\n\t\t\n\t\treturn realExpr instanceof TypeParam ? null : realExpr.getType();\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tif(debugCondition()) System.out.println(\"[getRealExpr] Should getRealExpr of \"+typeParam);\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\t\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\t\n\t\t\t// e.g. func <T> myFunc(T: Class), and arg = T\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = callArg;\n\t\t\t\tif(res.params.veryVerbose || debugCondition()) \n\t\t\t\t\tSystem.out.println(\"[getRealExpr] Matched <\"+typeParam+\"> with \"+result+\", argName-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(value: T), and arg = value.\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\t// not resolved yet?\n\t\t\t\tif(callArg.getType() == null) return null;\n\t\t\t\tType ourType = callArg.getType();\n\t\t\t\t// make it flat!\n\t\t\t\tif(!ourType.isFlat()) {\n\t\t\t\t\tourType = ourType.clone();\n\t\t\t\t\tourType.setPointerLevel(0);\n\t\t\t\t\tourType.setReferenceLevel(0);\n\t\t\t\t\tourType.setArray(false);\n\t\t\t\t}\n\t\t\t\tTypeAccess typeAcc = new TypeAccess(ourType, callArg.startToken);\n\t\t\t\ttypeAcc.resolve(stack, res, fatal);\n\t\t\t\tresult = typeAcc;\n\t\t\t\tif(res.params.veryVerbose || debugCondition())\n\t\t\t\t\tSystem.out.println(\"[getRealExpr] Matched <\"+typeParam+\"> with \"+result+\", varAccType-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(list: List<T>)\n\t\t\tif(arg.getType().isGenericRecursive()) {\n\t\t\t\tif(res.params.veryVerbose || debugCondition())\n\t\t\t\t\tSystem.out.println(\"[getRealExpr] \"+arg.getType()+\" is generic-recursive, trying to get <\"+typeParam+\"> in it.\");\n\t\t\t\tresult = searchTypeParam(typeParam, callArg.getType(), stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\t\tSystem.out.println(\"[getRealExpr] Matched <\"+typeParam+\"> with \"+result+\", genericRecursive-wise\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\t/**\n\t * Search for the type param @needle in the type @haystack\n\t */\n\tprivate Expression searchTypeParam(String needle, Type haystack,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(debugCondition()) System.out.println(\"[searchTypeParam] Looking for typeParam \"+needle+\" in type \"+haystack);\n\t\t\n\t\tDeclaration ref = haystack.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(needle)) {\n\t\t\t\t\tif(debugCondition()) System.out.println(\"[searchTypeParam] Found the needle \"+needle+\" in type \"+haystack+\", in typeDecl \"+typeDecl);\n\t\t\t\t\tType realType = getRealType(haystack, stack, res, fatal);\n\t\t\t\t\tif(realType != null && i < realType.getTypeParams().size()) {\n\t\t\t\t\t\treturn realType.getTypeParams().get(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\t\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t\tif(debugCondition()) System.out.println(\"[getExprParam] callArg type name is 'Class'\");\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t\tif(debugCondition()) System.out.println(\"[getExprParam] callArg type is generic\");\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t\tif(debugCondition()) System.out.println(\"[getExprParam] callArg-normal\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(debugCondition()) System.out.println(\"Found exprParam \"+result+\" for typeParam \"+typeParam+\" in \"+this);\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\t// used to determine if debug messages should be printed (usually comparing a name)\n\tprivate boolean debugCondition() {\n\t\treturn name.equals(\"iterator\");\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())\n\t\t\t\t\t&& implArg.getType().getRef() != null\n\t\t\t\t\t&& callArg.getType().getRef() != null) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getGlobalImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix == null || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected Response resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getGlobalImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\t// copy the module information for getFullName if it's global.\n\t\t\t\t\t\t\tif(varDecl.isGlobal())\n\t\t\t\t\t\t\t\timpl.module = varDecl.module;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack, null);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t// copy the module information for getFullName if it's global.\n\t\t\t\t\t\tif(varDecl.isGlobal())\n\t\t\t\t\t\t\timpl.module = varDecl.module;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return Response.OK;\n\t\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) {\n\t\t\t\tturnIntoMemberCall(stack, res);\n\t\t\t\t//return Response.RESTART;\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate void turnIntoMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tmemberCall.setSuperCall(superCall);\n\t\tstack.peek().replace(this, memberCall);\n\t\tthis.dead = true;\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix == null || suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t\tif(declArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\tscore += 5;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName, Resolver res) {\n\t\n\t\tif(res.params.veryVerbose) {\n\t\t\tThread.dumpStack();\n\t\t}\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+getProtoRepr());\n\t\t\n\t}\n\n\tpublic String getFullName() {\n\t\tif(impl.module != null)\n\t\t\treturn impl.module.getMemberPrefix() + getName();\n\t\treturn getName();\n\t}\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected boolean dead = false;\n\t\n\tprotected boolean superCall;\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected Expression returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, Token startToken) {\n\t\tthis(name, null, startToken);\n\t}\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\t\n\tpublic boolean isSuperCall() {\n\t\treturn superCall;\n\t}\n\t\n\tpublic void setSuperCall(boolean superCall) {\n\t\tthis.superCall = superCall;\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic Expression getReturnArg() {\n\t\treturn returnArg;\n\t}\n\t\n\tpublic void setReturnArg(Expression returnArg) {\n\t\tthis.returnArg = returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\n\t\tType type = getRealType(typeArg, stack, res, true);\n\t\tif(type == null) {\n\t\t\ttype = typeArg.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t\tif(realType != null) realType.accept(visitor);\n\t\tif(returnArg != null) returnArg.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tResponse response = resolveRegular(stack, res, fatal);\n\t\t\t\tif(response != Response.OK) return response;\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast(stack, res);\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"No such function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n \t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\n\t\tboolean andedSomearg = false;\n\t\tint argOffset = impl.hasThis() ? 1 : 0;\n\t\tfor(int j = 0; j < impl.getArguments().size() - argOffset; j++) {\n\t\t\tArgument implArg = impl.getArguments().get(j + argOffset);\n\t\t\t\n\t\t\tif(implArg instanceof VarArg) { continue; }\n            if(implArg.getType() == null || !implArg.getType().isResolved()) {\n                // need ref arg type, we'll do it later\n            \treturn Response.LOOP;\n            }\n            if(!(implArg.getType().isGeneric() &&\n                 implArg.getType().getPointerLevel() == 0 &&\n                 implArg.getType().getReferenceLevel() == 0)) { continue; }\n\t\t\t\n\t\t\tExpression callArg = arguments.get(j);\n\t\t\tif(callArg.getType() == null || !callArg.getType().isResolved()) {\n\t\t\t\t// need call arg type\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\t\n            if(!(callArg instanceof AddressOf) && !callArg.getType().isGeneric()) {\n            \targuments.set(j, new AddressOf(callArg, callArg.startToken));\n                andedSomearg = true;\n            }\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName(), res);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\t//return Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(!retType.isResolved()) {\n\t\t\t\t// should know if it's generic or not\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tif(debugCondition()) System.out.println(\"[KALAMAZOO] Realtypizing retType \"+retType+\" for impl \"+impl);\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\tif(debugCondition()) System.out.println(\"[KALAMAZOO] Got candidate \"+candidate);\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Unwrap if needed */\n\t\t{\n\t\t\tResponse response = unwrapIfNeeded(stack);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\n\t\t/* Resolve returnArg */\n\t\tif(returnArg != null) {\n \t\t\tif(returnArg instanceof MustBeResolved && !((MustBeResolved) returnArg).isResolved()) {\n \t\t\t\t// need returnArg to be resolved\n \t\t\t\treturn Response.LOOP;\n \t\t\t}\n \t\t\tif(!(returnArg instanceof AddressOf)) {\n \t\t\t\treturnArg = returnArg.getGenericOperand();\n \t\t\t}\n        }\n\t\t\n\t\tif(andedSomearg) return Response.LOOP;\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate Response unwrapIfNeeded(final NodeList<Node> stack) {\n\t\tNode parent = stack.peek();\n        \n        if(impl == null || impl.getReturnType() == null) {\n            // need ref and refType\n            return Response.LOOP;\n        }\n        \n        Cast cast = null;\n        \n        int idx = 1;\n        while(parent instanceof Cast) {\n        \tcast = (Cast) parent;\n        \tidx += 1;\n            parent = stack.peek(idx);\n        }\n        \n\t\tif(impl.getReturnType().isGeneric() && !isFriendlyHost(parent)) {\n\t\t\tVariableDecl vDecl = new VariableDecl(getType(), generateTempName(\"genCall\", stack), startToken, stack.getModule());\n            stack.addBeforeLine(stack, vDecl);\n            VariableAccess varAcc = new VariableAccess(vDecl, startToken);\n            setReturnArg(varAcc);\n            \n            CommaSequence seq = new CommaSequence(startToken);\n            seq.getBody().add(this);\n            seq.getBody().add(cast != null ? new Cast(varAcc, cast.getType(), varAcc.startToken) : varAcc);\n            \n            stack.peek().replace(this, seq);\n            \n            // just unwrapped\n            return Response.LOOP;\n        }\n\t\t\n\t\treturn Response.OK;\n\t}\n\t\n\t/**\n\t * In some cases, a generic function call needs to be unwrapped,\n\t * e.g. when it's used as an expression in another call, etc.\n\t * However, some nodes are 'friendly' parents to us, e.g.\n\t * they handle things themselves and we don't need to unwrap.\n\t * @return true if the node is friendly, false if it is not and we\n\t * need to unwrap\n\t */\n    private boolean isFriendlyHost (Node node) {\n    \treturn  (node instanceof Line) ||\n\t\t\t\t(node instanceof CommaSequence) ||\n\t\t\t\t(node instanceof VariableDecl) ||\n\t\t\t\t(node instanceof Assignment);\n    }\n\n\tprotected final Type getRealType(Type typeArg, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tExpression realExpr = getRealExpr(typeArg.getName(), stack, res, fatal);\n\t\tif(realExpr == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif(realExpr instanceof VariableAccess && ((VariableAccess) realExpr).getName().equals(typeArg.getName())) {\n\t\t\treturn typeArg.clone();\n\t\t}\n\t\t\n\t\treturn realExpr instanceof TypeParam ? null : realExpr.getType();\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tif(debugCondition()) System.out.println(\"[getRealExpr] Should getRealExpr of \"+typeParam);\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\t\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\t\n\t\t\t// e.g. func <T> myFunc(T: Class), and arg = T\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = callArg;\n\t\t\t\tif(res.params.veryVerbose || debugCondition()) \n\t\t\t\t\tSystem.out.println(\"[getRealExpr] Matched <\"+typeParam+\"> with \"+result+\", argName-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(value: T), and arg = value.\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\t// not resolved yet?\n\t\t\t\tif(callArg.getType() == null) return null;\n\t\t\t\tType ourType = callArg.getType();\n\t\t\t\t// make it flat!\n\t\t\t\tif(!ourType.isFlat()) {\n\t\t\t\t\tourType = ourType.clone();\n\t\t\t\t\tourType.setPointerLevel(0);\n\t\t\t\t\tourType.setReferenceLevel(0);\n\t\t\t\t\tourType.setArray(false);\n\t\t\t\t}\n\t\t\t\tTypeAccess typeAcc = new TypeAccess(ourType, callArg.startToken);\n\t\t\t\ttypeAcc.resolve(stack, res, fatal);\n\t\t\t\tresult = typeAcc;\n\t\t\t\tif(res.params.veryVerbose || debugCondition())\n\t\t\t\t\tSystem.out.println(\"[getRealExpr] Matched <\"+typeParam+\"> with \"+result+\", varAccType-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(list: List<T>)\n\t\t\tif(arg.getType().isGenericRecursive()) {\n\t\t\t\tif(res.params.veryVerbose || debugCondition())\n\t\t\t\t\tSystem.out.println(\"[getRealExpr] \"+arg.getType()+\" is generic-recursive, trying to get <\"+typeParam+\"> in it.\");\n\t\t\t\tresult = searchTypeParam(typeParam, callArg.getType(), stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\t\tSystem.out.println(\"[getRealExpr] Matched <\"+typeParam+\"> with \"+result+\", genericRecursive-wise\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\t/**\n\t * Search for the type param @needle in the type @haystack\n\t */\n\tprivate Expression searchTypeParam(String needle, Type haystack,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(debugCondition()) System.out.println(\"[searchTypeParam] Looking for typeParam \"+needle+\" in type \"+haystack);\n\t\t\n\t\tDeclaration ref = haystack.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(needle)) {\n\t\t\t\t\tif(debugCondition()) System.out.println(\"[searchTypeParam] Found the needle \"+needle+\" in type \"+haystack+\", in typeDecl \"+typeDecl);\n\t\t\t\t\tType realType = getRealType(haystack, stack, res, fatal);\n\t\t\t\t\tif(realType != null && i < realType.getTypeParams().size()) {\n\t\t\t\t\t\treturn realType.getTypeParams().get(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\t\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t\tif(debugCondition()) System.out.println(\"[getExprParam] callArg type name is 'Class'\");\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t\tif(debugCondition()) System.out.println(\"[getExprParam] callArg type is generic\");\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t\tif(debugCondition()) System.out.println(\"[getExprParam] callArg-normal\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(debugCondition()) System.out.println(\"Found exprParam \"+result+\" for typeParam \"+typeParam+\" in \"+this);\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\t// used to determine if debug messages should be printed (usually comparing a name)\n\tprivate boolean debugCondition() {\n\t\treturn name.equals(\"iterator\");\n\t}\n\n\tprotected void autocast(NodeList<Node> stack, Resolver res) {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())\n\t\t\t\t\t&& implArg.getType().getRef() != null\n\t\t\t\t\t&& callArg.getType().getRef() != null) {\n\t\t\t\t\n\t\t\t\tType targetType = implArg.getType();\n\t\t\t\tif(!callArg.getType().getTypeParams().isEmpty()) {\n\t\t\t\t\ttargetType = targetType.clone();\n\t\t\t\t\ttargetType.getTypeParams().clear();\n\t\t\t\t\ttargetType.getTypeParams().addAll(callArg.getType().getTypeParams());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\targuments.replace(callArg, new Cast(callArg, targetType, callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getGlobalImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix == null || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected Response resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getGlobalImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\t// copy the module information for getFullName if it's global.\n\t\t\t\t\t\t\tif(varDecl.isGlobal())\n\t\t\t\t\t\t\t\timpl.module = varDecl.module;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack, null);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t// copy the module information for getFullName if it's global.\n\t\t\t\t\t\tif(varDecl.isGlobal())\n\t\t\t\t\t\t\timpl.module = varDecl.module;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return Response.OK;\n\t\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) {\n\t\t\t\tturnIntoMemberCall(stack, res);\n\t\t\t\t//return Response.RESTART;\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate void turnIntoMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tmemberCall.setSuperCall(superCall);\n\t\tstack.peek().replace(this, memberCall);\n\t\tthis.dead = true;\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix == null || suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t\tif(declArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\tscore += 5;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName, Resolver res) {\n\t\n\t\tif(res.params.veryVerbose) {\n\t\t\tThread.dumpStack();\n\t\t}\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+getProtoRepr());\n\t\t\n\t}\n\n\tpublic String getFullName() {\n\t\tif(impl.module != null)\n\t\t\treturn impl.module.getMemberPrefix() + getName();\n\t\treturn getName();\n\t}\n}\n","lineNo":487}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Assignment extends BinaryOperation {\n\n\tprotected boolean dead = false;\n\t\n\tpublic static enum Mode {\n\t\tREGULAR,\n\t\tADD,\n\t\tSUB,\n\t\tDIV,\n\t\tMUL,\n\t\tB_XOR,\n\t\tB_OR,\n\t\tB_AND,\n\t\tB_LSHIFT,\n\t\tB_RSHIFT,\n\t}\n\t\n\tprotected Mode mode;\n\t\n\tpublic Assignment(Expression left, Expression right, Token startToken) {\n\t\tthis(Mode.REGULAR, left, right, startToken);\n\t}\n\t\n\tpublic Assignment(Mode mode, Expression lvalue, Expression rvalue, Token startToken) {\n\t\tsuper(lvalue, rvalue, startToken);\n\t\tthis.mode = mode;\n\t\tthis.left = lvalue;\n\t\tthis.right = rvalue;\n\t}\n\t\n\tpublic Mode getMode() {\n\t\treturn mode;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\treturn left.getType();\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tleft.accept(visitor);\n\t\tright.accept(visitor);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == left) {\n\t\t\tleft = (Access) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\tif(oldie == right) {\n\t\t\tright = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String getSymbol() {\n\t\tswitch(mode) {\n\t\t\tcase ADD:\n\t\t\t\treturn \"+=\";\n\t\t\tcase DIV:\n\t\t\t\treturn \"/=\";\n\t\t\tcase MUL:\n\t\t\t\treturn \"*=\";\n\t\t\tcase SUB:\n\t\t\t\treturn \"-=\";\n\t\t\tcase B_AND:\n\t\t\t\treturn \"&=\";\n\t\t\tcase B_LSHIFT:\n\t\t\t\treturn \"<<=\";\n\t\t\tcase B_OR:\n\t\t\t\treturn \"|=\";\n\t\t\tcase B_RSHIFT:\n\t\t\t\treturn \">>=\";\n\t\t\tcase B_XOR:\n\t\t\t\treturn \"^=\";\n\t\t\tcase REGULAR:\n\t\t\t\treturn \"=\";\n\t\t}\n\t\treturn \"unknown\";\n\t}\n\n\t@Override\n\tpublic OpType getOpType() {\n\t\tswitch(mode) {\n\t\tcase ADD:\n\t\t\treturn OpType.ADD_ASS;\n\t\tcase DIV:\n\t\t\treturn OpType.DIV_ASS;\n\t\tcase MUL:\n\t\t\treturn OpType.MUL_ASS;\n\t\tcase SUB:\n\t\t\treturn OpType.SUB_ASS;\n\t\tcase B_XOR:\n\t\t\treturn OpType.B_XOR_ASS;\n\t\tcase B_OR:\n\t\t\treturn OpType.B_OR_ASS;\n\t\tcase B_AND:\n\t\t\treturn OpType.B_AND_ASS;\n\t\tcase B_LSHIFT:\n\t\t\treturn OpType.B_LSHIFT_ASS;\n\t\tcase B_RSHIFT:\n\t\t\treturn OpType.B_RSHIFT_ASS;\n\t\tcase REGULAR:\n\t\t\treturn OpType.ASS;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Assignment: \"+left.toString()+\" = \"+right.toString();\n\t}\n\t\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\t// if the parent is not a line\n\t\t// or the parent is not (a for of which we are not the test)\n\t\t// then it's illegal to use an assignment as an expression\n\t\tif(!(stack.peek() instanceof Line) && !(stack.peek() instanceof For && ((For) stack.peek()).getTest() != this)) {\n\t\t\tthrow new OocCompilationError(this, stack,\n\t\t\t\t\t\"It's illegal to use an assignment as an expression (here, in a \"\n\t\t\t\t\t+stack.peek().getClass().getSimpleName()+\") Did you mean '==' ?\");\n\t\t}\n\t\t\n\t\tif(left.getType() == null || !left.getType().isResolved()) {\n\t\t\tif(fatal) throw new OocCompilationError(left, stack, \"Left type of assignment unresolved: \"+left+\" (btw, stack = \"+stack.toString(true));\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tif(right.getType() == null || !left.getType().isResolved()) {\n\t\t\tif(fatal) throw new OocCompilationError(right, stack, \"Right type of assignment unresolved: \"+right);\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t/*\n\t\tif(left.getType().isSuperOf(right.getType())) {\n\t\t\tright = new Cast(right, left.getType(), right.startToken);\n\t\t}\n\t\t*/\n\t\t\n\t\t// if we're an assignment from a generic return value\n        // we need to set the returnArg to left and disappear! =)\n        if(right instanceof FunctionCall) {\n            FunctionCall fCall = (FunctionCall) right;\n            FunctionDecl fDecl = fCall.getImpl();\n            if(fDecl == null || !fDecl.getReturnType().isResolved()) {\n            \tif(res.fatal) {\n            \t\tthrow new OocCompilationError(this, stack, \"Need more info on fDecl\");\n            \t}\n            \treturn Response.LOOP;\n            }\n            \n            if(fDecl.getReturnType().isGeneric()) {\n            \tfCall.setReturnArg(left.getGenericOperand());\n                stack.peek().replace(this, fCall);\n                if(res.fatal) {\n            \t\tthrow new OocCompilationError(this, stack, \"Just replaced ourselves with fCall, need to restart\");\n            \t}\n            \treturn Response.LOOP;\n            }\n        }\n        \n        if(isGeneric()) {\n        \tMemberAccess sizeAcc = new MemberAccess(new VariableAccess(left.getType().getName(), startToken), \"size\", startToken);\n            \n        \tFunctionCall fCall = new FunctionCall(\"memcpy\", startToken);\n            fCall.getArguments().add(left. getGenericOperand());\n            fCall.getArguments().add(right.getGenericOperand());\n            fCall.getArguments().add(sizeAcc);\n            boolean result = stack.peek().replace(this, fCall);\n            \n            if(!result) {\n                if(res.fatal) throw new OocCompilationError(this, stack, \"Couldn't replace ourselves (\"+this\n                \t\t+\") with a memcpy/assignment in a \"+stack.peek().getClass().getName()+\"! trail = \" +stack.toString(true));\n            }\n            \n            // Replaced ourselves, need to tidy up\n            return Response.LOOP;\n        }\n\t\t\n\t\treturn super.resolve(stack, res, fatal);\n\t\t\n\t}\n\t\n\tprivate boolean isGeneric() {\n        return (left. getType().isGeneric() && left. getType().getPointerLevel() == 0) ||\n        \t   (right.getType().isGeneric() && right.getType().getPointerLevel() == 0);\n    }\n\n\t@Override\n\tpublic int getPriority() {\n\t\treturn 120;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Assignment extends BinaryOperation {\n\n\tprotected boolean dead = false;\n\t\n\tpublic static enum Mode {\n\t\tREGULAR,\n\t\tADD,\n\t\tSUB,\n\t\tDIV,\n\t\tMUL,\n\t\tB_XOR,\n\t\tB_OR,\n\t\tB_AND,\n\t\tB_LSHIFT,\n\t\tB_RSHIFT,\n\t}\n\t\n\tprotected Mode mode;\n\t\n\tpublic Assignment(Expression left, Expression right, Token startToken) {\n\t\tthis(Mode.REGULAR, left, right, startToken);\n\t}\n\t\n\tpublic Assignment(Mode mode, Expression lvalue, Expression rvalue, Token startToken) {\n\t\tsuper(lvalue, rvalue, startToken);\n\t\tthis.mode = mode;\n\t\tthis.left = lvalue;\n\t\tthis.right = rvalue;\n\t}\n\t\n\tpublic Mode getMode() {\n\t\treturn mode;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\treturn left.getType();\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tleft.accept(visitor);\n\t\tright.accept(visitor);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == left) {\n\t\t\tleft = (Access) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\tif(oldie == right) {\n\t\t\tright = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String getSymbol() {\n\t\tswitch(mode) {\n\t\t\tcase ADD:\n\t\t\t\treturn \"+=\";\n\t\t\tcase DIV:\n\t\t\t\treturn \"/=\";\n\t\t\tcase MUL:\n\t\t\t\treturn \"*=\";\n\t\t\tcase SUB:\n\t\t\t\treturn \"-=\";\n\t\t\tcase B_AND:\n\t\t\t\treturn \"&=\";\n\t\t\tcase B_LSHIFT:\n\t\t\t\treturn \"<<=\";\n\t\t\tcase B_OR:\n\t\t\t\treturn \"|=\";\n\t\t\tcase B_RSHIFT:\n\t\t\t\treturn \">>=\";\n\t\t\tcase B_XOR:\n\t\t\t\treturn \"^=\";\n\t\t\tcase REGULAR:\n\t\t\t\treturn \"=\";\n\t\t}\n\t\treturn \"unknown\";\n\t}\n\n\t@Override\n\tpublic OpType getOpType() {\n\t\tswitch(mode) {\n\t\tcase ADD:\n\t\t\treturn OpType.ADD_ASS;\n\t\tcase DIV:\n\t\t\treturn OpType.DIV_ASS;\n\t\tcase MUL:\n\t\t\treturn OpType.MUL_ASS;\n\t\tcase SUB:\n\t\t\treturn OpType.SUB_ASS;\n\t\tcase B_XOR:\n\t\t\treturn OpType.B_XOR_ASS;\n\t\tcase B_OR:\n\t\t\treturn OpType.B_OR_ASS;\n\t\tcase B_AND:\n\t\t\treturn OpType.B_AND_ASS;\n\t\tcase B_LSHIFT:\n\t\t\treturn OpType.B_LSHIFT_ASS;\n\t\tcase B_RSHIFT:\n\t\t\treturn OpType.B_RSHIFT_ASS;\n\t\tcase REGULAR:\n\t\t\treturn OpType.ASS;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Assignment: \"+left.toString()+\" = \"+right.toString();\n\t}\n\t\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\t// if the parent is not a line\n\t\t// or the parent is not (a for of which we are not the test)\n\t\t// then it's illegal to use an assignment as an expression\n\t\tif(!(stack.peek() instanceof Line) && !(stack.peek() instanceof For && ((For) stack.peek()).getTest() != this)) {\n\t\t\tthrow new OocCompilationError(this, stack,\n\t\t\t\t\t\"It's illegal to use an assignment as an expression (here, in a \"\n\t\t\t\t\t+stack.peek().getClass().getSimpleName()+\") Did you mean '==' ?\");\n\t\t}\n\t\t\n\t\tif(left.getType() == null || !left.getType().isResolved()) {\n\t\t\tif(fatal) throw new OocCompilationError(left, stack, \"Left type of assignment unresolved: \"+left+\" (btw, stack = \"+stack.toString(true));\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tif(right.getType() == null || !left.getType().isResolved()) {\n\t\t\tif(fatal) throw new OocCompilationError(right, stack, \"Right type of assignment unresolved: \"+right);\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t/*\n\t\tif(left.getType().isSuperOf(right.getType())) {\n\t\t\tright = new Cast(right, left.getType(), right.startToken);\n\t\t}\n\t\t*/\n\t\t\n\t\t// if we're an assignment from a generic return value\n        // we need to set the returnArg to left and disappear! =)\n\t\tExpression realRight = right;\n\t\tif(realRight instanceof Cast) {\n\t\t\trealRight = ((Cast) realRight).inner;\n\t\t}\n\t\t\n        if(realRight instanceof FunctionCall) {\n            FunctionCall fCall = (FunctionCall) realRight;\n            FunctionDecl fDecl = fCall.getImpl();\n            if(fDecl == null || !fDecl.getReturnType().isResolved()) {\n            \tif(res.fatal) {\n            \t\tthrow new OocCompilationError(this, stack, \"Need more info on fDecl\");\n            \t}\n            \treturn Response.LOOP;\n            }\n            \n            if(fDecl.getReturnType().isGeneric()) {\n            \tfCall.setReturnArg(left.getGenericOperand());\n                stack.peek().replace(this, fCall);\n                if(res.fatal) {\n            \t\tthrow new OocCompilationError(this, stack, \"Just replaced ourselves with fCall, need to restart\");\n            \t}\n            \treturn Response.LOOP;\n            }\n        }\n        \n        if(isGeneric()) {\n        \tMemberAccess sizeAcc = new MemberAccess(new VariableAccess(left.getType().getName(), startToken), \"size\", startToken);\n            \n        \tFunctionCall fCall = new FunctionCall(\"memcpy\", startToken);\n            fCall.getArguments().add(left. getGenericOperand());\n            fCall.getArguments().add(right.getGenericOperand());\n            fCall.getArguments().add(sizeAcc);\n            boolean result = stack.peek().replace(this, fCall);\n            \n            if(!result) {\n                if(res.fatal) throw new OocCompilationError(this, stack, \"Couldn't replace ourselves (\"+this\n                \t\t+\") with a memcpy/assignment in a \"+stack.peek().getClass().getName()+\"! trail = \" +stack.toString(true));\n            }\n            \n            // Replaced ourselves, need to tidy up\n            return Response.LOOP;\n        }\n\t\t\n\t\treturn super.resolve(stack, res, fatal);\n\t\t\n\t}\n\t\n\tprivate boolean isGeneric() {\n        return (left. getType().isGeneric() && left. getType().getPointerLevel() == 0) ||\n        \t   (right.getType().isGeneric() && right.getType().getPointerLevel() == 0);\n    }\n\n\t@Override\n\tpublic int getPriority() {\n\t\treturn 120;\n\t}\n\t\n}\n","lineNo":168}
{"Smelly Sample":"package org.ooc.frontend.parser;\n\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.BinaryNegation;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.Declaration;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.Literal;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.Assignment.Mode;\nimport org.ooc.frontend.model.BinaryCombination.BinaryComp;\nimport org.ooc.frontend.model.Compare.CompareType;\nimport org.ooc.frontend.model.IntLiteral.Format;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class ExpressionParser {\n\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader) {\n\t\treturn parse(module, sReader, reader, false);\n\t}\n\t\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tToken firstToken = reader.peek();\n\t\tif(firstToken.type == TokenType.BANG) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Not(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.TILDE) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new BinaryNegation(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.MINUS) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Sub(new IntLiteral(0, Format.DEC, firstToken), inner, firstToken);\n\t\t}\n\t\t\n\t\tExpression expr = null;\n\t\tif(reader.peek().type == TokenType.OPEN_PAREN) {\n\t\t\treader.skip();\n\t\t\treader.skipWhitespace();\n\t\t\texpr = parse(module, sReader, reader, noDecl);\n\t\t\texpr = new Parenthesis(expr, expr.startToken);\n\t\t\treader.skipWhitespace();\n\t\t\tif(reader.read().type != TokenType.CLOS_PAREN) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev())\n\t\t\t\t\t\t, \"Expected closing parenthesis, but got \"+reader.prev());\n\t\t\t}\n\t\t} else {\n\t\t\texpr = parseFlatNoparen(module, sReader, reader, noDecl);\n\t\t}\n\t\t\n\t\tif(expr == null) return null;\n\t\t\n\t\twhile(reader.hasNext()) {\n\t\t\t\n\t\t\tToken token = reader.peek();\n\t\t\t\n\t\t\tif(token.isNameToken()) {\n\t\t\t\tFunctionCall call = FunctionCallParser.parse(module, sReader, reader);\n\t\t\t\tif(call != null) {\n\t\t\t\t\texpr = new MemberCall(expr, call, token);\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tVariableAccess varAccess = AccessParser.parse(module, sReader, reader);\n\t\t\t\tif(varAccess != null) {\n\t\t\t\t\texpr = new MemberAccess(expr, varAccess, token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.DOUBLE_DOT) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression upper = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(upper == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\t\"Expected expression for the upper part of a range literal\");\n\t\t\t\t}\n\t\t\t\t// this is so beautiful it makes me wanna cry\n\t\t\t\texpr = new RangeLiteral(expr, upper, expr.startToken);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.OPEN_SQUAR) {\n\n\t\t\t\tArrayAccess arrAcc = new ArrayAccess(expr, token);\n\t\t\t\texpr = arrAcc;\n\t\t\t\treader.skip();\n\t\t\t\t\n\t\t\t\twhile(reader.peekWhiteless().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tExpression index = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\t\tif(index == null) {\n\t\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression for the index of an array access\");\n\t\t\t\t\t}\n\t\t\t\t\tarrAcc.getIndices().add(index);\n\t\t\t\t\t\n\t\t\t\t\tif(reader.peekWhiteless().type != TokenType.COMMA) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(reader.read().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\"Expected closing bracket to end array access, got \"+reader.prev()+\" instead.\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(rvalue == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression after '='.\");\n\t\t\t\t}\n\t\t\t\tif(!(expr instanceof Access)) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Attempting to assign to a constant, e.g. \"+expr);\n\t\t\t\t}\n\t\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\texpr = new Assignment(expr, rvalue, token);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AMPERSAND) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new AddressOf(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.QUEST) {\n\t\t\t\treader.skip();\n\t\t\t\tExpression ifTrue = parse(module, sReader, reader, true);\n\t\t\t\tif(reader.read().type != TokenType.COLON) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected ':' after '?', but got \"+reader.prev());\n\t\t\t\t}\n\t\t\t\tExpression ifFalse = parse(module, sReader, reader, true);\n\t\t\t\texpr = new Ternary(expr.startToken, expr, ifTrue, ifFalse);\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AT) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new Dereference(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t/** Must find a way to clean that up */\n\t\t\tif(token.type == TokenType.PLUS || token.type == TokenType.STAR\n\t\t\t\t\t|| token.type == TokenType.MINUS || token.type == TokenType.SLASH\n\t\t\t\t\t|| token.type == TokenType.PERCENT || token.type == TokenType.GREATERTHAN\n\t\t\t\t\t|| token.type == TokenType.LESSTHAN || token.type == TokenType.GREATERTHAN_EQUALS\n\t\t\t\t\t|| token.type == TokenType.LESSTHAN_EQUALS || token.type == TokenType.EQUALS\n\t\t\t\t\t|| token.type == TokenType.LSHIFT || token.type == TokenType.LSHIFT_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.RSHIFT || token.type == TokenType.RSHIFT_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.NOT_EQUALS || token.type == TokenType.PLUS_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.MINUS_ASSIGN || token.type == TokenType.STAR_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.SLASH_ASSIGN || token.type == TokenType.DOUBLE_PIPE\n\t\t\t\t\t|| token.type == TokenType.DOUBLE_AMPERSAND || token.type == TokenType.PIPE\n\t\t\t\t\t|| token.type == TokenType.AMPERSAND || token.type == TokenType.BINARY_AND\n\t\t\t\t\t|| token.type == TokenType.CARET) {\n\n\t\t\t\treader.skip();\n\t\t\t\treader.skipWhitespace();\n\t\t\t\t\n\t\t\t\tboolean isAssign = false;\n\t\t\t\t\n\t\t\t\tif(reader.peek().type == TokenType.ASSIGN) {\n\t\t\t\t\tisAssign = true;\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\n\t\t\t\treader.skipWhitespace();\n\t\t\t\t\n\t\t\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(rvalue == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected rvalue after binary operator\");\n\t\t\t\t}\n\t\t\t\tswitch(token.type) {\n\t\t\t\t\tcase TokenType.PLUS: \n\t\t\t\t\t\texpr = new Add(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR: \n\t\t\t\t\t\texpr = new Mul(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS:\n\t\t\t\t\t\texpr = new Sub(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH:\n\t\t\t\t\t\texpr = new Div(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PERCENT:\n\t\t\t\t\t\texpr = new Mod(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.GREATERTHAN:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER, token); break;\n\t\t\t\t\tcase TokenType.GREATERTHAN_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER_OR_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.LESSTHAN:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER, token); break;\n\t\t\t\t\tcase TokenType.LESSTHAN_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER_OR_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.EQUAL, token); break;\n\t\t\t\t\tcase TokenType.NOT_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.NOT_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.PLUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.ADD, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.SUB, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.MUL, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.DIV, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PIPE:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_OR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_OR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.AMPERSAND:\n\t\t\t\t\tcase TokenType.BINARY_AND:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_AND, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_PIPE: \n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_OR,  expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_AMPERSAND:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.CARET:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_XOR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_XOR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.LSHIFT:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.RSHIFT:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.LSHIFT_ASSIGN:\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.RSHIFT_ASSIGN:\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token); break;\n\t\t\t\t\tdefault: throw new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Unknown binary operation yet \"+token.type);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AS_KW) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tType type = TypeParser.parse(module, sReader, reader);\n\t\t\t\tif(type == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected destination type after 'as' keyword (e.g. for casting)\");\n\t\t\t\t}\n\t\t\t\texpr = new Cast(expr, type, token);\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn expr;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected static void ensureAccess(Expression expr) {\n\n\t\tif(!(expr instanceof Access)) {\n\t\t\tthrow new CompilationFailedError(null, \"Trying to assign to a constant :/\");\n\t\t}\n\t\t\n\t}\n\t\n\tprotected static Expression parseFlatNoparen(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tLiteral literal = LiteralParser.parse(module, sReader, reader);\n\t\tif(literal != null) return literal;\n\n\t\tFunctionCall funcCall = FunctionCallParser.parse(module, sReader, reader);\n\t\tif(funcCall != null) return funcCall;\n\t\t\n\t\tif(!noDecl) {\n\t\t\tDeclaration declaration = DeclarationParser.parse(module, sReader, reader);\n\t\t\tif(declaration != null) return declaration;\n\t\t}\n\t\t\t\t\n\t\tAccess access = AccessParser.parse(module, sReader, reader);\n\t\tif(access != null) return access;\n\t\t\n\t\tMatch match = MatchParser.parse(module, sReader, reader);\n\t\tif(match != null) return match;\n\t\t\n\t\treader.reset(mark);\n\t\treturn null;\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.parser;\n\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.BinaryNegation;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.Declaration;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.Literal;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.Assignment.Mode;\nimport org.ooc.frontend.model.BinaryCombination.BinaryComp;\nimport org.ooc.frontend.model.Compare.CompareType;\nimport org.ooc.frontend.model.IntLiteral.Format;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class ExpressionParser {\n\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader) {\n\t\treturn parse(module, sReader, reader, false);\n\t}\n\t\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tToken firstToken = reader.peek();\n\t\tif(firstToken.type == TokenType.BANG) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Not(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.TILDE) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new BinaryNegation(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.MINUS) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Sub(new IntLiteral(0, Format.DEC, firstToken), inner, firstToken);\n\t\t}\n\t\t\n\t\tExpression expr = null;\n\t\tif(reader.peek().type == TokenType.OPEN_PAREN) {\n\t\t\treader.skip();\n\t\t\treader.skipWhitespace();\n\t\t\texpr = parse(module, sReader, reader, noDecl);\n\t\t\texpr = new Parenthesis(expr, expr.startToken);\n\t\t\treader.skipWhitespace();\n\t\t\tif(reader.read().type != TokenType.CLOS_PAREN) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev())\n\t\t\t\t\t\t, \"Expected closing parenthesis, but got \"+reader.prev());\n\t\t\t}\n\t\t} else {\n\t\t\texpr = parseFlatNoparen(module, sReader, reader, noDecl);\n\t\t}\n\t\t\n\t\tif(expr == null) return null;\n\t\t\n\t\twhile(reader.hasNext()) {\n\t\t\t\n\t\t\tToken token = reader.peek();\n\t\t\t\n\t\t\tif(token.isNameToken()) {\n\t\t\t\tFunctionCall call = FunctionCallParser.parse(module, sReader, reader);\n\t\t\t\tif(call != null) {\n\t\t\t\t\texpr = new MemberCall(expr, call, token);\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tVariableAccess varAccess = AccessParser.parse(module, sReader, reader);\n\t\t\t\tif(varAccess != null) {\n\t\t\t\t\texpr = new MemberAccess(expr, varAccess, token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.DOUBLE_DOT) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression upper = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(upper == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\t\"Expected expression for the upper part of a range literal\");\n\t\t\t\t}\n\t\t\t\t// this is so beautiful it makes me wanna cry\n\t\t\t\texpr = new RangeLiteral(expr, upper, expr.startToken);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.OPEN_SQUAR) {\n\n\t\t\t\tArrayAccess arrAcc = new ArrayAccess(expr, token);\n\t\t\t\texpr = arrAcc;\n\t\t\t\treader.skip();\n\t\t\t\t\n\t\t\t\twhile(reader.peekWhiteless().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tExpression index = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\t\tif(index == null) {\n\t\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression for the index of an array access\");\n\t\t\t\t\t}\n\t\t\t\t\tarrAcc.getIndices().add(index);\n\t\t\t\t\t\n\t\t\t\t\tif(reader.peekWhiteless().type != TokenType.COMMA) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(reader.read().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\"Expected closing bracket to end array access, got \"+reader.prev()+\" instead.\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(rvalue == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression after '='.\");\n\t\t\t\t}\n\t\t\t\tif(!(expr instanceof Access)) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Attempting to assign to a constant, e.g. \"+expr);\n\t\t\t\t}\n\t\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\texpr = new Assignment(expr, rvalue, token);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AMPERSAND) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new AddressOf(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.QUEST) {\n\t\t\t\treader.skip();\n\t\t\t\tExpression ifTrue = parse(module, sReader, reader, true);\n\t\t\t\tif(reader.read().type != TokenType.COLON) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected ':' after '?', but got \"+reader.prev());\n\t\t\t\t}\n\t\t\t\tExpression ifFalse = parse(module, sReader, reader, true);\n\t\t\t\texpr = new Ternary(expr.startToken, expr, ifTrue, ifFalse);\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AT) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new Dereference(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t/** Must find a way to clean that up */\n\t\t\tif(token.type == TokenType.GREATERTHAN) {\n\t\t\t\treader.skip();\n\t\t\t\tToken token2 = reader.peek();\n\t\t\t\tif(token2.type == TokenType.GREATERTHAN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tToken token3 = reader.peek();\n\t\t\t\t\tif(token3.type == TokenType.ASSIGN) {\n\t\t\t\t\t\treader.skip();\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token);\n\t\t\t\t\t}\n\t\t\t\t} else if(token2.type == TokenType.ASSIGN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER_OR_EQUAL, token);\n\t\t\t\t} else {\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER, token);\n\t\t\t\t}\n\t\t\t} else if(token.type == TokenType.LESSTHAN) {\n\t\t\t\treader.skip();\n\t\t\t\tToken token2 = reader.peek();\n\t\t\t\tif(token2.type == TokenType.LESSTHAN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tToken token3 = reader.peek();\n\t\t\t\t\tif(token3.type == TokenType.ASSIGN) {\n\t\t\t\t\t\treader.skip();\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token);\n\t\t\t\t\t}\n\t\t\t\t} else if(token2.type == TokenType.ASSIGN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER_OR_EQUAL, token);\n\t\t\t\t} else {\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER, token);\n\t\t\t\t}\n\t\t\t} else if(token.type == TokenType.PLUS || token.type == TokenType.STAR\n\t\t\t\t\t|| token.type == TokenType.MINUS || token.type == TokenType.SLASH\n\t\t\t\t\t|| token.type == TokenType.PERCENT || token.type == TokenType.EQUALS\n\t\t\t\t\t|| token.type == TokenType.NOT_EQUALS || token.type == TokenType.PLUS_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.MINUS_ASSIGN || token.type == TokenType.STAR_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.SLASH_ASSIGN || token.type == TokenType.DOUBLE_PIPE\n\t\t\t\t\t|| token.type == TokenType.DOUBLE_AMPERSAND || token.type == TokenType.PIPE\n\t\t\t\t\t|| token.type == TokenType.AMPERSAND || token.type == TokenType.BINARY_AND\n\t\t\t\t\t|| token.type == TokenType.CARET) {\n\n\t\t\t\treader.skip();\n\t\t\t\treader.skipWhitespace();\n\t\t\t\t\n\t\t\t\tboolean isAssign = false;\n\t\t\t\t\n\t\t\t\tif(reader.peek().type == TokenType.ASSIGN) {\n\t\t\t\t\tisAssign = true;\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\n\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\n\t\t\t\tswitch(token.type) {\n\t\t\t\t\tcase TokenType.PLUS: \n\t\t\t\t\t\texpr = new Add(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR: \n\t\t\t\t\t\texpr = new Mul(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS:\n\t\t\t\t\t\texpr = new Sub(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH:\n\t\t\t\t\t\texpr = new Div(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PERCENT:\n\t\t\t\t\t\texpr = new Mod(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.EQUAL, token); break;\n\t\t\t\t\tcase TokenType.NOT_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.NOT_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.PLUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.ADD, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.SUB, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.MUL, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.DIV, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PIPE:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_OR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_OR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.AMPERSAND:\n\t\t\t\t\tcase TokenType.BINARY_AND:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_AND, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_PIPE: \n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_OR,  expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_AMPERSAND:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.CARET:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_XOR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_XOR, expr, rvalue, token); break;\n\t\t\t\t\tdefault: throw new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Unknown binary operation yet \"+token.type);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AS_KW) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tType type = TypeParser.parse(module, sReader, reader);\n\t\t\t\tif(type == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected destination type after 'as' keyword (e.g. for casting)\");\n\t\t\t\t}\n\t\t\t\texpr = new Cast(expr, type, token);\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn expr;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprivate static Expression getRvalue(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\treader.skipWhitespace();\n\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\tif(rvalue == null) {\n\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\"Expected rvalue after binary operator\");\n\t\t}\n\t\treturn rvalue;\n\t}\n\n\tprotected static void ensureAccess(Expression expr) {\n\n\t\tif(!(expr instanceof Access)) {\n\t\t\tthrow new CompilationFailedError(null, \"Trying to assign to a constant :/\");\n\t\t}\n\t\t\n\t}\n\t\n\tprotected static Expression parseFlatNoparen(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tLiteral literal = LiteralParser.parse(module, sReader, reader);\n\t\tif(literal != null) return literal;\n\n\t\tFunctionCall funcCall = FunctionCallParser.parse(module, sReader, reader);\n\t\tif(funcCall != null) return funcCall;\n\t\t\n\t\tif(!noDecl) {\n\t\t\tDeclaration declaration = DeclarationParser.parse(module, sReader, reader);\n\t\t\tif(declaration != null) return declaration;\n\t\t}\n\t\t\t\t\n\t\tAccess access = AccessParser.parse(module, sReader, reader);\n\t\tif(access != null) return access;\n\t\t\n\t\tMatch match = MatchParser.parse(module, sReader, reader);\n\t\tif(match != null) return match;\n\t\t\n\t\treader.reset(mark);\n\t\treturn null;\n\t\t\n\t}\n\t\n}\n","lineNo":207}
{"Smelly Sample":"package org.ooc.frontend.parser;\n\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.BinaryNegation;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.Declaration;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.Literal;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.Assignment.Mode;\nimport org.ooc.frontend.model.BinaryCombination.BinaryComp;\nimport org.ooc.frontend.model.Compare.CompareType;\nimport org.ooc.frontend.model.IntLiteral.Format;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class ExpressionParser {\n\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader) {\n\t\treturn parse(module, sReader, reader, false);\n\t}\n\t\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tToken firstToken = reader.peek();\n\t\tif(firstToken.type == TokenType.BANG) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Not(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.TILDE) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new BinaryNegation(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.MINUS) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Sub(new IntLiteral(0, Format.DEC, firstToken), inner, firstToken);\n\t\t}\n\t\t\n\t\tExpression expr = null;\n\t\tif(reader.peek().type == TokenType.OPEN_PAREN) {\n\t\t\treader.skip();\n\t\t\treader.skipWhitespace();\n\t\t\texpr = parse(module, sReader, reader, noDecl);\n\t\t\texpr = new Parenthesis(expr, expr.startToken);\n\t\t\treader.skipWhitespace();\n\t\t\tif(reader.read().type != TokenType.CLOS_PAREN) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev())\n\t\t\t\t\t\t, \"Expected closing parenthesis, but got \"+reader.prev());\n\t\t\t}\n\t\t} else {\n\t\t\texpr = parseFlatNoparen(module, sReader, reader, noDecl);\n\t\t}\n\t\t\n\t\tif(expr == null) return null;\n\t\t\n\t\twhile(reader.hasNext()) {\n\t\t\t\n\t\t\tToken token = reader.peek();\n\t\t\t\n\t\t\tif(token.isNameToken()) {\n\t\t\t\tFunctionCall call = FunctionCallParser.parse(module, sReader, reader);\n\t\t\t\tif(call != null) {\n\t\t\t\t\texpr = new MemberCall(expr, call, token);\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tVariableAccess varAccess = AccessParser.parse(module, sReader, reader);\n\t\t\t\tif(varAccess != null) {\n\t\t\t\t\texpr = new MemberAccess(expr, varAccess, token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.DOUBLE_DOT) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression upper = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(upper == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\t\"Expected expression for the upper part of a range literal\");\n\t\t\t\t}\n\t\t\t\t// this is so beautiful it makes me wanna cry\n\t\t\t\texpr = new RangeLiteral(expr, upper, expr.startToken);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.OPEN_SQUAR) {\n\n\t\t\t\tArrayAccess arrAcc = new ArrayAccess(expr, token);\n\t\t\t\texpr = arrAcc;\n\t\t\t\treader.skip();\n\t\t\t\t\n\t\t\t\twhile(reader.peekWhiteless().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tExpression index = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\t\tif(index == null) {\n\t\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression for the index of an array access\");\n\t\t\t\t\t}\n\t\t\t\t\tarrAcc.getIndices().add(index);\n\t\t\t\t\t\n\t\t\t\t\tif(reader.peekWhiteless().type != TokenType.COMMA) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(reader.read().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\"Expected closing bracket to end array access, got \"+reader.prev()+\" instead.\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(rvalue == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression after '='.\");\n\t\t\t\t}\n\t\t\t\tif(!(expr instanceof Access)) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Attempting to assign to a constant, e.g. \"+expr);\n\t\t\t\t}\n\t\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\texpr = new Assignment(expr, rvalue, token);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AMPERSAND) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new AddressOf(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.QUEST) {\n\t\t\t\treader.skip();\n\t\t\t\tExpression ifTrue = parse(module, sReader, reader, true);\n\t\t\t\tif(reader.read().type != TokenType.COLON) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected ':' after '?', but got \"+reader.prev());\n\t\t\t\t}\n\t\t\t\tExpression ifFalse = parse(module, sReader, reader, true);\n\t\t\t\texpr = new Ternary(expr.startToken, expr, ifTrue, ifFalse);\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AT) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new Dereference(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t/** Must find a way to clean that up */\n\t\t\tif(token.type == TokenType.PLUS || token.type == TokenType.STAR\n\t\t\t\t\t|| token.type == TokenType.MINUS || token.type == TokenType.SLASH\n\t\t\t\t\t|| token.type == TokenType.PERCENT || token.type == TokenType.GREATERTHAN\n\t\t\t\t\t|| token.type == TokenType.LESSTHAN || token.type == TokenType.GREATERTHAN_EQUALS\n\t\t\t\t\t|| token.type == TokenType.LESSTHAN_EQUALS || token.type == TokenType.EQUALS\n\t\t\t\t\t|| token.type == TokenType.LSHIFT || token.type == TokenType.LSHIFT_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.RSHIFT || token.type == TokenType.RSHIFT_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.NOT_EQUALS || token.type == TokenType.PLUS_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.MINUS_ASSIGN || token.type == TokenType.STAR_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.SLASH_ASSIGN || token.type == TokenType.DOUBLE_PIPE\n\t\t\t\t\t|| token.type == TokenType.DOUBLE_AMPERSAND || token.type == TokenType.PIPE\n\t\t\t\t\t|| token.type == TokenType.AMPERSAND || token.type == TokenType.BINARY_AND\n\t\t\t\t\t|| token.type == TokenType.CARET) {\n\n\t\t\t\treader.skip();\n\t\t\t\treader.skipWhitespace();\n\t\t\t\t\n\t\t\t\tboolean isAssign = false;\n\t\t\t\t\n\t\t\t\tif(reader.peek().type == TokenType.ASSIGN) {\n\t\t\t\t\tisAssign = true;\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\n\t\t\t\treader.skipWhitespace();\n\t\t\t\t\n\t\t\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(rvalue == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected rvalue after binary operator\");\n\t\t\t\t}\n\t\t\t\tswitch(token.type) {\n\t\t\t\t\tcase TokenType.PLUS: \n\t\t\t\t\t\texpr = new Add(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR: \n\t\t\t\t\t\texpr = new Mul(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS:\n\t\t\t\t\t\texpr = new Sub(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH:\n\t\t\t\t\t\texpr = new Div(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PERCENT:\n\t\t\t\t\t\texpr = new Mod(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.GREATERTHAN:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER, token); break;\n\t\t\t\t\tcase TokenType.GREATERTHAN_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER_OR_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.LESSTHAN:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER, token); break;\n\t\t\t\t\tcase TokenType.LESSTHAN_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER_OR_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.EQUAL, token); break;\n\t\t\t\t\tcase TokenType.NOT_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.NOT_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.PLUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.ADD, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.SUB, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.MUL, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.DIV, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PIPE:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_OR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_OR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.AMPERSAND:\n\t\t\t\t\tcase TokenType.BINARY_AND:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_AND, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_PIPE: \n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_OR,  expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_AMPERSAND:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.CARET:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_XOR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_XOR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.LSHIFT:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.RSHIFT:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.LSHIFT_ASSIGN:\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.RSHIFT_ASSIGN:\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token); break;\n\t\t\t\t\tdefault: throw new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Unknown binary operation yet \"+token.type);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AS_KW) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tType type = TypeParser.parse(module, sReader, reader);\n\t\t\t\tif(type == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected destination type after 'as' keyword (e.g. for casting)\");\n\t\t\t\t}\n\t\t\t\texpr = new Cast(expr, type, token);\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn expr;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected static void ensureAccess(Expression expr) {\n\n\t\tif(!(expr instanceof Access)) {\n\t\t\tthrow new CompilationFailedError(null, \"Trying to assign to a constant :/\");\n\t\t}\n\t\t\n\t}\n\t\n\tprotected static Expression parseFlatNoparen(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tLiteral literal = LiteralParser.parse(module, sReader, reader);\n\t\tif(literal != null) return literal;\n\n\t\tFunctionCall funcCall = FunctionCallParser.parse(module, sReader, reader);\n\t\tif(funcCall != null) return funcCall;\n\t\t\n\t\tif(!noDecl) {\n\t\t\tDeclaration declaration = DeclarationParser.parse(module, sReader, reader);\n\t\t\tif(declaration != null) return declaration;\n\t\t}\n\t\t\t\t\n\t\tAccess access = AccessParser.parse(module, sReader, reader);\n\t\tif(access != null) return access;\n\t\t\n\t\tMatch match = MatchParser.parse(module, sReader, reader);\n\t\tif(match != null) return match;\n\t\t\n\t\treader.reset(mark);\n\t\treturn null;\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.parser;\n\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.BinaryNegation;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.Declaration;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.Literal;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.Assignment.Mode;\nimport org.ooc.frontend.model.BinaryCombination.BinaryComp;\nimport org.ooc.frontend.model.Compare.CompareType;\nimport org.ooc.frontend.model.IntLiteral.Format;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class ExpressionParser {\n\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader) {\n\t\treturn parse(module, sReader, reader, false);\n\t}\n\t\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tToken firstToken = reader.peek();\n\t\tif(firstToken.type == TokenType.BANG) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Not(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.TILDE) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new BinaryNegation(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.MINUS) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Sub(new IntLiteral(0, Format.DEC, firstToken), inner, firstToken);\n\t\t}\n\t\t\n\t\tExpression expr = null;\n\t\tif(reader.peek().type == TokenType.OPEN_PAREN) {\n\t\t\treader.skip();\n\t\t\treader.skipWhitespace();\n\t\t\texpr = parse(module, sReader, reader, noDecl);\n\t\t\texpr = new Parenthesis(expr, expr.startToken);\n\t\t\treader.skipWhitespace();\n\t\t\tif(reader.read().type != TokenType.CLOS_PAREN) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev())\n\t\t\t\t\t\t, \"Expected closing parenthesis, but got \"+reader.prev());\n\t\t\t}\n\t\t} else {\n\t\t\texpr = parseFlatNoparen(module, sReader, reader, noDecl);\n\t\t}\n\t\t\n\t\tif(expr == null) return null;\n\t\t\n\t\twhile(reader.hasNext()) {\n\t\t\t\n\t\t\tToken token = reader.peek();\n\t\t\t\n\t\t\tif(token.isNameToken()) {\n\t\t\t\tFunctionCall call = FunctionCallParser.parse(module, sReader, reader);\n\t\t\t\tif(call != null) {\n\t\t\t\t\texpr = new MemberCall(expr, call, token);\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tVariableAccess varAccess = AccessParser.parse(module, sReader, reader);\n\t\t\t\tif(varAccess != null) {\n\t\t\t\t\texpr = new MemberAccess(expr, varAccess, token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.DOUBLE_DOT) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression upper = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(upper == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\t\"Expected expression for the upper part of a range literal\");\n\t\t\t\t}\n\t\t\t\t// this is so beautiful it makes me wanna cry\n\t\t\t\texpr = new RangeLiteral(expr, upper, expr.startToken);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.OPEN_SQUAR) {\n\n\t\t\t\tArrayAccess arrAcc = new ArrayAccess(expr, token);\n\t\t\t\texpr = arrAcc;\n\t\t\t\treader.skip();\n\t\t\t\t\n\t\t\t\twhile(reader.peekWhiteless().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tExpression index = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\t\tif(index == null) {\n\t\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression for the index of an array access\");\n\t\t\t\t\t}\n\t\t\t\t\tarrAcc.getIndices().add(index);\n\t\t\t\t\t\n\t\t\t\t\tif(reader.peekWhiteless().type != TokenType.COMMA) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(reader.read().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\"Expected closing bracket to end array access, got \"+reader.prev()+\" instead.\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(rvalue == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression after '='.\");\n\t\t\t\t}\n\t\t\t\tif(!(expr instanceof Access)) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Attempting to assign to a constant, e.g. \"+expr);\n\t\t\t\t}\n\t\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\texpr = new Assignment(expr, rvalue, token);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AMPERSAND) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new AddressOf(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.QUEST) {\n\t\t\t\treader.skip();\n\t\t\t\tExpression ifTrue = parse(module, sReader, reader, true);\n\t\t\t\tif(reader.read().type != TokenType.COLON) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected ':' after '?', but got \"+reader.prev());\n\t\t\t\t}\n\t\t\t\tExpression ifFalse = parse(module, sReader, reader, true);\n\t\t\t\texpr = new Ternary(expr.startToken, expr, ifTrue, ifFalse);\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AT) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new Dereference(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t/** Must find a way to clean that up */\n\t\t\tif(token.type == TokenType.GREATERTHAN) {\n\t\t\t\treader.skip();\n\t\t\t\tToken token2 = reader.peek();\n\t\t\t\tif(token2.type == TokenType.GREATERTHAN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tToken token3 = reader.peek();\n\t\t\t\t\tif(token3.type == TokenType.ASSIGN) {\n\t\t\t\t\t\treader.skip();\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token);\n\t\t\t\t\t}\n\t\t\t\t} else if(token2.type == TokenType.ASSIGN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER_OR_EQUAL, token);\n\t\t\t\t} else {\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER, token);\n\t\t\t\t}\n\t\t\t} else if(token.type == TokenType.LESSTHAN) {\n\t\t\t\treader.skip();\n\t\t\t\tToken token2 = reader.peek();\n\t\t\t\tif(token2.type == TokenType.LESSTHAN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tToken token3 = reader.peek();\n\t\t\t\t\tif(token3.type == TokenType.ASSIGN) {\n\t\t\t\t\t\treader.skip();\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token);\n\t\t\t\t\t}\n\t\t\t\t} else if(token2.type == TokenType.ASSIGN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER_OR_EQUAL, token);\n\t\t\t\t} else {\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER, token);\n\t\t\t\t}\n\t\t\t} else if(token.type == TokenType.PLUS || token.type == TokenType.STAR\n\t\t\t\t\t|| token.type == TokenType.MINUS || token.type == TokenType.SLASH\n\t\t\t\t\t|| token.type == TokenType.PERCENT || token.type == TokenType.EQUALS\n\t\t\t\t\t|| token.type == TokenType.NOT_EQUALS || token.type == TokenType.PLUS_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.MINUS_ASSIGN || token.type == TokenType.STAR_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.SLASH_ASSIGN || token.type == TokenType.DOUBLE_PIPE\n\t\t\t\t\t|| token.type == TokenType.DOUBLE_AMPERSAND || token.type == TokenType.PIPE\n\t\t\t\t\t|| token.type == TokenType.AMPERSAND || token.type == TokenType.BINARY_AND\n\t\t\t\t\t|| token.type == TokenType.CARET) {\n\n\t\t\t\treader.skip();\n\t\t\t\treader.skipWhitespace();\n\t\t\t\t\n\t\t\t\tboolean isAssign = false;\n\t\t\t\t\n\t\t\t\tif(reader.peek().type == TokenType.ASSIGN) {\n\t\t\t\t\tisAssign = true;\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\n\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\n\t\t\t\tswitch(token.type) {\n\t\t\t\t\tcase TokenType.PLUS: \n\t\t\t\t\t\texpr = new Add(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR: \n\t\t\t\t\t\texpr = new Mul(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS:\n\t\t\t\t\t\texpr = new Sub(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH:\n\t\t\t\t\t\texpr = new Div(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PERCENT:\n\t\t\t\t\t\texpr = new Mod(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.EQUAL, token); break;\n\t\t\t\t\tcase TokenType.NOT_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.NOT_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.PLUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.ADD, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.SUB, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.MUL, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.DIV, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PIPE:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_OR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_OR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.AMPERSAND:\n\t\t\t\t\tcase TokenType.BINARY_AND:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_AND, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_PIPE: \n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_OR,  expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_AMPERSAND:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.CARET:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_XOR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_XOR, expr, rvalue, token); break;\n\t\t\t\t\tdefault: throw new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Unknown binary operation yet \"+token.type);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AS_KW) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tType type = TypeParser.parse(module, sReader, reader);\n\t\t\t\tif(type == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected destination type after 'as' keyword (e.g. for casting)\");\n\t\t\t\t}\n\t\t\t\texpr = new Cast(expr, type, token);\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn expr;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprivate static Expression getRvalue(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\treader.skipWhitespace();\n\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\tif(rvalue == null) {\n\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\"Expected rvalue after binary operator\");\n\t\t}\n\t\treturn rvalue;\n\t}\n\n\tprotected static void ensureAccess(Expression expr) {\n\n\t\tif(!(expr instanceof Access)) {\n\t\t\tthrow new CompilationFailedError(null, \"Trying to assign to a constant :/\");\n\t\t}\n\t\t\n\t}\n\t\n\tprotected static Expression parseFlatNoparen(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tLiteral literal = LiteralParser.parse(module, sReader, reader);\n\t\tif(literal != null) return literal;\n\n\t\tFunctionCall funcCall = FunctionCallParser.parse(module, sReader, reader);\n\t\tif(funcCall != null) return funcCall;\n\t\t\n\t\tif(!noDecl) {\n\t\t\tDeclaration declaration = DeclarationParser.parse(module, sReader, reader);\n\t\t\tif(declaration != null) return declaration;\n\t\t}\n\t\t\t\t\n\t\tAccess access = AccessParser.parse(module, sReader, reader);\n\t\tif(access != null) return access;\n\t\t\n\t\tMatch match = MatchParser.parse(module, sReader, reader);\n\t\tif(match != null) return match;\n\t\t\n\t\treader.reset(mark);\n\t\treturn null;\n\t\t\n\t}\n\t\n}\n","lineNo":230}
{"Smelly Sample":"package org.ooc.frontend.parser;\n\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.BinaryNegation;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.Declaration;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.Literal;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.Assignment.Mode;\nimport org.ooc.frontend.model.BinaryCombination.BinaryComp;\nimport org.ooc.frontend.model.Compare.CompareType;\nimport org.ooc.frontend.model.IntLiteral.Format;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class ExpressionParser {\n\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader) {\n\t\treturn parse(module, sReader, reader, false);\n\t}\n\t\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tToken firstToken = reader.peek();\n\t\tif(firstToken.type == TokenType.BANG) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Not(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.TILDE) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new BinaryNegation(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.MINUS) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Sub(new IntLiteral(0, Format.DEC, firstToken), inner, firstToken);\n\t\t}\n\t\t\n\t\tExpression expr = null;\n\t\tif(reader.peek().type == TokenType.OPEN_PAREN) {\n\t\t\treader.skip();\n\t\t\treader.skipWhitespace();\n\t\t\texpr = parse(module, sReader, reader, noDecl);\n\t\t\texpr = new Parenthesis(expr, expr.startToken);\n\t\t\treader.skipWhitespace();\n\t\t\tif(reader.read().type != TokenType.CLOS_PAREN) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev())\n\t\t\t\t\t\t, \"Expected closing parenthesis, but got \"+reader.prev());\n\t\t\t}\n\t\t} else {\n\t\t\texpr = parseFlatNoparen(module, sReader, reader, noDecl);\n\t\t}\n\t\t\n\t\tif(expr == null) return null;\n\t\t\n\t\twhile(reader.hasNext()) {\n\t\t\t\n\t\t\tToken token = reader.peek();\n\t\t\t\n\t\t\tif(token.isNameToken()) {\n\t\t\t\tFunctionCall call = FunctionCallParser.parse(module, sReader, reader);\n\t\t\t\tif(call != null) {\n\t\t\t\t\texpr = new MemberCall(expr, call, token);\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tVariableAccess varAccess = AccessParser.parse(module, sReader, reader);\n\t\t\t\tif(varAccess != null) {\n\t\t\t\t\texpr = new MemberAccess(expr, varAccess, token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.DOUBLE_DOT) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression upper = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(upper == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\t\"Expected expression for the upper part of a range literal\");\n\t\t\t\t}\n\t\t\t\t// this is so beautiful it makes me wanna cry\n\t\t\t\texpr = new RangeLiteral(expr, upper, expr.startToken);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.OPEN_SQUAR) {\n\n\t\t\t\tArrayAccess arrAcc = new ArrayAccess(expr, token);\n\t\t\t\texpr = arrAcc;\n\t\t\t\treader.skip();\n\t\t\t\t\n\t\t\t\twhile(reader.peekWhiteless().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tExpression index = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\t\tif(index == null) {\n\t\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression for the index of an array access\");\n\t\t\t\t\t}\n\t\t\t\t\tarrAcc.getIndices().add(index);\n\t\t\t\t\t\n\t\t\t\t\tif(reader.peekWhiteless().type != TokenType.COMMA) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(reader.read().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\"Expected closing bracket to end array access, got \"+reader.prev()+\" instead.\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(rvalue == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression after '='.\");\n\t\t\t\t}\n\t\t\t\tif(!(expr instanceof Access)) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Attempting to assign to a constant, e.g. \"+expr);\n\t\t\t\t}\n\t\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\texpr = new Assignment(expr, rvalue, token);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AMPERSAND) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new AddressOf(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.QUEST) {\n\t\t\t\treader.skip();\n\t\t\t\tExpression ifTrue = parse(module, sReader, reader, true);\n\t\t\t\tif(reader.read().type != TokenType.COLON) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected ':' after '?', but got \"+reader.prev());\n\t\t\t\t}\n\t\t\t\tExpression ifFalse = parse(module, sReader, reader, true);\n\t\t\t\texpr = new Ternary(expr.startToken, expr, ifTrue, ifFalse);\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AT) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new Dereference(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t/** Must find a way to clean that up */\n\t\t\tif(token.type == TokenType.PLUS || token.type == TokenType.STAR\n\t\t\t\t\t|| token.type == TokenType.MINUS || token.type == TokenType.SLASH\n\t\t\t\t\t|| token.type == TokenType.PERCENT || token.type == TokenType.GREATERTHAN\n\t\t\t\t\t|| token.type == TokenType.LESSTHAN || token.type == TokenType.GREATERTHAN_EQUALS\n\t\t\t\t\t|| token.type == TokenType.LESSTHAN_EQUALS || token.type == TokenType.EQUALS\n\t\t\t\t\t|| token.type == TokenType.LSHIFT || token.type == TokenType.LSHIFT_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.RSHIFT || token.type == TokenType.RSHIFT_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.NOT_EQUALS || token.type == TokenType.PLUS_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.MINUS_ASSIGN || token.type == TokenType.STAR_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.SLASH_ASSIGN || token.type == TokenType.DOUBLE_PIPE\n\t\t\t\t\t|| token.type == TokenType.DOUBLE_AMPERSAND || token.type == TokenType.PIPE\n\t\t\t\t\t|| token.type == TokenType.AMPERSAND || token.type == TokenType.BINARY_AND\n\t\t\t\t\t|| token.type == TokenType.CARET) {\n\n\t\t\t\treader.skip();\n\t\t\t\treader.skipWhitespace();\n\t\t\t\t\n\t\t\t\tboolean isAssign = false;\n\t\t\t\t\n\t\t\t\tif(reader.peek().type == TokenType.ASSIGN) {\n\t\t\t\t\tisAssign = true;\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\n\t\t\t\treader.skipWhitespace();\n\t\t\t\t\n\t\t\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(rvalue == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected rvalue after binary operator\");\n\t\t\t\t}\n\t\t\t\tswitch(token.type) {\n\t\t\t\t\tcase TokenType.PLUS: \n\t\t\t\t\t\texpr = new Add(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR: \n\t\t\t\t\t\texpr = new Mul(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS:\n\t\t\t\t\t\texpr = new Sub(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH:\n\t\t\t\t\t\texpr = new Div(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PERCENT:\n\t\t\t\t\t\texpr = new Mod(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.GREATERTHAN:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER, token); break;\n\t\t\t\t\tcase TokenType.GREATERTHAN_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER_OR_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.LESSTHAN:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER, token); break;\n\t\t\t\t\tcase TokenType.LESSTHAN_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER_OR_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.EQUAL, token); break;\n\t\t\t\t\tcase TokenType.NOT_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.NOT_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.PLUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.ADD, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.SUB, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.MUL, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.DIV, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PIPE:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_OR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_OR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.AMPERSAND:\n\t\t\t\t\tcase TokenType.BINARY_AND:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_AND, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_PIPE: \n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_OR,  expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_AMPERSAND:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.CARET:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_XOR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_XOR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.LSHIFT:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.RSHIFT:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.LSHIFT_ASSIGN:\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.RSHIFT_ASSIGN:\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token); break;\n\t\t\t\t\tdefault: throw new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Unknown binary operation yet \"+token.type);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AS_KW) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tType type = TypeParser.parse(module, sReader, reader);\n\t\t\t\tif(type == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected destination type after 'as' keyword (e.g. for casting)\");\n\t\t\t\t}\n\t\t\t\texpr = new Cast(expr, type, token);\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn expr;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected static void ensureAccess(Expression expr) {\n\n\t\tif(!(expr instanceof Access)) {\n\t\t\tthrow new CompilationFailedError(null, \"Trying to assign to a constant :/\");\n\t\t}\n\t\t\n\t}\n\t\n\tprotected static Expression parseFlatNoparen(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tLiteral literal = LiteralParser.parse(module, sReader, reader);\n\t\tif(literal != null) return literal;\n\n\t\tFunctionCall funcCall = FunctionCallParser.parse(module, sReader, reader);\n\t\tif(funcCall != null) return funcCall;\n\t\t\n\t\tif(!noDecl) {\n\t\t\tDeclaration declaration = DeclarationParser.parse(module, sReader, reader);\n\t\t\tif(declaration != null) return declaration;\n\t\t}\n\t\t\t\t\n\t\tAccess access = AccessParser.parse(module, sReader, reader);\n\t\tif(access != null) return access;\n\t\t\n\t\tMatch match = MatchParser.parse(module, sReader, reader);\n\t\tif(match != null) return match;\n\t\t\n\t\treader.reset(mark);\n\t\treturn null;\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.parser;\n\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.BinaryNegation;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.Declaration;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.Literal;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.Assignment.Mode;\nimport org.ooc.frontend.model.BinaryCombination.BinaryComp;\nimport org.ooc.frontend.model.Compare.CompareType;\nimport org.ooc.frontend.model.IntLiteral.Format;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class ExpressionParser {\n\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader) {\n\t\treturn parse(module, sReader, reader, false);\n\t}\n\t\n\tpublic static Expression parse(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tToken firstToken = reader.peek();\n\t\tif(firstToken.type == TokenType.BANG) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Not(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.TILDE) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new BinaryNegation(inner, firstToken);\n\t\t}\n\t\t\n\t\tif(firstToken.type == TokenType.MINUS) {\n\t\t\treader.skip();\n\t\t\tExpression inner = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\tif(inner == null) {\n\t\t\t\treader.reset(mark);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Sub(new IntLiteral(0, Format.DEC, firstToken), inner, firstToken);\n\t\t}\n\t\t\n\t\tExpression expr = null;\n\t\tif(reader.peek().type == TokenType.OPEN_PAREN) {\n\t\t\treader.skip();\n\t\t\treader.skipWhitespace();\n\t\t\texpr = parse(module, sReader, reader, noDecl);\n\t\t\texpr = new Parenthesis(expr, expr.startToken);\n\t\t\treader.skipWhitespace();\n\t\t\tif(reader.read().type != TokenType.CLOS_PAREN) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev())\n\t\t\t\t\t\t, \"Expected closing parenthesis, but got \"+reader.prev());\n\t\t\t}\n\t\t} else {\n\t\t\texpr = parseFlatNoparen(module, sReader, reader, noDecl);\n\t\t}\n\t\t\n\t\tif(expr == null) return null;\n\t\t\n\t\twhile(reader.hasNext()) {\n\t\t\t\n\t\t\tToken token = reader.peek();\n\t\t\t\n\t\t\tif(token.isNameToken()) {\n\t\t\t\tFunctionCall call = FunctionCallParser.parse(module, sReader, reader);\n\t\t\t\tif(call != null) {\n\t\t\t\t\texpr = new MemberCall(expr, call, token);\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tVariableAccess varAccess = AccessParser.parse(module, sReader, reader);\n\t\t\t\tif(varAccess != null) {\n\t\t\t\t\texpr = new MemberAccess(expr, varAccess, token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.DOUBLE_DOT) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression upper = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(upper == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\t\"Expected expression for the upper part of a range literal\");\n\t\t\t\t}\n\t\t\t\t// this is so beautiful it makes me wanna cry\n\t\t\t\texpr = new RangeLiteral(expr, upper, expr.startToken);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.OPEN_SQUAR) {\n\n\t\t\t\tArrayAccess arrAcc = new ArrayAccess(expr, token);\n\t\t\t\texpr = arrAcc;\n\t\t\t\treader.skip();\n\t\t\t\t\n\t\t\t\twhile(reader.peekWhiteless().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tExpression index = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\t\tif(index == null) {\n\t\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression for the index of an array access\");\n\t\t\t\t\t}\n\t\t\t\t\tarrAcc.getIndices().add(index);\n\t\t\t\t\t\n\t\t\t\t\tif(reader.peekWhiteless().type != TokenType.COMMA) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(reader.read().type != TokenType.CLOS_SQUAR) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\"Expected closing bracket to end array access, got \"+reader.prev()+\" instead.\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\t\t\tif(rvalue == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected expression after '='.\");\n\t\t\t\t}\n\t\t\t\tif(!(expr instanceof Access)) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Attempting to assign to a constant, e.g. \"+expr);\n\t\t\t\t}\n\t\t\t\tif(token.type == TokenType.ASSIGN) {\n\t\t\t\t\texpr = new Assignment(expr, rvalue, token);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AMPERSAND) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new AddressOf(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.QUEST) {\n\t\t\t\treader.skip();\n\t\t\t\tExpression ifTrue = parse(module, sReader, reader, true);\n\t\t\t\tif(reader.read().type != TokenType.COLON) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected ':' after '?', but got \"+reader.prev());\n\t\t\t\t}\n\t\t\t\tExpression ifFalse = parse(module, sReader, reader, true);\n\t\t\t\texpr = new Ternary(expr.startToken, expr, ifTrue, ifFalse);\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AT) {\n\t\t\t\treader.skip();\n\t\t\t\texpr = new Dereference(expr, token);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t/** Must find a way to clean that up */\n\t\t\tif(token.type == TokenType.GREATERTHAN) {\n\t\t\t\treader.skip();\n\t\t\t\tToken token2 = reader.peek();\n\t\t\t\tif(token2.type == TokenType.GREATERTHAN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tToken token3 = reader.peek();\n\t\t\t\t\tif(token3.type == TokenType.ASSIGN) {\n\t\t\t\t\t\treader.skip();\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.RSHIFT, expr, rvalue, token);\n\t\t\t\t\t}\n\t\t\t\t} else if(token2.type == TokenType.ASSIGN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER_OR_EQUAL, token);\n\t\t\t\t} else {\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.GREATER, token);\n\t\t\t\t}\n\t\t\t} else if(token.type == TokenType.LESSTHAN) {\n\t\t\t\treader.skip();\n\t\t\t\tToken token2 = reader.peek();\n\t\t\t\tif(token2.type == TokenType.LESSTHAN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tToken token3 = reader.peek();\n\t\t\t\t\tif(token3.type == TokenType.ASSIGN) {\n\t\t\t\t\t\treader.skip();\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\trvalue = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token);\n\t\t\t\t\t\texpr = new Assignment(Mode.REGULAR, expr, rvalue, token);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LSHIFT, expr, rvalue, token);\n\t\t\t\t\t}\n\t\t\t\t} else if(token2.type == TokenType.ASSIGN) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER_OR_EQUAL, token);\n\t\t\t\t} else {\n\t\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.LESSER, token);\n\t\t\t\t}\n\t\t\t} else if(token.type == TokenType.PLUS || token.type == TokenType.STAR\n\t\t\t\t\t|| token.type == TokenType.MINUS || token.type == TokenType.SLASH\n\t\t\t\t\t|| token.type == TokenType.PERCENT || token.type == TokenType.EQUALS\n\t\t\t\t\t|| token.type == TokenType.NOT_EQUALS || token.type == TokenType.PLUS_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.MINUS_ASSIGN || token.type == TokenType.STAR_ASSIGN\n\t\t\t\t\t|| token.type == TokenType.SLASH_ASSIGN || token.type == TokenType.DOUBLE_PIPE\n\t\t\t\t\t|| token.type == TokenType.DOUBLE_AMPERSAND || token.type == TokenType.PIPE\n\t\t\t\t\t|| token.type == TokenType.AMPERSAND || token.type == TokenType.BINARY_AND\n\t\t\t\t\t|| token.type == TokenType.CARET) {\n\n\t\t\t\treader.skip();\n\t\t\t\treader.skipWhitespace();\n\t\t\t\t\n\t\t\t\tboolean isAssign = false;\n\t\t\t\t\n\t\t\t\tif(reader.peek().type == TokenType.ASSIGN) {\n\t\t\t\t\tisAssign = true;\n\t\t\t\t\treader.skip();\n\t\t\t\t}\n\n\t\t\t\tExpression rvalue = getRvalue(module, sReader, reader, noDecl);\n\t\t\t\t\n\t\t\t\tswitch(token.type) {\n\t\t\t\t\tcase TokenType.PLUS: \n\t\t\t\t\t\texpr = new Add(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR: \n\t\t\t\t\t\texpr = new Mul(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS:\n\t\t\t\t\t\texpr = new Sub(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH:\n\t\t\t\t\t\texpr = new Div(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PERCENT:\n\t\t\t\t\t\texpr = new Mod(expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.EQUAL, token); break;\n\t\t\t\t\tcase TokenType.NOT_EQUALS:\n\t\t\t\t\t\texpr = new Compare(expr, rvalue, CompareType.NOT_EQUAL, token); break;\n\t\t\t\t\tcase TokenType.PLUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.ADD, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.MINUS_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.SUB, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.STAR_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.MUL, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.SLASH_ASSIGN:\n\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\texpr = new Assignment(Mode.DIV, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.PIPE:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_OR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_OR, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.AMPERSAND:\n\t\t\t\t\tcase TokenType.BINARY_AND:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_AND, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_PIPE: \n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_OR,  expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.DOUBLE_AMPERSAND:\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.LOGICAL_AND, expr, rvalue, token); break;\n\t\t\t\t\tcase TokenType.CARET:\n\t\t\t\t\t\tif(isAssign) {\n\t\t\t\t\t\t\tensureAccess(expr);\n\t\t\t\t\t\t\texpr = new Assignment(Mode.B_XOR, expr, rvalue, token); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpr = new BinaryCombination(BinaryComp.BITWISE_XOR, expr, rvalue, token); break;\n\t\t\t\t\tdefault: throw new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Unknown binary operation yet \"+token.type);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(token.type == TokenType.AS_KW) {\n\t\t\t\t\n\t\t\t\treader.skip();\n\t\t\t\tType type = TypeParser.parse(module, sReader, reader);\n\t\t\t\tif(type == null) {\n\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected destination type after 'as' keyword (e.g. for casting)\");\n\t\t\t\t}\n\t\t\t\texpr = new Cast(expr, type, token);\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn expr;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprivate static Expression getRvalue(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\treader.skipWhitespace();\n\t\tExpression rvalue = ExpressionParser.parse(module, sReader, reader, noDecl);\n\t\tif(rvalue == null) {\n\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\"Expected rvalue after binary operator\");\n\t\t}\n\t\treturn rvalue;\n\t}\n\n\tprotected static void ensureAccess(Expression expr) {\n\n\t\tif(!(expr instanceof Access)) {\n\t\t\tthrow new CompilationFailedError(null, \"Trying to assign to a constant :/\");\n\t\t}\n\t\t\n\t}\n\t\n\tprotected static Expression parseFlatNoparen(Module module, SourceReader sReader, TokenReader reader, boolean noDecl) {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\tLiteral literal = LiteralParser.parse(module, sReader, reader);\n\t\tif(literal != null) return literal;\n\n\t\tFunctionCall funcCall = FunctionCallParser.parse(module, sReader, reader);\n\t\tif(funcCall != null) return funcCall;\n\t\t\n\t\tif(!noDecl) {\n\t\t\tDeclaration declaration = DeclarationParser.parse(module, sReader, reader);\n\t\t\tif(declaration != null) return declaration;\n\t\t}\n\t\t\t\t\n\t\tAccess access = AccessParser.parse(module, sReader, reader);\n\t\tif(access != null) return access;\n\t\t\n\t\tMatch match = MatchParser.parse(module, sReader, reader);\n\t\tif(match != null) return match;\n\t\t\n\t\treader.reset(mark);\n\t\treturn null;\n\t\t\n\t}\n\t\n}\n","lineNo":227}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.VariableAccess;\n\npublic class LocalAccessWriter {\n\n\tpublic static void write(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\twrite(variableAccess, doTypeParams, cgen, 0);\n\t}\n\t\n\tpublic static void write(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen, int refOffset) throws IOException {\n\t\t\n\t\tif(variableAccess.getRef() instanceof TypeDecl && !(variableAccess.getRef() instanceof TypeParam)) {\n\t\t\tcgen.current.app(variableAccess.getName()).app(\"_class()\");\n\t\t\treturn;\n\t\t}\n\n\t\t// duplicated code with MemberAccessWriter: modularize!\n\t\tint refLevel = variableAccess.getRef().getType().getReferenceLevel();\n\t\tif(doTypeParams) {\n\t\t\tif(variableAccess.getType().isGeneric()) {\n\t\t\t\trefLevel++;\n\t\t\t}\n\t\t}\n\t\trefLevel += refOffset;\n\t\t\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app('(');\n\t\t\tfor(int i = 0; i < refLevel; i++) {\n\t\t\t\tcgen.current.app('*');\n\t\t\t}\n\t\t}\n\t\tif(variableAccess.getRef().isMangled())\n\t\t\tcgen.current.app(variableAccess.getRef().getMangledName());\n\t\telse\n\t\t\tcgen.current.app(variableAccess.getRef().getExternName(variableAccess));\n\t\tif(refLevel > 0) cgen.current.app(')');\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\n\npublic class LocalAccessWriter {\n\n\tpublic static void write(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\twrite(variableAccess, doTypeParams, cgen, 0);\n\t}\n\t\n\tpublic static void write(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen, int refOffset) throws IOException {\n\t\t\n\t\tif(variableAccess.getRef() instanceof TypeDecl && !(variableAccess.getRef() instanceof TypeParam)) {\n\t\t\tTypeDecl ref = (TypeDecl) variableAccess.getRef();\n\t\t\tif(ref instanceof CoverDecl && ((CoverDecl)ref).isAddon()) {\n\t\t\t\tref = ((CoverDecl)ref).getBase();\n\t\t\t}\n\t\t\tcgen.current.app(ref.getUnderName()).app(\"_class()\");\n\t\t\treturn;\n\t\t}\n\n\t\t// duplicated code with MemberAccessWriter: modularize!\n\t\tint refLevel = variableAccess.getRef().getType().getReferenceLevel();\n\t\tif(doTypeParams) {\n\t\t\tif(variableAccess.getType().isGeneric()) {\n\t\t\t\trefLevel++;\n\t\t\t}\n\t\t}\n\t\trefLevel += refOffset;\n\t\t\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app('(');\n\t\t\tfor(int i = 0; i < refLevel; i++) {\n\t\t\t\tcgen.current.app('*');\n\t\t\t}\n\t\t}\n\t\tif(variableAccess.getRef() instanceof VariableDecl) {\n\t\t\tVariableDecl ref = (VariableDecl)variableAccess.getRef();\n\t\t\tcgen.current.app(ref.getFullName(ref.getAtom(variableAccess.getName())));\n\t\t} else if(variableAccess.getRef() instanceof FunctionDecl) {\n\t\t\t// closure, man!\n\t\t\tcgen.current.app(((FunctionDecl)variableAccess.getRef()).getFullName());\n\t\t} else {\n\t\t\tcgen.current.app(variableAccess.getRef().getExternName());\n\t\t}\n\t\tif(refLevel > 0) cgen.current.app(')');\n\t\t\n\t}\n\t\n}\n","lineNo":21}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.VariableAccess;\n\npublic class LocalAccessWriter {\n\n\tpublic static void write(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\twrite(variableAccess, doTypeParams, cgen, 0);\n\t}\n\t\n\tpublic static void write(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen, int refOffset) throws IOException {\n\t\t\n\t\tif(variableAccess.getRef() instanceof TypeDecl && !(variableAccess.getRef() instanceof TypeParam)) {\n\t\t\tcgen.current.app(variableAccess.getName()).app(\"_class()\");\n\t\t\treturn;\n\t\t}\n\n\t\t// duplicated code with MemberAccessWriter: modularize!\n\t\tint refLevel = variableAccess.getRef().getType().getReferenceLevel();\n\t\tif(doTypeParams) {\n\t\t\tif(variableAccess.getType().isGeneric()) {\n\t\t\t\trefLevel++;\n\t\t\t}\n\t\t}\n\t\trefLevel += refOffset;\n\t\t\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app('(');\n\t\t\tfor(int i = 0; i < refLevel; i++) {\n\t\t\t\tcgen.current.app('*');\n\t\t\t}\n\t\t}\n\t\tif(variableAccess.getRef().isMangled())\n\t\t\tcgen.current.app(variableAccess.getRef().getMangledName());\n\t\telse\n\t\t\tcgen.current.app(variableAccess.getRef().getExternName(variableAccess));\n\t\tif(refLevel > 0) cgen.current.app(')');\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\n\npublic class LocalAccessWriter {\n\n\tpublic static void write(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\twrite(variableAccess, doTypeParams, cgen, 0);\n\t}\n\t\n\tpublic static void write(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen, int refOffset) throws IOException {\n\t\t\n\t\tif(variableAccess.getRef() instanceof TypeDecl && !(variableAccess.getRef() instanceof TypeParam)) {\n\t\t\tTypeDecl ref = (TypeDecl) variableAccess.getRef();\n\t\t\tif(ref instanceof CoverDecl && ((CoverDecl)ref).isAddon()) {\n\t\t\t\tref = ((CoverDecl)ref).getBase();\n\t\t\t}\n\t\t\tcgen.current.app(ref.getUnderName()).app(\"_class()\");\n\t\t\treturn;\n\t\t}\n\n\t\t// duplicated code with MemberAccessWriter: modularize!\n\t\tint refLevel = variableAccess.getRef().getType().getReferenceLevel();\n\t\tif(doTypeParams) {\n\t\t\tif(variableAccess.getType().isGeneric()) {\n\t\t\t\trefLevel++;\n\t\t\t}\n\t\t}\n\t\trefLevel += refOffset;\n\t\t\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app('(');\n\t\t\tfor(int i = 0; i < refLevel; i++) {\n\t\t\t\tcgen.current.app('*');\n\t\t\t}\n\t\t}\n\t\tif(variableAccess.getRef() instanceof VariableDecl) {\n\t\t\tVariableDecl ref = (VariableDecl)variableAccess.getRef();\n\t\t\tcgen.current.app(ref.getFullName(ref.getAtom(variableAccess.getName())));\n\t\t} else if(variableAccess.getRef() instanceof FunctionDecl) {\n\t\t\t// closure, man!\n\t\t\tcgen.current.app(((FunctionDecl)variableAccess.getRef()).getFullName());\n\t\t} else {\n\t\t\tcgen.current.app(variableAccess.getRef().getExternName());\n\t\t}\n\t\tif(refLevel > 0) cgen.current.app(')');\n\t\t\n\t}\n\t\n}\n","lineNo":45}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ArrayAccess extends Access implements MustBeResolved {\n\n\tType type;\n\tprotected Expression variable;\n\tprotected NodeList<Expression> indices;\n\n\tpublic ArrayAccess(Expression variable, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.variable = variable;\n\t\tthis.indices =  new NodeList<Expression>(startToken);\n\t}\n\t\n\tpublic Expression getVariable() {\n\t\treturn variable;\n\t}\n\t\n\tpublic void setVariable(Expression variable) {\n\t\tthis.variable = variable;\n\t}\n\t\n\tpublic NodeList<Expression> getIndices() {\n\t\treturn indices;\n\t}\n\n\tpublic Type getType() {\n\t\tif(type == null) {\n\t\t\tType exprType = variable.getType();\n\t\t\tif(exprType != null) {\n\t\t\t\tDeclaration ref = exprType.getRef();\n\t\t\t\tif(ref instanceof CoverDecl) {\n\t\t\t\t\tType fromType = ((CoverDecl) ref).getFromType();\n\t\t\t\t\tif(fromType != null && fromType.getRef() instanceof CoverDecl) {\n\t\t\t\t\t\tType clone = fromType.clone();\n\t\t\t\t\t\tclone.setPointerLevel(exprType.getPointerLevel() + fromType.getPointerLevel());\n\t\t\t\t\t\texprType = clone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttype = new Type(exprType.getName(), exprType.getPointerLevel() - 1, exprType.startToken);\n\t\t\t\ttype.setRef(exprType.getRef());\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tvariable.accept(visitor);\n\t\tindices.accept(visitor);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(oldie == variable) {\n\t\t\tvariable = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == indices) {\n\t\t\tindices = (NodeList<Expression>) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tint assignIndex = -1;\n\t\t\n\t\tif(stack.peek() instanceof Assignment) {\n\t\t\tAssignment ass = (Assignment) stack.peek();\n\t\t\tif(ass.getLeft() == this) {\n\t\t\t\tassignIndex = stack.size() - 1;\n\t\t\t} else {\n\t\t\t\tNodeList<Node> copy = new NodeList<Node>();\n\t\t\t\tcopy.addAll(stack);\n\t\t\t\tcopy.pop();\n\t\t\t\tResponse response = ass.resolve(copy, res, fatal);\n\t\t\t\tif(response != Response.OK) {\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tif(tryOp(stack, res, assignIndex, op)) {\n\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tif(tryOp(stack, res, assignIndex, op)) { \n\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate boolean tryOp(NodeList<Node> stack, Resolver res, int assignIndex, OpDecl op)\n\t\tthrows OocCompilationError {\n\t\t\n\t\tif(assignIndex == -1) {\n\t\t\tif(tryIndexing(op, stack, res)) return true;\n\t\t} else {\n\t\t\tif(tryIndexedAssign(op, stack, res, assignIndex)) return true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\n\tprotected boolean tryIndexedAssign(OpDecl op, NodeList<Node> stack, Resolver res, int assignIndex) throws OocCompilationError {\n\t\t\n\t\tif(op.getOpType() != OpType.IDX_ASS) return false;\n\t\t\n\t\tAssignment ass = (Assignment) stack.get(assignIndex);\n\t\tif(ass.getLeft() != this) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(op.getFunc().getArguments().size() < 3) {\n\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\"To overload the indexed assign operator, you need exactly three arguments, not \"\n\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t}\n\t\t\n\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\tif(args.get(0).getType().softEquals(variable.getType(), res)\n\t\t\t\t&& args.get(1).getType().softEquals(indices.getFirst().getType(), res)) {\n\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\tcall.getArguments().add(variable);\n\t\t\tcall.getArguments().addAll(indices);\n\t\t\tcall.getArguments().add(ass.getRight());\n\t\t\tif(!stack.get(assignIndex - 1).replace(ass, call)) {\n\t\t\t\tSystem.out.println(\"stack = \"+stack.toString(true));\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace array-access-assign with a function call\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprotected boolean tryIndexing(OpDecl op, NodeList<Node> stack, Resolver res) throws OocCompilationError {\n\t\t\n\t\tif(op.getOpType() != OpType.IDX) return false;\n\t\t\n\t\tif(op.getFunc().getArguments().size() < 2) {\n\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\"To overload the indexing operator, you need at least two arguments, not \"\n\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t}\n\t\t\n\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\tif(args.get(0).getType().softEquals(variable.getType(), res)\n\t\t&& args.get(1).getType().softEquals(indices.getFirst().getType(), res)) {\n\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\tcall.getArguments().add(variable);\n\t\t\tcall.getArguments().addAll(indices);\n\t\t\tstack.peek().replace(this, call);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn variable.toString() + indices;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ArrayAccess extends Access implements MustBeResolved {\n\n\tType type;\n\tprotected Expression variable;\n\tprotected NodeList<Expression> indices;\n\n\tpublic ArrayAccess(Expression variable, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.variable = variable;\n\t\tthis.indices =  new NodeList<Expression>(startToken);\n\t}\n\t\n\tpublic Expression getVariable() {\n\t\treturn variable;\n\t}\n\t\n\tpublic void setVariable(Expression variable) {\n\t\tthis.variable = variable;\n\t}\n\t\n\tpublic NodeList<Expression> getIndices() {\n\t\treturn indices;\n\t}\n\n\tpublic Type getType() {\n\t\tif(type == null) {\n\t\t\tType exprType = variable.getType();\n\t\t\tif(exprType != null) {\n\t\t\t\tDeclaration ref = exprType.getRef();\n\t\t\t\tif(ref instanceof CoverDecl) {\n\t\t\t\t\tType fromType = ((CoverDecl) ref).getFromType();\n\t\t\t\t\tif(fromType != null && fromType.getRef() instanceof CoverDecl) {\n\t\t\t\t\t\tType clone = fromType.clone();\n\t\t\t\t\t\tclone.setPointerLevel(exprType.getPointerLevel() + fromType.getPointerLevel());\n\t\t\t\t\t\texprType = clone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttype = new Type(exprType.getName(), exprType.getPointerLevel() - 1, exprType.startToken);\n\t\t\t\ttype.setRef(exprType.getRef());\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tvariable.accept(visitor);\n\t\tindices.accept(visitor);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(oldie == variable) {\n\t\t\tvariable = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == indices) {\n\t\t\tindices = (NodeList<Expression>) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tint assignIndex = -1;\n\t\t\n\t\tif(stack.peek() instanceof Assignment) {\n\t\t\tAssignment ass = (Assignment) stack.peek();\n\t\t\tif(ass.getLeft() == this) {\n\t\t\t\tassignIndex = stack.size() - 1;\n\t\t\t} else {\n\t\t\t\tNodeList<Node> copy = new NodeList<Node>();\n\t\t\t\tcopy.addAll(stack);\n\t\t\t\tcopy.pop();\n\t\t\t\tResponse response = ass.resolve(copy, res, fatal);\n\t\t\t\tif(response != Response.OK) {\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tOpDecl bestOp = null;\n\t\tint bestScore = 0;\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tint score = getOpScore(stack, res, assignIndex, op);\n\t\t\tif(bestScore < score) {\n\t\t\t\tbestOp = op;\n\t\t\t\tbestScore = score;\n\t\t\t}\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tint score = getOpScore(stack, res, assignIndex, op);\n\t\t\t\tif(bestScore < score) {\n\t\t\t\t\tbestOp = op;\n\t\t\t\t\tbestScore = score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestOp != null) {\n\t\t\tNodeList<Argument> args = bestOp.getFunc().getArguments();\n\t\t\tFunctionCall call = new FunctionCall(bestOp.getFunc(), startToken);\n\t\t\t\n\t\t\tArgument arg = args.getFirst();\n\t\t\tif(arg.getType().getReferenceLevel() == variable.getType().getReferenceLevel() + 1) {\n\t\t\t\tvariable = new AddressOf(variable, startToken);\n\t\t\t}\n\t\t\t\n\t\t\tcall.getArguments().add(variable);\n\t\t\t\n\t\t\tfor(int argIdx = 0; argIdx < indices.size(); ++argIdx) {\n\t\t\t\targ = args.get(argIdx+1);\n\t\t\t\tExpression exp = indices.get(argIdx);\n\t\t\t\t\n\t\t\t\tif(arg.getType().getReferenceLevel() == exp.getType().getReferenceLevel() + 1) {\n\t\t\t\t\texp = new AddressOf(exp, exp.startToken);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcall.getArguments().add(exp);\n\t\t\t}\n\t\t\t\n\t\t\tif(assignIndex != -1) {\n\t\t\t\tAssignment ass = (Assignment)stack.get(assignIndex);\n\t\t\t\tcall.getArguments().add(ass.getRight());\n\t\t\t\t\n\t\t\t\tif(!stack.get(assignIndex - 1).replace(ass, call)) {\n\t\t\t\t\tSystem.out.println(\"stack = \"+stack.toString(true));\n\t\t\t\t\tThread.dumpStack();\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace array-access-assign with a function call\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstack.peek().replace(this, call);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n\tprivate int getOpScore(NodeList<Node> stack, Resolver res, int assignIndex, OpDecl op) throws OocCompilationError {\n\t\tint score = 0;\n\t\t\n\t\tOpType opType = assignIndex == -1 ? OpType.IDX : OpType.IDX_ASS;\n\t\tint numArgs = 1 + indices.size() + (opType == OpType.IDX ? 0 : 1);\n\t\t\n\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\tif(op.getOpType() != opType || args.size() != numArgs) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tArgument first = args.getFirst();\n\t\tif(first.getType().equals(variable.getType())) {\n\t\t\tif(opType == OpType.IDX && args.size() < 2) {\n\t\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\t\"To overload the indexing operator, you need at least two arguments, not \"\n\t\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t\t} else if(opType == OpType.IDX_ASS && args.size() < 3) {\n\t\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\t\"To overload the indexed assign operator, you need exactly three arguments, not \"\n\t\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t\t}\n\t\t\t\n\t\t\tscore += 10;\n\t\t\t\n\t\t\tfor(int idx = 0; idx < indices.size(); ++idx) {\n\t\t\t\tExpression exp = indices.get(idx);\n\t\t\t\tArgument arg = args.get(idx+1);\n\t\t\t\t\n\t\t\t\tif(exp instanceof MustBeResolved && ((MustBeResolved)exp).resolve(stack, res, true) != Response.OK) {\n\t\t\t\t\t// FIXME I'm not entirely sure how to handle this, so I'm doing this\n\t\t\t\t\t// in the least-friendly way possible: death by exception\n\t\t\t\t\tthrow new OocCompilationError(exp, stack,\n\t\t\t\t\t\t\t\"Unable to determine the type of the expression being used as an index\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(exp.getType().softEquals(arg.getType(), res)) {\n\t\t\t\t\tscore += 10;\n\t\t\t\t\tif(exp.getType().equals(arg.getType())) {\n\t\t\t\t\t\tscore += 10;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(assignIndex != -1) {\n\t\t\t\tArgument last = args.getLast();\n\t\t\t\tAssignment ass = (Assignment)stack.get(assignIndex);\n\t\t\t\tif(ass.getRight().getType().softEquals(last.getType(), res)) {\n\t\t\t\t\tscore += 10;\n\t\t\t\t\tif(ass.getRight().getType().equals(last.getType())) {\n\t\t\t\t\t\tscore += 20;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn variable.toString() + indices;\n\t}\n\t\n}\n","lineNo":173}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\nimport org.ubi.SyntaxError;\n\npublic class Tokenizer {\n\n\tprotected static class Name {\n\t\tString name;\n\t\tbyte tokenType;\n\t\t\n\t\tpublic Name(String name, byte tokenType) {\n\t\t\tthis.name = name;\n\t\t\tthis.tokenType = tokenType;\n\t\t}\n\t}\n\t\n\tprotected static Name[] names = new Name[] {\n\t\tnew Name(\"func\", TokenType.FUNC_KW),\n\t\tnew Name(\"class\", TokenType.CLASS_KW),\n\t\tnew Name(\"cover\", TokenType.COVER_KW),\n\t\tnew Name(\"extern\", TokenType.EXTERN_KW),\n\t\tnew Name(\"from\", TokenType.FROM_KW),\n\t\tnew Name(\"if\", TokenType.IF_KW),\n\t\tnew Name(\"else\", TokenType.ELSE_KW),\n\t\tnew Name(\"for\", TokenType.FOR_KW),\n\t\tnew Name(\"while\", TokenType.WHILE_KW),\n\t\tnew Name(\"true\", TokenType.TRUE),\n\t\tnew Name(\"false\", TokenType.FALSE),\n\t\tnew Name(\"null\", TokenType.NULL),\n\t\tnew Name(\"do\", TokenType.DO_KW),\n\t\tnew Name(\"match\", TokenType.MATCH_KW),\n\t\tnew Name(\"case\", TokenType.CASE_KW),\n\t\tnew Name(\"return\", TokenType.RETURN_KW),\n\t\tnew Name(\"as\", TokenType.AS_KW),\n\t\tnew Name(\"const\", TokenType.CONST_KW),\n\t\tnew Name(\"static\", TokenType.STATIC_KW),\n\t\tnew Name(\"abstract\", TokenType.ABSTRACT_KW),\n\t\tnew Name(\"import\", TokenType.IMPORT_KW),\n\t\tnew Name(\"final\", TokenType.FINAL_KW),\n\t\tnew Name(\"include\", TokenType.INCLUDE_KW),\n\t\tnew Name(\"use\", TokenType.USE_KW),\n\t\tnew Name(\"break\", TokenType.BREAK_KW),\n\t\tnew Name(\"continue\", TokenType.CONTINUE_KW),\n\t\tnew Name(\"fallthrough\", TokenType.FALLTHR_KW),\n\t\tnew Name(\"extends\", TokenType.EXTENDS_KW),\n\t\tnew Name(\"in\", TokenType.IN_KW),\n\t\tnew Name(\"version\", TokenType.VERSION_KW),\n\t\tnew Name(\"proto\", TokenType.PROTO_KW),\n\t\tnew Name(\"inline\", TokenType.INLINE_KW),\n\t\tnew Name(\"operator\", TokenType.OPERATOR_KW),\n\t\t//TODO I'm not sure if those three should be keywords.\n\t\t//They are remains from C and can be parsed as NAMEs\n\t\tnew Name(\"unsigned\", TokenType.UNSIGNED),\n\t\tnew Name(\"signed\", TokenType.SIGNED),\n\t\tnew Name(\"long\", TokenType.LONG),\n\t\tnew Name(\"union\", TokenType.UNION),\n\t\tnew Name(\"struct\", TokenType.STRUCT),\n\t};\n\t\n\tprotected static class CharTuple {\n\t\tchar first;\n\t\tbyte firstType;\n\t\t\n\t\tchar second;\n\t\tbyte secondType;\n\t\t\n\t\tchar third;\n\t\tbyte thirdType;\n\t\t\n\t\tpublic CharTuple(char first, byte firstType) {\n\t\t\tthis(first, firstType, '\\0', (byte) 0);\n\t\t}\n\t\t\n\t\tpublic CharTuple(char first, byte firstType, char second, byte secondType) {\n\t\t\tthis(first, firstType, second, secondType, '\\0', (byte) 0);\n\t\t}\n\t\t\n\t\tpublic CharTuple(char first, byte firstType, char second, byte secondType,\n\t\t\t\tchar third, byte thirdType) {\n\t\t\tthis.first = first;\n\t\t\tthis.firstType = firstType;\n\t\t\tthis.second = second;\n\t\t\tthis.secondType = secondType;\n\t\t\tthis.third = third;\n\t\t\tthis.thirdType = thirdType;\n\t\t}\n\n\t\tpublic Token handle(int index, char c, SourceReader reader) throws EOFException {\n\t\t\tif(c != first) return null;\n\t\t\treader.read();\n\t\t\tif(second == '\\0' || !reader.hasNext() || second != reader.peek()) {\n\t\t\t\treturn new Token(index, 1, firstType);\n\t\t\t}\n\t\t\treader.read();\n\t\t\tif(third == '\\0' || !reader.hasNext() || third != reader.peek()) {\n\t\t\t\treturn new Token(index, 2, secondType);\n\t\t\t}\n\t\t\treader.read();\n\t\t\treturn new Token(index, 3, thirdType);\n\t\t}\n\t}\n\t\n\tprotected static CharTuple[] chars = new CharTuple[] {\n\t\tnew CharTuple('(', TokenType.OPEN_PAREN),\n\t\tnew CharTuple(')', TokenType.CLOS_PAREN),\n\t\tnew CharTuple('{', TokenType.OPEN_BRACK),\n\t\tnew CharTuple('}', TokenType.CLOS_BRACK),\n\t\tnew CharTuple('[', TokenType.OPEN_SQUAR),\n\t\tnew CharTuple(']', TokenType.CLOS_SQUAR),\n\t\t//new CharTuple('=', TokenType.ASSIGN, '=', TokenType.EQUALS),\n\t\tnew CharTuple('.', TokenType.DOT, '.', TokenType.DOUBLE_DOT, '.', TokenType.TRIPLE_DOT),\n\t\tnew CharTuple(',', TokenType.COMMA),\n\t\tnew CharTuple('%', TokenType.PERCENT),\n\t\tnew CharTuple('~', TokenType.TILDE),\n\t\tnew CharTuple(':', TokenType.COLON, '=', TokenType.DECL_ASSIGN),\n\t\tnew CharTuple('!', TokenType.BANG, '=', TokenType.NOT_EQUALS),\n\t\t//new CharTuple('&', TokenType.AMPERSAND, '&', TokenType.DOUBLE_AMPERSAND),\n\t\tnew CharTuple('|', TokenType.PIPE, '|', TokenType.DOUBLE_PIPE),\n\t\tnew CharTuple('?', TokenType.QUEST),\n\t\tnew CharTuple('#', TokenType.HASH),\n\t\tnew CharTuple('@', TokenType.AT),\n\t\tnew CharTuple('+', TokenType.PLUS, '=', TokenType.PLUS_ASSIGN),\n\t\tnew CharTuple('*', TokenType.STAR, '=', TokenType.STAR_ASSIGN),\n\t\tnew CharTuple('>', TokenType.GREATERTHAN, '=', TokenType.GREATERTHAN_EQUALS),\n\t\tnew CharTuple('>', TokenType.GREATERTHAN, '=', TokenType.GREATERTHAN_EQUALS),\n\t\tnew CharTuple('^', TokenType.CARET),\n\t};\n\t\n\tpublic List<Token> parse(SourceReader reader) throws IOException {\n\t\t\n\t\tList<Token> tokens = new ArrayList<Token>();\n\t\t\n\t\treading: while(reader.hasNext()) {\n\t\t\t\n\t\t\treader.skipChars(\"\\t \");\n\t\t\tif(!reader.hasNext()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint index = reader.mark();\n\t\t\t\n\t\t\tchar c = reader.peek();\n\t\t\tif(c == ';' || c == '\\n' || c == '\\r') {\n\t\t\t\treader.read();\n\t\t\t\twhile(reader.hasNext() && (reader.peek() == '\\n' || reader.peek() == '\\r')) {\n\t\t\t\t\treader.read();\n\t\t\t\t}\n\t\t\t\ttokens.add(new Token(index, 1, TokenType.LINESEP));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '\\\\') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '\\\\') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.DOUBLE_BACKSLASH));\n\t\t\t\t} else if(c2 == '\\n') {\n\t\t\t\t\treader.read(); // Just skip both of'em (line continuation)\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.BACKSLASH));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(CharTuple candidate: chars) {\n\t\t\t\tToken token = candidate.handle(index, c, reader);\n\t\t\t\tif(token != null) {\n\t\t\t\t\ttokens.add(token);\n\t\t\t\t\tcontinue reading;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tif(c == '\"') {\n\t\t\t\treader.read();\n\t\t\t\t// TODO: optimize. readStringLiteral actually stores it into a String, but we don't care\n\t\t\t\ttry {\n\t\t\t\t\treader.readStringLiteral();\n\t\t\t\t} catch(EOFException eof) {\n\t\t\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 0), \"Never-ending string literal (reached end of file)\");\n\t\t\t\t}\n\t\t\t\ttokens.add(new Token(index + 1,\n\t\t\t\t\t\treader.mark() - index - 2,\n\t\t\t\t\t\tTokenType.STRING_LIT));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '\\'') {\n\t\t\t\treader.read();\n\t\t\t\ttry {\n\t\t\t\t\treader.readCharLiteral();\n\t\t\t\t\ttokens.add(new Token(index + 1, \n\t\t\t\t\t\t\treader.mark() - index - 2,\n\t\t\t\t\t\t\tTokenType.CHAR_LIT));\n\t\t\t\t\tcontinue;\n\t\t\t\t} catch(SyntaxError e) {\n\t\t\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 0), e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '/') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '=') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.SLASH_ASSIGN));\n\t\t\t\t} else if(c2 == '/') {\n\t\t\t\t\treader.readLine();\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.LINESEP));\n\t\t\t\t} else if(c2 == '*') {\n\t\t\t\t\treader.read();\n\t\t\t\t\tchar c3 = reader.peek();\n\t\t\t\t\tif(c3 == '*') {\n\t\t\t\t\t\treader.read();\n\t\t\t\t\t\treader.readUntil(new String[] {\"*/\"}, true);\n\t\t\t\t\t\ttokens.add(new Token(index, reader.mark() - index, TokenType.OOCDOC));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treader.readUntil(new String[] {\"*/\"}, true);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.SLASH));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '-') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '>') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.ARROW));\n\t\t\t\t} else if(c2 == '=') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.MINUS_ASSIGN));\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.MINUS));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '<') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '=') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.LESSTHAN_EQUALS));\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.LESSTHAN));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '=') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '>') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.DOUBLE_ARROW));\n\t\t\t\t} else if(c2 == '=') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.EQUALS));\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.ASSIGN));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '&') {\n\t\t\t\t// read the precious one\n\t\t\t\treader.rewind(1);\n\t\t\t\tchar cprev = reader.read();\n\t\t\t\treader.read(); // skip the '&'\n\t\t\t\tboolean binary = false;\n\t\t\t\tif(cprev == ' ') binary = true;\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '&') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.DOUBLE_AMPERSAND));\n\t\t\t\t} else if(binary) {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.BINARY_AND));\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.AMPERSAND));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '0') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == 'x') {\n\t\t\t\t\treader.read();\n\t\t\t\t\tString lit = reader.readMany(\"0123456789abcdefABCDEF\", \"_\", true);\n\t\t\t\t\tif(lit.length() == 0) {\n\t\t\t\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 0), \"Empty hexadecimal number literal\");\n\t\t\t\t\t}\n\t\t\t\t\ttokens.add(new Token(index + 2, reader.mark()\n\t\t\t\t\t\t\t- index - 2, TokenType.HEX_INT));\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if(c2 == 'c') {\n\t\t\t\t\treader.read();\n\t\t\t\t\tString lit = reader.readMany(\"01234567\", \"_\", true);\n\t\t\t\t\tif(lit.length() == 0) {\n\t\t\t\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 0), \"Empty octal number literal\");\n\t\t\t\t\t}\n\t\t\t\t\ttokens.add(new Token(index + 2, reader.mark()\n\t\t\t\t\t\t\t- index - 2, TokenType.OCT_INT));\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if(c2 == 'b') {\n\t\t\t\t\treader.read();\n\t\t\t\t\tString lit = reader.readMany(\"01\", \"_\", true);\n\t\t\t\t\tif(lit.length() == 0) {\n\t\t\t\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 0), \"Empty binary number literal\");\n\t\t\t\t\t}\n\t\t\t\t\ttokens.add(new Token(index + 2, reader.mark()\n\t\t\t\t\t\t\t- index - 2, TokenType.BIN_INT));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(Character.isDigit(c)) {\n\t\t\t\treader.readMany(\"0123456789\", \"_\", true);\n\t\t\t\tif(reader.peek() == '.') {\n\t\t\t\t\treader.read();\n\t\t\t\t\tif(reader.peek() != '.') {\n\t\t\t\t\t\treader.readMany(\"0123456789\", \"_\", true);\n\t\t\t\t\t\ttokens.add(new Token(index, reader.mark() - index,\n\t\t\t\t\t\t\t\tTokenType.DEC_FLOAT));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treader.rewind(1);\n\t\t\t\t}\n\t\t\t\ttokens.add(new Token(index, reader.mark() - index,\n\t\t\t\t\tTokenType.DEC_INT));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(reader.skipName()) {\n\t\t\t\tString name = reader.getSlice(index, reader.mark() - index);\n\t\t\t\tfor(Name candidate: names) {\n\t\t\t\t\tif(candidate.name.equals(name)) {\n\t\t\t\t\t\ttokens.add(new Token(index, name.length(), candidate.tokenType));\n\t\t\t\t\t\tcontinue reading;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttokens.add(new Token(index, name.length(), TokenType.NAME));\n\t\t\t\tcontinue reading;\n\t\t\t}\n\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 1),\n\t\t\t\t\t\"Unexpected input '\"+SourceReader.spelled(reader.peek())+\"'\");\n\t\t\t\n\t\t}\n\t\t\n\t\ttokens.add(new Token(reader.mark(), 0, TokenType.LINESEP));\n\t\t\n\t\treturn tokens;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\nimport org.ubi.SyntaxError;\n\npublic class Tokenizer {\n\n\tprotected static class Name {\n\t\tString name;\n\t\tbyte tokenType;\n\t\t\n\t\tpublic Name(String name, byte tokenType) {\n\t\t\tthis.name = name;\n\t\t\tthis.tokenType = tokenType;\n\t\t}\n\t}\n\t\n\tprotected static Name[] names = new Name[] {\n\t\tnew Name(\"func\", TokenType.FUNC_KW),\n\t\tnew Name(\"class\", TokenType.CLASS_KW),\n\t\tnew Name(\"cover\", TokenType.COVER_KW),\n\t\tnew Name(\"extern\", TokenType.EXTERN_KW),\n\t\tnew Name(\"from\", TokenType.FROM_KW),\n\t\tnew Name(\"if\", TokenType.IF_KW),\n\t\tnew Name(\"else\", TokenType.ELSE_KW),\n\t\tnew Name(\"for\", TokenType.FOR_KW),\n\t\tnew Name(\"while\", TokenType.WHILE_KW),\n\t\tnew Name(\"true\", TokenType.TRUE),\n\t\tnew Name(\"false\", TokenType.FALSE),\n\t\tnew Name(\"null\", TokenType.NULL),\n\t\tnew Name(\"do\", TokenType.DO_KW),\n\t\tnew Name(\"match\", TokenType.MATCH_KW),\n\t\tnew Name(\"case\", TokenType.CASE_KW),\n\t\tnew Name(\"return\", TokenType.RETURN_KW),\n\t\tnew Name(\"as\", TokenType.AS_KW),\n\t\tnew Name(\"const\", TokenType.CONST_KW),\n\t\tnew Name(\"static\", TokenType.STATIC_KW),\n\t\tnew Name(\"abstract\", TokenType.ABSTRACT_KW),\n\t\tnew Name(\"import\", TokenType.IMPORT_KW),\n\t\tnew Name(\"final\", TokenType.FINAL_KW),\n\t\tnew Name(\"include\", TokenType.INCLUDE_KW),\n\t\tnew Name(\"use\", TokenType.USE_KW),\n\t\tnew Name(\"break\", TokenType.BREAK_KW),\n\t\tnew Name(\"continue\", TokenType.CONTINUE_KW),\n\t\tnew Name(\"fallthrough\", TokenType.FALLTHR_KW),\n\t\tnew Name(\"extends\", TokenType.EXTENDS_KW),\n\t\tnew Name(\"in\", TokenType.IN_KW),\n\t\tnew Name(\"version\", TokenType.VERSION_KW),\n\t\tnew Name(\"proto\", TokenType.PROTO_KW),\n\t\tnew Name(\"inline\", TokenType.INLINE_KW),\n\t\tnew Name(\"operator\", TokenType.OPERATOR_KW),\n\t\t//TODO I'm not sure if those three should be keywords.\n\t\t//They are remains from C and can be parsed as NAMEs\n\t\tnew Name(\"unsigned\", TokenType.UNSIGNED),\n\t\tnew Name(\"signed\", TokenType.SIGNED),\n\t\tnew Name(\"long\", TokenType.LONG),\n\t\tnew Name(\"union\", TokenType.UNION),\n\t\tnew Name(\"struct\", TokenType.STRUCT),\n\t};\n\t\n\tprotected static class CharTuple {\n\t\tchar first;\n\t\tbyte firstType;\n\t\t\n\t\tchar second;\n\t\tbyte secondType;\n\t\t\n\t\tchar third;\n\t\tbyte thirdType;\n\t\t\n\t\tpublic CharTuple(char first, byte firstType) {\n\t\t\tthis(first, firstType, '\\0', (byte) 0);\n\t\t}\n\t\t\n\t\tpublic CharTuple(char first, byte firstType, char second, byte secondType) {\n\t\t\tthis(first, firstType, second, secondType, '\\0', (byte) 0);\n\t\t}\n\t\t\n\t\tpublic CharTuple(char first, byte firstType, char second, byte secondType,\n\t\t\t\tchar third, byte thirdType) {\n\t\t\tthis.first = first;\n\t\t\tthis.firstType = firstType;\n\t\t\tthis.second = second;\n\t\t\tthis.secondType = secondType;\n\t\t\tthis.third = third;\n\t\t\tthis.thirdType = thirdType;\n\t\t}\n\n\t\tpublic Token handle(int index, char c, SourceReader reader) throws EOFException {\n\t\t\tif(c != first) return null;\n\t\t\treader.read();\n\t\t\tif(second == '\\0' || !reader.hasNext() || second != reader.peek()) {\n\t\t\t\treturn new Token(index, 1, firstType);\n\t\t\t}\n\t\t\treader.read();\n\t\t\tif(third == '\\0' || !reader.hasNext() || third != reader.peek()) {\n\t\t\t\treturn new Token(index, 2, secondType);\n\t\t\t}\n\t\t\treader.read();\n\t\t\treturn new Token(index, 3, thirdType);\n\t\t}\n\t}\n\t\n\tprotected static CharTuple[] chars = new CharTuple[] {\n\t\tnew CharTuple('(', TokenType.OPEN_PAREN),\n\t\tnew CharTuple(')', TokenType.CLOS_PAREN),\n\t\tnew CharTuple('{', TokenType.OPEN_BRACK),\n\t\tnew CharTuple('}', TokenType.CLOS_BRACK),\n\t\tnew CharTuple('[', TokenType.OPEN_SQUAR),\n\t\tnew CharTuple(']', TokenType.CLOS_SQUAR),\n\t\t//new CharTuple('=', TokenType.ASSIGN, '=', TokenType.EQUALS),\n\t\tnew CharTuple('.', TokenType.DOT, '.', TokenType.DOUBLE_DOT, '.', TokenType.TRIPLE_DOT),\n\t\tnew CharTuple(',', TokenType.COMMA),\n\t\tnew CharTuple('%', TokenType.PERCENT),\n\t\tnew CharTuple('~', TokenType.TILDE),\n\t\tnew CharTuple(':', TokenType.COLON, '=', TokenType.DECL_ASSIGN),\n\t\tnew CharTuple('!', TokenType.BANG, '=', TokenType.NOT_EQUALS),\n\t\t//new CharTuple('&', TokenType.AMPERSAND, '&', TokenType.DOUBLE_AMPERSAND),\n\t\tnew CharTuple('|', TokenType.PIPE, '|', TokenType.DOUBLE_PIPE),\n\t\tnew CharTuple('?', TokenType.QUEST),\n\t\tnew CharTuple('#', TokenType.HASH),\n\t\tnew CharTuple('@', TokenType.AT),\n\t\tnew CharTuple('+', TokenType.PLUS, '=', TokenType.PLUS_ASSIGN),\n\t\tnew CharTuple('*', TokenType.STAR, '=', TokenType.STAR_ASSIGN),\n\t\tnew CharTuple('>', TokenType.GREATERTHAN, '=', TokenType.GREATERTHAN_EQUALS),\n\t\tnew CharTuple('>', TokenType.GREATERTHAN, '=', TokenType.GREATERTHAN_EQUALS),\n\t\tnew CharTuple('^', TokenType.CARET),\n\t};\n\t\n\tpublic List<Token> parse(SourceReader reader) throws IOException {\n\t\t\n\t\tList<Token> tokens = new ArrayList<Token>();\n\t\t\n\t\treading: while(reader.hasNext()) {\n\t\t\t\n\t\t\treader.skipChars(\"\\t \");\n\t\t\tif(!reader.hasNext()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint index = reader.mark();\n\t\t\t\n\t\t\tchar c = reader.peek();\n\t\t\tif(c == ';' || c == '\\n' || c == '\\r') {\n\t\t\t\treader.read();\n\t\t\t\twhile(reader.hasNext() && (reader.peek() == '\\n' || reader.peek() == '\\r')) {\n\t\t\t\t\treader.read();\n\t\t\t\t}\n\t\t\t\ttokens.add(new Token(index, 1, TokenType.LINESEP));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '\\\\') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '\\\\') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.DOUBLE_BACKSLASH));\n\t\t\t\t} else if(c2 == '\\n') {\n\t\t\t\t\treader.read(); // Just skip both of'em (line continuation)\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.BACKSLASH));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(CharTuple candidate: chars) {\n\t\t\t\tToken token = candidate.handle(index, c, reader);\n\t\t\t\tif(token != null) {\n\t\t\t\t\ttokens.add(token);\n\t\t\t\t\tcontinue reading;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tif(c == '\"') {\n\t\t\t\treader.read();\n\t\t\t\t// TODO: optimize. readStringLiteral actually stores it into a String, but we don't care\n\t\t\t\ttry {\n\t\t\t\t\treader.readStringLiteral();\n\t\t\t\t} catch(EOFException eof) {\n\t\t\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 0), \"Never-ending string literal (reached end of file)\");\n\t\t\t\t}\n\t\t\t\ttokens.add(new Token(index + 1,\n\t\t\t\t\t\treader.mark() - index - 2,\n\t\t\t\t\t\tTokenType.STRING_LIT));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '\\'') {\n\t\t\t\treader.read();\n\t\t\t\ttry {\n\t\t\t\t\treader.readCharLiteral();\n\t\t\t\t\ttokens.add(new Token(index + 1, \n\t\t\t\t\t\t\treader.mark() - index - 2,\n\t\t\t\t\t\t\tTokenType.CHAR_LIT));\n\t\t\t\t\tcontinue;\n\t\t\t\t} catch(SyntaxError e) {\n\t\t\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 0), e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '/') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '=') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.SLASH_ASSIGN));\n\t\t\t\t} else if(c2 == '/') {\n\t\t\t\t\treader.readLine();\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.LINESEP));\n\t\t\t\t} else if(c2 == '*') {\n\t\t\t\t\treader.read();\n\t\t\t\t\tchar c3 = reader.peek();\n\t\t\t\t\tif(c3 == '*') {\n\t\t\t\t\t\treader.read();\n\t\t\t\t\t\treader.readUntil(new String[] {\"*/\"}, true);\n\t\t\t\t\t\ttokens.add(new Token(index, reader.mark() - index, TokenType.OOCDOC));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treader.readUntil(new String[] {\"*/\"}, true);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.SLASH));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '-') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '>') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.ARROW));\n\t\t\t\t} else if(c2 == '=') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.MINUS_ASSIGN));\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.MINUS));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '<') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '=') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.LESSTHAN_EQUALS));\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.LESSTHAN));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '=') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '>') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.DOUBLE_ARROW));\n\t\t\t\t} else if(c2 == '=') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.EQUALS));\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.ASSIGN));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '&') {\n\t\t\t\t// read the precious one\n\t\t\t\treader.rewind(1);\n\t\t\t\tchar cprev = reader.read();\n\t\t\t\treader.read(); // skip the '&'\n\t\t\t\tboolean binary = false;\n\t\t\t\tif(cprev == ' ') binary = true;\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == '&') {\n\t\t\t\t\treader.read();\n\t\t\t\t\ttokens.add(new Token(index, 2, TokenType.DOUBLE_AMPERSAND));\n\t\t\t\t} else if(binary) {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.BINARY_AND));\n\t\t\t\t} else {\n\t\t\t\t\ttokens.add(new Token(index, 1, TokenType.AMPERSAND));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(c == '0') {\n\t\t\t\treader.read();\n\t\t\t\tchar c2 = reader.peek();\n\t\t\t\tif(c2 == 'x') {\n\t\t\t\t\treader.read();\n\t\t\t\t\tString lit = reader.readMany(\"0123456789abcdefABCDEF\", \"_\", true);\n\t\t\t\t\tif(lit.length() == 0) {\n\t\t\t\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 0), \"Empty hexadecimal number literal\");\n\t\t\t\t\t}\n\t\t\t\t\ttokens.add(new Token(index + 2, reader.mark()\n\t\t\t\t\t\t\t- index - 2, TokenType.HEX_INT));\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if(c2 == 'c') {\n\t\t\t\t\treader.read();\n\t\t\t\t\tString lit = reader.readMany(\"01234567\", \"_\", true);\n\t\t\t\t\tif(lit.length() == 0) {\n\t\t\t\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 0), \"Empty octal number literal\");\n\t\t\t\t\t}\n\t\t\t\t\ttokens.add(new Token(index + 2, reader.mark()\n\t\t\t\t\t\t\t- index - 2, TokenType.OCT_INT));\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if(c2 == 'b') {\n\t\t\t\t\treader.read();\n\t\t\t\t\tString lit = reader.readMany(\"01\", \"_\", true);\n\t\t\t\t\tif(lit.length() == 0) {\n\t\t\t\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 0), \"Empty binary number literal\");\n\t\t\t\t\t}\n\t\t\t\t\ttokens.add(new Token(index + 2, reader.mark()\n\t\t\t\t\t\t\t- index - 2, TokenType.BIN_INT));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(Character.isDigit(c)) {\n\t\t\t\treader.readMany(\"0123456789\", \"_\", true);\n\t\t\t\tif(reader.peek() == '.') {\n\t\t\t\t\treader.read();\n\t\t\t\t\tif(reader.peek() != '.') {\n\t\t\t\t\t\treader.readMany(\"0123456789\", \"_\", true);\n\t\t\t\t\t\treader.readExponent();\n\t\t\t\t\t\ttokens.add(new Token(index, reader.mark() - index,\n\t\t\t\t\t\t\t\tTokenType.DEC_FLOAT));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treader.rewind(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbyte type = TokenType.DEC_INT;\n\t\t\t\t\n\t\t\t\tif (reader.readExponent()) {\n\t\t\t\t\ttype = TokenType.DEC_FLOAT;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttokens.add(new Token(index, reader.mark() - index, type));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(reader.skipName()) {\n\t\t\t\tString name = reader.getSlice(index, reader.mark() - index);\n\t\t\t\tfor(Name candidate: names) {\n\t\t\t\t\tif(candidate.name.equals(name)) {\n\t\t\t\t\t\ttokens.add(new Token(index, name.length(), candidate.tokenType));\n\t\t\t\t\t\tcontinue reading;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttokens.add(new Token(index, name.length(), TokenType.NAME));\n\t\t\t\tcontinue reading;\n\t\t\t}\n\t\t\tthrow new CompilationFailedError(reader.getLocation(index, 1),\n\t\t\t\t\t\"Unexpected input '\"+SourceReader.spelled(reader.peek())+\"'\");\n\t\t\t\n\t\t}\n\t\t\n\t\ttokens.add(new Token(reader.mark(), 0, TokenType.LINESEP));\n\t\t\n\t\treturn tokens;\n\t}\n\t\n}\n","lineNo":344}
{"Smelly Sample":"package org.ubi;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Utility class to read blocks of text.\n * Mostly useful for keeping track of line number/positions (for accurate\n * error messages, @see SyntaxError).\n * Has builtin methods for reading C-like elements/tokens, like\n * string literals/char literals, blocks, etc.\n * @author Amos Wenger\n */\npublic class SourceReader {\n\t\n\t/**\n\t * The case sensibility setting, e.g. whether 'A' == 'a' or 'A' != 'a'\n\t * @author Amos Wenger\n\t */\n    public enum CaseSensibility {\n    \t/** Don't make a difference between capitalized characters and others, e.g. 'A' != 'a' */\n        SENSITIVE,\n        /** Distinguish between capitalized characters and others, e.g. 'A' == 'a' */\n        INSENSITIVE\n    }\n\n    protected ArrayList<Integer> newlineIndices;\n    protected String fileName;\n    protected char[] content;\n    protected int index;\n    protected int mark;\n\n    /**\n     * Read the content of a the file at place \"path\"\n     * @param path The path of the file to be read\n     * @return a SourceReader reading from the file content\n     * @throws java.io.IOException if file can't be found or opened for reading\n     * (or any other I/O exception, for that matter).\n     */\n    public static SourceReader getReaderFromPath(String path) throws IOException {\n        return getReaderFromFile(new File(path));\n    }\n\n    /**\n     * Read the content of a the file pointed by \"file\"\n     * @param file The file object from which to read\n     * @return a SourceReader reading from the file content\n     * @throws java.io.IOException if file can't be found or opened for reading\n     * (or any other I/O exception, for that matter).\n     */\n    public static SourceReader getReaderFromFile(File file) throws IOException {\n        return new SourceReader(file.getPath(), readToString(file));\n    }\n    \n    /**\n     * Read the content of a string\n     * @param path The path this string came from. Can be an URL, a file path, etc.\n     * anything descriptive, really, even \"<system>\" or \"<copy-protected>\" ^^\n     * @param content\n     * @return\n     */\n    public static SourceReader getReaderFromText(String path, String content) {\n\t\treturn new SourceReader(path, content);\n\t}\n    \n    /**\n     * Read the content of a the file pointed by \"file\"\n     * @param file The file object from which to read\n     * @return a SourceReader reading from the file content\n     * @throws java.io.IOException if file can't be found or opened for reading\n     * (or any other I/O exception, for that matter).\n     */\n    public static String readToString(File file) throws IOException {\n        char[] buffer = new char[8192];\n        FileReader fR = new FileReader(file);\n        StringBuilder content = new StringBuilder((int) file.length());\n        int length;\n        while((length = fR.read(buffer)) != -1) {\n            content.append(buffer, 0, length);\n        }\n        fR.close();\n        return content.toString();\n    }\n\n\n    /**\n     * Create a new SourceReader\n     * @param filePath The filepath is used in locations, for accurate\n     * error messages @see SyntaxError\n     * @param content The content to read from.\n     */\n    protected SourceReader(String filePath, String content) {\n        this.fileName = filePath;\n        this.content = content.toCharArray();\n        this.index = 0;\n        this.mark = 0;\n        this.newlineIndices = new ArrayList<Integer> ();\n    }\n\n    /**\n     * Read one character from the source at current position.\n     * @return The character read\n     * @throws EOFException When the end of the file is reached.\n     */\n    public char read() throws EOFException {\n        if(index + 1 > content.length) {\n            throw new EOFException(\"Parsing ended. Parsed\"+index\n            \t\t+\" chars, \"+getLineNumber()+\" lines total.\");\n        }\n        char character = content[index++];\n        if(character == '\\n') {\n            if(newlineIndices.isEmpty() || newlineIndices.get(newlineIndices.size() - 1).intValue() < index) {\n                newlineIndices.add(new Integer(index));\n            }\n        }\n        return character;\n    }\n    \n    /**\n     * Read one character from the source at current position, without advancing\n     * the pointer\n     * @return The character read\n     * @throws EOFException When the end of the file is reached.\n     */\n    public char peek() {\n\n    \treturn content[index];\n    \t\n\t}\n\n\n    /**\n     * Save the current position, allowing it to be restored later with the reset()\n     *\n     * <i>Note : functions from SourceReader may call mark(), thus overwriting the saved\n     * position. If you want to be safe, assign the return value from mark() to an int,\n     * which you can later pass to reset(int).<\/i>\n     *\n     * Example :\n     * <code>\n     * int mark = sourceReader.mark();\n     * sourceReader.readUntil(...);\n     * sourceReader.reset(mark);\n     * <\/code>\n     *\n     * @return The current position\n     */\n    public int mark() {\n        this.mark = index;\n        return mark;\n    }\n\n    /**\n     * Restore position to the last saved with mark()\n     */\n    public void reset() {\n        this.index = this.mark;\n    }\n\n    /**\n     * Restore position to the given one\n     * @param index The position to jump to\n     */\n    public void reset(int index) {\n        this.index = index;\n    }\n\n    /**\n     * Rewind position from given offset.\n     * (Subtracts offset from index)\n     * @param index The position to jump to\n     */\n    public void rewind(int offset) {\n        this.index -= offset;\n    }\n    \n    /**\n     * Advance position from given offset.\n     * @param offset\n     * @throws EOFException \n     */\n    public void skip(int offset) throws EOFException {\n    \tif(offset < 0) {\n    \t\trewind(-offset);\n    \t} else {\n    \t\tfor(int i = 0; i < offset; i++) {\n    \t\t\tread();\n    \t\t}\n    \t}\n\t}\n\n    /**\n     * @return the current line number\n     */\n    public int getLineNumber() {\n        int lineNumber = 0;\n        while(lineNumber < newlineIndices.size() && newlineIndices.get(lineNumber).intValue() <= index) {\n            lineNumber++;\n        }\n        return lineNumber + 1;\n    }\n\n    /**\n     * @return the current position in line (e.g. number of characters since the last newline\n     */\n    public int getLinePos() {\n        int lineNumber = getLineNumber();\n        if(lineNumber == 1) {\n            return index + 1;\n        }\n\t\treturn index - newlineIndices.get(getLineNumber() - 2).intValue() + 1;\n    }\n\n    /**\n     * @return false if positioned at the end of the content.\n     */\n    public boolean hasNext() {\n        return (index < content.length);\n    }\n\n    public String getFileName() {\n        return fileName;\n    }\n\n    /**\n     * @return the current file location, containing the file number, line position, and index\n     */\n    public FileLocation getLocation() {\n        return new FileLocation(fileName, getLineNumber(), getLinePos(), index);\n    }\n    \n    public FileLocation getLocation(Locatable loc) {\n    \treturn getLocation(loc.getStart(), loc.getLength());\n    }\n    \n    public FileLocation getLocation(int start, int length) {\n    \tint mark = mark();\n    \treset(0);\n    \ttry {\n    \t\tskip(start);\n    \t} catch(EOFException e) {}\n    \tFileLocation loc = getLocation();\n    \tloc.length = length;\n    \treset(mark);\n\t\treturn loc;\n\t}\n\n    /**\n     * @param character\n     * @return true if the last-but-one char equals 'character'.\n     */\n    public boolean backMatches(char character, boolean trueIfStartpos) {\n        if(index <= 0) {\n            return trueIfStartpos;\n        }\n\t\treturn content[index - 1] == character;\n    }\n\n    /**\n     * Test if each candidate in \"candidates\" matches the next characters in the content.\n     * @param candidates\n     * @param keepEnd If false, will reset to the initial position before returning.\n     * If true, will stay after the matched candidate.\n     * @return -1 if no candidate matched. Otherwise, the index of the first matching candidate.\n     * @throws java.io.EOFException\n     * @throws java.io.IOException\n     */\n    public int matches(List<String> candidates, boolean keepEnd) throws EOFException {\n        int match = -1;\n        int count = 0;\n        search: for(String candidate: candidates) {\n            if(matches(candidate, keepEnd, CaseSensibility.SENSITIVE)) {\n                match = count;\n                break search;\n            }\n            ++count;\n        }\n        return match;\n    }\n    \n    /**\n     * Test if a \"candidate\" matches the next character in the content, and if there's\n     * whitespace after it.\n     * @param candidate\n     * @param keepEnd\n     * @return\n     * @throws EOFException\n     */\n    public boolean matchesSpaced(String candidate, boolean keepEnd) throws EOFException {\n    \tint mark = mark();\n    \tboolean result = matches(candidate, true) && hasWhitespace(false);\n    \tif(!keepEnd) {\n    \t\treset(mark);\n    \t}\n    \treturn result;\n    }\n    \n    /**\n     * Test if a \"candidate\" matches the next character in the content, and if there's\n     * characters other than \"A-Za-z0-9_\" after iti\n     * @param candidate\n     * @param keepEnd\n     * @return\n     * @throws EOFException\n     */\n    public boolean matchesNonident(String candidate, boolean keepEnd) throws EOFException {\n    \tint mark = mark();\n    \tboolean result = matches(candidate, true);\n    \tchar c = peek();\n    \tresult &= !((c == '_') || Character.isLetterOrDigit(c));\n    \tif(!keepEnd) {\n    \t\treset(mark);\n    \t}\n    \treturn result;\n    }\n\n    /**\n     * Test if a \"candidate\" matches the next characters in the content.\n     * It is case-sensitive by default\n     * @param candidate\n     * @param keepEnd If false, will reset to the initial position before returning.\n     * If true, will stay after the matched candidate.\n     * @return true if the candidate matches, false otherwise.\n     * \n     */\n    public boolean matches(String candidate, boolean keepEnd) throws EOFException {\n        return matches(candidate, keepEnd, CaseSensibility.SENSITIVE);\n    }\n\n    /**\n     * Test if a \"candidate\" matches the next characters in the content.\n     * @param candidate\n     * @param keepEnd If false, will reset to the initial position before returning.\n     * If true, will stay after the matched candidate.\n     * @param caseMode either Case.SENSITIVE or Case.INSENSITIVE\n     * @return true if the candidate matches, false otherwise.\n     */\n    public boolean matches(String candidate, boolean keepEnd, CaseSensibility caseMode) throws EOFException {\n\n        mark();\n        int i = 0;\n        char c, c2;\n        boolean result = true;\n        while(i < candidate.length()) {\n            c = read();\n            c2 = candidate.charAt(i);\n            if(c2 != c) {\n                if((caseMode == CaseSensibility.SENSITIVE) || (Character.toLowerCase(c2) != Character.toLowerCase(c))) {\n                    result = false;\n                    break;\n                }\n            }\n            i++;\n        }\n        if(!result || !keepEnd) {\n            reset();\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Read a C-style name (a string containing [A-Za-z0-9_] characters) and return it.\n     * @return the read name\n     */\n    public boolean skipName() throws EOFException {\n\n        if(hasNext()) {\n            char chr = read();\n            if(!Character.isLetter(chr) && chr != '_') { \n                rewind(1);\n                return false;\n            }\n        }\n\n        read : while(hasNext()) {\n            char chr = read();\n            if(!Character.isLetterOrDigit(chr) && chr != '_' && chr != '!') {\n            \trewind(1);\n                break read;\n            }\n        }\n\n        return true;\n\n    }\n    \n    /**\n     * Read a C-style name (a string containing [A-Za-z0-9_] characters) and return it.\n     * @return the read name\n     */\n    public String readName() throws EOFException {\n\n        StringBuilder sB = new StringBuilder();\n\n        mark();\n        if(hasNext()) {\n            char chr = read();\n            if(Character.isLetter(chr) || chr == '_') {\n                sB.append(chr);\n            } else {\n            \trewind(1);\n                return \"\";\n            }\n        }\n\n        read : while(hasNext()) {\n            mark();\n            char chr = read();\n            if(Character.isLetterOrDigit(chr) || chr == '_' || chr == '!') {\n                sB.append(chr);\n            } else {\n            \trewind(1);\n                break read;\n            }\n        }\n\n        return sB.toString();\n\n    }\n\n    /**\n     * Read until a newline character and return the read input\n     * @return the read input\n     */\n    public String readLine() throws EOFException {\n\n        return readUntil('\\n', true);\n\n    }\n\n    /**\n     * Read a C-style single-line comment (ignore a line).\n     * C-style single-line comments are prefixed by \"//\"\n     */\n    public void readSingleComment() throws EOFException {\n        readLine();\n    }\n\n    /**\n     * Read a C-style multi-line comment (ignore until \"*\\/\").\n     * C-style multi-line comments are prefixed by \"/*\" and \"*\\/\"\n     */\n    public void readMultiComment() throws EOFException {\n        while(!matches(\"*/\", true, CaseSensibility.SENSITIVE)) { read(); }\n    }\n    \n    /**\n     * Read as many times candidates as we can ! Ignoring any char\n     * in 'ignored'.\n     * @param candidates\n     * @param ignored\n     * @param keepEnd\n     * @return\n     */\n    public String readMany(String candidates, String ignored, boolean keepEnd) throws EOFException {\n\n        StringBuilder sB = new StringBuilder();\n\n        int myMark = mark();\n        while(hasNext()) {\n            char c = read();\n            if(candidates.indexOf(c) != -1) {\n                sB.append(c);\n            } else if(ignored.indexOf(c) != -1) {\n                // look up in the sky, and think of how lucky you are and others aren't.\n            } else {\n            \tif(keepEnd) {\n            \t\trewind(1); // We went one too far.\n            \t}\n                break;\n            }\n        }\n\n        if(!keepEnd) {\n            reset(myMark);\n        }\n\n        return sB.toString();\n\n    }\n\n    /**\n     * Read a C-style character literal, e.g. any character or an escape sequence,\n     * and return it as a char.\n     */\n    @SuppressWarnings(\"fallthrough\")\n\tpublic char readCharLiteral() throws EOFException, SyntaxError {\n\n        mark();\n        char c = read();\n        switch(c) {\n            case '\\'':\n                throw new SyntaxError(getLocation(), \"Empty char literal !\");\n            case '\\\\':\n                char c2 = read();\n                switch(c2) {\n                    case '\\\\': // backslash\n                        c = '\\\\'; break;\n                    case '0': // null char\n                        c = '\\0'; break;\n                    case 'n': // newline\n                        c = '\\n'; break;\n                    case 't': // tab\n                        c = '\\t'; break;\n                    case 'v': // vertical tab\n                        c = '\\013'; break;\n                    case 'b': // backspace\n                        c = '\\b'; break;\n                    case 'f': // form feed\n                        c = '\\f'; break;\n                    case 'r': // carriage return\n                        c = '\\r'; break;\n                    case '\\'': // simple quote\n                        c = '\\''; break;\n                    default:\n                    \tthrow new SyntaxError(getLocation(), \"Invalid escape sequence : \"+spelled(c));\n                }\n            // intentional fallthrough\n            default:\n                c2 = read();\n                if(c2 != '\\'') {\n                \tthrow new SyntaxError(getLocation(), \"Char literal too long. Expected ', found \"+spelled(c2));\n                }\n                return c;\n        }\n        \n    }\n    \n    /**\n     * Parse a C-style character literal from an input string, e.g. any character\n     * or an escape sequence, and return it as a char.\n     */\n    @SuppressWarnings(\"fallthrough\")\n\tpublic static char parseCharLiteral(String input) throws SyntaxError {\n    \t\n        char c = input.charAt(0);\n        int supposedLength = 1;\n        switch(c) {\n            case '\\'':\n                throw new SyntaxError(null, \"Empty char literal !\");\n            case '\\\\':\n            \tsupposedLength++;\n                char c2 = input.charAt(1);\n                switch(c2) {\n                    case '\\\\': // backslash\n                        c = '\\\\'; break;\n                    case '0': // null char\n                        c = '\\0'; break;\n                    case 'n': // newline\n                        c = '\\n'; break;\n                    case 't': // tab\n                        c = '\\t'; break;\n                    case 'v': // vertical tab\n                        c = '\\013'; break;\n                    case 'b': // backspace\n                        c = '\\b'; break;\n                    case 'f': // form feed\n                        c = '\\f'; break;\n                    case 'r': // carriage return\n                        c = '\\r'; break;\n                    case '\\'': // simple quote\n                        c = '\\''; break;\n                    default:\n                    \tthrow new SyntaxError(null, \"Invalid escape sequence : \"+spelled(c));\n                }\n            // intentional fallthrough\n            default:\n                if(input.length() > supposedLength) {\n                \tthrow new SyntaxError(null, \"Char literal too long.\");\n                }\n                return c;\n        }\n    \t\n\t}\n    \n    public static String parseStringLiteral(String string) {\n\n    \tint index = 0;\n    \tStringBuilder buffer = new StringBuilder();\n        char c;\n        while(index < string.length()) {\n            c = string.charAt(index++);\n            switch(c) {\n                case '\\\\':\n                    char c2 = string.charAt(index++);\n                    switch(c2) {\n                        case '\\\\': // backslash\n                            buffer.append('\\\\'); break;\n                        case '0': // null char\n                            buffer.append('\\0'); break;\n                        case 'n': // newline\n                            buffer.append('\\n'); break;\n                        case 't': // tab\n                            buffer.append('\\t'); break;\n                        case 'b': // backspace\n                            buffer.append('\\b'); break;\n                        case 'f': // form feed\n                            buffer.append('\\f'); break;\n                        case 'r': // return\n                            buffer.append('\\r'); break;\n                        default: // delimiter\n                            buffer.append(c2); break;\n                    }\n                    break;\n                default:\n                \tbuffer.append(c);\n            }\n        }\n\n        return buffer.toString();\n    \t\n\t}\n\n    /**\n     * Read a C-like string literal, e.g. enclosed by '\"', and with C-like escape sequences,\n     * and return it.\n     * Note: eats the final '\"', no need to skip it.\n     */\n    public String readStringLiteral() throws EOFException {\n        return readStringLiteral('\"');\n    }\n\n    /**\n     * Read a string literal, e.g. enclosed by \"delimiter\", and with C-like escape sequences,\n     * and return it.\n     * Note: eats the final '\"', no need to skip it.\n     * @param delimiter The delimitr, e.g. \" (C-like), or ' (e.g. Python-like)\n     */\n    public String readStringLiteral(char delimiter) throws EOFException {\n\n        StringBuilder buffer = new StringBuilder();\n        char c;\n        reading : while(true) {\n            mark();\n            c = read();\n            switch(c) {\n                case '\\\\':\n                    char c2 = read();\n                    switch(c2) {\n                        case '\\\\': // backslash\n                            buffer.append('\\\\'); break;\n                        case '0': // null char\n                            buffer.append('\\0'); break;\n                        case 'n': // newline\n                            buffer.append('\\n'); break;\n                        case 't': // tab\n                            buffer.append('\\t'); break;\n                        case 'b': // backspace\n                            buffer.append('\\b'); break;\n                        case 'f': // form feed\n                            buffer.append('\\f'); break;\n                        case 'r': // return\n                            buffer.append('\\r'); break;\n                        default: // delimiter\n                            if(c2 == delimiter) { // freakin' java switches. *growl*\n                                buffer.append(delimiter);\n                            } break;\n                    }\n                    break;\n                default: // TODO : wonder if newline is a syntax error in a string literal\n                \tif(c == delimiter) {\n                \t\tbreak reading;\n                \t}\n                    buffer.append(c);\n            }\n        }\n\n        return buffer.toString();\n\n    }\n\n    /**\n     * Return true if there's any whitespace after the current position.\n     * @param keep If true, will have the same effect as skipWhitespace\n     * If false, the position will be left unchanged.\n     * @return true if there was any whitespace.\n     * @throws java.io.IOException Go look in the closet, 3rd door left.\n     */\n    public boolean hasWhitespace(boolean skip) throws EOFException {\n\n        boolean has = false;\n        int myMark = mark();\n        while(hasNext()) {\n            int c = read();\n            if(Character.isWhitespace(c)) {\n            \thas = true;\n            } else {\n            \trewind(1);\n            \tbreak;\n            }\n        }\n\n        if(!skip) {\n            reset(myMark);\n        }\n\n        return has;\n\n    }\n\n    /**\n     * Ignore the next characters which are whitespace (e.g. spaces, tabulations,\n     * newlines, linefeeds, ie. anything for which Character.isWhitespace(int) is true.\n     * @throws java.io.IOException\n     */\n    public boolean skipWhitespace() throws EOFException {\n\n        while(hasNext()) {\n            int myMark = mark();\n            int c = read();\n            if(!Character.isWhitespace(c)) {\n                reset(myMark);\n                break;\n            }\n        }\n        return true;\n\n    }\n    \n    /**\n     * Ignore the next characters which are contained in the string 'chars'\n     * @throws java.io.IOException\n     */\n    public boolean skipChars(String chars) throws EOFException {\n\n        while(hasNext()) {\n            int myMark = mark();\n            int c = read();\n            if(chars.indexOf(c) == -1) {\n                reset(myMark);\n                break;\n            }\n        }\n        return true;\n\n    }\n\n    /**\n     * Skip the next characters until a newline.\n     * @throws java.io.EOFException\n     */\n    public void skipLine() throws EOFException {\n        while(read() != '\\n') {\n        \t// Go on with the loop, don't look back.\n        }\n    }\n\n    /**\n     * Read until the character \"chr\", and return the characters read.\n     * Example:\n     * <code>\n     * String myLine = sourceReader.readUntil(';');\n     * <\/code>\n     * @param chr The end delimiter.\n     * @throws java.io.EOFException\n     */\n    public String readUntil(char chr) throws EOFException {\n        return readUntil(chr, false);\n    }\n\n    /**\n     * Read until the character \"chr\", and return the characters read.\n     * @param chr The end delimiter.\n     * @param keepEnd If false, leave the position before the end delimiter.\n     * If true, include the delimiter in the returned String, and leave the\n     * position after.\n     * @throws java.io.EOFException\n     */\n    public String readUntil(char chr, boolean keepEnd) throws EOFException {\n\n        StringBuilder sB = new StringBuilder();\n\n        char chrRead = 0;\n        while(hasNext() && (chrRead = read()) != chr) {\n            sB.append(chrRead);\n        }\n        if(!keepEnd) {\n            reset(index - 1); // chop off the last character\n        } else if(chrRead != 0) {\n            sB.append(chr);\n        }\n        \n        return sB.toString();\n\n    }\n\n    /**\n     * Read until one of the Strings in \"matches\" matches, and return the characters read.\n     * By default, do not include the matching end delimiter in the resulting String, and leave\n     * the position before the matching end delimiter.\n     * @param readUntil The potential end delimiters\n     * @throws java.io.EOFException\n     */\n    public String readUntil(String[] matches) throws EOFException {\n        return readUntil(matches, false);\n    }\n\n    /**\n     * Read until one of the Strings in \"matches\" matches, and return the characters read.\n     * @param readUntil The potential end delimiters\n     * @param keepEnd If false, leave the position before the matching end delimiter.\n     * If true, include the matching delimiter in the returned String, and leave the\n     * position after.\n     * @throws java.io.EOFException\n     */\n    public String readUntil(String[] matches, boolean keepEnd) throws EOFException {\n\n        StringBuilder sB = new StringBuilder();\n        \n        try { while(hasNext()) {\n            for(String match: matches) {\n                if(matches(match, keepEnd, CaseSensibility.SENSITIVE)) {\n                    if(keepEnd) {\n                        sB.append(match);\n                    }\n                    return sB.toString();\n                }\n            }\n            sB.append(read());\n        } } catch(EOFException e) {\n        \t// Normal operation.\n        }\n\n        return sB.toString();\n\n    }\n\n    /**\n     * Read until the end of file, and return the result.\n     */\n    public String readUntilEOF() {\n\n        StringBuilder output = new StringBuilder();\n        \n        try { while(hasNext()) {\n           output.append(read());\n        } } catch(EOFException e) {\n        \t// Well, that's the point\n        }\n\n        return output.toString();\n\n    }\n\n    /**\n     * Read a block delimited by \"start\" and \"end\". It deals with nested blocks, e.g.\n     * with '{' and '}', it will match '{{}}' in one piece.\n     * Note : the final end delimiter is eaten, No need to skip it.\n     * @param startChr the start delimiter\n     * @param endChr the end delimiter\n     * @return the content of the block\n     * @throws org.ubi.SyntaxError\n     * @throws java.io.IOException\n     */\n    public String readBlock(char startChr, char endChr) throws SyntaxError, EOFException {\n        return readBlock(startChr, endChr, '\\0');\n    }\n\n    /**\n     * Read a block delimited by \"start\" and \"end\" delimiters. It deals with nested blocks, e.g.\n     * with '{' and '}', it will match '{{}}' in one piece.\n     * The escape character (escapeChar) allows to include the endDelimiter in the block,\n     * e.g. with '\"' and '\"' delimiters, and '\\\\' escapeChar, there can be escape sequence in\n     * what looks obviously like a String literal.\n     * Note : the final end delimiter is eaten, No need to skip it.\n     * @param startChr the start delimiter\n     * @param endChr the end delimiter\n     * @return the content of the block\n     * @throws org.ubi.SyntaxError\n     * @throws java.io.IOException\n     */\n    public String readBlock(char startChr, char endChr, char escapeChar) throws SyntaxError, EOFException {\n\n        skipWhitespace();\n        mark();\n        char c;\n        if((c = read()) != startChr) {\n            reset();\n            throw new SyntaxError(getLocation(), \"Trying to read block delimited by \"\n            \t\t+spelled(startChr)+spelled(endChr)\n            \t\t+\", but \"+spelled(c)+\" found instead.\");\n        }\n\n        StringBuilder output = new StringBuilder();\n\n        int count = 1;\n        char chr;\n\n        try { reading: while(true) {\n            chr = read();\n            if(chr == escapeChar) {\n                output.append(chr);\n                chr = read();\n            }\n\n            if(chr == endChr) {\n                if(--count <= 0) {\n                    break reading;\n                }\n            } else if(chr == startChr) {\n                ++count;\n            }\n            output.append(chr);\n        } } catch(EOFException e) {\n        \t// Normal operation\n        }\n\n        return output.toString();\n\n    }\n\n    /**\n     * Read a block delimited by \"start\" and \"end\" delimiters. It deals with nested blocks, e.g.\n     * with '{' and '}', it will match '{{}}' in one piece.\n     * The escape character (escapeChar) allows to include the endDelimiter in the block,\n     * e.g. with '\"' and '\"' delimiters, and '\\\\' escapeChar, there can be escape sequence in\n     * what looks obviously like a String literal.\n     * Note : the final end delimiter is eaten, No need to skip it.\n     * @param start the start delimiter\n     * @param end the end delimiter\n     * @return the content of the block\n     * @throws org.ubi.SyntaxError\n     * @throws java.io.IOException\n     */\n    public String readBlock(String start, String end, char escapeChar) throws SyntaxError, EOFException {\n\n        skipWhitespace();\n        mark();\n        if(!matches(start, true)) {\n            char c = read();\n            reset();\n            throw new SyntaxError(getLocation(), \"Trying to read block delimited by \"\n            \t\t+spelled(start)+spelled(end)+\", but \"+spelled(c)+\" found instead.\");\n        }\n\n        StringBuilder output = new StringBuilder();\n\n        int count = 1;\n        char chr;\n\n        try { reading: while(true) {\n\n            if(matches(end, true)) {\n                if(--count <= 0) {\n                    break reading;\n                }\n            } else if(matches(start, true)) {\n                ++count;\n            } else {\n                chr = read();\n                if(chr == escapeChar) {\n                    output.append(chr);\n                    chr = read();\n                }\n                output.append(chr);\n            }\n\n        } } catch(EOFException e) {\n        \t// Normal operation\n        }\n\n        return output.toString();\n\n    }\n\n    /**\n     * Throws a SyntaxError with the current location\n     * @param string\n     */\n    public void err(String msg) throws SyntaxError {\n        throw new SyntaxError(getLocation(), msg);\n    }\n\n    /**\n     * Return a String representation of a character, with spelled\n     * out representations of newlines, tabs, etc.\n     * Example: spelled(32) = \" \";\n     * Example: spelled('\\n') = \"\\\\n\";\n     */\n    public static String spelled(char character) {\n        switch(character) {\n        \tcase '\\\"':\n        \t\treturn \"\\\\\\\"\";\n            case '\\t':\n                return \"\\\\t\";\n            case '\\f':\n            \treturn \"\\\\f\";\n            case '\\013':\n            \treturn \"\\\\v\";\n            case '\\r':\n                return \"\\\\r\";\n            case '\\n':\n                return \"\\\\n\";\n            case '\\0':\n                return \"\\\\0\";\n            case '\\'':\n            \treturn \"\\\\'\";\n            case '\\\\':\n            \treturn \"\\\\\\\\\";\n            default:\n                return Character.toString(character);\n        }\n    }\n    \n    public static void spelled(char character, Appendable output) throws IOException {\n        switch(character) {\n        \tcase '\\\"':\n        \t\toutput.append(\"\\\"\"); return;\n            case '\\t':\n            \toutput.append(\"\\\\t\"); return;\n            case '\\f':\n            \toutput.append(\"\\\\f\"); return;\n            case '\\b':\n            \toutput.append(\"\\\\b\"); return;\n            case '\\013':\n            \toutput.append(\"\\\\v\"); return;\n            case '\\r':\n            \toutput.append(\"\\\\r\"); return;\n            case '\\n':\n            \toutput.append(\"\\\\n\"); return;\n            case '\\0':\n            \toutput.append(\"\\\\0\"); return;\n            case '\\'':\n            \toutput.append(\"\\\\'\"); return;\n            case '\\\\':\n            \toutput.append(\"\\\\\"); return;\n            default:\n            \toutput.append(character); return;\n        }\n    }\n\n    /**\n     * Return a String representation of a String, with spelled\n     * out representations of newlines, tabs, etc.\n     * Example: spelled(32) = \" \";\n     * Example: spelled('\\n') = \"\\\\n\";\n     */\n    public static String spelled(String str) {\n\n\t\tStringBuilder output = new StringBuilder();\n\t\ttry {\n\t\t\tspelled(str, output);\n\t\t} catch (IOException e) {\n\t\t\tthrow new Error(e);\n\t\t}\n\t\treturn output.toString();\n\n    }\n\n\tpublic static void spelled(String str, Appendable output) throws IOException {\n\t\t\n\t\tint length = str.length();\n\t\tfor(int i = 0; i < length; i++) {\n\t\t\tspelled(str.charAt(i), output);\n        }\n\t\t\n\t}\n\n    /**\n     * Return the String containing the whole content this SourceReader is reading from.\n     */\n    public char[] getContent() {\n    \t\n        return content;\n        \n    }\n\n    /**\n     * Put the current index in token.start and return true.\n     * Intended to be used like this:\n     * <code>\n     * static Token token = new Token();\n     * void parse(SourceReader read) {\n     *   if(reader.startToken(token) && reader.matches(\"myKeyword\", true) && reader.endToken(token)) {\n     * \t   // Add a copy of the Token to the token list.\n     *   }\n     * }\n     * <\/code>\n     * @param token\n     * @return\n     */\n    public boolean startToken(Token token) {\n\n    \ttoken.start = index;\n    \treturn true;\n    \t\n    }\n    \n    \n    /**\n     * Put the current index in token.end and return true.\n     * Intended to be used like this:\n     * <code>\n     * static Token token = new Token();\n     * void parse(SourceReader read) {\n     *   if(reader.startToken(token) && reader.matches(\"myKeyword\", true) && reader.endToken(token)) {\n     * \t   // Add a copy of the Token to the token list.\n     *   }\n     * }\n     * <\/code>\n     * @param token\n     * @return\n     */\n    public boolean endToken(Token token) {\n \n    \ttoken.length = index - token.start;\n    \treturn true;\n    \t\n    }\n\n\t@SuppressWarnings(\"boxing\")\n\tpublic String getLine(int lineNumber) throws IOException {\n\n\t\tint mark = mark();\n\t\tif(newlineIndices.size() > lineNumber) {\n\t\t\treset(newlineIndices.get(lineNumber));\n\t\t} else {\n\t\t\treset(0);\n\t\t\tfor(int i = 1; i < lineNumber; i++) {\n\t\t\t\treadLine();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString line = readLine();\n\t\treset(mark);\n\t\treturn line;\n\t\t\n\t}\n\n\t/**\n\t * Get a slice of the source, specifying the start position\n\t * and the length of the slice.\n\t * @param start\n\t * @param length\n\t * @return\n\t */\n\tpublic String getSlice(int start, int length) {\n\n\t\treturn new String(content, start, length);\n\t\t\n\t}\n\n}\n","Method after Refactoring":"package org.ubi;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Utility class to read blocks of text.\n * Mostly useful for keeping track of line number/positions (for accurate\n * error messages, @see SyntaxError).\n * Has builtin methods for reading C-like elements/tokens, like\n * string literals/char literals, blocks, etc.\n * @author Amos Wenger\n */\npublic class SourceReader {\n\t\n\t/**\n\t * The case sensibility setting, e.g. whether 'A' == 'a' or 'A' != 'a'\n\t * @author Amos Wenger\n\t */\n    public enum CaseSensibility {\n    \t/** Don't make a difference between capitalized characters and others, e.g. 'A' != 'a' */\n        SENSITIVE,\n        /** Distinguish between capitalized characters and others, e.g. 'A' == 'a' */\n        INSENSITIVE\n    }\n\n    protected ArrayList<Integer> newlineIndices;\n    protected String fileName;\n    protected char[] content;\n    protected int index;\n    protected int mark;\n\n    /**\n     * Read the content of a the file at place \"path\"\n     * @param path The path of the file to be read\n     * @return a SourceReader reading from the file content\n     * @throws java.io.IOException if file can't be found or opened for reading\n     * (or any other I/O exception, for that matter).\n     */\n    public static SourceReader getReaderFromPath(String path) throws IOException {\n        return getReaderFromFile(new File(path));\n    }\n\n    /**\n     * Read the content of a the file pointed by \"file\"\n     * @param file The file object from which to read\n     * @return a SourceReader reading from the file content\n     * @throws java.io.IOException if file can't be found or opened for reading\n     * (or any other I/O exception, for that matter).\n     */\n    public static SourceReader getReaderFromFile(File file) throws IOException {\n        return new SourceReader(file.getPath(), readToString(file));\n    }\n    \n    /**\n     * Read the content of a string\n     * @param path The path this string came from. Can be an URL, a file path, etc.\n     * anything descriptive, really, even \"<system>\" or \"<copy-protected>\" ^^\n     * @param content\n     * @return\n     */\n    public static SourceReader getReaderFromText(String path, String content) {\n\t\treturn new SourceReader(path, content);\n\t}\n    \n    /**\n     * Read the content of a the file pointed by \"file\"\n     * @param file The file object from which to read\n     * @return a SourceReader reading from the file content\n     * @throws java.io.IOException if file can't be found or opened for reading\n     * (or any other I/O exception, for that matter).\n     */\n    public static String readToString(File file) throws IOException {\n        char[] buffer = new char[8192];\n        FileReader fR = new FileReader(file);\n        StringBuilder content = new StringBuilder((int) file.length());\n        int length;\n        while((length = fR.read(buffer)) != -1) {\n            content.append(buffer, 0, length);\n        }\n        fR.close();\n        return content.toString();\n    }\n\n\n    /**\n     * Create a new SourceReader\n     * @param filePath The filepath is used in locations, for accurate\n     * error messages @see SyntaxError\n     * @param content The content to read from.\n     */\n    protected SourceReader(String filePath, String content) {\n        this.fileName = filePath;\n        this.content = content.toCharArray();\n        this.index = 0;\n        this.mark = 0;\n        this.newlineIndices = new ArrayList<Integer> ();\n    }\n\n    /**\n     * Read one character from the source at current position.\n     * @return The character read\n     * @throws EOFException When the end of the file is reached.\n     */\n    public char read() throws EOFException {\n        if(index + 1 > content.length) {\n            throw new EOFException(\"Parsing ended. Parsed\"+index\n            \t\t+\" chars, \"+getLineNumber()+\" lines total.\");\n        }\n        char character = content[index++];\n        if(character == '\\n') {\n            if(newlineIndices.isEmpty() || newlineIndices.get(newlineIndices.size() - 1).intValue() < index) {\n                newlineIndices.add(new Integer(index));\n            }\n        }\n        return character;\n    }\n    \n    /**\n     * Read one character from the source at current position, without advancing\n     * the pointer\n     * @return The character read\n     * @throws EOFException When the end of the file is reached.\n     */\n    public char peek() {\n\n    \treturn content[index];\n    \t\n\t}\n\n\n    /**\n     * Save the current position, allowing it to be restored later with the reset()\n     *\n     * <i>Note : functions from SourceReader may call mark(), thus overwriting the saved\n     * position. If you want to be safe, assign the return value from mark() to an int,\n     * which you can later pass to reset(int).<\/i>\n     *\n     * Example :\n     * <code>\n     * int mark = sourceReader.mark();\n     * sourceReader.readUntil(...);\n     * sourceReader.reset(mark);\n     * <\/code>\n     *\n     * @return The current position\n     */\n    public int mark() {\n        this.mark = index;\n        return mark;\n    }\n\n    /**\n     * Restore position to the last saved with mark()\n     */\n    public void reset() {\n        this.index = this.mark;\n    }\n\n    /**\n     * Restore position to the given one\n     * @param index The position to jump to\n     */\n    public void reset(int index) {\n        this.index = index;\n    }\n\n    /**\n     * Rewind position from given offset.\n     * (Subtracts offset from index)\n     * @param index The position to jump to\n     */\n    public void rewind(int offset) {\n        this.index -= offset;\n    }\n    \n    /**\n     * Advance position from given offset.\n     * @param offset\n     * @throws EOFException \n     */\n    public void skip(int offset) throws EOFException {\n    \tif(offset < 0) {\n    \t\trewind(-offset);\n    \t} else {\n    \t\tfor(int i = 0; i < offset; i++) {\n    \t\t\tread();\n    \t\t}\n    \t}\n\t}\n\n    /**\n     * @return the current line number\n     */\n    public int getLineNumber() {\n        int lineNumber = 0;\n        while(lineNumber < newlineIndices.size() && newlineIndices.get(lineNumber).intValue() <= index) {\n            lineNumber++;\n        }\n        return lineNumber + 1;\n    }\n\n    /**\n     * @return the current position in line (e.g. number of characters since the last newline\n     */\n    public int getLinePos() {\n        int lineNumber = getLineNumber();\n        if(lineNumber == 1) {\n            return index + 1;\n        }\n\t\treturn index - newlineIndices.get(getLineNumber() - 2).intValue() + 1;\n    }\n\n    /**\n     * @return false if positioned at the end of the content.\n     */\n    public boolean hasNext() {\n        return (index < content.length);\n    }\n\n    public String getFileName() {\n        return fileName;\n    }\n\n    /**\n     * @return the current file location, containing the file number, line position, and index\n     */\n    public FileLocation getLocation() {\n        return new FileLocation(fileName, getLineNumber(), getLinePos(), index);\n    }\n    \n    public FileLocation getLocation(Locatable loc) {\n    \treturn getLocation(loc.getStart(), loc.getLength());\n    }\n    \n    public FileLocation getLocation(int start, int length) {\n    \tint mark = mark();\n    \treset(0);\n    \ttry {\n    \t\tskip(start);\n    \t} catch(EOFException e) {}\n    \tFileLocation loc = getLocation();\n    \tloc.length = length;\n    \treset(mark);\n\t\treturn loc;\n\t}\n\n    /**\n     * @param character\n     * @return true if the last-but-one char equals 'character'.\n     */\n    public boolean backMatches(char character, boolean trueIfStartpos) {\n        if(index <= 0) {\n            return trueIfStartpos;\n        }\n\t\treturn content[index - 1] == character;\n    }\n\n    /**\n     * Test if each candidate in \"candidates\" matches the next characters in the content.\n     * @param candidates\n     * @param keepEnd If false, will reset to the initial position before returning.\n     * If true, will stay after the matched candidate.\n     * @return -1 if no candidate matched. Otherwise, the index of the first matching candidate.\n     * @throws java.io.EOFException\n     * @throws java.io.IOException\n     */\n    public int matches(List<String> candidates, boolean keepEnd) throws EOFException {\n        int match = -1;\n        int count = 0;\n        search: for(String candidate: candidates) {\n            if(matches(candidate, keepEnd, CaseSensibility.SENSITIVE)) {\n                match = count;\n                break search;\n            }\n            ++count;\n        }\n        return match;\n    }\n    \n    /**\n     * Test if a \"candidate\" matches the next character in the content, and if there's\n     * whitespace after it.\n     * @param candidate\n     * @param keepEnd\n     * @return\n     * @throws EOFException\n     */\n    public boolean matchesSpaced(String candidate, boolean keepEnd) throws EOFException {\n    \tint mark = mark();\n    \tboolean result = matches(candidate, true) && hasWhitespace(false);\n    \tif(!keepEnd) {\n    \t\treset(mark);\n    \t}\n    \treturn result;\n    }\n    \n    /**\n     * Test if a \"candidate\" matches the next character in the content, and if there's\n     * characters other than \"A-Za-z0-9_\" after iti\n     * @param candidate\n     * @param keepEnd\n     * @return\n     * @throws EOFException\n     */\n    public boolean matchesNonident(String candidate, boolean keepEnd) throws EOFException {\n    \tint mark = mark();\n    \tboolean result = matches(candidate, true);\n    \tchar c = peek();\n    \tresult &= !((c == '_') || Character.isLetterOrDigit(c));\n    \tif(!keepEnd) {\n    \t\treset(mark);\n    \t}\n    \treturn result;\n    }\n\n    /**\n     * Test if a \"candidate\" matches the next characters in the content.\n     * It is case-sensitive by default\n     * @param candidate\n     * @param keepEnd If false, will reset to the initial position before returning.\n     * If true, will stay after the matched candidate.\n     * @return true if the candidate matches, false otherwise.\n     * \n     */\n    public boolean matches(String candidate, boolean keepEnd) throws EOFException {\n        return matches(candidate, keepEnd, CaseSensibility.SENSITIVE);\n    }\n\n    /**\n     * Test if a \"candidate\" matches the next characters in the content.\n     * @param candidate\n     * @param keepEnd If false, will reset to the initial position before returning.\n     * If true, will stay after the matched candidate.\n     * @param caseMode either Case.SENSITIVE or Case.INSENSITIVE\n     * @return true if the candidate matches, false otherwise.\n     */\n    public boolean matches(String candidate, boolean keepEnd, CaseSensibility caseMode) throws EOFException {\n\n        mark();\n        int i = 0;\n        char c, c2;\n        boolean result = true;\n        while(i < candidate.length()) {\n            c = read();\n            c2 = candidate.charAt(i);\n            if(c2 != c) {\n                if((caseMode == CaseSensibility.SENSITIVE) || (Character.toLowerCase(c2) != Character.toLowerCase(c))) {\n                    result = false;\n                    break;\n                }\n            }\n            i++;\n        }\n        if(!result || !keepEnd) {\n            reset();\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Read a C-style name (a string containing [A-Za-z0-9_] characters) and return it.\n     * @return the read name\n     */\n    public boolean skipName() throws EOFException {\n\n        if(hasNext()) {\n            char chr = read();\n            if(!Character.isLetter(chr) && chr != '_') { \n                rewind(1);\n                return false;\n            }\n        }\n\n        read : while(hasNext()) {\n            char chr = read();\n            if(!Character.isLetterOrDigit(chr) && chr != '_' && chr != '!') {\n            \trewind(1);\n                break read;\n            }\n        }\n\n        return true;\n\n    }\n    \n    /**\n     * Read a C-style name (a string containing [A-Za-z0-9_] characters) and return it.\n     * @return the read name\n     */\n    public String readName() throws EOFException {\n\n        StringBuilder sB = new StringBuilder();\n\n        mark();\n        if(hasNext()) {\n            char chr = read();\n            if(Character.isLetter(chr) || chr == '_') {\n                sB.append(chr);\n            } else {\n            \trewind(1);\n                return \"\";\n            }\n        }\n\n        read : while(hasNext()) {\n            mark();\n            char chr = read();\n            if(Character.isLetterOrDigit(chr) || chr == '_' || chr == '!') {\n                sB.append(chr);\n            } else {\n            \trewind(1);\n                break read;\n            }\n        }\n\n        return sB.toString();\n\n    }\n\n    /**\n     * Read until a newline character and return the read input\n     * @return the read input\n     */\n    public String readLine() throws EOFException {\n\n        return readUntil('\\n', true);\n\n    }\n\n    /**\n     * Read a C-style single-line comment (ignore a line).\n     * C-style single-line comments are prefixed by \"//\"\n     */\n    public void readSingleComment() throws EOFException {\n        readLine();\n    }\n\n    /**\n     * Read a C-style multi-line comment (ignore until \"*\\/\").\n     * C-style multi-line comments are prefixed by \"/*\" and \"*\\/\"\n     */\n    public void readMultiComment() throws EOFException {\n        while(!matches(\"*/\", true, CaseSensibility.SENSITIVE)) { read(); }\n    }\n    \n    /**\n     * Read as many times candidates as we can ! Ignoring any char\n     * in 'ignored'.\n     * @param candidates\n     * @param ignored\n     * @param keepEnd\n     * @return\n     */\n    public String readMany(String candidates, String ignored, boolean keepEnd) throws EOFException {\n\n        StringBuilder sB = new StringBuilder();\n\n        int myMark = mark();\n        while(hasNext()) {\n            char c = read();\n            if(candidates.indexOf(c) != -1) {\n                sB.append(c);\n            } else if(ignored.indexOf(c) != -1) {\n                // look up in the sky, and think of how lucky you are and others aren't.\n            } else {\n            \tif(keepEnd) {\n            \t\trewind(1); // We went one too far.\n            \t}\n                break;\n            }\n        }\n\n        if(!keepEnd) {\n            reset(myMark);\n        }\n\n        return sB.toString();\n\n    }\n\n    /**\n     * Read a C-style character literal, e.g. any character or an escape sequence,\n     * and return it as a char.\n     */\n    @SuppressWarnings(\"fallthrough\")\n\tpublic char readCharLiteral() throws EOFException, SyntaxError {\n\n        mark();\n        char c = read();\n        switch(c) {\n            case '\\'':\n                throw new SyntaxError(getLocation(), \"Empty char literal !\");\n            case '\\\\':\n                char c2 = read();\n                switch(c2) {\n                    case '\\\\': // backslash\n                        c = '\\\\'; break;\n                    case '0': // null char\n                        c = '\\0'; break;\n                    case 'n': // newline\n                        c = '\\n'; break;\n                    case 't': // tab\n                        c = '\\t'; break;\n                    case 'v': // vertical tab\n                        c = '\\013'; break;\n                    case 'b': // backspace\n                        c = '\\b'; break;\n                    case 'f': // form feed\n                        c = '\\f'; break;\n                    case 'r': // carriage return\n                        c = '\\r'; break;\n                    case '\\'': // simple quote\n                        c = '\\''; break;\n                    default:\n                    \tthrow new SyntaxError(getLocation(), \"Invalid escape sequence : \"+spelled(c));\n                }\n            // intentional fallthrough\n            default:\n                c2 = read();\n                if(c2 != '\\'') {\n                \tthrow new SyntaxError(getLocation(), \"Char literal too long. Expected ', found \"+spelled(c2));\n                }\n                return c;\n        }\n        \n    }\n    \n    /**\n     * Parse a C-style character literal from an input string, e.g. any character\n     * or an escape sequence, and return it as a char.\n     */\n    @SuppressWarnings(\"fallthrough\")\n\tpublic static char parseCharLiteral(String input) throws SyntaxError {\n    \t\n        char c = input.charAt(0);\n        int supposedLength = 1;\n        switch(c) {\n            case '\\'':\n                throw new SyntaxError(null, \"Empty char literal !\");\n            case '\\\\':\n            \tsupposedLength++;\n                char c2 = input.charAt(1);\n                switch(c2) {\n                    case '\\\\': // backslash\n                        c = '\\\\'; break;\n                    case '0': // null char\n                        c = '\\0'; break;\n                    case 'n': // newline\n                        c = '\\n'; break;\n                    case 't': // tab\n                        c = '\\t'; break;\n                    case 'v': // vertical tab\n                        c = '\\013'; break;\n                    case 'b': // backspace\n                        c = '\\b'; break;\n                    case 'f': // form feed\n                        c = '\\f'; break;\n                    case 'r': // carriage return\n                        c = '\\r'; break;\n                    case '\\'': // simple quote\n                        c = '\\''; break;\n                    default:\n                    \tthrow new SyntaxError(null, \"Invalid escape sequence : \"+spelled(c));\n                }\n            // intentional fallthrough\n            default:\n                if(input.length() > supposedLength) {\n                \tthrow new SyntaxError(null, \"Char literal too long.\");\n                }\n                return c;\n        }\n    \t\n\t}\n    \n    public static String parseStringLiteral(String string) {\n\n    \tint index = 0;\n    \tStringBuilder buffer = new StringBuilder();\n        char c;\n        while(index < string.length()) {\n            c = string.charAt(index++);\n            switch(c) {\n                case '\\\\':\n                    char c2 = string.charAt(index++);\n                    switch(c2) {\n                        case '\\\\': // backslash\n                            buffer.append('\\\\'); break;\n                        case '0': // null char\n                            buffer.append('\\0'); break;\n                        case 'n': // newline\n                            buffer.append('\\n'); break;\n                        case 't': // tab\n                            buffer.append('\\t'); break;\n                        case 'b': // backspace\n                            buffer.append('\\b'); break;\n                        case 'f': // form feed\n                            buffer.append('\\f'); break;\n                        case 'r': // return\n                            buffer.append('\\r'); break;\n                        default: // delimiter\n                            buffer.append(c2); break;\n                    }\n                    break;\n                default:\n                \tbuffer.append(c);\n            }\n        }\n\n        return buffer.toString();\n    \t\n\t}\n\n    /**\n     * Read a C-like string literal, e.g. enclosed by '\"', and with C-like escape sequences,\n     * and return it.\n     * Note: eats the final '\"', no need to skip it.\n     */\n    public String readStringLiteral() throws EOFException {\n        return readStringLiteral('\"');\n    }\n\n    /**\n     * Read a string literal, e.g. enclosed by \"delimiter\", and with C-like escape sequences,\n     * and return it.\n     * Note: eats the final '\"', no need to skip it.\n     * @param delimiter The delimitr, e.g. \" (C-like), or ' (e.g. Python-like)\n     */\n    public String readStringLiteral(char delimiter) throws EOFException {\n\n        StringBuilder buffer = new StringBuilder();\n        char c;\n        reading : while(true) {\n            mark();\n            c = read();\n            switch(c) {\n                case '\\\\':\n                    char c2 = read();\n                    switch(c2) {\n                        case '\\\\': // backslash\n                            buffer.append('\\\\'); break;\n                        case '0': // null char\n                            buffer.append('\\0'); break;\n                        case 'n': // newline\n                            buffer.append('\\n'); break;\n                        case 't': // tab\n                            buffer.append('\\t'); break;\n                        case 'b': // backspace\n                            buffer.append('\\b'); break;\n                        case 'f': // form feed\n                            buffer.append('\\f'); break;\n                        case 'r': // return\n                            buffer.append('\\r'); break;\n                        default: // delimiter\n                            if(c2 == delimiter) { // freakin' java switches. *growl*\n                                buffer.append(delimiter);\n                            } break;\n                    }\n                    break;\n                default: // TODO : wonder if newline is a syntax error in a string literal\n                \tif(c == delimiter) {\n                \t\tbreak reading;\n                \t}\n                    buffer.append(c);\n            }\n        }\n\n        return buffer.toString();\n\n    }\n\n    /**\n     * Return true if there's any whitespace after the current position.\n     * @param keep If true, will have the same effect as skipWhitespace\n     * If false, the position will be left unchanged.\n     * @return true if there was any whitespace.\n     * @throws java.io.IOException Go look in the closet, 3rd door left.\n     */\n    public boolean hasWhitespace(boolean skip) throws EOFException {\n\n        boolean has = false;\n        int myMark = mark();\n        while(hasNext()) {\n            int c = read();\n            if(Character.isWhitespace(c)) {\n            \thas = true;\n            } else {\n            \trewind(1);\n            \tbreak;\n            }\n        }\n\n        if(!skip) {\n            reset(myMark);\n        }\n\n        return has;\n\n    }\n\n    /**\n     * Ignore the next characters which are whitespace (e.g. spaces, tabulations,\n     * newlines, linefeeds, ie. anything for which Character.isWhitespace(int) is true.\n     * @throws java.io.IOException\n     */\n    public boolean skipWhitespace() throws EOFException {\n\n        while(hasNext()) {\n            int myMark = mark();\n            int c = read();\n            if(!Character.isWhitespace(c)) {\n                reset(myMark);\n                break;\n            }\n        }\n        return true;\n\n    }\n    \n    /**\n     * Ignore the next characters which are contained in the string 'chars'\n     * @throws java.io.IOException\n     */\n    public boolean skipChars(String chars) throws EOFException {\n\n        while(hasNext()) {\n            int myMark = mark();\n            int c = read();\n            if(chars.indexOf(c) == -1) {\n                reset(myMark);\n                break;\n            }\n        }\n        return true;\n\n    }\n\n    /**\n     * Skip the next characters until a newline.\n     * @throws java.io.EOFException\n     */\n    public void skipLine() throws EOFException {\n        while(read() != '\\n') {\n        \t// Go on with the loop, don't look back.\n        }\n    }\n\n    /**\n     * Read until the character \"chr\", and return the characters read.\n     * Example:\n     * <code>\n     * String myLine = sourceReader.readUntil(';');\n     * <\/code>\n     * @param chr The end delimiter.\n     * @throws java.io.EOFException\n     */\n    public String readUntil(char chr) throws EOFException {\n        return readUntil(chr, false);\n    }\n\n    /**\n     * Read until the character \"chr\", and return the characters read.\n     * @param chr The end delimiter.\n     * @param keepEnd If false, leave the position before the end delimiter.\n     * If true, include the delimiter in the returned String, and leave the\n     * position after.\n     * @throws java.io.EOFException\n     */\n    public String readUntil(char chr, boolean keepEnd) throws EOFException {\n\n        StringBuilder sB = new StringBuilder();\n\n        char chrRead = 0;\n        while(hasNext() && (chrRead = read()) != chr) {\n            sB.append(chrRead);\n        }\n        if(!keepEnd) {\n            reset(index - 1); // chop off the last character\n        } else if(chrRead != 0) {\n            sB.append(chr);\n        }\n        \n        return sB.toString();\n\n    }\n\n    /**\n     * Read until one of the Strings in \"matches\" matches, and return the characters read.\n     * By default, do not include the matching end delimiter in the resulting String, and leave\n     * the position before the matching end delimiter.\n     * @param readUntil The potential end delimiters\n     * @throws java.io.EOFException\n     */\n    public String readUntil(String[] matches) throws EOFException {\n        return readUntil(matches, false);\n    }\n\n    /**\n     * Read until one of the Strings in \"matches\" matches, and return the characters read.\n     * @param readUntil The potential end delimiters\n     * @param keepEnd If false, leave the position before the matching end delimiter.\n     * If true, include the matching delimiter in the returned String, and leave the\n     * position after.\n     * @throws java.io.EOFException\n     */\n    public String readUntil(String[] matches, boolean keepEnd) throws EOFException {\n\n        StringBuilder sB = new StringBuilder();\n        \n        try { while(hasNext()) {\n            for(String match: matches) {\n                if(matches(match, keepEnd, CaseSensibility.SENSITIVE)) {\n                    if(keepEnd) {\n                        sB.append(match);\n                    }\n                    return sB.toString();\n                }\n            }\n            sB.append(read());\n        } } catch(EOFException e) {\n        \t// Normal operation.\n        }\n\n        return sB.toString();\n\n    }\n\n    /**\n     * Read until the end of file, and return the result.\n     */\n    public String readUntilEOF() {\n\n        StringBuilder output = new StringBuilder();\n        \n        try { while(hasNext()) {\n           output.append(read());\n        } } catch(EOFException e) {\n        \t// Well, that's the point\n        }\n\n        return output.toString();\n\n    }\n\n    /**\n     * Read a block delimited by \"start\" and \"end\". It deals with nested blocks, e.g.\n     * with '{' and '}', it will match '{{}}' in one piece.\n     * Note : the final end delimiter is eaten, No need to skip it.\n     * @param startChr the start delimiter\n     * @param endChr the end delimiter\n     * @return the content of the block\n     * @throws org.ubi.SyntaxError\n     * @throws java.io.IOException\n     */\n    public String readBlock(char startChr, char endChr) throws SyntaxError, EOFException {\n        return readBlock(startChr, endChr, '\\0');\n    }\n\n    /**\n     * Read a block delimited by \"start\" and \"end\" delimiters. It deals with nested blocks, e.g.\n     * with '{' and '}', it will match '{{}}' in one piece.\n     * The escape character (escapeChar) allows to include the endDelimiter in the block,\n     * e.g. with '\"' and '\"' delimiters, and '\\\\' escapeChar, there can be escape sequence in\n     * what looks obviously like a String literal.\n     * Note : the final end delimiter is eaten, No need to skip it.\n     * @param startChr the start delimiter\n     * @param endChr the end delimiter\n     * @return the content of the block\n     * @throws org.ubi.SyntaxError\n     * @throws java.io.IOException\n     */\n    public String readBlock(char startChr, char endChr, char escapeChar) throws SyntaxError, EOFException {\n\n        skipWhitespace();\n        mark();\n        char c;\n        if((c = read()) != startChr) {\n            reset();\n            throw new SyntaxError(getLocation(), \"Trying to read block delimited by \"\n            \t\t+spelled(startChr)+spelled(endChr)\n            \t\t+\", but \"+spelled(c)+\" found instead.\");\n        }\n\n        StringBuilder output = new StringBuilder();\n\n        int count = 1;\n        char chr;\n\n        try { reading: while(true) {\n            chr = read();\n            if(chr == escapeChar) {\n                output.append(chr);\n                chr = read();\n            }\n\n            if(chr == endChr) {\n                if(--count <= 0) {\n                    break reading;\n                }\n            } else if(chr == startChr) {\n                ++count;\n            }\n            output.append(chr);\n        } } catch(EOFException e) {\n        \t// Normal operation\n        }\n\n        return output.toString();\n\n    }\n\n    /**\n     * Read a block delimited by \"start\" and \"end\" delimiters. It deals with nested blocks, e.g.\n     * with '{' and '}', it will match '{{}}' in one piece.\n     * The escape character (escapeChar) allows to include the endDelimiter in the block,\n     * e.g. with '\"' and '\"' delimiters, and '\\\\' escapeChar, there can be escape sequence in\n     * what looks obviously like a String literal.\n     * Note : the final end delimiter is eaten, No need to skip it.\n     * @param start the start delimiter\n     * @param end the end delimiter\n     * @return the content of the block\n     * @throws org.ubi.SyntaxError\n     * @throws java.io.IOException\n     */\n    public String readBlock(String start, String end, char escapeChar) throws SyntaxError, EOFException {\n\n        skipWhitespace();\n        mark();\n        if(!matches(start, true)) {\n            char c = read();\n            reset();\n            throw new SyntaxError(getLocation(), \"Trying to read block delimited by \"\n            \t\t+spelled(start)+spelled(end)+\", but \"+spelled(c)+\" found instead.\");\n        }\n\n        StringBuilder output = new StringBuilder();\n\n        int count = 1;\n        char chr;\n\n        try { reading: while(true) {\n\n            if(matches(end, true)) {\n                if(--count <= 0) {\n                    break reading;\n                }\n            } else if(matches(start, true)) {\n                ++count;\n            } else {\n                chr = read();\n                if(chr == escapeChar) {\n                    output.append(chr);\n                    chr = read();\n                }\n                output.append(chr);\n            }\n\n        } } catch(EOFException e) {\n        \t// Normal operation\n        }\n\n        return output.toString();\n\n    }\n\n    /**\n     * Throws a SyntaxError with the current location\n     * @param string\n     */\n    public void err(String msg) throws SyntaxError {\n        throw new SyntaxError(getLocation(), msg);\n    }\n\n    /**\n     * Return a String representation of a character, with spelled\n     * out representations of newlines, tabs, etc.\n     * Example: spelled(32) = \" \";\n     * Example: spelled('\\n') = \"\\\\n\";\n     */\n    public static String spelled(char character) {\n        switch(character) {\n        \tcase '\\\"':\n        \t\treturn \"\\\\\\\"\";\n            case '\\t':\n                return \"\\\\t\";\n            case '\\f':\n            \treturn \"\\\\f\";\n            case '\\013':\n            \treturn \"\\\\v\";\n            case '\\r':\n                return \"\\\\r\";\n            case '\\n':\n                return \"\\\\n\";\n            case '\\0':\n                return \"\\\\0\";\n            case '\\'':\n            \treturn \"\\\\'\";\n            case '\\\\':\n            \treturn \"\\\\\\\\\";\n            default:\n                return Character.toString(character);\n        }\n    }\n    \n    public static void spelled(char character, Appendable output) throws IOException {\n        switch(character) {\n        \tcase '\\\"':\n        \t\toutput.append(\"\\\"\"); return;\n            case '\\t':\n            \toutput.append(\"\\\\t\"); return;\n            case '\\f':\n            \toutput.append(\"\\\\f\"); return;\n            case '\\b':\n            \toutput.append(\"\\\\b\"); return;\n            case '\\013':\n            \toutput.append(\"\\\\v\"); return;\n            case '\\r':\n            \toutput.append(\"\\\\r\"); return;\n            case '\\n':\n            \toutput.append(\"\\\\n\"); return;\n            case '\\0':\n            \toutput.append(\"\\\\0\"); return;\n            case '\\'':\n            \toutput.append(\"\\\\'\"); return;\n            case '\\\\':\n            \toutput.append(\"\\\\\"); return;\n            default:\n            \toutput.append(character); return;\n        }\n    }\n\n    /**\n     * Return a String representation of a String, with spelled\n     * out representations of newlines, tabs, etc.\n     * Example: spelled(32) = \" \";\n     * Example: spelled('\\n') = \"\\\\n\";\n     */\n    public static String spelled(String str) {\n\n\t\tStringBuilder output = new StringBuilder();\n\t\ttry {\n\t\t\tspelled(str, output);\n\t\t} catch (IOException e) {\n\t\t\tthrow new Error(e);\n\t\t}\n\t\treturn output.toString();\n\n    }\n\n    public static void spelled(String str, Appendable output) throws IOException {\n    \t\n    \tspelled(str, output, false);\n    \t\n    }\n    \n    \n\tpublic static void spelled(String str, Appendable output, boolean doBackslashes) throws IOException {\n\t\t\n\t\tint length = str.length();\n\t\tfor(int i = 0; i < length; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(doBackslashes && c == '\\\\') {\n\t\t\t\toutput.append(\"\\\\\\\\\");\n\t\t\t} else {\n\t\t\t\tspelled(c, output); \n\t\t\t}\n        }\n\t\t\n\t}\n\n    /**\n     * Return the String containing the whole content this SourceReader is reading from.\n     */\n    public char[] getContent() {\n    \t\n        return content;\n        \n    }\n\n    /**\n     * Put the current index in token.start and return true.\n     * Intended to be used like this:\n     * <code>\n     * static Token token = new Token();\n     * void parse(SourceReader read) {\n     *   if(reader.startToken(token) && reader.matches(\"myKeyword\", true) && reader.endToken(token)) {\n     * \t   // Add a copy of the Token to the token list.\n     *   }\n     * }\n     * <\/code>\n     * @param token\n     * @return\n     */\n    public boolean startToken(Token token) {\n\n    \ttoken.start = index;\n    \treturn true;\n    \t\n    }\n    \n    \n    /**\n     * Put the current index in token.end and return true.\n     * Intended to be used like this:\n     * <code>\n     * static Token token = new Token();\n     * void parse(SourceReader read) {\n     *   if(reader.startToken(token) && reader.matches(\"myKeyword\", true) && reader.endToken(token)) {\n     * \t   // Add a copy of the Token to the token list.\n     *   }\n     * }\n     * <\/code>\n     * @param token\n     * @return\n     */\n    public boolean endToken(Token token) {\n \n    \ttoken.length = index - token.start;\n    \treturn true;\n    \t\n    }\n\n\t@SuppressWarnings(\"boxing\")\n\tpublic String getLine(int lineNumber) throws IOException {\n\n\t\tint mark = mark();\n\t\tif(newlineIndices.size() > lineNumber) {\n\t\t\treset(newlineIndices.get(lineNumber));\n\t\t} else {\n\t\t\treset(0);\n\t\t\tfor(int i = 1; i < lineNumber; i++) {\n\t\t\t\treadLine();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString line = readLine();\n\t\treset(mark);\n\t\treturn line;\n\t\t\n\t}\n\n\t/**\n\t * Get a slice of the source, specifying the start position\n\t * and the length of the slice.\n\t * @param start\n\t * @param length\n\t * @return\n\t */\n\tpublic String getSlice(int start, int length) {\n\n\t\treturn new String(content, start, length);\n\t\t\n\t}\n\n}\n","lineNo":1067}
{"Smelly Sample":"package org.ooc.frontend.parser;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.OocDocComment;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class ClassDeclParser {\n\n\tpublic static ClassDecl parse(Module module, SourceReader sReader, TokenReader reader) {\n\t\tint mark = reader.mark();\n\t\t\n\t\tOocDocComment comment = null;\n\t\tif(reader.peek().type == TokenType.OOCDOC) {\n\t\t\tToken token = reader.read();\n\t\t\tcomment = new OocDocComment(token.get(sReader), token);\n\t\t}\n\t\t\n\t\tString name = \"\";\n\t\tToken tName = reader.peek();\n\t\tif(tName.type != TokenType.NAME) {\n\t\t\treader.reset(mark);\n\t\t\treturn null;\n\t\t}\n\t\t\t\n\t\tname = tName.get(sReader);\n\t\treader.skip();\n\t\tif(reader.read().type != TokenType.COLON) {\n\t\t\treader.reset(mark);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tboolean isAbstract = reader.peek().type == TokenType.ABSTRACT_KW;\n\t\tif(isAbstract) reader.skip();\n\t\tList<TypeParam> genTypes = null;\n\t\t\n\t\tif(reader.readWhiteless().type == TokenType.CLASS_KW) {\n\t\t\n\t\t\tif(reader.peek().type == TokenType.LESSTHAN) {\n\t\t\t\treader.skip();\n\t\t\t\tgenTypes = new ArrayList<TypeParam>();\n\t\t\t\tTypeParamParser.parse(sReader, reader, genTypes);\n\t\t\t}\n\t\t\t\n\t\t\tType superType = null;\n\t\t\tif(reader.peek().type == TokenType.EXTENDS_KW) {\n\t\t\t\treader.skip();\n\t\t\t\tsuperType = TypeParser.parse(module, sReader, reader);\n\t\t\t}\n\t\t\t\n\t\t\treader.skipWhitespace();\n\t\t\tToken t2 = reader.read();\n\t\t\tif(t2.type != TokenType.OPEN_BRACK) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(t2),\n\t\t\t\t\t\t\"Expected opening bracket to begin class declaration.\");\n\t\t\t}\n\t\t\t\n\t\t\tif(superType != null && name.equals(superType.getName())) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(tName), \"A class cannot extends itself!\");\n\t\t\t}\n\t\t\t\n\t\t\tClassDecl classDecl = new ClassDecl(name, superType, isAbstract, module, tName);\n\t\t\tif(genTypes != null) for(TypeParam genType: genTypes) {\n\t\t\t\tclassDecl.addTypeParam(genType);\n\t\t\t}\n\t\t\tclassDecl.addInit();\n\t\t\tmodule.parseStack.push(classDecl);\n\t\t\tif(comment != null) classDecl.setComment(comment);\n\t\t\t\n\t\t\twhile(reader.hasNext() && reader.peek().type != TokenType.CLOS_BRACK) {\n\t\t\t\n\t\t\t\tif(reader.skipWhitespace()) continue;\n\t\t\t\t\n\t\t\t\tVariableDecl varDecl = VariableDeclParser.parse(module, sReader, reader);\n\t\t\t\tif(varDecl != null) {\n\t\t\t\t\tif(reader.read().type != TokenType.LINESEP) {\n\t\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected semi-colon after variable declaration in class declaration\");\n\t\t\t\t\t}\n\t\t\t\t\tclassDecl.addVariable(varDecl);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tFunctionDecl funcDecl = FunctionDeclParser.parse(module, sReader, reader, false);\n\t\t\t\tif(funcDecl != null) {\n\t\t\t\t\tclassDecl.addFunction(funcDecl);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(reader.peek().type == TokenType.OOCDOC) {\n\t\t\t\t\treader.read();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected variable declaration or function declaration in a class declaration, got \"+reader.peek());\n\t\t\t\n\t\t\t}\n\t\t\treader.skip();\n\t\t\t\n\t\t\tmodule.parseStack.pop(classDecl);\n\t\t\treturn classDecl;\n\t\t\t\n\t\t}\n\t\t\n\t\treader.reset(mark);\n\t\treturn null;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.parser;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.OocDocComment;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class ClassDeclParser {\n\n\tpublic static ClassDecl parse(Module module, SourceReader sReader, TokenReader reader) {\n\t\tint mark = reader.mark();\n\t\t\n\t\tOocDocComment comment = null;\n\t\tif(reader.peek().type == TokenType.OOCDOC) {\n\t\t\tToken token = reader.read();\n\t\t\tcomment = new OocDocComment(token.get(sReader), token);\n\t\t}\n\t\t\n\t\tString name = \"\";\n\t\tToken tName = reader.peek();\n\t\tif(tName.type != TokenType.NAME) {\n\t\t\treader.reset(mark);\n\t\t\treturn null;\n\t\t}\n\t\t\t\n\t\tname = tName.get(sReader);\n\t\treader.skip();\n\t\tif(reader.read().type != TokenType.COLON) {\n\t\t\treader.reset(mark);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tboolean isAbstract = reader.peek().type == TokenType.ABSTRACT_KW;\n\t\tif(isAbstract) reader.skip();\n\t\tList<TypeParam> genTypes = null;\n\t\t\n\t\tif(reader.readWhiteless().type == TokenType.CLASS_KW) {\n\t\t\n\t\t\tif(reader.peek().type == TokenType.LESSTHAN) {\n\t\t\t\treader.skip();\n\t\t\t\tgenTypes = new ArrayList<TypeParam>();\n\t\t\t\tTypeParamParser.parse(sReader, reader, genTypes);\n\t\t\t}\n\t\t\t\n\t\t\tType superType = null;\n\t\t\tif(reader.peek().type == TokenType.EXTENDS_KW) {\n\t\t\t\treader.skip();\n\t\t\t\tsuperType = TypeParser.parse(module, sReader, reader);\n\t\t\t}\n\t\t\t\n\t\t\treader.skipWhitespace();\n\t\t\tToken t2 = reader.read();\n\t\t\tif(t2.type != TokenType.OPEN_BRACK) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(t2),\n\t\t\t\t\t\t\"Expected opening bracket to begin class declaration.\");\n\t\t\t}\n\t\t\t\n\t\t\tif(superType != null && name.equals(superType.getName())) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(tName), \"A class cannot extends itself!\");\n\t\t\t}\n\t\t\t\n\t\t\tClassDecl classDecl = new ClassDecl(name, superType, isAbstract, module, tName);\n\t\t\tif(genTypes != null) for(TypeParam genType: genTypes) {\n\t\t\t\tclassDecl.addTypeParam(genType);\n\t\t\t}\n\t\t\tclassDecl.addInit();\n\t\t\tmodule.parseStack.push(classDecl);\n\t\t\tif(comment != null) classDecl.setComment(comment);\n\t\t\t\n\t\t\twhile(reader.hasNext() && reader.peek().type != TokenType.CLOS_BRACK) {\n\t\t\t\n\t\t\t\tif(reader.skipWhitespace()) continue;\n\t\t\t\t\n\t\t\t\tVariableDecl varDecl = VariableDeclParser.parse(module, sReader, reader);\n\t\t\t\tif(varDecl != null) {\n\t\t\t\t\tToken tok = reader.read();\n\t\t\t\t\tif(tok.type != TokenType.LINESEP && tok.type != TokenType.OOCDOC) {\n\t\t\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.prev()),\n\t\t\t\t\t\t\t\"Expected semi-colon after variable declaration in class declaration\");\n\t\t\t\t\t}\n\t\t\t\t\tclassDecl.addVariable(varDecl);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tFunctionDecl funcDecl = FunctionDeclParser.parse(module, sReader, reader, false);\n\t\t\t\tif(funcDecl != null) {\n\t\t\t\t\tclassDecl.addFunction(funcDecl);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(reader.peek().type == TokenType.OOCDOC) {\n\t\t\t\t\treader.read();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Expected variable declaration or function declaration in a class declaration, got \"+reader.peek());\n\t\t\t\n\t\t\t}\n\t\t\treader.skip();\n\t\t\t\n\t\t\tmodule.parseStack.pop(classDecl);\n\t\t\treturn classDecl;\n\t\t\t\n\t\t}\n\t\t\n\t\treader.reset(mark);\n\t\treturn null;\n\t}\n\t\n}\n","lineNo":87}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class MemberCall extends FunctionCall {\n\n\tprotected Expression expression;\n\n\tpublic MemberCall(Expression expression, String name, String suffix, Token startToken) {\n\t\tsuper(name, suffix, startToken);\n\t\tthis.expression = expression;\n\t}\n\t\n\tpublic MemberCall(Expression expression, FunctionCall call, Token startToken) {\n\t\tsuper(call.name, call.suffix, startToken);\n\t\tthis.expression = expression;\n\t\targuments.addAll(call.getArguments());\n\t}\n\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\t\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\texpression.accept(visitor);\n\t\tsuper.acceptChildren(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(super.replace(oldie, kiddo)) return true;\n\t\t\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tType exprType = expression.getType();\n\t\tif(exprType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Calling member function \"\n\t\t\t\t\t\t+name+getArgsRepr()+\" in an expression \"+expression\n\t\t\t\t\t\t+\" which type hasn't been resolved yet!\");\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\texprType = exprType.getFlatType(res);\n\t\t\n\t\tif(exprType.getRef() == null) exprType.resolve(res);\n\t\t\n\t\tif(exprType.getRef() == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Calling member function \"\n\t\t\t\t\t\t+name+getArgsRepr()+\" in an expression \"+expression\n\t\t\t\t\t\t+\" which type hasn't been ref'd yet. Its type = \"+exprType);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tDeclaration decl = exprType.getRef();\n\t\tif(!(decl instanceof TypeDecl)) {\n\t\t\tthrow new OocCompilationError(this, stack, \n\t\t\t\t\t\"Trying to call a member function of not a TypeDecl, but a \"\n\t\t\t\t\t+decl.getClass().getSimpleName());\n\t\t}\n\n\t\tTypeDecl typeDeclaration = (TypeDecl) decl;\n\t\timpl = typeDeclaration.getFunction(this);\n\t\t\n\t\tif(impl == null) {\n\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Dirty work */\n\t\tif(impl != null) {\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t\tautocast();\n\t\t}\n\t\t\n\t\tif(impl != null) {\n\t\t\tif(expression instanceof VariableAccess) {\n\t\t\t\tVariableAccess varAcc = (VariableAccess) expression;\n\t\t\t\tif(varAcc.getRef() instanceof TypeDecl && !(varAcc.getRef() instanceof TypeParam)) {\n\t\t\t\t\tif(!impl.isStatic()) {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \n\t\t\t\t\t\t\t\t\"Trying to call member member functions \"+getProtoRepr()\n\t\t\t\t\t\t\t\t+\" as if it were static. But it's not.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(fatal && impl == null) {\n\t\t\tString message = \"No such function \"\n\t\t\t\t+typeDeclaration.getInstanceType()+\".\"+name+getArgsRepr();\n\t\t\tString guess = guessCorrectName(typeDeclaration);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn (impl == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\t\n\tprotected String guessCorrectName(final TypeDecl typeDeclaration) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> functions = new NodeList<FunctionDecl>();\n\t\ttypeDeclaration.getFunctionsRecursive(functions);\n\t\tfor(FunctionDecl decl: functions) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr(true);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(\"+expression+\")\"+\"->\"+getProtoRepr();\n\t}\n\t\n\t@Override\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tExpression result = getRealExpr(typeParam, stack, res, fatal, expression.getType());\n\t\tif(result != null) return result;\n\t\treturn super.getRealExpr(typeParam, stack, res, fatal);\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal, Type type) {\n\t\t\n\t\tif(type != null && !type.getTypeParams().isEmpty()) {\n\t\t\tDeclaration ref = type.getRef();\n\t\t\tif(ref instanceof TypeDecl) {\n\t\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\t\tLinkedHashMap<String, TypeParam> typeParams = typeDecl.getTypeParams();\n\t\t\t\tif(!typeParams.isEmpty()) {\n\t\t\t\t\tint i = -1;\n\t\t\t\t\tfor(TypeParam candidate: typeParams.values()) {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(candidate.getName().equals(typeParam)) {\n\t\t\t\t\t\t\tAccess result = type.getTypeParams().get(i);\n\t\t\t\t\t\t\tif(result != null && result.getType() != null) {\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName, Resolver res) {\n\t\t\n\t\tif(!expression.getType().getRef().getType().getTypeParams().isEmpty()) {\n\t\t\tthrow new OocCompilationError(this, stack,\n\t\t\t\t\"You should specify type parameters of \"+expression.getType().getName()\n\t\t\t\t+\" for calling \"+getProtoRepr()+\". E.g. you could write \"+expression.getType().getName()+\"<Int>\");\n\t\t}\n\t\t\n\t\tsuper.throwUnresolvedType(stack, typeName, res);\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class MemberCall extends FunctionCall {\n\n\tprotected Expression expression;\n\n\tpublic MemberCall(Expression expression, String name, String suffix, Token startToken) {\n\t\tsuper(name, suffix, startToken);\n\t\tthis.expression = expression;\n\t}\n\t\n\tpublic MemberCall(Expression expression, FunctionCall call, Token startToken) {\n\t\tsuper(call.name, call.suffix, startToken);\n\t\tthis.expression = expression;\n\t\targuments.addAll(call.getArguments());\n\t}\n\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\t\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\texpression.accept(visitor);\n\t\tsuper.acceptChildren(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(super.replace(oldie, kiddo)) return true;\n\t\t\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tType exprType = expression.getType();\n\t\tif(exprType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Calling member function \"\n\t\t\t\t\t\t+name+getArgsRepr()+\" in an expression \"+expression\n\t\t\t\t\t\t+\" which type hasn't been resolved yet!\");\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\texprType = exprType.getFlatType(res);\n\t\t\n\t\tif(exprType.getRef() == null) exprType.resolve(res);\n\t\t\n\t\tif(exprType.getRef() == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Calling member function \"\n\t\t\t\t\t\t+name+getArgsRepr()+\" in an expression \"+expression\n\t\t\t\t\t\t+\" which type hasn't been ref'd yet. Its type = \"+exprType);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tDeclaration decl = exprType.getRef();\n\t\tif(!(decl instanceof TypeDecl)) {\n\t\t\tthrow new OocCompilationError(this, stack, \n\t\t\t\t\t\"Trying to call a member function of not a TypeDecl, but a \"\n\t\t\t\t\t+decl.getClass().getSimpleName());\n\t\t}\n\n\t\tTypeDecl typeDeclaration = (TypeDecl) decl;\n\t\timpl = typeDeclaration.getFunction(this);\n\t\t\n\t\tif(impl == null) {\n\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Dirty work */\n\t\tif(impl != null) {\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t\tautocast();\n\t\t}\n\t\t\n\t\tif(impl != null) {\n\t\t\tif(expression instanceof VariableAccess) {\n\t\t\t\tVariableAccess varAcc = (VariableAccess) expression;\n\t\t\t\tif(varAcc.getRef() instanceof TypeDecl && !(varAcc.getRef() instanceof TypeParam)) {\n\t\t\t\t\tif(!impl.isStatic()) {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \n\t\t\t\t\t\t\t\t\"Trying to call member member functions \"+getProtoRepr()\n\t\t\t\t\t\t\t\t+\" as if it were static. But it's not.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(fatal && impl == null) {\n\t\t\tString message = \"No such function \"\n\t\t\t\t+typeDeclaration.getInstanceType()+\".\"+name+getArgsRepr();\n\t\t\tString guess = guessCorrectName(typeDeclaration);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn (impl == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\t\n\tprotected String guessCorrectName(final TypeDecl typeDeclaration) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> functions = new NodeList<FunctionDecl>();\n\t\ttypeDeclaration.getFunctionsRecursive(functions);\n\t\tfor(FunctionDecl decl: functions) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr(true);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(\"+expression+\")\"+\"->\"+getProtoRepr();\n\t}\n\t\n\t@Override\n\tprotected Expression getRealExpr(String needle, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tType type = expression.getType();\n\t\t\n\t\tExpression result = super.getRealExpr(needle, stack, res, fatal);\n\t\tif(result != null) return result;\n\t\t\n\t\twhile(type != null) {\n\t\t\tresult = getRealExpr(needle, stack, res, fatal, type);\n\t\t\tif(result != null) return result;\n\t\t\ttype = ((TypeDecl) type.getRef()).getSuperType();\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String needle, NodeList<Node> stack, Resolver res, boolean fatal, Type type) {\n\t\t\n\t\tif(type != null && !type.getTypeParams().isEmpty()) {\n\t\t\tDeclaration ref = type.getRef();\n\t\t\tif(ref instanceof TypeDecl) {\n\t\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\t\tLinkedHashMap<String, TypeParam> typeParams = typeDecl.getTypeParams();\n\t\t\t\tif(!typeParams.isEmpty()) {\n\t\t\t\t\tint i = -1;\n\t\t\t\t\tfor(TypeParam candidate: typeParams.values()) {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(candidate.getName().equals(needle)) {\n\t\t\t\t\t\t\tAccess result = type.getTypeParams().get(i);\n\t\t\t\t\t\t\tif(result != null && result.getType() != null) {\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName, Resolver res) {\n\t\t\n\t\tif(!expression.getType().getRef().getType().getTypeParams().isEmpty()) {\n\t\t\tthrow new OocCompilationError(this, stack,\n\t\t\t\t\"You should specify type parameters of \"+expression.getType().getName()\n\t\t\t\t+\" for calling \"+getProtoRepr()+\". E.g. you could write \"+expression.getType().getName()+\"<Int>\");\n\t\t}\n\t\t\n\t\tsuper.throwUnresolvedType(stack, typeName, res);\n\t\t\n\t}\n\t\n}\n","lineNo":172}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.IntLiteral.Format;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Cast extends Expression implements MustBeResolved {\n\n\tstatic enum CastMode {\n\t\tREGULAR,\n\t\tARRAY, // for array literals\n\t\tMAP, // for map literal\n\t}\n\t\n\tprotected Expression expression;\n\tprotected Type type;\n\t\n\tpublic Cast(Expression expression, Type targetType, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.expression = expression;\n\t\tsetType(targetType);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == type) {\n\t\t\ttype = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttype.accept(visitor);\n\t\texpression.accept(visitor);\n\t}\n\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\n\tpublic void setType(Type newType) {\n\t\tthis.type = newType;\n\t\tif(type.isGenericRecursive() && expression.getType() != null && expression.getType().isGenericRecursive()) {\n\t\t\ttype = type.clone();\n\t\t\tTypeDecl dstDecl = (TypeDecl) newType.getRef();\n\t\t\tType src = expression.getType();\n\t\t\tif(dstDecl != null && dstDecl.getTypeParams() != null\n\t\t\t\t&& src != null && src.getTypeParams() != null\n\t\t\t\t&& dstDecl.getTypeParams().size() != src.getTypeParams().size()) {\n\t\t\t\tthrow new Error(\"Invalid cast between types \"+dstDecl.getType()+\" and \"+src);\n\t\t\t}\n\t\t\ttype.getTypeParams().clear();\n\t\t\ttype.getTypeParams().addAll(src.getTypeParams());\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic Expression getInner() {\n\t\treturn getExpression();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"[\"+expression+\" as \"+type+\"]\";\n\t}\n\t\n\t@Override\n\tpublic boolean canBeReferenced() {\n\t\treturn expression.canBeReferenced();\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(expression.getType() == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of expression in a cast\");\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tCastMode castMode = CastMode.REGULAR;\n\t\t\n\t\tExpression realExpr = expression.bitchJumpCasts(); \n\t\tif(realExpr instanceof ArrayLiteral) {\n\t\t\tcastMode = CastMode.ARRAY;\n\t\t}\n\t\t\n\t\tResponse response;\n\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tresponse = tryOp(stack, op, res, fatal, castMode);\n\t\t\tif(response != Response.OK) {\n\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\tSystem.out.println(\"Got op \"+op);\n\t\t\t\treturn response;\n\t\t\t}\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tresponse = tryOp(stack, op, res, fatal, castMode);\n\t\t\t\tif(response != Response.OK) {\n\t\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\t\tSystem.out.println(\"Got op \"+op);\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate Response tryOp(NodeList<Node> stack, OpDecl op, Resolver res, boolean fatal, CastMode castMode) {\n\t\t\n\t\tif(op.opType != OpType.AS) return Response.OK;\n\n\t\tFunctionDecl func = op.getFunc();\n\t\tNodeList<Argument> args = func.getArguments();\n\n\t\t\n\t\tif(castMode == CastMode.REGULAR) {\n\t\t\tif(!expression.getType().isResolved() || !args.get(0).getType().isResolved() || !func.getReturnType().isResolved()) {\n\t\t\t\t// FIXME deubg KALAMAZOO\n\t\t\t\tSystem.out.println(\"Looping cause one of expr/args(0)/retType isn't resolved\");\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\t//if(expression.getType().softEquals(args.get(0).getType(), res) && type.softEquals(func.getReturnType(), res)) {\n\t\t\tif(expression.getType().equals(args.get(0).getType()) && type.equals(func.getReturnType())) {\n\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\tSystem.out.println(\"Regular-took operator overloading \"+func+\" for cast from \"+expression+\" to \"+getType());\n\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\t\n\t\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\t\tcall.getArguments().add(expression);\n\t\t\t\tNode parent = stack.peek();\n\t\t\t\tparent.replace(this, call);\n\t\t\t\tcall.resolve(stack, res, true);\n\t\t\t\t//return Response.RESTART;\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t} else if(castMode == CastMode.ARRAY) {\n\t\t\tif(args.get(0).getType().getPointerLevel() > 0) {\n\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\tSystem.out.println(\"Array-took operator overloading \"+func+\" for cast from \"+expression+\" to \"+getType());\n\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\t\n\t\t\t\tArrayLiteral lit = (ArrayLiteral) expression;\n\t\t\t\tif(lit.getInnerType() == null) {\n\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\tthrow new OocCompilationError(lit, stack,\n\t\t\t\t\t\t\t\t\"Couldn't resolve inner type of ArrayLiteral, can't correctly call the overloaded cast!\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\t\tcall.getArguments().add(expression);\n\t\t\t\tcall.getArguments().add(new IntLiteral(lit.elements.size(), Format.DEC, lit.startToken));\n\t\t\t\tTypeAccess typeAccess = new TypeAccess(lit.getInnerType());\n\t\t\t\tcall.getTypeParams().add(typeAccess);\n\t\t\t\ttypeAccess.resolve(stack, res, true);\n\t\t\t\tNode parent = stack.peek();\n\t\t\t\tparent.replace(this, call);\n\t\t\t\tResponse resp2 = Response.RESTART;\n\t\t\t\twhile(resp2 == Response.RESTART) {\n\t\t\t\t\tresp2 = call.resolve(stack, res, true);\n\t\t\t\t}\n\t\t\t\t//return Response.RESTART;\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Node> T bitchJumpCasts() {\n\t\treturn (T) expression;\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Cast extends Expression implements MustBeResolved {\n\n\tstatic enum CastMode {\n\t\tREGULAR,\n\t\tARRAY, // for array literals\n\t\tMAP, // for map literal\n\t}\n\t\n\tprotected Expression expression;\n\tprotected Type type;\n\t\n\tpublic Cast(Expression expression, Type targetType, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.expression = expression;\n\t\tsetType(targetType);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == type) {\n\t\t\ttype = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttype.accept(visitor);\n\t\texpression.accept(visitor);\n\t}\n\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\n\tpublic void setType(Type newType) {\n\t\tthis.type = newType;\n\t\tif(type.isGenericRecursive() && expression.getType() != null && expression.getType().isGenericRecursive()) {\n\t\t\ttype = type.clone();\n\t\t\tTypeDecl dstDecl = (TypeDecl) newType.getRef();\n\t\t\tType src = expression.getType();\n\t\t\tif(dstDecl != null && dstDecl.getTypeParams() != null\n\t\t\t\t&& src != null && src.getTypeParams() != null\n\t\t\t\t&& dstDecl.getTypeParams().size() != src.getTypeParams().size()) {\n\t\t\t\tthrow new Error(\"Invalid cast between types \"+dstDecl.getType()+\" and \"+src);\n\t\t\t}\n\t\t\tif(src != null) {\n\t\t\t\ttype.getTypeParams().clear();\n\t\t\t\ttype.getTypeParams().addAll(src.getTypeParams());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic Expression getInner() {\n\t\treturn getExpression();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"[\"+expression+\" as \"+type+\"]\";\n\t}\n\t\n\t@Override\n\tpublic boolean canBeReferenced() {\n\t\treturn expression.canBeReferenced();\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(expression.getType() == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of expression in a cast\");\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tExpression realExpr = expression.bitchJumpCasts(); \n\t\tif(realExpr instanceof ArrayLiteral) {\n\t\t\ttryArrayOverload(stack, res, fatal);\n\t\t} else {\n\t\t\ttryRegularOverload(stack, res, fatal);\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n\tprivate Response tryRegularOverload(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tType leftType = expression.getType();\n\t\tType rightType = getType();\n\t\tif(!leftType.isResolved() || !rightType.isResolved()) {\n\t\t\tSystem.out.println(\"Bitch-looping because either \"+leftType+\" or \"+rightType+\" isn't resolved\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tOpDecl bestOp = null;\n\t\tint bestScore = 0;\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tint score = getRegularOpScore(stack, OpType.AS, op, res, leftType, rightType);\n\t\t\tif(score > bestScore) {\n\t\t\t\tbestScore = score;\n\t\t\t\tbestOp = op;\n\t\t\t}\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tint score = getRegularOpScore(stack, OpType.AS, op, res, leftType, rightType);\n\t\t\t\tif(score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestOp = op;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestOp != null) {\n\t\t\tFunctionCall call = new FunctionCall(bestOp.getFunc(), startToken);\n\t\t\tcall.getArguments().add(expression);\n\t\t\tNode parent = stack.peek();\n\t\t\tparent.replace(this, call);\n\t\t\tcall.resolve(stack, res, true);\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate int getRegularOpScore(NodeList<Node> stack, OpType opType, OpDecl op, Resolver res, Type leftType, Type rightType) {\n\t\t\n\t\tint score = 0;\n\t\tif(op.getOpType() == opType) {\n\t\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\t\tif(args.size() == 2) return score; // not for us\n\t\t\tif(args.size() != 1) {\n\t\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\t\"To overload the \"+opType.toPrettyString()+\" operator, you need exactly one arguments, not \"\n\t\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t\t}\n\t\t\tType firstType = args.get(0).getType();\n\t\t\tType secondType = op.getFunc().getReturnType();\n\t\t\tif(firstType.softEquals(leftType, res)) {\n\t\t\t\tif(secondType.softEquals(rightType, res) || isGeneric(secondType, op.getFunc().getTypeParams())) {\n\t\t\t\t\tscore += 10;\n\t\t\t\t\tif(firstType.equals(leftType)) {\n\t\t\t\t\t\tscore += 20;\n\t\t\t\t\t}\n\t\t\t\t\tif(secondType.equals(rightType)) {\n\t\t\t\t\t\tscore += 20;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t\t\n\t}\n\t\n\tprivate Response tryArrayOverload(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tType leftType = expression.getType();\n\t\tType rightType = getType();\n\t\tif(!leftType.isResolved() || !rightType.isResolved()) {\n\t\t\tSystem.out.println(\"Bitch-looping because either \"+leftType+\" or \"+rightType+\" isn't resolved\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tOpDecl bestOp = null;\n\t\tint bestScore = 0;\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tint score = getArrayOpScore(stack, OpType.AS, op, res, leftType, rightType);\n\t\t\tif(score > bestScore) {\n\t\t\t\tbestScore = score;\n\t\t\t\tbestOp = op;\n\t\t\t}\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tint score = getArrayOpScore(stack, OpType.AS, op, res, leftType, rightType);\n\t\t\t\tif(score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestOp = op;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestOp != null) {\n\t\t\tArrayLiteral lit = (ArrayLiteral) expression;\n\t\t\tif(lit.getInnerType() == null) {\n\t\t\t\tif(fatal) {\n\t\t\t\t\tthrow new OocCompilationError(lit, stack,\n\t\t\t\t\t\t\t\"Couldn't resolve inner type of ArrayLiteral, can't correctly call the overloaded cast!\");\n\t\t\t\t}\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\t\n\t\t\tFunctionCall call = new FunctionCall(bestOp.getFunc(), startToken);\n\t\t\tcall.getArguments().add(expression);\n\t\t\tcall.getArguments().add(new IntLiteral(lit.elements.size(), IntLiteral.Format.DEC, lit.startToken));\n\t\t\tTypeAccess typeAccess = new TypeAccess(lit.getInnerType());\n\t\t\tcall.getTypeParams().add(typeAccess);\n\t\t\ttypeAccess.resolve(stack, res, true);\n\t\t\tNode parent = stack.peek();\n\t\t\tparent.replace(this, call);\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n\tprivate int getArrayOpScore(NodeList<Node> stack, OpType opType, OpDecl op, Resolver res, Type leftType, Type rightType) {\n\t\t\n\t\tint score = 0;\n\t\tif(op.getOpType() == opType) {\n\t\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\t\tif(args.size() == 1) return score; // not for us\n\t\t\tif(args.size() > 2 || args.size() < 1) {\n\t\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\t\"To overload the \"+opType.toPrettyString()+\" operator from arrays, you need exactly two arguments (T* and size), not \"\n\t\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t\t}\n\t\t\tType firstType = args.get(0).getType();\n\t\t\tType secondType = op.getFunc().getReturnType();\n\t\t\tif(firstType.softEquals(leftType, res)) {\n\t\t\t\tif(secondType.softEquals(rightType, res) || isGeneric(secondType, op.getFunc().getTypeParams())) {\n\t\t\t\t\tscore += 10;\n\t\t\t\t\tif(firstType.equals(leftType)) {\n\t\t\t\t\t\tscore += 20;\n\t\t\t\t\t}\n\t\t\t\t\tif(secondType.equals(rightType)) {\n\t\t\t\t\t\tscore += 20;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t\t\n\t}\n\t\n\tprivate boolean isGeneric(Type type, LinkedHashMap<String, TypeParam> linkedHashMap) {\n\t\treturn linkedHashMap.containsKey(type.getName());\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Node> T bitchJumpCasts() {\n\t\treturn (T) expression;\n\t}\n\n}\n","lineNo":207}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.IntLiteral.Format;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Cast extends Expression implements MustBeResolved {\n\n\tstatic enum CastMode {\n\t\tREGULAR,\n\t\tARRAY, // for array literals\n\t\tMAP, // for map literal\n\t}\n\t\n\tprotected Expression expression;\n\tprotected Type type;\n\t\n\tpublic Cast(Expression expression, Type targetType, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.expression = expression;\n\t\tsetType(targetType);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == type) {\n\t\t\ttype = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttype.accept(visitor);\n\t\texpression.accept(visitor);\n\t}\n\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\n\tpublic void setType(Type newType) {\n\t\tthis.type = newType;\n\t\tif(type.isGenericRecursive() && expression.getType() != null && expression.getType().isGenericRecursive()) {\n\t\t\ttype = type.clone();\n\t\t\tTypeDecl dstDecl = (TypeDecl) newType.getRef();\n\t\t\tType src = expression.getType();\n\t\t\tif(dstDecl != null && dstDecl.getTypeParams() != null\n\t\t\t\t&& src != null && src.getTypeParams() != null\n\t\t\t\t&& dstDecl.getTypeParams().size() != src.getTypeParams().size()) {\n\t\t\t\tthrow new Error(\"Invalid cast between types \"+dstDecl.getType()+\" and \"+src);\n\t\t\t}\n\t\t\ttype.getTypeParams().clear();\n\t\t\ttype.getTypeParams().addAll(src.getTypeParams());\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic Expression getInner() {\n\t\treturn getExpression();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"[\"+expression+\" as \"+type+\"]\";\n\t}\n\t\n\t@Override\n\tpublic boolean canBeReferenced() {\n\t\treturn expression.canBeReferenced();\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(expression.getType() == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of expression in a cast\");\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tCastMode castMode = CastMode.REGULAR;\n\t\t\n\t\tExpression realExpr = expression.bitchJumpCasts(); \n\t\tif(realExpr instanceof ArrayLiteral) {\n\t\t\tcastMode = CastMode.ARRAY;\n\t\t}\n\t\t\n\t\tResponse response;\n\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tresponse = tryOp(stack, op, res, fatal, castMode);\n\t\t\tif(response != Response.OK) {\n\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\tSystem.out.println(\"Got op \"+op);\n\t\t\t\treturn response;\n\t\t\t}\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tresponse = tryOp(stack, op, res, fatal, castMode);\n\t\t\t\tif(response != Response.OK) {\n\t\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\t\tSystem.out.println(\"Got op \"+op);\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate Response tryOp(NodeList<Node> stack, OpDecl op, Resolver res, boolean fatal, CastMode castMode) {\n\t\t\n\t\tif(op.opType != OpType.AS) return Response.OK;\n\n\t\tFunctionDecl func = op.getFunc();\n\t\tNodeList<Argument> args = func.getArguments();\n\n\t\t\n\t\tif(castMode == CastMode.REGULAR) {\n\t\t\tif(!expression.getType().isResolved() || !args.get(0).getType().isResolved() || !func.getReturnType().isResolved()) {\n\t\t\t\t// FIXME deubg KALAMAZOO\n\t\t\t\tSystem.out.println(\"Looping cause one of expr/args(0)/retType isn't resolved\");\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\t//if(expression.getType().softEquals(args.get(0).getType(), res) && type.softEquals(func.getReturnType(), res)) {\n\t\t\tif(expression.getType().equals(args.get(0).getType()) && type.equals(func.getReturnType())) {\n\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\tSystem.out.println(\"Regular-took operator overloading \"+func+\" for cast from \"+expression+\" to \"+getType());\n\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\t\n\t\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\t\tcall.getArguments().add(expression);\n\t\t\t\tNode parent = stack.peek();\n\t\t\t\tparent.replace(this, call);\n\t\t\t\tcall.resolve(stack, res, true);\n\t\t\t\t//return Response.RESTART;\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t} else if(castMode == CastMode.ARRAY) {\n\t\t\tif(args.get(0).getType().getPointerLevel() > 0) {\n\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\tSystem.out.println(\"Array-took operator overloading \"+func+\" for cast from \"+expression+\" to \"+getType());\n\t\t\t\t// FIXME debug KALAMAZOO\n\t\t\t\t\n\t\t\t\tArrayLiteral lit = (ArrayLiteral) expression;\n\t\t\t\tif(lit.getInnerType() == null) {\n\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\tthrow new OocCompilationError(lit, stack,\n\t\t\t\t\t\t\t\t\"Couldn't resolve inner type of ArrayLiteral, can't correctly call the overloaded cast!\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\t\tcall.getArguments().add(expression);\n\t\t\t\tcall.getArguments().add(new IntLiteral(lit.elements.size(), Format.DEC, lit.startToken));\n\t\t\t\tTypeAccess typeAccess = new TypeAccess(lit.getInnerType());\n\t\t\t\tcall.getTypeParams().add(typeAccess);\n\t\t\t\ttypeAccess.resolve(stack, res, true);\n\t\t\t\tNode parent = stack.peek();\n\t\t\t\tparent.replace(this, call);\n\t\t\t\tResponse resp2 = Response.RESTART;\n\t\t\t\twhile(resp2 == Response.RESTART) {\n\t\t\t\t\tresp2 = call.resolve(stack, res, true);\n\t\t\t\t}\n\t\t\t\t//return Response.RESTART;\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Node> T bitchJumpCasts() {\n\t\treturn (T) expression;\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Cast extends Expression implements MustBeResolved {\n\n\tstatic enum CastMode {\n\t\tREGULAR,\n\t\tARRAY, // for array literals\n\t\tMAP, // for map literal\n\t}\n\t\n\tprotected Expression expression;\n\tprotected Type type;\n\t\n\tpublic Cast(Expression expression, Type targetType, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.expression = expression;\n\t\tsetType(targetType);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == type) {\n\t\t\ttype = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttype.accept(visitor);\n\t\texpression.accept(visitor);\n\t}\n\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\n\tpublic void setType(Type newType) {\n\t\tthis.type = newType;\n\t\tif(type.isGenericRecursive() && expression.getType() != null && expression.getType().isGenericRecursive()) {\n\t\t\ttype = type.clone();\n\t\t\tTypeDecl dstDecl = (TypeDecl) newType.getRef();\n\t\t\tType src = expression.getType();\n\t\t\tif(dstDecl != null && dstDecl.getTypeParams() != null\n\t\t\t\t&& src != null && src.getTypeParams() != null\n\t\t\t\t&& dstDecl.getTypeParams().size() != src.getTypeParams().size()) {\n\t\t\t\tthrow new Error(\"Invalid cast between types \"+dstDecl.getType()+\" and \"+src);\n\t\t\t}\n\t\t\tif(src != null) {\n\t\t\t\ttype.getTypeParams().clear();\n\t\t\t\ttype.getTypeParams().addAll(src.getTypeParams());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic Expression getInner() {\n\t\treturn getExpression();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"[\"+expression+\" as \"+type+\"]\";\n\t}\n\t\n\t@Override\n\tpublic boolean canBeReferenced() {\n\t\treturn expression.canBeReferenced();\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(expression.getType() == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of expression in a cast\");\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tExpression realExpr = expression.bitchJumpCasts(); \n\t\tif(realExpr instanceof ArrayLiteral) {\n\t\t\ttryArrayOverload(stack, res, fatal);\n\t\t} else {\n\t\t\ttryRegularOverload(stack, res, fatal);\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n\tprivate Response tryRegularOverload(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tType leftType = expression.getType();\n\t\tType rightType = getType();\n\t\tif(!leftType.isResolved() || !rightType.isResolved()) {\n\t\t\tSystem.out.println(\"Bitch-looping because either \"+leftType+\" or \"+rightType+\" isn't resolved\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tOpDecl bestOp = null;\n\t\tint bestScore = 0;\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tint score = getRegularOpScore(stack, OpType.AS, op, res, leftType, rightType);\n\t\t\tif(score > bestScore) {\n\t\t\t\tbestScore = score;\n\t\t\t\tbestOp = op;\n\t\t\t}\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tint score = getRegularOpScore(stack, OpType.AS, op, res, leftType, rightType);\n\t\t\t\tif(score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestOp = op;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestOp != null) {\n\t\t\tFunctionCall call = new FunctionCall(bestOp.getFunc(), startToken);\n\t\t\tcall.getArguments().add(expression);\n\t\t\tNode parent = stack.peek();\n\t\t\tparent.replace(this, call);\n\t\t\tcall.resolve(stack, res, true);\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate int getRegularOpScore(NodeList<Node> stack, OpType opType, OpDecl op, Resolver res, Type leftType, Type rightType) {\n\t\t\n\t\tint score = 0;\n\t\tif(op.getOpType() == opType) {\n\t\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\t\tif(args.size() == 2) return score; // not for us\n\t\t\tif(args.size() != 1) {\n\t\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\t\"To overload the \"+opType.toPrettyString()+\" operator, you need exactly one arguments, not \"\n\t\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t\t}\n\t\t\tType firstType = args.get(0).getType();\n\t\t\tType secondType = op.getFunc().getReturnType();\n\t\t\tif(firstType.softEquals(leftType, res)) {\n\t\t\t\tif(secondType.softEquals(rightType, res) || isGeneric(secondType, op.getFunc().getTypeParams())) {\n\t\t\t\t\tscore += 10;\n\t\t\t\t\tif(firstType.equals(leftType)) {\n\t\t\t\t\t\tscore += 20;\n\t\t\t\t\t}\n\t\t\t\t\tif(secondType.equals(rightType)) {\n\t\t\t\t\t\tscore += 20;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t\t\n\t}\n\t\n\tprivate Response tryArrayOverload(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tType leftType = expression.getType();\n\t\tType rightType = getType();\n\t\tif(!leftType.isResolved() || !rightType.isResolved()) {\n\t\t\tSystem.out.println(\"Bitch-looping because either \"+leftType+\" or \"+rightType+\" isn't resolved\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tOpDecl bestOp = null;\n\t\tint bestScore = 0;\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tint score = getArrayOpScore(stack, OpType.AS, op, res, leftType, rightType);\n\t\t\tif(score > bestScore) {\n\t\t\t\tbestScore = score;\n\t\t\t\tbestOp = op;\n\t\t\t}\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tint score = getArrayOpScore(stack, OpType.AS, op, res, leftType, rightType);\n\t\t\t\tif(score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestOp = op;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestOp != null) {\n\t\t\tArrayLiteral lit = (ArrayLiteral) expression;\n\t\t\tif(lit.getInnerType() == null) {\n\t\t\t\tif(fatal) {\n\t\t\t\t\tthrow new OocCompilationError(lit, stack,\n\t\t\t\t\t\t\t\"Couldn't resolve inner type of ArrayLiteral, can't correctly call the overloaded cast!\");\n\t\t\t\t}\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\t\n\t\t\tFunctionCall call = new FunctionCall(bestOp.getFunc(), startToken);\n\t\t\tcall.getArguments().add(expression);\n\t\t\tcall.getArguments().add(new IntLiteral(lit.elements.size(), IntLiteral.Format.DEC, lit.startToken));\n\t\t\tTypeAccess typeAccess = new TypeAccess(lit.getInnerType());\n\t\t\tcall.getTypeParams().add(typeAccess);\n\t\t\ttypeAccess.resolve(stack, res, true);\n\t\t\tNode parent = stack.peek();\n\t\t\tparent.replace(this, call);\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n\tprivate int getArrayOpScore(NodeList<Node> stack, OpType opType, OpDecl op, Resolver res, Type leftType, Type rightType) {\n\t\t\n\t\tint score = 0;\n\t\tif(op.getOpType() == opType) {\n\t\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\t\tif(args.size() == 1) return score; // not for us\n\t\t\tif(args.size() > 2 || args.size() < 1) {\n\t\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\t\"To overload the \"+opType.toPrettyString()+\" operator from arrays, you need exactly two arguments (T* and size), not \"\n\t\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t\t}\n\t\t\tType firstType = args.get(0).getType();\n\t\t\tType secondType = op.getFunc().getReturnType();\n\t\t\tif(firstType.softEquals(leftType, res)) {\n\t\t\t\tif(secondType.softEquals(rightType, res) || isGeneric(secondType, op.getFunc().getTypeParams())) {\n\t\t\t\t\tscore += 10;\n\t\t\t\t\tif(firstType.equals(leftType)) {\n\t\t\t\t\t\tscore += 20;\n\t\t\t\t\t}\n\t\t\t\t\tif(secondType.equals(rightType)) {\n\t\t\t\t\t\tscore += 20;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t\t\n\t}\n\t\n\tprivate boolean isGeneric(Type type, LinkedHashMap<String, TypeParam> linkedHashMap) {\n\t\treturn linkedHashMap.containsKey(type.getName());\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends Node> T bitchJumpCasts() {\n\t\treturn (T) expression;\n\t}\n\n}\n","lineNo":200}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VersionNodes.VersionAnd;\nimport org.ooc.frontend.model.VersionNodes.VersionName;\nimport org.ooc.frontend.model.VersionNodes.VersionNegation;\nimport org.ooc.frontend.model.VersionNodes.VersionNode;\nimport org.ooc.frontend.model.VersionNodes.VersionNodeVisitor;\nimport org.ooc.frontend.model.VersionNodes.VersionOr;\nimport org.ooc.frontend.model.VersionNodes.VersionParen;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.interfaces.Versioned;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\nimport org.ubi.CompilationFailedError;\n\npublic class VersionBlock extends Block implements MustBeResolved {\n\n\tprotected static Map<String, String> map = new HashMap<String, String>();\n\n\tstatic {\n\t\t\n\t\t// Java's excuse for a Map literal\n\t\tmap.put(\"windows\", \t\t\"__WIN32__) || defined(__WIN64__\"); // FIXME: does that imply that we're not 64 ?\n\t\tmap.put(\"linux\", \t\t\"__linux__\");\n\t\tmap.put(\"solaris\", \t\t\"__sun\");\n\t\tmap.put(\"unix\", \t\t\"__unix__\");\n\t\tmap.put(\"beos\", \t\t\"__BEOS__\");\n\t\tmap.put(\"haiku\", \t\t\"__HAIKU__\");\n\t\tmap.put(\"apple\", \t\t\"__APPLE__\");\n\t\tmap.put(\"gnuc\", \t\t\"__GNUC__\");\n\t\tmap.put(\"i386\", \t\t\"__i386__\");\n\t\tmap.put(\"x86\", \t\t\t\"__X86__\");\n\t\tmap.put(\"x86_64\", \t\t\"__x86_64__\");\n\t\tmap.put(\"ppc\", \t\t\t\"__ppc__\");\n\t\tmap.put(\"ppc64\",\t\t\"__ppc64__\");\n\t\tmap.put(\"64\", \t\t\t\"__x86_64__) || defined(__ppc64__\");\n\t\tmap.put(\"gc\",\t\t\t\"__OOC_USE_GC__\");\n\t\t\n\t}\n\t\n\tprivate VersionNode version;\n\n\t/**\n\t * Default constructor\n\t * @param location\n\t * @param id The id of this version. One of \"linux\", \"windows\", etc.\n\t */\n\tpublic VersionBlock(VersionNode version, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.version = version;\n\t}\n\t\n\tpublic VersionNode getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\ttry {\n\t\t\tversion.accept(new VersionNodeVisitor() {\n\t\t\t\t\n\t\t\t\tpublic void visit(VersionOr versionOr) throws IOException {\n\t\t\t\t\tversionOr.acceptChildren(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic void visit(VersionAnd versionAnd) throws IOException {\n\t\t\t\t\tversionAnd.acceptChildren(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic void visit(VersionNegation versionNegation) throws IOException {\n\t\t\t\t\tversionNegation.acceptChildren(this);\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic void visit(VersionName versionName) {\n\t\t\t\t\tif(versionName.solved) return;\n\t\t\t\t\tString match = map.get(versionName.name.toLowerCase());\n\t\t\t\t\tif(match != null) {\n\t\t\t\t\t\tversionName.name = match;\n\t\t\t\t\t\tversionName.solved = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(new OocCompilationError(VersionBlock.this, stack,\n\t\t\t\t\t\t\t\t\"Unknown version id: '\" + versionName.name\n\t\t\t\t\t\t\t\t+ \"', compiling anyway (who knows?)\").toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void visit(VersionParen versionParen) throws IOException {\n\t\t\t\t\tversionParen.acceptChildren(this);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (IOException e) {\n\t\t\tthrow new CompilationFailedError(e);\n\t\t}\n\n\t\tfor(int i = 0; i < body.size(); i++) {\n\t\t\tLine line = body.get(i);\n\t\t\tStatement stmt = line.getStatement();\n\t\t\tif(stmt instanceof Versioned) {\n\t\t\t\tVersioned vs = (Versioned) stmt;\n\t\t\t\tvs.setVersion(this);\n\t\t\t\tstack.getModule().getBody().add(stmt);\n\t\t\t\tbody.remove(i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif(!(o instanceof VersionBlock)) return super.equals(o);\n\t\tVersionBlock vb = (VersionBlock) o;\n\t\treturn this.version.toString().equals(vb.version.toString());\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VersionNodes.VersionAnd;\nimport org.ooc.frontend.model.VersionNodes.VersionName;\nimport org.ooc.frontend.model.VersionNodes.VersionNegation;\nimport org.ooc.frontend.model.VersionNodes.VersionNode;\nimport org.ooc.frontend.model.VersionNodes.VersionNodeVisitor;\nimport org.ooc.frontend.model.VersionNodes.VersionOr;\nimport org.ooc.frontend.model.VersionNodes.VersionParen;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.interfaces.Versioned;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\nimport org.ubi.CompilationFailedError;\n\npublic class VersionBlock extends Block implements MustBeResolved {\n\n\tprotected static Map<String, String> map = new HashMap<String, String>();\n\n\tstatic {\n\t\t\n\t\t// Java's excuse for a Map literal\n\t\tmap.put(\"windows\", \t\t\"__WIN32__) || defined(__WIN64__\"); // FIXME: does that imply that we're not 64 ?\n\t\tmap.put(\"linux\", \t\t\"__linux__\");\n\t\tmap.put(\"solaris\", \t\t\"__sun\");\n\t\tmap.put(\"unix\", \t\t\"__unix__\");\n\t\tmap.put(\"beos\", \t\t\"__BEOS__\");\n\t\tmap.put(\"haiku\", \t\t\"__HAIKU__\");\n\t\tmap.put(\"apple\", \t\t\"__APPLE__\");\n\t\tmap.put(\"gnuc\", \t\t\"__GNUC__\");\n\t\tmap.put(\"i386\", \t\t\"__i386__\");\n\t\tmap.put(\"x86\", \t\t\t\"__X86__\");\n\t\tmap.put(\"x86_64\", \t\t\"__x86_64__\");\n\t\tmap.put(\"ppc\", \t\t\t\"__ppc__\");\n\t\tmap.put(\"ppc64\",\t\t\"__ppc64__\");\n\t\tmap.put(\"64\", \t\t\t\"__x86_64__) || defined(__ppc64__\");\n\t\tmap.put(\"gc\",\t\t\t\"__OOC_USE_GC__\");\n\t\t\n\t}\n\t\n\tprivate VersionNode version;\n\n\t/**\n\t * Default constructor\n\t * @param location\n\t * @param id The id of this version. One of \"linux\", \"windows\", etc.\n\t */\n\tpublic VersionBlock(VersionNode version, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.version = version;\n\t}\n\t\n\tpublic VersionNode getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\ttry {\n\t\t\tversion.accept(new VersionNodeVisitor() {\n\t\t\t\t\n\t\t\t\tpublic void visit(VersionOr versionOr) throws IOException {\n\t\t\t\t\tversionOr.acceptChildren(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic void visit(VersionAnd versionAnd) throws IOException {\n\t\t\t\t\tversionAnd.acceptChildren(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic void visit(VersionNegation versionNegation) throws IOException {\n\t\t\t\t\tversionNegation.acceptChildren(this);\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic void visit(VersionName versionName) {\n\t\t\t\t\tif(versionName.solved) return;\n\t\t\t\t\tString match = map.get(versionName.name.toLowerCase());\n\t\t\t\t\tif(match != null) {\n\t\t\t\t\t\tversionName.name = match;\n\t\t\t\t\t\tversionName.solved = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(new OocCompilationError(VersionBlock.this, stack,\n\t\t\t\t\t\t\t\t\"Unknown version id: '\" + versionName.name\n\t\t\t\t\t\t\t\t+ \"', compiling anyway (who knows?)\").toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void visit(VersionParen versionParen) throws IOException {\n\t\t\t\t\tversionParen.acceptChildren(this);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (IOException e) {\n\t\t\tthrow new CompilationFailedError(e);\n\t\t}\n\n\t\tfor(int i = 0; i < body.size(); i++) {\n\t\t\tLine line = body.get(i);\n\t\t\tStatement stmt = line.getStatement();\n\t\t\tif(stmt instanceof Versioned) {\n\t\t\t\tVersioned vs = (Versioned) stmt;\n\t\t\t\tvs.setVersion(this);\n\t\t\t\tSystem.out.println(\"Just versioned \"+ vs + \" to \" + version);\n\t\t\t\tModule module = stack.getModule();\n\t\t\t\t\n\t\t\t\tif(stmt instanceof TypeDecl) {\n\t\t\t\t\tTypeDecl tDecl = (TypeDecl) stmt;\n\t\t\t\t\tmodule.addType(tDecl, res);\n\t\t\t\t} else {\n\t\t\t\t\tmodule.getBody().add(stmt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbody.remove(i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif(!(o instanceof VersionBlock)) return super.equals(o);\n\t\tVersionBlock vb = (VersionBlock) o;\n\t\treturn this.version.toString().equals(vb.version.toString());\n\t}\n\n\tpublic boolean isSatisfied(Resolver res) {\n\t\treturn version.isSatisfied(res);\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn version.toString();\n\t}\n\n}\n","lineNo":112}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\n\npublic class VariableDeclWriter {\n\n\tpublic static boolean write(VariableDecl variableDecl, CGenerator cgen) throws IOException {\n\n\t\tif(variableDecl.isExtern()) return false;\n\t\t\n\t\tif (variableDecl.isGlobal())\n\t\t{\n\t\t\tassert cgen.current == cgen.hw;\n\t\t\tcgen.current.app(\"extern \");\n\t\t\twriteGuts(variableDecl, cgen, false);\n\t\t\tcgen.current = cgen.cw;\n\t\t\twriteGuts(variableDecl, cgen, true);\n\t\t\tcgen.current.app(\";\\n\");\n\t\t\tcgen.current = cgen.hw;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twriteGuts(variableDecl, cgen, true);\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}\n\t\n\tprivate static void writeGuts(VariableDecl variableDecl, CGenerator cgen,\n\t\t\tboolean writeInitializer) throws IOException {\n\t\t// FIXME add const checking from the ooc side of things. Disabled C's\n\t\t// const keyword because it causes problems with class initializations\n\t\t//if(variableDecl.isConst()) cgen.current.app(\"const \");\n\t\t\n\t\tType type = variableDecl.getType();\n\t\tif(type.getName().equals(\"Func\")) {\n\t\t\t\n\t\t\tFunctionDecl funcDecl = (FunctionDecl) type.getRef();\n\t\t\tIterator<VariableDeclAtom> iter = variableDecl.getAtoms().iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tVariableDeclAtom atom = iter.next();\n\t\t\t\tTypeWriter.writeSpaced(funcDecl.getReturnType(), cgen);\n\t\t\t\tcgen.current.app(\"(*\").app(atom.getName()).app(\")\");\n\t\t\t\tFunctionDeclWriter.writeFuncArgs(funcDecl, cgen);\n\t\t\t\twriteInitAndComma(cgen, type, iter.hasNext(), atom, writeInitializer);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tboolean isStatic = variableDecl.isStatic();\n\t\t\tTypeDecl typeDecl = variableDecl.getTypeDecl();\n\t\t\tif(isStatic && (typeDecl == null)) cgen.current.append(\"static \");\n\t\t\t\n\t\t\tif(!type.isArray()) {\n\t\t\t\tboolean isConst = type.isConst();\n\t\t\t\ttype.setConst(false);\n\t\t\t\tTypeWriter.writeSpaced(type, cgen);\n\t\t\t\ttype.setConst(isConst);\n\t\t\t} else {\n\t\t\t\tTypeWriter.write(type.getGroundType(), cgen);\n\t\t\t\tcgen.current.app(' ');\n\t\t\t}\n\t\t\t\n\t\t\tIterator<VariableDeclAtom> iter = variableDecl.getAtoms().iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tVariableDeclAtom atom = iter.next();\n\t\t\t\tif(type.isArray()) {\n\t\t\t\t\tTypeWriter.writePreFinale(type, cgen);\n\t\t\t\t}\n\t\t\t\tcgen.current.app(atom.getName());\n\t\t\t\tif(type.isArray()) {\n\t\t\t\t\tTypeWriter.writePostFinale(type, cgen);\n\t\t\t\t}\n\t\t\t\twriteInitAndComma(cgen, type, iter.hasNext(), atom, writeInitializer);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tprivate static void writeInitAndComma(CGenerator cgen, Type type,\n\t\t\tboolean writeComma, VariableDeclAtom atom, boolean writeInitializer)\n\t\t\tthrows IOException {\n\t\tif(writeInitializer) {\n\t\t\tif(atom.getExpression() != null) {\n\t\t\t\tcgen.current.app(\" = \");\n\t\t\t\tatom.getExpression().accept(cgen);\n\t\t\t}\n\t\t}\n\t\tif(writeComma) {\n\t\t\tcgen.current.app(\", \");\n\t\t\tTypeWriter.writeFinale(type.getGroundType(), cgen);\n\t\t}\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\n\npublic class VariableDeclWriter {\n\n\tpublic static boolean write(VariableDecl variableDecl, CGenerator cgen) throws IOException {\n\n\t\tif(variableDecl.isExtern()) return false;\n\t\t\n\t\tif (variableDecl.isGlobal())\n\t\t{\n\t\t\tassert cgen.current == cgen.hw;\n\t\t\tcgen.current.app(\"extern \");\n\t\t\twriteGuts(variableDecl, cgen, false);\n\t\t\tcgen.current = cgen.cw;\n\t\t\twriteGuts(variableDecl, cgen, true);\n\t\t\tcgen.current.app(\";\\n\");\n\t\t\tcgen.current = cgen.hw;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twriteGuts(variableDecl, cgen, true);\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}\n\t\n\tprivate static void writeGuts(VariableDecl variableDecl, CGenerator cgen,\n\t\t\tboolean writeInitializer) throws IOException {\n\t\t// FIXME add const checking from the ooc side of things. Disabled C's\n\t\t// const keyword because it causes problems with class initializations\n\t\t//if(variableDecl.isConst()) cgen.current.app(\"const \");\n\t\t\n\t\tType type = variableDecl.getType();\n\t\tif(type.getName().equals(\"Func\")) {\n\t\t\t\n\t\t\tFunctionDecl funcDecl = (FunctionDecl) type.getRef();\n\t\t\tIterator<VariableDeclAtom> iter = variableDecl.getAtoms().iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tVariableDeclAtom atom = iter.next();\n\t\t\t\tTypeWriter.writeSpaced(funcDecl.getReturnType(), cgen);\n\t\t\t\tcgen.current.app(\"(*\").app(atom.getName()).app(\")\");\n\t\t\t\tFunctionDeclWriter.writeFuncArgs(funcDecl, cgen);\n\t\t\t\twriteInitAndComma(cgen, type, iter.hasNext(), atom, writeInitializer);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tboolean isStatic = variableDecl.isStatic();\n\t\t\tTypeDecl typeDecl = variableDecl.getTypeDecl();\n\t\t\tif(isStatic && (typeDecl == null)) cgen.current.append(\"static \");\n\t\t\t\n\t\t\tif(!type.isArray()) {\n\t\t\t\tboolean isConst = type.isConst();\n\t\t\t\ttype.setConst(false);\n\t\t\t\tTypeWriter.writeSpaced(type, cgen);\n\t\t\t\ttype.setConst(isConst);\n\t\t\t} else {\n\t\t\t\tType ground = type.getGroundType().clone();\n\t\t\t\tground.setPointerLevel(ground.getPointerLevel() - 1);\n\t\t\t\tTypeWriter.write(ground, cgen);\n\t\t\t\tcgen.current.app(' ');\n\t\t\t}\n\t\t\t\n\t\t\tIterator<VariableDeclAtom> iter = variableDecl.getAtoms().iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tVariableDeclAtom atom = iter.next();\n\t\t\t\tif(type.isArray()) {\n\t\t\t\t\tTypeWriter.writePreFinale(type, cgen);\n\t\t\t\t}\n\t\t\t\tcgen.current.app(atom.getName());\n\t\t\t\tif(type.isArray()) {\n\t\t\t\t\tTypeWriter.writePostFinale(type, cgen);\n\t\t\t\t}\n\t\t\t\twriteInitAndComma(cgen, type, iter.hasNext(), atom, writeInitializer);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tprivate static void writeInitAndComma(CGenerator cgen, Type type,\n\t\t\tboolean writeComma, VariableDeclAtom atom, boolean writeInitializer)\n\t\t\tthrows IOException {\n\t\tif(writeInitializer) {\n\t\t\tif(atom.getExpression() != null) {\n\t\t\t\tcgen.current.app(\" = \");\n\t\t\t\tatom.getExpression().accept(cgen);\n\t\t\t}\n\t\t}\n\t\tif(writeComma) {\n\t\t\tcgen.current.app(\", \");\n\t\t\tTypeWriter.writeFinale(type.getGroundType(), cgen);\n\t\t}\n\t}\n\t\n}\n","lineNo":68}
{"Smelly Sample":"package org.ooc.frontend.drivers;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.Include.Mode;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.pkgconfig.PkgConfigFrontend;\nimport org.ooc.frontend.pkgconfig.PkgInfo;\nimport org.ooc.middle.UseDef;\nimport org.ooc.middle.UseDef.Requirement;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\n\n/**\n * Drives the compilation process, e.g. chooses in which order\n * files are compiled, optionally checks for timestamps and stuff.\n * Great fun.\n * \n * @author Amos Wenger\n */\npublic abstract class Driver {\n\n\tpublic BuildParams params;\n\tpublic List<String> additionals = new ArrayList<String>();\n\tpublic List<String> compilerArgs = new ArrayList<String>();\n\t\n\tpublic Driver(BuildParams params) {\n\t\tsuper();\n\t\tthis.params = params;\n\t}\n\n\tpublic abstract int compile(Module module, String outName) throws Error,\n\t\t\tIOException, InterruptedException;\n\t\n\tprotected void copyLocalHeaders(Module module, BuildParams params, HashSet<Module> done) {\n\t\t\n\t\tif(done.contains(module)) return;\n\t\tdone.add(module);\n\t\tfor(Include inc: module.getIncludes()) {\n\t\t\tif(inc.getMode() == Mode.LOCAL) {\n\t\t\t\ttry {\n\t\t\t\t\tFile file = params.sourcePath.getFile(module.getPrefixLessPath()).getParentFile();\n\t\t\t\t\t\n\t\t\t\t\tFileUtils.copy(new File(file, inc.getPath() + \".h\"),\n\t\t\t\t\t\tnew File(params.outPath, inc.getPath() + \".h\"));\n\t\t\t\t} catch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tcopyLocalHeaders(imp.getModule(), params, done);\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void addDeps(Module module, Set<Module> toCompile, Set<String> done) {\n\t\t\n\t\ttoCompile.add(module);\n\t\tdone.add(module.getPath());\n\t\t\n\t\tparams.compiler.addObjectFile(new File(params.outPath, module.getPath(\".c\")).getPath());\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule().getPath())) {\n\t\t\t\taddDeps(imp.getModule(), toCompile, done);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected Collection<String> getFlagsFromUse(Module module) throws IOException, InterruptedException {\n\n\t\tSet<String> list = new HashSet<String>();\n\t\tSet<Module> done = new HashSet<Module>();\n\t\tgetFlagsFromUse(module, list, done, new HashSet<UseDef>());\n\t\treturn list;\n\t\t\n\t}\n\n\tprotected void getFlagsFromUse(Module module, Set<String> flagsDone, Set<Module> modulesDone, Set<UseDef> usesDone) throws IOException, InterruptedException {\n\n\t\tif(modulesDone.contains(module)) return;\n\t\tmodulesDone.add(module);\n\t\t\n\t\tfor(Use use: module.getUses()) {\n\t\t\tUseDef useDef = use.getUseDef();\n\t\t\tgetFlagsFromUse(useDef, flagsDone, usesDone);\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tgetFlagsFromUse(imp.getModule(), flagsDone, modulesDone, usesDone);\n\t\t}\n\t\t\n\t}\n\n\tprivate void getFlagsFromUse(UseDef useDef, Set<String> flagsDone,\n\t\t\tSet<UseDef> usesDone) throws IOException, InterruptedException {\n\t\t\n\t\tif(usesDone.contains(useDef)) return;\n\t\tusesDone.add(useDef);\n\t\tcompileNasms(useDef.getLibs(), flagsDone);\n\t\tfor(String pkg: useDef.getPkgs()) {\n\t\t\tPkgInfo info = PkgConfigFrontend.getInfo(pkg);\n\t\t\tfor(String cflag: info.cflags) {\n\t\t\t\tif(!flagsDone.contains(cflag)) {\n\t\t\t\t\tflagsDone.add(cflag);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(String library: info.libraries) {\n\t\t\t\t // FIXME lazy\n\t\t\t\tString lpath = \"-l\"+library;\n\t\t\t\tif(!flagsDone.contains(lpath)) {\n\t\t\t\t\tflagsDone.add(lpath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(String includePath: useDef.getIncludePaths()) {\n\t\t\t // FIXME lazy too.\n\t\t\tString ipath = \"-I\"+includePath;\n\t\t\tif(!flagsDone.contains(ipath)) {\n\t\t\t\tflagsDone.add(ipath);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(String libPath: useDef.getLibPaths()) {\n\t\t\t // FIXME lazy too.\n\t\t\tString lpath = \"-L\"+libPath;\n\t\t\tif(!flagsDone.contains(lpath)) {\n\t\t\t\tflagsDone.add(lpath);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Requirement req: useDef.getRequirements()) {\n\t\t\tgetFlagsFromUse(req.getUseDef(), flagsDone, usesDone);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic void compileNasms(List<String> nasms, Collection<String> list) throws IOException, InterruptedException {\n\t\t\n\t\tboolean has = false;\n\t\tif(nasms.isEmpty()) return;\n\t\tif(params.verbose) {\n\t\t\tSystem.out.println(\"Should compile nasms \"+nasms);\n\t\t}\n\t\t\n\t\tList<String> reallyNasms = new ArrayList<String>();\n\t\tfor(String nasm: nasms) {\n\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\treallyNasms.add(nasm);\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(has) {\n\t\t\tList<String> command = new ArrayList<String>();\n\t\t\tcommand.add(findExec(\"nasm\").getPath());\n\t\t\tcommand.add(\"-f\");\n\t\t\tcommand.add(\"elf\");\n\t\t\tcommand.addAll(reallyNasms);\n\t\t\t\n\t\t\tProcessBuilder builder = new ProcessBuilder(command);\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tint code = process.waitFor();\n\t\t\tif(code != 0) {\n\t\t\t\tSystem.err.println(\"nasm failed, aborting compilation process\");\n\t\t\t\tSystem.exit(code);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String nasm: nasms) {\n\t\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\t\tlist.add(nasm.substring(0, nasm.length() - 1) + \"o\");\n\t\t\t\t} else {\n\t\t\t\t\tlist.add(nasm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist.addAll(nasms);\n\t\t}\n\t\t\n\t}\n\t\n\tprotected File findExec(String name) throws Error {\n\t\t\n\t\tFile execFile = ShellUtils.findExecutable(name);\n\t\tif(execFile == null) {\n\t\t\texecFile = ShellUtils.findExecutable(name+\".exe\");\n\t\t}\n\t\tif(execFile == null) {\n\t\t\tthrow new Error(name+\" not found :/\");\n\t\t}\n\t\treturn execFile;\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.drivers;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.Include.Mode;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.pkgconfig.PkgConfigFrontend;\nimport org.ooc.frontend.pkgconfig.PkgInfo;\nimport org.ooc.middle.UseDef;\nimport org.ooc.middle.UseDef.Requirement;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\n\n/**\n * Drives the compilation process, e.g. chooses in which order\n * files are compiled, optionally checks for timestamps and stuff.\n * Great fun.\n * \n * @author Amos Wenger\n */\npublic abstract class Driver {\n\n\tpublic BuildParams params;\n\tpublic List<String> additionals = new ArrayList<String>();\n\tpublic List<String> compilerArgs = new ArrayList<String>();\n\t\n\tpublic Driver(BuildParams params) {\n\t\tsuper();\n\t\tthis.params = params;\n\t}\n\n\tpublic abstract int compile(Module module, String outName) throws Error,\n\t\t\tIOException, InterruptedException;\n\t\n\tprotected void copyLocalHeaders(Module module, BuildParams params, HashSet<Module> done) {\n\t\t\n\t\tif(done.contains(module)) return;\n\t\tdone.add(module);\n\t\tfor(Include inc: module.getIncludes()) {\n\t\t\tif(inc.getMode() == Mode.LOCAL) {\n\t\t\t\ttry {\n\t\t\t\t\tFile file = params.sourcePath.getFile(module.getPrefixLessPath()).getParentFile();\n\t\t\t\t\t\n\t\t\t\t\tFile target = new File(params.outPath, inc.getPath() + \".h\");\n\t\t\t\t\ttarget.getParentFile().mkdirs();\n\t\t\t\t\tFileUtils.copy(new File(file, inc.getPath() + \".h\"),\n\t\t\t\t\t\ttarget);\n\t\t\t\t} catch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tcopyLocalHeaders(imp.getModule(), params, done);\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void addDeps(Module module, Set<Module> toCompile, Set<String> done) {\n\t\t\n\t\ttoCompile.add(module);\n\t\tdone.add(module.getPath());\n\t\t\n\t\tparams.compiler.addObjectFile(new File(params.outPath, module.getPath(\".c\")).getPath());\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule().getPath())) {\n\t\t\t\taddDeps(imp.getModule(), toCompile, done);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected Collection<String> getFlagsFromUse(Module module) throws IOException, InterruptedException {\n\n\t\tSet<String> list = new HashSet<String>();\n\t\tSet<Module> done = new HashSet<Module>();\n\t\tgetFlagsFromUse(module, list, done, new HashSet<UseDef>());\n\t\treturn list;\n\t\t\n\t}\n\n\tprotected void getFlagsFromUse(Module module, Set<String> flagsDone, Set<Module> modulesDone, Set<UseDef> usesDone) throws IOException, InterruptedException {\n\n\t\tif(modulesDone.contains(module)) return;\n\t\tmodulesDone.add(module);\n\t\t\n\t\tfor(Use use: module.getUses()) {\n\t\t\tUseDef useDef = use.getUseDef();\n\t\t\tgetFlagsFromUse(useDef, flagsDone, usesDone);\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tgetFlagsFromUse(imp.getModule(), flagsDone, modulesDone, usesDone);\n\t\t}\n\t\t\n\t}\n\n\tprivate void getFlagsFromUse(UseDef useDef, Set<String> flagsDone,\n\t\t\tSet<UseDef> usesDone) throws IOException, InterruptedException {\n\t\t\n\t\tif(usesDone.contains(useDef)) return;\n\t\tusesDone.add(useDef);\n\t\tcompileNasms(useDef.getLibs(), flagsDone);\n\t\tfor(String pkg: useDef.getPkgs()) {\n\t\t\tPkgInfo info = PkgConfigFrontend.getInfo(pkg);\n\t\t\tfor(String cflag: info.cflags) {\n\t\t\t\tif(!flagsDone.contains(cflag)) {\n\t\t\t\t\tflagsDone.add(cflag);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(String library: info.libraries) {\n\t\t\t\t // FIXME lazy\n\t\t\t\tString lpath = \"-l\"+library;\n\t\t\t\tif(!flagsDone.contains(lpath)) {\n\t\t\t\t\tflagsDone.add(lpath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(String includePath: useDef.getIncludePaths()) {\n\t\t\t // FIXME lazy too.\n\t\t\tString ipath = \"-I\"+includePath;\n\t\t\tif(!flagsDone.contains(ipath)) {\n\t\t\t\tflagsDone.add(ipath);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(String libPath: useDef.getLibPaths()) {\n\t\t\t // FIXME lazy too.\n\t\t\tString lpath = \"-L\"+libPath;\n\t\t\tif(!flagsDone.contains(lpath)) {\n\t\t\t\tflagsDone.add(lpath);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Requirement req: useDef.getRequirements()) {\n\t\t\tgetFlagsFromUse(req.getUseDef(), flagsDone, usesDone);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic void compileNasms(List<String> nasms, Collection<String> list) throws IOException, InterruptedException {\n\t\t\n\t\tboolean has = false;\n\t\tif(nasms.isEmpty()) return;\n\t\tif(params.verbose) {\n\t\t\tSystem.out.println(\"Should compile nasms \"+nasms);\n\t\t}\n\t\t\n\t\tList<String> reallyNasms = new ArrayList<String>();\n\t\tfor(String nasm: nasms) {\n\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\treallyNasms.add(nasm);\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(has) {\n\t\t\tList<String> command = new ArrayList<String>();\n\t\t\tcommand.add(findExec(\"nasm\").getPath());\n\t\t\tcommand.add(\"-f\");\n\t\t\tcommand.add(\"elf\");\n\t\t\tcommand.addAll(reallyNasms);\n\t\t\t\n\t\t\tProcessBuilder builder = new ProcessBuilder(command);\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tint code = process.waitFor();\n\t\t\tif(code != 0) {\n\t\t\t\tSystem.err.println(\"nasm failed, aborting compilation process\");\n\t\t\t\tSystem.exit(code);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String nasm: nasms) {\n\t\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\t\tlist.add(nasm.substring(0, nasm.length() - 1) + \"o\");\n\t\t\t\t} else {\n\t\t\t\t\tlist.add(nasm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist.addAll(nasms);\n\t\t}\n\t\t\n\t}\n\t\n\tprotected File findExec(String name) throws Error {\n\t\t\n\t\tFile execFile = ShellUtils.findExecutable(name);\n\t\tif(execFile == null) {\n\t\t\texecFile = ShellUtils.findExecutable(name+\".exe\");\n\t\t}\n\t\tif(execFile == null) {\n\t\t\tthrow new Error(name+\" not found :/\");\n\t\t}\n\t\treturn execFile;\n\t\t\n\t}\n\t\n}\n","lineNo":55}
{"Smelly Sample":"package org.ooc.frontend.parser;\n\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class UseParser {\n\n\tpublic static boolean fill(SourceReader sReader, TokenReader reader,\n\t\t\tNodeList<Use> uses) throws CompilationFailedError {\n\t\t\n\t\tToken startToken = reader.peek();\n\t\tif(startToken.type != TokenType.USE_KW) return false;\n\t\treader.skip();\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tToken token = reader.read();\n\t\t\tif(token.type == TokenType.LINESEP) {\n\t\t\t\tuses.add(new Use(sb.toString(), startToken));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(token.type == TokenType.COMMA) {\n\t\t\t\tuses.add(new Use(sb.toString(), startToken));\n\t\t\t\tsb.setLength(0);\n\t\t\t} else {\n\t\t\t\tsb.append(token.get(sReader));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn true;\n\t\t\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend.parser;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ooc.middle.UseDef;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class UseParser {\n\n\tpublic static boolean fill(SourceReader sReader, TokenReader reader,\n\t\t\tNodeList<Use> uses, BuildParams params) throws CompilationFailedError, IOException {\n\t\t\n\t\tToken startToken = reader.peek();\n\t\tif(startToken.type != TokenType.USE_KW) return false;\n\t\treader.skip();\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tToken token = reader.read();\n\t\t\tif(token.type == TokenType.LINESEP) {\n\t\t\t\tUseDef useDef = UseDefParser.parse(sb.toString(), sReader, token, params);\n\t\t\t\tuses.add(new Use(useDef, startToken));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(token.type == TokenType.COMMA) {\n\t\t\t\tUseDef useDef = UseDefParser.parse(sb.toString(), sReader, token, params);\n\t\t\t\tuses.add(new Use(useDef, startToken));\n\t\t\t\tsb.setLength(0);\n\t\t\t} else {\n\t\t\t\tsb.append(token.get(sReader));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn true;\n\t\t\n\t}\n\n}\n","lineNo":29}
{"Smelly Sample":"package org.ooc.frontend.parser;\n\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class UseParser {\n\n\tpublic static boolean fill(SourceReader sReader, TokenReader reader,\n\t\t\tNodeList<Use> uses) throws CompilationFailedError {\n\t\t\n\t\tToken startToken = reader.peek();\n\t\tif(startToken.type != TokenType.USE_KW) return false;\n\t\treader.skip();\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tToken token = reader.read();\n\t\t\tif(token.type == TokenType.LINESEP) {\n\t\t\t\tuses.add(new Use(sb.toString(), startToken));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(token.type == TokenType.COMMA) {\n\t\t\t\tuses.add(new Use(sb.toString(), startToken));\n\t\t\t\tsb.setLength(0);\n\t\t\t} else {\n\t\t\t\tsb.append(token.get(sReader));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn true;\n\t\t\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend.parser;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ooc.middle.UseDef;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class UseParser {\n\n\tpublic static boolean fill(SourceReader sReader, TokenReader reader,\n\t\t\tNodeList<Use> uses, BuildParams params) throws CompilationFailedError, IOException {\n\t\t\n\t\tToken startToken = reader.peek();\n\t\tif(startToken.type != TokenType.USE_KW) return false;\n\t\treader.skip();\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tToken token = reader.read();\n\t\t\tif(token.type == TokenType.LINESEP) {\n\t\t\t\tUseDef useDef = UseDefParser.parse(sb.toString(), sReader, token, params);\n\t\t\t\tuses.add(new Use(useDef, startToken));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(token.type == TokenType.COMMA) {\n\t\t\t\tUseDef useDef = UseDefParser.parse(sb.toString(), sReader, token, params);\n\t\t\t\tuses.add(new Use(useDef, startToken));\n\t\t\t\tsb.setLength(0);\n\t\t\t} else {\n\t\t\t\tsb.append(token.get(sReader));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn true;\n\t\t\n\t}\n\n}\n","lineNo":34}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ClassDecl extends TypeDecl {\n\n\tpublic static final String DESTROY_FUNC_NAME = \"__destroy__\";\n\tpublic static final String DEFAULTS_FUNC_NAME = \"__defaults__\";\n\tpublic static final String LOAD_FUNC_NAME = \"__load__\";\n\n\tprotected boolean isAbstract;\n\t\n\tprotected OocDocComment comment;\n\t\n\tprotected FunctionDecl defaultInit = null;\n\t\n\tpublic ClassDecl(String name, Type superType, boolean isAbstract, Module module, Token startToken) {\n\t\tsuper(name, (superType == null && !name.equals(\"Object\")) ?\n\t\t\t\tnew Type(\"Object\", Token.defaultToken) : superType, module, startToken);\n\t\tthis.isAbstract = isAbstract;\n\t\t\n\t\taddFunction(new FunctionDecl(LOAD_FUNC_NAME,     \"\", false, true,  false, false, startToken));\n\t\taddFunction(new FunctionDecl(DEFAULTS_FUNC_NAME, \"\", false, false, false, false, startToken));\n\t\taddFunction(new FunctionDecl(DESTROY_FUNC_NAME,  \"\", false, false, false, false, startToken));\n\t}\n\n\tpublic void addInit() {\n\t\tif(!isAbstract && defaultInit == null) {\n\t\t\tFunctionDecl init = new FunctionDecl(\"init\", \"\", false, false, false, false, startToken);\n\t\t\taddFunction(init);\n\t\t\tdefaultInit = init;\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic ClassDecl getSuperRef() {\n\t\treturn (ClassDecl) super.getSuperRef();\n\t}\n\n\tpublic boolean isObjectClass() {\n\t\treturn name.equals(\"Object\");\n\t}\n\t\n\tpublic boolean isClassClass() {\n\t\treturn name.equals(\"Class\");\n\t}\n\t\n\tpublic boolean isRootClass() {\n\t\treturn isObjectClass() || isClassClass();\n\t}\n\t\n\tpublic OocDocComment getComment() {\n\t\treturn comment;\n\t}\n\t\n\tpublic void setComment(OocDocComment comment) {\n\t\tthis.comment = comment;\n\t}\n\t\n\tpublic boolean isAbstract() {\n\t\treturn isAbstract;\n\t}\n\t\n\tpublic void setAbstract(boolean isAbstract) {\n\t\tthis.isAbstract = isAbstract;\n\t}\n\t\n\t@Override\n\tpublic void addFunction(FunctionDecl decl) {\n\t\t\n\t\tif(decl.getName().equals(\"init\")) {\n\t\t\taddInit(decl);\n\t\t} else if(decl.getName().equals(\"new\")) {\n\t\t\tFunctionDecl already = getFunction(decl.getName(), decl.getSuffix(), null);\n\t\t\tif(already != null) { functions.remove(already); }\n\t\t}\n\t\t\n\t\tsuper.addFunction(decl);\n\t}\n\n\tprivate void addInit(FunctionDecl decl) {\n\t\tif(defaultInit != null) {\n\t\t\tFunctionDecl newFunc = getFunction(\"new\", \"\", null);\n\t\t\tfunctions.remove(defaultInit);\n\t\t\tfunctions.remove(newFunc);\n\t\t\tdefaultInit = null;\n\t\t}\n\t\t\n\t\tFunctionDecl constructor = new FunctionDecl(\"new\", decl.getSuffix(), false, true, false, false, decl.startToken);\n\t\tType retType = getType().clone();\n\t\tretType.getTypeParams().clear();\n\t\t\n\t\tconstructor.getArguments().addAll(decl.getArguments());\n\t\tconstructor.getTypeParams().putAll(getTypeParams());\n\t\t\n\t\tVariableAccess thisTypeAccess = new VariableAccess(name, decl.startToken);\n\t\tthisTypeAccess.setRef(this);\n\t\tVariableAccess classAccess = new MemberAccess(thisTypeAccess, \"class\", decl.startToken);\n\t\tMemberCall allocCall = new MemberCall(classAccess, \"alloc\", \"\", decl.startToken);\n\t\tCast cast = new Cast(allocCall, getType(), decl.startToken);\n\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\"this\", cast, decl.startToken);\n\t\tconstructor.getBody().add(new Line(vdfe));\n\t\t\n\t\tfor(TypeParam genType: typeParams.values()) {\n\t\t\tVariableAccess e = new VariableAccess(genType.getName(), constructor.startToken);\n\t\t\tretType.getTypeParams().add(e);\n\t\t\t\n\t\t\tconstructor.getBody().add(new Line(new Assignment(\n\t\t\t\t\tnew MemberAccess(genType.getName(), startToken), e, constructor.startToken))\n\t\t\t);\n\t\t}\n\t\tconstructor.setReturnType(retType);\n\n\t\tVariableAccess thisAccess = new VariableAccess(vdfe, decl.startToken);\n\t\tthisAccess.setRef(vdfe);\n\t\t\n\t\tFunctionCall initCall = new FunctionCall(decl, decl.startToken);\n\t\tfor(Argument arg: constructor.getArguments()) {\n\t\t\tinitCall.getArguments().add(new VariableAccess(arg, decl.startToken));\n\t\t}\n\t\tconstructor.getBody().add(new Line(new MemberCall(thisAccess, initCall, decl.startToken)));\n\t\tconstructor.getBody().add(new Line(new ValuedReturn(thisAccess, decl.startToken)));\n\t\t\n\t\taddFunction(constructor);\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tVariableDecl variable = super.getVariable(name);\n\t\tif(variable != null) return variable;\n\t\tif(getSuperRef() != null) return getSuperRef().getVariable(name);\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tsuper.getVariables(variables);\n\t\tif(getSuperRef() != null) getSuperRef().getVariables(variables);\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tResponse response = super.resolve(stack, res, fatal);\n\t\tif(response != Response.OK) return response;\n\t\t\n\t\tif(isResolved()) return Response.OK;\n\t\t\n\t\tif(getSuperType() != null && !(super.getSuperRef() instanceof ClassDecl)) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Trying to extends a \"\n\t\t\t\t\t+getSuperRef().getClass().getSimpleName()+\". You can only extend classes.\");\n\t\t}\n\t\tif (getSuperType() != null) {\n\t\t\tif(getSuperRef() == null) {\n\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Super-type \"\n\t\t\t\t\t\t+getSuperType()+\" of class \"+getType()+\" couldn't be resolved\");\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\tif(defaultInit == null) {\n\t\t\t\tFunctionDecl superInit = getSuperRef().getFunction(\"init\", \"\", null);\n\t\t\t\tif(superInit != null && superInit == getSuperRef().defaultInit) {\n\t\t\t\t\taddInit();\n\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tpublic ClassDecl getBaseClass(FunctionDecl decl) {\n\t\tif(getSuperRef() != null) {\n\t\t\tClassDecl base = getSuperRef().getBaseClass(decl);\n\t\t\tif(base != null) return base;\n\t\t}\n\t\tif(getFunction(decl.getName(), decl.getSuffix(), null, false) != null) return this;\n\t\treturn null;\n\t}\n\t\n\tpublic boolean isChildOf(String candidate) {\n\t\tif(getName().equals(candidate)) return true;\n\t\tif(getSuperRef() != null) return getSuperRef().isChildOf(candidate);\n\t\treturn false;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\nimport org.ubi.CompilationFailedError;\n\npublic class ClassDecl extends TypeDecl {\n\n\tpublic static final String DESTROY_FUNC_NAME = \"__destroy__\";\n\tpublic static final String DEFAULTS_FUNC_NAME = \"__defaults__\";\n\tpublic static final String LOAD_FUNC_NAME = \"__load__\";\n\n\tprotected boolean isAbstract;\n\t\n\tprotected OocDocComment comment;\n\t\n\tprotected FunctionDecl defaultInit = null;\n\t\n\tpublic ClassDecl(String name, Type superType, boolean isAbstract, Module module, Token startToken) {\n\t\tsuper(name, (superType == null && !name.equals(\"Object\")) ?\n\t\t\t\tnew Type(\"Object\", Token.defaultToken) : superType, module, startToken);\n\t\tthis.isAbstract = isAbstract;\n\t\t\n\t\taddFunction(new FunctionDecl(LOAD_FUNC_NAME,     \"\", false, true,  false, false, startToken));\n\t\taddFunction(new FunctionDecl(DEFAULTS_FUNC_NAME, \"\", false, false, false, false, startToken));\n\t\taddFunction(new FunctionDecl(DESTROY_FUNC_NAME,  \"\", false, false, false, false, startToken));\n\t}\n\n\tpublic void addInit() {\n\t\tif(!isAbstract && defaultInit == null) {\n\t\t\tFunctionDecl init = new FunctionDecl(\"init\", \"\", false, false, false, false, startToken);\n\t\t\taddFunction(init);\n\t\t\tdefaultInit = init;\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic ClassDecl getSuperRef() {\n\t\tTypeDecl ref = super.getSuperRef();\n\t\tif(!(ref instanceof ClassDecl)) {\n\t\t\tthrow new CompilationFailedError(null, \"Huh your class '\"+getName()\n\t\t\t\t\t+\"' in '\"+module.getFullName()+\"' extends\"+ref.getName()+\" which isn't a ClassDecl but a \"\n\t\t\t\t\t+ref.getClass().getSimpleName());\n\t\t}\n\t\treturn (ClassDecl) ref;\n\t}\n\n\tpublic boolean isObjectClass() {\n\t\treturn name.equals(\"Object\");\n\t}\n\t\n\tpublic boolean isClassClass() {\n\t\treturn name.equals(\"Class\");\n\t}\n\t\n\tpublic boolean isRootClass() {\n\t\treturn isObjectClass() || isClassClass();\n\t}\n\t\n\tpublic OocDocComment getComment() {\n\t\treturn comment;\n\t}\n\t\n\tpublic void setComment(OocDocComment comment) {\n\t\tthis.comment = comment;\n\t}\n\t\n\tpublic boolean isAbstract() {\n\t\treturn isAbstract;\n\t}\n\t\n\tpublic void setAbstract(boolean isAbstract) {\n\t\tthis.isAbstract = isAbstract;\n\t}\n\t\n\t@Override\n\tpublic void addFunction(FunctionDecl decl) {\n\t\t\n\t\tif(decl.getName().equals(\"init\")) {\n\t\t\taddInit(decl);\n\t\t} else if(decl.getName().equals(\"new\")) {\n\t\t\tFunctionDecl already = getFunction(decl.getName(), decl.getSuffix(), null);\n\t\t\tif(already != null) { functions.remove(already); }\n\t\t}\n\t\t\n\t\tsuper.addFunction(decl);\n\t}\n\n\tprivate void addInit(FunctionDecl decl) {\n\t\tif(defaultInit != null) {\n\t\t\tFunctionDecl newFunc = getFunction(\"new\", \"\", null);\n\t\t\tfunctions.remove(defaultInit);\n\t\t\tfunctions.remove(newFunc);\n\t\t\tdefaultInit = null;\n\t\t}\n\t\t\n\t\tFunctionDecl constructor = new FunctionDecl(\"new\", decl.getSuffix(), false, true, false, false, decl.startToken);\n\t\tType retType = getType().clone();\n\t\tretType.getTypeParams().clear();\n\t\t\n\t\tconstructor.getArguments().addAll(decl.getArguments());\n\t\tconstructor.getTypeParams().putAll(getTypeParams());\n\t\t\n\t\tVariableAccess thisTypeAccess = new VariableAccess(name, decl.startToken);\n\t\tthisTypeAccess.setRef(this);\n\t\tVariableAccess classAccess = new MemberAccess(thisTypeAccess, \"class\", decl.startToken);\n\t\tMemberCall allocCall = new MemberCall(classAccess, \"alloc\", \"\", decl.startToken);\n\t\tCast cast = new Cast(allocCall, getType(), decl.startToken);\n\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\"this\", cast, decl.startToken);\n\t\tconstructor.getBody().add(new Line(vdfe));\n\t\t\n\t\tfor(TypeParam genType: typeParams.values()) {\n\t\t\tVariableAccess e = new VariableAccess(genType.getName(), constructor.startToken);\n\t\t\tretType.getTypeParams().add(e);\n\t\t\t\n\t\t\tconstructor.getBody().add(new Line(new Assignment(\n\t\t\t\t\tnew MemberAccess(genType.getName(), startToken), e, constructor.startToken))\n\t\t\t);\n\t\t}\n\t\tconstructor.setReturnType(retType);\n\n\t\tVariableAccess thisAccess = new VariableAccess(vdfe, decl.startToken);\n\t\tthisAccess.setRef(vdfe);\n\t\t\n\t\tFunctionCall initCall = new FunctionCall(decl, decl.startToken);\n\t\tfor(Argument arg: constructor.getArguments()) {\n\t\t\tinitCall.getArguments().add(new VariableAccess(arg, decl.startToken));\n\t\t}\n\t\tconstructor.getBody().add(new Line(new MemberCall(thisAccess, initCall, decl.startToken)));\n\t\tconstructor.getBody().add(new Line(new ValuedReturn(thisAccess, decl.startToken)));\n\t\t\n\t\taddFunction(constructor);\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tVariableDecl variable = super.getVariable(name);\n\t\tif(variable != null) return variable;\n\t\tif(getSuperRef() != null) return getSuperRef().getVariable(name);\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tsuper.getVariables(variables);\n\t\tif(getSuperRef() != null) getSuperRef().getVariables(variables);\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tResponse response = super.resolve(stack, res, fatal);\n\t\tif(response != Response.OK) return response;\n\t\t\n\t\tif(isResolved()) return Response.OK;\n\t\t\n\t\tif(getSuperType() != null && !(super.getSuperRef() instanceof ClassDecl)) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Trying to extends a \"\n\t\t\t\t\t+getSuperRef().getClass().getSimpleName()+\". You can only extend classes.\");\n\t\t}\n\t\tif (getSuperType() != null) {\n\t\t\tif(getSuperRef() == null) {\n\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Super-type \"\n\t\t\t\t\t\t+getSuperType()+\" of class \"+getType()+\" couldn't be resolved\");\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\tif(defaultInit == null) {\n\t\t\t\tFunctionDecl superInit = getSuperRef().getFunction(\"init\", \"\", null);\n\t\t\t\tif(superInit != null && superInit == getSuperRef().defaultInit) {\n\t\t\t\t\taddInit();\n\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tpublic ClassDecl getBaseClass(FunctionDecl decl) {\n\t\tif(getSuperRef() != null) {\n\t\t\tClassDecl base = getSuperRef().getBaseClass(decl);\n\t\t\tif(base != null) return base;\n\t\t}\n\t\tif(getFunction(decl.getName(), decl.getSuffix(), null, false) != null) return this;\n\t\treturn null;\n\t}\n\t\n\tpublic boolean isChildOf(String candidate) {\n\t\tif(getName().equals(candidate)) return true;\n\t\tif(getSuperRef() != null) return getSuperRef().isChildOf(candidate);\n\t\treturn false;\n\t}\n\t\n}\n","lineNo":43}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Type extends Node implements MustBeResolved {\n\n\tpublic static class Classification {\n\t\tpublic static final int POINTER = 1;\n\t\tpublic static final int NUMBER = 2;\n\t\tpublic static final int CLASS = 4;\n\t}\n\n\tprotected String name;\n\tprotected int pointerLevel;\n\tprotected int referenceLevel;\n\tprivate Declaration ref;\n\t\n\tprivate boolean isArray = false;\n\tprivate Expression arraySize = null;\n\t\n\tprotected NodeList<Access> typeParams;\n\tprivate boolean isConst = false;\n\t\n\tprivate static Type voidType = null;\n\t\n\tpublic static Type getVoid() {\n\t\tif(voidType == null) {\n\t\t\tvoidType = new Type(\"Void\", Token.defaultToken);\n\t\t}\n\t\treturn voidType;\n\t}\n\t\n\tpublic Type(String name, Token startToken) {\n\t\tthis(name, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, Token startToken) {\n\t\tthis(name, pointerLevel, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, int referenceLevel, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.pointerLevel = pointerLevel;\n\t\tthis.referenceLevel = referenceLevel;\n\t\tthis.typeParams = new NodeList<Access>(startToken);\n\t}\n\t\n\tpublic NodeList<Access> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void setPointerLevel(int pointerLevel) {\n\t\tthis.pointerLevel = pointerLevel;\n\t}\n\n\tpublic int getPointerLevel() {\n\t\treturn pointerLevel;\n\t}\n\t\n\tpublic void setReferenceLevel(int referenceLevel) {\n\t\tthis.referenceLevel = referenceLevel;\n\t}\n\t\n\tpublic int getReferenceLevel() {\n\t\treturn referenceLevel;\n\t}\n\t\n\tpublic Declaration getRef() {\n\t\treturn ref;\n\t}\n\t\n\tpublic void setRef(Declaration ref) {\n\t\tthis.ref = ref;\n\t}\n\t\n\tpublic boolean isConst() {\n\t\treturn isConst;\n\t}\n\t\n\tpublic void setConst(boolean isConst) {\n\t\tthis.isConst = isConst;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif(arraySize != null) arraySize.accept(visitor);\n\t\ttypeParams.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(isConst) sb.append(\"const \");\n\t\tsb.append(name);\n\t\t\n\t\tfor(int i = 0; i < pointerLevel; i++) {\n\t\t\tif(isArray) sb.append(\"[]\");\n\t\t\telse sb.append('*');\n\t\t}\n\t\tfor(int i = 0; i < referenceLevel; i++) {\n\t\t\tsb.append('@');\n\t\t}\n\t\tif(!typeParams.isEmpty()) {\n\t\t\tsb.append('<');\n\t\t\tIterator<Access> iter = typeParams.iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tAccess element = iter.next();\n\t\t\t\tif(element instanceof TypeAccess) {\n\t\t\t\t\tsb.append(element.toString());\n\t\t\t\t} else if(element instanceof VariableAccess) {\n\t\t\t\t\tsb.append(((VariableAccess) element).getName());\n\t\t\t\t} else if(element instanceof FunctionCall) {\n\t\t\t\t\tsb.append(((FunctionCall) element).getName());\n\t\t\t\t}\n\t\t\t\tif(iter.hasNext()) sb.append(\", \");\n\t\t\t}\n\t\t\tsb.append('>');\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t\t\n\t}\n\t\n\tpublic String getMangledName() {\n\t\t\n\t\tif(pointerLevel == 0) {\n\t\t\treturn name;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(name);\n\t\tfor(int i = 0; i < pointerLevel + referenceLevel; i++) {\n\t\t\tsb.append(\"__star\");\n\t\t}\n\t\treturn sb.toString();\n\t\t\n\t}\n\n\tpublic boolean isVoid() {\n\t\treturn (name.equals(\"void\") || name.equals(\"Void\")) && isFlat();\n\t}\n\n\tpublic boolean isFlat() {\n\t\treturn pointerLevel == 0 && referenceLevel == 0 && !(ref instanceof ClassDecl);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == ref) {\n\t\t\tref = (Declaration) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif(obj instanceof Type) {\n\t\t\tType type = (Type) obj;\n\t\t\tboolean result = name.equals(type.name) && pointerLevel == type.getPointerLevel();\n\t\t\treturn result;\n\t\t}\n\t\treturn super.equals(obj);\n\t}\n\t\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(name.equals(\"Func\")) {\n\t\t\tFuncType newType = new FuncType(startToken);\n\t\t\tnewType.setPointerLevel(pointerLevel);\n\t\t\tnewType.setReferenceLevel(referenceLevel);\n\t\t\tnewType.setArray(isArray);\n\t\t\tnewType.setArraySize(arraySize);\n\t\t\tif(!stack.peek().replace(this, newType)) {\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace \"\n\t\t\t\t\t\t+this+\" with \"+newType+\" in \"+stack.peek());\n\t\t\t}\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref != null) return Response.OK;\n\t\t\n\t\tref = stack.getModule().getType(name);\n\n\t\tif(ref == null && name.equals(\"This\")) {\n\t\t\tint index = stack.find(TypeDecl.class);\n\t\t\tif(index == -1) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Using 'This' outside a type definition is meaningless.\");\n\t\t\t}\n\t\t\tTypeDecl typeDecl = (TypeDecl) stack.get(index);\n\t\t\tname = typeDecl.getName();\n\t\t\tref = typeDecl;\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref == null) {\n\t\t\tTypeParam param = getTypeParam(stack, name);\n\t\t\tif(param != null) {\n\t\t\t\tref = param;\n\t\t\t\treturn Response.OK;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ref == null && fatal) {\n\t\t\tif(res.params.veryVerbose) {\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type \"\n\t\t\t\t\t+getName()+\". btw, stack = \"+stack.toString(true));\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type \"\n\t\t\t\t\t+getName());\n\t\t}\n\t\t\n\t\treturn (ref == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn ref != null || name.length() == 0; // empty name = any type.\n\t}\n\t\n\tpublic void setArray(boolean isArray) {\n\t\tthis.isArray = isArray;\n\t}\n\t\n\tpublic boolean isArray() {\n\t\treturn isArray;\n\t}\n\t\n\tpublic Type getGroundType() {\n\t\treturn getGroundType(null);\n\t}\n\t\n\tpublic Type getGroundType(Resolver res) {\n\t\tif(ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) ref;\n\t\t\tif(coverDecl.getFromType() != null && !name.equals(coverDecl.getFromType().getName())) {\n\t\t\t\tType rawType = coverDecl.getFromType().getGroundType(res);\n\t\t\t\tType groundType = new Type(rawType.name, pointerLevel, referenceLevel, rawType.startToken);\n\t\t\t\tif(res == null) {\n\t\t\t\t\tgroundType.ref = ref;\n\t\t\t\t} else {\n\t\t\t\t\tgroundType.resolve(res);\n\t\t\t\t}\n\t\t\t\treturn groundType;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tpublic Type getFlatType(Resolver res) {\n\t\tType returnType = this;\n\t\twhile(returnType.ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) returnType.ref;\n\t\t\tType fromType = coverDecl.getFromType();\n\t\t\tif(fromType == null) break;\n\t\t\tif(fromType.referenceLevel <= 0) break;\n\t\t\t\n\t\t\treturnType = new Type(fromType.name, fromType.pointerLevel - 1,\n\t\t\t\t\treturnType.referenceLevel - 1, fromType.startToken);\n\t\t\treturnType.resolve(res);\n\t\t}\n\t\t\n\t\treturn returnType;\n\t}\n\n\tpublic boolean fitsIn(Type innerType) {\n\t\tif (equals(innerType)) return true;\n\t\tif (getClassification() == innerType.getClassification()) return true;\n\t\treturn false;\n\t}\n\t\n\tpublic int getClassification() {\n\t\tif(!isFlat()) return Classification.POINTER;\n\t\t\n\t\tif(name.equals(\"Int\")   || name.equals(\"UInt\")  || name.equals(\"Short\")\n\t\t|| name.equals(\"UShort\")|| name.equals(\"Long\")  || name.equals(\"ULong\")\n\t\t|| name.equals(\"LLong\") || name.equals(\"ULLong\")|| name.equals(\"Char\")\n\t\t|| name.equals(\"UChar\") || name.equals(\"Int8\")  || name.equals(\"Int16\")\n\t\t|| name.equals(\"Int32\") || name.equals(\"Int64\") || name.equals(\"UInt8\")\n\t\t|| name.equals(\"UInt16\")|| name.equals(\"UInt32\")|| name.equals(\"UInt64\")\n\t\t|| name.equals(\"SizeT\")\n\t\t) return Classification.NUMBER;\n\t\t\n\t\treturn Classification.CLASS;\n\t}\n\n\tpublic void resolve(Resolver res) {\n\t\tref = res.module.getType(name);\n\t}\n\n\tpublic boolean isSuperOf(Type type) {\n\t\tif(type == null) return false;\n\t\tif(this.equals(type)) return false;\n\t\tif(name.length() == 0 || type.name.length() == 0) return false;\n\t\t\n\t\tif(type.getRef() instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) type.getRef();\n\t\t\tif(typeDecl.getSuperRef() != null) {\n\t\t\t\tType superType = typeDecl.getSuperRef().getType();\n\t\t\t\tif(superType.getName().equals(this.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn isSuperOf(superType);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String getHierarchyRepr() {\n\t\tString repr = name;\n\t\tType t = this;\n\t\twhile(t.ref != null) {\n\t\t\tif(!(t.ref instanceof TypeDecl)) break;\n\t\t\tTypeDecl typeDecl = (TypeDecl) t.ref;\n\t\t\tif(typeDecl.getSuperRef() == null) break;\n\t\t\tt = typeDecl.getSuperRef().getType();\n\t\t\trepr += \":\" + t;\n\t\t}\n\t\treturn repr;\n\t}\n\n\t@Override\n\tpublic Type clone() {\n\t\tType clone = new Type(name, pointerLevel, referenceLevel, startToken);\n\t\tclone.ref = ref;\n\t\tclone.isArray = isArray;\n\t\tclone.isConst = isConst;\n\t\tclone.typeParams.addAll(typeParams);\n\t\treturn clone;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn ref instanceof TypeParam;\n\t}\n\t\n\tpublic boolean isGenericRecursive() {\n\t\treturn (ref instanceof TypeParam) || !typeParams.isEmpty();\n\t}\n\n\tpublic Expression getArraySize() {\n\t\treturn arraySize;\n\t}\n\n\tpublic void setArraySize(Expression arraySize) {\n\t\tthis.arraySize = arraySize;\n\t}\n\n\tpublic boolean softEquals(Type type, Resolver res) {\n\t\tif(type == null) return false;\n\t\tresolve(res);\n\t\tif(equals(type)) {\n\t\t\treturn true;\n\t\t}\n\t\tDeclaration ref = type.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tif(typeDecl.getSuperType() != null) {\n\t\t\t\tType subType = typeDecl.getSuperType();\n\t\t\t\treturn softEquals(subType, res);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(\t\tgetClassification() == Classification.NUMBER\n\t\t&& type.getClassification() == Classification.NUMBER) return true;\n\t\treturn false;\n\t}\n\t\n\tpublic boolean isPrefixed() {\n\t\n\t\treturn (ref instanceof ClassDecl || (ref instanceof CoverDecl && !((CoverDecl) ref).isExtern()));\n\t\t\n\t}\n\n\tpublic String getUnderName() {\n\t\t\n\t\tif(isPrefixed()) return ((TypeDecl) ref).getUnderName();\n\t\treturn getName();\n\t\t\n\t}\n\n\tpublic Type dereference() {\n\t\tType clone = clone();\n\t\tclone.setPointerLevel(getPointerLevel() - 1);\n\t\treturn clone;\n\t}\n\t\n}\n\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Type extends Node implements MustBeResolved {\n\n\tpublic static class Classification {\n\t\tpublic static final int POINTER = 1;\n\t\tpublic static final int NUMBER = 2;\n\t\tpublic static final int CLASS = 4;\n\t}\n\n\tprotected String name;\n\tprotected int pointerLevel;\n\tprotected int referenceLevel;\n\tprivate Declaration ref;\n\t\n\tprivate boolean isArray = false;\n\tprivate Expression arraySize = null;\n\t\n\tprotected NodeList<Access> typeParams;\n\tprivate boolean isConst = false;\n\t\n\tprivate static Type voidType = null;\n\t\n\tpublic static Type getVoid() {\n\t\tif(voidType == null) {\n\t\t\tvoidType = new Type(\"Void\", Token.defaultToken);\n\t\t}\n\t\treturn voidType;\n\t}\n\t\n\tpublic Type(String name, Token startToken) {\n\t\tthis(name, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, Token startToken) {\n\t\tthis(name, pointerLevel, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, int referenceLevel, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.pointerLevel = pointerLevel;\n\t\tthis.referenceLevel = referenceLevel;\n\t\tthis.typeParams = new NodeList<Access>(startToken);\n\t}\n\t\n\tpublic NodeList<Access> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void setPointerLevel(int pointerLevel) {\n\t\tthis.pointerLevel = pointerLevel;\n\t}\n\n\tpublic int getPointerLevel() {\n\t\treturn pointerLevel;\n\t}\n\t\n\tpublic void setReferenceLevel(int referenceLevel) {\n\t\tthis.referenceLevel = referenceLevel;\n\t}\n\t\n\tpublic int getReferenceLevel() {\n\t\treturn referenceLevel;\n\t}\n\t\n\tpublic Declaration getRef() {\n\t\treturn ref;\n\t}\n\t\n\tpublic void setRef(Declaration ref) {\n\t\tthis.ref = ref;\n\t}\n\t\n\tpublic boolean isConst() {\n\t\treturn isConst;\n\t}\n\t\n\tpublic void setConst(boolean isConst) {\n\t\tthis.isConst = isConst;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif(arraySize != null) arraySize.accept(visitor);\n\t\ttypeParams.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(isConst) sb.append(\"const \");\n\t\tsb.append(name);\n\t\t\n\t\tfor(int i = 0; i < pointerLevel; i++) {\n\t\t\tif(isArray) sb.append(\"[]\");\n\t\t\telse sb.append('*');\n\t\t}\n\t\tfor(int i = 0; i < referenceLevel; i++) {\n\t\t\tsb.append('@');\n\t\t}\n\t\tif(!typeParams.isEmpty()) {\n\t\t\tsb.append('<');\n\t\t\tIterator<Access> iter = typeParams.iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tAccess element = iter.next();\n\t\t\t\tif(element instanceof TypeAccess) {\n\t\t\t\t\tsb.append(element.toString());\n\t\t\t\t} else if(element instanceof VariableAccess) {\n\t\t\t\t\tsb.append(((VariableAccess) element).getName());\n\t\t\t\t} else if(element instanceof FunctionCall) {\n\t\t\t\t\tsb.append(((FunctionCall) element).getName());\n\t\t\t\t}\n\t\t\t\tif(iter.hasNext()) sb.append(\", \");\n\t\t\t}\n\t\t\tsb.append('>');\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t\t\n\t}\n\t\n\tpublic String getMangledName() {\n\t\t\n\t\tif(pointerLevel == 0) {\n\t\t\treturn name;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(name);\n\t\tfor(int i = 0; i < pointerLevel + referenceLevel; i++) {\n\t\t\tsb.append(\"__star\");\n\t\t}\n\t\treturn sb.toString();\n\t\t\n\t}\n\n\tpublic boolean isVoid() {\n\t\treturn (name.equals(\"void\") || name.equals(\"Void\")) && isFlat();\n\t}\n\n\tpublic boolean isFlat() {\n\t\treturn pointerLevel == 0 && referenceLevel == 0 && !(ref instanceof ClassDecl);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == ref) {\n\t\t\tref = (Declaration) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif(obj instanceof Type) {\n\t\t\tType type = (Type) obj;\n\t\t\tboolean result = name.equals(type.name) && pointerLevel == type.getPointerLevel();\n\t\t\treturn result;\n\t\t}\n\t\treturn super.equals(obj);\n\t}\n\t\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(name.equals(\"Func\")) {\n\t\t\tFuncType newType = new FuncType(startToken);\n\t\t\tnewType.setPointerLevel(pointerLevel);\n\t\t\tnewType.setReferenceLevel(referenceLevel);\n\t\t\tnewType.setArray(isArray);\n\t\t\tnewType.setArraySize(arraySize);\n\t\t\tif(!stack.peek().replace(this, newType)) {\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace \"\n\t\t\t\t\t\t+this+\" with \"+newType+\" in \"+stack.peek());\n\t\t\t}\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref != null) return Response.OK;\n\t\t\n\t\tref = stack.getModule().getType(name);\n\n\t\tif(ref == null && name.equals(\"This\")) {\n\t\t\tint index = stack.find(TypeDecl.class);\n\t\t\tif(index == -1) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Using 'This' outside a type definition is meaningless.\");\n\t\t\t}\n\t\t\tTypeDecl typeDecl = (TypeDecl) stack.get(index);\n\t\t\tname = typeDecl.getName();\n\t\t\tref = typeDecl;\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref == null) {\n\t\t\tTypeParam param = getTypeParam(stack, name);\n\t\t\tif(param != null) {\n\t\t\t\tref = param;\n\t\t\t\treturn Response.OK;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ref == null && fatal) {\n\t\t\tif(res.params.veryVerbose) {\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type \"\n\t\t\t\t\t+getName()+\". btw, stack = \"+stack.toString(true));\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type \"\n\t\t\t\t\t+getName());\n\t\t}\n\t\t\n\t\treturn (ref == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn ref != null || name.length() == 0; // empty name = any type.\n\t}\n\t\n\tpublic void setArray(boolean isArray) {\n\t\tthis.isArray = isArray;\n\t}\n\t\n\tpublic boolean isArray() {\n\t\treturn isArray;\n\t}\n\t\n\tpublic Type getGroundType() {\n\t\treturn getGroundType(null);\n\t}\n\t\n\tpublic Type getGroundType(Resolver res) {\n\t\tif(ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) ref;\n\t\t\tType fromType = coverDecl.getFromType();\n\t\t\tif(fromType != null && !name.equals(fromType.getName())) {\n\t\t\t\tType rawType = coverDecl.getFromType().getGroundType(res);\n\t\t\t\tType groundType = new Type(\n\t\t\t\t\trawType.name,\n\t\t\t\t\trawType.getPointerLevel() + pointerLevel,\n\t\t\t\t\trawType.getReferenceLevel() + referenceLevel,\n\t\t\t\t\tstartToken\n\t\t\t\t);\n\t\t\t\tif(res == null) {\n\t\t\t\t\tgroundType.ref = ref;\n\t\t\t\t} else {\n\t\t\t\t\tgroundType.resolve(res);\n\t\t\t\t}\n\t\t\t\treturn groundType;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tpublic Type getFlatType(Resolver res) {\n\t\tType returnType = this;\n\t\twhile(returnType.ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) returnType.ref;\n\t\t\tType fromType = coverDecl.getFromType();\n\t\t\tif(fromType == null) break;\n\t\t\tif(fromType.referenceLevel <= 0) break;\n\t\t\t\n\t\t\treturnType = new Type(fromType.name, fromType.pointerLevel - 1,\n\t\t\t\t\treturnType.referenceLevel - 1, fromType.startToken);\n\t\t\treturnType.resolve(res);\n\t\t}\n\t\t\n\t\treturn returnType;\n\t}\n\n\tpublic boolean fitsIn(Type innerType) {\n\t\tif (equals(innerType)) return true;\n\t\tif (getClassification() == innerType.getClassification()) return true;\n\t\treturn false;\n\t}\n\t\n\tpublic int getClassification() {\n\t\tif(!isFlat()) return Classification.POINTER;\n\t\t\n\t\tif(name.equals(\"Int\")   || name.equals(\"UInt\")  || name.equals(\"Short\")\n\t\t|| name.equals(\"UShort\")|| name.equals(\"Long\")  || name.equals(\"ULong\")\n\t\t|| name.equals(\"LLong\") || name.equals(\"ULLong\")|| name.equals(\"Char\")\n\t\t|| name.equals(\"UChar\") || name.equals(\"Int8\")  || name.equals(\"Int16\")\n\t\t|| name.equals(\"Int32\") || name.equals(\"Int64\") || name.equals(\"UInt8\")\n\t\t|| name.equals(\"UInt16\")|| name.equals(\"UInt32\")|| name.equals(\"UInt64\")\n\t\t|| name.equals(\"SizeT\")\n\t\t) return Classification.NUMBER;\n\t\t\n\t\treturn Classification.CLASS;\n\t}\n\n\tpublic void resolve(Resolver res) {\n\t\tref = res.module.getType(name);\n\t}\n\n\tpublic boolean isSuperOf(Type type) {\n\t\tif(type == null) return false;\n\t\tif(this.equals(type)) return false;\n\t\tif(name.length() == 0 || type.name.length() == 0) return false;\n\t\t\n\t\tif(type.getRef() instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) type.getRef();\n\t\t\tif(typeDecl.getSuperRef() != null) {\n\t\t\t\tType superType = typeDecl.getSuperRef().getType();\n\t\t\t\tif(superType.getName().equals(this.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn isSuperOf(superType);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String getHierarchyRepr() {\n\t\tString repr = name;\n\t\tType t = this;\n\t\twhile(t.ref != null) {\n\t\t\tif(!(t.ref instanceof TypeDecl)) break;\n\t\t\tTypeDecl typeDecl = (TypeDecl) t.ref;\n\t\t\tif(typeDecl.getSuperRef() == null) break;\n\t\t\tt = typeDecl.getSuperRef().getType();\n\t\t\trepr += \":\" + t;\n\t\t}\n\t\treturn repr;\n\t}\n\n\t@Override\n\tpublic Type clone() {\n\t\tType clone = new Type(name, pointerLevel, referenceLevel, startToken);\n\t\tclone.ref = ref;\n\t\tclone.isArray = isArray;\n\t\tclone.isConst = isConst;\n\t\tclone.typeParams.addAll(typeParams);\n\t\treturn clone;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn ref instanceof TypeParam;\n\t}\n\t\n\tpublic boolean isGenericRecursive() {\n\t\treturn (ref instanceof TypeParam) || !typeParams.isEmpty();\n\t}\n\n\tpublic Expression getArraySize() {\n\t\treturn arraySize;\n\t}\n\n\tpublic void setArraySize(Expression arraySize) {\n\t\tthis.arraySize = arraySize;\n\t}\n\n\tpublic boolean softEquals(Type type, Resolver res) {\n\t\tif(type == null) return false;\n\t\tresolve(res);\n\t\tif(equals(type)) {\n\t\t\treturn true;\n\t\t}\n\t\tDeclaration ref = type.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tif(typeDecl.getSuperType() != null) {\n\t\t\t\tType subType = typeDecl.getSuperType();\n\t\t\t\treturn softEquals(subType, res);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(\t\tgetClassification() == Classification.NUMBER\n\t\t&& type.getClassification() == Classification.NUMBER) return true;\n\t\treturn false;\n\t}\n\t\n\tpublic boolean isPrefixed() {\n\t\n\t\treturn (ref instanceof ClassDecl || (ref instanceof CoverDecl && !((CoverDecl) ref).isExtern()));\n\t\t\n\t}\n\n\tpublic String getUnderName() {\n\t\t\n\t\tif(isPrefixed()) return ((TypeDecl) ref).getUnderName();\n\t\treturn getName();\n\t\t\n\t}\n\n\tpublic Type dereference() {\n\t\tType clone = clone();\n\t\tclone.setPointerLevel(getPointerLevel() - 1);\n\t\treturn clone;\n\t}\n\t\n}\n\n","lineNo":263}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.IntLiteral.Format;\nimport org.ooc.frontend.model.NodeList.AddListener;\nimport org.ooc.frontend.model.interfaces.MustBeUnwrapped;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionDecl extends Declaration implements Scope, Generic, MustBeUnwrapped, PotentiallyStatic {\n\n\tpublic static Type type = new FuncType(Token.defaultToken);\n\t\n\tprotected OocDocComment comment;\n\t\n\tprotected boolean isFinal;\n\tprotected boolean isStatic;\n\tprotected boolean isAbstract;\n\tprotected boolean isProto = false;\n\tprotected boolean isInline = false;\n\tprotected boolean fromPointer = false;\n\t\n\tprotected TypeDecl typeDecl;\n\n\tprotected String suffix;\n\tprivate final NodeList<Line> body;\n\t\n\tprotected Type returnType;\n\t// when the return type is generic, the returnArg is a pointer.\n\tprotected Argument returnArg;\n\t\n\tprotected final LinkedHashMap<String, TypeParam> typeParams;\n\tprivate final NodeList<Argument> arguments;\n\t\n\tpublic FunctionDecl(String name, String suffix, boolean isFinal,\n\t\t\tboolean isStatic, boolean isAbstract, boolean isExtern, Token startToken) {\n\t\tthis(name, suffix, isFinal, isStatic, isAbstract, isExtern ? \"\" : null, startToken);\n\t}\n\t\n\tpublic FunctionDecl(String name, String suffix, boolean isFinal,\n\t\t\tboolean isStatic, boolean isAbstract, String externName, Token startToken) {\n\t\tsuper(name, externName, startToken);\n\t\tthis.suffix = suffix;\n\t\tthis.isFinal = isFinal;\n\t\tthis.isStatic = isStatic;\n\t\tthis.isAbstract = isAbstract;\n\t\tthis.body = new NodeList<Line>(startToken);\n\t\tthis.returnType = name.equals(\"main\") ? IntLiteral.type : Type.getVoid();\n\t\tthis.arguments = new NodeList<Argument>(startToken);\n\t\tthis.arguments.addAddListener(new AddListener<Argument>() {\n\t\t\tpublic void onAdd(NodeList<Argument> list, Argument arg) {\n\t\t\t\tTypeParam typeParam = typeParams.get(arg.getName());\n\t\t\t\tif(typeParam != null) {\n\t\t\t\t\ttypeParam.setGhost(true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.typeParams = new LinkedHashMap<String, TypeParam>();\n\t\t// FIXME this will bite us in the ass later. Ohh yes it will\n\t\t// you see, nothing guarantees that \"__returnArg\" isn't in the scope already\n\t\t// we should create returnArg in resolve instead, using generateTempName()\n\t\tthis.returnArg = new RegularArgument(NullLiteral.type, \"__returnArg\", startToken);\n\t}\n\n\tpublic LinkedHashMap<String, TypeParam> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic void setComment(OocDocComment comment) {\n\t\tthis.comment = comment;\n\t}\n\t\n\tpublic OocDocComment getComment() {\n\t\treturn comment;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic boolean isFromPointer() {\n\t\treturn fromPointer;\n\t}\n\t\n\tpublic void setFromPointer(boolean fromPointer) {\n\t\tthis.fromPointer = fromPointer;\n\t}\n\t\n\tpublic boolean isProto() {\n\t\treturn isProto;\n\t}\n\t\n\tpublic void setProto(boolean isProto) {\n\t\tthis.isProto = isProto;\n\t}\n\t\n\tpublic boolean isAbstract() {\n\t\treturn isAbstract;\n\t}\n\t\n\tpublic void setAbstract(boolean isAbstract) {\n\t\tthis.isAbstract = isAbstract;\n\t}\n\t\n\tpublic boolean isStatic() {\n\t\treturn isStatic;\n\t}\n\t\n\tpublic void setStatic(boolean isStatic) {\n\t\tthis.isStatic = isStatic;\n\t}\n\t\n\tpublic boolean isFinal() {\n\t\treturn isFinal;\n\t}\n\t\n\tpublic void setFinal(boolean isFinal) {\n\t\tthis.isFinal = isFinal;\n\t}\n\t\n\t@Override\n\tpublic TypeDecl getTypeDecl() {\n\t\treturn typeDecl;\n\t}\n\t\n\tpublic boolean isInline() {\n\t\treturn isInline;\n\t}\n\t\n\tpublic void setInline(boolean isInline) {\n\t\tthis.isInline = isInline;\n\t}\n\t\n\tpublic void setTypeDecl(TypeDecl typeDecl) {\n\t\tthis.typeDecl = typeDecl;\n\t}\n\t\n\t/**\n\t * @return true if it's a member function\n\t */\n\tpublic boolean isMember() {\n\t\treturn typeDecl != null;\n\t}\n\t\n\tpublic boolean hasThis() {\n\t\treturn !isStatic() && isMember();\n\t}\n\t\n\tpublic NodeList<Line> getBody() {\n\t\treturn body;\n\t}\n\t\n\tpublic Type getReturnType() {\n\t\treturn returnType;\n\t}\n\t\n\tpublic void setReturnType(Type returnType) {\n\t\tthis.returnType = returnType;\n\t}\n\t\n\tpublic NodeList<Argument> getArguments() {\n\t\treturn arguments;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif (typeParams.size() > 0) for (TypeParam typeParam: typeParams.values()) {\n\t\t\ttypeParam.getType().accept(visitor);\n\t\t}\n\t\targuments.accept(visitor);\n\t\treturnType.accept(visitor);\n\t\treturnArg.getType().accept(visitor);\n\t\tbody.accept(visitor);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(oldie == returnType) {\n\t\t\treturnType = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tpublic String getArgsRepr() {\n\t\treturn getArgsRepr(hasThis());\n\t}\t\n\t\n\tpublic String getArgsRepr(boolean skipThis) {\n\t\t\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Argument> iter = arguments.iterator();\n\t\tif(skipThis && hasThis()) iter.next();\n\t\twhile(iter.hasNext()) {\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg instanceof VarArg) sB.append(\"...\");\n\t\t\telse sB.append(arg.getType());\n\t\t\t\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tString name = isMember() ? typeDecl.getType() + \".\" + getSuffixedName() : getSuffixedName();\n\t\tString repr = /*getClass().getSimpleName()+\" : \"+*/name+getArgsRepr();\n\t\treturn repr;\n\t\t\n\t}\n\n\tpublic String getFullName() {\n\t\t\n\t\tStringBuilder sB = new StringBuilder();\n\t\ttry {\n\t\t\twriteFullName(sB);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn sB.toString();\n\t\t\n\t}\n\n\tpublic void writeFullName(Appendable dst) throws IOException {\n\t\t\n\t\tif(externName != null && externName.length() > 0) {\n\t\t\tdst.append(externName);\n\t\t} else {\n\t\t\tif(isMember()) {\n\t\t\t\tdst.append(typeDecl.getExternName()).append('_');\n\t\t\t}\n\t\t\twriteSuffixedName(dst);\n\t\t}\n\t\t\n\t}\n\n\tpublic void writeSuffixedName(Appendable dst) throws IOException {\n\t\t\n\t\tdst.append(getExternName());\n\t\tif(suffix.length() > 0) {\n\t\t\tdst.append('_').append(suffix);\n\t\t}\n\t\t\n\t}\n\n\tpublic String getProtoRepr() {\n\t\treturn getProtoRepr(hasThis());\n\t}\n\t\n\tpublic String getProtoRepr(boolean skipThis) {\n\t\tif(typeDecl != null) return typeDecl.getName()+\".\"+name+getArgsRepr(skipThis);\n\t\treturn name+getArgsRepr(skipThis);\n\t}\n\n\tpublic boolean sameProto(FunctionDecl decl2) {\n\t\treturn name.equals(decl2.getName()) && (suffix.equals(decl2.getSuffix()));\n\t}\n\n\tpublic boolean isEntryPoint() {\n\t\treturn name.equals(\"main\");\n\t}\n\n\tpublic VariableDecl getVariable(String name) {\n\t\tif(arguments.size() > 0) for(Argument argument: arguments) {\n\t\t\tif(argument.hasAtom(name)) return argument;\n\t\t}\n\t\treturn getVariable(body, name);\n\t}\n\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tif(arguments.size() > 0) for(Argument argument: arguments) {\n\t\t\tvariables.add(argument);\n\t\t}\n\t\tgetVariables(body, variables);\n\t}\n\t\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call) {\n\t\treturn null;\n\t}\n\n\tpublic void getFunctions(NodeList<FunctionDecl> functions) {}\n\n\tpublic String getSuffixedName() {\n\t\tif(suffix.length() == 0) return name;\n\t\treturn name+\"_\"+suffix;\n\t}\n\n\tpublic boolean unwrap(NodeList<Node> stack) throws IOException {\n\t\tif(name.length() == 0) {\n\t\t\tModule module = stack.getModule();\n\t\t\tname = stack.get(0).generateTempName(module.getUnderName()+\"_closure\", stack);\n\t\t\tVariableAccess varAcc = new VariableAccess(name, startToken);\n\t\t\tvarAcc.setRef(this);\n\t\t\tstack.peek().replace(this, varAcc);\n\t\t\tmodule.getBody().add(this);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(isEntryPoint()) {\n\t\t\tif(arguments.size() == 1 && arguments.getFirst().getType().getName().equals(\"Array\")) {\n\t\t\t\tArgument arg = arguments.getFirst();\n\t\t\t\targuments.clear();\n\t\t\t\tArgument argc = new RegularArgument(IntLiteral.type, \"argc\", arg.startToken);\n\t\t\t\tArgument argv = new RegularArgument(new Type(\"String\", 1, arg.startToken), \"argv\", arg.startToken);\n\t\t\t\targuments.add(argc);\n\t\t\t\targuments.add(argv);\n\t\t\t\t\n\t\t\t\tMemberCall constructCall = new MemberCall(new TypeAccess(arg.getType()), \"new\", \"withData\", arg.startToken);\n\t\t\t\tconstructCall.getTypeParams().add(new TypeAccess(NullLiteral.type));\n\t\t\t\tconstructCall.getArguments().add(new VariableAccess(argv, startToken));\n\t\t\t\tconstructCall.getArguments().add(new VariableAccess(argc, startToken));\n\t\t\t\t\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(arg.getName(), \n\t\t\t\t\t\tconstructCall, arg.startToken);\n\t\t\t\t\n\t\t\t\tbody.add(0, new Line(vdfe));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic boolean isExternWithName() {\n\t\treturn externName != null && externName.length() > 0;\n\t}\n\n\tpublic Argument getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic boolean isNamed(String name, String suffix) {\n\t\treturn this.name.equals(name) && (suffix == null || this.suffix.equals(suffix));\n\t}\n\n\tpublic boolean isSpecialFunc() {\n\t\treturn name.equals(ClassDecl.DEFAULTS_FUNC_NAME)\n\t\t\t|| name.equals(ClassDecl.DESTROY_FUNC_NAME)\n\t\t\t|| name.equals(ClassDecl.LOAD_FUNC_NAME);\n\t}\n\n\tpublic Iterator<Argument> getThisLessArgsIter() {\n\t\tIterator<Argument> iter = getArguments().iterator();\n\t\tif(hasThis()) iter.next();\n\t\treturn iter;\n\t}\n\n\tpublic boolean hasReturn() {\n\t\treturn !getReturnType().isVoid() && !(getReturnType().getRef() instanceof TypeParam);\n\t}\n\n\tpublic TypeParam getGenericType(String name) {\n\t\tTypeParam genericType = typeParams.get(name);\n\t\tif(genericType == null && typeDecl != null) {\n\t\t\tMap<String, TypeParam> classGenerics = typeDecl.getTypeParams();\n\t\t\tgenericType = classGenerics.get(name);\n\t\t\treturn genericType;\n\t\t}\n\t\treturn genericType;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\tif(typeParams.size() > 0) return true;\n\t\tif(typeDecl != null && typeDecl.getTypeParams().size() > 0) return true;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tfor(Argument arg: arguments) {\n\t\t\tType argType = arg.getType();\n\t\t\tif(argType != null && !argType.isResolved()) {\n\t\t\t\tstack.push(arguments);\n\t\t\t\tstack.push(arg);\n\t\t\t\twhile(argType.getRef() == null) {\n\t\t\t\t\targType.resolve(stack, res, true);\n\t\t\t\t}\n\t\t\t\tstack.pop(arg);\n\t\t\t\tstack.pop(arguments);\n\t\t\t}\n\t\t}\n\t\t\n\t\tResponse response = super.resolve(stack, res, fatal);\n\t\tif(response != Response.OK) return response;\n\t\t\n\t\tif(isMember() && typeDecl.getSuperRef() != null) {\n\t\t\tFunctionDecl sup = typeDecl.getSuperRef().getFunction(name, suffix, null);\n\t\t\tif(sup != null && (sup.getArguments().size() != getArguments().size())) {\n\t\t\t\tif(name.equals(\"new\") || name.equals(\"init\")) {\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"There's no no-argument constructor in super-type \"\n\t\t\t\t\t\t\t+typeDecl.getSuperRef().getName()+\", you should add a constructor to \"\n\t\t\t\t\t\t\t+typeDecl.getName()+\" with a suffix, e.g. init: func ~mySuffix () {}\");\n\t\t\t\t}\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Definition of \"\n\t\t\t\t\t\t+this+\" conflicts with definition in super-type \"\n\t\t\t\t\t\t+typeDecl.getSuperRef().getName()+\", you should add a suffix to this one or make it have the same arguments.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!getReturnType().isVoid() && !isExtern() && !isAbstract()) {\n\t\t\t\n\t\t\tif(getBody().isEmpty()) {\n\t\t\t\tif(getName().equals(\"main\")) {\n\t\t\t\t\tgetBody().add(new Line(new ValuedReturn(\n\t\t\t\t\t\t\tnew IntLiteral(0, Format.DEC, startToken), startToken)));\n\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t} /*else {\n\t\t\t\t\t\n\t\t\t\t\tthrow new OocCompilationError(node, stack,\n\t\t\t\t\t\t\t\"Returning nothing in function \"+getProtoRepr()\n\t\t\t\t\t\t\t\t+\" that should return a \"+getReturnType());\n\t\t\t\t\t\n\t\t\t\t}*/\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tLine line = getBody().getLast();\n\t\t\t\tif(!(line.getStatement() instanceof Return)) {\n\t\t\t\t\tif(isEntryPoint()) {\n\t\t\t\t\t\tgetBody().add(new Line(new ValuedReturn(\n\t\t\t\t\t\t\t\tnew IntLiteral(0, Format.DEC, startToken), startToken)));\n\t\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t\t} else if(line.getStatement() instanceof Expression) {\n\t\t\t\t\t\tline.setStatement(new ValuedReturn((Expression) line.getStatement(),\n\t\t\t\t\t\t\t\tline.getStatement().startToken));\n\t\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t\t} /*else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tthrow new OocCompilationError(node, stack,\n\t\t\t\t\t\t\t\t\"Returning nothing in function \"+getProtoRepr()\n\t\t\t\t\t\t\t\t\t+\" that should return a \"+getReturnType());\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t}\n\n\tpublic String getStub() {\n\t\t\n\t\tStringBuffer buff = new StringBuffer(name);\n\t\tbuff.append(\": func \");\n\t\tif(arguments.size() > 0) {\n\t\t\tbuff.append(\"(\");\n\t\t\tIterator<Argument> iter = arguments.iterator();\n\t\t\tif(iter.hasNext() && hasThis()) iter.next(); // skip this\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tArgument arg = iter.next();\n\t\t\t\tbuff.append(arg.getName());\n\t\t\t\tbuff.append(\": \");\n\t\t\t\tbuff.append(arg.getType());\n\t\t\t\tif(iter.hasNext()) buff.append(\", \");\n\t\t\t}\n\t\t\tbuff.append(\")\");\n\t\t}\n\t\tbuff.append(\" {}\");\n\t\t \n\t\treturn buff.toString();\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.IntLiteral.Format;\nimport org.ooc.frontend.model.NodeList.AddListener;\nimport org.ooc.frontend.model.interfaces.MustBeUnwrapped;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionDecl extends Declaration implements Scope, Generic, MustBeUnwrapped, PotentiallyStatic {\n\n\tpublic static Type type = new FuncType(Token.defaultToken);\n\t\n\tprotected OocDocComment comment;\n\t\n\tprotected boolean isFinal;\n\tprotected boolean isStatic;\n\tprotected boolean isAbstract;\n\tprotected boolean isProto = false;\n\tprotected boolean isInline = false;\n\tprotected boolean fromPointer = false;\n\t\n\tprotected TypeDecl typeDecl;\n\n\tprotected String suffix;\n\tprivate final NodeList<Line> body;\n\t\n\tprotected Type returnType;\n\t// when the return type is generic, the returnArg is a pointer.\n\tprotected Argument returnArg;\n\t\n\tprotected final LinkedHashMap<String, TypeParam> typeParams;\n\tprivate final NodeList<Argument> arguments;\n\t\n\tpublic FunctionDecl(String name, String suffix, boolean isFinal,\n\t\t\tboolean isStatic, boolean isAbstract, boolean isExtern, Token startToken) {\n\t\tthis(name, suffix, isFinal, isStatic, isAbstract, isExtern ? \"\" : null, startToken);\n\t}\n\t\n\tpublic FunctionDecl(String name, String suffix, boolean isFinal,\n\t\t\tboolean isStatic, boolean isAbstract, String externName, Token startToken) {\n\t\tsuper(name, externName, startToken);\n\t\tthis.suffix = suffix;\n\t\tthis.isFinal = isFinal;\n\t\tthis.isStatic = isStatic;\n\t\tthis.isAbstract = isAbstract;\n\t\tthis.body = new NodeList<Line>(startToken);\n\t\tthis.returnType = name.equals(\"main\") ? IntLiteral.type : Type.getVoid();\n\t\tthis.arguments = new NodeList<Argument>(startToken);\n\t\tthis.arguments.addAddListener(new AddListener<Argument>() {\n\t\t\tpublic void onAdd(NodeList<Argument> list, Argument arg) {\n\t\t\t\tTypeParam typeParam = typeParams.get(arg.getName());\n\t\t\t\tif(typeParam != null) {\n\t\t\t\t\ttypeParam.setGhost(true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.typeParams = new LinkedHashMap<String, TypeParam>();\n\t\t// FIXME this will bite us in the ass later. Ohh yes it will\n\t\t// you see, nothing guarantees that \"__returnArg\" isn't in the scope already\n\t\t// we should create returnArg in resolve instead, using generateTempName()\n\t\tthis.returnArg = new RegularArgument(NullLiteral.type, \"__returnArg\", startToken);\n\t}\n\n\tpublic LinkedHashMap<String, TypeParam> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic void setComment(OocDocComment comment) {\n\t\tthis.comment = comment;\n\t}\n\t\n\tpublic OocDocComment getComment() {\n\t\treturn comment;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic boolean isFromPointer() {\n\t\treturn fromPointer;\n\t}\n\t\n\tpublic void setFromPointer(boolean fromPointer) {\n\t\tthis.fromPointer = fromPointer;\n\t}\n\t\n\tpublic boolean isProto() {\n\t\treturn isProto;\n\t}\n\t\n\tpublic void setProto(boolean isProto) {\n\t\tthis.isProto = isProto;\n\t}\n\t\n\tpublic boolean isAbstract() {\n\t\treturn isAbstract;\n\t}\n\t\n\tpublic void setAbstract(boolean isAbstract) {\n\t\tthis.isAbstract = isAbstract;\n\t}\n\t\n\tpublic boolean isStatic() {\n\t\treturn isStatic;\n\t}\n\t\n\tpublic void setStatic(boolean isStatic) {\n\t\tthis.isStatic = isStatic;\n\t}\n\t\n\tpublic boolean isFinal() {\n\t\treturn isFinal;\n\t}\n\t\n\tpublic void setFinal(boolean isFinal) {\n\t\tthis.isFinal = isFinal;\n\t}\n\t\n\t@Override\n\tpublic TypeDecl getTypeDecl() {\n\t\treturn typeDecl;\n\t}\n\t\n\tpublic boolean isInline() {\n\t\treturn isInline;\n\t}\n\t\n\tpublic void setInline(boolean isInline) {\n\t\tthis.isInline = isInline;\n\t}\n\t\n\tpublic void setTypeDecl(TypeDecl typeDecl) {\n\t\tthis.typeDecl = typeDecl;\n\t}\n\t\n\t/**\n\t * @return true if it's a member function\n\t */\n\tpublic boolean isMember() {\n\t\treturn typeDecl != null;\n\t}\n\t\n\tpublic boolean hasThis() {\n\t\treturn !isStatic() && isMember();\n\t}\n\t\n\tpublic NodeList<Line> getBody() {\n\t\treturn body;\n\t}\n\t\n\tpublic Type getReturnType() {\n\t\treturn returnType;\n\t}\n\t\n\tpublic void setReturnType(Type returnType) {\n\t\tthis.returnType = returnType;\n\t}\n\t\n\tpublic NodeList<Argument> getArguments() {\n\t\treturn arguments;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif (typeParams.size() > 0) for (TypeParam typeParam: typeParams.values()) {\n\t\t\ttypeParam.getType().accept(visitor);\n\t\t}\n\t\targuments.accept(visitor);\n\t\treturnType.accept(visitor);\n\t\treturnArg.getType().accept(visitor);\n\t\tbody.accept(visitor);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(oldie == returnType) {\n\t\t\treturnType = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tpublic String getArgsRepr() {\n\t\treturn getArgsRepr(hasThis());\n\t}\t\n\t\n\tpublic String getArgsRepr(boolean skipThis) {\n\t\t\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Argument> iter = arguments.iterator();\n\t\tif(skipThis && hasThis()) iter.next();\n\t\twhile(iter.hasNext()) {\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg instanceof VarArg) sB.append(\"...\");\n\t\t\telse sB.append(arg.getType());\n\t\t\t\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tString name = isMember() ? typeDecl.getType() + \".\" + getSuffixedName() : getSuffixedName();\n\t\tString repr = /*getClass().getSimpleName()+\" : \"+*/name+getArgsRepr();\n\t\treturn repr;\n\t\t\n\t}\n\n\tpublic String getFullName() {\n\t\t\n\t\tStringBuilder sB = new StringBuilder();\n\t\ttry {\n\t\t\twriteFullName(sB);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn sB.toString();\n\t\t\n\t}\n\n\tpublic void writeFullName(Appendable dst) throws IOException {\n\t\t\n\t\tif(externName != null && externName.length() > 0) {\n\t\t\tdst.append(externName);\n\t\t} else {\n\t\t\tif(isMember()) {\n\t\t\t\tdst.append(typeDecl.getExternName()).append('_');\n\t\t\t}\n\t\t\twriteSuffixedName(dst);\n\t\t}\n\t\t\n\t}\n\n\tpublic void writeSuffixedName(Appendable dst) throws IOException {\n\t\t\n\t\tdst.append(getExternName());\n\t\tif(suffix.length() > 0) {\n\t\t\tdst.append('_').append(suffix);\n\t\t}\n\t\t\n\t}\n\n\tpublic String getProtoRepr() {\n\t\treturn getProtoRepr(hasThis());\n\t}\n\t\n\tpublic String getProtoRepr(boolean skipThis) {\n\t\tif(typeDecl != null) return typeDecl.getName()+\".\"+name+getArgsRepr(skipThis);\n\t\treturn name+getArgsRepr(skipThis);\n\t}\n\n\tpublic boolean sameProto(FunctionDecl decl2) {\n\t\treturn name.equals(decl2.getName()) && (suffix.equals(decl2.getSuffix()));\n\t}\n\n\tpublic boolean isEntryPoint() {\n\t\treturn name.equals(\"main\");\n\t}\n\n\tpublic VariableDecl getVariable(String name) {\n\t\tif(arguments.size() > 0) for(Argument argument: arguments) {\n\t\t\tif(argument.hasAtom(name)) return argument;\n\t\t}\n\t\treturn getVariable(body, name);\n\t}\n\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tif(arguments.size() > 0) for(Argument argument: arguments) {\n\t\t\tvariables.add(argument);\n\t\t}\n\t\tgetVariables(body, variables);\n\t}\n\t\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call) {\n\t\treturn null;\n\t}\n\n\tpublic void getFunctions(NodeList<FunctionDecl> functions) {}\n\n\tpublic String getSuffixedName() {\n\t\tif(suffix.length() == 0) return name;\n\t\treturn name+\"_\"+suffix;\n\t}\n\n\tpublic boolean unwrap(NodeList<Node> stack) throws IOException {\n\t\tif(name.length() == 0) {\n\t\t\tModule module = stack.getModule();\n\t\t\tname = stack.get(0).generateTempName(module.getUnderName()+\"_closure\", stack);\n\t\t\tVariableAccess varAcc = new VariableAccess(name, startToken);\n\t\t\tvarAcc.setRef(this);\n\t\t\tstack.peek().replace(this, varAcc);\n\t\t\tmodule.getBody().add(this);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(isEntryPoint()) {\n\t\t\tif(arguments.size() == 1 && arguments.getFirst().getType().getName().equals(\"Array\")) {\n\t\t\t\tArgument arg = arguments.getFirst();\n\t\t\t\targuments.clear();\n\t\t\t\tArgument argc = new RegularArgument(IntLiteral.type, \"argc\", arg.startToken);\n\t\t\t\tArgument argv = new RegularArgument(new Type(\"String\", 1, arg.startToken), \"argv\", arg.startToken);\n\t\t\t\targuments.add(argc);\n\t\t\t\targuments.add(argv);\n\t\t\t\t\n\t\t\t\tMemberCall constructCall = new MemberCall(new TypeAccess(arg.getType()), \"new\", \"withData\", arg.startToken);\n\t\t\t\tconstructCall.getTypeParams().add(new TypeAccess(NullLiteral.type));\n\t\t\t\tconstructCall.getArguments().add(new VariableAccess(argv, startToken));\n\t\t\t\tconstructCall.getArguments().add(new VariableAccess(argc, startToken));\n\t\t\t\t\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(arg.getName(), \n\t\t\t\t\t\tconstructCall, arg.startToken);\n\t\t\t\t\n\t\t\t\tbody.add(0, new Line(vdfe));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic boolean isExternWithName() {\n\t\treturn externName != null && externName.length() > 0;\n\t}\n\n\tpublic Argument getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic boolean isNamed(String name, String suffix) {\n\t\treturn this.name.equals(name) && (suffix == null || this.suffix.equals(suffix));\n\t}\n\n\tpublic boolean isSpecialFunc() {\n\t\treturn name.equals(ClassDecl.DEFAULTS_FUNC_NAME)\n\t\t\t|| name.equals(ClassDecl.DESTROY_FUNC_NAME)\n\t\t\t|| name.equals(ClassDecl.LOAD_FUNC_NAME);\n\t}\n\n\tpublic Iterator<Argument> getThisLessArgsIter() {\n\t\tIterator<Argument> iter = getArguments().iterator();\n\t\tif(hasThis()) iter.next();\n\t\treturn iter;\n\t}\n\n\tpublic boolean hasReturn() {\n\t\treturn !getReturnType().isVoid() && !(getReturnType().getRef() instanceof TypeParam);\n\t}\n\n\tpublic TypeParam getGenericType(String name) {\n\t\tTypeParam genericType = typeParams.get(name);\n\t\tif(genericType == null && typeDecl != null) {\n\t\t\tMap<String, TypeParam> classGenerics = typeDecl.getTypeParams();\n\t\t\tgenericType = classGenerics.get(name);\n\t\t\treturn genericType;\n\t\t}\n\t\treturn genericType;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\tif(typeParams.size() > 0) return true;\n\t\tif(typeDecl != null && typeDecl.getTypeParams().size() > 0) return true;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tfor(Argument arg: arguments) {\n\t\t\tType argType = arg.getType();\n\t\t\tif(argType != null && !argType.isResolved()) {\n\t\t\t\tstack.push(arguments);\n\t\t\t\tstack.push(arg);\n\t\t\t\twhile(argType.getRef() == null) {\n\t\t\t\t\targType.resolve(stack, res, true);\n\t\t\t\t}\n\t\t\t\tstack.pop(arg);\n\t\t\t\tstack.pop(arguments);\n\t\t\t}\n\t\t}\n\t\t\n\t\tResponse response = super.resolve(stack, res, fatal);\n\t\tif(response != Response.OK) return response;\n\t\t\n\t\tif(isMember() && typeDecl.getSuperRef() != null) {\n\t\t\tFunctionDecl sup = typeDecl.getSuperRef().getFunction(name, suffix, null);\n\t\t\tif(sup != null && (sup.getArguments().size() != getArguments().size())) {\n\t\t\t\tif(name.equals(\"new\") || name.equals(\"init\")) {\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"There's no no-argument constructor in super-type \"\n\t\t\t\t\t\t\t+typeDecl.getSuperRef().getName()+\", you should add a constructor to \"\n\t\t\t\t\t\t\t+typeDecl.getName()+\" with a suffix, e.g. init: func ~mySuffix () {}\");\n\t\t\t\t}\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Definition of \"\n\t\t\t\t\t\t+this+\" conflicts with definition in super-type \"\n\t\t\t\t\t\t+typeDecl.getSuperRef().getName()+\", you should add a suffix to this one or make it have the same arguments.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!getReturnType().isVoid() && !isExtern() && !isAbstract()) {\n\t\t\t\n\t\t\tif(getBody().isEmpty()) {\n\t\t\t\tif(getName().equals(\"main\")) {\n\t\t\t\t\tgetBody().add(new Line(new ValuedReturn(\n\t\t\t\t\t\t\tnew IntLiteral(0, Format.DEC, startToken), startToken)));\n\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t} /*else {\n\t\t\t\t\t\n\t\t\t\t\tthrow new OocCompilationError(node, stack,\n\t\t\t\t\t\t\t\"Returning nothing in function \"+getProtoRepr()\n\t\t\t\t\t\t\t\t+\" that should return a \"+getReturnType());\n\t\t\t\t\t\n\t\t\t\t}*/\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tLine line = getBody().getLast();\n\t\t\t\tif(!(line.getStatement() instanceof Return)) {\n\t\t\t\t\tif(isEntryPoint()) {\n\t\t\t\t\t\tgetBody().add(new Line(new ValuedReturn(\n\t\t\t\t\t\t\t\tnew IntLiteral(0, Format.DEC, startToken), startToken)));\n\t\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t\t} else if(line.getStatement() instanceof Expression) {\n\t\t\t\t\t\tline.setStatement(new ValuedReturn((Expression) line.getStatement(),\n\t\t\t\t\t\t\t\tline.getStatement().startToken));\n\t\t\t\t\t\t//return Response.RESTART;\n\t\t\t\t\t} /*else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tthrow new OocCompilationError(node, stack,\n\t\t\t\t\t\t\t\t\"Returning nothing in function \"+getProtoRepr()\n\t\t\t\t\t\t\t\t\t+\" that should return a \"+getReturnType());\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t}\n\n\tpublic String getStub() {\n\t\t\n\t\tStringBuffer buff = new StringBuffer(name);\n\t\tbuff.append(\": func \");\n\t\tint numArgs = arguments.size();\n\t\tif(hasThis()) numArgs--;\n\t\tif(numArgs > 0) {\n\t\t\tbuff.append(\"(\");\n\t\t\tIterator<Argument> iter = arguments.iterator();\n\t\t\tif(iter.hasNext() && hasThis()) iter.next(); // skip this\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tArgument arg = iter.next();\n\t\t\t\tbuff.append(arg.getName());\n\t\t\t\tbuff.append(\": \");\n\t\t\t\tbuff.append(arg.getType());\n\t\t\t\tif(iter.hasNext()) buff.append(\", \");\n\t\t\t}\n\t\t\tbuff.append(\")\");\n\t\t}\n\t\tbuff.append(\" {}\");\n\t\t \n\t\treturn buff.toString();\n\t\t\n\t}\n\t\n}\n","lineNo":479}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Foreach extends ControlStatement implements MustBeResolved {\n\n\tprotected Expression variable;\n\tprotected Expression collection; // must be of type Range or Iterable\n\t\n\tpublic Foreach(Expression variable, Expression collection, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.variable = variable;\n\t\tthis.collection = collection;\n\t}\n\t\n\tpublic Expression getVariable() {\n\t\treturn variable;\n\t}\n\t\n\tpublic void setVariable(VariableDecl variable) {\n\t\tthis.variable = variable;\n\t}\n\t\n\tpublic Expression getCollection() {\n\t\treturn collection;\n\t}\n\t\n\tpublic void setCollection(Expression range) {\n\t\tthis.collection = range;\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tvariable.accept(visitor);\n\t\tcollection.accept(visitor);\n\t\tbody.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == variable) {\n\t\t\tvariable = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == collection) {\n\t\t\tcollection = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tif(variable instanceof VariableDecl) {\n\t\t\tVariableDecl varDecl = (VariableDecl) variable;\n\t\t\tif(varDecl.hasAtom(name)) return varDecl;\n\t\t} else if(variable instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) variable;\n\t\t\tif(varAcc.getName().equals(name)) return (VariableDecl) varAcc.getRef();\n\t\t}\n\t\treturn super.getVariable(name);\n\t}\n\t\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tif(variable instanceof VariableDecl) {\n\t\t\tVariableDecl varDecl = (VariableDecl) variable;\n\t\t\tvariables.add(varDecl);\n\t\t} else if(variable instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) variable;\n\t\t\tif(varAcc.getRef() != null)\n\t\t\t\tvariables.add((VariableDecl) varAcc.getRef());\n\t\t}\n\t\tsuper.getVariables(variables);\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(collection.getType() == null || (!collection.getType().getName().equals(\"Range\") && collection.getType().getRef() == null)) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(collection, stack, \"Couldn't resolve type \"\n\t\t\t\t\t\t+collection.getType()+\" of foreach's collection (ref = \"+collection.getType().getRef());\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\n\t\tif(collection.getType().getRef() instanceof ClassDecl) {\n\t\t\tClassDecl classDecl = (ClassDecl) collection.getType().getRef();\n\t\t\tif(classDecl.isChildOf(\"Iterable\")) {\n\t\t\t\tMemberCall iterCall = new MemberCall(collection, \"iterator\", \"\", startToken);\n\t\t\t\tResponse resp = Response.LOOP;\n\t\t\t\twhile(resp == Response.LOOP) {\n\t\t\t\t\tresp = iterCall.resolve(stack, res, true);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tType iterType = iterCall.getType();\n\t\t\t\titerType.resolve(stack, res, false);\n\t\t\t\tif(iterType.getRef() == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"couldn't resolve iterType \"+iterType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\n\t\t\t\tint lineIndex = stack.find(Line.class);\n\t\t\t\tLine line = (Line) stack.get(lineIndex);\n\t\t\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\t\t\t\n\t\t\t\tBlock block = new Block(startToken);\n\t\t\t\t\n\t\t\t\tVariableDecl vdfe = new VariableDecl(iterCall.getType(), false, startToken);\n\t\t\t\tvdfe.setType(iterType);\n\t\t\t\tvdfe.getAtoms().add(new VariableDeclAtom(generateTempName(\"iter\", stack),\n\t\t\t\t\t\titerCall, startToken));\n\n\t\t\t\tVariableAccess iterAcc = new VariableAccess(vdfe.getName(), startToken);\n\t\t\t\titerAcc.setRef(vdfe);\n\t\t\t\t\n\t\t\t\tMemberCall hasNextCall = new MemberCall(iterAcc, \"hasNext\", \"\", startToken);\n\t\t\t\thasNextCall.resolve(stack, res, true);\n\t\t\t\tWhile while1 = new While(hasNextCall, startToken);\n\t\t\t\t\n\t\t\t\tMemberCall nextCall = new MemberCall(iterAcc, \"next\", \"\", startToken);\n\t\t\t\tnextCall.resolve(stack, res, true);\n\t\t\t\t\n\t\t\t\tif(variable instanceof VariableAccess) {\n\t\t\t\t\tVariableAccess varAcc = (VariableAccess) variable;\n\t\t\t\t\tif(varAcc.getRef() == null) {\n\t\t\t\t\t\tVariableDecl varDecl = new VariableDecl(iterCall.getType().getTypeParams().getFirst().getType(), false, varAcc.startToken);\n\t\t\t\t\t\tvarDecl.getAtoms().add(new VariableDeclAtom(varAcc.getName(), null, varAcc.startToken));\n\t\t\t\t\t\tblock.getBody().add(0, new Line(varDecl));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// FIXME what if variable isn't an Access?\n\t\t\t\twhile1.getBody().add(new Line(new Assignment(variable, nextCall, startToken)));\n\t\t\t\twhile1.getBody().addAll(getBody());\n\t\t\t\t\n\t\t\t\tlist.replace(line, new Line(block));\n\t\t\t\tblock.getBody().add(new Line(vdfe));\n\t\t\t\tblock.getBody().add(new Line(while1));\n\t\t\t\t\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Foreach extends ControlStatement implements MustBeResolved {\n\n\tprotected Expression variable;\n\tprotected Expression collection; // must be of type Range or Iterable\n\t\n\tpublic Foreach(Expression variable, Expression collection, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.variable = variable;\n\t\tthis.collection = collection;\n\t}\n\t\n\tpublic Expression getVariable() {\n\t\treturn variable;\n\t}\n\t\n\tpublic void setVariable(VariableDecl variable) {\n\t\tthis.variable = variable;\n\t}\n\t\n\tpublic Expression getCollection() {\n\t\treturn collection;\n\t}\n\t\n\tpublic void setCollection(Expression range) {\n\t\tthis.collection = range;\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tvariable.accept(visitor);\n\t\tcollection.accept(visitor);\n\t\tbody.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == variable) {\n\t\t\tvariable = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == collection) {\n\t\t\tcollection = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tif(variable instanceof VariableDecl) {\n\t\t\tVariableDecl varDecl = (VariableDecl) variable;\n\t\t\tif(varDecl.hasAtom(name)) return varDecl;\n\t\t} else if(variable instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) variable;\n\t\t\tif(varAcc.getName().equals(name)) return (VariableDecl) varAcc.getRef();\n\t\t}\n\t\treturn super.getVariable(name);\n\t}\n\t\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tif(variable instanceof VariableDecl) {\n\t\t\tVariableDecl varDecl = (VariableDecl) variable;\n\t\t\tvariables.add(varDecl);\n\t\t} else if(variable instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) variable;\n\t\t\tif(varAcc.getRef() != null)\n\t\t\t\tvariables.add((VariableDecl) varAcc.getRef());\n\t\t}\n\t\tsuper.getVariables(variables);\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(collection.getType() == null || (!collection.getType().getName().equals(\"Range\") && collection.getType().getRef() == null)) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(collection, stack, \"Couldn't resolve type \"\n\t\t\t\t\t\t+collection.getType()+\" of foreach's collection (ref = \"+collection.getType().getRef());\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\n\t\tif(collection.getType().getRef() instanceof ClassDecl) {\n\t\t\tClassDecl classDecl = (ClassDecl) collection.getType().getRef();\n\t\t\tif(classDecl.isChildOf(\"Iterable\")) {\n\t\t\t\tMemberCall iterCall = new MemberCall(collection, \"iterator\", \"\", startToken);\n\t\t\t\tResponse resp = Response.LOOP;\n\t\t\t\twhile(resp == Response.LOOP) {\n\t\t\t\t\tresp = iterCall.resolve(stack, res, true);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tType iterType = iterCall.getType();\n\t\t\t\titerType.resolve(stack, res, false);\n\t\t\t\tif(iterType.getRef() == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"couldn't resolve iterType \"+iterType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\n\t\t\t\tint lineIndex = stack.find(Line.class);\n\t\t\t\tLine line = (Line) stack.get(lineIndex);\n\t\t\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\t\t\t\n\t\t\t\tBlock block = new Block(startToken);\n\t\t\t\t\n\t\t\t\tVariableDecl vdfe = new VariableDecl(iterCall.getType(), false, startToken);\n\t\t\t\tvdfe.setType(iterType);\n\t\t\t\tvdfe.getAtoms().add(new VariableDeclAtom(generateTempName(\"iter\", stack),\n\t\t\t\t\t\titerCall, startToken));\n\n\t\t\t\tVariableAccess iterAcc = new VariableAccess(vdfe.getName(), startToken);\n\t\t\t\titerAcc.setRef(vdfe);\n\t\t\t\t\n\t\t\t\tMemberCall hasNextCall = new MemberCall(iterAcc, \"hasNext\", \"\", startToken);\n\t\t\t\thasNextCall.resolve(stack, res, true);\n\t\t\t\tWhile while1 = new While(hasNextCall, startToken);\n\t\t\t\t\n\t\t\t\tMemberCall nextCall = new MemberCall(iterAcc, \"next\", \"\", startToken);\n\t\t\t\tnextCall.resolve(stack, res, true);\n\t\t\t\t\n\t\t\t\tif(variable instanceof VariableAccess) {\n\t\t\t\t\tVariableAccess varAcc = (VariableAccess) variable;\n\t\t\t\t\tif(varAcc.getRef() == null) {\n\t\t\t\t\t\tType innerType = iterCall.getType().getTypeParams().getFirst().getType();\n\t\t\t\t\t\tVariableDecl varDecl = new VariableDecl(innerType, false, varAcc.startToken);\n\t\t\t\t\t\tvarDecl.getAtoms().add(new VariableDeclAtom(varAcc.getName(), null, varAcc.startToken));\n\t\t\t\t\t\tblock.getBody().add(0, new Line(varDecl));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// FIXME what if variable isn't an Access?\n\t\t\t\twhile1.getBody().add(new Line(new Assignment(variable, nextCall, startToken)));\n\t\t\t\twhile1.getBody().addAll(getBody());\n\t\t\t\t\n\t\t\t\tlist.replace(line, new Line(block));\n\t\t\t\tblock.getBody().add(new Line(vdfe));\n\t\t\t\tblock.getBody().add(new Line(while1));\n\t\t\t\t\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t\t\n\t}\n\t\n}\n","lineNo":148}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected boolean superCall;\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\tprotected boolean dead = false;\n\t\n\tpublic FunctionCall(String name, Token startToken) {\n\t\tthis(name, null, startToken);\n\t}\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\t\n\tpublic boolean isSuperCall() {\n\t\treturn superCall;\n\t}\n\t\n\tpublic void setSuperCall(boolean superCall) {\n\t\tthis.superCall = superCall;\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t\tif(realType != null) realType.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tResponse response = resolveRegular(stack, res, fatal);\n\t\t\t\tif(response != Response.OK) return response;\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n \t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\n\t\tint argOffset = impl.hasThis() ? 1 : 0;\n\t\tfor(int i = 0; i < arguments.size(); i++) {\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\tif(i + argOffset < impl.getArguments().size()) {\n\t\t\t\tArgument implArg = impl.getArguments().get(i + argOffset);\n\t\t\t\tif(callArg.getType() != null && implArg.getType() != null\n\t\t\t\t\t\t&& callArg.getType().isGeneric() && (callArg.getType().getPointerLevel() == 0)\n\t\t\t\t\t\t&& implArg.getType().isFlat() && !implArg.getType().equals(callArg.getType())) {\n\t\t\t\t\targuments.set(i, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName(), res);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(\"gcall\", stack), this, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!parent.replace(this, vdfe)) {\n\t\t\t\t\tThread.dumpStack();\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"[FC] Couldn't replace \\n\"+this+\" with \\n\"+vdfe\n\t\t\t\t\t\t\t+\"in \\n\"+parent.getClass().getSimpleName()+\"|\"+parent);\n\t\t\t\t}\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tExpression realExpr = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(realExpr == null) return null;\n\t\treturn realExpr.getType();\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\t\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\t\n\t\t\t// e.g. func <T> myFunc(T: Class), and arg = T\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = callArg;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", argName-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(value: T), and arg = value.\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\t// not resolved yet?\n\t\t\t\tif(callArg.getType() == null) return null;\n\t\t\t\tTypeAccess typeAcc = new TypeAccess(callArg.getType());\n\t\t\t\t//varAcc.setRef(callArg.getType().getRef());\n\t\t\t\ttypeAcc.resolve(stack, res, fatal);\n\t\t\t\tresult = typeAcc;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", varAccType-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(list:)\n\t\t\tif(arg.getType().isGenericRecursive()) {\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(arg.getType()+\" is generic-recursive, trying to get <\"+typeParam+\"> in it.\");\n\t\t\t\tresult = searchTypeParam(typeParam, arg.getType(), stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", genericRecursive-wise\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\t/**\n\t * Search for the type param @needle in the type @haystack\n\t */\n\tprivate Expression searchTypeParam(String needle, Type haystack,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = haystack.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(needle)) {\n\t\t\t\t\tType realType = getRealType(haystack.getName(), stack, res, fatal);\n\t\t\t\t\tif(realType != null) {\n\t\t\t\t\t\treturn realType.getTypeParams().get(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\t\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess || expr instanceof Cast)) {\n\t\t\t\tString tmpName = generateTempName(genType.getName()+\"param\", stack);\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\ttmpName, expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tif(declType != null) declType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix == null || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected Response resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return Response.OK;\n\t\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) turnIntoMemberCall(stack, res);\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate void turnIntoMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tmemberCall.setSuperCall(superCall);\n\t\tstack.peek().replace(this, memberCall);\n\t\tdead = true;\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix == null || suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName, Resolver res) {\n\t\n\t\tif(res.params.veryVerbose) {\n\t\t\tThread.dumpStack();\n\t\t}\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+getProtoRepr());\n\t\t\n\t}\n\t\n\t@Override\n\tpublic boolean canBeReferenced() {\n\t\treturn false;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected boolean superCall;\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\tprotected boolean dead = false;\n\t\n\tpublic FunctionCall(String name, Token startToken) {\n\t\tthis(name, null, startToken);\n\t}\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\t\n\tpublic boolean isSuperCall() {\n\t\treturn superCall;\n\t}\n\t\n\tpublic void setSuperCall(boolean superCall) {\n\t\tthis.superCall = superCall;\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t\tif(realType != null) realType.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tResponse response = resolveRegular(stack, res, fatal);\n\t\t\t\tif(response != Response.OK) return response;\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n \t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\n\t\tint argOffset = impl.hasThis() ? 1 : 0;\n\t\tfor(int i = 0; i < arguments.size(); i++) {\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\tif(i + argOffset < impl.getArguments().size()) {\n\t\t\t\tArgument implArg = impl.getArguments().get(i + argOffset);\n\t\t\t\tif(callArg.getType() != null && implArg.getType() != null\n\t\t\t\t\t\t&& callArg.getType().isGeneric() && (callArg.getType().getPointerLevel() == 0)\n\t\t\t\t\t\t&& implArg.getType().isFlat() && !implArg.getType().equals(callArg.getType())) {\n\t\t\t\t\targuments.set(i, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName(), res);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(\"gcall\", stack), this, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!parent.replace(this, vdfe)) {\n\t\t\t\t\tThread.dumpStack();\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"[FC] Couldn't replace \\n\"+this+\" with \\n\"+vdfe\n\t\t\t\t\t\t\t+\"in \\n\"+parent.getClass().getSimpleName()+\"|\"+parent);\n\t\t\t\t}\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tExpression realExpr = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(realExpr == null) return null;\n\t\treturn realExpr.getType();\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\t\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\t\n\t\t\t// e.g. func <T> myFunc(T: Class), and arg = T\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = callArg;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", argName-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(value: T), and arg = value.\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\t// not resolved yet?\n\t\t\t\tif(callArg.getType() == null) return null;\n\t\t\t\tType ourType = callArg.getType();\n\t\t\t\t// make it flat!\n\t\t\t\tif(!ourType.isFlat()) {\n\t\t\t\t\tourType = ourType.clone();\n\t\t\t\t\tourType.setPointerLevel(0);\n\t\t\t\t\tourType.setReferenceLevel(0);\n\t\t\t\t\tourType.setArray(false);\n\t\t\t\t}\n\t\t\t\tTypeAccess typeAcc = new TypeAccess(ourType);\n\t\t\t\ttypeAcc.resolve(stack, res, fatal);\n\t\t\t\tresult = typeAcc;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", varAccType-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(list:)\n\t\t\tif(arg.getType().isGenericRecursive()) {\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(arg.getType()+\" is generic-recursive, trying to get <\"+typeParam+\"> in it.\");\n\t\t\t\tresult = searchTypeParam(typeParam, arg.getType(), stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", genericRecursive-wise\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\t/**\n\t * Search for the type param @needle in the type @haystack\n\t */\n\tprivate Expression searchTypeParam(String needle, Type haystack,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = haystack.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(needle)) {\n\t\t\t\t\tType realType = getRealType(haystack.getName(), stack, res, fatal);\n\t\t\t\t\tif(realType != null) {\n\t\t\t\t\t\treturn realType.getTypeParams().get(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\t\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess || expr instanceof Cast)) {\n\t\t\t\tString tmpName = generateTempName(genType.getName()+\"param\", stack);\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\ttmpName, expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tif(declType != null) declType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix == null || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected Response resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return Response.OK;\n\t\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) turnIntoMemberCall(stack, res);\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate void turnIntoMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tmemberCall.setSuperCall(superCall);\n\t\tstack.peek().replace(this, memberCall);\n\t\tdead = true;\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix == null || suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName, Resolver res) {\n\t\n\t\tif(res.params.veryVerbose) {\n\t\t\tThread.dumpStack();\n\t\t}\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+getProtoRepr());\n\t\t\n\t}\n\t\n\t@Override\n\tpublic boolean canBeReferenced() {\n\t\treturn false;\n\t}\n\t\n}\n","lineNo":333}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.backend.CachedFileWriter;\nimport org.ooc.backend.Generator;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ArrayLiteral;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.Block;\nimport org.ooc.frontend.model.BoolLiteral;\nimport org.ooc.frontend.model.BuiltinType;\nimport org.ooc.frontend.model.Case;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.CharLiteral;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Else;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FloatLiteral;\nimport org.ooc.frontend.model.FlowControl;\nimport org.ooc.frontend.model.Foreach;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.If;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.InterfaceDecl;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberArgument;\nimport org.ooc.frontend.model.MemberAssignArgument;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.NullLiteral;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.RegularArgument;\nimport org.ooc.frontend.model.Return;\nimport org.ooc.frontend.model.StringLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.ValuedReturn;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.VersionBlock;\nimport org.ooc.frontend.model.While;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.VersionNodes.VersionAnd;\nimport org.ooc.frontend.model.VersionNodes.VersionName;\nimport org.ooc.frontend.model.VersionNodes.VersionNegation;\nimport org.ooc.frontend.model.VersionNodes.VersionNodeVisitor;\nimport org.ooc.frontend.model.VersionNodes.VersionOr;\nimport org.ooc.frontend.model.VersionNodes.VersionParen;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.TypeArgument;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ooc.middle.structs.NodeMap;\nimport org.ubi.SourceReader;\n\npublic class CGenerator extends Generator implements Visitor {\n\n\tpublic final AwesomeWriter hw;\n\tpublic final AwesomeWriter cw;\n\tpublic AwesomeWriter current;\n\tpublic BuildParams params;\n\n\tpublic CGenerator(File outPath, Module module) {\n\t\tsuper(outPath, module);\n\t\tString basePath = module.getOutPath();\n\t\tFile hFile = new File(outPath, basePath + \".h\");\n\t\thFile.getParentFile().mkdirs();\n\t\tthis.hw = new AwesomeWriter(new CachedFileWriter(hFile));\n\t\tFile cFile = new File(outPath, basePath + \".c\");\n\t\tthis.cw = new AwesomeWriter(new CachedFileWriter(cFile));\n\t\tthis.current = hw;\n\t}\n\n\t@Override\n\tpublic void generate(BuildParams params) throws IOException {\n\t\tthis.params = params;\n\t\tmodule.accept(this);\n\t\thw.close();\n\t\tcw.close();\n\t}\n\n\tpublic void visit(Module module) throws IOException {\n\t\tModuleWriter.write(module, this);\n\t}\n\n\tpublic void visit(Add add) throws IOException {\n\t\tadd.getLeft().accept(this);\n\t\tcurrent.app(\" + \");\n\t\tadd.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Mul mul) throws IOException {\n\t\tmul.getLeft().accept(this);\n\t\tcurrent.app(\" * \");\n\t\tmul.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Sub sub) throws IOException {\n\t\tsub.getLeft().accept(this);\n\t\tcurrent.app(\" - \");\n\t\tsub.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Div div) throws IOException {\n\t\tdiv.getLeft().accept(this);\n\t\tcurrent.app(\" / \");\n\t\tdiv.getRight().accept(this);\n\t}\n\n\tpublic void visit(Not not) throws IOException {\n\t\tcurrent.app('!');\n\t\tnot.getExpression().accept(this);\t\t\n\t}\n\t\n\tpublic void visit(Mod mod) throws IOException {\n\t\tmod.getLeft().accept(this);\n\t\tcurrent.app(\" % \");\n\t\tmod.getRight().accept(this);\n\t}\n\t\n\tpublic void visit(Compare compare) throws IOException {\n\t\tcompare.getLeft().accept(this);\n\t\tswitch(compare.getCompareType()) {\n\t\t\tcase GREATER: current.app(\" > \"); break;\n\t\t\tcase GREATER_OR_EQUAL: current.app(\" >= \"); break;\n\t\t\tcase LESSER: current.app(\" < \"); break;\n\t\t\tcase LESSER_OR_EQUAL: current.app(\" <= \"); break;\n\t\t\tcase EQUAL: current.app(\" == \"); break;\n\t\t\tcase NOT_EQUAL: current.app(\" != \"); break;\n\t\t}\n\t\tcompare.getRight().accept(this);\n\t}\n\n\tpublic void visit(FunctionCall functionCall) throws IOException {\n\t\tCallWriter.write(functionCall, this);\n\t}\n\n\tpublic void visit(MemberCall memberCall) throws IOException {\n\t\tCallWriter.writeMember(memberCall, this);\n\t}\n\n\tpublic void visit(Parenthesis parenthesis) throws IOException {\n\t\tcurrent.app('(');\n\t\tparenthesis.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Assignment assignment) throws IOException {\n\t\tExpression left = assignment.getLeft();\n\t\tif(left instanceof VariableAccess) {\n\t\t\tAccessWriter.write((VariableAccess) left, false, this);\n\t\t} else {\n\t\t\tleft.accept(this);\n\t\t}\n\t\tcurrent.app(' ').app(assignment.getSymbol()).app(' ');\n\t\tassignment.getRight().accept(this);\n\t}\n\n\tpublic void visit(ValuedReturn return1) throws IOException {\n\t\tcurrent.app(\"return \");\n\t\treturn1.getExpression().accept(this);\n\t}\n\t\n\tpublic void visit(Return return1) throws IOException {\n\t\tcurrent.app(\"return\");\n\t}\n\n\tpublic void visit(NullLiteral nullLiteral) throws IOException {\n\t\tLiteralWriter.writeNull(this);\n\t}\n\n\tpublic void visit(IntLiteral numberLiteral) throws IOException {\n\t\tLiteralWriter.writeInt(numberLiteral, this);\n\t}\n\t\n\tpublic void visit(FloatLiteral floatLiteral) throws IOException {\n\t\tLiteralWriter.writeFloat(floatLiteral, this);\n\t}\n\n\tpublic void visit(StringLiteral stringLiteral) throws IOException {\n\t\tLiteralWriter.writeString(stringLiteral, this);\n\t}\n\n\tpublic void visit(RangeLiteral rangeLiteral) throws IOException {\n\t\tthrow new OocCompilationError(rangeLiteral, module,\n\t\t\t\t\"Using a range literal outside a foreach is not supported yet.\");\n\t}\n\n\tpublic void visit(BoolLiteral boolLiteral) throws IOException {\n\t\tcurrent.app(boolLiteral.getValue() ? \"true\" : \"false\");\n\t}\n\n\tpublic void visit(CharLiteral charLiteral) throws IOException {\n\t\tcurrent.app('\\'').app(SourceReader.spelled(charLiteral.getValue())).app('\\'');\t\t\n\t}\n\n\tpublic void visit(Line line) throws IOException {\n\t\tcurrent.nl();\n\n\t\tif(params.debug && params.lineDirectives) {\n\t\t\tcurrent.app(\"#line \");\n\t\t\tcurrent.app(String.valueOf(module.getReader().getLocation(line.startToken).getLineNumber()));\n\t\t\tcurrent.app(\" \\\"\");\n\t\t\tcurrent.app(module.getReader().getFileName());\n\t\t\tcurrent.app(\"\\\"\");\n\t\t\tcurrent.nl();\n\t\t}\n\n\t\tif(line.getStatement() instanceof FunctionCall) CallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\tline.getStatement().accept(this);\n\t\tif(!(line.getStatement() instanceof ControlStatement || line.getStatement() instanceof VersionBlock)) {\n\t\t\tcurrent.app(';');\n\t\t}\n\t}\n\n\tpublic void visit(Include include) throws IOException {}\n\n\tpublic void visit(If if1) throws IOException {\n\t\tControlStatementWriter.writeIf(if1, this);\n\t}\n\t\n\tpublic void visit(Else else1) throws IOException {\n\t\tControlStatementWriter.writeElse(else1, this);\n\t}\n\n\tpublic void visit(While while1) throws IOException {\n\t\tControlStatementWriter.writeWhile(while1, this);\n\t}\n\n\tpublic void visit(Foreach foreach) throws IOException {\n\t\tControlStatementWriter.writeForeach(foreach, this);\n\t}\n\n\tpublic void visit(MemberAccess memberAccess) throws IOException {\n\t\tAccessWriter.writeMember(memberAccess, this);\n\t}\n\t\n\tpublic void visit(VariableAccess variableAccess) throws IOException {\n\t\tAccessWriter.writeVariable(variableAccess, true, this);\n\t}\n\n\tpublic void visit(ArrayAccess arrayAccess) throws IOException {\n\t\tAccessWriter.writeArray(arrayAccess, this);\n\t}\n\n\tpublic void visit(VariableDecl variableDecl) throws IOException {\n\t\tVariableDeclWriter.write(variableDecl, this);\n\t}\n\n\tpublic void visit(FunctionDecl functionDecl) throws IOException {\n\t\tFunctionDeclWriter.write(functionDecl, this);\n\t}\n\n\tpublic void visit(ClassDecl classDecl) throws IOException {\n\t\tClassDeclWriter.write(classDecl, this);\n\t}\n\t\n\tpublic void visit(CoverDecl cover) throws IOException {\n\t\tCoverDeclWriter.write(cover, this);\n\t}\n\t\n\tpublic void visit(TypeArgument typeArgument) throws IOException {\n\t\ttypeArgument.getType().accept(this);\n\t}\n\n\tpublic void visit(RegularArgument regularArgument) throws IOException {\n\t\tType type = regularArgument.getType();\n\t\tif(type.isArray()) {\n\t\t\tcurrent.app(type.getName()).app(' ').app(regularArgument.getName());\n\t\t\tfor(int i = 0; i < type.getPointerLevel(); i++) {\n\t\t\t\tcurrent.app(\"[]\");\n\t\t\t}\n\t\t} else {\n\t\t\tif(type instanceof FuncType) {\n\t\t\t\tTypeWriter.writeFuncPointer((FunctionDecl) type.getRef(), regularArgument.getName(), this);\n\t\t\t} else {\n\t\t\t\tTypeWriter.writeSpaced(type, this);\n\t\t\t\tcurrent.app(regularArgument.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void visit(MemberArgument memberArgument) throws IOException {}\n\n\tpublic void visit(MemberAssignArgument memberArgument) throws IOException {}\n\n\tpublic void visit(Type type) throws IOException {\n\t\tTypeWriter.write(type, this);\n\t}\n\n\tpublic void visit(VarArg varArg) throws IOException {\n\t\tcurrent.app(\"...\");\n\t}\n\t\n\tpublic void visit(NodeList<? extends Node> list) throws IOException {\n\t\tlist.acceptChildren(this);\n\t}\n\t\n\tpublic void visit(Block block) throws IOException {\n\t\tcurrent.openBlock();\n\t\tblock.acceptChildren(this);\n\t\tcurrent.closeBlock();\n\t}\n\n\tpublic void visit(BuiltinType builtinType) throws IOException {}\n\n\tpublic void visit(VariableDeclAtom variableDeclAtom) throws IOException {}\n\t\n\tpublic void visit(Cast cast) throws IOException {\n\t\tCastWriter.write(cast, this);\n\t}\n\n\tpublic void visit(AddressOf addressOf) throws IOException {\n\t\tif(addressOf.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) addressOf.getExpression();\n\t\t\tType varAccType = varAcc.getRef().getType();\n\t\t\tif(varAccType.getRef() instanceof TypeParam) {\n\t\t\t\tAccessWriter.write(varAcc, false, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(varAccType.getReferenceLevel() == 1) {\n\t\t\t\tAccessWriter.write(varAcc, false, this, -1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcurrent.app('&');\n\t\tboolean paren = !(addressOf.getExpression() instanceof VariableAccess);\n\t\tif(paren) current.app('(');\n\t\tExpression expr = addressOf.getExpression();\n\t\twhile(expr instanceof Cast) {\n\t\t\texpr = ((Cast) expr).getExpression();\n\t\t}\n\t\texpr.accept(this);\n\t\tif(paren) current.app(')');\n\t}\n\n\tpublic void visit(Dereference dereference) throws IOException {\n\t\tcurrent.app(\"(*\");\n\t\tdereference.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(OpDecl opDecl) throws IOException {\n\t\topDecl.getFunc().accept(this);\n\t}\n\n\tpublic void visit(Import import1) throws IOException {}\n\t\n\tpublic void visit(ArrayLiteral arrayLiteral) throws IOException {\n\t\tcurrent.app('{');\n\t\tIterator<Expression> iter = arrayLiteral.getElements().iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression element = iter.next();\n\t\t\tboolean doCasting = false;\n\t\t\tif(!element.getType().getName().equals(arrayLiteral.getType().getName())) {\n\t\t\t\tdoCasting = true;\n\t\t\t\tcurrent.app(\"((\");\n\t\t\t\tarrayLiteral.getElements().get(0).getType().accept(this);\n\t\t\t\tcurrent.app(\") \");\n\t\t\t}\n\t\t\telement.accept(this);\n\t\t\tif(doCasting) {\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\tif(iter.hasNext()) current.app(\", \");\n\t\t}\n\t\tcurrent.app('}');\n\t}\n\n\tpublic void visit(Use use) throws IOException {}\n\n\tpublic void visit(BinaryCombination binaryCombination) throws IOException {\n\t\tbinaryCombination.getLeft().accept(this);\n\t\tcurrent.app(' ').app(binaryCombination.getOpString()).app(' ');\n\t\tbinaryCombination.getRight().accept(this);\n\t}\n\n\tpublic void visit(MultiMap<?, ?> list) throws IOException {}\n\n\tpublic void visit(FlowControl flow) throws IOException {\n\t\tcurrent.app(flow.getKeyword()).app(\";\");\n\t}\n\n\tpublic void visit(InterfaceDecl interfaceDecl) throws IOException {\n\t\t// huh.. slack off?\n\t}\n\n\tpublic void visit(Ternary ternary) throws IOException {\n\t\tternary.getCondition().accept(this);\n\t\tcurrent.app(\" ? \");\n\t\tternary.getValueIfTrue().accept(this);\n\t\tcurrent.app(\" : \");\n\t\tternary.getValueIfFalse().accept(this);\n\t}\n\n\tpublic void visit(Match match) throws IOException {\n\t\tboolean isFirst = true;\n\t\tfor(Case case1: match.getCases()) {\n\t\t\tif(!isFirst) {\n\t\t\t\tcurrent.app(\" else \");\n\t\t\t}\n\n\t\t\tif(case1.getExpr() == null) {\n\t\t\t\tif(isFirst) current.app(\" else \");\n\t\t\t} else {\n\t\t\t\tif(case1.isFallthrough()) current.app(' ');\n\t\t\t\tcurrent.app(\"if (\");\n\t\t\t\tcase1.getExpr().accept(this);\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.app(\"{\").tab();\n\t\t\t\n\t\t\tfor(Line line: case1.getBody()) {\n\t\t\t\tcurrent.newLine();\n\t\t\t\tif(line.getStatement() instanceof FunctionCall) {\n\t\t\t\t\tCallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\t\t\t}\n\t\t\t\tline.getStatement().accept(this);\n\t\t\t\tcurrent.append(\";\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.untab().nl().app(\"}\");\n\t\t\tif(isFirst) isFirst = false;\n\t\t}\n\t}\n\n\tpublic void visit(Case case1) throws IOException {\n\t\t// hmmm... no\n\t}\n\n\tpublic void visit(VersionBlock versionBlock) throws IOException {\n\t\tcurrent.app(\"\\n#if \");\n\t\t\n\t\tversionBlock.getVersion().accept(new VersionNodeVisitor() {\n\t\t\t\n\t\t\tpublic void visit(VersionOr versionOr) throws IOException {\n\t\t\t\tversionOr.getLeft().accept(this);\n\t\t\t\tcurrent.app(\" || \");\n\t\t\t\tversionOr.getRight().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionAnd versionAnd) throws IOException {\n\t\t\t\tversionAnd.getLeft().accept(this);\n\t\t\t\tcurrent.app(\" && \");\n\t\t\t\tversionAnd.getRight().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionNegation versionNegation) throws IOException {\n\t\t\t\tcurrent.app('!');\n\t\t\t\tversionNegation.getInner().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionName versionName) throws IOException {\n\t\t\t\tcurrent.app(\"defined(\").app(versionName.getName()).app(\")\");\n\t\t\t}\n\n\t\t\tpublic void visit(VersionParen versionParen) throws IOException {\n\t\t\t\tcurrent.app('(');\n\t\t\t\tversionParen.getInner().accept(this);\n\t\t\t\tcurrent.app(')');\n\t\t\t}\n\t\t});\n\t\t\n\t\tvisit((Block) versionBlock);\n\t\tcurrent.app(\"\\n#endif\");\n\t}\n\n\tpublic void visit(NodeMap<?, ? extends Node> list) throws IOException {}\n\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.backend.CachedFileWriter;\nimport org.ooc.backend.Generator;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ArrayLiteral;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.Block;\nimport org.ooc.frontend.model.BoolLiteral;\nimport org.ooc.frontend.model.BuiltinType;\nimport org.ooc.frontend.model.Case;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.CharLiteral;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Else;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FloatLiteral;\nimport org.ooc.frontend.model.FlowControl;\nimport org.ooc.frontend.model.Foreach;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.If;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.InterfaceDecl;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberArgument;\nimport org.ooc.frontend.model.MemberAssignArgument;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.NullLiteral;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.RegularArgument;\nimport org.ooc.frontend.model.Return;\nimport org.ooc.frontend.model.StringLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.ValuedReturn;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.VersionBlock;\nimport org.ooc.frontend.model.While;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.VersionNodes.VersionAnd;\nimport org.ooc.frontend.model.VersionNodes.VersionName;\nimport org.ooc.frontend.model.VersionNodes.VersionNegation;\nimport org.ooc.frontend.model.VersionNodes.VersionNodeVisitor;\nimport org.ooc.frontend.model.VersionNodes.VersionOr;\nimport org.ooc.frontend.model.VersionNodes.VersionParen;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.TypeArgument;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ooc.middle.structs.NodeMap;\nimport org.ubi.SourceReader;\n\npublic class CGenerator extends Generator implements Visitor {\n\n\tpublic final AwesomeWriter hw;\n\tpublic final AwesomeWriter cw;\n\tpublic AwesomeWriter current;\n\tpublic BuildParams params;\n\n\tpublic CGenerator(File outPath, Module module) {\n\t\tsuper(outPath, module);\n\t\tString basePath = module.getOutPath();\n\t\tFile hFile = new File(outPath, basePath + \".h\");\n\t\thFile.getParentFile().mkdirs();\n\t\tthis.hw = new AwesomeWriter(new CachedFileWriter(hFile));\n\t\tFile cFile = new File(outPath, basePath + \".c\");\n\t\tthis.cw = new AwesomeWriter(new CachedFileWriter(cFile));\n\t\tthis.current = hw;\n\t}\n\n\t@Override\n\tpublic void generate(BuildParams params) throws IOException {\n\t\tthis.params = params;\n\t\tmodule.accept(this);\n\t\thw.close();\n\t\tcw.close();\n\t}\n\n\tpublic void visit(Module module) throws IOException {\n\t\tModuleWriter.write(module, this);\n\t}\n\n\tpublic void visit(Add add) throws IOException {\n\t\tadd.getLeft().accept(this);\n\t\tcurrent.app(\" + \");\n\t\tadd.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Mul mul) throws IOException {\n\t\tmul.getLeft().accept(this);\n\t\tcurrent.app(\" * \");\n\t\tmul.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Sub sub) throws IOException {\n\t\tsub.getLeft().accept(this);\n\t\tcurrent.app(\" - \");\n\t\tsub.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Div div) throws IOException {\n\t\tdiv.getLeft().accept(this);\n\t\tcurrent.app(\" / \");\n\t\tdiv.getRight().accept(this);\n\t}\n\n\tpublic void visit(Not not) throws IOException {\n\t\tcurrent.app('!');\n\t\tnot.getExpression().accept(this);\t\t\n\t}\n\t\n\tpublic void visit(Mod mod) throws IOException {\n\t\tmod.getLeft().accept(this);\n\t\tcurrent.app(\" % \");\n\t\tmod.getRight().accept(this);\n\t}\n\t\n\tpublic void visit(Compare compare) throws IOException {\n\t\tcompare.getLeft().accept(this);\n\t\tswitch(compare.getCompareType()) {\n\t\t\tcase GREATER: current.app(\" > \"); break;\n\t\t\tcase GREATER_OR_EQUAL: current.app(\" >= \"); break;\n\t\t\tcase LESSER: current.app(\" < \"); break;\n\t\t\tcase LESSER_OR_EQUAL: current.app(\" <= \"); break;\n\t\t\tcase EQUAL: current.app(\" == \"); break;\n\t\t\tcase NOT_EQUAL: current.app(\" != \"); break;\n\t\t}\n\t\tcompare.getRight().accept(this);\n\t}\n\n\tpublic void visit(FunctionCall functionCall) throws IOException {\n\t\tCallWriter.write(functionCall, this);\n\t}\n\n\tpublic void visit(MemberCall memberCall) throws IOException {\n\t\tCallWriter.writeMember(memberCall, this);\n\t}\n\n\tpublic void visit(Parenthesis parenthesis) throws IOException {\n\t\tcurrent.app('(');\n\t\tparenthesis.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Assignment assignment) throws IOException {\n\t\tExpression left = assignment.getLeft();\n\t\tif(left instanceof VariableAccess) {\n\t\t\tAccessWriter.write((VariableAccess) left, false, this);\n\t\t} else {\n\t\t\tleft.accept(this);\n\t\t}\n\t\tcurrent.app(' ').app(assignment.getSymbol()).app(' ');\n\t\tassignment.getRight().accept(this);\n\t}\n\n\tpublic void visit(ValuedReturn return1) throws IOException {\n\t\tcurrent.app(\"return \");\n\t\treturn1.getExpression().accept(this);\n\t}\n\t\n\tpublic void visit(Return return1) throws IOException {\n\t\tcurrent.app(\"return\");\n\t}\n\n\tpublic void visit(NullLiteral nullLiteral) throws IOException {\n\t\tLiteralWriter.writeNull(this);\n\t}\n\n\tpublic void visit(IntLiteral numberLiteral) throws IOException {\n\t\tLiteralWriter.writeInt(numberLiteral, this);\n\t}\n\t\n\tpublic void visit(FloatLiteral floatLiteral) throws IOException {\n\t\tLiteralWriter.writeFloat(floatLiteral, this);\n\t}\n\n\tpublic void visit(StringLiteral stringLiteral) throws IOException {\n\t\tLiteralWriter.writeString(stringLiteral, this);\n\t}\n\n\tpublic void visit(RangeLiteral rangeLiteral) throws IOException {\n\t\tthrow new OocCompilationError(rangeLiteral, module,\n\t\t\t\t\"Using a range literal outside a foreach is not supported yet.\");\n\t}\n\n\tpublic void visit(BoolLiteral boolLiteral) throws IOException {\n\t\tcurrent.app(boolLiteral.getValue() ? \"true\" : \"false\");\n\t}\n\n\tpublic void visit(CharLiteral charLiteral) throws IOException {\n\t\tcurrent.app('\\'').app(SourceReader.spelled(charLiteral.getValue())).app('\\'');\t\t\n\t}\n\n\tpublic void visit(Line line) throws IOException {\n\t\tcurrent.nl();\n\n\t\tif(params.debug && params.lineDirectives) {\n\t\t\tcurrent.app(\"#line \");\n\t\t\tcurrent.app(String.valueOf(module.getReader().getLocation(line.startToken).getLineNumber()));\n\t\t\tcurrent.app(\" \\\"\");\n\t\t\tcurrent.app(module.getReader().getFileName());\n\t\t\tcurrent.app(\"\\\"\");\n\t\t\tcurrent.nl();\n\t\t}\n\n\t\tif(line.getStatement() instanceof FunctionCall) CallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\tline.getStatement().accept(this);\n\t\tif(!(line.getStatement() instanceof ControlStatement || line.getStatement() instanceof VersionBlock)) {\n\t\t\tcurrent.app(';');\n\t\t}\n\t}\n\n\tpublic void visit(Include include) throws IOException {}\n\n\tpublic void visit(If if1) throws IOException {\n\t\tControlStatementWriter.writeIf(if1, this);\n\t}\n\t\n\tpublic void visit(Else else1) throws IOException {\n\t\tControlStatementWriter.writeElse(else1, this);\n\t}\n\n\tpublic void visit(While while1) throws IOException {\n\t\tControlStatementWriter.writeWhile(while1, this);\n\t}\n\n\tpublic void visit(Foreach foreach) throws IOException {\n\t\tControlStatementWriter.writeForeach(foreach, this);\n\t}\n\n\tpublic void visit(MemberAccess memberAccess) throws IOException {\n\t\tAccessWriter.write(memberAccess, this);\n\t}\n\t\n\tpublic void visit(VariableAccess variableAccess) throws IOException {\n\t\tAccessWriter.write(variableAccess, this);\n\t}\n\n\tpublic void visit(ArrayAccess arrayAccess) throws IOException {\n\t\tAccessWriter.write(arrayAccess, this);\n\t}\n\n\tpublic void visit(VariableDecl variableDecl) throws IOException {\n\t\tVariableDeclWriter.write(variableDecl, this);\n\t}\n\n\tpublic void visit(FunctionDecl functionDecl) throws IOException {\n\t\tFunctionDeclWriter.write(functionDecl, this);\n\t}\n\n\tpublic void visit(ClassDecl classDecl) throws IOException {\n\t\tClassDeclWriter.write(classDecl, this);\n\t}\n\t\n\tpublic void visit(CoverDecl cover) throws IOException {\n\t\tCoverDeclWriter.write(cover, this);\n\t}\n\t\n\tpublic void visit(TypeArgument typeArgument) throws IOException {\n\t\ttypeArgument.getType().accept(this);\n\t}\n\n\tpublic void visit(RegularArgument regularArgument) throws IOException {\n\t\tType type = regularArgument.getType();\n\t\tif(type.isArray()) {\n\t\t\tcurrent.app(type.getName()).app(' ').app(regularArgument.getName());\n\t\t\tfor(int i = 0; i < type.getPointerLevel(); i++) {\n\t\t\t\tcurrent.app(\"[]\");\n\t\t\t}\n\t\t} else {\n\t\t\tif(type instanceof FuncType) {\n\t\t\t\tTypeWriter.writeFuncPointer((FunctionDecl) type.getRef(), regularArgument.getName(), this);\n\t\t\t} else {\n\t\t\t\tTypeWriter.writeSpaced(type, this);\n\t\t\t\tcurrent.app(regularArgument.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void visit(MemberArgument memberArgument) throws IOException {}\n\n\tpublic void visit(MemberAssignArgument memberArgument) throws IOException {}\n\n\tpublic void visit(Type type) throws IOException {\n\t\tTypeWriter.write(type, this);\n\t}\n\n\tpublic void visit(VarArg varArg) throws IOException {\n\t\tcurrent.app(\"...\");\n\t}\n\t\n\tpublic void visit(NodeList<? extends Node> list) throws IOException {\n\t\tlist.acceptChildren(this);\n\t}\n\t\n\tpublic void visit(Block block) throws IOException {\n\t\tcurrent.openBlock();\n\t\tblock.acceptChildren(this);\n\t\tcurrent.closeBlock();\n\t}\n\n\tpublic void visit(BuiltinType builtinType) throws IOException {}\n\n\tpublic void visit(VariableDeclAtom variableDeclAtom) throws IOException {}\n\t\n\tpublic void visit(Cast cast) throws IOException {\n\t\tCastWriter.write(cast, this);\n\t}\n\n\tpublic void visit(AddressOf addressOf) throws IOException {\n\t\tExpression expression = addressOf.getExpression();\n\t\twhile(expression instanceof Cast) {\n\t\t\t// bitchjump the unnecessary casts\n\t\t\texpression = ((Cast) expression).getExpression();\n\t\t}\n\t\t\n\t\tif(expression instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) expression;\n\t\t\tType varAccType = varAcc.getRef().getType();\n\t\t\tif(varAccType.getRef() instanceof TypeParam) {\n\t\t\t\tAccessWriter.write(varAcc, false, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(varAccType.getReferenceLevel() == 1) {\n\t\t\t\tAccessWriter.write(varAcc, false, this, -1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcurrent.app('&');\n\t\tboolean paren = !(addressOf.getExpression() instanceof VariableAccess);\n\t\tif(paren) current.app('(');\n\t\tExpression expr = addressOf.getExpression();\n\t\twhile(expr instanceof Cast) {\n\t\t\texpr = ((Cast) expr).getExpression();\n\t\t}\n\t\texpr.accept(this);\n\t\tif(paren) current.app(')');\n\t}\n\n\tpublic void visit(Dereference dereference) throws IOException {\n\t\tcurrent.app(\"(*\");\n\t\tdereference.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(OpDecl opDecl) throws IOException {\n\t\topDecl.getFunc().accept(this);\n\t}\n\n\tpublic void visit(Import import1) throws IOException {}\n\t\n\tpublic void visit(ArrayLiteral arrayLiteral) throws IOException {\n\t\tcurrent.app('{');\n\t\tIterator<Expression> iter = arrayLiteral.getElements().iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression element = iter.next();\n\t\t\tboolean doCasting = false;\n\t\t\tif(!element.getType().getName().equals(arrayLiteral.getType().getName())) {\n\t\t\t\tdoCasting = true;\n\t\t\t\tcurrent.app(\"((\");\n\t\t\t\tarrayLiteral.getElements().get(0).getType().accept(this);\n\t\t\t\tcurrent.app(\") \");\n\t\t\t}\n\t\t\telement.accept(this);\n\t\t\tif(doCasting) {\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\tif(iter.hasNext()) current.app(\", \");\n\t\t}\n\t\tcurrent.app('}');\n\t}\n\n\tpublic void visit(Use use) throws IOException {}\n\n\tpublic void visit(BinaryCombination binaryCombination) throws IOException {\n\t\tbinaryCombination.getLeft().accept(this);\n\t\tcurrent.app(' ').app(binaryCombination.getOpString()).app(' ');\n\t\tbinaryCombination.getRight().accept(this);\n\t}\n\n\tpublic void visit(MultiMap<?, ?> list) throws IOException {}\n\n\tpublic void visit(FlowControl flow) throws IOException {\n\t\tcurrent.app(flow.getKeyword()).app(\";\");\n\t}\n\n\tpublic void visit(InterfaceDecl interfaceDecl) throws IOException {\n\t\t// huh.. slack off?\n\t}\n\n\tpublic void visit(Ternary ternary) throws IOException {\n\t\tternary.getCondition().accept(this);\n\t\tcurrent.app(\" ? \");\n\t\tternary.getValueIfTrue().accept(this);\n\t\tcurrent.app(\" : \");\n\t\tternary.getValueIfFalse().accept(this);\n\t}\n\n\tpublic void visit(Match match) throws IOException {\n\t\tboolean isFirst = true;\n\t\tfor(Case case1: match.getCases()) {\n\t\t\tif(!isFirst) {\n\t\t\t\tcurrent.app(\" else \");\n\t\t\t}\n\n\t\t\tif(case1.getExpr() == null) {\n\t\t\t\tif(isFirst) current.app(\" else \");\n\t\t\t} else {\n\t\t\t\tif(case1.isFallthrough()) current.app(' ');\n\t\t\t\tcurrent.app(\"if (\");\n\t\t\t\tcase1.getExpr().accept(this);\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.app(\"{\").tab();\n\t\t\t\n\t\t\tfor(Line line: case1.getBody()) {\n\t\t\t\tcurrent.newLine();\n\t\t\t\tif(line.getStatement() instanceof FunctionCall) {\n\t\t\t\t\tCallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\t\t\t}\n\t\t\t\tline.getStatement().accept(this);\n\t\t\t\tcurrent.append(\";\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.untab().nl().app(\"}\");\n\t\t\tif(isFirst) isFirst = false;\n\t\t}\n\t}\n\n\tpublic void visit(Case case1) throws IOException {\n\t\t// hmmm... no\n\t}\n\n\tpublic void visit(VersionBlock versionBlock) throws IOException {\n\t\tcurrent.app(\"\\n#if \");\n\t\t\n\t\tversionBlock.getVersion().accept(new VersionNodeVisitor() {\n\t\t\t\n\t\t\tpublic void visit(VersionOr versionOr) throws IOException {\n\t\t\t\tversionOr.getLeft().accept(this);\n\t\t\t\tcurrent.app(\" || \");\n\t\t\t\tversionOr.getRight().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionAnd versionAnd) throws IOException {\n\t\t\t\tversionAnd.getLeft().accept(this);\n\t\t\t\tcurrent.app(\" && \");\n\t\t\t\tversionAnd.getRight().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionNegation versionNegation) throws IOException {\n\t\t\t\tcurrent.app('!');\n\t\t\t\tversionNegation.getInner().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionName versionName) throws IOException {\n\t\t\t\tcurrent.app(\"defined(\").app(versionName.getName()).app(\")\");\n\t\t\t}\n\n\t\t\tpublic void visit(VersionParen versionParen) throws IOException {\n\t\t\t\tcurrent.app('(');\n\t\t\t\tversionParen.getInner().accept(this);\n\t\t\t\tcurrent.app(')');\n\t\t\t}\n\t\t});\n\t\t\n\t\tvisit((Block) versionBlock);\n\t\tcurrent.app(\"\\n#endif\");\n\t}\n\n\tpublic void visit(NodeMap<?, ? extends Node> list) throws IOException {}\n\n}\n","lineNo":343}
{"Smelly Sample":"package org.ooc.frontend;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.ooc.backend.cdirty.CGenerator;\nimport org.ooc.frontend.compilers.Clang;\nimport org.ooc.frontend.compilers.Gcc;\nimport org.ooc.frontend.compilers.Icc;\nimport org.ooc.frontend.compilers.Tcc;\nimport org.ooc.frontend.drivers.CombineDriver;\nimport org.ooc.frontend.drivers.Driver;\nimport org.ooc.frontend.drivers.SequenceDriver;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.ModuleParser;\nimport org.ooc.frontend.parser.Parser;\nimport org.ooc.middle.Tinkerer;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.FileLocation;\n\npublic class CommandLine {\n\t\n\tpublic static void main(String[] argv) throws InterruptedException, IOException {\n\t\tnew CommandLine(argv);\n\t}\n\t\n\tprivate BuildParams params = new BuildParams();\n\tprivate Driver driver = new CombineDriver(params);\n\t\n\tpublic CommandLine(String[] args) throws InterruptedException, IOException {\n\t\t\n\t\tList<String> modulePaths = new ArrayList<String>();\n\t\tList<String> nasms = new ArrayList<String>();\n\t\t\n\t\tfor(String arg: args) {\n\t\t\tif(arg.startsWith(\"-\")) {\n        \t\tString option = arg.substring(1);\n        \t\tif(option.startsWith(\"sourcepath\")) {\n        \t\t\t\n        \t\t\tString sourcePathOption = arg.substring(arg.indexOf('=') + 1);\n        \t\t\tStringTokenizer tokenizer = new StringTokenizer(sourcePathOption, File.pathSeparator);\n        \t\t\twhile(tokenizer.hasMoreTokens()) {\n        \t\t\t\tparams.sourcePath.add(tokenizer.nextToken());\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"outpath\")) {\n        \t\t\t\n        \t\t\tparams.outPath = new File(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"incpath\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"I\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"libpath\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"editor\")) {\n        \t\t\t\n        \t\t\tparams.editor = arg.substring(arg.indexOf('=') + 1);\n        \t\t\t\n        \t\t} else if(option.equals(\"c\")) {\n        \t\t\t\n        \t\t\tparams.link = false;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"L\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"l\")) {\n        \t\t\t\n        \t\t\tparams.dynamicLibs.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.equals(\"dyngc\")) {\n        \t\t\t\n        \t\t\tparams.dynGC = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"nogc\")) {\n        \t\t\t\n        \t\t\tparams.enableGC = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"noclean\")) {\n        \t\t\t\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"nolines\")) {\n        \t\t\t\n        \t\t\tparams.lineDirectives = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"shout\")) {\n        \t\t\t\n        \t\t\tparams.shout = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"timing\") || option.equals(\"t\")) {\n        \t\t\t\n        \t\t\tparams.timing = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"debug\") || option.equals(\"g\")) {\n        \t\t\t\n        \t\t\tparams.debug = true;\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"verbose\") || option.equals(\"v\")) {\n        \t\t\t\n        \t\t\tparams.verbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"veryVerbose\") || option.equals(\"vv\")) {\n        \t\t\t\n        \t\t\tparams.veryVerbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"run\") || option.equals(\"r\")) {\n        \t\t\t\n        \t\t\tparams.run = true;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"driver=\")) {\n        \t\t\t\n        \t\t\tString driverName = option.substring(\"driver=\".length());\n        \t\t\tif(driverName.equals(\"combine\")) {\n        \t\t\t\tdriver = new CombineDriver(params);\n        \t\t\t} else if(driverName.equals(\"sequence\")) {\n        \t\t\t\tdriver = new SequenceDriver(params);\n        \t\t\t} else {\n        \t\t\t\tSystem.out.println(\"Unknown driver '\"+driverName+\"'\");\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"blowup=\")) {\n        \t\t\t\n        \t\t\tparams.blowup = Integer.parseInt(option.substring(\"blowup=\".length()));\n        \t\t\t\n        \t\t} else if(option.equals(\"V\") || option.equals(\"-version\") || option.equals(\"version\")) {\n        \t\t\t\n        \t\t\tCompilerVersion.printVersion();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"h\") || option.equals(\"-help\") || option.equals(\"help\")) {\n        \t\t\t\n        \t\t\tHelp.printHelp();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.startsWith(\"gcc\")) {\n        \t\t\tif(option.startsWith(\"gcc=\")) {\n        \t\t\t\tparams.compiler = new Gcc(option.substring(4));\n        \t\t\t} else {\n        \t\t\t\tparams.compiler = new Gcc();\n        \t\t\t}\n        \t\t} else if(option.startsWith(\"icc\")) {\n        \t\t\tif(option.startsWith(\"icc=\")) {\n        \t\t\t\tparams.compiler = new Icc(option.substring(4));\n        \t\t\t} else {\n        \t\t\t\tparams.compiler = new Icc();\n        \t\t\t}\n        \t\t} else if(option.startsWith(\"tcc\")) {\n        \t\t\tif(option.startsWith(\"tcc=\")) {\n        \t\t\t\tparams.compiler = new Tcc(option.substring(4));\n        \t\t\t} else {\n        \t\t\t\tparams.compiler = new Tcc();\n        \t\t\t}\n        \t\t\tparams.dynGC = true;\n\t\t\t\t} else if(option.startsWith(\"clang\")) {\n\t\t\t\t\tif(option.startsWith(\"clang=\")) {\n        \t\t\t\tparams.compiler = new Clang(option.substring(6));\n        \t\t\t} else {\n        \t\t\t\tparams.compiler = new Clang();\n        \t\t\t}\n        \t\t} else if(option.equals(\"help-backends\") || option.equals(\"-help-backends\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpBackends();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-gcc\") || option.equals(\"-help-gcc\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpGcc();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-make\") || option.equals(\"-help-make\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpMake();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-none\") || option.equals(\"-help-none\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpNone();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"slave\")) {\n        \t\t\t\n        \t\t\tparams.slave = true;\n\n\t\t\t\t} else if(option.startsWith(\"m\")) {\n\t\t\t\t\t\n\t\t\t\t\tString arch = arg.substring(2);\n\t\t\t\t\tif (arch.equals(\"32\") || arch.equals(\"64\"))\n\t\t\t\t\t\tparams.arch = arg.substring(2);\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(\"Unrecognized architecture: \" + arch);\n\t\t\t\n        \t\t} else {\n        \t\t\t\n        \t\t\tSystem.err.println(\"Unrecognized option: '\"+arg+\"'\");\n        \t\t\t\n        \t\t}\n        \t} else if(arg.startsWith(\"+\")) {\n        \t\tdriver.compilerArgs.add(arg.substring(1));\n        \t} else {\n        \t\t\tString lowerArg = arg.toLowerCase();\n\t\t\t\t\tif(lowerArg.endsWith(\".s\")) {\n        \t\t\t\tnasms.add(arg);\n        \t\t\t} else if(lowerArg.endsWith(\".o\") || lowerArg.endsWith(\".c\") || lowerArg.endsWith(\".cpp\")) {\n        \t\t\t\tdriver.additionals.add(arg);\n            \t\t} else {\n            \t\t\tif(!lowerArg.endsWith(\".ooc\")) {\n            \t\t\t\tmodulePaths.add(arg+\".ooc\");\n            \t\t\t} else {\n            \t\t\t\tmodulePaths.add(arg);\n            \t\t\t}\n            \t\t}\n        \t}\n\t\t}\n\t\t\n\t\tif(modulePaths.isEmpty()) {\n\t\t\tSystem.err.println(\"ooc: no files.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(params.compiler == null) params.compiler = new Gcc();\n\t\t\n\t\tif(!nasms.isEmpty()) {\n\t\t\tdriver.compileNasms(nasms, driver.additionals);\n\t\t}\n\t\t\n\t\tif(params.sourcePath.isEmpty()) params.sourcePath.add(\".\");\n\t\tparams.sourcePath.add(params.sdkLocation.getPath());\n\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tdo {\n\t\t\tModuleParser.clearCache();\n\t\t\tint successCount = 0;\n\t\t\tfor(String modulePath: modulePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tint code = parse(modulePath);\n\t\t\t\t\tif(code == 0) successCount++;\n\t\t\t\t} catch(CompilationFailedError err) {\n\t\t\t\t\tSystem.err.println(err);\n\t\t\t\t\tfail();\n\t\t\t\t\tif(params.editor.length() > 0) {\n\t\t\t\t\t\tlaunchEditor(params.editor, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(params.clean) FileUtils.deleteRecursive(params.outPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(modulePaths.size() > 1) {\n\t\t\t\tSystem.out.println(modulePaths.size()+\" compiled (\"+successCount\n\t\t\t\t\t\t+\" success, \"+(modulePaths.size() - successCount)+\" failed)\");\n\t\t\t}\n\t\t\t\n\t\t\tif(params.slave) {\n\t\t\t\tSystem.out.println(\".-------------( ready )-------------.\\n\");\n\t\t\t\treader.readLine();\n\t\t\t} else {\n\t\t\t\tif(successCount < modulePaths.size()) {\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} while(params.slave);\n\t\t\n\t}\n\n\tprivate void ok() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;32m[ OK ]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[ OK ]\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void fail() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;31m[FAIL]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[FAIL]\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void launchEditor(final String editor, final CompilationFailedError err) {\n\t\t\n\t\tif(err.getLocation() == null) return;\n\t\t\n\t\t//Thread thread = new Thread() {\n\t\t\t//@Override\n\t\t\t//public void run() {\n\t\t\t\ttry {\n\t\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\t\tFileLocation location = err.getLocation();\n\t\t\t\t\tString absolutePath = new File(location.getFileName()).getAbsolutePath();\n\t\t\t\t\tif(editor.equals(\"geany\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath+\":\"+location.getLineNumber()+\":\"+(location.getLinePos() - 1));\n\t\t\t\t\t} else if(editor.equals(\"mate\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath, \"-l\", String.valueOf(location.getLineNumber()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessUtils.redirectIO(builder.start());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t//}\n\t\t//};\n\t\t//thread.setDaemon(true);\n\t\t//thread.start();\n\t\t\n\t}\n\n\tprotected int parse(String modulePath) throws InterruptedException, IOException {\n\t\t\n\t\tparams.outPath.mkdirs();\n\t\tlong tt1 = System.nanoTime();\n\t\tModule module = new Parser(params).parse(modulePath);\n\t\tmodule.setMain(true);\n\t\tlong tt2 = System.nanoTime();\n\t\t\n\t\tArrayList<Module> list = new ArrayList<Module>();\n\t\tcollectModules(module, list);\n\t\ttinker(list);\n\t\t\n\t\tlong tt3 = System.nanoTime();\n\t\toutput(module, new HashSet<Module>());\n\t\tlong tt4 = System.nanoTime();\n\t\tint code = driver.compile(module);\n\t\tlong tt5 = System.nanoTime();\n\n\t\tif(params.timing) {\n\t\t\tSystem.out.printf(\"parse: %.2f ms\\ttinker: %.2f ms\\toutput: %.2f ms\\tcc: %.2f ms\\tTOTAL %.2f ms\\n\",\n\t\t\t\t\tFloat.valueOf((tt2 - tt1) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt3 - tt2) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt4 - tt3) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt4) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt1) / 1000000.0f));\n\t\t}\n\t\t\n\t\tif(code == 0) {\n\t\t\tif(params.shout) ok();\n\t\t\tif(params.run) {\n\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\tbuilder.command(\"./\"+module.getSimpleName());\n\t\t\t\tProcess process = builder.start();\n\t\t\t\tProcessUtils.redirectIO(process);\n\t\t\t\tint exitCode = process.waitFor();\n\t\t\t\tif(exitCode != 0) {\n\t\t\t\t\tSystem.out.println(\"Unerwarteter Programmabbruch. Return code: \"+exitCode+\". Please don't cry :(\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(params.shout) fail();\n\t\treturn code;\n\t\t\n\t}\n\t\n\tprotected void output(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\toutput(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\tnew CGenerator(params.outPath, module).generate(params);\n\t}\n\n\tprotected void collectModules(Module module, List<Module> list) throws IOException {\n\t\tlist.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!list.contains(imp.getModule())) {\n\t\t\t\tcollectModules(imp.getModule(), list);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected void tinker(List<Module> list) throws IOException {\n\t\tTinkerer tink = new Tinkerer();\n\t\ttink.process(list, params);\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.ooc.backend.cdirty.CGenerator;\nimport org.ooc.frontend.compilers.Clang;\nimport org.ooc.frontend.compilers.Gcc;\nimport org.ooc.frontend.compilers.Icc;\nimport org.ooc.frontend.compilers.Tcc;\nimport org.ooc.frontend.drivers.CombineDriver;\nimport org.ooc.frontend.drivers.Driver;\nimport org.ooc.frontend.drivers.SequenceDriver;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.ModuleParser;\nimport org.ooc.frontend.parser.Parser;\nimport org.ooc.middle.Tinkerer;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.FileLocation;\n\npublic class CommandLine {\n\t\n\tpublic static void main(String[] argv) throws InterruptedException, IOException {\n\t\tnew CommandLine(argv);\n\t}\n\t\n\tprivate BuildParams params = new BuildParams();\n\tprivate Driver driver = new CombineDriver(params);\n\t\n\tpublic CommandLine(String[] args) throws InterruptedException, IOException {\n\t\t\n\t\tList<String> modulePaths = new ArrayList<String>();\n\t\tList<String> nasms = new ArrayList<String>();\n\t\t\n\t\tfor(String arg: args) {\n\t\t\tif(arg.startsWith(\"-\")) {\n        \t\tString option = arg.substring(1);\n        \t\tif(option.startsWith(\"sourcepath\")) {\n        \t\t\t\n        \t\t\tString sourcePathOption = arg.substring(arg.indexOf('=') + 1);\n        \t\t\tStringTokenizer tokenizer = new StringTokenizer(sourcePathOption, File.pathSeparator);\n        \t\t\twhile(tokenizer.hasMoreTokens()) {\n        \t\t\t\tparams.sourcePath.add(tokenizer.nextToken());\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"outpath\")) {\n        \t\t\t\n        \t\t\tparams.outPath = new File(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"incpath\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"I\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"libpath\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"editor\")) {\n        \t\t\t\n        \t\t\tparams.editor = arg.substring(arg.indexOf('=') + 1);\n        \t\t\t\n        \t\t} else if(option.equals(\"c\")) {\n        \t\t\t\n        \t\t\tparams.link = false;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"L\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"l\")) {\n        \t\t\t\n        \t\t\tparams.dynamicLibs.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.equals(\"dyngc\")) {\n        \t\t\t\n        \t\t\tparams.dynGC = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"nogc\")) {\n        \t\t\t\n        \t\t\tparams.enableGC = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"noclean\")) {\n        \t\t\t\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"nolines\")) {\n        \t\t\t\n        \t\t\tparams.lineDirectives = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"shout\")) {\n        \t\t\t\n        \t\t\tparams.shout = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"timing\") || option.equals(\"t\")) {\n        \t\t\t\n        \t\t\tparams.timing = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"debug\") || option.equals(\"g\")) {\n        \t\t\t\n        \t\t\tparams.debug = true;\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"verbose\") || option.equals(\"v\")) {\n        \t\t\t\n        \t\t\tparams.verbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"veryVerbose\") || option.equals(\"vv\")) {\n        \t\t\t\n        \t\t\tparams.veryVerbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"run\") || option.equals(\"r\")) {\n        \t\t\t\n        \t\t\tparams.run = true;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"driver=\")) {\n        \t\t\t\n        \t\t\tString driverName = option.substring(\"driver=\".length());\n        \t\t\tif(driverName.equals(\"combine\")) {\n        \t\t\t\tdriver = new CombineDriver(params);\n        \t\t\t} else if(driverName.equals(\"sequence\")) {\n        \t\t\t\tdriver = new SequenceDriver(params);\n        \t\t\t} else {\n        \t\t\t\tSystem.out.println(\"Unknown driver '\"+driverName+\"'\");\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"blowup=\")) {\n        \t\t\t\n        \t\t\tparams.blowup = Integer.parseInt(option.substring(\"blowup=\".length()));\n        \t\t\t\n        \t\t} else if(option.equals(\"V\") || option.equals(\"-version\") || option.equals(\"version\")) {\n        \t\t\t\n        \t\t\tCompilerVersion.printVersion();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"h\") || option.equals(\"-help\") || option.equals(\"help\")) {\n        \t\t\t\n        \t\t\tHelp.printHelp();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.startsWith(\"gcc\")) {\n        \t\t\tif(option.startsWith(\"gcc=\")) {\n        \t\t\t\tparams.compiler = new Gcc(option.substring(4));\n        \t\t\t} else {\n        \t\t\t\tparams.compiler = new Gcc();\n        \t\t\t}\n        \t\t} else if(option.startsWith(\"icc\")) {\n        \t\t\tif(option.startsWith(\"icc=\")) {\n        \t\t\t\tparams.compiler = new Icc(option.substring(4));\n        \t\t\t} else {\n        \t\t\t\tparams.compiler = new Icc();\n        \t\t\t}\n        \t\t} else if(option.startsWith(\"tcc\")) {\n        \t\t\tif(option.startsWith(\"tcc=\")) {\n        \t\t\t\tparams.compiler = new Tcc(option.substring(4));\n        \t\t\t} else {\n        \t\t\t\tparams.compiler = new Tcc();\n        \t\t\t}\n        \t\t\tparams.dynGC = true;\n\t\t\t\t} else if(option.startsWith(\"clang\")) {\n\t\t\t\t\tif(option.startsWith(\"clang=\")) {\n        \t\t\t\tparams.compiler = new Clang(option.substring(6));\n        \t\t\t} else {\n        \t\t\t\tparams.compiler = new Clang();\n        \t\t\t}\n        \t\t} else if(option.equals(\"help-backends\") || option.equals(\"-help-backends\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpBackends();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-gcc\") || option.equals(\"-help-gcc\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpGcc();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-make\") || option.equals(\"-help-make\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpMake();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-none\") || option.equals(\"-help-none\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpNone();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"slave\")) {\n        \t\t\t\n        \t\t\tparams.slave = true;\n\n\t\t\t\t} else if(option.startsWith(\"m\")) {\n\t\t\t\t\t\n\t\t\t\t\tString arch = arg.substring(2);\n\t\t\t\t\tif (arch.equals(\"32\") || arch.equals(\"64\"))\n\t\t\t\t\t\tparams.arch = arg.substring(2);\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(\"Unrecognized architecture: \" + arch);\n\t\t\t\n        \t\t} else {\n        \t\t\t\n        \t\t\tSystem.err.println(\"Unrecognized option: '\"+arg+\"'\");\n        \t\t\t\n        \t\t}\n        \t} else if(arg.startsWith(\"+\")) {\n        \t\tdriver.compilerArgs.add(arg.substring(1));\n        \t} else {\n        \t\t\tString lowerArg = arg.toLowerCase();\n\t\t\t\t\tif(lowerArg.endsWith(\".s\")) {\n        \t\t\t\tnasms.add(arg);\n        \t\t\t} else if(lowerArg.endsWith(\".o\") || lowerArg.endsWith(\".c\") || lowerArg.endsWith(\".cpp\")) {\n        \t\t\t\tdriver.additionals.add(arg);\n            \t\t} else {\n            \t\t\tif(!lowerArg.endsWith(\".ooc\")) {\n            \t\t\t\tmodulePaths.add(arg+\".ooc\");\n            \t\t\t} else {\n            \t\t\t\tmodulePaths.add(arg);\n            \t\t\t}\n            \t\t}\n        \t}\n\t\t}\n\t\t\n\t\tif(modulePaths.isEmpty()) {\n\t\t\tSystem.err.println(\"ooc: no files.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(params.compiler == null) params.compiler = new Gcc();\n\t\t\n\t\tif(!nasms.isEmpty()) {\n\t\t\tdriver.compileNasms(nasms, driver.additionals);\n\t\t}\n\t\t\n\t\tif(params.sourcePath.isEmpty()) params.sourcePath.add(\".\");\n\t\tparams.sourcePath.add(params.sdkLocation.getPath());\n\t\n\t\tint errorCode = 0;\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tdo {\n\t\t\tModuleParser.clearCache();\n\t\t\tint successCount = 0;\n\t\t\tfor(String modulePath: modulePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tint code = parse(modulePath);\n\t\t\t\t\tif(code == 0) {\n\t\t\t\t\t\tsuccessCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrorCode = 2; // C compiler failure.\n\t\t\t\t\t}\n\t\t\t\t} catch(CompilationFailedError err) {\n\t\t\t\t\tif(errorCode == 0) errorCode = 1; // ooc failure\n\t\t\t\t\tSystem.err.println(err);\n\t\t\t\t\tfail();\n\t\t\t\t\tif(params.editor.length() > 0) {\n\t\t\t\t\t\tlaunchEditor(params.editor, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(params.clean) FileUtils.deleteRecursive(params.outPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(modulePaths.size() > 1) {\n\t\t\t\tSystem.out.println(modulePaths.size()+\" compiled (\"+successCount\n\t\t\t\t\t\t+\" success, \"+(modulePaths.size() - successCount)+\" failed)\");\n\t\t\t}\n\t\t\t\n\t\t\tif(params.slave) {\n\t\t\t\tSystem.out.println(\".-------------( ready )-------------.\\n\");\n\t\t\t\treader.readLine();\n\t\t\t} else {\n\t\t\t\tif(successCount < modulePaths.size()) {\n\t\t\t\t\tSystem.exit(errorCode);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} while(params.slave);\n\t\t\n\t}\n\n\tprivate void ok() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;32m[ OK ]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[ OK ]\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void fail() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;31m[FAIL]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[FAIL]\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void launchEditor(final String editor, final CompilationFailedError err) {\n\t\t\n\t\tif(err.getLocation() == null) return;\n\t\t\n\t\t//Thread thread = new Thread() {\n\t\t\t//@Override\n\t\t\t//public void run() {\n\t\t\t\ttry {\n\t\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\t\tFileLocation location = err.getLocation();\n\t\t\t\t\tString absolutePath = new File(location.getFileName()).getAbsolutePath();\n\t\t\t\t\tif(editor.equals(\"geany\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath+\":\"+location.getLineNumber()+\":\"+(location.getLinePos() - 1));\n\t\t\t\t\t} else if(editor.equals(\"mate\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath, \"-l\", String.valueOf(location.getLineNumber()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessUtils.redirectIO(builder.start());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t//}\n\t\t//};\n\t\t//thread.setDaemon(true);\n\t\t//thread.start();\n\t\t\n\t}\n\n\tprotected int parse(String modulePath) throws InterruptedException, IOException {\n\t\t\n\t\tparams.outPath.mkdirs();\n\t\tlong tt1 = System.nanoTime();\n\t\tModule module = new Parser(params).parse(modulePath);\n\t\tmodule.setMain(true);\n\t\tlong tt2 = System.nanoTime();\n\t\t\n\t\tArrayList<Module> list = new ArrayList<Module>();\n\t\tcollectModules(module, list);\n\t\ttinker(list);\n\t\t\n\t\tlong tt3 = System.nanoTime();\n\t\toutput(module, new HashSet<Module>());\n\t\tlong tt4 = System.nanoTime();\n\t\tint code = driver.compile(module);\n\t\tlong tt5 = System.nanoTime();\n\n\t\tif(params.timing) {\n\t\t\tSystem.out.printf(\"parse: %.2f ms\\ttinker: %.2f ms\\toutput: %.2f ms\\tcc: %.2f ms\\tTOTAL %.2f ms\\n\",\n\t\t\t\t\tFloat.valueOf((tt2 - tt1) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt3 - tt2) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt4 - tt3) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt4) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt1) / 1000000.0f));\n\t\t}\n\t\t\n\t\tif(code == 0) {\n\t\t\tif(params.shout) ok();\n\t\t\tif(params.run) {\n\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\tbuilder.command(\"./\"+module.getSimpleName());\n\t\t\t\tProcess process = builder.start();\n\t\t\t\tProcessUtils.redirectIO(process);\n\t\t\t\tint exitCode = process.waitFor();\n\t\t\t\tif(exitCode != 0) {\n\t\t\t\t\tSystem.out.println(\"Unerwarteter Programmabbruch. Return code: \"+exitCode+\". Please don't cry :(\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(params.shout) fail();\n\t\treturn code;\n\t\t\n\t}\n\t\n\tprotected void output(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\toutput(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\tnew CGenerator(params.outPath, module).generate(params);\n\t}\n\n\tprotected void collectModules(Module module, List<Module> list) throws IOException {\n\t\tlist.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!list.contains(imp.getModule())) {\n\t\t\t\tcollectModules(imp.getModule(), list);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected void tinker(List<Module> list) throws IOException {\n\t\tTinkerer tink = new Tinkerer();\n\t\ttink.process(list, params);\n\t}\n\n}\n","lineNo":249}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.backend.CachedFileWriter;\nimport org.ooc.backend.Generator;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ArrayLiteral;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.Block;\nimport org.ooc.frontend.model.BoolLiteral;\nimport org.ooc.frontend.model.BuiltinType;\nimport org.ooc.frontend.model.Case;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.CharLiteral;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Else;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FloatLiteral;\nimport org.ooc.frontend.model.FlowControl;\nimport org.ooc.frontend.model.Foreach;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.If;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.InterfaceDecl;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberArgument;\nimport org.ooc.frontend.model.MemberAssignArgument;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.NullLiteral;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.RegularArgument;\nimport org.ooc.frontend.model.Return;\nimport org.ooc.frontend.model.StringLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.ValuedReturn;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.VersionBlock;\nimport org.ooc.frontend.model.While;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.VersionNodes.VersionAnd;\nimport org.ooc.frontend.model.VersionNodes.VersionName;\nimport org.ooc.frontend.model.VersionNodes.VersionNegation;\nimport org.ooc.frontend.model.VersionNodes.VersionNodeVisitor;\nimport org.ooc.frontend.model.VersionNodes.VersionOr;\nimport org.ooc.frontend.model.VersionNodes.VersionParen;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.TypeArgument;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ooc.middle.structs.NodeMap;\nimport org.ubi.SourceReader;\n\npublic class CGenerator extends Generator implements Visitor {\n\n\tpublic final AwesomeWriter hw;\n\tpublic final AwesomeWriter cw;\n\tpublic AwesomeWriter current;\n\tpublic BuildParams params;\n\n\tpublic CGenerator(File outPath, Module module) {\n\t\tsuper(outPath, module);\n\t\tString basePath = module.getOutPath();\n\t\tFile hFile = new File(outPath, basePath + \".h\");\n\t\thFile.getParentFile().mkdirs();\n\t\tthis.hw = new AwesomeWriter(new CachedFileWriter(hFile));\n\t\tFile cFile = new File(outPath, basePath + \".c\");\n\t\tthis.cw = new AwesomeWriter(new CachedFileWriter(cFile));\n\t\tthis.current = hw;\n\t}\n\n\t@Override\n\tpublic void generate(BuildParams params) throws IOException {\n\t\tthis.params = params;\n\t\tmodule.accept(this);\n\t\thw.close();\n\t\tcw.close();\n\t}\n\n\tpublic void visit(Module module) throws IOException {\n\t\tModuleWriter.write(module, this);\n\t}\n\n\tpublic void visit(Add add) throws IOException {\n\t\tadd.getLeft().accept(this);\n\t\tcurrent.app(\" + \");\n\t\tadd.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Mul mul) throws IOException {\n\t\tmul.getLeft().accept(this);\n\t\tcurrent.app(\" * \");\n\t\tmul.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Sub sub) throws IOException {\n\t\tsub.getLeft().accept(this);\n\t\tcurrent.app(\" - \");\n\t\tsub.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Div div) throws IOException {\n\t\tdiv.getLeft().accept(this);\n\t\tcurrent.app(\" / \");\n\t\tdiv.getRight().accept(this);\n\t}\n\n\tpublic void visit(Not not) throws IOException {\n\t\tcurrent.app('!');\n\t\tnot.getExpression().accept(this);\t\t\n\t}\n\t\n\tpublic void visit(Mod mod) throws IOException {\n\t\tmod.getLeft().accept(this);\n\t\tcurrent.app(\" % \");\n\t\tmod.getRight().accept(this);\n\t}\n\t\n\tpublic void visit(Compare compare) throws IOException {\n\t\tcompare.getLeft().accept(this);\n\t\tswitch(compare.getCompareType()) {\n\t\t\tcase GREATER: current.app(\" > \"); break;\n\t\t\tcase GREATER_OR_EQUAL: current.app(\" >= \"); break;\n\t\t\tcase LESSER: current.app(\" < \"); break;\n\t\t\tcase LESSER_OR_EQUAL: current.app(\" <= \"); break;\n\t\t\tcase EQUAL: current.app(\" == \"); break;\n\t\t\tcase NOT_EQUAL: current.app(\" != \"); break;\n\t\t}\n\t\tcompare.getRight().accept(this);\n\t}\n\n\tpublic void visit(FunctionCall functionCall) throws IOException {\n\t\tCallWriter.write(functionCall, this);\n\t}\n\n\tpublic void visit(MemberCall memberCall) throws IOException {\n\t\tCallWriter.writeMember(memberCall, this);\n\t}\n\n\tpublic void visit(Parenthesis parenthesis) throws IOException {\n\t\tcurrent.app('(');\n\t\tparenthesis.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Assignment assignment) throws IOException {\n\t\tExpression left = assignment.getLeft();\n\t\tif(left instanceof VariableAccess) {\n\t\t\tAccessWriter.write((VariableAccess) left, false, this);\n\t\t} else {\n\t\t\tleft.accept(this);\n\t\t}\n\t\tcurrent.app(' ').app(assignment.getSymbol()).app(' ');\n\t\tassignment.getRight().accept(this);\n\t}\n\n\tpublic void visit(ValuedReturn return1) throws IOException {\n\t\tcurrent.app(\"return \");\n\t\treturn1.getExpression().accept(this);\n\t}\n\t\n\tpublic void visit(Return return1) throws IOException {\n\t\tcurrent.app(\"return\");\n\t}\n\n\tpublic void visit(NullLiteral nullLiteral) throws IOException {\n\t\tLiteralWriter.writeNull(this);\n\t}\n\n\tpublic void visit(IntLiteral numberLiteral) throws IOException {\n\t\tLiteralWriter.writeInt(numberLiteral, this);\n\t}\n\t\n\tpublic void visit(FloatLiteral floatLiteral) throws IOException {\n\t\tLiteralWriter.writeFloat(floatLiteral, this);\n\t}\n\n\tpublic void visit(StringLiteral stringLiteral) throws IOException {\n\t\tLiteralWriter.writeString(stringLiteral, this);\n\t}\n\n\tpublic void visit(RangeLiteral rangeLiteral) throws IOException {\n\t\tthrow new OocCompilationError(rangeLiteral, module,\n\t\t\t\t\"Using a range literal outside a foreach is not supported yet.\");\n\t}\n\n\tpublic void visit(BoolLiteral boolLiteral) throws IOException {\n\t\tcurrent.app(boolLiteral.getValue() ? \"true\" : \"false\");\n\t}\n\n\tpublic void visit(CharLiteral charLiteral) throws IOException {\n\t\tcurrent.app('\\'').app(SourceReader.spelled(charLiteral.getValue())).app('\\'');\t\t\n\t}\n\n\tpublic void visit(Line line) throws IOException {\n\t\tcurrent.nl();\n\t\tif(line.getStatement() instanceof FunctionCall) CallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\tline.getStatement().accept(this);\n\t\tif(!(line.getStatement() instanceof ControlStatement || line.getStatement() instanceof VersionBlock)) {\n\t\t\tcurrent.app(';');\n\t\t}\n\t}\n\n\tpublic void visit(Include include) throws IOException {}\n\n\tpublic void visit(If if1) throws IOException {\n\t\tControlStatementWriter.writeIf(if1, this);\n\t}\n\t\n\tpublic void visit(Else else1) throws IOException {\n\t\tControlStatementWriter.writeElse(else1, this);\n\t}\n\n\tpublic void visit(While while1) throws IOException {\n\t\tControlStatementWriter.writeWhile(while1, this);\n\t}\n\n\tpublic void visit(Foreach foreach) throws IOException {\n\t\tControlStatementWriter.writeForeach(foreach, this);\n\t}\n\n\tpublic void visit(MemberAccess memberAccess) throws IOException {\n\t\tAccessWriter.writeMember(memberAccess, this);\n\t}\n\t\n\tpublic void visit(VariableAccess variableAccess) throws IOException {\n\t\tAccessWriter.writeVariable(variableAccess, true, this);\n\t}\n\n\tpublic void visit(ArrayAccess arrayAccess) throws IOException {\n\t\tAccessWriter.writeArray(arrayAccess, this);\n\t}\n\n\tpublic void visit(VariableDecl variableDecl) throws IOException {\n\t\tVariableDeclWriter.write(variableDecl, this);\n\t}\n\n\tpublic void visit(FunctionDecl functionDecl) throws IOException {\n\t\tFunctionDeclWriter.write(functionDecl, this);\n\t}\n\n\tpublic void visit(ClassDecl classDecl) throws IOException {\n\t\tClassDeclWriter.write(classDecl, this);\n\t}\n\t\n\tpublic void visit(CoverDecl cover) throws IOException {\n\t\tCoverDeclWriter.write(cover, this);\n\t}\n\t\n\tpublic void visit(TypeArgument typeArgument) throws IOException {\n\t\ttypeArgument.getType().accept(this);\n\t}\n\n\tpublic void visit(RegularArgument regularArgument) throws IOException {\n\t\tType type = regularArgument.getType();\n\t\tif(type.isArray()) {\n\t\t\tcurrent.app(type.getName()).app(' ').app(regularArgument.getName());\n\t\t\tfor(int i = 0; i < type.getPointerLevel(); i++) {\n\t\t\t\tcurrent.app(\"[]\");\n\t\t\t}\n\t\t} else {\n\t\t\tif(type instanceof FuncType) {\n\t\t\t\tTypeWriter.writeFuncPointer((FunctionDecl) type.getRef(), regularArgument.getName(), this);\n\t\t\t} else {\n\t\t\t\tTypeWriter.writeSpaced(type, this);\n\t\t\t\tcurrent.app(regularArgument.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void visit(MemberArgument memberArgument) throws IOException {}\n\n\tpublic void visit(MemberAssignArgument memberArgument) throws IOException {}\n\n\tpublic void visit(Type type) throws IOException {\n\t\tTypeWriter.write(type, this);\n\t}\n\n\tpublic void visit(VarArg varArg) throws IOException {\n\t\tcurrent.app(\"...\");\n\t}\n\t\n\tpublic void visit(NodeList<? extends Node> list) throws IOException {\n\t\tlist.acceptChildren(this);\n\t}\n\t\n\tpublic void visit(Block block) throws IOException {\n\t\tcurrent.openBlock();\n\t\tblock.acceptChildren(this);\n\t\tcurrent.closeBlock();\n\t}\n\n\tpublic void visit(BuiltinType builtinType) throws IOException {}\n\n\tpublic void visit(VariableDeclAtom variableDeclAtom) throws IOException {}\n\t\n\tpublic void visit(Cast cast) throws IOException {\n\t\tCastWriter.write(cast, this);\n\t}\n\n\tpublic void visit(AddressOf addressOf) throws IOException {\n\t\tif(addressOf.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) addressOf.getExpression();\n\t\t\tType varAccType = varAcc.getRef().getType();\n\t\t\tif(varAccType.getRef() instanceof TypeParam) {\n\t\t\t\tAccessWriter.write(varAcc, false, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(varAccType.getReferenceLevel() == 1) {\n\t\t\t\tAccessWriter.write(varAcc, false, this, -1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcurrent.app('&');\n\t\tboolean paren = !(addressOf.getExpression() instanceof VariableAccess);\n\t\tif(paren) current.app('(');\n\t\taddressOf.getExpression().accept(this);\n\t\tif(paren) current.app(')');\n\t}\n\n\tpublic void visit(Dereference dereference) throws IOException {\n\t\tcurrent.app(\"(*\");\n\t\tdereference.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(OpDecl opDecl) throws IOException {\n\t\topDecl.getFunc().accept(this);\n\t}\n\n\tpublic void visit(Import import1) throws IOException {}\n\t\n\tpublic void visit(ArrayLiteral arrayLiteral) throws IOException {\n\t\tcurrent.app('{');\n\t\tIterator<Expression> iter = arrayLiteral.getElements().iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression element = iter.next();\n\t\t\tboolean doCasting = false;\n\t\t\tif(!element.getType().getName().equals(arrayLiteral.getType().getName())) {\n\t\t\t\tdoCasting = true;\n\t\t\t\tcurrent.app(\"((\");\n\t\t\t\tarrayLiteral.getElements().get(0).getType().accept(this);\n\t\t\t\tcurrent.app(\") \");\n\t\t\t}\n\t\t\telement.accept(this);\n\t\t\tif(doCasting) {\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\tif(iter.hasNext()) current.app(\", \");\n\t\t}\n\t\tcurrent.app('}');\n\t}\n\n\tpublic void visit(Use use) throws IOException {}\n\n\tpublic void visit(BinaryCombination binaryCombination) throws IOException {\n\t\tbinaryCombination.getLeft().accept(this);\n\t\tcurrent.app(' ').app(binaryCombination.getOpString()).app(' ');\n\t\tbinaryCombination.getRight().accept(this);\n\t}\n\n\tpublic void visit(MultiMap<?, ?> list) throws IOException {}\n\n\tpublic void visit(FlowControl flow) throws IOException {\n\t\tcurrent.app(flow.getKeyword()).app(\";\");\n\t}\n\n\tpublic void visit(InterfaceDecl interfaceDecl) throws IOException {\n\t\t// huh.. slack off?\n\t}\n\n\tpublic void visit(Ternary ternary) throws IOException {\n\t\tternary.getCondition().accept(this);\n\t\tcurrent.app(\" ? \");\n\t\tternary.getValueIfTrue().accept(this);\n\t\tcurrent.app(\" : \");\n\t\tternary.getValueIfFalse().accept(this);\n\t}\n\n\tpublic void visit(Match match) throws IOException {\n\t\tboolean isFirst = true;\n\t\tfor(Case case1: match.getCases()) {\n\t\t\tif(!isFirst) {\n\t\t\t\tcurrent.app(\" else \");\n\t\t\t}\n\n\t\t\tif(case1.getExpr() == null) {\n\t\t\t\tif(isFirst) current.app(\" else \");\n\t\t\t} else {\n\t\t\t\tif(case1.isFallthrough()) current.app(' ');\n\t\t\t\tcurrent.app(\"if (\");\n\t\t\t\tcase1.getExpr().accept(this);\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.app(\"{\").tab();\n\t\t\t\n\t\t\tfor(Line line: case1.getBody()) {\n\t\t\t\tcurrent.newLine();\n\t\t\t\tif(line.getStatement() instanceof FunctionCall) {\n\t\t\t\t\tCallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\t\t\t}\n\t\t\t\tline.getStatement().accept(this);\n\t\t\t\tcurrent.append(\";\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.untab().nl().app(\"}\");\n\t\t\tif(isFirst) isFirst = false;\n\t\t}\n\t}\n\n\tpublic void visit(Case case1) throws IOException {\n\t\t// hmmm... no\n\t}\n\n\tpublic void visit(VersionBlock versionBlock) throws IOException {\n\t\tcurrent.app(\"\\n#if \");\n\t\t\n\t\tversionBlock.getVersion().accept(new VersionNodeVisitor() {\n\t\t\t\n\t\t\tpublic void visit(VersionOr versionOr) throws IOException {\n\t\t\t\tversionOr.getLeft().accept(this);\n\t\t\t\tcurrent.app(\" || \");\n\t\t\t\tversionOr.getRight().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionAnd versionAnd) throws IOException {\n\t\t\t\tversionAnd.getLeft().accept(this);\n\t\t\t\tcurrent.app(\" && \");\n\t\t\t\tversionAnd.getRight().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionNegation versionNegation) throws IOException {\n\t\t\t\tcurrent.app('!');\n\t\t\t\tversionNegation.getInner().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionName versionName) throws IOException {\n\t\t\t\tcurrent.app(\"defined(\").app(versionName.getName()).app(\")\");\n\t\t\t}\n\n\t\t\tpublic void visit(VersionParen versionParen) throws IOException {\n\t\t\t\tcurrent.app('(');\n\t\t\t\tversionParen.getInner().accept(this);\n\t\t\t\tcurrent.app(')');\n\t\t\t}\n\t\t});\n\t\t\n\t\tvisit((Block) versionBlock);\n\t\tcurrent.app(\"\\n#endif\");\n\t}\n\n\tpublic void visit(NodeMap<?, ? extends Node> list) throws IOException {}\n\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.backend.CachedFileWriter;\nimport org.ooc.backend.Generator;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ArrayLiteral;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.Block;\nimport org.ooc.frontend.model.BoolLiteral;\nimport org.ooc.frontend.model.BuiltinType;\nimport org.ooc.frontend.model.Case;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.CharLiteral;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Else;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FloatLiteral;\nimport org.ooc.frontend.model.FlowControl;\nimport org.ooc.frontend.model.Foreach;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.If;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.InterfaceDecl;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberArgument;\nimport org.ooc.frontend.model.MemberAssignArgument;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.NullLiteral;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.RegularArgument;\nimport org.ooc.frontend.model.Return;\nimport org.ooc.frontend.model.StringLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.ValuedReturn;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.VersionBlock;\nimport org.ooc.frontend.model.While;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.VersionNodes.VersionAnd;\nimport org.ooc.frontend.model.VersionNodes.VersionName;\nimport org.ooc.frontend.model.VersionNodes.VersionNegation;\nimport org.ooc.frontend.model.VersionNodes.VersionNodeVisitor;\nimport org.ooc.frontend.model.VersionNodes.VersionOr;\nimport org.ooc.frontend.model.VersionNodes.VersionParen;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.TypeArgument;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ooc.middle.structs.NodeMap;\nimport org.ubi.SourceReader;\n\npublic class CGenerator extends Generator implements Visitor {\n\n\tpublic final AwesomeWriter hw;\n\tpublic final AwesomeWriter cw;\n\tpublic AwesomeWriter current;\n\tpublic BuildParams params;\n\n\tpublic CGenerator(File outPath, Module module) {\n\t\tsuper(outPath, module);\n\t\tString basePath = module.getOutPath();\n\t\tFile hFile = new File(outPath, basePath + \".h\");\n\t\thFile.getParentFile().mkdirs();\n\t\tthis.hw = new AwesomeWriter(new CachedFileWriter(hFile));\n\t\tFile cFile = new File(outPath, basePath + \".c\");\n\t\tthis.cw = new AwesomeWriter(new CachedFileWriter(cFile));\n\t\tthis.current = hw;\n\t}\n\n\t@Override\n\tpublic void generate(BuildParams params) throws IOException {\n\t\tthis.params = params;\n\t\tmodule.accept(this);\n\t\thw.close();\n\t\tcw.close();\n\t}\n\n\tpublic void visit(Module module) throws IOException {\n\t\tModuleWriter.write(module, this);\n\t}\n\n\tpublic void visit(Add add) throws IOException {\n\t\tadd.getLeft().accept(this);\n\t\tcurrent.app(\" + \");\n\t\tadd.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Mul mul) throws IOException {\n\t\tmul.getLeft().accept(this);\n\t\tcurrent.app(\" * \");\n\t\tmul.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Sub sub) throws IOException {\n\t\tsub.getLeft().accept(this);\n\t\tcurrent.app(\" - \");\n\t\tsub.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Div div) throws IOException {\n\t\tdiv.getLeft().accept(this);\n\t\tcurrent.app(\" / \");\n\t\tdiv.getRight().accept(this);\n\t}\n\n\tpublic void visit(Not not) throws IOException {\n\t\tcurrent.app('!');\n\t\tnot.getExpression().accept(this);\t\t\n\t}\n\t\n\tpublic void visit(Mod mod) throws IOException {\n\t\tmod.getLeft().accept(this);\n\t\tcurrent.app(\" % \");\n\t\tmod.getRight().accept(this);\n\t}\n\t\n\tpublic void visit(Compare compare) throws IOException {\n\t\tcompare.getLeft().accept(this);\n\t\tswitch(compare.getCompareType()) {\n\t\t\tcase GREATER: current.app(\" > \"); break;\n\t\t\tcase GREATER_OR_EQUAL: current.app(\" >= \"); break;\n\t\t\tcase LESSER: current.app(\" < \"); break;\n\t\t\tcase LESSER_OR_EQUAL: current.app(\" <= \"); break;\n\t\t\tcase EQUAL: current.app(\" == \"); break;\n\t\t\tcase NOT_EQUAL: current.app(\" != \"); break;\n\t\t}\n\t\tcompare.getRight().accept(this);\n\t}\n\n\tpublic void visit(FunctionCall functionCall) throws IOException {\n\t\tCallWriter.write(functionCall, this);\n\t}\n\n\tpublic void visit(MemberCall memberCall) throws IOException {\n\t\tCallWriter.writeMember(memberCall, this);\n\t}\n\n\tpublic void visit(Parenthesis parenthesis) throws IOException {\n\t\tcurrent.app('(');\n\t\tparenthesis.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Assignment assignment) throws IOException {\n\t\tExpression left = assignment.getLeft();\n\t\tif(left instanceof VariableAccess) {\n\t\t\tAccessWriter.write((VariableAccess) left, false, this);\n\t\t} else {\n\t\t\tleft.accept(this);\n\t\t}\n\t\tcurrent.app(' ').app(assignment.getSymbol()).app(' ');\n\t\tassignment.getRight().accept(this);\n\t}\n\n\tpublic void visit(ValuedReturn return1) throws IOException {\n\t\tcurrent.app(\"return \");\n\t\treturn1.getExpression().accept(this);\n\t}\n\t\n\tpublic void visit(Return return1) throws IOException {\n\t\tcurrent.app(\"return\");\n\t}\n\n\tpublic void visit(NullLiteral nullLiteral) throws IOException {\n\t\tLiteralWriter.writeNull(this);\n\t}\n\n\tpublic void visit(IntLiteral numberLiteral) throws IOException {\n\t\tLiteralWriter.writeInt(numberLiteral, this);\n\t}\n\t\n\tpublic void visit(FloatLiteral floatLiteral) throws IOException {\n\t\tLiteralWriter.writeFloat(floatLiteral, this);\n\t}\n\n\tpublic void visit(StringLiteral stringLiteral) throws IOException {\n\t\tLiteralWriter.writeString(stringLiteral, this);\n\t}\n\n\tpublic void visit(RangeLiteral rangeLiteral) throws IOException {\n\t\tthrow new OocCompilationError(rangeLiteral, module,\n\t\t\t\t\"Using a range literal outside a foreach is not supported yet.\");\n\t}\n\n\tpublic void visit(BoolLiteral boolLiteral) throws IOException {\n\t\tcurrent.app(boolLiteral.getValue() ? \"true\" : \"false\");\n\t}\n\n\tpublic void visit(CharLiteral charLiteral) throws IOException {\n\t\tcurrent.app('\\'').app(SourceReader.spelled(charLiteral.getValue())).app('\\'');\t\t\n\t}\n\n\tpublic void visit(Line line) throws IOException {\n\t\tcurrent.nl();\n\t\tif(line.getStatement() instanceof FunctionCall) CallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\tline.getStatement().accept(this);\n\t\tif(!(line.getStatement() instanceof ControlStatement || line.getStatement() instanceof VersionBlock)) {\n\t\t\tcurrent.app(';');\n\t\t}\n\t}\n\n\tpublic void visit(Include include) throws IOException {}\n\n\tpublic void visit(If if1) throws IOException {\n\t\tControlStatementWriter.writeIf(if1, this);\n\t}\n\t\n\tpublic void visit(Else else1) throws IOException {\n\t\tControlStatementWriter.writeElse(else1, this);\n\t}\n\n\tpublic void visit(While while1) throws IOException {\n\t\tControlStatementWriter.writeWhile(while1, this);\n\t}\n\n\tpublic void visit(Foreach foreach) throws IOException {\n\t\tControlStatementWriter.writeForeach(foreach, this);\n\t}\n\n\tpublic void visit(MemberAccess memberAccess) throws IOException {\n\t\tAccessWriter.writeMember(memberAccess, this);\n\t}\n\t\n\tpublic void visit(VariableAccess variableAccess) throws IOException {\n\t\tAccessWriter.writeVariable(variableAccess, true, this);\n\t}\n\n\tpublic void visit(ArrayAccess arrayAccess) throws IOException {\n\t\tAccessWriter.writeArray(arrayAccess, this);\n\t}\n\n\tpublic void visit(VariableDecl variableDecl) throws IOException {\n\t\tVariableDeclWriter.write(variableDecl, this);\n\t}\n\n\tpublic void visit(FunctionDecl functionDecl) throws IOException {\n\t\tFunctionDeclWriter.write(functionDecl, this);\n\t}\n\n\tpublic void visit(ClassDecl classDecl) throws IOException {\n\t\tClassDeclWriter.write(classDecl, this);\n\t}\n\t\n\tpublic void visit(CoverDecl cover) throws IOException {\n\t\tCoverDeclWriter.write(cover, this);\n\t}\n\t\n\tpublic void visit(TypeArgument typeArgument) throws IOException {\n\t\ttypeArgument.getType().accept(this);\n\t}\n\n\tpublic void visit(RegularArgument regularArgument) throws IOException {\n\t\tType type = regularArgument.getType();\n\t\tif(type.isArray()) {\n\t\t\tcurrent.app(type.getName()).app(' ').app(regularArgument.getName());\n\t\t\tfor(int i = 0; i < type.getPointerLevel(); i++) {\n\t\t\t\tcurrent.app(\"[]\");\n\t\t\t}\n\t\t} else {\n\t\t\tif(type instanceof FuncType) {\n\t\t\t\tTypeWriter.writeFuncPointer((FunctionDecl) type.getRef(), regularArgument.getName(), this);\n\t\t\t} else {\n\t\t\t\tTypeWriter.writeSpaced(type, this);\n\t\t\t\tcurrent.app(regularArgument.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void visit(MemberArgument memberArgument) throws IOException {}\n\n\tpublic void visit(MemberAssignArgument memberArgument) throws IOException {}\n\n\tpublic void visit(Type type) throws IOException {\n\t\tTypeWriter.write(type, this);\n\t}\n\n\tpublic void visit(VarArg varArg) throws IOException {\n\t\tcurrent.app(\"...\");\n\t}\n\t\n\tpublic void visit(NodeList<? extends Node> list) throws IOException {\n\t\tlist.acceptChildren(this);\n\t}\n\t\n\tpublic void visit(Block block) throws IOException {\n\t\tcurrent.openBlock();\n\t\tblock.acceptChildren(this);\n\t\tcurrent.closeBlock();\n\t}\n\n\tpublic void visit(BuiltinType builtinType) throws IOException {}\n\n\tpublic void visit(VariableDeclAtom variableDeclAtom) throws IOException {}\n\t\n\tpublic void visit(Cast cast) throws IOException {\n\t\tCastWriter.write(cast, this);\n\t}\n\n\tpublic void visit(AddressOf addressOf) throws IOException {\n\t\tif(addressOf.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) addressOf.getExpression();\n\t\t\tType varAccType = varAcc.getRef().getType();\n\t\t\tif(varAccType.getRef() instanceof TypeParam) {\n\t\t\t\tAccessWriter.write(varAcc, false, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(varAccType.getReferenceLevel() == 1) {\n\t\t\t\tAccessWriter.write(varAcc, false, this, -1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcurrent.app('&');\n\t\tboolean paren = !(addressOf.getExpression() instanceof VariableAccess);\n\t\tif(paren) current.app('(');\n\t\tExpression expr = addressOf.getExpression();\n\t\twhile(expr instanceof Cast) {\n\t\t\texpr = ((Cast) expr).getExpression();\n\t\t}\n\t\texpr.accept(this);\n\t\tif(paren) current.app(')');\n\t}\n\n\tpublic void visit(Dereference dereference) throws IOException {\n\t\tcurrent.app(\"(*\");\n\t\tdereference.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(OpDecl opDecl) throws IOException {\n\t\topDecl.getFunc().accept(this);\n\t}\n\n\tpublic void visit(Import import1) throws IOException {}\n\t\n\tpublic void visit(ArrayLiteral arrayLiteral) throws IOException {\n\t\tcurrent.app('{');\n\t\tIterator<Expression> iter = arrayLiteral.getElements().iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression element = iter.next();\n\t\t\tboolean doCasting = false;\n\t\t\tif(!element.getType().getName().equals(arrayLiteral.getType().getName())) {\n\t\t\t\tdoCasting = true;\n\t\t\t\tcurrent.app(\"((\");\n\t\t\t\tarrayLiteral.getElements().get(0).getType().accept(this);\n\t\t\t\tcurrent.app(\") \");\n\t\t\t}\n\t\t\telement.accept(this);\n\t\t\tif(doCasting) {\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\tif(iter.hasNext()) current.app(\", \");\n\t\t}\n\t\tcurrent.app('}');\n\t}\n\n\tpublic void visit(Use use) throws IOException {}\n\n\tpublic void visit(BinaryCombination binaryCombination) throws IOException {\n\t\tbinaryCombination.getLeft().accept(this);\n\t\tcurrent.app(' ').app(binaryCombination.getOpString()).app(' ');\n\t\tbinaryCombination.getRight().accept(this);\n\t}\n\n\tpublic void visit(MultiMap<?, ?> list) throws IOException {}\n\n\tpublic void visit(FlowControl flow) throws IOException {\n\t\tcurrent.app(flow.getKeyword()).app(\";\");\n\t}\n\n\tpublic void visit(InterfaceDecl interfaceDecl) throws IOException {\n\t\t// huh.. slack off?\n\t}\n\n\tpublic void visit(Ternary ternary) throws IOException {\n\t\tternary.getCondition().accept(this);\n\t\tcurrent.app(\" ? \");\n\t\tternary.getValueIfTrue().accept(this);\n\t\tcurrent.app(\" : \");\n\t\tternary.getValueIfFalse().accept(this);\n\t}\n\n\tpublic void visit(Match match) throws IOException {\n\t\tboolean isFirst = true;\n\t\tfor(Case case1: match.getCases()) {\n\t\t\tif(!isFirst) {\n\t\t\t\tcurrent.app(\" else \");\n\t\t\t}\n\n\t\t\tif(case1.getExpr() == null) {\n\t\t\t\tif(isFirst) current.app(\" else \");\n\t\t\t} else {\n\t\t\t\tif(case1.isFallthrough()) current.app(' ');\n\t\t\t\tcurrent.app(\"if (\");\n\t\t\t\tcase1.getExpr().accept(this);\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.app(\"{\").tab();\n\t\t\t\n\t\t\tfor(Line line: case1.getBody()) {\n\t\t\t\tcurrent.newLine();\n\t\t\t\tif(line.getStatement() instanceof FunctionCall) {\n\t\t\t\t\tCallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\t\t\t}\n\t\t\t\tline.getStatement().accept(this);\n\t\t\t\tcurrent.append(\";\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.untab().nl().app(\"}\");\n\t\t\tif(isFirst) isFirst = false;\n\t\t}\n\t}\n\n\tpublic void visit(Case case1) throws IOException {\n\t\t// hmmm... no\n\t}\n\n\tpublic void visit(VersionBlock versionBlock) throws IOException {\n\t\tcurrent.app(\"\\n#if \");\n\t\t\n\t\tversionBlock.getVersion().accept(new VersionNodeVisitor() {\n\t\t\t\n\t\t\tpublic void visit(VersionOr versionOr) throws IOException {\n\t\t\t\tversionOr.getLeft().accept(this);\n\t\t\t\tcurrent.app(\" || \");\n\t\t\t\tversionOr.getRight().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionAnd versionAnd) throws IOException {\n\t\t\t\tversionAnd.getLeft().accept(this);\n\t\t\t\tcurrent.app(\" && \");\n\t\t\t\tversionAnd.getRight().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionNegation versionNegation) throws IOException {\n\t\t\t\tcurrent.app('!');\n\t\t\t\tversionNegation.getInner().accept(this);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void visit(VersionName versionName) throws IOException {\n\t\t\t\tcurrent.app(\"defined(\").app(versionName.getName()).app(\")\");\n\t\t\t}\n\n\t\t\tpublic void visit(VersionParen versionParen) throws IOException {\n\t\t\t\tcurrent.app('(');\n\t\t\t\tversionParen.getInner().accept(this);\n\t\t\t\tcurrent.app(')');\n\t\t\t}\n\t\t});\n\t\t\n\t\tvisit((Block) versionBlock);\n\t\tcurrent.app(\"\\n#endif\");\n\t}\n\n\tpublic void visit(NodeMap<?, ? extends Node> list) throws IOException {}\n\n}\n","lineNo":348}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected boolean superCall;\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\tprotected boolean dead = false;\n\t\n\tpublic FunctionCall(String name, Token startToken) {\n\t\tthis(name, null, startToken);\n\t}\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\t\n\tpublic boolean isSuperCall() {\n\t\treturn superCall;\n\t}\n\t\n\tpublic void setSuperCall(boolean superCall) {\n\t\tthis.superCall = superCall;\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t\tif(realType != null) realType.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tResponse response = resolveRegular(stack, res, fatal);\n\t\t\t\tif(response != Response.OK) return response;\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n \t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < arguments.size(); i++) {\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\tif(i < impl.getArguments().size()) {\n\t\t\t\tArgument implArg = impl.getArguments().get(i);\n\t\t\t\tif(callArg.getType() != null && implArg.getType() != null\n\t\t\t\t\t\t&& callArg.getType().isGeneric() && (callArg.getType().getPointerLevel() == 0)\n\t\t\t\t\t\t&& implArg.getType().isFlat()) {\n\t\t\t\t\targuments.set(i, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName(), res);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(\"gcall\", stack), this, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!parent.replace(this, vdfe)) {\n\t\t\t\t\tThread.dumpStack();\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"[FC] Couldn't replace \\n\"+this+\" with \\n\"+vdfe\n\t\t\t\t\t\t\t+\"in \\n\"+parent.getClass().getSimpleName()+\"|\"+parent);\n\t\t\t\t}\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tExpression realExpr = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(realExpr == null) return null;\n\t\treturn realExpr.getType();\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\t\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\t\n\t\t\t// e.g. func <T> myFunc(T: Class), and arg = T\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = callArg;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", argName-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(value: T), and arg = value.\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\tTypeAccess typeAcc = new TypeAccess(callArg.getType());\n\t\t\t\t//varAcc.setRef(callArg.getType().getRef());\n\t\t\t\ttypeAcc.resolve(stack, res, fatal);\n\t\t\t\tresult = typeAcc;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", varAccType-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(list:)\n\t\t\tif(arg.getType().isGenericRecursive()) {\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(arg.getType()+\" is generic-recursive, trying to get <\"+typeParam+\"> in it.\");\n\t\t\t\tresult = searchTypeParam(typeParam, arg.getType(), stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", genericRecursive-wise\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\t/**\n\t * Search for the type param @needle in the type @haystack\n\t */\n\tprivate Expression searchTypeParam(String needle, Type haystack,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = haystack.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(needle)) {\n\t\t\t\t\tType realType = getRealType(haystack.getName(), stack, res, fatal);\n\t\t\t\t\tif(realType != null) {\n\t\t\t\t\t\treturn realType.getTypeParams().get(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\t\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\", stack), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tif(declType != null) declType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix == null || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected Response resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return Response.OK;\n\t\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) turnIntoMemberCall(stack, res);\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate void turnIntoMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tmemberCall.setSuperCall(superCall);\n\t\tstack.peek().replace(this, memberCall);\n\t\tdead = true;\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix == null || suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName, Resolver res) {\n\t\n\t\tif(res.params.veryVerbose) {\n\t\t\tThread.dumpStack();\n\t\t}\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+getProtoRepr());\n\t\t\n\t}\n\t\n\t@Override\n\tpublic boolean canBeReferenced() {\n\t\treturn false;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected boolean superCall;\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\tprotected boolean dead = false;\n\t\n\tpublic FunctionCall(String name, Token startToken) {\n\t\tthis(name, null, startToken);\n\t}\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\t\n\tpublic boolean isSuperCall() {\n\t\treturn superCall;\n\t}\n\t\n\tpublic void setSuperCall(boolean superCall) {\n\t\tthis.superCall = superCall;\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t\tif(realType != null) realType.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tResponse response = resolveRegular(stack, res, fatal);\n\t\t\t\tif(response != Response.OK) return response;\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n \t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\n\t\tint argOffset = impl.hasThis() ? 1 : 0;\n\t\tfor(int i = 0; i < arguments.size(); i++) {\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\tif(i + argOffset < impl.getArguments().size()) {\n\t\t\t\tArgument implArg = impl.getArguments().get(i + argOffset);\n\t\t\t\tif(callArg.getType() != null && implArg.getType() != null\n\t\t\t\t\t\t&& callArg.getType().isGeneric() && (callArg.getType().getPointerLevel() == 0)\n\t\t\t\t\t\t&& implArg.getType().isFlat() && !implArg.getType().equals(callArg.getType())) {\n\t\t\t\t\targuments.set(i, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName(), res);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(\"gcall\", stack), this, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!parent.replace(this, vdfe)) {\n\t\t\t\t\tThread.dumpStack();\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"[FC] Couldn't replace \\n\"+this+\" with \\n\"+vdfe\n\t\t\t\t\t\t\t+\"in \\n\"+parent.getClass().getSimpleName()+\"|\"+parent);\n\t\t\t\t}\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tExpression realExpr = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(realExpr == null) return null;\n\t\treturn realExpr.getType();\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\t\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\t\n\t\t\t// e.g. func <T> myFunc(T: Class), and arg = T\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = callArg;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", argName-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(value: T), and arg = value.\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\t// not resolved yet?\n\t\t\t\tif(callArg.getType() == null) return null;\n\t\t\t\tTypeAccess typeAcc = new TypeAccess(callArg.getType());\n\t\t\t\t//varAcc.setRef(callArg.getType().getRef());\n\t\t\t\ttypeAcc.resolve(stack, res, fatal);\n\t\t\t\tresult = typeAcc;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", varAccType-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(list:)\n\t\t\tif(arg.getType().isGenericRecursive()) {\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(arg.getType()+\" is generic-recursive, trying to get <\"+typeParam+\"> in it.\");\n\t\t\t\tresult = searchTypeParam(typeParam, arg.getType(), stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", genericRecursive-wise\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\t/**\n\t * Search for the type param @needle in the type @haystack\n\t */\n\tprivate Expression searchTypeParam(String needle, Type haystack,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = haystack.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(needle)) {\n\t\t\t\t\tType realType = getRealType(haystack.getName(), stack, res, fatal);\n\t\t\t\t\tif(realType != null) {\n\t\t\t\t\t\treturn realType.getTypeParams().get(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\t\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess || expr instanceof Cast)) {\n\t\t\t\tString tmpName = generateTempName(genType.getName()+\"param\", stack);\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\ttmpName, expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tif(declType != null) declType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix == null || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected Response resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return Response.OK;\n\t\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) turnIntoMemberCall(stack, res);\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate void turnIntoMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tmemberCall.setSuperCall(superCall);\n\t\tstack.peek().replace(this, memberCall);\n\t\tdead = true;\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix == null || suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName, Resolver res) {\n\t\n\t\tif(res.params.veryVerbose) {\n\t\t\tThread.dumpStack();\n\t\t}\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+getProtoRepr());\n\t\t\n\t}\n\t\n\t@Override\n\tpublic boolean canBeReferenced() {\n\t\treturn false;\n\t}\n\t\n}\n","lineNo":417}
{"Smelly Sample":"package org.ooc.frontend.drivers;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.ooc.frontend.Target;\nimport org.ooc.frontend.compilers.AbstractCompiler;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Module;\n\npublic class SequenceDriver extends Driver {\n\n\tint finalCode;\n\tint count;\n\t\n\t@Override\n\tpublic int compile(Module module) throws Error, IOException, InterruptedException {\n\t\t\n\t\tcopyLocalHeaders(module, params, new HashSet<Module>());\n\t\t\n\t\tHashSet<Module> toCompile = collectDeps(module, new HashSet<Module>());\n\t\t\n\t\tfinal ArrayList<String> oPaths = new ArrayList<String> ();\n\t\tfinal long tt0 = System.nanoTime(); \n\t\tfinal Iterator<Module> iterator = toCompile.iterator();\n\t\t//count = toCompile.size();\n\t\t\n\t\tfinal AtomicInteger count = new AtomicInteger(toCompile.size());\t\t\n\t\t\n\t\tfinalCode = 0;\n\t\n\t\tRunnable runnable = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\t\n\t\t\t\tAbstractCompiler compiler = params.compiler.clone();\n\t\t\t\t\n\t\t\t\twhile(iterator.hasNext()) {\n\t\t\t\t\t\n\t\t\t\t\tModule currentModule = null;\n\t\t\t\t\t\n\t\t\t\t\tsynchronized(iterator) {\n\t\t\t\t\t\tcurrentModule = iterator.next();\n\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tinitCompiler(compiler);\n\t\t\t\t\tcompiler.setCompileOnly();\n\t\t\t\t\t\n\t\t\t\t\tString path = new File(params.outPath, currentModule.getPath(\"\")).getPath();\n\t\t\t\t\tString oPath = path + \".o\";\n\t\t\t\t\toPaths.add(oPath);\n\t\t\t\t\tcompiler.addObjectFile(path + \".c\");\n\t\t\t\t\tcompiler.setOutputPath(oPath);\n\t\t\t\t\t\n\t\t\t\t\tif(params.verbose) System.out.print(compiler.getCommandLine());\n\t\t\t\t\t\n\t\t\t\t\tlong tt1 = System.nanoTime();\n\t\t\t\t\tint code = -1;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcode = compiler.launch();\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tlong tt2 = System.nanoTime();\n\t\t\t\t\tif(params.verbose) System.out.println(\"  (\" + ((tt2 - tt1) / 1000000)+\"ms)\");\n\t\t\t\t\t\t\n\t\t\t\t\tif(code != 0) {\n\t\t\t\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t\t\t\t\tfinalCode = code;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tsynchronized(iterator) {\n\t\t\t\t\t\t//count--;\n\t\t\t\t\t\tcount.decrementAndGet();\n\t\t\t\t\t}\n\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t};\n\t\t\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tnew Thread(runnable).start();\n\t\t}\n\t\t\n\t\twhile(count.get() > 0) {\n\t\t\tThread.sleep(100L);\n\t\t}\n\t\t\n\t\tif(params.link) {\n\t\t\t\n\t\t\tinitCompiler(params.compiler);\n\t\t\t\n\t\t\tfor(String oPath: oPaths) {\n\t\t\t\tparams.compiler.addObjectFile(oPath);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String dynamicLib: params.dynamicLibs) {\n\t\t\t\tparams.compiler.addDynamicLibrary(dynamicLib);\n\t\t\t}\n\t\t\tfor(String additional: additionals) {\n\t\t\t\tparams.compiler.addObjectFile(additional);\n\t\t\t}\n\t\t\t\n\t\t\tparams.compiler.setOutputPath(module.getSimpleName());\n\t\t\tCollection<String> libs = getFlagsFromUse(module);\n\t\t\tfor(String lib: libs) params.compiler.addObjectFile(lib);\n\t\t\t\n\t\t\tif(params.enableGC) {\n\t\t\t\tparams.compiler.addDynamicLibrary(\"pthread\");\n\t\t\t\tif(params.dynGC) {\n\t\t\t\t\tparams.compiler.addDynamicLibrary(\"gc\");\n\t\t\t\t} else {\n\t\t\t\t\tparams.compiler.addObjectFile(new File(params.distLocation, \"libs/\"\n\t\t\t\t\t\t\t+ Target.guessHost().toString(params.arch.equals(\"\") ? Target.getArch() : params.arch) + \"/libgc.a\").getPath());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(params.verbose) System.out.println(params.compiler.getCommandLine());\n\n\t\tlong tt1 = System.nanoTime();\n\t\tint code = params.compiler.launch();\n\t\tlong tt2 = System.nanoTime();\n\t\tif(params.verbose) System.out.println(\"  (linking \" + ((tt2 - tt1) / 1000000)+\"ms)\");\n\t\t\n\t\tif(params.verbose) {\n\t\t\tSystem.out.println(\"(total \" + ((System.nanoTime() - tt0) / 1000000)+\"ms)\");\n\t\t}\n\t\t\n\t\tif(code != 0) {\n\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t\treturn code;\n\t\t}\n\t\t\n\t\treturn 0;\n\t\t\n\t}\n\n\tvoid initCompiler(AbstractCompiler compiler) {\n\t\tcompiler.reset();\n\t\t\n\t\tif(params.debug) compiler.setDebugEnabled();\n\t\tcompiler.addIncludePath(new File(params.distLocation, \"libs/headers/\").getPath());\n\t\tcompiler.addIncludePath(params.outPath.getPath());\n\t\t\n\t\tfor(String compilerArg: compilerArgs) {\n\t\t\tcompiler.addObjectFile(compilerArg);\n\t\t}\n\t}\n\n\tprivate HashSet<Module> collectDeps(Module module, HashSet<Module> toCompile) {\n\t\t\n\t\ttoCompile.add(module);\n\t\t\n\t\tfor(Import import1: module.getImports()) {\n\t\t\tif(toCompile.contains(import1.getModule())) continue;\n\t\t\tcollectDeps(import1.getModule(), toCompile);\n\t\t}\n\t\t\n\t\treturn toCompile;\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.drivers;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.ooc.frontend.Target;\nimport org.ooc.frontend.compilers.AbstractCompiler;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Module;\n\npublic class SequenceDriver extends Driver {\n\n\tint finalCode;\n\tint count;\n\t\n\t@Override\n\tpublic int compile(Module module) throws Error, IOException, InterruptedException {\n\t\t\n\t\tcopyLocalHeaders(module, params, new HashSet<Module>());\n\t\t\n\t\tHashSet<Module> toCompile = collectDeps(module, new HashSet<Module>());\n\t\t\n\t\tfinal ArrayList<String> oPaths = new ArrayList<String> ();\n\t\tfinal long tt0 = System.nanoTime(); \n\t\tfinal Iterator<Module> iterator = toCompile.iterator();\n\t\t// since we have several worker threads, we have to us an AtomicInteger\n\t\tfinal AtomicInteger count = new AtomicInteger(toCompile.size());\t\t\n\t\t\n\t\tfinalCode = 0;\n\t\n\t\tRunnable runnable = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\t\n\t\t\t\tAbstractCompiler compiler = params.compiler.clone();\n\t\t\t\t\n\t\t\t\twhile(iterator.hasNext()) {\n\t\t\t\t\t\n\t\t\t\t\tModule currentModule = null;\n\t\t\t\t\t\n\t\t\t\t\tsynchronized(iterator) {\n\t\t\t\t\t\tcurrentModule = iterator.next();\n\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tinitCompiler(compiler);\n\t\t\t\t\tcompiler.setCompileOnly();\n\t\t\t\t\t\n\t\t\t\t\tString path = new File(params.outPath, currentModule.getPath(\"\")).getPath();\n\t\t\t\t\tString oPath = path + \".o\";\n\t\t\t\t\tString cPath = path + \".c\";\n\t\t\t\t\toPaths.add(oPath);\n\t\t\t\t\t\n\t\t\t\t\tif(new File(cPath).lastModified() > new File(oPath).lastModified()) {\n\t\t\t\t\t\n\t\t\t\t\t\tcompiler.addObjectFile(cPath);\n\t\t\t\t\t\tcompiler.setOutputPath(oPath);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(params.verbose) System.out.print(compiler.getCommandLine());\n\t\t\t\t\t\t\n\t\t\t\t\t\tlong tt1 = System.nanoTime();\n\t\t\t\t\t\tint code = -1;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcode = compiler.launch();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong tt2 = System.nanoTime();\n\t\t\t\t\t\tif(params.verbose) System.out.println(\"  (\" + ((tt2 - tt1) / 1000000)+\"ms)\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(code != 0) {\n\t\t\t\t\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t\t\t\t\t\tfinalCode = code;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(params.verbose)\n\t\t\t\t\t\t\tSystem.out.println(\"Skipping \"+cPath+\", just the same.\");\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tsynchronized(iterator) {\n\t\t\t\t\t\tcount.decrementAndGet();\n\t\t\t\t\t}\n\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t};\n\t\t\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tnew Thread(runnable).start();\n\t\t}\n\t\t\n\t\twhile(count.get() > 0) {\n\t\t\tThread.sleep(100L);\n\t\t}\n\t\t\n\t\tif(params.link) {\n\t\t\t\n\t\t\tinitCompiler(params.compiler);\n\t\t\t\n\t\t\tfor(String oPath: oPaths) {\n\t\t\t\tparams.compiler.addObjectFile(oPath);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String dynamicLib: params.dynamicLibs) {\n\t\t\t\tparams.compiler.addDynamicLibrary(dynamicLib);\n\t\t\t}\n\t\t\tfor(String additional: additionals) {\n\t\t\t\tparams.compiler.addObjectFile(additional);\n\t\t\t}\n\t\t\t\n\t\t\tparams.compiler.setOutputPath(module.getSimpleName());\n\t\t\tCollection<String> libs = getFlagsFromUse(module);\n\t\t\tfor(String lib: libs) params.compiler.addObjectFile(lib);\n\t\t\t\n\t\t\tif(params.enableGC) {\n\t\t\t\tparams.compiler.addDynamicLibrary(\"pthread\");\n\t\t\t\tif(params.dynGC) {\n\t\t\t\t\tparams.compiler.addDynamicLibrary(\"gc\");\n\t\t\t\t} else {\n\t\t\t\t\tparams.compiler.addObjectFile(new File(params.distLocation, \"libs/\"\n\t\t\t\t\t\t\t+ Target.guessHost().toString(params.arch.equals(\"\") ? Target.getArch() : params.arch) + \"/libgc.a\").getPath());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(params.verbose) System.out.println(params.compiler.getCommandLine());\n\n\t\tlong tt1 = System.nanoTime();\n\t\tint code = params.compiler.launch();\n\t\tlong tt2 = System.nanoTime();\n\t\tif(params.verbose) System.out.println(\"  (linking \" + ((tt2 - tt1) / 1000000)+\"ms)\");\n\t\t\n\t\tif(params.verbose) {\n\t\t\tSystem.out.println(\"(total \" + ((System.nanoTime() - tt0) / 1000000)+\"ms)\");\n\t\t}\n\t\t\n\t\tif(code != 0) {\n\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t\treturn code;\n\t\t}\n\t\t\n\t\treturn 0;\n\t\t\n\t}\n\n\tvoid initCompiler(AbstractCompiler compiler) {\n\t\tcompiler.reset();\n\t\t\n\t\tif(params.debug) compiler.setDebugEnabled();\n\t\tcompiler.addIncludePath(new File(params.distLocation, \"libs/headers/\").getPath());\n\t\tcompiler.addIncludePath(params.outPath.getPath());\n\t\t\n\t\tfor(String compilerArg: compilerArgs) {\n\t\t\tcompiler.addObjectFile(compilerArg);\n\t\t}\n\t}\n\n\tprivate HashSet<Module> collectDeps(Module module, HashSet<Module> toCompile) {\n\t\t\n\t\ttoCompile.add(module);\n\t\t\n\t\tfor(Import import1: module.getImports()) {\n\t\t\tif(toCompile.contains(import1.getModule())) continue;\n\t\t\tcollectDeps(import1.getModule(), toCompile);\n\t\t}\n\t\t\n\t\treturn toCompile;\n\t\t\n\t}\n\t\n}\n","lineNo":55}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Type extends Node implements MustBeResolved {\n\n\tpublic static class Classification {\n\t\tpublic static final int POINTER = 1;\n\t\tpublic static final int NUMBER = 2;\n\t\tpublic static final int CLASS = 4;\n\t}\n\n\tprotected String name;\n\tprotected int pointerLevel;\n\tprotected int referenceLevel;\n\tprivate Declaration ref;\n\t\n\tprivate boolean isArray = false;\n\tprivate Expression arraySize = null;\n\t\n\tprotected NodeList<Access> typeParams;\n\tprivate boolean isConst = false;\n\t\n\tprivate static Type voidType = null;\n\t\n\tpublic static Type getVoid() {\n\t\tif(voidType == null) {\n\t\t\tvoidType = new Type(\"Void\", Token.defaultToken);\n\t\t}\n\t\treturn voidType;\n\t}\n\t\n\tpublic Type(String name, Token startToken) {\n\t\tthis(name, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, Token startToken) {\n\t\tthis(name, pointerLevel, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, int referenceLevel, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.pointerLevel = pointerLevel;\n\t\tthis.referenceLevel = referenceLevel;\n\t\tthis.typeParams = new NodeList<Access>(startToken);\n\t}\n\t\n\tpublic NodeList<Access> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void setPointerLevel(int pointerLevel) {\n\t\tthis.pointerLevel = pointerLevel;\n\t}\n\n\tpublic int getPointerLevel() {\n\t\treturn pointerLevel;\n\t}\n\t\n\tpublic void setReferenceLevel(int referenceLevel) {\n\t\tthis.referenceLevel = referenceLevel;\n\t}\n\t\n\tpublic int getReferenceLevel() {\n\t\treturn referenceLevel;\n\t}\n\t\n\tpublic Declaration getRef() {\n\t\treturn ref;\n\t}\n\t\n\tpublic void setRef(Declaration ref) {\n\t\tthis.ref = ref;\n\t}\n\t\n\tpublic boolean isConst() {\n\t\treturn isConst;\n\t}\n\t\n\tpublic void setConst(boolean isConst) {\n\t\tthis.isConst = isConst;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif(arraySize != null) arraySize.accept(visitor);\n\t\ttypeParams.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(isConst) sb.append(\"const \");\n\t\tsb.append(name);\n\t\t\n\t\tfor(int i = 0; i < pointerLevel; i++) {\n\t\t\tif(isArray) sb.append(\"[]\");\n\t\t\telse sb.append('*');\n\t\t}\n\t\tfor(int i = 0; i < referenceLevel; i++) {\n\t\t\tsb.append('@');\n\t\t}\n\t\tif(!typeParams.isEmpty()) {\n\t\t\tsb.append('<');\n\t\t\tIterator<Access> iter = typeParams.iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tAccess element = iter.next();\n\t\t\t\tif(element instanceof VariableAccess) {\n\t\t\t\t\tsb.append(((VariableAccess) element).getName());\n\t\t\t\t} else if(element instanceof FunctionCall) {\n\t\t\t\t\tsb.append(((FunctionCall) element).getName());\n\t\t\t\t}\n\t\t\t\tif(iter.hasNext()) sb.append(\", \");\n\t\t\t}\n\t\t\tsb.append('>');\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t\t\n\t}\n\t\n\tpublic String getMangledName() {\n\t\t\n\t\tif(pointerLevel == 0) {\n\t\t\treturn name;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(name);\n\t\tfor(int i = 0; i < pointerLevel + referenceLevel; i++) {\n\t\t\tsb.append(\"__star\");\n\t\t}\n\t\treturn sb.toString();\n\t\t\n\t}\n\n\tpublic boolean isVoid() {\n\t\treturn (name.equals(\"void\") || name.equals(\"Void\")) && isFlat();\n\t}\n\n\tpublic boolean isFlat() {\n\t\treturn pointerLevel == 0 && referenceLevel == 0 && !(ref instanceof ClassDecl);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == ref) {\n\t\t\tref = (Declaration) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif(obj instanceof Type) {\n\t\t\tType type = (Type) obj;\n\t\t\treturn name.equals(type.name) && pointerLevel == type.getPointerLevel();\n\t\t}\n\t\treturn super.equals(obj);\n\t}\n\t\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(name.equals(\"Func\")) {\n\t\t\tFuncType newType = new FuncType(startToken);\n\t\t\tnewType.setPointerLevel(pointerLevel);\n\t\t\tnewType.setReferenceLevel(referenceLevel);\n\t\t\tnewType.setArray(isArray);\n\t\t\tnewType.setArraySize(arraySize);\n\t\t\tif(!stack.peek().replace(this, newType)) {\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace \"\n\t\t\t\t\t\t+this+\" with \"+newType+\" in \"+stack.peek());\n\t\t\t}\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref != null) return Response.OK;\n\t\t\n\t\tref = stack.getModule().getType(name);\n\n\t\tif(ref == null && name.equals(\"This\")) {\n\t\t\tint index = stack.find(TypeDecl.class);\n\t\t\tif(index == -1) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Using 'This' outside a type definition is meaningless.\");\n\t\t\t}\n\t\t\tTypeDecl typeDecl = (TypeDecl) stack.get(index);\n\t\t\tname = typeDecl.getName();\n\t\t\tref = typeDecl;\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref == null) {\n\t\t\tTypeParam param = getTypeParam(stack, name);\n\t\t\tif(param != null) {\n\t\t\t\tref = param;\n\t\t\t\treturn Response.OK;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ref == null && fatal) {\n\t\t\tif(res.params.veryVerbose) {\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type \"\n\t\t\t\t\t+getName()+\", btw, stack = \"+stack.toString(true));\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type \"\n\t\t\t\t\t+getName());\n\t\t}\n\t\t\n\t\treturn (ref == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn ref != null;\n\t}\n\t\n\tpublic void setArray(boolean isArray) {\n\t\tthis.isArray = isArray;\n\t}\n\t\n\tpublic boolean isArray() {\n\t\treturn isArray;\n\t}\n\t\n\tpublic Type getGroundType() {\n\t\treturn getGroundType(null);\n\t}\n\t\n\tpublic Type getGroundType(Resolver res) {\n\t\tif(ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) ref;\n\t\t\tif(coverDecl.getFromType() != null && !name.equals(coverDecl.getFromType().getName())) {\n\t\t\t\tType rawType = coverDecl.getFromType().getGroundType(res);\n\t\t\t\tType groundType = new Type(rawType.name, pointerLevel, referenceLevel, rawType.startToken);\n\t\t\t\tif(res == null) {\n\t\t\t\t\tgroundType.ref = ref;\n\t\t\t\t} else {\n\t\t\t\t\tgroundType.resolve(res);\n\t\t\t\t}\n\t\t\t\treturn groundType;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tpublic Type getFlatType(Resolver res) {\n\t\tType returnType = this;\n\t\twhile(returnType.ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) returnType.ref;\n\t\t\tType fromType = coverDecl.getFromType();\n\t\t\tif(fromType == null) break;\n\t\t\tif(fromType.referenceLevel <= 0) break;\n\t\t\t\n\t\t\treturnType = new Type(fromType.name, fromType.pointerLevel - 1,\n\t\t\t\t\treturnType.referenceLevel - 1, fromType.startToken);\n\t\t\treturnType.resolve(res);\n\t\t}\n\t\t\n\t\treturn returnType;\n\t}\n\n\tpublic boolean fitsIn(Type innerType) {\n\t\tif (equals(innerType)) return true;\n\t\tif (getClassification() == innerType.getClassification()) return true;\n\t\treturn false;\n\t}\n\t\n\tpublic int getClassification() {\n\t\tif(!isFlat()) return Classification.POINTER;\n\t\t\n\t\tif(name.equals(\"Int\")   || name.equals(\"UInt\")  || name.equals(\"Short\")\n\t\t|| name.equals(\"UShort\")|| name.equals(\"Long\")  || name.equals(\"ULong\")\n\t\t|| name.equals(\"LLong\") || name.equals(\"ULLong\")|| name.equals(\"Char\")\n\t\t|| name.equals(\"UChar\") || name.equals(\"Int8\")  || name.equals(\"Int16\")\n\t\t|| name.equals(\"Int32\") || name.equals(\"Int64\") || name.equals(\"UInt8\")\n\t\t|| name.equals(\"UInt16\")|| name.equals(\"UInt32\")|| name.equals(\"UInt64\")\n\t\t|| name.equals(\"SizeT\")\n\t\t) return Classification.NUMBER;\n\t\t\n\t\treturn Classification.CLASS;\n\t}\n\n\tpublic void resolve(Resolver res) {\n\t\tref = res.module.getType(name);\n\t}\n\n\tpublic boolean isSuperOf(Type type) {\n\t\tif(type == null) return false;\n\t\tif(this.equals(type)) return false;\n\t\tif(name.length() == 0 || type.name.length() == 0) return false;\n\t\t\n\t\tif(type.getRef() instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) type.getRef();\n\t\t\tif(typeDecl.getSuperRef() != null) {\n\t\t\t\tType superType = typeDecl.getSuperRef().getType();\n\t\t\t\tif(superType.getName().equals(this.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn isSuperOf(superType);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String getHierarchyRepr() {\n\t\tString repr = name;\n\t\tType t = this;\n\t\twhile(t.ref != null) {\n\t\t\tif(!(t.ref instanceof TypeDecl)) break;\n\t\t\tTypeDecl typeDecl = (TypeDecl) t.ref;\n\t\t\tif(typeDecl.getSuperRef() == null) break;\n\t\t\tt = typeDecl.getSuperRef().getType();\n\t\t\trepr += \":\" + t;\n\t\t}\n\t\treturn repr;\n\t}\n\n\t@Override\n\tpublic Type clone() {\n\t\tType clone = new Type(name, pointerLevel, referenceLevel, startToken);\n\t\tclone.ref = ref;\n\t\tclone.isArray = isArray;\n\t\tclone.isConst = isConst;\n\t\tclone.typeParams.addAll(typeParams);\n\t\treturn clone;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn ref instanceof TypeParam;\n\t}\n\t\n\tpublic boolean isGenericRecursive() {\n\t\treturn (ref instanceof TypeParam) || !typeParams.isEmpty();\n\t}\n\n\tpublic Expression getArraySize() {\n\t\treturn arraySize;\n\t}\n\n\tpublic void setArraySize(Expression arraySize) {\n\t\tthis.arraySize = arraySize;\n\t}\n\n\tpublic boolean softEquals(Type type, Resolver res) {\n\t\tif(type == null) return false;\n\t\tresolve(res);\n\t\tif(equals(type)) {\n\t\t\treturn true;\n\t\t}\n\t\tDeclaration ref = type.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tif(typeDecl.getSuperType() != null) {\n\t\t\t\tType subType = typeDecl.getSuperType();\n\t\t\t\treturn softEquals(subType, res);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic boolean isPrefixed() {\n\t\n\t\treturn (ref instanceof ClassDecl || (ref instanceof CoverDecl && !((CoverDecl) ref).isExtern()));\n\t\t\n\t}\n\n\tpublic String getUnderName() {\n\t\t\n\t\tif(isPrefixed()) return ((TypeDecl) ref).getUnderName();\n\t\treturn getName();\n\t\t\n\t}\n\n\tpublic Type dereference() {\n\t\tType clone = clone();\n\t\tclone.setPointerLevel(getPointerLevel() - 1);\n\t\treturn clone;\n\t}\n\t\n}\n\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Type extends Node implements MustBeResolved {\n\n\tpublic static class Classification {\n\t\tpublic static final int POINTER = 1;\n\t\tpublic static final int NUMBER = 2;\n\t\tpublic static final int CLASS = 4;\n\t}\n\n\tprotected String name;\n\tprotected int pointerLevel;\n\tprotected int referenceLevel;\n\tprivate Declaration ref;\n\t\n\tprivate boolean isArray = false;\n\tprivate Expression arraySize = null;\n\t\n\tprotected NodeList<Access> typeParams;\n\tprivate boolean isConst = false;\n\t\n\tprivate static Type voidType = null;\n\t\n\tpublic static Type getVoid() {\n\t\tif(voidType == null) {\n\t\t\tvoidType = new Type(\"Void\", Token.defaultToken);\n\t\t}\n\t\treturn voidType;\n\t}\n\t\n\tpublic Type(String name, Token startToken) {\n\t\tthis(name, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, Token startToken) {\n\t\tthis(name, pointerLevel, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, int referenceLevel, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.pointerLevel = pointerLevel;\n\t\tthis.referenceLevel = referenceLevel;\n\t\tthis.typeParams = new NodeList<Access>(startToken);\n\t}\n\t\n\tpublic NodeList<Access> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void setPointerLevel(int pointerLevel) {\n\t\tthis.pointerLevel = pointerLevel;\n\t}\n\n\tpublic int getPointerLevel() {\n\t\treturn pointerLevel;\n\t}\n\t\n\tpublic void setReferenceLevel(int referenceLevel) {\n\t\tthis.referenceLevel = referenceLevel;\n\t}\n\t\n\tpublic int getReferenceLevel() {\n\t\treturn referenceLevel;\n\t}\n\t\n\tpublic Declaration getRef() {\n\t\treturn ref;\n\t}\n\t\n\tpublic void setRef(Declaration ref) {\n\t\tthis.ref = ref;\n\t}\n\t\n\tpublic boolean isConst() {\n\t\treturn isConst;\n\t}\n\t\n\tpublic void setConst(boolean isConst) {\n\t\tthis.isConst = isConst;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif(arraySize != null) arraySize.accept(visitor);\n\t\ttypeParams.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(isConst) sb.append(\"const \");\n\t\tsb.append(name);\n\t\t\n\t\tfor(int i = 0; i < pointerLevel; i++) {\n\t\t\tif(isArray) sb.append(\"[]\");\n\t\t\telse sb.append('*');\n\t\t}\n\t\tfor(int i = 0; i < referenceLevel; i++) {\n\t\t\tsb.append('@');\n\t\t}\n\t\tif(!typeParams.isEmpty()) {\n\t\t\tsb.append('<');\n\t\t\tIterator<Access> iter = typeParams.iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tAccess element = iter.next();\n\t\t\t\tif(element instanceof VariableAccess) {\n\t\t\t\t\tsb.append(((VariableAccess) element).getName());\n\t\t\t\t} else if(element instanceof FunctionCall) {\n\t\t\t\t\tsb.append(((FunctionCall) element).getName());\n\t\t\t\t}\n\t\t\t\tif(iter.hasNext()) sb.append(\", \");\n\t\t\t}\n\t\t\tsb.append('>');\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t\t\n\t}\n\t\n\tpublic String getMangledName() {\n\t\t\n\t\tif(pointerLevel == 0) {\n\t\t\treturn name;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(name);\n\t\tfor(int i = 0; i < pointerLevel + referenceLevel; i++) {\n\t\t\tsb.append(\"__star\");\n\t\t}\n\t\treturn sb.toString();\n\t\t\n\t}\n\n\tpublic boolean isVoid() {\n\t\treturn (name.equals(\"void\") || name.equals(\"Void\")) && isFlat();\n\t}\n\n\tpublic boolean isFlat() {\n\t\treturn pointerLevel == 0 && referenceLevel == 0 && !(ref instanceof ClassDecl);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == ref) {\n\t\t\tref = (Declaration) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif(obj instanceof Type) {\n\t\t\tType type = (Type) obj;\n\t\t\tboolean result = name.equals(type.name) && pointerLevel == type.getPointerLevel();\n\t\t\treturn result;\n\t\t}\n\t\treturn super.equals(obj);\n\t}\n\t\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(name.equals(\"Func\")) {\n\t\t\tFuncType newType = new FuncType(startToken);\n\t\t\tnewType.setPointerLevel(pointerLevel);\n\t\t\tnewType.setReferenceLevel(referenceLevel);\n\t\t\tnewType.setArray(isArray);\n\t\t\tnewType.setArraySize(arraySize);\n\t\t\tif(!stack.peek().replace(this, newType)) {\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace \"\n\t\t\t\t\t\t+this+\" with \"+newType+\" in \"+stack.peek());\n\t\t\t}\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref != null) return Response.OK;\n\t\t\n\t\tref = stack.getModule().getType(name);\n\n\t\tif(ref == null && name.equals(\"This\")) {\n\t\t\tint index = stack.find(TypeDecl.class);\n\t\t\tif(index == -1) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Using 'This' outside a type definition is meaningless.\");\n\t\t\t}\n\t\t\tTypeDecl typeDecl = (TypeDecl) stack.get(index);\n\t\t\tname = typeDecl.getName();\n\t\t\tref = typeDecl;\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref == null) {\n\t\t\tTypeParam param = getTypeParam(stack, name);\n\t\t\tif(param != null) {\n\t\t\t\tref = param;\n\t\t\t\treturn Response.OK;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ref == null && fatal) {\n\t\t\tif(res.params.veryVerbose) {\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type \"\n\t\t\t\t\t+getName()+\", btw, stack = \"+stack.toString(true));\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type \"\n\t\t\t\t\t+getName());\n\t\t}\n\t\t\n\t\treturn (ref == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn ref != null;\n\t}\n\t\n\tpublic void setArray(boolean isArray) {\n\t\tthis.isArray = isArray;\n\t}\n\t\n\tpublic boolean isArray() {\n\t\treturn isArray;\n\t}\n\t\n\tpublic Type getGroundType() {\n\t\treturn getGroundType(null);\n\t}\n\t\n\tpublic Type getGroundType(Resolver res) {\n\t\tif(ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) ref;\n\t\t\tif(coverDecl.getFromType() != null && !name.equals(coverDecl.getFromType().getName())) {\n\t\t\t\tType rawType = coverDecl.getFromType().getGroundType(res);\n\t\t\t\tType groundType = new Type(rawType.name, pointerLevel, referenceLevel, rawType.startToken);\n\t\t\t\tif(res == null) {\n\t\t\t\t\tgroundType.ref = ref;\n\t\t\t\t} else {\n\t\t\t\t\tgroundType.resolve(res);\n\t\t\t\t}\n\t\t\t\treturn groundType;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tpublic Type getFlatType(Resolver res) {\n\t\tType returnType = this;\n\t\twhile(returnType.ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) returnType.ref;\n\t\t\tType fromType = coverDecl.getFromType();\n\t\t\tif(fromType == null) break;\n\t\t\tif(fromType.referenceLevel <= 0) break;\n\t\t\t\n\t\t\treturnType = new Type(fromType.name, fromType.pointerLevel - 1,\n\t\t\t\t\treturnType.referenceLevel - 1, fromType.startToken);\n\t\t\treturnType.resolve(res);\n\t\t}\n\t\t\n\t\treturn returnType;\n\t}\n\n\tpublic boolean fitsIn(Type innerType) {\n\t\tif (equals(innerType)) return true;\n\t\tif (getClassification() == innerType.getClassification()) return true;\n\t\treturn false;\n\t}\n\t\n\tpublic int getClassification() {\n\t\tif(!isFlat()) return Classification.POINTER;\n\t\t\n\t\tif(name.equals(\"Int\")   || name.equals(\"UInt\")  || name.equals(\"Short\")\n\t\t|| name.equals(\"UShort\")|| name.equals(\"Long\")  || name.equals(\"ULong\")\n\t\t|| name.equals(\"LLong\") || name.equals(\"ULLong\")|| name.equals(\"Char\")\n\t\t|| name.equals(\"UChar\") || name.equals(\"Int8\")  || name.equals(\"Int16\")\n\t\t|| name.equals(\"Int32\") || name.equals(\"Int64\") || name.equals(\"UInt8\")\n\t\t|| name.equals(\"UInt16\")|| name.equals(\"UInt32\")|| name.equals(\"UInt64\")\n\t\t|| name.equals(\"SizeT\")\n\t\t) return Classification.NUMBER;\n\t\t\n\t\treturn Classification.CLASS;\n\t}\n\n\tpublic void resolve(Resolver res) {\n\t\tref = res.module.getType(name);\n\t}\n\n\tpublic boolean isSuperOf(Type type) {\n\t\tif(type == null) return false;\n\t\tif(this.equals(type)) return false;\n\t\tif(name.length() == 0 || type.name.length() == 0) return false;\n\t\t\n\t\tif(type.getRef() instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) type.getRef();\n\t\t\tif(typeDecl.getSuperRef() != null) {\n\t\t\t\tType superType = typeDecl.getSuperRef().getType();\n\t\t\t\tif(superType.getName().equals(this.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn isSuperOf(superType);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String getHierarchyRepr() {\n\t\tString repr = name;\n\t\tType t = this;\n\t\twhile(t.ref != null) {\n\t\t\tif(!(t.ref instanceof TypeDecl)) break;\n\t\t\tTypeDecl typeDecl = (TypeDecl) t.ref;\n\t\t\tif(typeDecl.getSuperRef() == null) break;\n\t\t\tt = typeDecl.getSuperRef().getType();\n\t\t\trepr += \":\" + t;\n\t\t}\n\t\treturn repr;\n\t}\n\n\t@Override\n\tpublic Type clone() {\n\t\tType clone = new Type(name, pointerLevel, referenceLevel, startToken);\n\t\tclone.ref = ref;\n\t\tclone.isArray = isArray;\n\t\tclone.isConst = isConst;\n\t\tclone.typeParams.addAll(typeParams);\n\t\treturn clone;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn ref instanceof TypeParam;\n\t}\n\t\n\tpublic boolean isGenericRecursive() {\n\t\treturn (ref instanceof TypeParam) || !typeParams.isEmpty();\n\t}\n\n\tpublic Expression getArraySize() {\n\t\treturn arraySize;\n\t}\n\n\tpublic void setArraySize(Expression arraySize) {\n\t\tthis.arraySize = arraySize;\n\t}\n\n\tpublic boolean softEquals(Type type, Resolver res) {\n\t\tif(type == null) return false;\n\t\tresolve(res);\n\t\tif(equals(type)) {\n\t\t\treturn true;\n\t\t}\n\t\tDeclaration ref = type.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tif(typeDecl.getSuperType() != null) {\n\t\t\t\tType subType = typeDecl.getSuperType();\n\t\t\t\treturn softEquals(subType, res);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic boolean isPrefixed() {\n\t\n\t\treturn (ref instanceof ClassDecl || (ref instanceof CoverDecl && !((CoverDecl) ref).isExtern()));\n\t\t\n\t}\n\n\tpublic String getUnderName() {\n\t\t\n\t\tif(isPrefixed()) return ((TypeDecl) ref).getUnderName();\n\t\treturn getName();\n\t\t\n\t}\n\n\tpublic Type dereference() {\n\t\tType clone = clone();\n\t\tclone.setPointerLevel(getPointerLevel() - 1);\n\t\treturn clone;\n\t}\n\t\n}\n\n","lineNo":183}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.backend.Generator;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ArrayLiteral;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.Block;\nimport org.ooc.frontend.model.BoolLiteral;\nimport org.ooc.frontend.model.BuiltinType;\nimport org.ooc.frontend.model.Case;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.CharLiteral;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Else;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FloatLiteral;\nimport org.ooc.frontend.model.FlowControl;\nimport org.ooc.frontend.model.Foreach;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.If;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.InterfaceDecl;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberArgument;\nimport org.ooc.frontend.model.MemberAssignArgument;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.NullLiteral;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.RegularArgument;\nimport org.ooc.frontend.model.Return;\nimport org.ooc.frontend.model.StringLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.ValuedReturn;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.While;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.TypeArgument;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ubi.SourceReader;\n\npublic class CGenerator extends Generator implements Visitor {\n\n\tpublic final AwesomeWriter hw;\n\tpublic final AwesomeWriter cw;\n\tpublic AwesomeWriter current;\n\tpublic BuildParams params;\n\n\tpublic CGenerator(File outPath, Module module) throws IOException {\n\t\tsuper(outPath, module);\n\t\tString basePath = module.getOutPath();\n\t\tFile hFile = new File(outPath, basePath + \".h\");\n\t\thFile.getParentFile().mkdirs();\n\t\tthis.hw = new AwesomeWriter(new FileWriter(hFile));\n\t\tFile cFile = new File(outPath, basePath + \".c\");\n\t\tthis.cw = new AwesomeWriter(new FileWriter(cFile));\n\t\tthis.current = hw;\n\t}\n\n\t@Override\n\tpublic void generate(BuildParams params) throws IOException {\n\t\tthis.params = params;\n\t\tmodule.accept(this);\n\t\thw.close();\n\t\tcw.close();\n\t}\n\n\tpublic void visit(Module module) throws IOException {\n\t\tModuleWriter.write(module, this);\n\t}\n\n\tpublic void visit(Add add) throws IOException {\n\t\tadd.getLeft().accept(this);\n\t\tcurrent.app(\" + \");\n\t\tadd.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Mul mul) throws IOException {\n\t\tmul.getLeft().accept(this);\n\t\tcurrent.app(\" * \");\n\t\tmul.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Sub sub) throws IOException {\n\t\tsub.getLeft().accept(this);\n\t\tcurrent.app(\" - \");\n\t\tsub.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Div div) throws IOException {\n\t\tdiv.getLeft().accept(this);\n\t\tcurrent.app(\" / \");\n\t\tdiv.getRight().accept(this);\n\t}\n\n\tpublic void visit(Not not) throws IOException {\n\t\tcurrent.app('!');\n\t\tnot.getExpression().accept(this);\t\t\n\t}\n\t\n\tpublic void visit(Mod mod) throws IOException {\n\t\tmod.getLeft().accept(this);\n\t\tcurrent.app(\" % \");\n\t\tmod.getRight().accept(this);\n\t}\n\t\n\tpublic void visit(Compare compare) throws IOException {\n\t\tcompare.getLeft().accept(this);\n\t\tswitch(compare.getCompareType()) {\n\t\t\tcase GREATER: current.app(\" > \"); break;\n\t\t\tcase GREATER_OR_EQUAL: current.app(\" >= \"); break;\n\t\t\tcase LESSER: current.app(\" < \"); break;\n\t\t\tcase LESSER_OR_EQUAL: current.app(\" <= \"); break;\n\t\t\tcase EQUAL: current.app(\" == \"); break;\n\t\t\tcase NOT_EQUAL: current.app(\" != \"); break;\n\t\t}\n\t\tcompare.getRight().accept(this);\n\t}\n\n\tpublic void visit(FunctionCall functionCall) throws IOException {\n\t\tCallWriter.write(functionCall, this);\n\t}\n\n\tpublic void visit(MemberCall memberCall) throws IOException {\n\t\tCallWriter.writeMember(memberCall, this);\n\t}\n\n\tpublic void visit(Parenthesis parenthesis) throws IOException {\n\t\tcurrent.app('(');\n\t\tparenthesis.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Assignment assignment) throws IOException {\n\t\tExpression left = assignment.getLeft();\n\t\tif(left instanceof VariableAccess) {\n\t\t\tAccessWriter.write((VariableAccess) left, false, this);\n\t\t} else {\n\t\t\tleft.accept(this);\n\t\t}\n\t\tcurrent.app(' ').app(assignment.getSymbol()).app(' ');\n\t\tassignment.getRight().accept(this);\n\t}\n\n\tpublic void visit(ValuedReturn return1) throws IOException {\n\t\tcurrent.app(\"return \");\n\t\treturn1.getExpression().accept(this);\n\t}\n\t\n\tpublic void visit(Return return1) throws IOException {\n\t\tcurrent.app(\"return\");\n\t}\n\n\tpublic void visit(NullLiteral nullLiteral) throws IOException {\n\t\tLiteralWriter.writeNull(this);\n\t}\n\n\tpublic void visit(IntLiteral numberLiteral) throws IOException {\n\t\tLiteralWriter.writeInt(numberLiteral, this);\n\t}\n\t\n\tpublic void visit(FloatLiteral floatLiteral) throws IOException {\n\t\tLiteralWriter.writeFloat(floatLiteral, this);\n\t}\n\n\tpublic void visit(StringLiteral stringLiteral) throws IOException {\n\t\tLiteralWriter.writeString(stringLiteral, this);\n\t}\n\n\tpublic void visit(RangeLiteral rangeLiteral) throws IOException {\n\t\tthrow new OocCompilationError(rangeLiteral, module,\n\t\t\t\t\"Using a range literal outside a foreach is not supported yet.\");\n\t}\n\n\tpublic void visit(BoolLiteral boolLiteral) throws IOException {\n\t\tcurrent.app(boolLiteral.getValue() ? \"true\" : \"false\");\n\t}\n\n\tpublic void visit(CharLiteral charLiteral) throws IOException {\n\t\tcurrent.app('\\'').app(SourceReader.spelled(charLiteral.getValue())).app('\\'');\t\t\n\t}\n\n\tpublic void visit(Line line) throws IOException {\n\t\tcurrent.nl();\n\t\tif(line.getStatement() instanceof FunctionCall) CallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\tline.getStatement().accept(this);\n\t\tif(!(line.getStatement() instanceof ControlStatement)) {\n\t\t\tcurrent.app(';');\n\t\t}\n\t}\n\n\tpublic void visit(Include include) throws IOException {}\n\n\tpublic void visit(If if1) throws IOException {\n\t\tControlStatementWriter.writeIf(if1, this);\n\t}\n\t\n\tpublic void visit(Else else1) throws IOException {\n\t\tControlStatementWriter.writeElse(else1, this);\n\t}\n\n\tpublic void visit(While while1) throws IOException {\n\t\tControlStatementWriter.writeWhile(while1, this);\n\t}\n\n\tpublic void visit(Foreach foreach) throws IOException {\n\t\tControlStatementWriter.writeForeach(foreach, this);\n\t}\n\n\tpublic void visit(MemberAccess memberAccess) throws IOException {\n\t\tAccessWriter.writeMember(memberAccess, this);\n\t}\n\t\n\tpublic void visit(VariableAccess variableAccess) throws IOException {\n\t\tAccessWriter.writeVariable(variableAccess, true, this);\n\t}\n\n\tpublic void visit(ArrayAccess arrayAccess) throws IOException {\n\t\tAccessWriter.writeArray(arrayAccess, this);\n\t}\n\n\tpublic void visit(VariableDecl variableDecl) throws IOException {\n\t\tVariableDeclWriter.write(variableDecl, this);\n\t}\n\n\tpublic void visit(FunctionDecl functionDecl) throws IOException {\n\t\tFunctionDeclWriter.write(functionDecl, this);\n\t}\n\n\tpublic void visit(ClassDecl classDecl) throws IOException {\n\t\tClassDeclWriter.write(classDecl, this);\n\t}\n\t\n\tpublic void visit(CoverDecl cover) throws IOException {\n\t\tCoverDeclWriter.write(cover, this);\n\t}\n\t\n\tpublic void visit(TypeArgument typeArgument) throws IOException {\n\t\ttypeArgument.getType().accept(this);\n\t}\n\n\tpublic void visit(RegularArgument regularArgument) throws IOException {\n\t\tType type = regularArgument.getType();\n\t\tif(type.isArray()) {\n\t\t\tcurrent.app(type.getName()).app(' ').app(regularArgument.getName());\n\t\t\tfor(int i = 0; i < type.getPointerLevel(); i++) {\n\t\t\t\tcurrent.app(\"[]\");\n\t\t\t}\n\t\t} else {\n\t\t\tif(type instanceof FuncType) {\n\t\t\t\tTypeWriter.writeFuncPointer((FunctionDecl) type.getRef(), regularArgument.getName(), this);\n\t\t\t} else {\n\t\t\t\tTypeWriter.writeSpaced(type, this);\n\t\t\t\tcurrent.app(regularArgument.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void visit(MemberArgument memberArgument) throws IOException {}\n\n\tpublic void visit(MemberAssignArgument memberArgument) throws IOException {}\n\n\tpublic void visit(Type type) throws IOException {\n\t\tTypeWriter.write(type, this);\n\t}\n\n\tpublic void visit(VarArg varArg) throws IOException {\n\t\tcurrent.app(\"...\");\n\t}\n\t\n\tpublic void visit(NodeList<? extends Node> list) throws IOException {\n\t\tlist.acceptChildren(this);\n\t}\n\t\n\tpublic void visit(Block block) throws IOException {\n\t\tcurrent.openBlock();\n\t\tblock.acceptChildren(this);\n\t\tcurrent.closeBlock();\n\t}\n\n\tpublic void visit(BuiltinType builtinType) throws IOException {}\n\n\tpublic void visit(VariableDeclAtom variableDeclAtom) throws IOException {}\n\t\n\tpublic void visit(Cast cast) throws IOException {\n\t\tCastWriter.write(cast, this);\n\t}\n\n\tpublic void visit(AddressOf addressOf) throws IOException {\n\t\tif(addressOf.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) addressOf.getExpression();\n\t\t\tif(varAcc.getRef().getType().getRef() instanceof TypeParam) {\n\t\t\t\tAccessWriter.write(varAcc, false, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcurrent.app(\"&(\");\n\t\taddressOf.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Dereference dereference) throws IOException {\n\t\tcurrent.app(\"(*\");\n\t\tdereference.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(OpDecl opDecl) throws IOException {\n\t\topDecl.getFunc().accept(this);\n\t}\n\n\tpublic void visit(Import import1) throws IOException {}\n\t\n\tpublic void visit(ArrayLiteral arrayLiteral) throws IOException {\n\t\tcurrent.app('{');\n\t\tIterator<Expression> iter = arrayLiteral.getElements().iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression element = iter.next();\n\t\t\tboolean doCasting = false;\n\t\t\tif(!element.getType().getName().equals(arrayLiteral.getType().getName())) {\n\t\t\t\tdoCasting = true;\n\t\t\t\tcurrent.app(\"((\");\n\t\t\t\tarrayLiteral.getElements().get(0).getType().accept(this);\n\t\t\t\tcurrent.app(\") \");\n\t\t\t}\n\t\t\telement.accept(this);\n\t\t\tif(doCasting) {\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\tif(iter.hasNext()) current.app(\", \");\n\t\t}\n\t\tcurrent.app('}');\n\t}\n\n\tpublic void visit(Use use) throws IOException {}\n\n\tpublic void visit(BinaryCombination binaryCombination) throws IOException {\n\t\tbinaryCombination.getLeft().accept(this);\n\t\tcurrent.app(' ').app(binaryCombination.getOpString()).app(' ');\n\t\tbinaryCombination.getRight().accept(this);\n\t}\n\n\tpublic void visit(MultiMap<?, ?> list) throws IOException {}\n\n\tpublic void visit(FlowControl flow) throws IOException {\n\t\tcurrent.app(flow.getKeyword()).app(\";\");\n\t}\n\n\tpublic void visit(InterfaceDecl interfaceDecl) throws IOException {\n\t\t// huh.. slack off?\n\t}\n\n\tpublic void visit(Ternary ternary) throws IOException {\n\t\tternary.getCondition().accept(this);\n\t\tcurrent.app(\" ? \");\n\t\tternary.getValueIfTrue().accept(this);\n\t\tcurrent.app(\" : \");\n\t\tternary.getValueIfFalse().accept(this);\n\t}\n\n\tpublic void visit(Match match) throws IOException {\n\t\tboolean isFirst = true;\n\t\tfor(Case case1: match.getCases()) {\n\t\t\tif(!isFirst) {\n\t\t\t\tcurrent.app(\" else \");\n\t\t\t}\n\n\t\t\tif(case1.getExpr() == null) {\n\t\t\t\tif(isFirst) current.app(\" else \");\n\t\t\t} else {\n\t\t\t\tif(case1.isFallthrough()) current.app(' ');\n\t\t\t\tcurrent.app(\"if (\");\n\t\t\t\tcase1.getExpr().accept(this);\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.app(\"{\").tab();\n\t\t\t\n\t\t\tint bodySize = case1.getBody().size();\n\t\t\tint index = bodySize;\n\t\t\tfor(Line line: case1.getBody()) {\n\t\t\t\tcurrent.newLine();\n\t\t\t\tif(index == bodySize && match.getVarAcc() != null) {\n\t\t\t\t\tmatch.getVarAcc().accept(this);\n\t\t\t\t\tcurrent.append(\" = \");\n\t\t\t\t}\n\t\t\t\tif(line.getStatement() instanceof FunctionCall) {\n\t\t\t\t\tCallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\t\t\t}\n\t\t\t\tline.getStatement().accept(this);\n\t\t\t\tcurrent.append(\";\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.untab().nl().app(\"}\");\n\t\t\tif(isFirst) isFirst = false;\n\t\t}\n\t}\n\n\tpublic void visit(Case case1) throws IOException {\n\t\t// hmmm... no\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.backend.Generator;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ArrayLiteral;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.Block;\nimport org.ooc.frontend.model.BoolLiteral;\nimport org.ooc.frontend.model.BuiltinType;\nimport org.ooc.frontend.model.Case;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.CharLiteral;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Else;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FloatLiteral;\nimport org.ooc.frontend.model.FlowControl;\nimport org.ooc.frontend.model.Foreach;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.If;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.InterfaceDecl;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.Match;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberArgument;\nimport org.ooc.frontend.model.MemberAssignArgument;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.NullLiteral;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.RegularArgument;\nimport org.ooc.frontend.model.Return;\nimport org.ooc.frontend.model.StringLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Ternary;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.ValuedReturn;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.While;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.TypeArgument;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ubi.SourceReader;\n\npublic class CGenerator extends Generator implements Visitor {\n\n\tpublic final AwesomeWriter hw;\n\tpublic final AwesomeWriter cw;\n\tpublic AwesomeWriter current;\n\tpublic BuildParams params;\n\n\tpublic CGenerator(File outPath, Module module) throws IOException {\n\t\tsuper(outPath, module);\n\t\tString basePath = module.getOutPath();\n\t\tFile hFile = new File(outPath, basePath + \".h\");\n\t\thFile.getParentFile().mkdirs();\n\t\tthis.hw = new AwesomeWriter(new FileWriter(hFile));\n\t\tFile cFile = new File(outPath, basePath + \".c\");\n\t\tthis.cw = new AwesomeWriter(new FileWriter(cFile));\n\t\tthis.current = hw;\n\t}\n\n\t@Override\n\tpublic void generate(BuildParams params) throws IOException {\n\t\tthis.params = params;\n\t\tmodule.accept(this);\n\t\thw.close();\n\t\tcw.close();\n\t}\n\n\tpublic void visit(Module module) throws IOException {\n\t\tModuleWriter.write(module, this);\n\t}\n\n\tpublic void visit(Add add) throws IOException {\n\t\tadd.getLeft().accept(this);\n\t\tcurrent.app(\" + \");\n\t\tadd.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Mul mul) throws IOException {\n\t\tmul.getLeft().accept(this);\n\t\tcurrent.app(\" * \");\n\t\tmul.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Sub sub) throws IOException {\n\t\tsub.getLeft().accept(this);\n\t\tcurrent.app(\" - \");\n\t\tsub.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Div div) throws IOException {\n\t\tdiv.getLeft().accept(this);\n\t\tcurrent.app(\" / \");\n\t\tdiv.getRight().accept(this);\n\t}\n\n\tpublic void visit(Not not) throws IOException {\n\t\tcurrent.app('!');\n\t\tnot.getExpression().accept(this);\t\t\n\t}\n\t\n\tpublic void visit(Mod mod) throws IOException {\n\t\tmod.getLeft().accept(this);\n\t\tcurrent.app(\" % \");\n\t\tmod.getRight().accept(this);\n\t}\n\t\n\tpublic void visit(Compare compare) throws IOException {\n\t\tcompare.getLeft().accept(this);\n\t\tswitch(compare.getCompareType()) {\n\t\t\tcase GREATER: current.app(\" > \"); break;\n\t\t\tcase GREATER_OR_EQUAL: current.app(\" >= \"); break;\n\t\t\tcase LESSER: current.app(\" < \"); break;\n\t\t\tcase LESSER_OR_EQUAL: current.app(\" <= \"); break;\n\t\t\tcase EQUAL: current.app(\" == \"); break;\n\t\t\tcase NOT_EQUAL: current.app(\" != \"); break;\n\t\t}\n\t\tcompare.getRight().accept(this);\n\t}\n\n\tpublic void visit(FunctionCall functionCall) throws IOException {\n\t\tCallWriter.write(functionCall, this);\n\t}\n\n\tpublic void visit(MemberCall memberCall) throws IOException {\n\t\tCallWriter.writeMember(memberCall, this);\n\t}\n\n\tpublic void visit(Parenthesis parenthesis) throws IOException {\n\t\tcurrent.app('(');\n\t\tparenthesis.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Assignment assignment) throws IOException {\n\t\tExpression left = assignment.getLeft();\n\t\tif(left instanceof VariableAccess) {\n\t\t\tAccessWriter.write((VariableAccess) left, false, this);\n\t\t} else {\n\t\t\tleft.accept(this);\n\t\t}\n\t\tcurrent.app(' ').app(assignment.getSymbol()).app(' ');\n\t\tassignment.getRight().accept(this);\n\t}\n\n\tpublic void visit(ValuedReturn return1) throws IOException {\n\t\tcurrent.app(\"return \");\n\t\treturn1.getExpression().accept(this);\n\t}\n\t\n\tpublic void visit(Return return1) throws IOException {\n\t\tcurrent.app(\"return\");\n\t}\n\n\tpublic void visit(NullLiteral nullLiteral) throws IOException {\n\t\tLiteralWriter.writeNull(this);\n\t}\n\n\tpublic void visit(IntLiteral numberLiteral) throws IOException {\n\t\tLiteralWriter.writeInt(numberLiteral, this);\n\t}\n\t\n\tpublic void visit(FloatLiteral floatLiteral) throws IOException {\n\t\tLiteralWriter.writeFloat(floatLiteral, this);\n\t}\n\n\tpublic void visit(StringLiteral stringLiteral) throws IOException {\n\t\tLiteralWriter.writeString(stringLiteral, this);\n\t}\n\n\tpublic void visit(RangeLiteral rangeLiteral) throws IOException {\n\t\tthrow new OocCompilationError(rangeLiteral, module,\n\t\t\t\t\"Using a range literal outside a foreach is not supported yet.\");\n\t}\n\n\tpublic void visit(BoolLiteral boolLiteral) throws IOException {\n\t\tcurrent.app(boolLiteral.getValue() ? \"true\" : \"false\");\n\t}\n\n\tpublic void visit(CharLiteral charLiteral) throws IOException {\n\t\tcurrent.app('\\'').app(SourceReader.spelled(charLiteral.getValue())).app('\\'');\t\t\n\t}\n\n\tpublic void visit(Line line) throws IOException {\n\t\tcurrent.nl();\n\t\tif(line.getStatement() instanceof FunctionCall) CallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\tline.getStatement().accept(this);\n\t\tif(!(line.getStatement() instanceof ControlStatement)) {\n\t\t\tcurrent.app(';');\n\t\t}\n\t}\n\n\tpublic void visit(Include include) throws IOException {}\n\n\tpublic void visit(If if1) throws IOException {\n\t\tControlStatementWriter.writeIf(if1, this);\n\t}\n\t\n\tpublic void visit(Else else1) throws IOException {\n\t\tControlStatementWriter.writeElse(else1, this);\n\t}\n\n\tpublic void visit(While while1) throws IOException {\n\t\tControlStatementWriter.writeWhile(while1, this);\n\t}\n\n\tpublic void visit(Foreach foreach) throws IOException {\n\t\tControlStatementWriter.writeForeach(foreach, this);\n\t}\n\n\tpublic void visit(MemberAccess memberAccess) throws IOException {\n\t\tAccessWriter.writeMember(memberAccess, this);\n\t}\n\t\n\tpublic void visit(VariableAccess variableAccess) throws IOException {\n\t\tAccessWriter.writeVariable(variableAccess, true, this);\n\t}\n\n\tpublic void visit(ArrayAccess arrayAccess) throws IOException {\n\t\tAccessWriter.writeArray(arrayAccess, this);\n\t}\n\n\tpublic void visit(VariableDecl variableDecl) throws IOException {\n\t\tVariableDeclWriter.write(variableDecl, this);\n\t}\n\n\tpublic void visit(FunctionDecl functionDecl) throws IOException {\n\t\tFunctionDeclWriter.write(functionDecl, this);\n\t}\n\n\tpublic void visit(ClassDecl classDecl) throws IOException {\n\t\tClassDeclWriter.write(classDecl, this);\n\t}\n\t\n\tpublic void visit(CoverDecl cover) throws IOException {\n\t\tCoverDeclWriter.write(cover, this);\n\t}\n\t\n\tpublic void visit(TypeArgument typeArgument) throws IOException {\n\t\ttypeArgument.getType().accept(this);\n\t}\n\n\tpublic void visit(RegularArgument regularArgument) throws IOException {\n\t\tType type = regularArgument.getType();\n\t\tif(type.isArray()) {\n\t\t\tcurrent.app(type.getName()).app(' ').app(regularArgument.getName());\n\t\t\tfor(int i = 0; i < type.getPointerLevel(); i++) {\n\t\t\t\tcurrent.app(\"[]\");\n\t\t\t}\n\t\t} else {\n\t\t\tif(type instanceof FuncType) {\n\t\t\t\tTypeWriter.writeFuncPointer((FunctionDecl) type.getRef(), regularArgument.getName(), this);\n\t\t\t} else {\n\t\t\t\tTypeWriter.writeSpaced(type, this);\n\t\t\t\tcurrent.app(regularArgument.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void visit(MemberArgument memberArgument) throws IOException {}\n\n\tpublic void visit(MemberAssignArgument memberArgument) throws IOException {}\n\n\tpublic void visit(Type type) throws IOException {\n\t\tTypeWriter.write(type, this);\n\t}\n\n\tpublic void visit(VarArg varArg) throws IOException {\n\t\tcurrent.app(\"...\");\n\t}\n\t\n\tpublic void visit(NodeList<? extends Node> list) throws IOException {\n\t\tlist.acceptChildren(this);\n\t}\n\t\n\tpublic void visit(Block block) throws IOException {\n\t\tcurrent.openBlock();\n\t\tblock.acceptChildren(this);\n\t\tcurrent.closeBlock();\n\t}\n\n\tpublic void visit(BuiltinType builtinType) throws IOException {}\n\n\tpublic void visit(VariableDeclAtom variableDeclAtom) throws IOException {}\n\t\n\tpublic void visit(Cast cast) throws IOException {\n\t\tCastWriter.write(cast, this);\n\t}\n\n\tpublic void visit(AddressOf addressOf) throws IOException {\n\t\tif(addressOf.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) addressOf.getExpression();\n\t\t\tType varAccType = varAcc.getRef().getType();\n\t\t\tif(varAccType.getRef() instanceof TypeParam) {\n\t\t\t\tAccessWriter.write(varAcc, false, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(varAccType.getReferenceLevel() == 1) {\n\t\t\t\tAccessWriter.write(varAcc, false, this, -1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcurrent.app(\"&(\");\n\t\taddressOf.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Dereference dereference) throws IOException {\n\t\tcurrent.app(\"(*\");\n\t\tdereference.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(OpDecl opDecl) throws IOException {\n\t\topDecl.getFunc().accept(this);\n\t}\n\n\tpublic void visit(Import import1) throws IOException {}\n\t\n\tpublic void visit(ArrayLiteral arrayLiteral) throws IOException {\n\t\tcurrent.app('{');\n\t\tIterator<Expression> iter = arrayLiteral.getElements().iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression element = iter.next();\n\t\t\tboolean doCasting = false;\n\t\t\tif(!element.getType().getName().equals(arrayLiteral.getType().getName())) {\n\t\t\t\tdoCasting = true;\n\t\t\t\tcurrent.app(\"((\");\n\t\t\t\tarrayLiteral.getElements().get(0).getType().accept(this);\n\t\t\t\tcurrent.app(\") \");\n\t\t\t}\n\t\t\telement.accept(this);\n\t\t\tif(doCasting) {\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\tif(iter.hasNext()) current.app(\", \");\n\t\t}\n\t\tcurrent.app('}');\n\t}\n\n\tpublic void visit(Use use) throws IOException {}\n\n\tpublic void visit(BinaryCombination binaryCombination) throws IOException {\n\t\tbinaryCombination.getLeft().accept(this);\n\t\tcurrent.app(' ').app(binaryCombination.getOpString()).app(' ');\n\t\tbinaryCombination.getRight().accept(this);\n\t}\n\n\tpublic void visit(MultiMap<?, ?> list) throws IOException {}\n\n\tpublic void visit(FlowControl flow) throws IOException {\n\t\tcurrent.app(flow.getKeyword()).app(\";\");\n\t}\n\n\tpublic void visit(InterfaceDecl interfaceDecl) throws IOException {\n\t\t// huh.. slack off?\n\t}\n\n\tpublic void visit(Ternary ternary) throws IOException {\n\t\tternary.getCondition().accept(this);\n\t\tcurrent.app(\" ? \");\n\t\tternary.getValueIfTrue().accept(this);\n\t\tcurrent.app(\" : \");\n\t\tternary.getValueIfFalse().accept(this);\n\t}\n\n\tpublic void visit(Match match) throws IOException {\n\t\tboolean isFirst = true;\n\t\tfor(Case case1: match.getCases()) {\n\t\t\tif(!isFirst) {\n\t\t\t\tcurrent.app(\" else \");\n\t\t\t}\n\n\t\t\tif(case1.getExpr() == null) {\n\t\t\t\tif(isFirst) current.app(\" else \");\n\t\t\t} else {\n\t\t\t\tif(case1.isFallthrough()) current.app(' ');\n\t\t\t\tcurrent.app(\"if (\");\n\t\t\t\tcase1.getExpr().accept(this);\n\t\t\t\tcurrent.app(\")\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.app(\"{\").tab();\n\t\t\t\n\t\t\tint bodySize = case1.getBody().size();\n\t\t\tint index = bodySize;\n\t\t\tfor(Line line: case1.getBody()) {\n\t\t\t\tcurrent.newLine();\n\t\t\t\tif(index == bodySize && match.getVarAcc() != null) {\n\t\t\t\t\tmatch.getVarAcc().accept(this);\n\t\t\t\t\tcurrent.append(\" = \");\n\t\t\t\t}\n\t\t\t\tif(line.getStatement() instanceof FunctionCall) {\n\t\t\t\t\tCallWriter.bypassPrelude = (FunctionCall) line.getStatement();\n\t\t\t\t}\n\t\t\t\tline.getStatement().accept(this);\n\t\t\t\tcurrent.append(\";\");\n\t\t\t}\n\t\t\t\n\t\t\tcurrent.untab().nl().app(\"}\");\n\t\t\tif(isFirst) isFirst = false;\n\t\t}\n\t}\n\n\tpublic void visit(Case case1) throws IOException {\n\t\t// hmmm... no\n\t}\n\n}\n","lineNo":327}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Type extends Node implements MustBeResolved {\n\n\tpublic static class Classification {\n\t\tpublic static final int POINTER = 1;\n\t\tpublic static final int NUMBER = 2;\n\t\tpublic static final int CLASS = 4;\n\t}\n\n\tprotected String name;\n\tprotected int pointerLevel;\n\tprotected int referenceLevel;\n\tprivate Declaration ref;\n\t\n\tprivate boolean isArray = false;\n\tprivate Expression arraySize = null;\n\t\n\tprotected NodeList<Access> typeParams;\n\tprivate boolean isConst = false;\n\t\n\tprivate static Type voidType = null;\n\t\n\tpublic static Type getVoid() {\n\t\tif(voidType == null) {\n\t\t\tvoidType = new Type(\"Void\", Token.defaultToken);\n\t\t}\n\t\treturn voidType;\n\t}\n\t\n\tpublic Type(String name, Token startToken) {\n\t\tthis(name, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, Token startToken) {\n\t\tthis(name, pointerLevel, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, int referenceLevel, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.pointerLevel = pointerLevel;\n\t\tthis.referenceLevel = referenceLevel;\n\t\tthis.typeParams = new NodeList<Access>(startToken);\n\t}\n\t\n\tpublic NodeList<Access> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void setPointerLevel(int pointerLevel) {\n\t\tthis.pointerLevel = pointerLevel;\n\t}\n\n\tpublic int getPointerLevel() {\n\t\treturn pointerLevel;\n\t}\n\t\n\tpublic void setReferenceLevel(int referenceLevel) {\n\t\tthis.referenceLevel = referenceLevel;\n\t}\n\t\n\tpublic int getReferenceLevel() {\n\t\treturn referenceLevel;\n\t}\n\t\n\tpublic Declaration getRef() {\n\t\treturn ref;\n\t}\n\t\n\tpublic void setRef(Declaration ref) {\n\t\tthis.ref = ref;\n\t}\n\t\n\tpublic boolean isConst() {\n\t\treturn isConst;\n\t}\n\t\n\tpublic void setConst(boolean isConst) {\n\t\tthis.isConst = isConst;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif(arraySize != null) arraySize.accept(visitor);\n\t\ttypeParams.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(isConst) sb.append(\"const \");\n\t\tsb.append(name);\n\t\t\n\t\tfor(int i = 0; i < pointerLevel; i++) {\n\t\t\tif(isArray) sb.append(\"[]\");\n\t\t\telse sb.append('*');\n\t\t}\n\t\tfor(int i = 0; i < referenceLevel; i++) {\n\t\t\tsb.append('@');\n\t\t}\n\t\tif(!typeParams.isEmpty()) {\n\t\t\tsb.append('<');\n\t\t\tIterator<Access> iter = typeParams.iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tAccess element = iter.next();\n\t\t\t\tif(element instanceof VariableAccess) {\n\t\t\t\t\tsb.append(((VariableAccess) element).getName());\n\t\t\t\t} else if(element instanceof FunctionCall) {\n\t\t\t\t\tsb.append(((FunctionCall) element).getName());\n\t\t\t\t}\n\t\t\t\tif(iter.hasNext()) sb.append(\", \");\n\t\t\t}\n\t\t\tsb.append('>');\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t\t\n\t}\n\t\n\tpublic String getMangledName() {\n\t\t\n\t\tif(pointerLevel == 0) {\n\t\t\treturn name;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(name);\n\t\tfor(int i = 0; i < pointerLevel + referenceLevel; i++) {\n\t\t\tsb.append(\"__star\");\n\t\t}\n\t\treturn sb.toString();\n\t\t\n\t}\n\n\tpublic boolean isVoid() {\n\t\treturn (name.equals(\"void\") || name.equals(\"Void\")) && isFlat();\n\t}\n\n\tpublic boolean isFlat() {\n\t\treturn pointerLevel == 0 && referenceLevel == 0 && !(ref instanceof ClassDecl);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == ref) {\n\t\t\tref = (Declaration) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif(obj instanceof Type) {\n\t\t\tType type = (Type) obj;\n\t\t\treturn name.equals(type.name) && pointerLevel == type.getPointerLevel();\n\t\t}\n\t\treturn super.equals(obj);\n\t}\n\t\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(name.equals(\"Func\")) {\n\t\t\tSystem.out.println(\"[\"+getClass().getSimpleName()+\"] Replaced Func with Func :D ! in \"+stack.peek());\n\t\t\tif(!stack.peek().replace(this, new FuncType(startToken))) {\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace \"+this+\" with a FuncType in \"+stack.peek());\n\t\t\t}\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref != null) return Response.OK;\n\t\t\n\t\tref = stack.getModule().getType(name);\n\n\t\tif(ref == null && name.equals(\"This\")) {\n\t\t\tint index = stack.find(TypeDecl.class);\n\t\t\tif(index == -1) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Using 'This' outside a type definition is meaningless.\");\n\t\t\t}\n\t\t\tTypeDecl typeDecl = (TypeDecl) stack.get(index);\n\t\t\tname = typeDecl.getName();\n\t\t\tref = typeDecl;\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref == null) {\n\t\t\tTypeParam param = getTypeParam(stack, name);\n\t\t\tif(param != null) {\n\t\t\t\tref = param;\n\t\t\t\treturn Response.OK;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ref == null && fatal) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type \"\n\t\t\t\t\t+getName());\n\t\t}\n\t\t\n\t\treturn (ref == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn ref != null;\n\t}\n\t\n\tpublic void setArray(boolean isArray) {\n\t\tthis.isArray = isArray;\n\t}\n\t\n\tpublic boolean isArray() {\n\t\treturn isArray;\n\t}\n\t\n\tpublic Type getGroundType() {\n\t\treturn getGroundType(null);\n\t}\n\t\n\tpublic Type getGroundType(Resolver res) {\n\t\tif(ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) ref;\n\t\t\tif(coverDecl.getFromType() != null && !name.equals(coverDecl.getFromType().getName())) {\n\t\t\t\tType rawType = coverDecl.getFromType().getGroundType(res);\n\t\t\t\tType groundType = new Type(rawType.name, pointerLevel, referenceLevel, rawType.startToken);\n\t\t\t\tif(res == null) {\n\t\t\t\t\tgroundType.ref = ref;\n\t\t\t\t} else {\n\t\t\t\t\tgroundType.resolve(res);\n\t\t\t\t}\n\t\t\t\treturn groundType;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tpublic Type getFlatType(Resolver res) {\n\t\tType returnType = this;\n\t\twhile(returnType.ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) returnType.ref;\n\t\t\tType fromType = coverDecl.getFromType();\n\t\t\tif(fromType == null) break;\n\t\t\tif(fromType.referenceLevel <= 0) break;\n\t\t\t\n\t\t\treturnType = new Type(fromType.name, fromType.pointerLevel - 1,\n\t\t\t\t\treturnType.referenceLevel - 1, fromType.startToken);\n\t\t\treturnType.resolve(res);\n\t\t}\n\t\t\n\t\treturn returnType;\n\t}\n\n\tpublic boolean fitsIn(Type innerType) {\n\t\tif (equals(innerType)) return true;\n\t\tif (getClassification() == innerType.getClassification()) return true;\n\t\treturn false;\n\t}\n\t\n\tpublic int getClassification() {\n\t\tif(!isFlat()) return Classification.POINTER;\n\t\t\n\t\tif(name.equals(\"Int\")   || name.equals(\"UInt\")  || name.equals(\"Short\")\n\t\t|| name.equals(\"UShort\")|| name.equals(\"Long\")  || name.equals(\"ULong\")\n\t\t|| name.equals(\"LLong\") || name.equals(\"ULLong\")|| name.equals(\"Char\")\n\t\t|| name.equals(\"UChar\") || name.equals(\"Int8\")  || name.equals(\"Int16\")\n\t\t|| name.equals(\"Int32\") || name.equals(\"Int64\") || name.equals(\"UInt8\")\n\t\t|| name.equals(\"UInt16\")|| name.equals(\"UInt32\")|| name.equals(\"UInt64\")\n\t\t|| name.equals(\"SizeT\")\n\t\t) return Classification.NUMBER;\n\t\t\n\t\treturn Classification.CLASS;\n\t}\n\n\tpublic void resolve(Resolver res) {\n\t\tref = res.module.getType(name);\n\t}\n\n\tpublic boolean isSuperOf(Type type) {\n\t\tif(type == null) return false;\n\t\tif(this.equals(type)) return false;\n\t\tif(name.length() == 0 || type.name.length() == 0) return false;\n\t\t\n\t\tif(type.getRef() instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) type.getRef();\n\t\t\tif(typeDecl.getSuperRef() != null) {\n\t\t\t\tType superType = typeDecl.getSuperRef().getType();\n\t\t\t\tif(superType.getName().equals(this.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn isSuperOf(superType);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String getHierarchyRepr() {\n\t\tString repr = name;\n\t\tType t = this;\n\t\twhile(t.ref != null) {\n\t\t\tif(!(t.ref instanceof TypeDecl)) break;\n\t\t\tTypeDecl typeDecl = (TypeDecl) t.ref;\n\t\t\tif(typeDecl.getSuperRef() == null) break;\n\t\t\tt = typeDecl.getSuperRef().getType();\n\t\t\trepr += \":\" + t;\n\t\t}\n\t\treturn repr;\n\t}\n\n\t@Override\n\tpublic Type clone() {\n\t\tType clone = new Type(name, pointerLevel, referenceLevel, startToken);\n\t\tclone.ref = ref;\n\t\tclone.isArray = isArray;\n\t\tclone.isConst = isConst;\n\t\tclone.typeParams.addAll(typeParams);\n\t\treturn clone;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn ref instanceof TypeParam;\n\t}\n\t\n\tpublic boolean isGenericRecursive() {\n\t\treturn (ref instanceof TypeParam) || !typeParams.isEmpty();\n\t}\n\n\tpublic Expression getArraySize() {\n\t\treturn arraySize;\n\t}\n\n\tpublic void setArraySize(Expression arraySize) {\n\t\tthis.arraySize = arraySize;\n\t}\n\n\tpublic boolean softEquals(Type type, Resolver res) {\n\t\tif(type == null) return false;\n\t\tresolve(res);\n\t\tif(equals(type)) {\n\t\t\treturn true;\n\t\t}\n\t\tDeclaration ref = type.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tif(typeDecl.getSuperType() != null) {\n\t\t\t\tType subType = typeDecl.getSuperType();\n\t\t\t\treturn softEquals(subType, res);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic boolean isPrefixed() {\n\t\n\t\treturn (ref instanceof ClassDecl || (ref instanceof CoverDecl && !((CoverDecl) ref).isExtern()));\n\t\t\n\t}\n\n\tpublic String getUnderName() {\n\t\t\n\t\tif(isPrefixed()) return ((TypeDecl) ref).getUnderName();\n\t\treturn getName();\n\t\t\n\t}\n\n\tpublic Type dereference() {\n\t\tType clone = clone();\n\t\tclone.setPointerLevel(getPointerLevel() - 1);\n\t\treturn clone;\n\t}\n\t\n}\n\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Type extends Node implements MustBeResolved {\n\n\tpublic static class Classification {\n\t\tpublic static final int POINTER = 1;\n\t\tpublic static final int NUMBER = 2;\n\t\tpublic static final int CLASS = 4;\n\t}\n\n\tprotected String name;\n\tprotected int pointerLevel;\n\tprotected int referenceLevel;\n\tprivate Declaration ref;\n\t\n\tprivate boolean isArray = false;\n\tprivate Expression arraySize = null;\n\t\n\tprotected NodeList<Access> typeParams;\n\tprivate boolean isConst = false;\n\t\n\tprivate static Type voidType = null;\n\t\n\tpublic static Type getVoid() {\n\t\tif(voidType == null) {\n\t\t\tvoidType = new Type(\"Void\", Token.defaultToken);\n\t\t}\n\t\treturn voidType;\n\t}\n\t\n\tpublic Type(String name, Token startToken) {\n\t\tthis(name, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, Token startToken) {\n\t\tthis(name, pointerLevel, 0, startToken);\n\t}\n\t\n\tpublic Type(String name, int pointerLevel, int referenceLevel, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.pointerLevel = pointerLevel;\n\t\tthis.referenceLevel = referenceLevel;\n\t\tthis.typeParams = new NodeList<Access>(startToken);\n\t}\n\t\n\tpublic NodeList<Access> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void setPointerLevel(int pointerLevel) {\n\t\tthis.pointerLevel = pointerLevel;\n\t}\n\n\tpublic int getPointerLevel() {\n\t\treturn pointerLevel;\n\t}\n\t\n\tpublic void setReferenceLevel(int referenceLevel) {\n\t\tthis.referenceLevel = referenceLevel;\n\t}\n\t\n\tpublic int getReferenceLevel() {\n\t\treturn referenceLevel;\n\t}\n\t\n\tpublic Declaration getRef() {\n\t\treturn ref;\n\t}\n\t\n\tpublic void setRef(Declaration ref) {\n\t\tthis.ref = ref;\n\t}\n\t\n\tpublic boolean isConst() {\n\t\treturn isConst;\n\t}\n\t\n\tpublic void setConst(boolean isConst) {\n\t\tthis.isConst = isConst;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif(arraySize != null) arraySize.accept(visitor);\n\t\ttypeParams.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(isConst) sb.append(\"const \");\n\t\tsb.append(name);\n\t\t\n\t\tfor(int i = 0; i < pointerLevel; i++) {\n\t\t\tif(isArray) sb.append(\"[]\");\n\t\t\telse sb.append('*');\n\t\t}\n\t\tfor(int i = 0; i < referenceLevel; i++) {\n\t\t\tsb.append('@');\n\t\t}\n\t\tif(!typeParams.isEmpty()) {\n\t\t\tsb.append('<');\n\t\t\tIterator<Access> iter = typeParams.iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tAccess element = iter.next();\n\t\t\t\tif(element instanceof VariableAccess) {\n\t\t\t\t\tsb.append(((VariableAccess) element).getName());\n\t\t\t\t} else if(element instanceof FunctionCall) {\n\t\t\t\t\tsb.append(((FunctionCall) element).getName());\n\t\t\t\t}\n\t\t\t\tif(iter.hasNext()) sb.append(\", \");\n\t\t\t}\n\t\t\tsb.append('>');\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t\t\n\t}\n\t\n\tpublic String getMangledName() {\n\t\t\n\t\tif(pointerLevel == 0) {\n\t\t\treturn name;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(name);\n\t\tfor(int i = 0; i < pointerLevel + referenceLevel; i++) {\n\t\t\tsb.append(\"__star\");\n\t\t}\n\t\treturn sb.toString();\n\t\t\n\t}\n\n\tpublic boolean isVoid() {\n\t\treturn (name.equals(\"void\") || name.equals(\"Void\")) && isFlat();\n\t}\n\n\tpublic boolean isFlat() {\n\t\treturn pointerLevel == 0 && referenceLevel == 0 && !(ref instanceof ClassDecl);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == ref) {\n\t\t\tref = (Declaration) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif(obj instanceof Type) {\n\t\t\tType type = (Type) obj;\n\t\t\treturn name.equals(type.name) && pointerLevel == type.getPointerLevel();\n\t\t}\n\t\treturn super.equals(obj);\n\t}\n\t\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(name.equals(\"Func\")) {\n\t\t\tFuncType newType = new FuncType(startToken);\n\t\t\tnewType.setPointerLevel(pointerLevel);\n\t\t\tnewType.setReferenceLevel(referenceLevel);\n\t\t\tnewType.setArray(isArray);\n\t\t\tnewType.setArraySize(arraySize);\n\t\t\tif(!stack.peek().replace(this, newType)) {\n\t\t\t\tThread.dumpStack();\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace \"\n\t\t\t\t\t\t+this+\" with \"+newType+\" in \"+stack.peek());\n\t\t\t}\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref != null) return Response.OK;\n\t\t\n\t\tref = stack.getModule().getType(name);\n\n\t\tif(ref == null && name.equals(\"This\")) {\n\t\t\tint index = stack.find(TypeDecl.class);\n\t\t\tif(index == -1) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Using 'This' outside a type definition is meaningless.\");\n\t\t\t}\n\t\t\tTypeDecl typeDecl = (TypeDecl) stack.get(index);\n\t\t\tname = typeDecl.getName();\n\t\t\tref = typeDecl;\n\t\t\treturn Response.OK;\n\t\t}\n\t\t\n\t\tif(ref == null) {\n\t\t\tTypeParam param = getTypeParam(stack, name);\n\t\t\tif(param != null) {\n\t\t\t\tref = param;\n\t\t\t\treturn Response.OK;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ref == null && fatal) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type \"\n\t\t\t\t\t+getName());\n\t\t}\n\t\t\n\t\treturn (ref == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn ref != null;\n\t}\n\t\n\tpublic void setArray(boolean isArray) {\n\t\tthis.isArray = isArray;\n\t}\n\t\n\tpublic boolean isArray() {\n\t\treturn isArray;\n\t}\n\t\n\tpublic Type getGroundType() {\n\t\treturn getGroundType(null);\n\t}\n\t\n\tpublic Type getGroundType(Resolver res) {\n\t\tif(ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) ref;\n\t\t\tif(coverDecl.getFromType() != null && !name.equals(coverDecl.getFromType().getName())) {\n\t\t\t\tType rawType = coverDecl.getFromType().getGroundType(res);\n\t\t\t\tType groundType = new Type(rawType.name, pointerLevel, referenceLevel, rawType.startToken);\n\t\t\t\tif(res == null) {\n\t\t\t\t\tgroundType.ref = ref;\n\t\t\t\t} else {\n\t\t\t\t\tgroundType.resolve(res);\n\t\t\t\t}\n\t\t\t\treturn groundType;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tpublic Type getFlatType(Resolver res) {\n\t\tType returnType = this;\n\t\twhile(returnType.ref instanceof CoverDecl) {\n\t\t\tCoverDecl coverDecl = (CoverDecl) returnType.ref;\n\t\t\tType fromType = coverDecl.getFromType();\n\t\t\tif(fromType == null) break;\n\t\t\tif(fromType.referenceLevel <= 0) break;\n\t\t\t\n\t\t\treturnType = new Type(fromType.name, fromType.pointerLevel - 1,\n\t\t\t\t\treturnType.referenceLevel - 1, fromType.startToken);\n\t\t\treturnType.resolve(res);\n\t\t}\n\t\t\n\t\treturn returnType;\n\t}\n\n\tpublic boolean fitsIn(Type innerType) {\n\t\tif (equals(innerType)) return true;\n\t\tif (getClassification() == innerType.getClassification()) return true;\n\t\treturn false;\n\t}\n\t\n\tpublic int getClassification() {\n\t\tif(!isFlat()) return Classification.POINTER;\n\t\t\n\t\tif(name.equals(\"Int\")   || name.equals(\"UInt\")  || name.equals(\"Short\")\n\t\t|| name.equals(\"UShort\")|| name.equals(\"Long\")  || name.equals(\"ULong\")\n\t\t|| name.equals(\"LLong\") || name.equals(\"ULLong\")|| name.equals(\"Char\")\n\t\t|| name.equals(\"UChar\") || name.equals(\"Int8\")  || name.equals(\"Int16\")\n\t\t|| name.equals(\"Int32\") || name.equals(\"Int64\") || name.equals(\"UInt8\")\n\t\t|| name.equals(\"UInt16\")|| name.equals(\"UInt32\")|| name.equals(\"UInt64\")\n\t\t|| name.equals(\"SizeT\")\n\t\t) return Classification.NUMBER;\n\t\t\n\t\treturn Classification.CLASS;\n\t}\n\n\tpublic void resolve(Resolver res) {\n\t\tref = res.module.getType(name);\n\t}\n\n\tpublic boolean isSuperOf(Type type) {\n\t\tif(type == null) return false;\n\t\tif(this.equals(type)) return false;\n\t\tif(name.length() == 0 || type.name.length() == 0) return false;\n\t\t\n\t\tif(type.getRef() instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) type.getRef();\n\t\t\tif(typeDecl.getSuperRef() != null) {\n\t\t\t\tType superType = typeDecl.getSuperRef().getType();\n\t\t\t\tif(superType.getName().equals(this.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn isSuperOf(superType);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String getHierarchyRepr() {\n\t\tString repr = name;\n\t\tType t = this;\n\t\twhile(t.ref != null) {\n\t\t\tif(!(t.ref instanceof TypeDecl)) break;\n\t\t\tTypeDecl typeDecl = (TypeDecl) t.ref;\n\t\t\tif(typeDecl.getSuperRef() == null) break;\n\t\t\tt = typeDecl.getSuperRef().getType();\n\t\t\trepr += \":\" + t;\n\t\t}\n\t\treturn repr;\n\t}\n\n\t@Override\n\tpublic Type clone() {\n\t\tType clone = new Type(name, pointerLevel, referenceLevel, startToken);\n\t\tclone.ref = ref;\n\t\tclone.isArray = isArray;\n\t\tclone.isConst = isConst;\n\t\tclone.typeParams.addAll(typeParams);\n\t\treturn clone;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn ref instanceof TypeParam;\n\t}\n\t\n\tpublic boolean isGenericRecursive() {\n\t\treturn (ref instanceof TypeParam) || !typeParams.isEmpty();\n\t}\n\n\tpublic Expression getArraySize() {\n\t\treturn arraySize;\n\t}\n\n\tpublic void setArraySize(Expression arraySize) {\n\t\tthis.arraySize = arraySize;\n\t}\n\n\tpublic boolean softEquals(Type type, Resolver res) {\n\t\tif(type == null) return false;\n\t\tresolve(res);\n\t\tif(equals(type)) {\n\t\t\treturn true;\n\t\t}\n\t\tDeclaration ref = type.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tif(typeDecl.getSuperType() != null) {\n\t\t\t\tType subType = typeDecl.getSuperType();\n\t\t\t\treturn softEquals(subType, res);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic boolean isPrefixed() {\n\t\n\t\treturn (ref instanceof ClassDecl || (ref instanceof CoverDecl && !((CoverDecl) ref).isExtern()));\n\t\t\n\t}\n\n\tpublic String getUnderName() {\n\t\t\n\t\tif(isPrefixed()) return ((TypeDecl) ref).getUnderName();\n\t\treturn getName();\n\t\t\n\t}\n\n\tpublic Type dereference() {\n\t\tType clone = clone();\n\t\tclone.setPointerLevel(getPointerLevel() - 1);\n\t\treturn clone;\n\t}\n\t\n}\n\n","lineNo":191}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\n/**\n * Binary in the sense that it has a left and a right operand (e.g. binary op,\n * as opposed to unary op or ternary op)\n */\npublic abstract class BinaryOperation extends Expression implements MustBeResolved {\n\n\tprotected Expression left;\n\tprotected Expression right;\n\t\n\tpublic BinaryOperation(Expression left, Expression right, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\t\n\tpublic Expression getLeft() {\n\t\treturn left;\n\t}\n\t\n\tpublic void setLeft(Expression left) {\n\t\tthis.left = left;\n\t}\n\t\n\tpublic Expression getRight() {\n\t\treturn right;\n\t}\n\t\n\tpublic void setRight(Expression right) {\n\t\tthis.right = right;\n\t}\n\t\n\tpublic Type getType() {\n\t\t// FIXME probably not right (haha)\n\t\treturn getLeft().getType();\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tleft.accept(visitor);\n\t\tright.accept(visitor);\n\t}\n\t\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(left.getType() == null) {\n\t\t\tif(left instanceof MustBeResolved) {\n\t\t\t\t((MustBeResolved) left).resolve(stack, res, fatal);\n\t\t\t}\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Can't resolve type of left \"+\n\t\t\t\t\t\tleft+\" operand. Wtf?\");\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tif(right.getType() == null) {\n\t\t\tif(right instanceof MustBeResolved) {\n\t\t\t\t((MustBeResolved) right).resolve(stack, res, fatal);\n\t\t\t}\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Can't resolve type of right \"\n\t\t\t\t\t\t+right+\" operand. Seriously.\");\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tOpType opType = getOpType();\t\t\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tif(tryOp(stack, opType, op, res)) return Response.RESTART;\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tif(tryOp(stack, opType, op, res)) return Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(opType.isNumeric() && left.getType().getRef() instanceof ClassDecl && left.getType().getPointerLevel() == 0) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Using operator \"+opType.toPrettyString()+\" between non-numeric types.\"\n\t\t\t\t\t+\" Maybe you want to overload it? Do it like this: operator \"\n\t\t\t\t\t+opType.toPrettyString()+\" (left: \"+left.getType()+\", right: \"+right.getType()+\") { ... }\");\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate boolean tryOp(NodeList<Node> stack, OpType opType, OpDecl op, Resolver res) {\n\t\tboolean end = false;\n\t\tif(op.getOpType() == opType) {\n\t\t\tif(op.getFunc().getArguments().size() != 2) {\n\t\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\t\"To overload the add operator, you need exactly two arguments, not \"\n\t\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t\t}\n\t\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\t\tArgument first = args.get(0);\n\t\t\tArgument second = args.get(1);\n\t\t\tif(first.getType().softEquals(left.getType(), res)) {\n\t\t\t\tif(second.getType().softEquals(right.getType(), res) || isGeneric(second.getType(), op.getFunc().getTypeParams())) {\n\t\t\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\t\t\tcall.getArguments().add(left);\n\t\t\t\t\tcall.getArguments().add(right);\n\t\t\t\t\tstack.peek().replace(this, call);\n\t\t\t\t\tcall.resolve(stack, res, true);\n\t\t\t\t\tend = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn end;\n\t}\n\t\n\tprivate boolean isGeneric(Type type, LinkedHashMap<String, TypeParam> linkedHashMap) {\n\t\treturn linkedHashMap.containsKey(type.getName());\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == left) {\n\t\t\tleft = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == right) {\n\t\t\tright = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic abstract OpType getOpType();\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.interfaces.MustBeUnwrapped;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\n/**\n * Binary in the sense that it has a left and a right operand (e.g. binary op,\n * as opposed to unary op or ternary op)\n * \n * Operator precedence chart:\n * \n *   10   * / %\n *   20   + -\n *   30   << >>\n *   40   < > <= >=\n *   50   == !=\n *   60   &\n *   70   ^\n *   80   |\n *   90   &&\n *   100  ||\n *   110  ?:\n *   120  = += -= /= *= >>= <<= ^= &= |=\n */\npublic abstract class BinaryOperation extends Expression implements MustBeUnwrapped, MustBeResolved {\n\n\tprotected Expression left;\n\tprotected Expression right;\n\t\n\tpublic BinaryOperation(Expression left, Expression right, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\t\n\tpublic Expression getLeft() {\n\t\treturn left;\n\t}\n\t\n\tpublic void setLeft(Expression left) {\n\t\tthis.left = left;\n\t}\n\t\n\tpublic Expression getRight() {\n\t\treturn right;\n\t}\n\t\n\tpublic void setRight(Expression right) {\n\t\tthis.right = right;\n\t}\n\t\n\tpublic Type getType() {\n\t\t// FIXME probably not right (haha)\n\t\treturn getLeft().getType();\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tleft.accept(visitor);\n\t\tright.accept(visitor);\n\t}\n\t\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(left.getType() == null) {\n\t\t\tif(left instanceof MustBeResolved) {\n\t\t\t\t((MustBeResolved) left).resolve(stack, res, fatal);\n\t\t\t}\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Can't resolve type of left \"+\n\t\t\t\t\t\tleft+\" operand. Wtf?\");\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tif(right.getType() == null) {\n\t\t\tif(right instanceof MustBeResolved) {\n\t\t\t\t((MustBeResolved) right).resolve(stack, res, fatal);\n\t\t\t}\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Can't resolve type of right \"\n\t\t\t\t\t\t+right+\" operand. Seriously.\");\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tOpType opType = getOpType();\t\t\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tif(tryOp(stack, opType, op, res)) return Response.RESTART;\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tif(tryOp(stack, opType, op, res)) return Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(opType.isNumeric() && left.getType().getRef() instanceof ClassDecl && left.getType().getPointerLevel() == 0) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Using operator \"+opType.toPrettyString()+\" between non-numeric types.\"\n\t\t\t\t\t+\" Maybe you want to overload it? Do it like this: operator \"\n\t\t\t\t\t+opType.toPrettyString()+\" (left: \"+left.getType()+\", right: \"+right.getType()+\") { ... }\");\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate boolean tryOp(NodeList<Node> stack, OpType opType, OpDecl op, Resolver res) {\n\t\tboolean end = false;\n\t\tif(op.getOpType() == opType) {\n\t\t\tif(op.getFunc().getArguments().size() != 2) {\n\t\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\t\"To overload the add operator, you need exactly two arguments, not \"\n\t\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t\t}\n\t\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\t\tArgument first = args.get(0);\n\t\t\tArgument second = args.get(1);\n\t\t\tif(first.getType().softEquals(left.getType(), res)) {\n\t\t\t\tif(second.getType().softEquals(right.getType(), res) || isGeneric(second.getType(), op.getFunc().getTypeParams())) {\n\t\t\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\t\t\tcall.getArguments().add(left);\n\t\t\t\t\tcall.getArguments().add(right);\n\t\t\t\t\tNode parent = stack.peek();\n\t\t\t\t\tparent.replace(this, call);\n\t\t\t\t\tcall.resolve(stack, res, true);\n\t\t\t\t\tend = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn end;\n\t}\n\t\n\tprivate boolean isGeneric(Type type, LinkedHashMap<String, TypeParam> linkedHashMap) {\n\t\treturn linkedHashMap.containsKey(type.getName());\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == left) {\n\t\t\tleft = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == right) {\n\t\t\tright = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic boolean unwrap(NodeList<Node> stack) throws IOException {\n\t\t\n\t\t// Example:\n\t\t// Mul(1, Add(2, 3))\n\t\t// Should infact be Add(Mul(1, 2), 3)\n\t\t\n\t\tif(right instanceof BinaryOperation) {\n\t\t\tBinaryOperation opRight = (BinaryOperation) right;\n\t\t\tif(getPriority() < opRight.getPriority()) {\n\t\t\t\tExpression tmp = opRight.getLeft();\n\t\t\t\topRight.setLeft(this);\n\t\t\t\tthis.setRight(tmp);\n\t\t\t\tstack.peek().replace(this, opRight);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\t\n\tpublic abstract OpType getOpType();\n\t\n\tpublic abstract int getPriority();\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(\" + left + \" \" + getOpType().toPrettyString() + \" \" + right + \")\";\n\t}\n\t\n}\n","lineNo":138}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\tprotected boolean dead = false;\n\t\n\tpublic FunctionCall(String name, Token startToken) {\n\t\tthis(name, null, startToken);\n\t}\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!parent.replace(this, vdfe)) {\n\t\t\t\t\tThread.dumpStack();\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"[FC] Couldn't replace \\n\"+this+\" with \\n\"+vdfe\n\t\t\t\t\t\t\t+\"in \\n\"+parent.getClass().getSimpleName()+\"|\"+parent);\n\t\t\t\t}\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tType result = null;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tType argType = arg.getType();\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i).getType();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(argType.isGenericRecursive()) {\n\t\t\t\tExpression resultExpr = getRealExpr(typeParam, argType, stack, res, fatal);\n\t\t\t\tif(resultExpr != null && resultExpr.getType() != null) {\n\t\t\t\t\tresult = resultExpr.getType();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tType argType = arg.getType();\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(argType.isGenericRecursive()) {\n\t\t\t\tresult = getRealExpr(typeParam, argType, stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprivate Expression getRealExpr(String typeParam, Type argType,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = argType.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(typeParam)) {\n\t\t\t\t\tType realType = getRealType(argType.getName(), stack, res, fatal);\n\t\t\t\t\tif(realType != null) {\n\t\t\t\t\t\treturn realType.getTypeParams().get(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tif(declType != null) declType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix == null || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t\tdead = true;\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix == null || suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\tprotected boolean dead = false;\n\t\n\tpublic FunctionCall(String name, Token startToken) {\n\t\tthis(name, null, startToken);\n\t}\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!parent.replace(this, vdfe)) {\n\t\t\t\t\tThread.dumpStack();\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"[FC] Couldn't replace \\n\"+this+\" with \\n\"+vdfe\n\t\t\t\t\t\t\t+\"in \\n\"+parent.getClass().getSimpleName()+\"|\"+parent);\n\t\t\t\t}\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tExpression realExpr = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(realExpr == null) return null;\n\t\treturn realExpr.getType();\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\t\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\t\n\t\t\t// e.g. func <T> myFunc(T: Class), and arg = T\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = callArg;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", argName-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(value: T), and arg = value.\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\tVariableAccess varAcc = new VariableAccess(callArg.getType().getName(), startToken);\n\t\t\t\tvarAcc.setRef(callArg.getType().getRef());\n\t\t\t\tresult = varAcc;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", varAccType-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(list:)\n\t\t\tif(arg.getType().isGenericRecursive()) {\n\t\t\t\tresult = searchTypeParam(typeParam, arg.getType(), stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", genericRecursive-wise\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\t/**\n\t * Search for the type param @needle in the type @haystack\n\t */\n\tprivate Expression searchTypeParam(String needle, Type haystack,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = haystack.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(needle)) {\n\t\t\t\t\tType realType = getRealType(haystack.getName(), stack, res, fatal);\n\t\t\t\t\tif(realType != null) {\n\t\t\t\t\t\treturn realType.getTypeParams().get(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\t\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tif(declType != null) declType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix == null || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t\tdead = true;\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix == null || suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tThread.dumpStack();\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","lineNo":296}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\tprotected boolean dead = false;\n\t\n\tpublic FunctionCall(String name, Token startToken) {\n\t\tthis(name, null, startToken);\n\t}\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!parent.replace(this, vdfe)) {\n\t\t\t\t\tThread.dumpStack();\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"[FC] Couldn't replace \\n\"+this+\" with \\n\"+vdfe\n\t\t\t\t\t\t\t+\"in \\n\"+parent.getClass().getSimpleName()+\"|\"+parent);\n\t\t\t\t}\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tType result = null;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tType argType = arg.getType();\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i).getType();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(argType.isGenericRecursive()) {\n\t\t\t\tExpression resultExpr = getRealExpr(typeParam, argType, stack, res, fatal);\n\t\t\t\tif(resultExpr != null && resultExpr.getType() != null) {\n\t\t\t\t\tresult = resultExpr.getType();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tType argType = arg.getType();\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(argType.isGenericRecursive()) {\n\t\t\t\tresult = getRealExpr(typeParam, argType, stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprivate Expression getRealExpr(String typeParam, Type argType,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = argType.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(typeParam)) {\n\t\t\t\t\tType realType = getRealType(argType.getName(), stack, res, fatal);\n\t\t\t\t\tif(realType != null) {\n\t\t\t\t\t\treturn realType.getTypeParams().get(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tif(declType != null) declType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix == null || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t\tdead = true;\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix == null || suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\tprotected boolean dead = false;\n\t\n\tpublic FunctionCall(String name, Token startToken) {\n\t\tthis(name, null, startToken);\n\t}\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!parent.replace(this, vdfe)) {\n\t\t\t\t\tThread.dumpStack();\n\t\t\t\t\tthrow new OocCompilationError(this, stack, \"[FC] Couldn't replace \\n\"+this+\" with \\n\"+vdfe\n\t\t\t\t\t\t\t+\"in \\n\"+parent.getClass().getSimpleName()+\"|\"+parent);\n\t\t\t\t}\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tExpression realExpr = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(realExpr == null) return null;\n\t\treturn realExpr.getType();\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\t\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\t\n\t\t\t// e.g. func <T> myFunc(T: Class), and arg = T\n\t\t\tif(arg.getName().equals(typeParam)) {\n\t\t\t\tresult = callArg;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", argName-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(value: T), and arg = value.\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\tVariableAccess varAcc = new VariableAccess(callArg.getType().getName(), startToken);\n\t\t\t\tvarAcc.setRef(callArg.getType().getRef());\n\t\t\t\tresult = varAcc;\n\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", varAccType-wise\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// e.g. func <T> myFunc(list:)\n\t\t\tif(arg.getType().isGenericRecursive()) {\n\t\t\t\tresult = searchTypeParam(typeParam, arg.getType(), stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tif(res.params.veryVerbose)\n\t\t\t\t\t\tSystem.out.println(\"Matched <\"+typeParam+\"> with \"+result+\", genericRecursive-wise\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\t/**\n\t * Search for the type param @needle in the type @haystack\n\t */\n\tprivate Expression searchTypeParam(String needle, Type haystack,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = haystack.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(needle)) {\n\t\t\t\t\tType realType = getRealType(haystack.getName(), stack, res, fatal);\n\t\t\t\t\tif(realType != null) {\n\t\t\t\t\t\treturn realType.getTypeParams().get(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\t\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tif(declType != null) declType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix == null || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t\tdead = true;\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix == null || suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tThread.dumpStack();\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for call to \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","lineNo":307}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.interfaces.MustBeUnwrapped;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ArrayLiteral extends Literal implements MustBeUnwrapped, MustBeResolved {\n\n\tprivate static Type defaultType = NullLiteral.type;\n\tprotected Type type = defaultType;\n\tprotected NodeList<Expression> elements;\n\t\n\tpublic ArrayLiteral(Token startToken) {\n\t\tsuper(startToken);\n\t\telements = new NodeList<Expression>(startToken);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == type) {\n\t\t\ttype = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\t\n\tpublic NodeList<Expression> getElements() {\n\t\treturn elements;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttype.accept(visitor);\n\t\telements.accept(visitor);\n\t}\n\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn type != defaultType;\n\t}\n\t\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(!elements.isEmpty()) {\n\t\t\tIterator<Expression> iter = elements.iterator();\n\t\t\tType innerType = iter.next().getType();\n\t\t\t\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tExpression element = iter.next();\n\t\t\t\tif(!element.getType().fitsIn(innerType)) {\n\t\t\t\t\tthrow new OocCompilationError(element, stack, \"Encountered a \"\n\t\t\t\t\t\t\t+element.getType()+\" in a \"+innerType+\"* array literal.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.type = new Type(innerType.name, innerType.pointerLevel + 1, startToken);\n\t\t\ttype.setArray(true);\n\t\t\ttype.resolve(stack, res, fatal);\n\t\t}\n\t\t\n\t\tif(type == defaultType && fatal) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out type of ArrayLiteral with elements \"+elements);\n\t\t}\n\t\treturn (type == defaultType) ? Response.LOOP : Response.OK; \n\t\t\n\t}\n\n\tpublic boolean unwrap(NodeList<Node> stack) throws IOException {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\t\n\t\t// if stack.size() - varDeclIndex > 3, we're nested in another varDecl\n\t\t//, thus we need to unwrap\n\t\tif(varDeclIndex == -1 || (stack.size() - varDeclIndex) > 3) {\n\t\t\tstack.peek().replace(this, new VariableDeclFromExpr(\n\t\t\t\t\tgenerateTempName(\"array\"), this, startToken));\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.interfaces.MustBeUnwrapped;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ArrayLiteral extends Literal implements MustBeUnwrapped, MustBeResolved {\n\n\tprivate static Type defaultType = NullLiteral.type;\n\tprotected Type type = defaultType;\n\tprotected NodeList<Expression> elements;\n\t\n\tpublic ArrayLiteral(Token startToken) {\n\t\tsuper(startToken);\n\t\telements = new NodeList<Expression>(startToken);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == type) {\n\t\t\ttype = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\t\n\tpublic NodeList<Expression> getElements() {\n\t\treturn elements;\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttype.accept(visitor);\n\t\telements.accept(visitor);\n\t}\n\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn type != defaultType;\n\t}\n\t\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(!elements.isEmpty()) {\n\t\t\tIterator<Expression> iter = elements.iterator();\n\t\t\tExpression first = iter.next();\n\t\t\tType innerType = first.getType();\n\t\t\tif(innerType == null) {\n\t\t\t\tif(fatal) {\n\t\t\t\t\tthrow new OocCompilationError(first, stack, \"Couldn't resolve type of \"\n\t\t\t\t\t\t\t+first+\" in an \"+innerType+\" array literal\");\n\t\t\t\t}\n\t\t\t\treturn Response.LOOP;\n\t\t\t}\n\t\t\t\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tExpression element = iter.next();\n\t\t\t\tif(element.getType() == null) {\n\t\t\t\t\tif(fatal) {\n\t\t\t\t\t\tthrow new OocCompilationError(element, stack, \"Couldn't resolve type of \"\n\t\t\t\t\t\t\t\t+element+\" in an \"+innerType+\" array literal\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\tif(!element.getType().fitsIn(innerType)) {\n\t\t\t\t\tthrow new OocCompilationError(element, stack, \"Encountered a \"\n\t\t\t\t\t\t\t+element.getType()+\" in a \"+innerType+\"[] array literal.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.type = new Type(innerType.name, innerType.pointerLevel + 1, startToken);\n\t\t\ttype.setArray(true);\n\t\t\ttype.resolve(stack, res, fatal);\n\t\t}\n\t\t\n\t\tif(type == defaultType && fatal) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out type of ArrayLiteral with elements \"+elements);\n\t\t}\n\t\treturn (type == defaultType) ? Response.LOOP : Response.OK; \n\t\t\n\t}\n\n\tpublic boolean unwrap(NodeList<Node> stack) throws IOException {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\t\n\t\t// if stack.size() - varDeclIndex > 3, we're nested in another varDecl\n\t\t//, thus we need to unwrap\n\t\tif(varDeclIndex == -1 || (stack.size() - varDeclIndex) > 3) {\n\t\t\tstack.peek().replace(this, new VariableDeclFromExpr(\n\t\t\t\t\tgenerateTempName(\"array\"), this, startToken));\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n}\n","lineNo":63}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Assignment extends BinaryOperation {\n\n\tpublic boolean dead = false;\n\t\n\tpublic static enum Mode {\n\t\tREGULAR,\n\t\tADD,\n\t\tSUB,\n\t\tDIV,\n\t\tMUL,\n\t\tB_XOR,\n\t\tB_OR,\n\t\tB_AND,\n\t\tB_LSHIFT,\n\t\tB_RSHIFT,\n\t}\n\t\n\tprotected Mode mode;\n\t\n\tpublic Assignment(Expression left, Expression right, Token startToken) {\n\t\tthis(Mode.REGULAR, left, right, startToken);\n\t}\n\t\n\tpublic Assignment(Mode mode, Expression lvalue, Expression rvalue, Token startToken) {\n\t\tsuper(lvalue, rvalue, startToken);\n\t\tthis.mode = mode;\n\t\tthis.left = lvalue;\n\t\tthis.right = rvalue;\n\t}\n\t\n\tpublic Mode getMode() {\n\t\treturn mode;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\treturn left.getType();\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tleft.accept(visitor);\n\t\tright.accept(visitor);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == left) {\n\t\t\tleft = (Access) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\tif(oldie == right) {\n\t\t\tright = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String getSymbol() {\n\t\tswitch(mode) {\n\t\t\tcase ADD:\n\t\t\t\treturn \"+=\";\n\t\t\tcase DIV:\n\t\t\t\treturn \"/=\";\n\t\t\tcase MUL:\n\t\t\t\treturn \"*=\";\n\t\t\tcase SUB:\n\t\t\t\treturn \"-=\";\n\t\t\tcase B_AND:\n\t\t\t\treturn \"&=\";\n\t\t\tcase B_LSHIFT:\n\t\t\t\treturn \"<<=\";\n\t\t\tcase B_OR:\n\t\t\t\treturn \"|=\";\n\t\t\tcase B_RSHIFT:\n\t\t\t\treturn \">>=\";\n\t\t\tcase B_XOR:\n\t\t\t\treturn \"^=\";\n\t\t\tcase REGULAR:\n\t\t\t\treturn \"=\";\n\t\t}\n\t\treturn \"unknown\";\n\t}\n\n\t@Override\n\tpublic OpType getOpType() {\n\t\tswitch(mode) {\n\t\tcase ADD:\n\t\t\treturn OpType.ADD_ASS;\n\t\tcase DIV:\n\t\t\treturn OpType.DIV_ASS;\n\t\tcase MUL:\n\t\t\treturn OpType.MUL_ASS;\n\t\tcase SUB:\n\t\t\treturn OpType.SUB_ASS;\n\t\tcase B_XOR:\n\t\t\treturn OpType.B_XOR_ASS;\n\t\tcase B_OR:\n\t\t\treturn OpType.B_OR_ASS;\n\t\tcase B_AND:\n\t\t\treturn OpType.B_AND_ASS;\n\t\tcase B_LSHIFT:\n\t\t\treturn OpType.B_LSHIFT_ASS;\n\t\tcase B_RSHIFT:\n\t\t\treturn OpType.B_RSHIFT_ASS;\n\t\tcase REGULAR:\n\t\t\treturn OpType.ASS;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Assignment: \"+left.toString()+\" = \"+right.toString();\n\t}\n\t\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(right.getType() != null && left.getType() != null) {\n\t\t\tif(left.getType().isSuperOf(right.getType())) {\n\t\t\t\tright = new Cast(right, left.getType(), right.startToken);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(left.getType() == null) {\n\t\t\tif(fatal) throw new OocCompilationError(left, stack, \"Left type of assignment unresolved: \"+left);\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tif(right.getType() == null) {\n\t\t\tif(fatal) throw new OocCompilationError(right, stack, \"Right type of assignment unresolved: \"+right);\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tboolean isGeneric = false;\n\t\tExpression realLeft = null;\n\t\tExpression realRight = null;\n\t\tExpression size = null;\n\t\tif(left.getType().isGeneric()) {\n\t\t\tisGeneric = true;\n\t\t\tTypeParam genericType = (TypeParam) left.getType().getRef();\n\t\t\tVariableAccess tAccess = new VariableAccess(genericType.getName(), startToken);\n\t\t\tsize = new MemberAccess(tAccess, \"size\", startToken);\n\t\t\trealLeft = new AddressOf(left, left.startToken);\n\t\t\trealRight = new AddressOf(right, right.startToken);\n\t\t}\n\t\t/*\n\t\tif(right.getType().isGeneric()) {\n\t\t\tisGeneric = true;\n\t\t\trealRight = new AddressOf(right, right.startToken);\n\t\t}\n\t\t*/\n\t\tif(isGeneric) {\n\t\t\tif(left instanceof ArrayAccess) {\n\t\t\t\tArrayAccess arrAcc = (ArrayAccess) left;\n\t\t\t\tExpression var = arrAcc.getVariable();\n\t\t\t\tif(var.getType().isGeneric()) {\n\t\t\t\t\tVariableAccess tAccess = new VariableAccess(var.getType().getRef().getName(), startToken);\n\t\t\t\t\tMemberAccess sizeAccess = new MemberAccess(tAccess, \"size\", startToken);\n\t\t\t\t\trealLeft = new Add(arrAcc.variable, new Mul(arrAcc.index, sizeAccess, startToken), startToken);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(right instanceof ArrayAccess) {\n\t\t\t\tArrayAccess arrAcc = (ArrayAccess) right;\n\t\t\t\tExpression var = arrAcc.getVariable();\n\t\t\t\tif(var.getType().isGeneric()) {\n\t\t\t\t\tVariableAccess tAccess = new VariableAccess(var.getType().getRef().getName(), startToken);\n\t\t\t\t\tMemberAccess sizeAccess = new MemberAccess(tAccess, \"size\", startToken);\n\t\t\t\t\trealRight = new Add(arrAcc.variable, new Mul(arrAcc.index, sizeAccess, startToken), startToken);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(realLeft != null && realRight != null && size != null\n\t\t\t\t\t&& (left.getType().isFlat() || left.getType().isArray())) {\n\t\t\t\tunwrapToMemcpy(stack, realLeft, realRight, size);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn super.resolve(stack, res, fatal);\n\t\t\n\t}\n\n\tprivate void unwrapToMemcpy(NodeList<Node> stack, Expression realLeft, Expression realRight, Expression size) {\n\t\t\n\t\tif(realLeft == null || realRight == null || size == null) {\n\t\t\tthrow new Error(\"Heh :/ either of those are null: realLeft = \"+realLeft\n\t\t\t\t\t+\", realRight = \"+realRight+\", size = \"+size);\n\t\t}\n\t\t\n\t\tFunctionCall call = new FunctionCall(\"memcpy\", startToken);\n\t\tNodeList<Expression> args = call.getArguments();\n\t\targs.add(realLeft);\n\t\targs.add(realRight);\n\t\targs.add(size);\n\n\t\t// why test if left is an array?\n\t\t// because when declaring a variable of type which resolves to a TypeParam, e.g.\n\t\t// value: T\n\t\t// Then it translates to\n\t\t// uint8_t value[T->size]\n\t\t// That's an optimization. Thus, this will never be null, and it'll never\n\t\t// need being malloc'd.\n\t\tif(realLeft instanceof Access && !(left.getType().isArray())) {\n\t\t\n\t\t\tBlock block = new Block(startToken);\n\t\t\t\n\t\t\tIf if1 = new If(new Not(realLeft, realLeft.startToken), startToken);\n\t\t\tFunctionCall alloc = new FunctionCall(\"gc_malloc\", startToken);\n\t\t\talloc.getArguments().add(size);\n\t\t\tAssignment allocAss = new Assignment(realLeft,\n\t\t\t\t\talloc, startToken);\n\t\t\tallocAss.dead = true;\n\t\t\tif1.getBody().add(new Line(allocAss));\n\t\t\tblock.getBody().add(new Line(if1));\n\t\t\tblock.getBody().add(new Line(call));\n\t\t\tstack.peek().replace(this, new Line(block));\n\t\t\n\t\t} else {\n\t\t\t\n\t\t\tstack.peek().replace(this, call);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class Assignment extends BinaryOperation {\n\n\tpublic boolean dead = false;\n\t\n\tpublic static enum Mode {\n\t\tREGULAR,\n\t\tADD,\n\t\tSUB,\n\t\tDIV,\n\t\tMUL,\n\t\tB_XOR,\n\t\tB_OR,\n\t\tB_AND,\n\t\tB_LSHIFT,\n\t\tB_RSHIFT,\n\t}\n\t\n\tprotected Mode mode;\n\t\n\tpublic Assignment(Expression left, Expression right, Token startToken) {\n\t\tthis(Mode.REGULAR, left, right, startToken);\n\t}\n\t\n\tpublic Assignment(Mode mode, Expression lvalue, Expression rvalue, Token startToken) {\n\t\tsuper(lvalue, rvalue, startToken);\n\t\tthis.mode = mode;\n\t\tthis.left = lvalue;\n\t\tthis.right = rvalue;\n\t}\n\t\n\tpublic Mode getMode() {\n\t\treturn mode;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\treturn left.getType();\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tleft.accept(visitor);\n\t\tright.accept(visitor);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == left) {\n\t\t\tleft = (Access) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\tif(oldie == right) {\n\t\t\tright = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic String getSymbol() {\n\t\tswitch(mode) {\n\t\t\tcase ADD:\n\t\t\t\treturn \"+=\";\n\t\t\tcase DIV:\n\t\t\t\treturn \"/=\";\n\t\t\tcase MUL:\n\t\t\t\treturn \"*=\";\n\t\t\tcase SUB:\n\t\t\t\treturn \"-=\";\n\t\t\tcase B_AND:\n\t\t\t\treturn \"&=\";\n\t\t\tcase B_LSHIFT:\n\t\t\t\treturn \"<<=\";\n\t\t\tcase B_OR:\n\t\t\t\treturn \"|=\";\n\t\t\tcase B_RSHIFT:\n\t\t\t\treturn \">>=\";\n\t\t\tcase B_XOR:\n\t\t\t\treturn \"^=\";\n\t\t\tcase REGULAR:\n\t\t\t\treturn \"=\";\n\t\t}\n\t\treturn \"unknown\";\n\t}\n\n\t@Override\n\tpublic OpType getOpType() {\n\t\tswitch(mode) {\n\t\tcase ADD:\n\t\t\treturn OpType.ADD_ASS;\n\t\tcase DIV:\n\t\t\treturn OpType.DIV_ASS;\n\t\tcase MUL:\n\t\t\treturn OpType.MUL_ASS;\n\t\tcase SUB:\n\t\t\treturn OpType.SUB_ASS;\n\t\tcase B_XOR:\n\t\t\treturn OpType.B_XOR_ASS;\n\t\tcase B_OR:\n\t\t\treturn OpType.B_OR_ASS;\n\t\tcase B_AND:\n\t\t\treturn OpType.B_AND_ASS;\n\t\tcase B_LSHIFT:\n\t\t\treturn OpType.B_LSHIFT_ASS;\n\t\tcase B_RSHIFT:\n\t\t\treturn OpType.B_RSHIFT_ASS;\n\t\tcase REGULAR:\n\t\t\treturn OpType.ASS;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Assignment: \"+left.toString()+\" = \"+right.toString();\n\t}\n\t\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(dead) return Response.OK;\n\t\t\n\t\tif(right.getType() != null && left.getType() != null) {\n\t\t\tif(left.getType().isSuperOf(right.getType())) {\n\t\t\t\tright = new Cast(right, left.getType(), right.startToken);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(left.getType() == null) {\n\t\t\tif(fatal) throw new OocCompilationError(left, stack, \"Left type of assignment unresolved: \"+left);\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tif(right.getType() == null) {\n\t\t\tif(fatal) throw new OocCompilationError(right, stack, \"Right type of assignment unresolved: \"+right);\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tboolean isGeneric = false;\n\t\tExpression realLeft = null;\n\t\tExpression realRight = null;\n\t\tExpression size = null;\n\t\tif(left.getType().isGeneric()) {\n\t\t\tisGeneric = true;\n\t\t\tTypeParam genericType = (TypeParam) left.getType().getRef();\n\t\t\tVariableAccess tAccess = new VariableAccess(genericType.getName(), startToken);\n\t\t\tsize = new MemberAccess(tAccess, \"size\", startToken);\n\t\t\trealLeft = new AddressOf(left, left.startToken);\n\t\t\trealRight = new AddressOf(right, right.startToken);\n\t\t}\n\t\t/*\n\t\tif(right.getType().isGeneric()) {\n\t\t\tisGeneric = true;\n\t\t\trealRight = new AddressOf(right, right.startToken);\n\t\t}\n\t\t*/\n\t\tif(isGeneric) {\n\t\t\tif(left instanceof ArrayAccess) {\n\t\t\t\tArrayAccess arrAcc = (ArrayAccess) left;\n\t\t\t\tExpression var = arrAcc.getVariable();\n\t\t\t\tif(var.getType().isGeneric()) {\n\t\t\t\t\tVariableAccess tAccess = new VariableAccess(var.getType().getRef().getName(), startToken);\n\t\t\t\t\tMemberAccess sizeAccess = new MemberAccess(tAccess, \"size\", startToken);\n\t\t\t\t\trealLeft = new Add(arrAcc.variable, new Mul(arrAcc.index, sizeAccess, startToken), startToken);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(right instanceof ArrayAccess) {\n\t\t\t\tArrayAccess arrAcc = (ArrayAccess) right;\n\t\t\t\tExpression var = arrAcc.getVariable();\n\t\t\t\tif(var.getType().isGeneric()) {\n\t\t\t\t\tVariableAccess tAccess = new VariableAccess(var.getType().getRef().getName(), startToken);\n\t\t\t\t\tMemberAccess sizeAccess = new MemberAccess(tAccess, \"size\", startToken);\n\t\t\t\t\trealRight = new Add(arrAcc.variable, new Mul(arrAcc.index, sizeAccess, startToken), startToken);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(realLeft != null && realRight != null && size != null\n\t\t\t\t\t&& (left.getType().isFlat() || left.getType().isArray())) {\n\t\t\t\tunwrapToMemcpy(stack, realLeft, realRight, size);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn super.resolve(stack, res, fatal);\n\t\t\n\t}\n\n\tprivate void unwrapToMemcpy(NodeList<Node> stack, Expression realLeft, Expression realRight, Expression size) {\n\t\t\n\t\tif(realLeft == null || realRight == null || size == null) {\n\t\t\tthrow new Error(\"Heh :/ either of those are null: realLeft = \"+realLeft\n\t\t\t\t\t+\", realRight = \"+realRight+\", size = \"+size);\n\t\t}\n\t\t\n\t\tFunctionCall call = new FunctionCall(\"memcpy\", startToken);\n\t\tNodeList<Expression> args = call.getArguments();\n\t\targs.add(realLeft);\n\t\targs.add(realRight);\n\t\targs.add(size);\n\t\t\n\t\tNode parent = stack.peek();\n\n\t\t// why test if left is an array?\n\t\t// because when declaring a variable of type which resolves to a TypeParam, e.g.\n\t\t// value: T\n\t\t// Then it translates to\n\t\t// uint8_t value[T->size]\n\t\t// That's an optimization. Thus, this will never be null, and it'll never\n\t\t// need being malloc'd.\n\t\tif(realLeft instanceof Access && !(left.getType().isArray())) {\n\t\t\n\t\t\tBlock block = new Block(startToken);\n\t\t\t\n\t\t\tIf if1 = new If(new Not(realLeft, realLeft.startToken), startToken);\n\t\t\tFunctionCall alloc = new FunctionCall(\"gc_malloc\", startToken);\n\t\t\talloc.getArguments().add(size);\n\t\t\tAssignment allocAss = new Assignment(realLeft,\n\t\t\t\t\talloc, startToken);\n\t\t\tallocAss.dead = true;\n\t\t\tif1.getBody().add(new Line(allocAss));\n\t\t\tblock.getBody().add(new Line(if1));\n\t\t\tblock.getBody().add(new Line(call));\n\t\t\t\n\t\t\t// FIXME I'm not entirely sure this is right.\n\t\t\tif(parent instanceof NodeList) {\n\t\t\t\tparent.replace(this, new Line(block));\n\t\t\t} else {\n\t\t\t\tparent.replace(this, block);\n\t\t\t}\n\t\t\n\t\t} else {\n\t\t\t\n\t\t\tparent.replace(this, call);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\n","lineNo":217}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ArrayAccess extends Access implements MustBeResolved {\n\n\tType type;\n\tprotected Expression variable;\n\tprotected Expression index;\n\n\tpublic ArrayAccess(Expression variable, Expression index, Token token) {\n\t\tsuper(token);\n\t\tthis.variable = variable;\n\t\tthis.index = index;\n\t}\n\t\n\tpublic Expression getVariable() {\n\t\treturn variable;\n\t}\n\t\n\tpublic void setVariable(Expression variable) {\n\t\tthis.variable = variable;\n\t}\n\n\tpublic Expression getIndex() {\n\t\treturn index;\n\t}\n\t\n\tpublic void setIndex(Expression index) {\n\t\tthis.index = index;\n\t}\n\t\n\tpublic Type getType() {\n\t\tif(type == null) {\n\t\t\tType exprType = variable.getType();\n\t\t\tif(exprType != null) {\n\t\t\t\tDeclaration ref = exprType.getRef();\n\t\t\t\tif(ref instanceof CoverDecl) {\n\t\t\t\t\tType fromType = ((CoverDecl) ref).getFromType();\n\t\t\t\t\tif(fromType != null && fromType.getRef() instanceof CoverDecl) exprType = fromType;\n\t\t\t\t}\n\t\t\t\ttype = new Type(exprType.getName(), exprType.getPointerLevel() - 1, exprType.startToken);\n\t\t\t\ttype.setRef(exprType.getRef());\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tvariable.accept(visitor);\n\t\tindex.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(oldie == variable) {\n\t\t\tvariable = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == index) {\n\t\t\tindex = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tint assignIndex = stack.find(Assignment.class);\n\t\t\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tif(tryOp(stack, res, assignIndex, op)) return Response.RESTART;\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tif(tryOp(stack, res, assignIndex, op)) return Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate boolean tryOp(NodeList<Node> stack, Resolver res, int assignIndex, OpDecl op)\n\t\tthrows OocCompilationError {\n\t\t\n\t\tif(assignIndex == -1) {\n\t\t\tif(tryIndexing(op, stack, res)) return true;\n\t\t} else {\n\t\t\tif(tryIndexedAssign(op, stack, res, assignIndex)) return true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\n\tprotected boolean tryIndexedAssign(OpDecl op, NodeList<Node> stack, Resolver res, int assignIndex) throws OocCompilationError {\n\t\t\n\t\tif(op.getOpType() != OpType.IDX_ASS) return false;\n\t\t\n\t\tAssignment ass = (Assignment) stack.get(assignIndex);\n\t\tif(ass.getLeft() != this) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(op.getFunc().getArguments().size() != 3) {\n\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\"To overload the indexed assign operator, you need exactly three arguments, not \"\n\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t}\n\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\tif(args.get(0).getType().softEquals(variable.getType(), res)\n\t\t\t\t&& args.get(1).getType().softEquals(index.getType(), res)) {\n\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\tcall.getArguments().add(variable);\n\t\t\tcall.getArguments().add(index);\n\t\t\tcall.getArguments().add(ass.getRight());\n\t\t\tif(!stack.get(assignIndex - 1).replace(ass, call)) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace array-access-assign with a function call\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprotected boolean tryIndexing(OpDecl op, NodeList<Node> stack, Resolver res) throws OocCompilationError {\n\t\t\n\t\tif(op.getOpType() != OpType.IDX) return false;\n\t\t\n\t\tif(op.getFunc().getArguments().size() != 2) {\n\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\"To overload the indexing operator, you need exactly two arguments, not \"\n\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t}\n\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\tif(args.get(0).getType().softEquals(variable.getType(), res)\n\t\t\t\t&& args.get(1).getType().softEquals(index.getType(), res)) {\n\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\tcall.getArguments().add(variable);\n\t\t\tcall.getArguments().add(index);\n\t\t\tstack.peek().replace(this, call);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \"|\" + variable + \"[\"+index+\"]\";\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.OpDecl.OpType;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ArrayAccess extends Access implements MustBeResolved {\n\n\tType type;\n\tprotected Expression variable;\n\tprotected Expression index;\n\n\tpublic ArrayAccess(Expression variable, Expression index, Token token) {\n\t\tsuper(token);\n\t\tthis.variable = variable;\n\t\tthis.index = index;\n\t}\n\t\n\tpublic Expression getVariable() {\n\t\treturn variable;\n\t}\n\t\n\tpublic void setVariable(Expression variable) {\n\t\tthis.variable = variable;\n\t}\n\n\tpublic Expression getIndex() {\n\t\treturn index;\n\t}\n\t\n\tpublic void setIndex(Expression index) {\n\t\tthis.index = index;\n\t}\n\t\n\tpublic Type getType() {\n\t\tif(type == null) {\n\t\t\tType exprType = variable.getType();\n\t\t\tif(exprType != null) {\n\t\t\t\tDeclaration ref = exprType.getRef();\n\t\t\t\tif(ref instanceof CoverDecl) {\n\t\t\t\t\tType fromType = ((CoverDecl) ref).getFromType();\n\t\t\t\t\tif(fromType != null && fromType.getRef() instanceof CoverDecl) {\n\t\t\t\t\t\tType clone = fromType.clone();\n\t\t\t\t\t\tclone.setPointerLevel(exprType.getPointerLevel() + fromType.getPointerLevel());\n\t\t\t\t\t\texprType = clone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttype = new Type(exprType.getName(), exprType.getPointerLevel() - 1, exprType.startToken);\n\t\t\t\ttype.setRef(exprType.getRef());\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t}\n\t\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tvariable.accept(visitor);\n\t\tindex.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(oldie == variable) {\n\t\t\tvariable = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(oldie == index) {\n\t\t\tindex = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tint assignIndex = stack.find(Assignment.class);\n\t\t\n\t\tfor(OpDecl op: res.module.getOps()) {\n\t\t\tif(tryOp(stack, res, assignIndex, op)) return Response.RESTART;\n\t\t}\n\t\tfor(Import imp: res.module.getImports()) {\n\t\t\tfor(OpDecl op: imp.getModule().getOps()) {\n\t\t\t\tif(tryOp(stack, res, assignIndex, op)) return Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate boolean tryOp(NodeList<Node> stack, Resolver res, int assignIndex, OpDecl op)\n\t\tthrows OocCompilationError {\n\t\t\n\t\tif(assignIndex == -1) {\n\t\t\tif(tryIndexing(op, stack, res)) return true;\n\t\t} else {\n\t\t\tif(tryIndexedAssign(op, stack, res, assignIndex)) return true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\n\tprotected boolean tryIndexedAssign(OpDecl op, NodeList<Node> stack, Resolver res, int assignIndex) throws OocCompilationError {\n\t\t\n\t\tif(op.getOpType() != OpType.IDX_ASS) return false;\n\t\t\n\t\tAssignment ass = (Assignment) stack.get(assignIndex);\n\t\tif(ass.getLeft() != this) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(op.getFunc().getArguments().size() != 3) {\n\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\"To overload the indexed assign operator, you need exactly three arguments, not \"\n\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t}\n\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\tif(args.get(0).getType().softEquals(variable.getType(), res)\n\t\t\t\t&& args.get(1).getType().softEquals(index.getType(), res)) {\n\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\tcall.getArguments().add(variable);\n\t\t\tcall.getArguments().add(index);\n\t\t\tcall.getArguments().add(ass.getRight());\n\t\t\tif(!stack.get(assignIndex - 1).replace(ass, call)) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace array-access-assign with a function call\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprotected boolean tryIndexing(OpDecl op, NodeList<Node> stack, Resolver res) throws OocCompilationError {\n\t\t\n\t\tif(op.getOpType() != OpType.IDX) return false;\n\t\t\n\t\tif(op.getFunc().getArguments().size() != 2) {\n\t\t\tthrow new OocCompilationError(op, stack,\n\t\t\t\t\t\"To overload the indexing operator, you need exactly two arguments, not \"\n\t\t\t\t\t+op.getFunc().getArgsRepr());\n\t\t}\n\t\tNodeList<Argument> args = op.getFunc().getArguments();\n\t\tif(args.get(0).getType().softEquals(variable.getType(), res)\n\t\t\t\t&& args.get(1).getType().softEquals(index.getType(), res)) {\n\t\t\tFunctionCall call = new FunctionCall(op.getFunc(), startToken);\n\t\t\tcall.getArguments().add(variable);\n\t\t\tcall.getArguments().add(index);\n\t\t\tstack.peek().replace(this, call);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \"|\" + variable + \"[\"+index+\"]\";\n\t}\n\t\n}\n","lineNo":48}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\t\t\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\treturn arguments.get(i).getType();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tdeclType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix.length() == 0 || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\t\t\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tType result = null;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tType argType = arg.getType();\n\t\t\tif(argType.getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i).getType();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(argType.isGenericRecursive()) {\n\t\t\t\tExpression resultExpr = getRealExpr(typeParam, argType, stack, res, fatal);\n\t\t\t\tif(resultExpr != null && resultExpr.getType() != null) {\n\t\t\t\t\tresult = resultExpr.getType();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tType argType = arg.getType();\n\t\t\tif(argType.getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(argType.isGenericRecursive()) {\n\t\t\t\tresult = getRealExpr(typeParam, argType, stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprivate Expression getRealExpr(String typeParam, Type argType,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = argType.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(typeParam)) {\n\t\t\t\t\tAccess match = argType.getTypeParams().get(i);\n\t\t\t\t\tType realType = getRealType(argType.getName(), stack, res, fatal);\n\t\t\t\t\tAccess realMatch = realType.getTypeParams().get(i);\n\t\t\t\t\treturn realMatch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tdeclType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix.length() == 0 || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tThread.dumpStack();\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","lineNo":265}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\t\t\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\treturn arguments.get(i).getType();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tdeclType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix.length() == 0 || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\t\t\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tType result = null;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tType argType = arg.getType();\n\t\t\tif(argType.getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i).getType();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(argType.isGenericRecursive()) {\n\t\t\t\tExpression resultExpr = getRealExpr(typeParam, argType, stack, res, fatal);\n\t\t\t\tif(resultExpr != null && resultExpr.getType() != null) {\n\t\t\t\t\tresult = resultExpr.getType();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tType argType = arg.getType();\n\t\t\tif(argType.getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(argType.isGenericRecursive()) {\n\t\t\t\tresult = getRealExpr(typeParam, argType, stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprivate Expression getRealExpr(String typeParam, Type argType,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = argType.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(typeParam)) {\n\t\t\t\t\tAccess match = argType.getTypeParams().get(i);\n\t\t\t\t\tType realType = getRealType(argType.getName(), stack, res, fatal);\n\t\t\t\t\tAccess realMatch = realType.getTypeParams().get(i);\n\t\t\t\t\treturn realMatch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tdeclType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix.length() == 0 || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tThread.dumpStack();\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","lineNo":272}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\t\t\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\treturn arguments.get(i).getType();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tdeclType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix.length() == 0 || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\t\t\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tType result = null;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tType argType = arg.getType();\n\t\t\tif(argType.getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i).getType();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(argType.isGenericRecursive()) {\n\t\t\t\tExpression resultExpr = getRealExpr(typeParam, argType, stack, res, fatal);\n\t\t\t\tif(resultExpr != null && resultExpr.getType() != null) {\n\t\t\t\t\tresult = resultExpr.getType();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tType argType = arg.getType();\n\t\t\tif(argType.getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(argType.isGenericRecursive()) {\n\t\t\t\tresult = getRealExpr(typeParam, argType, stack, res, fatal);\n\t\t\t\tif(result != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprivate Expression getRealExpr(String typeParam, Type argType,\n\t\t\tNodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\tDeclaration ref = argType.getRef();\n\t\tif(ref instanceof TypeDecl) {\n\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\tIterator<String> keys = typeDecl.getTypeParams().keySet().iterator();\n\t\t\tint i = -1;\n\t\t\twhile(keys.hasNext()) {\n\t\t\t\ti++;\n\t\t\t\tString key = keys.next();\n\t\t\t\tif(key.equals(typeParam)) {\n\t\t\t\t\tAccess match = argType.getTypeParams().get(i);\n\t\t\t\t\tType realType = getRealType(argType.getName(), stack, res, fatal);\n\t\t\t\t\tAccess realMatch = realType.getTypeParams().get(i);\n\t\t\t\t\treturn realMatch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tdeclType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix.length() == 0 || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext() && declIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tThread.dumpStack();\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","lineNo":304}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.backend.Generator;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ArrayLiteral;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.Block;\nimport org.ooc.frontend.model.BoolLiteral;\nimport org.ooc.frontend.model.BuiltinType;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.CharLiteral;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Else;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FloatLiteral;\nimport org.ooc.frontend.model.FlowControl;\nimport org.ooc.frontend.model.Foreach;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.If;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.InterfaceDecl;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberArgument;\nimport org.ooc.frontend.model.MemberAssignArgument;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.NullLiteral;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.RegularArgument;\nimport org.ooc.frontend.model.Return;\nimport org.ooc.frontend.model.StringLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.ValuedReturn;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.While;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.TypeArgument;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ubi.SourceReader;\n\npublic class CGenerator extends Generator implements Visitor {\n\n\tpublic final AwesomeWriter hw;\n\tpublic final AwesomeWriter cw;\n\tpublic AwesomeWriter current;\n\n\tpublic CGenerator(File outPath, Module module) throws IOException {\n\t\tsuper(outPath, module);\n\t\tString basePath = module.getFullName().replace('.', File.separatorChar);\n\t\tFile hFile = new File(outPath, basePath + \".h\");\n\t\thFile.getParentFile().mkdirs();\n\t\tthis.hw = new AwesomeWriter(new FileWriter(hFile));\n\t\tFile cFile = new File(outPath, basePath + \".c\");\n\t\tthis.cw = new AwesomeWriter(new FileWriter(cFile));\n\t\tthis.current = hw;\n\t}\n\n\t@Override\n\tpublic void generate(BuildParams params) throws IOException {\n\t\tmodule.accept(this);\n\t\thw.close();\n\t\tcw.close();\n\t}\n\n\tpublic void visit(Module module) throws IOException {\n\t\tModuleWriter.write(module, this);\n\t}\n\n\tpublic void visit(Add add) throws IOException {\n\t\tadd.getLeft().accept(this);\n\t\tcurrent.app(\" + \");\n\t\tadd.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Mul mul) throws IOException {\n\t\tmul.getLeft().accept(this);\n\t\tcurrent.app(\" * \");\n\t\tmul.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Sub sub) throws IOException {\n\t\tsub.getLeft().accept(this);\n\t\tcurrent.app(\" - \");\n\t\tsub.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Div div) throws IOException {\n\t\tdiv.getLeft().accept(this);\n\t\tcurrent.app(\" / \");\n\t\tdiv.getRight().accept(this);\n\t}\n\n\tpublic void visit(Not not) throws IOException {\n\t\tcurrent.app('!');\n\t\tnot.getExpression().accept(this);\t\t\n\t}\n\t\n\tpublic void visit(Mod mod) throws IOException {\n\t\tmod.getLeft().accept(this);\n\t\tcurrent.app(\" % \");\n\t\tmod.getRight().accept(this);\n\t}\n\t\n\tpublic void visit(Compare compare) throws IOException {\n\t\tcompare.getLeft().accept(this);\n\t\tswitch(compare.getCompareType()) {\n\t\t\tcase GREATER: current.app(\" > \"); break;\n\t\t\tcase GREATER_OR_EQUAL: current.app(\" >= \"); break;\n\t\t\tcase LESSER: current.app(\" < \"); break;\n\t\t\tcase LESSER_OR_EQUAL: current.app(\" <= \"); break;\n\t\t\tcase EQUAL: current.app(\" == \"); break;\n\t\t\tcase NOT_EQUAL: current.app(\" != \"); break;\n\t\t}\n\t\tcompare.getRight().accept(this);\n\t}\n\n\tpublic void visit(FunctionCall functionCall) throws IOException {\n\t\tCallWriter.write(functionCall, this);\n\t}\n\n\tpublic void visit(MemberCall memberCall) throws IOException {\n\t\tCallWriter.writeMember(memberCall, this);\n\t}\n\n\tpublic void visit(Parenthesis parenthesis) throws IOException {\n\t\tcurrent.app('(');\n\t\tparenthesis.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Assignment assignment) throws IOException {\n\t\tExpression left = assignment.getLeft();\n\t\tif(left instanceof VariableAccess) {\n\t\t\tAccessWriter.write((VariableAccess) left, false, this);\n\t\t} else {\n\t\t\tleft.accept(this);\n\t\t}\n\t\tcurrent.app(' ').app(assignment.getSymbol()).app(' ');\n\t\tassignment.getRight().accept(this);\n\t}\n\n\tpublic void visit(ValuedReturn return1) throws IOException {\n\t\tcurrent.app(\"return \");\n\t\treturn1.getExpression().accept(this);\n\t}\n\t\n\tpublic void visit(Return return1) throws IOException {\n\t\tcurrent.app(\"return\");\n\t}\n\n\tpublic void visit(NullLiteral nullLiteral) throws IOException {\n\t\tLiteralWriter.writeNull(this);\n\t}\n\n\tpublic void visit(IntLiteral numberLiteral) throws IOException {\n\t\tLiteralWriter.writeInt(numberLiteral, this);\n\t}\n\t\n\tpublic void visit(FloatLiteral floatLiteral) throws IOException {\n\t\tLiteralWriter.writeFloat(floatLiteral, this);\n\t}\n\n\tpublic void visit(StringLiteral stringLiteral) throws IOException {\n\t\tLiteralWriter.writeString(stringLiteral, this);\n\t}\n\n\tpublic void visit(RangeLiteral rangeLiteral) throws IOException {\n\t\tthrow new OocCompilationError(rangeLiteral, module,\n\t\t\t\t\"Using a range literal outside a foreach is not supported yet.\");\n\t}\n\n\tpublic void visit(BoolLiteral boolLiteral) throws IOException {\n\t\tcurrent.app(boolLiteral.getValue() ? \"true\" : \"false\");\n\t}\n\n\tpublic void visit(CharLiteral charLiteral) throws IOException {\n\t\tcurrent.app('\\'').app(SourceReader.spelled(charLiteral.getValue())).app('\\'');\t\t\n\t}\n\n\tpublic void visit(Line line) throws IOException {\n\t\tcurrent.nl();\n\t\tif(line.getStatement() instanceof FunctionCall) CallWriter.noCast = (FunctionCall) line.getStatement();\n\t\tline.getStatement().accept(this);\n\t\tif(!(line.getStatement() instanceof ControlStatement)) {\n\t\t\tcurrent.app(';');\n\t\t}\n\t}\n\n\tpublic void visit(Include include) throws IOException {}\n\n\tpublic void visit(If if1) throws IOException {\n\t\tControlStatementWriter.writeIf(if1, this);\n\t}\n\t\n\tpublic void visit(Else else1) throws IOException {\n\t\tControlStatementWriter.writeElse(else1, this);\n\t}\n\n\tpublic void visit(While while1) throws IOException {\n\t\tControlStatementWriter.writeWhile(while1, this);\n\t}\n\n\tpublic void visit(Foreach foreach) throws IOException {\n\t\tControlStatementWriter.writeForeach(foreach, this);\n\t}\n\n\tpublic void visit(MemberAccess memberAccess) throws IOException {\n\t\tAccessWriter.writeMember(memberAccess, this);\n\t}\n\t\n\tpublic void visit(VariableAccess variableAccess) throws IOException {\n\t\tAccessWriter.writeVariable(variableAccess, true, this);\n\t}\n\n\tpublic void visit(ArrayAccess arrayAccess) throws IOException {\n\t\tAccessWriter.writeArray(arrayAccess, this);\n\t}\n\n\tpublic void visit(VariableDecl variableDecl) throws IOException {\n\t\tVariableDeclWriter.write(variableDecl, this);\n\t}\n\n\tpublic void visit(FunctionDecl functionDecl) throws IOException {\n\t\tFunctionDeclWriter.write(functionDecl, this);\n\t}\n\n\tpublic void visit(ClassDecl classDecl) throws IOException {\n\t\tClassDeclWriter.write(classDecl, this);\n\t}\n\t\n\tpublic void visit(CoverDecl cover) throws IOException {\n\t\tCoverDeclWriter.write(cover, this);\n\t}\n\t\n\tpublic void visit(TypeArgument typeArgument) throws IOException {\n\t\ttypeArgument.getType().accept(this);\n\t}\n\n\tpublic void visit(RegularArgument regularArgument) throws IOException {\n\t\tType type = regularArgument.getType();\n\t\tif(type.isArray()) {\n\t\t\tcurrent.app(type.getName()).app(' ').app(regularArgument.getName());\n\t\t\tfor(int i = 0; i < type.getPointerLevel(); i++) {\n\t\t\t\tcurrent.app(\"[]\");\n\t\t\t}\n\t\t} else {\n\t\t\tif(type instanceof FuncType) {\n\t\t\t\tTypeWriter.writeFuncPointer((FunctionDecl) type.getRef(), regularArgument.getName(), this);\n\t\t\t} else {\n\t\t\t\tTypeWriter.writeSpaced(type, this);\n\t\t\t\tcurrent.app(regularArgument.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void visit(MemberArgument memberArgument) throws IOException {}\n\n\tpublic void visit(MemberAssignArgument memberArgument) throws IOException {}\n\n\tpublic void visit(Type type) throws IOException {\n\t\tTypeWriter.write(type, this);\n\t}\n\n\tpublic void visit(VarArg varArg) throws IOException {\n\t\tcurrent.app(\"...\");\n\t}\n\t\n\tpublic void visit(NodeList<? extends Node> list) throws IOException {\n\t\tlist.acceptChildren(this);\n\t}\n\t\n\tpublic void visit(Block block) throws IOException {\n\t\tcurrent.openBlock();\n\t\tblock.acceptChildren(this);\n\t\tcurrent.closeBlock();\n\t}\n\n\tpublic void visit(BuiltinType builtinType) throws IOException {}\n\n\tpublic void visit(VariableDeclAtom variableDeclAtom) throws IOException {}\n\t\n\tpublic void visit(Cast cast) throws IOException {\n\t\tCastWriter.write(cast, this);\n\t}\n\n\tpublic void visit(AddressOf addressOf) throws IOException {\n\t\tif(addressOf.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) addressOf.getExpression();\n\t\t\tif(varAcc.getRef().getType().getRef() instanceof TypeParam) {\n\t\t\t\tAccessWriter.write(varAcc, false, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcurrent.app(\"&(\");\n\t\taddressOf.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Dereference dereference) throws IOException {\n\t\tcurrent.app(\"(*\");\n\t\tdereference.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(OpDecl opDecl) throws IOException {\n\t\topDecl.getFunc().accept(this);\n\t}\n\n\tpublic void visit(Import import1) throws IOException {}\n\t\n\tpublic void visit(ArrayLiteral arrayLiteral) throws IOException {\n\t\tcurrent.app('{');\n\t\tIterator<Expression> iter = arrayLiteral.getElements().iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\titer.next().accept(this);\n\t\t\tif(iter.hasNext()) current.app(\", \");\n\t\t}\n\t\tcurrent.app('}');\n\t}\n\n\tpublic void visit(Use use) throws IOException {}\n\n\tpublic void visit(BinaryCombination binaryCombination) throws IOException {\n\t\tbinaryCombination.getLeft().accept(this);\n\t\tcurrent.app(' ').app(binaryCombination.getOpString()).app(' ');\n\t\tbinaryCombination.getRight().accept(this);\n\t}\n\n\tpublic void visit(MultiMap<?, ?> list) throws IOException {}\n\n\tpublic void visit(FlowControl flow) throws IOException {\n\t\tcurrent.app(flow.getKeyword()).app(\";\");\n\t}\n\n\tpublic void visit(InterfaceDecl interfaceDecl) throws IOException {\n\t\t// huh.. slack off?\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.backend.Generator;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ArrayLiteral;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.Block;\nimport org.ooc.frontend.model.BoolLiteral;\nimport org.ooc.frontend.model.BuiltinType;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.CharLiteral;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Else;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FloatLiteral;\nimport org.ooc.frontend.model.FlowControl;\nimport org.ooc.frontend.model.Foreach;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.If;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.InterfaceDecl;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberArgument;\nimport org.ooc.frontend.model.MemberAssignArgument;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.NullLiteral;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.RegularArgument;\nimport org.ooc.frontend.model.Return;\nimport org.ooc.frontend.model.StringLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.ValuedReturn;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.While;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.TypeArgument;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ubi.SourceReader;\n\npublic class CGenerator extends Generator implements Visitor {\n\n\tpublic final AwesomeWriter hw;\n\tpublic final AwesomeWriter cw;\n\tpublic AwesomeWriter current;\n\n\tpublic CGenerator(File outPath, Module module) throws IOException {\n\t\tsuper(outPath, module);\n\t\tString basePath = module.getFullName().replace('.', File.separatorChar);\n\t\tFile hFile = new File(outPath, basePath + \".h\");\n\t\thFile.getParentFile().mkdirs();\n\t\tthis.hw = new AwesomeWriter(new FileWriter(hFile));\n\t\tFile cFile = new File(outPath, basePath + \".c\");\n\t\tthis.cw = new AwesomeWriter(new FileWriter(cFile));\n\t\tthis.current = hw;\n\t}\n\n\t@Override\n\tpublic void generate(BuildParams params) throws IOException {\n\t\tmodule.accept(this);\n\t\thw.close();\n\t\tcw.close();\n\t}\n\n\tpublic void visit(Module module) throws IOException {\n\t\tModuleWriter.write(module, this);\n\t}\n\n\tpublic void visit(Add add) throws IOException {\n\t\tadd.getLeft().accept(this);\n\t\tcurrent.app(\" + \");\n\t\tadd.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Mul mul) throws IOException {\n\t\tmul.getLeft().accept(this);\n\t\tcurrent.app(\" * \");\n\t\tmul.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Sub sub) throws IOException {\n\t\tsub.getLeft().accept(this);\n\t\tcurrent.app(\" - \");\n\t\tsub.getRight().accept(this);\t\t\n\t}\n\n\tpublic void visit(Div div) throws IOException {\n\t\tdiv.getLeft().accept(this);\n\t\tcurrent.app(\" / \");\n\t\tdiv.getRight().accept(this);\n\t}\n\n\tpublic void visit(Not not) throws IOException {\n\t\tcurrent.app('!');\n\t\tnot.getExpression().accept(this);\t\t\n\t}\n\t\n\tpublic void visit(Mod mod) throws IOException {\n\t\tmod.getLeft().accept(this);\n\t\tcurrent.app(\" % \");\n\t\tmod.getRight().accept(this);\n\t}\n\t\n\tpublic void visit(Compare compare) throws IOException {\n\t\tcompare.getLeft().accept(this);\n\t\tswitch(compare.getCompareType()) {\n\t\t\tcase GREATER: current.app(\" > \"); break;\n\t\t\tcase GREATER_OR_EQUAL: current.app(\" >= \"); break;\n\t\t\tcase LESSER: current.app(\" < \"); break;\n\t\t\tcase LESSER_OR_EQUAL: current.app(\" <= \"); break;\n\t\t\tcase EQUAL: current.app(\" == \"); break;\n\t\t\tcase NOT_EQUAL: current.app(\" != \"); break;\n\t\t}\n\t\tcompare.getRight().accept(this);\n\t}\n\n\tpublic void visit(FunctionCall functionCall) throws IOException {\n\t\tCallWriter.write(functionCall, this);\n\t}\n\n\tpublic void visit(MemberCall memberCall) throws IOException {\n\t\tCallWriter.writeMember(memberCall, this);\n\t}\n\n\tpublic void visit(Parenthesis parenthesis) throws IOException {\n\t\tcurrent.app('(');\n\t\tparenthesis.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Assignment assignment) throws IOException {\n\t\tExpression left = assignment.getLeft();\n\t\tif(left instanceof VariableAccess) {\n\t\t\tAccessWriter.write((VariableAccess) left, false, this);\n\t\t} else {\n\t\t\tleft.accept(this);\n\t\t}\n\t\tcurrent.app(' ').app(assignment.getSymbol()).app(' ');\n\t\tassignment.getRight().accept(this);\n\t}\n\n\tpublic void visit(ValuedReturn return1) throws IOException {\n\t\tcurrent.app(\"return \");\n\t\treturn1.getExpression().accept(this);\n\t}\n\t\n\tpublic void visit(Return return1) throws IOException {\n\t\tcurrent.app(\"return\");\n\t}\n\n\tpublic void visit(NullLiteral nullLiteral) throws IOException {\n\t\tLiteralWriter.writeNull(this);\n\t}\n\n\tpublic void visit(IntLiteral numberLiteral) throws IOException {\n\t\tLiteralWriter.writeInt(numberLiteral, this);\n\t}\n\t\n\tpublic void visit(FloatLiteral floatLiteral) throws IOException {\n\t\tLiteralWriter.writeFloat(floatLiteral, this);\n\t}\n\n\tpublic void visit(StringLiteral stringLiteral) throws IOException {\n\t\tLiteralWriter.writeString(stringLiteral, this);\n\t}\n\n\tpublic void visit(RangeLiteral rangeLiteral) throws IOException {\n\t\tthrow new OocCompilationError(rangeLiteral, module,\n\t\t\t\t\"Using a range literal outside a foreach is not supported yet.\");\n\t}\n\n\tpublic void visit(BoolLiteral boolLiteral) throws IOException {\n\t\tcurrent.app(boolLiteral.getValue() ? \"true\" : \"false\");\n\t}\n\n\tpublic void visit(CharLiteral charLiteral) throws IOException {\n\t\tcurrent.app('\\'').app(SourceReader.spelled(charLiteral.getValue())).app('\\'');\t\t\n\t}\n\n\tpublic void visit(Line line) throws IOException {\n\t\tcurrent.nl();\n\t\tif(line.getStatement() instanceof FunctionCall) CallWriter.noCast = (FunctionCall) line.getStatement();\n\t\tline.getStatement().accept(this);\n\t\tif(!(line.getStatement() instanceof ControlStatement)) {\n\t\t\tcurrent.app(';');\n\t\t}\n\t}\n\n\tpublic void visit(Include include) throws IOException {}\n\n\tpublic void visit(If if1) throws IOException {\n\t\tControlStatementWriter.writeIf(if1, this);\n\t}\n\t\n\tpublic void visit(Else else1) throws IOException {\n\t\tControlStatementWriter.writeElse(else1, this);\n\t}\n\n\tpublic void visit(While while1) throws IOException {\n\t\tControlStatementWriter.writeWhile(while1, this);\n\t}\n\n\tpublic void visit(Foreach foreach) throws IOException {\n\t\tControlStatementWriter.writeForeach(foreach, this);\n\t}\n\n\tpublic void visit(MemberAccess memberAccess) throws IOException {\n\t\tAccessWriter.writeMember(memberAccess, this);\n\t}\n\t\n\tpublic void visit(VariableAccess variableAccess) throws IOException {\n\t\tAccessWriter.writeVariable(variableAccess, true, this);\n\t}\n\n\tpublic void visit(ArrayAccess arrayAccess) throws IOException {\n\t\tAccessWriter.writeArray(arrayAccess, this);\n\t}\n\n\tpublic void visit(VariableDecl variableDecl) throws IOException {\n\t\tVariableDeclWriter.write(variableDecl, this);\n\t}\n\n\tpublic void visit(FunctionDecl functionDecl) throws IOException {\n\t\tFunctionDeclWriter.write(functionDecl, this);\n\t}\n\n\tpublic void visit(ClassDecl classDecl) throws IOException {\n\t\tClassDeclWriter.write(classDecl, this);\n\t}\n\t\n\tpublic void visit(CoverDecl cover) throws IOException {\n\t\tCoverDeclWriter.write(cover, this);\n\t}\n\t\n\tpublic void visit(TypeArgument typeArgument) throws IOException {\n\t\ttypeArgument.getType().accept(this);\n\t}\n\n\tpublic void visit(RegularArgument regularArgument) throws IOException {\n\t\tType type = regularArgument.getType();\n\t\tif(type.isArray()) {\n\t\t\tcurrent.app(type.getName()).app(' ').app(regularArgument.getName());\n\t\t\tfor(int i = 0; i < type.getPointerLevel(); i++) {\n\t\t\t\tcurrent.app(\"[]\");\n\t\t\t}\n\t\t} else {\n\t\t\tif(type instanceof FuncType) {\n\t\t\t\tTypeWriter.writeFuncPointer((FunctionDecl) type.getRef(), regularArgument.getName(), this);\n\t\t\t} else {\n\t\t\t\tTypeWriter.writeSpaced(type, this);\n\t\t\t\tcurrent.app(regularArgument.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void visit(MemberArgument memberArgument) throws IOException {}\n\n\tpublic void visit(MemberAssignArgument memberArgument) throws IOException {}\n\n\tpublic void visit(Type type) throws IOException {\n\t\tTypeWriter.write(type, this);\n\t}\n\n\tpublic void visit(VarArg varArg) throws IOException {\n\t\tcurrent.app(\"...\");\n\t}\n\t\n\tpublic void visit(NodeList<? extends Node> list) throws IOException {\n\t\tlist.acceptChildren(this);\n\t}\n\t\n\tpublic void visit(Block block) throws IOException {\n\t\tcurrent.openBlock();\n\t\tblock.acceptChildren(this);\n\t\tcurrent.closeBlock();\n\t}\n\n\tpublic void visit(BuiltinType builtinType) throws IOException {}\n\n\tpublic void visit(VariableDeclAtom variableDeclAtom) throws IOException {}\n\t\n\tpublic void visit(Cast cast) throws IOException {\n\t\tCastWriter.write(cast, this);\n\t}\n\n\tpublic void visit(AddressOf addressOf) throws IOException {\n\t\tif(addressOf.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) addressOf.getExpression();\n\t\t\tif(varAcc.getRef().getType().getRef() instanceof TypeParam) {\n\t\t\t\tAccessWriter.write(varAcc, false, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcurrent.app(\"&(\");\n\t\taddressOf.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(Dereference dereference) throws IOException {\n\t\tcurrent.app(\"(*\");\n\t\tdereference.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\tpublic void visit(OpDecl opDecl) throws IOException {\n\t\topDecl.getFunc().accept(this);\n\t}\n\n\tpublic void visit(Import import1) throws IOException {}\n\t\n\tpublic void visit(ArrayLiteral arrayLiteral) throws IOException {\n\t\tcurrent.app('{');\n\t\tIterator<Expression> iter = arrayLiteral.getElements().iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression element = iter.next();\n\t\t\tif(!element.getType().getName().equals(arrayLiteral.getType().getName())) {\n\t\t\t\t\n\t\t\t}\n\t\t\telement.accept(this);\n\t\t\tif(iter.hasNext()) current.app(\", \");\n\t\t}\n\t\tcurrent.app('}');\n\t}\n\n\tpublic void visit(Use use) throws IOException {}\n\n\tpublic void visit(BinaryCombination binaryCombination) throws IOException {\n\t\tbinaryCombination.getLeft().accept(this);\n\t\tcurrent.app(' ').app(binaryCombination.getOpString()).app(' ');\n\t\tbinaryCombination.getRight().accept(this);\n\t}\n\n\tpublic void visit(MultiMap<?, ?> list) throws IOException {}\n\n\tpublic void visit(FlowControl flow) throws IOException {\n\t\tcurrent.app(flow.getKeyword()).app(\";\");\n\t}\n\n\tpublic void visit(InterfaceDecl interfaceDecl) throws IOException {\n\t\t// huh.. slack off?\n\t}\n\n}\n","lineNo":348}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\t\t\n\t\t\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\treturn arguments.get(i).getType();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\treturn arguments.get(i);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tMemberAccess membAcc = new MemberAccess(callArg, \"class\", callArg.startToken);\n\t\t\t\tNodeList<Access> nl = new NodeList<Access>(1, startToken);\n\t\t\t\tnl.add(membAcc);\n\t\t\t\tstack.push(nl);\n\t\t\t\tmembAcc.resolve(stack, res, fatal);\n\t\t\t\tstack.pop(nl);\n\t\t\t\tresult = nl.get(0);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tdeclType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix.length() == 0 || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\t\t\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\treturn arguments.get(i).getType();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tExpression result = null;\n\t\t\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\tresult = arguments.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t\t\n\t}\n\t\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null && callArg.getType() != null) {\n\t\t\tif(callArg.getType().getName().equals(\"Class\")) {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t} else if(callArg.getType().isGeneric()) {\n\t\t\t\tresult = new VariableAccess(typeParam, callArg.startToken);\n\t\t\t} else {\n\t\t\t\tresult = (Access) callArg;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tdeclType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix.length() == 0 || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix.length() == 0) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","lineNo":284}
{"Smelly Sample":"package org.ooc.frontend;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.ooc.backend.cdirty.CGenerator;\nimport org.ooc.frontend.compilers.AbstractCompiler;\nimport org.ooc.frontend.compilers.Clang;\nimport org.ooc.frontend.compilers.Gcc;\nimport org.ooc.frontend.compilers.Icc;\nimport org.ooc.frontend.compilers.Tcc;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.Include.Mode;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.ModuleParser;\nimport org.ooc.frontend.parser.Parser;\nimport org.ooc.frontend.pkgconfig.PkgConfigFrontend;\nimport org.ooc.frontend.pkgconfig.PkgInfo;\nimport org.ooc.middle.Tinkerer;\nimport org.ooc.middle.UseDef;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.FileLocation;\n\npublic class CommandLine {\n\t\n\tpublic static void main(String[] argv) throws InterruptedException, IOException {\n\t\tnew CommandLine(argv);\n\t}\n\t\n\tprotected BuildParams params = new BuildParams();\n\tList<String> additionals = new ArrayList<String>();\n\tList<String> compilerArgs = new ArrayList<String>();\n\tprivate AbstractCompiler compiler = null;\n\t\n\tpublic CommandLine(String[] args) throws InterruptedException, IOException {\n\t\t\n\t\tList<String> modulePaths = new ArrayList<String>();\n\t\tList<String> nasms = new ArrayList<String>();\n\t\t\n\t\tfor(String arg: args) {\n\t\t\tif(arg.startsWith(\"-\")) {\n        \t\tString option = arg.substring(1);\n        \t\tif(option.startsWith(\"sourcepath\")) {\n        \t\t\t\n        \t\t\tString sourcePathOption = arg.substring(arg.indexOf('=') + 1);\n        \t\t\tStringTokenizer tokenizer = new StringTokenizer(sourcePathOption, File.pathSeparator);\n        \t\t\twhile(tokenizer.hasMoreTokens()) {\n        \t\t\t\tparams.sourcePath.add(tokenizer.nextToken());\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"outpath\")) {\n        \t\t\t\n        \t\t\tparams.outPath = new File(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"incpath\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"I\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"libpath\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"editor\")) {\n        \t\t\t\n        \t\t\tparams.editor = arg.substring(arg.indexOf('=') + 1);\n        \t\t\t\n        \t\t} else if(option.equals(\"c\")) {\n        \t\t\t\n        \t\t\tparams.link = false;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"L\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"l\")) {\n        \t\t\t\n        \t\t\tparams.dynamicLibs.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.equals(\"dyngc\")) {\n        \t\t\t\n        \t\t\tparams.dynGC = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"noclean\")) {\n        \t\t\t\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"shout\")) {\n        \t\t\t\n        \t\t\tparams.shout = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"timing\") || option.equals(\"t\")) {\n        \t\t\t\n        \t\t\tparams.timing = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"debug\") || option.equals(\"g\")) {\n        \t\t\t\n        \t\t\tparams.debug = true;\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"verbose\") || option.equals(\"v\")) {\n        \t\t\t\n        \t\t\tparams.verbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"run\") || option.equals(\"r\")) {\n        \t\t\t\n        \t\t\tparams.run = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"V\") || option.equals(\"-version\") || option.equals(\"version\")) {\n        \t\t\t\n        \t\t\tCompilerVersion.printVersion();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"h\") || option.equals(\"-help\") || option.equals(\"help\")) {\n        \t\t\t\n        \t\t\tHelp.printHelp();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"gcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Gcc();\n        \t\t\t\n        \t\t} else if(option.equals(\"icc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Icc();\n        \t\t\t\n        \t\t} else if(option.equals(\"tcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Tcc();\n        \t\t\t\n\t\t\t\t} else if(option.equals(\"clang\")) {\n        \t\t\t\n        \t\t\tcompiler = new Clang();\n        \t\t\t\n        \t\t} else if(option.equals(\"help-backends\") || option.equals(\"-help-backends\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpBackends();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-gcc\") || option.equals(\"-help-gcc\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpGcc();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-make\") || option.equals(\"-help-make\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpMake();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-none\") || option.equals(\"-help-none\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpNone();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"slave\")) {\n        \t\t\t\n        \t\t\tparams.slave = true;\n\n\t\t\t\t} else if(option.startsWith(\"m\")) {\n\t\t\t\t\t\n\t\t\t\t\tString arch = arg.substring(2);\n\t\t\t\t\tif (arch.equals(\"32\") || arch.equals(\"64\"))\n\t\t\t\t\t\tparams.arch = arg.substring(2);\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(\"Unrecognized architecture: \" + arch);\n\t\t\t\n        \t\t} else {\n        \t\t\t\n        \t\t\tSystem.err.println(\"Unrecognized option: '\"+arg+\"'\");\n        \t\t\t\n        \t\t}\n        \t} else if(arg.startsWith(\"+\")) {\n        \t\tcompilerArgs.add(arg.substring(1));\n        \t} else {\n        \t\t\tString lowerArg = arg.toLowerCase();\n\t\t\t\t\tif(lowerArg.endsWith(\".s\")) {\n        \t\t\t\tnasms.add(arg);\n        \t\t\t} else if(lowerArg.endsWith(\".o\") || lowerArg.endsWith(\".c\") || lowerArg.endsWith(\".cpp\")) {\n            \t\t\tadditionals.add(arg);\n            \t\t} else {\n            \t\t\tif(!lowerArg.endsWith(\".ooc\")) {\n            \t\t\t\tmodulePaths.add(arg+\".ooc\");\n            \t\t\t} else {\n            \t\t\t\tmodulePaths.add(arg);\n            \t\t\t}\n            \t\t}\n        \t}\n\t\t}\n\t\t\n\t\tif(modulePaths.isEmpty()) {\n\t\t\tSystem.err.println(\"ooc: no files.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(compiler == null) compiler = new Gcc();\n\t\t\n\t\tif(!nasms.isEmpty()) {\n\t\t\tcompileNasms(nasms, additionals);\n\t\t}\n\t\t\n\t\tif(params.sourcePath.isEmpty()) params.sourcePath.add(\".\");\n\t\tparams.sourcePath.add(params.distLocation + File.separator + \"sdk\");\n\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tdo {\n\t\t\tModuleParser.clearCache();\n\t\t\tint successCount = 0;\n\t\t\tfor(String modulePath: modulePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tint code = parse(modulePath);\n\t\t\t\t\tif(code == 0) successCount++;\n\t\t\t\t} catch(CompilationFailedError err) {\n\t\t\t\t\tSystem.err.println(err);\n\t\t\t\t\tfail();\n\t\t\t\t\tif(!params.editor.isEmpty()) {\n\t\t\t\t\t\tlaunchEditor(params.editor, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(params.clean) FileUtils.deleteRecursive(params.outPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(modulePaths.size() > 1) {\n\t\t\t\tSystem.out.println(modulePaths.size()+\" compiled (\"+successCount\n\t\t\t\t\t\t+\" success, \"+(modulePaths.size() - successCount)+\" failed)\");\n\t\t\t}\n\t\t\t\n\t\t\tif(params.slave) {\n\t\t\t\tSystem.out.println(\".-------------( ready )-------------.\\n\");\n\t\t\t\treader.readLine();\n\t\t\t} else {\n\t\t\t\tif(successCount < modulePaths.size()) {\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} while(params.slave);\n\t\t\n\t}\n\n\tprivate void ok() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;32m[ OK ]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[ OK ]\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void fail() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;31m[FAIL]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[FAIL]\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void launchEditor(final String editor, final CompilationFailedError err) {\n\t\t\n\t\tif(err.getLocation() == null) return;\n\t\t\n\t\tThread thread = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\t\tFileLocation location = err.getLocation();\n\t\t\t\t\tString absolutePath = new File(location.getFileName()).getAbsolutePath();\n\t\t\t\t\tif(editor.equals(\"geany\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath+\":\"+location.getLineNumber()+\":\"+(location.getLinePos() - 1));\n\t\t\t\t\t} else if(editor.equals(\"mate\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath, \"-l\", String.valueOf(location.getLineNumber()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessUtils.redirectIO(builder.start());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.setDaemon(true);\n\t\tthread.start();\n\t\t\n\t}\n\n\tprivate void compileNasms(List<String> nasms, Collection<String> list) throws IOException, InterruptedException {\n\t\t\n\t\tboolean has = false;\n\t\t\n\t\tList<String> command = new ArrayList<String>();\n\t\tcommand.add(findExec(\"nasm\").getPath());\n\t\tcommand.add(\"-f\");\n\t\tcommand.add(\"elf\");\n\t\tfor(String nasm: nasms) {\n\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\tcommand.add(nasm);\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(has) {\n\t\t\tProcessBuilder builder = new ProcessBuilder(command);\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tint code = process.waitFor();\n\t\t\tif(code != 0) {\n\t\t\t\tSystem.err.println(\"nasm failed, aborting compilation process\");\n\t\t\t\tSystem.exit(code);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String nasm: nasms) {\n\t\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\t\tlist.add(nasm.substring(0, nasm.length() - 1) + \"o\");\n\t\t\t\t} else {\n\t\t\t\t\tlist.add(nasm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist.addAll(nasms);\n\t\t}\n\t\t\n\t}\n\n\tprotected int parse(String modulePath) throws InterruptedException, IOException {\n\t\t\n\t\tparams.outPath.mkdirs();\n\t\tlong tt1 = System.nanoTime();\n\t\tModule module = new Parser(params).parse(modulePath);\n\t\tmodule.setMain(true);\n\t\tlong tt2 = System.nanoTime();\n\t\t\n\t\tArrayList<Module> list = new ArrayList<Module>();\n\t\tcollectModules(module, list);\n\t\ttinker(list);\n\t\t\n\t\tlong tt3 = System.nanoTime();\n\t\toutput(module, new HashSet<Module>());\n\t\tlong tt4 = System.nanoTime();\n\t\tint code = compile(module);\n\t\tlong tt5 = System.nanoTime();\n\n\t\tif(params.timing) {\n\t\t\tSystem.out.printf(\"parse: %.2f ms\\ttinker: %.2f ms\\toutput: %.2f ms\\tcc: %.2f ms\\tTOTAL %.2f ms\\n\",\n\t\t\t\t\tFloat.valueOf((tt2 - tt1) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt3 - tt2) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt4 - tt3) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt4) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt1) / 1000000.0f));\n\t\t}\n\t\t\n\t\tif(code == 0) {\n\t\t\tif(params.shout) ok();\n\t\t\tif(params.run) {\n\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\tbuilder.command(\"./\"+module.getSimpleName());\n\t\t\t\tProcess process = builder.start();\n\t\t\t\tProcessUtils.redirectIO(process);\n\t\t\t\tprocess.waitFor();\n\t\t\t}\n\t\t} else if(params.shout) fail();\n\t\treturn code;\n\t\t\n\t}\n\t\n\tprotected void output(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\toutput(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\tnew CGenerator(params.outPath, module).generate(params);\n\t}\n\n\tprotected void collectModules(Module module, List<Module> list) throws IOException {\n\t\tlist.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!list.contains(imp.getModule())) {\n\t\t\t\tcollectModules(imp.getModule(), list);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected void tinker(List<Module> list) throws IOException {\n\t\tTinkerer tink = new Tinkerer();\n\t\ttink.process(list, params);\n\t}\n\n\tprotected int compile(Module module) throws Error,\n\t\t\tIOException, InterruptedException {\n\t\t\n\t\tcompiler.reset();\n\t\t\n\t\tfor(Include inc: module.getIncludes()) {\n\t\t\tif(inc.getMode() == Mode.LOCAL) {\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.copy(new File(inc.getPath() + \".h\"),\n\t\t\t\t\t\tnew File(params.outPath, inc.getPath() + \".h\"));\n\t\t\t\t} catch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(params.debug) compiler.setDebugEnabled();\t\t\n\t\tcompiler.addIncludePath(new File(params.distLocation, \"libs/headers/\").getPath());\n\t\tcompiler.addIncludePath(params.outPath.getPath());\n\t\taddDeps(compiler, module, new HashSet<Module>());\n\t\tfor(String dynamicLib: params.dynamicLibs) {\n\t\t\tcompiler.addDynamicLibrary(dynamicLib);\n\t\t}\n\t\tfor(String additional: additionals) {\n\t\t\tcompiler.addObjectFile(additional);\n\t\t}\n\t\tfor(String compilerArg: compilerArgs) {\n\t\t\tcompiler.addObjectFile(compilerArg);\n\t\t}\n\t\t\n\t\tif(params.link) {\n\t\t\tcompiler.setOutputPath(module.getSimpleName());\n\t\t\tCollection<String> libs = getFlagsFromUse(module);\n\t\t\tfor(String lib: libs) compiler.addObjectFile(lib);\n\t\t\t\n\t\t\tcompiler.addDynamicLibrary(\"pthread\");\n\t\t\tif(params.dynGC) {\n\t\t\t\tcompiler.addDynamicLibrary(\"gc\");\n\t\t\t} else {\n\t\t\t\tcompiler.addObjectFile(new File(params.distLocation, \"libs/\"\n\t\t\t\t\t\t+ Target.guessHost().toString(params.arch.equals(\"\") ? Target.getArch() : params.arch) + \"/libgc.a\").getPath());\n\t\t\t}\n\t\t} else {\n\t\t\tcompiler.setCompileOnly();\n\t\t}\n\t\t\n\t\tif(params.verbose) compiler.printCommandLine();\n\t\t\n\t\tint code = compiler.launch();\n\t\tif(code != 0) {\n\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\n\tprotected Collection<String> getFlagsFromUse(Module module) throws IOException, InterruptedException {\n\n\t\tSet<String> list = new HashSet<String>();\n\t\tSet<Module> done = new HashSet<Module>();\n\t\tgetFlagsFromUse(module, list, done);\n\t\treturn list;\n\t\t\n\t}\n\n\tprotected void getFlagsFromUse(Module module, Set<String> list, Set<Module> done) throws IOException, InterruptedException {\n\n\t\tif(done.contains(module)) return;\n\t\tdone.add(module);\n\t\t\n\t\tfor(Use use: module.getUses()) {\n\t\t\tUseDef useDef = use.getUseDef();\n\t\t\tcompileNasms(useDef.getLibs(), list);\n\t\t\tfor(String pkg: useDef.getPkgs()) {\n\t\t\t\tPkgInfo info = PkgConfigFrontend.getInfo(pkg);\n\t\t\t\tfor(String cflag: info.cflags) {\n\t\t\t\t\tif(!list.contains(cflag)) {\n\t\t\t\t\t\tlist.add(cflag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(String library: info.libraries) {\n\t\t\t\t\tif(!list.contains(library)) {\n\t\t\t\t\t\tlist.add(\"-l\"+library); // FIXME lazy\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tgetFlagsFromUse(imp.getModule(), list, done);\n\t\t}\n\t\t\n\t}\n\n\tprotected File findExec(String name) throws Error {\n\t\t\n\t\tFile execFile = ShellUtils.findExecutable(name);\n\t\tif(execFile == null) {\n\t\t\texecFile = ShellUtils.findExecutable(name+\".exe\");\n\t\t}\n\t\tif(execFile == null) {\n\t\t\tthrow new Error(name+\" not found :/\");\n\t\t}\n\t\treturn execFile;\n\t\t\n\t}\n\n\tprotected void addDeps(AbstractCompiler compiler, Module module, Set<Module> done) {\n\t\t\n\t\tdone.add(module);\n\t\tcompiler.addObjectFile(new File(params.outPath, module.getPath(\".c\")).getPath());\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\taddDeps(compiler, imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.ooc.backend.cdirty.CGenerator;\nimport org.ooc.frontend.compilers.AbstractCompiler;\nimport org.ooc.frontend.compilers.Clang;\nimport org.ooc.frontend.compilers.Gcc;\nimport org.ooc.frontend.compilers.Icc;\nimport org.ooc.frontend.compilers.Tcc;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.Include.Mode;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.ModuleParser;\nimport org.ooc.frontend.parser.Parser;\nimport org.ooc.frontend.pkgconfig.PkgConfigFrontend;\nimport org.ooc.frontend.pkgconfig.PkgInfo;\nimport org.ooc.middle.Tinkerer;\nimport org.ooc.middle.UseDef;\nimport org.ooc.middle.UseDef.Requirement;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.FileLocation;\n\npublic class CommandLine {\n\t\n\tpublic static void main(String[] argv) throws InterruptedException, IOException {\n\t\tnew CommandLine(argv);\n\t}\n\t\n\tprotected BuildParams params = new BuildParams();\n\tList<String> additionals = new ArrayList<String>();\n\tList<String> compilerArgs = new ArrayList<String>();\n\tprivate AbstractCompiler compiler = null;\n\t\n\tpublic CommandLine(String[] args) throws InterruptedException, IOException {\n\t\t\n\t\tList<String> modulePaths = new ArrayList<String>();\n\t\tList<String> nasms = new ArrayList<String>();\n\t\t\n\t\tfor(String arg: args) {\n\t\t\tif(arg.startsWith(\"-\")) {\n        \t\tString option = arg.substring(1);\n        \t\tif(option.startsWith(\"sourcepath\")) {\n        \t\t\t\n        \t\t\tString sourcePathOption = arg.substring(arg.indexOf('=') + 1);\n        \t\t\tStringTokenizer tokenizer = new StringTokenizer(sourcePathOption, File.pathSeparator);\n        \t\t\twhile(tokenizer.hasMoreTokens()) {\n        \t\t\t\tparams.sourcePath.add(tokenizer.nextToken());\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"outpath\")) {\n        \t\t\t\n        \t\t\tparams.outPath = new File(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"incpath\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"I\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"libpath\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"editor\")) {\n        \t\t\t\n        \t\t\tparams.editor = arg.substring(arg.indexOf('=') + 1);\n        \t\t\t\n        \t\t} else if(option.equals(\"c\")) {\n        \t\t\t\n        \t\t\tparams.link = false;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"L\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"l\")) {\n        \t\t\t\n        \t\t\tparams.dynamicLibs.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.equals(\"dyngc\")) {\n        \t\t\t\n        \t\t\tparams.dynGC = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"noclean\")) {\n        \t\t\t\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"shout\")) {\n        \t\t\t\n        \t\t\tparams.shout = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"timing\") || option.equals(\"t\")) {\n        \t\t\t\n        \t\t\tparams.timing = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"debug\") || option.equals(\"g\")) {\n        \t\t\t\n        \t\t\tparams.debug = true;\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"verbose\") || option.equals(\"v\")) {\n        \t\t\t\n        \t\t\tparams.verbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"run\") || option.equals(\"r\")) {\n        \t\t\t\n        \t\t\tparams.run = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"V\") || option.equals(\"-version\") || option.equals(\"version\")) {\n        \t\t\t\n        \t\t\tCompilerVersion.printVersion();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"h\") || option.equals(\"-help\") || option.equals(\"help\")) {\n        \t\t\t\n        \t\t\tHelp.printHelp();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"gcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Gcc();\n        \t\t\t\n        \t\t} else if(option.equals(\"icc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Icc();\n        \t\t\t\n        \t\t} else if(option.equals(\"tcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Tcc();\n        \t\t\t\n\t\t\t\t} else if(option.equals(\"clang\")) {\n        \t\t\t\n        \t\t\tcompiler = new Clang();\n        \t\t\t\n        \t\t} else if(option.equals(\"help-backends\") || option.equals(\"-help-backends\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpBackends();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-gcc\") || option.equals(\"-help-gcc\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpGcc();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-make\") || option.equals(\"-help-make\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpMake();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-none\") || option.equals(\"-help-none\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpNone();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"slave\")) {\n        \t\t\t\n        \t\t\tparams.slave = true;\n\n\t\t\t\t} else if(option.startsWith(\"m\")) {\n\t\t\t\t\t\n\t\t\t\t\tString arch = arg.substring(2);\n\t\t\t\t\tif (arch.equals(\"32\") || arch.equals(\"64\"))\n\t\t\t\t\t\tparams.arch = arg.substring(2);\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(\"Unrecognized architecture: \" + arch);\n\t\t\t\n        \t\t} else {\n        \t\t\t\n        \t\t\tSystem.err.println(\"Unrecognized option: '\"+arg+\"'\");\n        \t\t\t\n        \t\t}\n        \t} else if(arg.startsWith(\"+\")) {\n        \t\tcompilerArgs.add(arg.substring(1));\n        \t} else {\n        \t\t\tString lowerArg = arg.toLowerCase();\n\t\t\t\t\tif(lowerArg.endsWith(\".s\")) {\n        \t\t\t\tnasms.add(arg);\n        \t\t\t} else if(lowerArg.endsWith(\".o\") || lowerArg.endsWith(\".c\") || lowerArg.endsWith(\".cpp\")) {\n            \t\t\tadditionals.add(arg);\n            \t\t} else {\n            \t\t\tif(!lowerArg.endsWith(\".ooc\")) {\n            \t\t\t\tmodulePaths.add(arg+\".ooc\");\n            \t\t\t} else {\n            \t\t\t\tmodulePaths.add(arg);\n            \t\t\t}\n            \t\t}\n        \t}\n\t\t}\n\t\t\n\t\tif(modulePaths.isEmpty()) {\n\t\t\tSystem.err.println(\"ooc: no files.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(compiler == null) compiler = new Gcc();\n\t\t\n\t\tif(!nasms.isEmpty()) {\n\t\t\tcompileNasms(nasms, additionals);\n\t\t}\n\t\t\n\t\tif(params.sourcePath.isEmpty()) params.sourcePath.add(\".\");\n\t\tparams.sourcePath.add(params.distLocation + File.separator + \"sdk\");\n\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tdo {\n\t\t\tModuleParser.clearCache();\n\t\t\tint successCount = 0;\n\t\t\tfor(String modulePath: modulePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tint code = parse(modulePath);\n\t\t\t\t\tif(code == 0) successCount++;\n\t\t\t\t} catch(CompilationFailedError err) {\n\t\t\t\t\tSystem.err.println(err);\n\t\t\t\t\tfail();\n\t\t\t\t\tif(!params.editor.isEmpty()) {\n\t\t\t\t\t\tlaunchEditor(params.editor, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(params.clean) FileUtils.deleteRecursive(params.outPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(modulePaths.size() > 1) {\n\t\t\t\tSystem.out.println(modulePaths.size()+\" compiled (\"+successCount\n\t\t\t\t\t\t+\" success, \"+(modulePaths.size() - successCount)+\" failed)\");\n\t\t\t}\n\t\t\t\n\t\t\tif(params.slave) {\n\t\t\t\tSystem.out.println(\".-------------( ready )-------------.\\n\");\n\t\t\t\treader.readLine();\n\t\t\t} else {\n\t\t\t\tif(successCount < modulePaths.size()) {\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} while(params.slave);\n\t\t\n\t}\n\n\tprivate void ok() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;32m[ OK ]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[ OK ]\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void fail() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;31m[FAIL]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[FAIL]\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void launchEditor(final String editor, final CompilationFailedError err) {\n\t\t\n\t\tif(err.getLocation() == null) return;\n\t\t\n\t\tThread thread = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\t\tFileLocation location = err.getLocation();\n\t\t\t\t\tString absolutePath = new File(location.getFileName()).getAbsolutePath();\n\t\t\t\t\tif(editor.equals(\"geany\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath+\":\"+location.getLineNumber()+\":\"+(location.getLinePos() - 1));\n\t\t\t\t\t} else if(editor.equals(\"mate\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath, \"-l\", String.valueOf(location.getLineNumber()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessUtils.redirectIO(builder.start());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.setDaemon(true);\n\t\tthread.start();\n\t\t\n\t}\n\n\tprivate void compileNasms(List<String> nasms, Collection<String> list) throws IOException, InterruptedException {\n\t\t\n\t\tboolean has = false;\n\t\t\n\t\tList<String> command = new ArrayList<String>();\n\t\tcommand.add(findExec(\"nasm\").getPath());\n\t\tcommand.add(\"-f\");\n\t\tcommand.add(\"elf\");\n\t\tfor(String nasm: nasms) {\n\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\tcommand.add(nasm);\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(has) {\n\t\t\tProcessBuilder builder = new ProcessBuilder(command);\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tint code = process.waitFor();\n\t\t\tif(code != 0) {\n\t\t\t\tSystem.err.println(\"nasm failed, aborting compilation process\");\n\t\t\t\tSystem.exit(code);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String nasm: nasms) {\n\t\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\t\tlist.add(nasm.substring(0, nasm.length() - 1) + \"o\");\n\t\t\t\t} else {\n\t\t\t\t\tlist.add(nasm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist.addAll(nasms);\n\t\t}\n\t\t\n\t}\n\n\tprotected int parse(String modulePath) throws InterruptedException, IOException {\n\t\t\n\t\tparams.outPath.mkdirs();\n\t\tlong tt1 = System.nanoTime();\n\t\tModule module = new Parser(params).parse(modulePath);\n\t\tmodule.setMain(true);\n\t\tlong tt2 = System.nanoTime();\n\t\t\n\t\tArrayList<Module> list = new ArrayList<Module>();\n\t\tcollectModules(module, list);\n\t\ttinker(list);\n\t\t\n\t\tlong tt3 = System.nanoTime();\n\t\toutput(module, new HashSet<Module>());\n\t\tlong tt4 = System.nanoTime();\n\t\tint code = compile(module);\n\t\tlong tt5 = System.nanoTime();\n\n\t\tif(params.timing) {\n\t\t\tSystem.out.printf(\"parse: %.2f ms\\ttinker: %.2f ms\\toutput: %.2f ms\\tcc: %.2f ms\\tTOTAL %.2f ms\\n\",\n\t\t\t\t\tFloat.valueOf((tt2 - tt1) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt3 - tt2) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt4 - tt3) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt4) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt1) / 1000000.0f));\n\t\t}\n\t\t\n\t\tif(code == 0) {\n\t\t\tif(params.shout) ok();\n\t\t\tif(params.run) {\n\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\tbuilder.command(\"./\"+module.getSimpleName());\n\t\t\t\tProcess process = builder.start();\n\t\t\t\tProcessUtils.redirectIO(process);\n\t\t\t\tprocess.waitFor();\n\t\t\t}\n\t\t} else if(params.shout) fail();\n\t\treturn code;\n\t\t\n\t}\n\t\n\tprotected void output(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\toutput(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\tnew CGenerator(params.outPath, module).generate(params);\n\t}\n\n\tprotected void collectModules(Module module, List<Module> list) throws IOException {\n\t\tlist.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!list.contains(imp.getModule())) {\n\t\t\t\tcollectModules(imp.getModule(), list);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected void tinker(List<Module> list) throws IOException {\n\t\tTinkerer tink = new Tinkerer();\n\t\ttink.process(list, params);\n\t}\n\n\tprotected int compile(Module module) throws Error,\n\t\t\tIOException, InterruptedException {\n\t\t\n\t\tcompiler.reset();\n\t\t\n\t\tfor(Include inc: module.getIncludes()) {\n\t\t\tif(inc.getMode() == Mode.LOCAL) {\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.copy(new File(inc.getPath() + \".h\"),\n\t\t\t\t\t\tnew File(params.outPath, inc.getPath() + \".h\"));\n\t\t\t\t} catch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(params.debug) compiler.setDebugEnabled();\t\t\n\t\tcompiler.addIncludePath(new File(params.distLocation, \"libs/headers/\").getPath());\n\t\tcompiler.addIncludePath(params.outPath.getPath());\n\t\taddDeps(compiler, module, new HashSet<Module>());\n\t\tfor(String dynamicLib: params.dynamicLibs) {\n\t\t\tcompiler.addDynamicLibrary(dynamicLib);\n\t\t}\n\t\tfor(String additional: additionals) {\n\t\t\tcompiler.addObjectFile(additional);\n\t\t}\n\t\tfor(String compilerArg: compilerArgs) {\n\t\t\tcompiler.addObjectFile(compilerArg);\n\t\t}\n\t\t\n\t\tif(params.link) {\n\t\t\tcompiler.setOutputPath(module.getSimpleName());\n\t\t\tCollection<String> libs = getFlagsFromUse(module);\n\t\t\tfor(String lib: libs) compiler.addObjectFile(lib);\n\t\t\t\n\t\t\tcompiler.addDynamicLibrary(\"pthread\");\n\t\t\tif(params.dynGC) {\n\t\t\t\tcompiler.addDynamicLibrary(\"gc\");\n\t\t\t} else {\n\t\t\t\tcompiler.addObjectFile(new File(params.distLocation, \"libs/\"\n\t\t\t\t\t\t+ Target.guessHost().toString(params.arch.equals(\"\") ? Target.getArch() : params.arch) + \"/libgc.a\").getPath());\n\t\t\t}\n\t\t} else {\n\t\t\tcompiler.setCompileOnly();\n\t\t}\n\t\t\n\t\tif(params.verbose) compiler.printCommandLine();\n\t\t\n\t\tint code = compiler.launch();\n\t\tif(code != 0) {\n\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\n\tprotected Collection<String> getFlagsFromUse(Module module) throws IOException, InterruptedException {\n\n\t\tSet<String> list = new HashSet<String>();\n\t\tSet<Module> done = new HashSet<Module>();\n\t\tgetFlagsFromUse(module, list, done, new HashSet<UseDef>());\n\t\treturn list;\n\t\t\n\t}\n\n\tprotected void getFlagsFromUse(Module module, Set<String> flagsDone, Set<Module> modulesDone, Set<UseDef> usesDone) throws IOException, InterruptedException {\n\n\t\tif(modulesDone.contains(module)) return;\n\t\tmodulesDone.add(module);\n\t\t\n\t\tfor(Use use: module.getUses()) {\n\t\t\tUseDef useDef = use.getUseDef();\n\t\t\tgetFlagsFromUse(useDef, flagsDone, usesDone);\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tgetFlagsFromUse(imp.getModule(), flagsDone, modulesDone, usesDone);\n\t\t}\n\t\t\n\t}\n\n\tprivate void getFlagsFromUse(UseDef useDef, Set<String> flagsDone,\n\t\t\tSet<UseDef> usesDone) throws IOException, InterruptedException {\n\t\t\n\t\tif(usesDone.contains(useDef)) return;\n\t\tusesDone.add(useDef);\n\t\tcompileNasms(useDef.getLibs(), flagsDone);\n\t\tfor(String pkg: useDef.getPkgs()) {\n\t\t\tPkgInfo info = PkgConfigFrontend.getInfo(pkg);\n\t\t\tfor(String cflag: info.cflags) {\n\t\t\t\tif(!flagsDone.contains(cflag)) {\n\t\t\t\t\tflagsDone.add(cflag);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(String library: info.libraries) {\n\t\t\t\t // FIXME lazy\n\t\t\t\tString lpath = \"-l\"+library;\n\t\t\t\tif(!flagsDone.contains(lpath)) {\n\t\t\t\t\tflagsDone.add(lpath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(String includePath: useDef.getIncludePaths()) {\n\t\t\t // FIXME lazy too.\n\t\t\tString ipath = \"-I\"+includePath;\n\t\t\tif(!flagsDone.contains(ipath)) {\n\t\t\t\tflagsDone.add(ipath);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(String libPath: useDef.getLibPaths()) {\n\t\t\t // FIXME lazy too.\n\t\t\tString lpath = \"-L\"+libPath;\n\t\t\tif(!flagsDone.contains(lpath)) {\n\t\t\t\tflagsDone.add(lpath);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Requirement req: useDef.getRequirements()) {\n\t\t\tgetFlagsFromUse(req.getUseDef(), flagsDone, usesDone);\n\t\t}\n\t\t\n\t}\n\n\tprotected File findExec(String name) throws Error {\n\t\t\n\t\tFile execFile = ShellUtils.findExecutable(name);\n\t\tif(execFile == null) {\n\t\t\texecFile = ShellUtils.findExecutable(name+\".exe\");\n\t\t}\n\t\tif(execFile == null) {\n\t\t\tthrow new Error(name+\" not found :/\");\n\t\t}\n\t\treturn execFile;\n\t\t\n\t}\n\n\tprotected void addDeps(AbstractCompiler compiler, Module module, Set<Module> done) {\n\t\t\n\t\tdone.add(module);\n\t\tcompiler.addObjectFile(new File(params.outPath, module.getPath(\".c\")).getPath());\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\taddDeps(compiler, imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","lineNo":504}
{"Smelly Sample":"package org.ooc.frontend;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.ooc.backend.cdirty.CGenerator;\nimport org.ooc.frontend.compilers.AbstractCompiler;\nimport org.ooc.frontend.compilers.Clang;\nimport org.ooc.frontend.compilers.Gcc;\nimport org.ooc.frontend.compilers.Icc;\nimport org.ooc.frontend.compilers.Tcc;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.Include.Mode;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.ModuleParser;\nimport org.ooc.frontend.parser.Parser;\nimport org.ooc.frontend.pkgconfig.PkgConfigFrontend;\nimport org.ooc.frontend.pkgconfig.PkgInfo;\nimport org.ooc.middle.Tinkerer;\nimport org.ooc.middle.UseDef;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.FileLocation;\n\npublic class CommandLine {\n\t\n\tpublic static void main(String[] argv) throws InterruptedException, IOException {\n\t\tnew CommandLine(argv);\n\t}\n\t\n\tprotected BuildParams params = new BuildParams();\n\tList<String> additionals = new ArrayList<String>();\n\tList<String> compilerArgs = new ArrayList<String>();\n\tprivate AbstractCompiler compiler = null;\n\t\n\tpublic CommandLine(String[] args) throws InterruptedException, IOException {\n\t\t\n\t\tList<String> modulePaths = new ArrayList<String>();\n\t\tList<String> nasms = new ArrayList<String>();\n\t\t\n\t\tfor(String arg: args) {\n\t\t\tif(arg.startsWith(\"-\")) {\n        \t\tString option = arg.substring(1);\n        \t\tif(option.startsWith(\"sourcepath\")) {\n        \t\t\t\n        \t\t\tString sourcePathOption = arg.substring(arg.indexOf('=') + 1);\n        \t\t\tStringTokenizer tokenizer = new StringTokenizer(sourcePathOption, File.pathSeparator);\n        \t\t\twhile(tokenizer.hasMoreTokens()) {\n        \t\t\t\tparams.sourcePath.add(tokenizer.nextToken());\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"outpath\")) {\n        \t\t\t\n        \t\t\tparams.outPath = new File(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"incpath\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"I\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"libpath\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"editor\")) {\n        \t\t\t\n        \t\t\tparams.editor = arg.substring(arg.indexOf('=') + 1);\n        \t\t\t\n        \t\t} else if(option.equals(\"c\")) {\n        \t\t\t\n        \t\t\tparams.link = false;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"L\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"l\")) {\n        \t\t\t\n        \t\t\tparams.dynamicLibs.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.equals(\"dyngc\")) {\n        \t\t\t\n        \t\t\tparams.dynGC = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"noclean\")) {\n        \t\t\t\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"shout\")) {\n        \t\t\t\n        \t\t\tparams.shout = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"timing\") || option.equals(\"t\")) {\n        \t\t\t\n        \t\t\tparams.timing = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"debug\") || option.equals(\"g\")) {\n        \t\t\t\n        \t\t\tparams.debug = true;\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"verbose\") || option.equals(\"v\")) {\n        \t\t\t\n        \t\t\tparams.verbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"run\") || option.equals(\"r\")) {\n        \t\t\t\n        \t\t\tparams.run = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"V\") || option.equals(\"-version\") || option.equals(\"version\")) {\n        \t\t\t\n        \t\t\tCompilerVersion.printVersion();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"h\") || option.equals(\"-help\") || option.equals(\"help\")) {\n        \t\t\t\n        \t\t\tHelp.printHelp();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"gcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Gcc();\n        \t\t\t\n        \t\t} else if(option.equals(\"icc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Icc();\n        \t\t\t\n        \t\t} else if(option.equals(\"tcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Tcc();\n        \t\t\t\n\t\t\t\t} else if(option.equals(\"clang\")) {\n        \t\t\t\n        \t\t\tcompiler = new Clang();\n        \t\t\t\n        \t\t} else if(option.equals(\"help-backends\") || option.equals(\"-help-backends\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpBackends();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-gcc\") || option.equals(\"-help-gcc\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpGcc();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-make\") || option.equals(\"-help-make\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpMake();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-none\") || option.equals(\"-help-none\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpNone();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"slave\")) {\n        \t\t\t\n        \t\t\tparams.slave = true;\n\n\t\t\t\t} else if(option.startsWith(\"m\")) {\n\t\t\t\t\t\n\t\t\t\t\tString arch = arg.substring(2);\n\t\t\t\t\tif (arch.equals(\"32\") || arch.equals(\"64\"))\n\t\t\t\t\t\tparams.arch = arg.substring(2);\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(\"Unrecognized architecture: \" + arch);\n\t\t\t\n        \t\t} else {\n        \t\t\t\n        \t\t\tSystem.err.println(\"Unrecognized option: '\"+arg+\"'\");\n        \t\t\t\n        \t\t}\n        \t} else if(arg.startsWith(\"+\")) {\n        \t\tcompilerArgs.add(arg.substring(1));\n        \t} else {\n        \t\t\tString lowerArg = arg.toLowerCase();\n\t\t\t\t\tif(lowerArg.endsWith(\".s\")) {\n        \t\t\t\tnasms.add(arg);\n        \t\t\t} else if(lowerArg.endsWith(\".o\") || lowerArg.endsWith(\".c\") || lowerArg.endsWith(\".cpp\")) {\n            \t\t\tadditionals.add(arg);\n            \t\t} else {\n            \t\t\tif(!lowerArg.endsWith(\".ooc\")) {\n            \t\t\t\tmodulePaths.add(arg+\".ooc\");\n            \t\t\t} else {\n            \t\t\t\tmodulePaths.add(arg);\n            \t\t\t}\n            \t\t}\n        \t}\n\t\t}\n\t\t\n\t\tif(modulePaths.isEmpty()) {\n\t\t\tSystem.err.println(\"ooc: no files.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(compiler == null) compiler = new Gcc();\n\t\t\n\t\tif(!nasms.isEmpty()) {\n\t\t\tcompileNasms(nasms, additionals);\n\t\t}\n\t\t\n\t\tif(params.sourcePath.isEmpty()) params.sourcePath.add(\".\");\n\t\tparams.sourcePath.add(params.distLocation + File.separator + \"sdk\");\n\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tdo {\n\t\t\tModuleParser.clearCache();\n\t\t\tint successCount = 0;\n\t\t\tfor(String modulePath: modulePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tint code = parse(modulePath);\n\t\t\t\t\tif(code == 0) successCount++;\n\t\t\t\t} catch(CompilationFailedError err) {\n\t\t\t\t\tSystem.err.println(err);\n\t\t\t\t\tfail();\n\t\t\t\t\tif(!params.editor.isEmpty()) {\n\t\t\t\t\t\tlaunchEditor(params.editor, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(params.clean) FileUtils.deleteRecursive(params.outPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(modulePaths.size() > 1) {\n\t\t\t\tSystem.out.println(modulePaths.size()+\" compiled (\"+successCount\n\t\t\t\t\t\t+\" success, \"+(modulePaths.size() - successCount)+\" failed)\");\n\t\t\t}\n\t\t\t\n\t\t\tif(params.slave) {\n\t\t\t\tSystem.out.println(\".-------------( ready )-------------.\\n\");\n\t\t\t\treader.readLine();\n\t\t\t} else {\n\t\t\t\tif(successCount < modulePaths.size()) {\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} while(params.slave);\n\t\t\n\t}\n\n\tprivate void ok() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;32m[ OK ]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[ OK ]\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void fail() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;31m[FAIL]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[FAIL]\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void launchEditor(final String editor, final CompilationFailedError err) {\n\t\t\n\t\tif(err.getLocation() == null) return;\n\t\t\n\t\tThread thread = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\t\tFileLocation location = err.getLocation();\n\t\t\t\t\tString absolutePath = new File(location.getFileName()).getAbsolutePath();\n\t\t\t\t\tif(editor.equals(\"geany\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath+\":\"+location.getLineNumber()+\":\"+(location.getLinePos() - 1));\n\t\t\t\t\t} else if(editor.equals(\"mate\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath, \"-l\", String.valueOf(location.getLineNumber()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessUtils.redirectIO(builder.start());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.setDaemon(true);\n\t\tthread.start();\n\t\t\n\t}\n\n\tprivate void compileNasms(List<String> nasms, Collection<String> list) throws IOException, InterruptedException {\n\t\t\n\t\tboolean has = false;\n\t\t\n\t\tList<String> command = new ArrayList<String>();\n\t\tcommand.add(findExec(\"nasm\").getPath());\n\t\tcommand.add(\"-f\");\n\t\tcommand.add(\"elf\");\n\t\tfor(String nasm: nasms) {\n\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\tcommand.add(nasm);\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(has) {\n\t\t\tProcessBuilder builder = new ProcessBuilder(command);\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tint code = process.waitFor();\n\t\t\tif(code != 0) {\n\t\t\t\tSystem.err.println(\"nasm failed, aborting compilation process\");\n\t\t\t\tSystem.exit(code);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String nasm: nasms) {\n\t\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\t\tlist.add(nasm.substring(0, nasm.length() - 1) + \"o\");\n\t\t\t\t} else {\n\t\t\t\t\tlist.add(nasm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist.addAll(nasms);\n\t\t}\n\t\t\n\t}\n\n\tprotected int parse(String modulePath) throws InterruptedException, IOException {\n\t\t\n\t\tparams.outPath.mkdirs();\n\t\tlong tt1 = System.nanoTime();\n\t\tModule module = new Parser(params).parse(modulePath);\n\t\tmodule.setMain(true);\n\t\tlong tt2 = System.nanoTime();\n\t\t\n\t\tArrayList<Module> list = new ArrayList<Module>();\n\t\tcollectModules(module, list);\n\t\ttinker(list);\n\t\t\n\t\tlong tt3 = System.nanoTime();\n\t\toutput(module, new HashSet<Module>());\n\t\tlong tt4 = System.nanoTime();\n\t\tint code = compile(module);\n\t\tlong tt5 = System.nanoTime();\n\n\t\tif(params.timing) {\n\t\t\tSystem.out.printf(\"parse: %.2f ms\\ttinker: %.2f ms\\toutput: %.2f ms\\tcc: %.2f ms\\tTOTAL %.2f ms\\n\",\n\t\t\t\t\tFloat.valueOf((tt2 - tt1) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt3 - tt2) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt4 - tt3) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt4) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt1) / 1000000.0f));\n\t\t}\n\t\t\n\t\tif(code == 0) {\n\t\t\tif(params.shout) ok();\n\t\t\tif(params.run) {\n\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\tbuilder.command(\"./\"+module.getSimpleName());\n\t\t\t\tProcess process = builder.start();\n\t\t\t\tProcessUtils.redirectIO(process);\n\t\t\t\tprocess.waitFor();\n\t\t\t}\n\t\t} else if(params.shout) fail();\n\t\treturn code;\n\t\t\n\t}\n\t\n\tprotected void output(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\toutput(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\tnew CGenerator(params.outPath, module).generate(params);\n\t}\n\n\tprotected void collectModules(Module module, List<Module> list) throws IOException {\n\t\tlist.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!list.contains(imp.getModule())) {\n\t\t\t\tcollectModules(imp.getModule(), list);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected void tinker(List<Module> list) throws IOException {\n\t\tTinkerer tink = new Tinkerer();\n\t\ttink.process(list, params);\n\t}\n\n\tprotected int compile(Module module) throws Error,\n\t\t\tIOException, InterruptedException {\n\t\t\n\t\tcompiler.reset();\n\t\t\n\t\tfor(Include inc: module.getIncludes()) {\n\t\t\tif(inc.getMode() == Mode.LOCAL) {\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.copy(new File(inc.getPath() + \".h\"),\n\t\t\t\t\t\tnew File(params.outPath, inc.getPath() + \".h\"));\n\t\t\t\t} catch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(params.debug) compiler.setDebugEnabled();\t\t\n\t\tcompiler.addIncludePath(new File(params.distLocation, \"libs/headers/\").getPath());\n\t\tcompiler.addIncludePath(params.outPath.getPath());\n\t\taddDeps(compiler, module, new HashSet<Module>());\n\t\tfor(String dynamicLib: params.dynamicLibs) {\n\t\t\tcompiler.addDynamicLibrary(dynamicLib);\n\t\t}\n\t\tfor(String additional: additionals) {\n\t\t\tcompiler.addObjectFile(additional);\n\t\t}\n\t\tfor(String compilerArg: compilerArgs) {\n\t\t\tcompiler.addObjectFile(compilerArg);\n\t\t}\n\t\t\n\t\tif(params.link) {\n\t\t\tcompiler.setOutputPath(module.getSimpleName());\n\t\t\tCollection<String> libs = getFlagsFromUse(module);\n\t\t\tfor(String lib: libs) compiler.addObjectFile(lib);\n\t\t\t\n\t\t\tcompiler.addDynamicLibrary(\"pthread\");\n\t\t\tif(params.dynGC) {\n\t\t\t\tcompiler.addDynamicLibrary(\"gc\");\n\t\t\t} else {\n\t\t\t\tcompiler.addObjectFile(new File(params.distLocation, \"libs/\"\n\t\t\t\t\t\t+ Target.guessHost().toString(params.arch.equals(\"\") ? Target.getArch() : params.arch) + \"/libgc.a\").getPath());\n\t\t\t}\n\t\t} else {\n\t\t\tcompiler.setCompileOnly();\n\t\t}\n\t\t\n\t\tif(params.verbose) compiler.printCommandLine();\n\t\t\n\t\tint code = compiler.launch();\n\t\tif(code != 0) {\n\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\n\tprotected Collection<String> getFlagsFromUse(Module module) throws IOException, InterruptedException {\n\n\t\tSet<String> list = new HashSet<String>();\n\t\tSet<Module> done = new HashSet<Module>();\n\t\tgetFlagsFromUse(module, list, done);\n\t\treturn list;\n\t\t\n\t}\n\n\tprotected void getFlagsFromUse(Module module, Set<String> list, Set<Module> done) throws IOException, InterruptedException {\n\n\t\tif(done.contains(module)) return;\n\t\tdone.add(module);\n\t\t\n\t\tfor(Use use: module.getUses()) {\n\t\t\tUseDef useDef = use.getUseDef();\n\t\t\tcompileNasms(useDef.getLibs(), list);\n\t\t\tfor(String pkg: useDef.getPkgs()) {\n\t\t\t\tPkgInfo info = PkgConfigFrontend.getInfo(pkg);\n\t\t\t\tfor(String cflag: info.cflags) {\n\t\t\t\t\tif(!list.contains(cflag)) {\n\t\t\t\t\t\tlist.add(cflag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(String library: info.libraries) {\n\t\t\t\t\tif(!list.contains(library)) {\n\t\t\t\t\t\tlist.add(\"-l\"+library); // FIXME lazy\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tgetFlagsFromUse(imp.getModule(), list, done);\n\t\t}\n\t\t\n\t}\n\n\tprotected File findExec(String name) throws Error {\n\t\t\n\t\tFile execFile = ShellUtils.findExecutable(name);\n\t\tif(execFile == null) {\n\t\t\texecFile = ShellUtils.findExecutable(name+\".exe\");\n\t\t}\n\t\tif(execFile == null) {\n\t\t\tthrow new Error(name+\" not found :/\");\n\t\t}\n\t\treturn execFile;\n\t\t\n\t}\n\n\tprotected void addDeps(AbstractCompiler compiler, Module module, Set<Module> done) {\n\t\t\n\t\tdone.add(module);\n\t\tcompiler.addObjectFile(new File(params.outPath, module.getPath(\".c\")).getPath());\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\taddDeps(compiler, imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.ooc.backend.cdirty.CGenerator;\nimport org.ooc.frontend.compilers.AbstractCompiler;\nimport org.ooc.frontend.compilers.Clang;\nimport org.ooc.frontend.compilers.Gcc;\nimport org.ooc.frontend.compilers.Icc;\nimport org.ooc.frontend.compilers.Tcc;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.Include.Mode;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.ModuleParser;\nimport org.ooc.frontend.parser.Parser;\nimport org.ooc.frontend.pkgconfig.PkgConfigFrontend;\nimport org.ooc.frontend.pkgconfig.PkgInfo;\nimport org.ooc.middle.Tinkerer;\nimport org.ooc.middle.UseDef;\nimport org.ooc.middle.UseDef.Requirement;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.FileLocation;\n\npublic class CommandLine {\n\t\n\tpublic static void main(String[] argv) throws InterruptedException, IOException {\n\t\tnew CommandLine(argv);\n\t}\n\t\n\tprotected BuildParams params = new BuildParams();\n\tList<String> additionals = new ArrayList<String>();\n\tList<String> compilerArgs = new ArrayList<String>();\n\tprivate AbstractCompiler compiler = null;\n\t\n\tpublic CommandLine(String[] args) throws InterruptedException, IOException {\n\t\t\n\t\tList<String> modulePaths = new ArrayList<String>();\n\t\tList<String> nasms = new ArrayList<String>();\n\t\t\n\t\tfor(String arg: args) {\n\t\t\tif(arg.startsWith(\"-\")) {\n        \t\tString option = arg.substring(1);\n        \t\tif(option.startsWith(\"sourcepath\")) {\n        \t\t\t\n        \t\t\tString sourcePathOption = arg.substring(arg.indexOf('=') + 1);\n        \t\t\tStringTokenizer tokenizer = new StringTokenizer(sourcePathOption, File.pathSeparator);\n        \t\t\twhile(tokenizer.hasMoreTokens()) {\n        \t\t\t\tparams.sourcePath.add(tokenizer.nextToken());\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"outpath\")) {\n        \t\t\t\n        \t\t\tparams.outPath = new File(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"incpath\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"I\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"libpath\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"editor\")) {\n        \t\t\t\n        \t\t\tparams.editor = arg.substring(arg.indexOf('=') + 1);\n        \t\t\t\n        \t\t} else if(option.equals(\"c\")) {\n        \t\t\t\n        \t\t\tparams.link = false;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"L\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"l\")) {\n        \t\t\t\n        \t\t\tparams.dynamicLibs.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.equals(\"dyngc\")) {\n        \t\t\t\n        \t\t\tparams.dynGC = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"noclean\")) {\n        \t\t\t\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"shout\")) {\n        \t\t\t\n        \t\t\tparams.shout = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"timing\") || option.equals(\"t\")) {\n        \t\t\t\n        \t\t\tparams.timing = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"debug\") || option.equals(\"g\")) {\n        \t\t\t\n        \t\t\tparams.debug = true;\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"verbose\") || option.equals(\"v\")) {\n        \t\t\t\n        \t\t\tparams.verbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"run\") || option.equals(\"r\")) {\n        \t\t\t\n        \t\t\tparams.run = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"V\") || option.equals(\"-version\") || option.equals(\"version\")) {\n        \t\t\t\n        \t\t\tCompilerVersion.printVersion();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"h\") || option.equals(\"-help\") || option.equals(\"help\")) {\n        \t\t\t\n        \t\t\tHelp.printHelp();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"gcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Gcc();\n        \t\t\t\n        \t\t} else if(option.equals(\"icc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Icc();\n        \t\t\t\n        \t\t} else if(option.equals(\"tcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Tcc();\n        \t\t\t\n\t\t\t\t} else if(option.equals(\"clang\")) {\n        \t\t\t\n        \t\t\tcompiler = new Clang();\n        \t\t\t\n        \t\t} else if(option.equals(\"help-backends\") || option.equals(\"-help-backends\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpBackends();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-gcc\") || option.equals(\"-help-gcc\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpGcc();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-make\") || option.equals(\"-help-make\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpMake();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-none\") || option.equals(\"-help-none\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpNone();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"slave\")) {\n        \t\t\t\n        \t\t\tparams.slave = true;\n\n\t\t\t\t} else if(option.startsWith(\"m\")) {\n\t\t\t\t\t\n\t\t\t\t\tString arch = arg.substring(2);\n\t\t\t\t\tif (arch.equals(\"32\") || arch.equals(\"64\"))\n\t\t\t\t\t\tparams.arch = arg.substring(2);\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(\"Unrecognized architecture: \" + arch);\n\t\t\t\n        \t\t} else {\n        \t\t\t\n        \t\t\tSystem.err.println(\"Unrecognized option: '\"+arg+\"'\");\n        \t\t\t\n        \t\t}\n        \t} else if(arg.startsWith(\"+\")) {\n        \t\tcompilerArgs.add(arg.substring(1));\n        \t} else {\n        \t\t\tString lowerArg = arg.toLowerCase();\n\t\t\t\t\tif(lowerArg.endsWith(\".s\")) {\n        \t\t\t\tnasms.add(arg);\n        \t\t\t} else if(lowerArg.endsWith(\".o\") || lowerArg.endsWith(\".c\") || lowerArg.endsWith(\".cpp\")) {\n            \t\t\tadditionals.add(arg);\n            \t\t} else {\n            \t\t\tif(!lowerArg.endsWith(\".ooc\")) {\n            \t\t\t\tmodulePaths.add(arg+\".ooc\");\n            \t\t\t} else {\n            \t\t\t\tmodulePaths.add(arg);\n            \t\t\t}\n            \t\t}\n        \t}\n\t\t}\n\t\t\n\t\tif(modulePaths.isEmpty()) {\n\t\t\tSystem.err.println(\"ooc: no files.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(compiler == null) compiler = new Gcc();\n\t\t\n\t\tif(!nasms.isEmpty()) {\n\t\t\tcompileNasms(nasms, additionals);\n\t\t}\n\t\t\n\t\tif(params.sourcePath.isEmpty()) params.sourcePath.add(\".\");\n\t\tparams.sourcePath.add(params.distLocation + File.separator + \"sdk\");\n\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tdo {\n\t\t\tModuleParser.clearCache();\n\t\t\tint successCount = 0;\n\t\t\tfor(String modulePath: modulePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tint code = parse(modulePath);\n\t\t\t\t\tif(code == 0) successCount++;\n\t\t\t\t} catch(CompilationFailedError err) {\n\t\t\t\t\tSystem.err.println(err);\n\t\t\t\t\tfail();\n\t\t\t\t\tif(!params.editor.isEmpty()) {\n\t\t\t\t\t\tlaunchEditor(params.editor, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(params.clean) FileUtils.deleteRecursive(params.outPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(modulePaths.size() > 1) {\n\t\t\t\tSystem.out.println(modulePaths.size()+\" compiled (\"+successCount\n\t\t\t\t\t\t+\" success, \"+(modulePaths.size() - successCount)+\" failed)\");\n\t\t\t}\n\t\t\t\n\t\t\tif(params.slave) {\n\t\t\t\tSystem.out.println(\".-------------( ready )-------------.\\n\");\n\t\t\t\treader.readLine();\n\t\t\t} else {\n\t\t\t\tif(successCount < modulePaths.size()) {\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} while(params.slave);\n\t\t\n\t}\n\n\tprivate void ok() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;32m[ OK ]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[ OK ]\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void fail() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;31m[FAIL]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[FAIL]\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void launchEditor(final String editor, final CompilationFailedError err) {\n\t\t\n\t\tif(err.getLocation() == null) return;\n\t\t\n\t\tThread thread = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\t\tFileLocation location = err.getLocation();\n\t\t\t\t\tString absolutePath = new File(location.getFileName()).getAbsolutePath();\n\t\t\t\t\tif(editor.equals(\"geany\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath+\":\"+location.getLineNumber()+\":\"+(location.getLinePos() - 1));\n\t\t\t\t\t} else if(editor.equals(\"mate\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath, \"-l\", String.valueOf(location.getLineNumber()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessUtils.redirectIO(builder.start());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.setDaemon(true);\n\t\tthread.start();\n\t\t\n\t}\n\n\tprivate void compileNasms(List<String> nasms, Collection<String> list) throws IOException, InterruptedException {\n\t\t\n\t\tboolean has = false;\n\t\t\n\t\tList<String> command = new ArrayList<String>();\n\t\tcommand.add(findExec(\"nasm\").getPath());\n\t\tcommand.add(\"-f\");\n\t\tcommand.add(\"elf\");\n\t\tfor(String nasm: nasms) {\n\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\tcommand.add(nasm);\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(has) {\n\t\t\tProcessBuilder builder = new ProcessBuilder(command);\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tint code = process.waitFor();\n\t\t\tif(code != 0) {\n\t\t\t\tSystem.err.println(\"nasm failed, aborting compilation process\");\n\t\t\t\tSystem.exit(code);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String nasm: nasms) {\n\t\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\t\tlist.add(nasm.substring(0, nasm.length() - 1) + \"o\");\n\t\t\t\t} else {\n\t\t\t\t\tlist.add(nasm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist.addAll(nasms);\n\t\t}\n\t\t\n\t}\n\n\tprotected int parse(String modulePath) throws InterruptedException, IOException {\n\t\t\n\t\tparams.outPath.mkdirs();\n\t\tlong tt1 = System.nanoTime();\n\t\tModule module = new Parser(params).parse(modulePath);\n\t\tmodule.setMain(true);\n\t\tlong tt2 = System.nanoTime();\n\t\t\n\t\tArrayList<Module> list = new ArrayList<Module>();\n\t\tcollectModules(module, list);\n\t\ttinker(list);\n\t\t\n\t\tlong tt3 = System.nanoTime();\n\t\toutput(module, new HashSet<Module>());\n\t\tlong tt4 = System.nanoTime();\n\t\tint code = compile(module);\n\t\tlong tt5 = System.nanoTime();\n\n\t\tif(params.timing) {\n\t\t\tSystem.out.printf(\"parse: %.2f ms\\ttinker: %.2f ms\\toutput: %.2f ms\\tcc: %.2f ms\\tTOTAL %.2f ms\\n\",\n\t\t\t\t\tFloat.valueOf((tt2 - tt1) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt3 - tt2) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt4 - tt3) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt4) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt1) / 1000000.0f));\n\t\t}\n\t\t\n\t\tif(code == 0) {\n\t\t\tif(params.shout) ok();\n\t\t\tif(params.run) {\n\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\tbuilder.command(\"./\"+module.getSimpleName());\n\t\t\t\tProcess process = builder.start();\n\t\t\t\tProcessUtils.redirectIO(process);\n\t\t\t\tprocess.waitFor();\n\t\t\t}\n\t\t} else if(params.shout) fail();\n\t\treturn code;\n\t\t\n\t}\n\t\n\tprotected void output(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\toutput(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\tnew CGenerator(params.outPath, module).generate(params);\n\t}\n\n\tprotected void collectModules(Module module, List<Module> list) throws IOException {\n\t\tlist.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!list.contains(imp.getModule())) {\n\t\t\t\tcollectModules(imp.getModule(), list);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected void tinker(List<Module> list) throws IOException {\n\t\tTinkerer tink = new Tinkerer();\n\t\ttink.process(list, params);\n\t}\n\n\tprotected int compile(Module module) throws Error,\n\t\t\tIOException, InterruptedException {\n\t\t\n\t\tcompiler.reset();\n\t\t\n\t\tfor(Include inc: module.getIncludes()) {\n\t\t\tif(inc.getMode() == Mode.LOCAL) {\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.copy(new File(inc.getPath() + \".h\"),\n\t\t\t\t\t\tnew File(params.outPath, inc.getPath() + \".h\"));\n\t\t\t\t} catch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(params.debug) compiler.setDebugEnabled();\t\t\n\t\tcompiler.addIncludePath(new File(params.distLocation, \"libs/headers/\").getPath());\n\t\tcompiler.addIncludePath(params.outPath.getPath());\n\t\taddDeps(compiler, module, new HashSet<Module>());\n\t\tfor(String dynamicLib: params.dynamicLibs) {\n\t\t\tcompiler.addDynamicLibrary(dynamicLib);\n\t\t}\n\t\tfor(String additional: additionals) {\n\t\t\tcompiler.addObjectFile(additional);\n\t\t}\n\t\tfor(String compilerArg: compilerArgs) {\n\t\t\tcompiler.addObjectFile(compilerArg);\n\t\t}\n\t\t\n\t\tif(params.link) {\n\t\t\tcompiler.setOutputPath(module.getSimpleName());\n\t\t\tCollection<String> libs = getFlagsFromUse(module);\n\t\t\tfor(String lib: libs) compiler.addObjectFile(lib);\n\t\t\t\n\t\t\tcompiler.addDynamicLibrary(\"pthread\");\n\t\t\tif(params.dynGC) {\n\t\t\t\tcompiler.addDynamicLibrary(\"gc\");\n\t\t\t} else {\n\t\t\t\tcompiler.addObjectFile(new File(params.distLocation, \"libs/\"\n\t\t\t\t\t\t+ Target.guessHost().toString(params.arch.equals(\"\") ? Target.getArch() : params.arch) + \"/libgc.a\").getPath());\n\t\t\t}\n\t\t} else {\n\t\t\tcompiler.setCompileOnly();\n\t\t}\n\t\t\n\t\tif(params.verbose) compiler.printCommandLine();\n\t\t\n\t\tint code = compiler.launch();\n\t\tif(code != 0) {\n\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\n\tprotected Collection<String> getFlagsFromUse(Module module) throws IOException, InterruptedException {\n\n\t\tSet<String> list = new HashSet<String>();\n\t\tSet<Module> done = new HashSet<Module>();\n\t\tgetFlagsFromUse(module, list, done, new HashSet<UseDef>());\n\t\treturn list;\n\t\t\n\t}\n\n\tprotected void getFlagsFromUse(Module module, Set<String> flagsDone, Set<Module> modulesDone, Set<UseDef> usesDone) throws IOException, InterruptedException {\n\n\t\tif(modulesDone.contains(module)) return;\n\t\tmodulesDone.add(module);\n\t\t\n\t\tfor(Use use: module.getUses()) {\n\t\t\tUseDef useDef = use.getUseDef();\n\t\t\tgetFlagsFromUse(useDef, flagsDone, usesDone);\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tgetFlagsFromUse(imp.getModule(), flagsDone, modulesDone, usesDone);\n\t\t}\n\t\t\n\t}\n\n\tprivate void getFlagsFromUse(UseDef useDef, Set<String> flagsDone,\n\t\t\tSet<UseDef> usesDone) throws IOException, InterruptedException {\n\t\t\n\t\tif(usesDone.contains(useDef)) return;\n\t\tusesDone.add(useDef);\n\t\tcompileNasms(useDef.getLibs(), flagsDone);\n\t\tfor(String pkg: useDef.getPkgs()) {\n\t\t\tPkgInfo info = PkgConfigFrontend.getInfo(pkg);\n\t\t\tfor(String cflag: info.cflags) {\n\t\t\t\tif(!flagsDone.contains(cflag)) {\n\t\t\t\t\tflagsDone.add(cflag);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(String library: info.libraries) {\n\t\t\t\t // FIXME lazy\n\t\t\t\tString lpath = \"-l\"+library;\n\t\t\t\tif(!flagsDone.contains(lpath)) {\n\t\t\t\t\tflagsDone.add(lpath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(String includePath: useDef.getIncludePaths()) {\n\t\t\t // FIXME lazy too.\n\t\t\tString ipath = \"-I\"+includePath;\n\t\t\tif(!flagsDone.contains(ipath)) {\n\t\t\t\tflagsDone.add(ipath);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(String libPath: useDef.getLibPaths()) {\n\t\t\t // FIXME lazy too.\n\t\t\tString lpath = \"-L\"+libPath;\n\t\t\tif(!flagsDone.contains(lpath)) {\n\t\t\t\tflagsDone.add(lpath);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Requirement req: useDef.getRequirements()) {\n\t\t\tgetFlagsFromUse(req.getUseDef(), flagsDone, usesDone);\n\t\t}\n\t\t\n\t}\n\n\tprotected File findExec(String name) throws Error {\n\t\t\n\t\tFile execFile = ShellUtils.findExecutable(name);\n\t\tif(execFile == null) {\n\t\t\texecFile = ShellUtils.findExecutable(name+\".exe\");\n\t\t}\n\t\tif(execFile == null) {\n\t\t\tthrow new Error(name+\" not found :/\");\n\t\t}\n\t\treturn execFile;\n\t\t\n\t}\n\n\tprotected void addDeps(AbstractCompiler compiler, Module module, Set<Module> done) {\n\t\t\n\t\tdone.add(module);\n\t\tcompiler.addObjectFile(new File(params.outPath, module.getPath(\".c\")).getPath());\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\taddDeps(compiler, imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","lineNo":520}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.PotentiallyStatic;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.VariableAccess;\n\npublic class AccessWriter {\n\n\tpublic static void writeMember(MemberAccess memberAccess, CGenerator cgen) throws IOException {\n\n\t\tif(memberAccess.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) memberAccess.getExpression();\n\t\t\tif(varAcc.getRef() instanceof TypeDecl) {\n\t\t\t\tif(memberAccess.getName().equals(\"class\")) {\n\t\t\t\t\tcgen.current.app(varAcc.getName()).app(\"_class()\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tTypeDecl refTypeDecl = memberAccess.getRef().getTypeDecl();\n\t\tboolean isStatic = ((PotentiallyStatic) memberAccess.getRef()).isStatic();\n\t\t\n\t\tif(memberAccess.getRef() instanceof FunctionDecl) {\n\t\t\tFunctionDecl funcDecl = (FunctionDecl) memberAccess.getRef();\n\t\t\tcgen.current.app(\"((\").app(funcDecl.getTypeDecl().getName()).app(\"Class *) \");\n\t\t\tmemberAccess.getExpression().accept(cgen);\n\t\t\tcgen.current.app(\")->\").app(memberAccess.getName());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(isStatic) {\n\n\t\t\tif(memberAccess.getRef().isExtern() && !memberAccess.getRef().getExternName().isEmpty()) {\n\t\t\t\tcgen.current.app(memberAccess.getRef().getExternName());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcgen.current.app(\"((\").app(refTypeDecl.getType().getMangledName())\n\t\t\t\t.app(\"Class*) \").app(refTypeDecl.getType().getMangledName())\n\t\t\t\t.app(\"_class())->\").app(memberAccess.getName());\n\t\t\t\n\t\t} else {\n\t\t\n\t\t\tboolean isArrow = (refTypeDecl instanceof ClassDecl);\n\t\t\t\n\t\t\tExpression expression = memberAccess.getExpression();\n\t\t\tif(!isArrow && expression instanceof Dereference) {\n\t\t\t\tDereference deref = (Dereference) expression;\n\t\t\t\texpression = deref.getExpression();\n\t\t\t\tisArrow = true;\n\t\t\t}\n\t\t\t\n\t\t\tif(refTypeDecl.getType().equals(expression.getType())) {\t\t\n\t\t\t\texpression.accept(cgen);\n\t\t\t} else {\n\t\t\t\tcgen.current.app(\"((\");\n\t\t\t\tcgen.current.app(refTypeDecl.getInstanceType().getName());\n\t\t\t\tTypeWriter.writeFinale(membExprType(memberAccess), cgen);\n\t\t\t\tcgen.current.app(\") \");\n\t\t\t\texpression.accept(cgen);\n\t\t\t\tcgen.current.app(')');\n\t\t\t}\n\t\t\t\n\t\t\tif(isArrow) {\n\t\t\t\tcgen.current.app(\"->\");\n\t\t\t} else {\n\t\t\t\tcgen.current.app('.');\n\t\t\t}\n\t\t\twriteVariable(memberAccess, false, cgen);\n\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate static Type membExprType(MemberAccess memberAccess) {\n\t\treturn memberAccess.getExpression().getType();\n\t}\n\t\n\tpublic static void writeVariable(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\t\n\t\tif(variableAccess.getRef() instanceof TypeDecl && !(variableAccess.getRef() instanceof TypeParam)) {\n\t\t\tcgen.current.app(variableAccess.getName()).app(\"_class()\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint refLevel = variableAccess.getRef().getType().getReferenceLevel();\n\t\t\n\t\tif(doTypeParams) {\n\t\t\tif(variableAccess.getType().isGeneric()) {\n\t\t\t\trefLevel++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app('(');\n\t\t\tfor(int i = 0; i < refLevel; i++) {\n\t\t\t\tcgen.current.app('*');\n\t\t\t}\n\t\t}\n\t\tcgen.current.app(variableAccess.getRef().getExternName(variableAccess));\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app(')');\n\t\t}\n\t\t\n\t}\n\n\tpublic static void writeArray(ArrayAccess arrayAccess, CGenerator cgen) throws IOException {\n\t\tarrayAccess.getVariable().accept(cgen);\n\t\tcgen.current.app('[');\n\t\tarrayAccess.getIndex().accept(cgen);\n\t\tcgen.current.app(']');\n\t}\n\t\n\tpublic static void write(Access access, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\tif(access instanceof ArrayAccess) writeArray((ArrayAccess) access, cgen);\n\t\telse if(access instanceof MemberAccess) writeMember((MemberAccess) access, cgen);\n\t\telse writeVariable((VariableAccess) access, doTypeParams, cgen);\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.PotentiallyStatic;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.VariableAccess;\n\npublic class AccessWriter {\n\n\tpublic static void writeMember(MemberAccess memberAccess, CGenerator cgen) throws IOException {\n\n\t\tif(memberAccess.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) memberAccess.getExpression();\n\t\t\tif(varAcc.getRef() instanceof TypeDecl) {\n\t\t\t\tif(memberAccess.getName().equals(\"class\")) {\n\t\t\t\t\tcgen.current.app(varAcc.getName()).app(\"_class()\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tTypeDecl refTypeDecl = memberAccess.getRef().getTypeDecl();\n\t\tboolean isStatic = ((PotentiallyStatic) memberAccess.getRef()).isStatic();\n\t\t\n\t\tif(memberAccess.getRef() instanceof FunctionDecl) {\n\t\t\tFunctionDecl funcDecl = (FunctionDecl) memberAccess.getRef();\n\t\t\tTypeDecl typeDecl = funcDecl.getTypeDecl();\n\t\t\tString typeName = typeDecl.getName();\n\t\t\tif(typeDecl instanceof ClassDecl) {\n\t\t\t\tClassDecl classDecl = (ClassDecl) typeDecl;\n\t\t\t\tClassDecl baseClass = classDecl.getBaseClass(funcDecl);\n\t\t\t\ttypeName = baseClass.getName();\n\t\t\t}\n\t\t\tcgen.current.app(\"((\").app(typeName).app(\"Class *) \");\n\t\t\tmemberAccess.getExpression().accept(cgen);\n\t\t\tcgen.current.app(\")->\").app(memberAccess.getName());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(isStatic) {\n\n\t\t\tif(memberAccess.getRef().isExtern() && !memberAccess.getRef().getExternName().isEmpty()) {\n\t\t\t\tcgen.current.app(memberAccess.getRef().getExternName());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcgen.current.app(\"((\").app(refTypeDecl.getType().getMangledName())\n\t\t\t\t.app(\"Class*) \").app(refTypeDecl.getType().getMangledName())\n\t\t\t\t.app(\"_class())->\").app(memberAccess.getName());\n\t\t\t\n\t\t} else {\n\t\t\n\t\t\tboolean isArrow = (refTypeDecl instanceof ClassDecl);\n\t\t\t\n\t\t\tExpression expression = memberAccess.getExpression();\n\t\t\tif(!isArrow && expression instanceof Dereference) {\n\t\t\t\tDereference deref = (Dereference) expression;\n\t\t\t\texpression = deref.getExpression();\n\t\t\t\tisArrow = true;\n\t\t\t}\n\t\t\t\n\t\t\tif(refTypeDecl.getType().equals(expression.getType())) {\t\t\n\t\t\t\texpression.accept(cgen);\n\t\t\t} else {\n\t\t\t\tcgen.current.app(\"((\");\n\t\t\t\tcgen.current.app(refTypeDecl.getInstanceType().getName());\n\t\t\t\tTypeWriter.writeFinale(membExprType(memberAccess), cgen);\n\t\t\t\tcgen.current.app(\") \");\n\t\t\t\texpression.accept(cgen);\n\t\t\t\tcgen.current.app(')');\n\t\t\t}\n\t\t\t\n\t\t\tif(isArrow) {\n\t\t\t\tcgen.current.app(\"->\");\n\t\t\t} else {\n\t\t\t\tcgen.current.app('.');\n\t\t\t}\n\t\t\twriteVariable(memberAccess, false, cgen);\n\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate static Type membExprType(MemberAccess memberAccess) {\n\t\treturn memberAccess.getExpression().getType();\n\t}\n\t\n\tpublic static void writeVariable(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\t\n\t\tif(variableAccess.getRef() instanceof TypeDecl && !(variableAccess.getRef() instanceof TypeParam)) {\n\t\t\tcgen.current.app(variableAccess.getName()).app(\"_class()\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint refLevel = variableAccess.getRef().getType().getReferenceLevel();\n\t\t\n\t\tif(doTypeParams) {\n\t\t\tif(variableAccess.getType().isGeneric()) {\n\t\t\t\trefLevel++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app('(');\n\t\t\tfor(int i = 0; i < refLevel; i++) {\n\t\t\t\tcgen.current.app('*');\n\t\t\t}\n\t\t}\n\t\tcgen.current.app(variableAccess.getRef().getExternName(variableAccess));\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app(')');\n\t\t}\n\t\t\n\t}\n\n\tpublic static void writeArray(ArrayAccess arrayAccess, CGenerator cgen) throws IOException {\n\t\tarrayAccess.getVariable().accept(cgen);\n\t\tcgen.current.app('[');\n\t\tarrayAccess.getIndex().accept(cgen);\n\t\tcgen.current.app(']');\n\t}\n\t\n\tpublic static void write(Access access, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\tif(access instanceof ArrayAccess) writeArray((ArrayAccess) access, cgen);\n\t\telse if(access instanceof MemberAccess) writeMember((MemberAccess) access, cgen);\n\t\telse writeVariable((VariableAccess) access, doTypeParams, cgen);\n\t}\n\t\n}\n","lineNo":37}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.PotentiallyStatic;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.VariableAccess;\n\npublic class AccessWriter {\n\n\tpublic static void writeMember(MemberAccess memberAccess, CGenerator cgen) throws IOException {\n\n\t\tif(memberAccess.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) memberAccess.getExpression();\n\t\t\tif(varAcc.getRef() instanceof TypeDecl) {\n\t\t\t\tif(memberAccess.getName().equals(\"class\")) {\n\t\t\t\t\tcgen.current.app(varAcc.getName()).app(\"_class()\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tTypeDecl refTypeDecl = memberAccess.getRef().getTypeDecl();\n\t\tboolean isStatic = ((PotentiallyStatic) memberAccess.getRef()).isStatic();\n\t\t\n\t\tif(memberAccess.getRef() instanceof FunctionDecl) {\n\t\t\tFunctionDecl funcDecl = (FunctionDecl) memberAccess.getRef();\n\t\t\tcgen.current.app(\"((\").app(funcDecl.getTypeDecl().getName()).app(\"Class *) \");\n\t\t\tmemberAccess.getExpression().accept(cgen);\n\t\t\tcgen.current.app(\")->\").app(memberAccess.getName());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(isStatic) {\n\n\t\t\tif(memberAccess.getRef().isExtern() && !memberAccess.getRef().getExternName().isEmpty()) {\n\t\t\t\tcgen.current.app(memberAccess.getRef().getExternName());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcgen.current.app(\"((\").app(refTypeDecl.getType().getMangledName())\n\t\t\t\t.app(\"Class*) \").app(refTypeDecl.getType().getMangledName())\n\t\t\t\t.app(\"_class())->\").app(memberAccess.getName());\n\t\t\t\n\t\t} else {\n\t\t\n\t\t\tboolean isArrow = (refTypeDecl instanceof ClassDecl);\n\t\t\t\n\t\t\tExpression expression = memberAccess.getExpression();\n\t\t\tif(!isArrow && expression instanceof Dereference) {\n\t\t\t\tDereference deref = (Dereference) expression;\n\t\t\t\texpression = deref.getExpression();\n\t\t\t\tisArrow = true;\n\t\t\t}\n\t\t\t\n\t\t\tif(refTypeDecl.getType().equals(expression.getType())) {\t\t\n\t\t\t\texpression.accept(cgen);\n\t\t\t} else {\n\t\t\t\tcgen.current.app(\"((\");\n\t\t\t\tcgen.current.app(refTypeDecl.getInstanceType().getName());\n\t\t\t\tTypeWriter.writeFinale(membExprType(memberAccess), cgen);\n\t\t\t\tcgen.current.app(\") \");\n\t\t\t\texpression.accept(cgen);\n\t\t\t\tcgen.current.app(')');\n\t\t\t}\n\t\t\t\n\t\t\tif(isArrow) {\n\t\t\t\tcgen.current.app(\"->\");\n\t\t\t} else {\n\t\t\t\tcgen.current.app('.');\n\t\t\t}\n\t\t\twriteVariable(memberAccess, false, cgen);\n\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate static Type membExprType(MemberAccess memberAccess) {\n\t\treturn memberAccess.getExpression().getType();\n\t}\n\t\n\tpublic static void writeVariable(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\t\n\t\tif(variableAccess.getRef() instanceof TypeDecl && !(variableAccess.getRef() instanceof TypeParam)) {\n\t\t\tcgen.current.app(variableAccess.getName()).app(\"_class()\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint refLevel = variableAccess.getRef().getType().getReferenceLevel();\n\t\t\n\t\tif(doTypeParams) {\n\t\t\tif(variableAccess.getType().isGeneric()) {\n\t\t\t\trefLevel++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app('(');\n\t\t\tfor(int i = 0; i < refLevel; i++) {\n\t\t\t\tcgen.current.app('*');\n\t\t\t}\n\t\t}\n\t\tcgen.current.app(variableAccess.getRef().getExternName(variableAccess));\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app(')');\n\t\t}\n\t\t\n\t}\n\n\tpublic static void writeArray(ArrayAccess arrayAccess, CGenerator cgen) throws IOException {\n\t\tarrayAccess.getVariable().accept(cgen);\n\t\tcgen.current.app('[');\n\t\tarrayAccess.getIndex().accept(cgen);\n\t\tcgen.current.app(']');\n\t}\n\t\n\tpublic static void write(Access access, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\tif(access instanceof ArrayAccess) writeArray((ArrayAccess) access, cgen);\n\t\telse if(access instanceof MemberAccess) writeMember((MemberAccess) access, cgen);\n\t\telse writeVariable((VariableAccess) access, doTypeParams, cgen);\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.PotentiallyStatic;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.frontend.model.VariableAccess;\n\npublic class AccessWriter {\n\n\tpublic static void writeMember(MemberAccess memberAccess, CGenerator cgen) throws IOException {\n\n\t\tif(memberAccess.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) memberAccess.getExpression();\n\t\t\tif(varAcc.getRef() instanceof TypeDecl) {\n\t\t\t\tif(memberAccess.getName().equals(\"class\")) {\n\t\t\t\t\tcgen.current.app(varAcc.getName()).app(\"_class()\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tTypeDecl refTypeDecl = memberAccess.getRef().getTypeDecl();\n\t\tboolean isStatic = ((PotentiallyStatic) memberAccess.getRef()).isStatic();\n\t\t\n\t\tif(memberAccess.getRef() instanceof FunctionDecl) {\n\t\t\tFunctionDecl funcDecl = (FunctionDecl) memberAccess.getRef();\n\t\t\tTypeDecl typeDecl = funcDecl.getTypeDecl();\n\t\t\tString typeName = typeDecl.getName();\n\t\t\tif(typeDecl instanceof ClassDecl) {\n\t\t\t\tClassDecl classDecl = (ClassDecl) typeDecl;\n\t\t\t\tClassDecl baseClass = classDecl.getBaseClass(funcDecl);\n\t\t\t\ttypeName = baseClass.getName();\n\t\t\t}\n\t\t\tcgen.current.app(\"((\").app(typeName).app(\"Class *) \");\n\t\t\tmemberAccess.getExpression().accept(cgen);\n\t\t\tcgen.current.app(\")->\").app(memberAccess.getName());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(isStatic) {\n\n\t\t\tif(memberAccess.getRef().isExtern() && !memberAccess.getRef().getExternName().isEmpty()) {\n\t\t\t\tcgen.current.app(memberAccess.getRef().getExternName());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcgen.current.app(\"((\").app(refTypeDecl.getType().getMangledName())\n\t\t\t\t.app(\"Class*) \").app(refTypeDecl.getType().getMangledName())\n\t\t\t\t.app(\"_class())->\").app(memberAccess.getName());\n\t\t\t\n\t\t} else {\n\t\t\n\t\t\tboolean isArrow = (refTypeDecl instanceof ClassDecl);\n\t\t\t\n\t\t\tExpression expression = memberAccess.getExpression();\n\t\t\tif(!isArrow && expression instanceof Dereference) {\n\t\t\t\tDereference deref = (Dereference) expression;\n\t\t\t\texpression = deref.getExpression();\n\t\t\t\tisArrow = true;\n\t\t\t}\n\t\t\t\n\t\t\tif(refTypeDecl.getType().equals(expression.getType())) {\t\t\n\t\t\t\texpression.accept(cgen);\n\t\t\t} else {\n\t\t\t\tcgen.current.app(\"((\");\n\t\t\t\tcgen.current.app(refTypeDecl.getInstanceType().getName());\n\t\t\t\tTypeWriter.writeFinale(membExprType(memberAccess), cgen);\n\t\t\t\tcgen.current.app(\") \");\n\t\t\t\texpression.accept(cgen);\n\t\t\t\tcgen.current.app(')');\n\t\t\t}\n\t\t\t\n\t\t\tif(isArrow) {\n\t\t\t\tcgen.current.app(\"->\");\n\t\t\t} else {\n\t\t\t\tcgen.current.app('.');\n\t\t\t}\n\t\t\twriteVariable(memberAccess, false, cgen);\n\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate static Type membExprType(MemberAccess memberAccess) {\n\t\treturn memberAccess.getExpression().getType();\n\t}\n\t\n\tpublic static void writeVariable(VariableAccess variableAccess, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\t\n\t\tif(variableAccess.getRef() instanceof TypeDecl && !(variableAccess.getRef() instanceof TypeParam)) {\n\t\t\tcgen.current.app(variableAccess.getName()).app(\"_class()\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint refLevel = variableAccess.getRef().getType().getReferenceLevel();\n\t\t\n\t\tif(doTypeParams) {\n\t\t\tif(variableAccess.getType().isGeneric()) {\n\t\t\t\trefLevel++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app('(');\n\t\t\tfor(int i = 0; i < refLevel; i++) {\n\t\t\t\tcgen.current.app('*');\n\t\t\t}\n\t\t}\n\t\tcgen.current.app(variableAccess.getRef().getExternName(variableAccess));\n\t\tif(refLevel > 0) {\n\t\t\tcgen.current.app(')');\n\t\t}\n\t\t\n\t}\n\n\tpublic static void writeArray(ArrayAccess arrayAccess, CGenerator cgen) throws IOException {\n\t\tarrayAccess.getVariable().accept(cgen);\n\t\tcgen.current.app('[');\n\t\tarrayAccess.getIndex().accept(cgen);\n\t\tcgen.current.app(']');\n\t}\n\t\n\tpublic static void write(Access access, boolean doTypeParams, CGenerator cgen) throws IOException {\n\t\tif(access instanceof ArrayAccess) writeArray((ArrayAccess) access, cgen);\n\t\telse if(access instanceof MemberAccess) writeMember((MemberAccess) access, cgen);\n\t\telse writeVariable((VariableAccess) access, doTypeParams, cgen);\n\t}\n\t\n}\n","lineNo":38}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type type, NodeList<Node> stack) {\n\t\tint i = -1;\n\t\tfor(VariableAccess exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tVariableAccess expr = resolveTypeParam(exprParam.getName(), stack, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = resolveTypeParam(typeParam.getName(), stack, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, genType,  atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected VariableAccess resolveTypeParam(String typeParam, NodeList<Node> stack, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tVariableAccess result = null;\n\t\t\n\t\tint i = -1;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\tExpression callArg = arguments.get(i);\n\t\t\t\tresult = new MemberAccess(callArg, \"class\", callArg.startToken);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tif(decl.getType() == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = decl.getType().getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tExpression result = resolveTypeParam(typeRef.getName(), stack, true);\n\t\tif(result != null) {\n\t\t\tdecl.setType(result.getType());\n\t\t}\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix.isEmpty() || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix.isEmpty()) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\tprotected Type realType;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t\tthis.realType = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\treturn realType;\n\t}\n\t\n\tprivate Type realTypize(Type typeArg, Resolver res, NodeList<Node> stack) {\n\t\t\n\t\t\n\t\tType realType = getRealType(typeArg.getName(), stack, res, true);\n\t\t\n\t\tType type = null;\n\t\tif(realType == null) {\n\t\t\ttype = typeArg.clone();\n\t\t} else {\n\t\t\ttype = realType.clone();\n\t\t}\n\t\t\n\t\tint i = -1;\n\t\tfor(Access exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tString name = \"\";\n\t\t\tif(exprParam instanceof VariableAccess) {\n\t\t\t\tname = ((VariableAccess) exprParam).getName();\n\t\t\t} else if(exprParam instanceof FunctionCall) {\n\t\t\t\tname = ((FunctionCall) exprParam).getName();\n\t\t\t}\n\t\t\tAccess expr = getExprParam(name, stack, res, true);\n\t\t\tif(expr != null){\n\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t\t\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tresolveRegular(stack, res, fatal);\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null) {\n \t\t\tif(fatal) {\n \t\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n \t\t\t\tString guess = guessCorrectName(stack, res);\n \t\t\t\tif(guess != null) {\n \t\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n \t\t\t\t}\n \t\t\t\tthrow new OocCompilationError(this, stack, message);\n \t\t\t}\n \t\t\treturn Response.LOOP;\n \t\t}\n\t\t\n \t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal) {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Find all variable accesses to fill this function's type params\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = getExprParam(typeParam.getName(), stack, res, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\t// Determine the real type of this function call.\n\t\tif(realType == null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType candidate = realTypize(retType, res, stack);\n\t\t\t\tif(candidate == null) {\n\t\t\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"RealType still null, can't resolve generic type \"+retType);\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\trealType = candidate;\n\t\t\t} else {\n\t\t\t\trealType = retType;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, res, genType, atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected Type getRealType(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\treturn arguments.get(i).getType();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected Expression getRealExpr(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\tint i = -1;\n\t\tboolean isFirst = true;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(isFirst && impl.hasThis()) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\treturn arguments.get(i);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprotected Access getExprParam(String typeParam, NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\n\t\tif(impl == null) return null;\n\t\t\n\t\tAccess result = null;\n\t\tExpression callArg = getRealExpr(typeParam, stack, res, fatal);\n\t\tif(callArg != null) {\n\t\t\tMemberAccess membAcc = new MemberAccess(callArg, \"class\", callArg.startToken);\n\t\t\tNodeList<Access> nl = new NodeList<Access>(1, startToken);\n\t\t\tnl.add(membAcc);\n\t\t\tstack.push(nl);\n\t\t\tmembAcc.resolve(stack, res, fatal);\n\t\t\tstack.pop(nl);\n\t\t\tresult = nl.get(0);\n\t\t}\n\t\t\t\n\t\treturn result;\n\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType, boolean fatal) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack, Resolver res,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tType declType = decl.getType();\n\t\tdeclType = realTypize(declType, res, stack);\n\t\tif(declType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't resolve type of \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\tDeclaration typeRef = declType.getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tdecl.setType(declType); // fixate the type\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType() == null || callArg.getType() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bestDistance > 3) return null;\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\") && (suffix.isEmpty() || decl.getSuffix().equals(suffix))) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected boolean resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return false;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack, final Resolver res) {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\tif(suffix.isEmpty()) {\n\t\t\treturn name+getArgsRepr();\n\t\t}\n\t\treturn name+\"~\"+suffix+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl decl) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = decl.getArguments();\n\t\tif(matchesArgs(decl)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(decl.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType() == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","lineNo":359}
{"Smelly Sample":"package org.ooc.frontend.compilers;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\n\npublic abstract class BaseCompiler implements AbstractCompiler {\n\t\n\tprotected List<String> command = new ArrayList<String>();\n\tprotected String executablePath;\n\t\n\tpublic BaseCompiler(String executableName) {\n\t\texecutablePath = ShellUtils.findExecutable(executableName).getName();\n\t\treset();\n\t}\n\t\n\t@Override\n\tpublic int launch() throws IOException, InterruptedException {\n\t\tProcessBuilder builder = new ProcessBuilder();\n\t\tbuilder.command(command);\n\t\tProcess process = builder.start();\n\t\tProcessUtils.redirectIO(process);\n\t\treturn process.waitFor();\n\t}\n\t\n\t@Override\n\tpublic void printCommandLine() {\n\t\tStringBuilder commandLine = new StringBuilder();\n\t\tfor(String arg: command) {\n\t\t\tcommandLine.append(arg);\n\t\t\tcommandLine.append(' ');\n\t\t}\n\t\tSystem.out.println(commandLine.toString());\n\t}\n\t\n\t@Override\n\tpublic void reset() {\n\t\tcommand.clear();\n\t\tcommand.add(executablePath);\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend.compilers;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\n\npublic abstract class BaseCompiler implements AbstractCompiler {\n\t\n\tprotected List<String> command = new ArrayList<String>();\n\tprotected String executablePath;\n\t\n\t@SuppressWarnings(\"null\")\n\tpublic BaseCompiler(String executableName) {\n\t\tFile execFile = ShellUtils.findExecutable(executableName);\n\t\tif(execFile == null) {\n\t\t\tShellUtils.findExecutable(executableName + \".exe\");\n\t\t\tif(execFile == null) {\n\t\t\t\tShellUtils.findExecutable(executableName, true);\n\t\t\t}\n\t\t}\n\t\texecutablePath = execFile.getName();\n\t\treset();\n\t}\n\t\n\t@Override\n\tpublic int launch() throws IOException, InterruptedException {\n\t\tProcessBuilder builder = new ProcessBuilder();\n\t\tbuilder.command(command);\n\t\tProcess process = builder.start();\n\t\tProcessUtils.redirectIO(process);\n\t\treturn process.waitFor();\n\t}\n\t\n\t@Override\n\tpublic void printCommandLine() {\n\t\tStringBuilder commandLine = new StringBuilder();\n\t\tfor(String arg: command) {\n\t\t\tcommandLine.append(arg);\n\t\t\tcommandLine.append(' ');\n\t\t}\n\t\tSystem.out.println(commandLine.toString());\n\t}\n\t\n\t@Override\n\tpublic void reset() {\n\t\tcommand.clear();\n\t\tcommand.add(executablePath);\n\t}\n\n}\n","lineNo":18}
{"Smelly Sample":"package org.ooc.frontend;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.ooc.backend.cdirty.CGenerator;\nimport org.ooc.frontend.compilers.AbstractCompiler;\nimport org.ooc.frontend.compilers.Clang;\nimport org.ooc.frontend.compilers.Gcc;\nimport org.ooc.frontend.compilers.Icc;\nimport org.ooc.frontend.compilers.Tcc;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.Include.Mode;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.ModuleParser;\nimport org.ooc.frontend.parser.Parser;\nimport org.ooc.frontend.pkgconfig.PkgConfigFrontend;\nimport org.ooc.frontend.pkgconfig.PkgInfo;\nimport org.ooc.middle.Tinkerer;\nimport org.ooc.middle.UseDef;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.FileLocation;\n\npublic class CommandLine {\n\t\n\tpublic static void main(String[] argv) throws InterruptedException, IOException {\n\t\tnew CommandLine(argv);\n\t}\n\t\n\tprotected BuildParams params = new BuildParams();\n\tList<String> additionals = new ArrayList<String>();\n\tList<String> compilerArgs = new ArrayList<String>();\n\tprivate AbstractCompiler compiler = null;\n\t\n\tpublic CommandLine(String[] args) throws InterruptedException, IOException {\n\t\t\n\t\tList<String> modulePaths = new ArrayList<String>();\n\t\tList<String> nasms = new ArrayList<String>();\n\t\t\n\t\tfor(String arg: args) {\n\t\t\tif(arg.startsWith(\"-\")) {\n        \t\tString option = arg.substring(1);\n        \t\tif(option.startsWith(\"sourcepath\")) {\n        \t\t\t\n        \t\t\tString sourcePathOption = arg.substring(arg.indexOf('=') + 1);\n        \t\t\tStringTokenizer tokenizer = new StringTokenizer(sourcePathOption, File.pathSeparator);\n        \t\t\twhile(tokenizer.hasMoreTokens()) {\n        \t\t\t\tparams.sourcePath.add(tokenizer.nextToken());\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"outpath\")) {\n        \t\t\t\n        \t\t\tparams.outPath = new File(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"incpath\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"I\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"libpath\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"editor\")) {\n        \t\t\t\n        \t\t\tparams.editor = arg.substring(arg.indexOf('=') + 1);\n        \t\t\t\n        \t\t} else if(option.equals(\"c\")) {\n        \t\t\t\n        \t\t\tparams.link = false;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"L\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"l\")) {\n        \t\t\t\n        \t\t\tparams.dynamicLibs.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.equals(\"dyngc\")) {\n        \t\t\t\n        \t\t\tparams.dynGC = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"noclean\")) {\n        \t\t\t\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"shout\")) {\n        \t\t\t\n        \t\t\tparams.shout = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"timing\") || option.equals(\"t\")) {\n        \t\t\t\n        \t\t\tparams.timing = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"debug\") || option.equals(\"g\")) {\n        \t\t\t\n        \t\t\tparams.debug = true;\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"verbose\") || option.equals(\"v\")) {\n        \t\t\t\n        \t\t\tparams.verbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"run\") || option.equals(\"r\")) {\n        \t\t\t\n        \t\t\tparams.run = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"V\") || option.equals(\"-version\") || option.equals(\"version\")) {\n        \t\t\t\n        \t\t\tCompilerVersion.printVersion();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"h\") || option.equals(\"-help\") || option.equals(\"help\")) {\n        \t\t\t\n        \t\t\tHelp.printHelp();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"gcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Gcc();\n        \t\t\t\n        \t\t} else if(option.equals(\"icc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Icc();\n        \t\t\t\n        \t\t} else if(option.equals(\"tcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Tcc();\n        \t\t\t\n\t\t\t\t} else if(option.equals(\"clang\")) {\n        \t\t\t\n        \t\t\tcompiler = new Clang();\n        \t\t\t\n        \t\t} else if(option.equals(\"help-backends\") || option.equals(\"-help-backends\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpBackends();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-gcc\") || option.equals(\"-help-gcc\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpGcc();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-make\") || option.equals(\"-help-make\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpMake();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-none\") || option.equals(\"-help-none\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpNone();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"slave\")) {\n        \t\t\t\n        \t\t\tparams.slave = true;\n\n\t\t\t\t} else if(option.startsWith(\"m\")) {\n\t\t\t\t\t\n\t\t\t\t\tString arch = arg.substring(2);\n\t\t\t\t\tif (arch.equals(\"32\") || arch.equals(\"64\"))\n\t\t\t\t\t\tparams.arch = arg.substring(2);\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(\"Unrecognized architecture: \" + arch);\n\t\t\t\n        \t\t} else {\n        \t\t\t\n        \t\t\tSystem.err.println(\"Unrecognized option: '\"+arg+\"'\");\n        \t\t\t\n        \t\t}\n        \t} else if(arg.startsWith(\"+\")) {\n        \t\tcompilerArgs.add(arg.substring(1));\n        \t} else {\n        \t\t\tString lowerArg = arg.toLowerCase();\n\t\t\t\t\tif(lowerArg.endsWith(\".s\")) {\n        \t\t\t\tnasms.add(arg);\n        \t\t\t} else if(lowerArg.endsWith(\".o\") || lowerArg.endsWith(\".c\") || lowerArg.endsWith(\".cpp\")) {\n            \t\t\tadditionals.add(arg);\n            \t\t} else {\n            \t\t\tif(!lowerArg.endsWith(\".ooc\")) {\n            \t\t\t\tmodulePaths.add(arg+\".ooc\");\n            \t\t\t} else {\n            \t\t\t\tmodulePaths.add(arg);\n            \t\t\t}\n            \t\t}\n        \t}\n\t\t}\n\t\t\n\t\tif(modulePaths.isEmpty()) {\n\t\t\tSystem.err.println(\"ooc: no files.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(compiler == null) compiler = new Gcc();\n\t\t\n\t\tif(!nasms.isEmpty()) {\n\t\t\tcompileNasms(nasms, additionals);\n\t\t}\n\t\t\n\t\tif(params.sourcePath.isEmpty()) params.sourcePath.add(\".\");\n\t\tparams.sourcePath.add(params.distLocation + File.separator + \"sdk\");\n\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tdo {\n\t\t\tModuleParser.clearCache();\n\t\t\tint successCount = 0;\n\t\t\tfor(String modulePath: modulePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tint code = parse(modulePath);\n\t\t\t\t\tif(code == 0) successCount++;\n\t\t\t\t} catch(CompilationFailedError err) {\n\t\t\t\t\tSystem.err.println(err);\n\t\t\t\t\tif(!params.editor.isEmpty()) {\n\t\t\t\t\t\tlaunchEditor(params.editor, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(params.clean) FileUtils.deleteRecursive(params.outPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(modulePaths.size() > 1) {\n\t\t\t\tSystem.out.println(modulePaths.size()+\" compiled (\"+successCount\n\t\t\t\t\t\t+\" success, \"+(modulePaths.size() - successCount)+\" failed)\");\n\t\t\t}\n\t\t\tif(params.slave) {\n\t\t\t\tSystem.out.println(\".-------------( ready )-------------.\\n\");\n\t\t\t\treader.readLine();\n\t\t\t}\n\t\t} while(params.slave);\n\t\t\n\t}\n\t\n\tprivate void launchEditor(final String editor, final CompilationFailedError err) {\n\t\t\n\t\tif(err.getLocation() == null) return;\n\t\t\n\t\tThread thread = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\t\tFileLocation location = err.getLocation();\n\t\t\t\t\tString absolutePath = new File(location.getFileName()).getAbsolutePath();\n\t\t\t\t\tif(editor.equals(\"geany\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath+\":\"+location.getLineNumber()+\":\"+(location.getLinePos() - 1));\n\t\t\t\t\t} else if(editor.equals(\"mate\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath, \"-l\", String.valueOf(location.getLineNumber()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessUtils.redirectIO(builder.start());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.setDaemon(true);\n\t\tthread.start();\n\t\t\n\t}\n\n\tprivate void compileNasms(List<String> nasms, Collection<String> list) throws IOException, InterruptedException {\n\t\t\n\t\tboolean has = false;\n\t\t\n\t\tList<String> command = new ArrayList<String>();\n\t\tcommand.add(findExec(\"nasm\").getPath());\n\t\tcommand.add(\"-f\");\n\t\tcommand.add(\"elf\");\n\t\tfor(String nasm: nasms) {\n\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\tcommand.add(nasm);\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(has) {\n\t\t\tProcessBuilder builder = new ProcessBuilder(command);\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tint code = process.waitFor();\n\t\t\tif(code != 0) {\n\t\t\t\tSystem.err.println(\"nasm failed, aborting compilation process\");\n\t\t\t\tSystem.exit(code);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String nasm: nasms) {\n\t\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\t\tlist.add(nasm.substring(0, nasm.length() - 1) + \"o\");\n\t\t\t\t} else {\n\t\t\t\t\tlist.add(nasm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist.addAll(nasms);\n\t\t}\n\t\t\n\t}\n\n\tprotected int parse(String modulePath) throws InterruptedException, IOException {\n\t\t\n\t\tparams.outPath.mkdirs();\n\t\tlong tt1 = System.nanoTime();\n\t\tModule module = new Parser(params).parse(modulePath);\n\t\tmodule.setMain(true);\n\t\tlong tt2 = System.nanoTime();\n\t\ttinker(module, new HashSet<Module>());\n\t\tlong tt3 = System.nanoTime();\n\t\toutput(module, new HashSet<Module>());\n\t\tlong tt4 = System.nanoTime();\n\t\tint code = compile(module);\n\t\tlong tt5 = System.nanoTime();\n\n\t\tif(params.timing) {\n\t\t\tSystem.out.printf(\"parse: %.2f ms\\ttinker: %.2f ms\\toutput: %.2f ms\\tcc: %.2f ms\\tTOTAL %.2f ms\\n\",\n\t\t\t\t\tFloat.valueOf((tt2 - tt1) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt3 - tt2) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt4 - tt3) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt4) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt1) / 1000000.0f));\n\t\t}\n\t\t\n\t\tif(code == 0 && params.run) {\n\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\tbuilder.command(\"./\"+module.getSimpleName());\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tprocess.waitFor();\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\t\n\tprotected void output(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\toutput(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\tnew CGenerator(params.outPath, module).generate(params);\n\t}\n\n\tprotected void tinker(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tnew Tinkerer().process(module, params);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\ttinker(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected int compile(Module module) throws Error,\n\t\t\tIOException, InterruptedException {\n\t\t\n\t\tcompiler.reset();\n\t\t\n\t\tfor(Include inc: module.getIncludes()) {\n\t\t\tif(inc.getMode() == Mode.LOCAL) {\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.copy(new File(inc.getPath() + \".h\"),\n\t\t\t\t\t\tnew File(params.outPath, inc.getPath() + \".h\"));\n\t\t\t\t} catch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(params.debug) compiler.setDebugEnabled();\t\t\n\t\tcompiler.addIncludePath(new File(params.distLocation, \"libs/headers/\").getPath());\n\t\tcompiler.addIncludePath(params.outPath.getPath());\n\t\taddDeps(compiler, module, new HashSet<Module>());\n\t\tfor(String dynamicLib: params.dynamicLibs) {\n\t\t\tcompiler.addDynamicLibrary(dynamicLib);\n\t\t}\n\t\tfor(String additional: additionals) {\n\t\t\tcompiler.addObjectFile(additional);\n\t\t}\n\t\tfor(String compilerArg: compilerArgs) {\n\t\t\tcompiler.addObjectFile(compilerArg);\n\t\t}\n\t\t\n\t\tif(params.link) {\n\t\t\tcompiler.setOutputPath(module.getSimpleName());\n\t\t\tCollection<String> libs = getFlagsFromUse(module);\n\t\t\tfor(String lib: libs) compiler.addObjectFile(lib);\n\t\t\t\n\t\t\tcompiler.addDynamicLibrary(\"pthread\");\n\t\t\tif(params.dynGC) {\n\t\t\t\tcompiler.addDynamicLibrary(\"gc\");\n\t\t\t} else {\n\t\t\t\tcompiler.addObjectFile(new File(params.distLocation, \"libs/\"\n\t\t\t\t\t\t+ Target.guessHost().toString(params.arch.equals(\"\") ? Target.getArch() : params.arch) + \"/libgc.a\").getPath());\n\t\t\t}\n\t\t} else {\n\t\t\tcompiler.setCompileOnly();\n\t\t}\n\t\t\n\t\tif(params.verbose) compiler.printCommandLine();\n\t\t\n\t\tint code = compiler.launch();\n\t\tif(code != 0) {\n\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\n\tprotected Collection<String> getFlagsFromUse(Module module) throws IOException, InterruptedException {\n\n\t\tSet<String> list = new HashSet<String>();\n\t\tSet<Module> done = new HashSet<Module>();\n\t\tgetFlagsFromUse(module, list, done);\n\t\treturn list;\n\t\t\n\t}\n\n\tprotected void getFlagsFromUse(Module module, Set<String> list, Set<Module> done) throws IOException, InterruptedException {\n\n\t\tif(done.contains(module)) return;\n\t\tdone.add(module);\n\t\t\n\t\tfor(Use use: module.getUses()) {\n\t\t\tUseDef useDef = use.getUseDef();\n\t\t\tcompileNasms(useDef.getLibs(), list);\n\t\t\tfor(String pkg: useDef.getPkgs()) {\n\t\t\t\tPkgInfo info = PkgConfigFrontend.getInfo(pkg);\n\t\t\t\tfor(String cflag: info.cflags) {\n\t\t\t\t\tif(!list.contains(cflag)) {\n\t\t\t\t\t\tlist.add(cflag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(String library: info.libraries) {\n\t\t\t\t\tif(!list.contains(library)) {\n\t\t\t\t\t\tlist.add(\"-l\"+library); // FIXME lazy\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tgetFlagsFromUse(imp.getModule(), list, done);\n\t\t}\n\t\t\n\t}\n\n\tprotected File findExec(String name) throws Error {\n\t\t\n\t\tFile execFile = ShellUtils.findExecutable(name);\n\t\tif(execFile == null) {\n\t\t\texecFile = ShellUtils.findExecutable(name+\".exe\");\n\t\t}\n\t\tif(execFile == null) {\n\t\t\tthrow new Error(name+\" not found :/\");\n\t\t}\n\t\treturn execFile;\n\t\t\n\t}\n\n\tprotected void addDeps(AbstractCompiler compiler, Module module, Set<Module> done) {\n\t\t\n\t\tdone.add(module);\n\t\tcompiler.addObjectFile(new File(params.outPath, module.getPath(\".c\")).getPath());\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\taddDeps(compiler, imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.ooc.backend.cdirty.CGenerator;\nimport org.ooc.frontend.compilers.AbstractCompiler;\nimport org.ooc.frontend.compilers.Clang;\nimport org.ooc.frontend.compilers.Gcc;\nimport org.ooc.frontend.compilers.Icc;\nimport org.ooc.frontend.compilers.Tcc;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.Include.Mode;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.ModuleParser;\nimport org.ooc.frontend.parser.Parser;\nimport org.ooc.frontend.pkgconfig.PkgConfigFrontend;\nimport org.ooc.frontend.pkgconfig.PkgInfo;\nimport org.ooc.middle.Tinkerer;\nimport org.ooc.middle.UseDef;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.FileLocation;\n\npublic class CommandLine {\n\t\n\tpublic static void main(String[] argv) throws InterruptedException, IOException {\n\t\tnew CommandLine(argv);\n\t}\n\t\n\tprotected BuildParams params = new BuildParams();\n\tList<String> additionals = new ArrayList<String>();\n\tList<String> compilerArgs = new ArrayList<String>();\n\tprivate AbstractCompiler compiler = null;\n\t\n\tpublic CommandLine(String[] args) throws InterruptedException, IOException {\n\t\t\n\t\tList<String> modulePaths = new ArrayList<String>();\n\t\tList<String> nasms = new ArrayList<String>();\n\t\t\n\t\tfor(String arg: args) {\n\t\t\tif(arg.startsWith(\"-\")) {\n        \t\tString option = arg.substring(1);\n        \t\tif(option.startsWith(\"sourcepath\")) {\n        \t\t\t\n        \t\t\tString sourcePathOption = arg.substring(arg.indexOf('=') + 1);\n        \t\t\tStringTokenizer tokenizer = new StringTokenizer(sourcePathOption, File.pathSeparator);\n        \t\t\twhile(tokenizer.hasMoreTokens()) {\n        \t\t\t\tparams.sourcePath.add(tokenizer.nextToken());\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"outpath\")) {\n        \t\t\t\n        \t\t\tparams.outPath = new File(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"incpath\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"I\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"libpath\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"editor\")) {\n        \t\t\t\n        \t\t\tparams.editor = arg.substring(arg.indexOf('=') + 1);\n        \t\t\t\n        \t\t} else if(option.equals(\"c\")) {\n        \t\t\t\n        \t\t\tparams.link = false;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"L\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"l\")) {\n        \t\t\t\n        \t\t\tparams.dynamicLibs.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.equals(\"dyngc\")) {\n        \t\t\t\n        \t\t\tparams.dynGC = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"noclean\")) {\n        \t\t\t\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"shout\")) {\n        \t\t\t\n        \t\t\tparams.shout = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"timing\") || option.equals(\"t\")) {\n        \t\t\t\n        \t\t\tparams.timing = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"debug\") || option.equals(\"g\")) {\n        \t\t\t\n        \t\t\tparams.debug = true;\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"verbose\") || option.equals(\"v\")) {\n        \t\t\t\n        \t\t\tparams.verbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"run\") || option.equals(\"r\")) {\n        \t\t\t\n        \t\t\tparams.run = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"V\") || option.equals(\"-version\") || option.equals(\"version\")) {\n        \t\t\t\n        \t\t\tCompilerVersion.printVersion();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"h\") || option.equals(\"-help\") || option.equals(\"help\")) {\n        \t\t\t\n        \t\t\tHelp.printHelp();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"gcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Gcc();\n        \t\t\t\n        \t\t} else if(option.equals(\"icc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Icc();\n        \t\t\t\n        \t\t} else if(option.equals(\"tcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Tcc();\n        \t\t\t\n\t\t\t\t} else if(option.equals(\"clang\")) {\n        \t\t\t\n        \t\t\tcompiler = new Clang();\n        \t\t\t\n        \t\t} else if(option.equals(\"help-backends\") || option.equals(\"-help-backends\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpBackends();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-gcc\") || option.equals(\"-help-gcc\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpGcc();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-make\") || option.equals(\"-help-make\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpMake();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-none\") || option.equals(\"-help-none\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpNone();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"slave\")) {\n        \t\t\t\n        \t\t\tparams.slave = true;\n\n\t\t\t\t} else if(option.startsWith(\"m\")) {\n\t\t\t\t\t\n\t\t\t\t\tString arch = arg.substring(2);\n\t\t\t\t\tif (arch.equals(\"32\") || arch.equals(\"64\"))\n\t\t\t\t\t\tparams.arch = arg.substring(2);\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(\"Unrecognized architecture: \" + arch);\n\t\t\t\n        \t\t} else {\n        \t\t\t\n        \t\t\tSystem.err.println(\"Unrecognized option: '\"+arg+\"'\");\n        \t\t\t\n        \t\t}\n        \t} else if(arg.startsWith(\"+\")) {\n        \t\tcompilerArgs.add(arg.substring(1));\n        \t} else {\n        \t\t\tString lowerArg = arg.toLowerCase();\n\t\t\t\t\tif(lowerArg.endsWith(\".s\")) {\n        \t\t\t\tnasms.add(arg);\n        \t\t\t} else if(lowerArg.endsWith(\".o\") || lowerArg.endsWith(\".c\") || lowerArg.endsWith(\".cpp\")) {\n            \t\t\tadditionals.add(arg);\n            \t\t} else {\n            \t\t\tif(!lowerArg.endsWith(\".ooc\")) {\n            \t\t\t\tmodulePaths.add(arg+\".ooc\");\n            \t\t\t} else {\n            \t\t\t\tmodulePaths.add(arg);\n            \t\t\t}\n            \t\t}\n        \t}\n\t\t}\n\t\t\n\t\tif(modulePaths.isEmpty()) {\n\t\t\tSystem.err.println(\"ooc: no files.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(compiler == null) compiler = new Gcc();\n\t\t\n\t\tif(!nasms.isEmpty()) {\n\t\t\tcompileNasms(nasms, additionals);\n\t\t}\n\t\t\n\t\tif(params.sourcePath.isEmpty()) params.sourcePath.add(\".\");\n\t\tparams.sourcePath.add(params.distLocation + File.separator + \"sdk\");\n\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tdo {\n\t\t\tModuleParser.clearCache();\n\t\t\tint successCount = 0;\n\t\t\tfor(String modulePath: modulePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tint code = parse(modulePath);\n\t\t\t\t\tif(code == 0) {\n\t\t\t\t\t\tsuccessCount++;\n\t\t\t\t\t\tok();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfail();\t\n\t\t\t\t\t}\n\t\t\t\t} catch(CompilationFailedError err) {\n\t\t\t\t\tSystem.err.println(err);\n\t\t\t\t\tfail();\n\t\t\t\t\tif(!params.editor.isEmpty()) {\n\t\t\t\t\t\tlaunchEditor(params.editor, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(params.clean) FileUtils.deleteRecursive(params.outPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(modulePaths.size() > 1) {\n\t\t\t\tSystem.out.println(modulePaths.size()+\" compiled (\"+successCount\n\t\t\t\t\t\t+\" success, \"+(modulePaths.size() - successCount)+\" failed)\");\n\t\t\t}\n\t\t\t\n\t\t\tif(params.slave) {\n\t\t\t\tSystem.out.println(\".-------------( ready )-------------.\\n\");\n\t\t\t\treader.readLine();\n\t\t\t} else {\n\t\t\t\tif(successCount < modulePaths.size()) {\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} while(params.slave);\n\t\t\n\t}\n\n\tprivate void ok() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;32m[ OK ]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[ OK ]\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void fail() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;31m[FAIL]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[FAIL]\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void launchEditor(final String editor, final CompilationFailedError err) {\n\t\t\n\t\tif(err.getLocation() == null) return;\n\t\t\n\t\tThread thread = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\t\tFileLocation location = err.getLocation();\n\t\t\t\t\tString absolutePath = new File(location.getFileName()).getAbsolutePath();\n\t\t\t\t\tif(editor.equals(\"geany\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath+\":\"+location.getLineNumber()+\":\"+(location.getLinePos() - 1));\n\t\t\t\t\t} else if(editor.equals(\"mate\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath, \"-l\", String.valueOf(location.getLineNumber()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessUtils.redirectIO(builder.start());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.setDaemon(true);\n\t\tthread.start();\n\t\t\n\t}\n\n\tprivate void compileNasms(List<String> nasms, Collection<String> list) throws IOException, InterruptedException {\n\t\t\n\t\tboolean has = false;\n\t\t\n\t\tList<String> command = new ArrayList<String>();\n\t\tcommand.add(findExec(\"nasm\").getPath());\n\t\tcommand.add(\"-f\");\n\t\tcommand.add(\"elf\");\n\t\tfor(String nasm: nasms) {\n\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\tcommand.add(nasm);\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(has) {\n\t\t\tProcessBuilder builder = new ProcessBuilder(command);\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tint code = process.waitFor();\n\t\t\tif(code != 0) {\n\t\t\t\tSystem.err.println(\"nasm failed, aborting compilation process\");\n\t\t\t\tSystem.exit(code);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String nasm: nasms) {\n\t\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\t\tlist.add(nasm.substring(0, nasm.length() - 1) + \"o\");\n\t\t\t\t} else {\n\t\t\t\t\tlist.add(nasm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist.addAll(nasms);\n\t\t}\n\t\t\n\t}\n\n\tprotected int parse(String modulePath) throws InterruptedException, IOException {\n\t\t\n\t\tparams.outPath.mkdirs();\n\t\tlong tt1 = System.nanoTime();\n\t\tModule module = new Parser(params).parse(modulePath);\n\t\tmodule.setMain(true);\n\t\tlong tt2 = System.nanoTime();\n\t\t\n\t\tArrayList<Module> list = new ArrayList<Module>();\n\t\tcollectModules(module, list);\n\t\ttinker(list);\n\t\t\n\t\tlong tt3 = System.nanoTime();\n\t\toutput(module, new HashSet<Module>());\n\t\tlong tt4 = System.nanoTime();\n\t\tint code = compile(module);\n\t\tlong tt5 = System.nanoTime();\n\n\t\tif(params.timing) {\n\t\t\tSystem.out.printf(\"parse: %.2f ms\\ttinker: %.2f ms\\toutput: %.2f ms\\tcc: %.2f ms\\tTOTAL %.2f ms\\n\",\n\t\t\t\t\tFloat.valueOf((tt2 - tt1) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt3 - tt2) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt4 - tt3) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt4) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt1) / 1000000.0f));\n\t\t}\n\t\t\n\t\tif(code == 0 && params.run) {\n\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\tbuilder.command(\"./\"+module.getSimpleName());\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tprocess.waitFor();\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\t\n\tprotected void output(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\toutput(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\tnew CGenerator(params.outPath, module).generate(params);\n\t}\n\n\tprotected void collectModules(Module module, List<Module> list) throws IOException {\n\t\tlist.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!list.contains(imp.getModule())) {\n\t\t\t\tcollectModules(imp.getModule(), list);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected void tinker(List<Module> list) throws IOException {\n\t\tTinkerer tink = new Tinkerer();\n\t\ttink.process(list, params);\n\t}\n\n\tprotected int compile(Module module) throws Error,\n\t\t\tIOException, InterruptedException {\n\t\t\n\t\tcompiler.reset();\n\t\t\n\t\tfor(Include inc: module.getIncludes()) {\n\t\t\tif(inc.getMode() == Mode.LOCAL) {\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.copy(new File(inc.getPath() + \".h\"),\n\t\t\t\t\t\tnew File(params.outPath, inc.getPath() + \".h\"));\n\t\t\t\t} catch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(params.debug) compiler.setDebugEnabled();\t\t\n\t\tcompiler.addIncludePath(new File(params.distLocation, \"libs/headers/\").getPath());\n\t\tcompiler.addIncludePath(params.outPath.getPath());\n\t\taddDeps(compiler, module, new HashSet<Module>());\n\t\tfor(String dynamicLib: params.dynamicLibs) {\n\t\t\tcompiler.addDynamicLibrary(dynamicLib);\n\t\t}\n\t\tfor(String additional: additionals) {\n\t\t\tcompiler.addObjectFile(additional);\n\t\t}\n\t\tfor(String compilerArg: compilerArgs) {\n\t\t\tcompiler.addObjectFile(compilerArg);\n\t\t}\n\t\t\n\t\tif(params.link) {\n\t\t\tcompiler.setOutputPath(module.getSimpleName());\n\t\t\tCollection<String> libs = getFlagsFromUse(module);\n\t\t\tfor(String lib: libs) compiler.addObjectFile(lib);\n\t\t\t\n\t\t\tcompiler.addDynamicLibrary(\"pthread\");\n\t\t\tif(params.dynGC) {\n\t\t\t\tcompiler.addDynamicLibrary(\"gc\");\n\t\t\t} else {\n\t\t\t\tcompiler.addObjectFile(new File(params.distLocation, \"libs/\"\n\t\t\t\t\t\t+ Target.guessHost().toString(params.arch.equals(\"\") ? Target.getArch() : params.arch) + \"/libgc.a\").getPath());\n\t\t\t}\n\t\t} else {\n\t\t\tcompiler.setCompileOnly();\n\t\t}\n\t\t\n\t\tif(params.verbose) compiler.printCommandLine();\n\t\t\n\t\tint code = compiler.launch();\n\t\tif(code != 0) {\n\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\n\tprotected Collection<String> getFlagsFromUse(Module module) throws IOException, InterruptedException {\n\n\t\tSet<String> list = new HashSet<String>();\n\t\tSet<Module> done = new HashSet<Module>();\n\t\tgetFlagsFromUse(module, list, done);\n\t\treturn list;\n\t\t\n\t}\n\n\tprotected void getFlagsFromUse(Module module, Set<String> list, Set<Module> done) throws IOException, InterruptedException {\n\n\t\tif(done.contains(module)) return;\n\t\tdone.add(module);\n\t\t\n\t\tfor(Use use: module.getUses()) {\n\t\t\tUseDef useDef = use.getUseDef();\n\t\t\tcompileNasms(useDef.getLibs(), list);\n\t\t\tfor(String pkg: useDef.getPkgs()) {\n\t\t\t\tPkgInfo info = PkgConfigFrontend.getInfo(pkg);\n\t\t\t\tfor(String cflag: info.cflags) {\n\t\t\t\t\tif(!list.contains(cflag)) {\n\t\t\t\t\t\tlist.add(cflag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(String library: info.libraries) {\n\t\t\t\t\tif(!list.contains(library)) {\n\t\t\t\t\t\tlist.add(\"-l\"+library); // FIXME lazy\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tgetFlagsFromUse(imp.getModule(), list, done);\n\t\t}\n\t\t\n\t}\n\n\tprotected File findExec(String name) throws Error {\n\t\t\n\t\tFile execFile = ShellUtils.findExecutable(name);\n\t\tif(execFile == null) {\n\t\t\texecFile = ShellUtils.findExecutable(name+\".exe\");\n\t\t}\n\t\tif(execFile == null) {\n\t\t\tthrow new Error(name+\" not found :/\");\n\t\t}\n\t\treturn execFile;\n\t\t\n\t}\n\n\tprotected void addDeps(AbstractCompiler compiler, Module module, Set<Module> done) {\n\t\t\n\t\tdone.add(module);\n\t\tcompiler.addObjectFile(new File(params.outPath, module.getPath(\".c\")).getPath());\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\taddDeps(compiler, imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","lineNo":357}
{"Smelly Sample":"package org.ooc.frontend;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.ooc.backend.cdirty.CGenerator;\nimport org.ooc.frontend.compilers.AbstractCompiler;\nimport org.ooc.frontend.compilers.Clang;\nimport org.ooc.frontend.compilers.Gcc;\nimport org.ooc.frontend.compilers.Icc;\nimport org.ooc.frontend.compilers.Tcc;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.Include.Mode;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.ModuleParser;\nimport org.ooc.frontend.parser.Parser;\nimport org.ooc.frontend.pkgconfig.PkgConfigFrontend;\nimport org.ooc.frontend.pkgconfig.PkgInfo;\nimport org.ooc.middle.Tinkerer;\nimport org.ooc.middle.UseDef;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.FileLocation;\n\npublic class CommandLine {\n\t\n\tpublic static void main(String[] argv) throws InterruptedException, IOException {\n\t\tnew CommandLine(argv);\n\t}\n\t\n\tprotected BuildParams params = new BuildParams();\n\tList<String> additionals = new ArrayList<String>();\n\tList<String> compilerArgs = new ArrayList<String>();\n\tprivate AbstractCompiler compiler = null;\n\t\n\tpublic CommandLine(String[] args) throws InterruptedException, IOException {\n\t\t\n\t\tList<String> modulePaths = new ArrayList<String>();\n\t\tList<String> nasms = new ArrayList<String>();\n\t\t\n\t\tfor(String arg: args) {\n\t\t\tif(arg.startsWith(\"-\")) {\n        \t\tString option = arg.substring(1);\n        \t\tif(option.startsWith(\"sourcepath\")) {\n        \t\t\t\n        \t\t\tString sourcePathOption = arg.substring(arg.indexOf('=') + 1);\n        \t\t\tStringTokenizer tokenizer = new StringTokenizer(sourcePathOption, File.pathSeparator);\n        \t\t\twhile(tokenizer.hasMoreTokens()) {\n        \t\t\t\tparams.sourcePath.add(tokenizer.nextToken());\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"outpath\")) {\n        \t\t\t\n        \t\t\tparams.outPath = new File(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"incpath\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"I\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"libpath\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"editor\")) {\n        \t\t\t\n        \t\t\tparams.editor = arg.substring(arg.indexOf('=') + 1);\n        \t\t\t\n        \t\t} else if(option.equals(\"c\")) {\n        \t\t\t\n        \t\t\tparams.link = false;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"L\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"l\")) {\n        \t\t\t\n        \t\t\tparams.dynamicLibs.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.equals(\"dyngc\")) {\n        \t\t\t\n        \t\t\tparams.dynGC = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"noclean\")) {\n        \t\t\t\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"shout\")) {\n        \t\t\t\n        \t\t\tparams.shout = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"timing\") || option.equals(\"t\")) {\n        \t\t\t\n        \t\t\tparams.timing = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"debug\") || option.equals(\"g\")) {\n        \t\t\t\n        \t\t\tparams.debug = true;\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"verbose\") || option.equals(\"v\")) {\n        \t\t\t\n        \t\t\tparams.verbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"run\") || option.equals(\"r\")) {\n        \t\t\t\n        \t\t\tparams.run = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"V\") || option.equals(\"-version\") || option.equals(\"version\")) {\n        \t\t\t\n        \t\t\tCompilerVersion.printVersion();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"h\") || option.equals(\"-help\") || option.equals(\"help\")) {\n        \t\t\t\n        \t\t\tHelp.printHelp();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"gcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Gcc();\n        \t\t\t\n        \t\t} else if(option.equals(\"icc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Icc();\n        \t\t\t\n        \t\t} else if(option.equals(\"tcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Tcc();\n        \t\t\t\n\t\t\t\t} else if(option.equals(\"clang\")) {\n        \t\t\t\n        \t\t\tcompiler = new Clang();\n        \t\t\t\n        \t\t} else if(option.equals(\"help-backends\") || option.equals(\"-help-backends\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpBackends();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-gcc\") || option.equals(\"-help-gcc\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpGcc();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-make\") || option.equals(\"-help-make\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpMake();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-none\") || option.equals(\"-help-none\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpNone();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"slave\")) {\n        \t\t\t\n        \t\t\tparams.slave = true;\n\n\t\t\t\t} else if(option.startsWith(\"m\")) {\n\t\t\t\t\t\n\t\t\t\t\tString arch = arg.substring(2);\n\t\t\t\t\tif (arch.equals(\"32\") || arch.equals(\"64\"))\n\t\t\t\t\t\tparams.arch = arg.substring(2);\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(\"Unrecognized architecture: \" + arch);\n\t\t\t\n        \t\t} else {\n        \t\t\t\n        \t\t\tSystem.err.println(\"Unrecognized option: '\"+arg+\"'\");\n        \t\t\t\n        \t\t}\n        \t} else if(arg.startsWith(\"+\")) {\n        \t\tcompilerArgs.add(arg.substring(1));\n        \t} else {\n        \t\t\tString lowerArg = arg.toLowerCase();\n\t\t\t\t\tif(lowerArg.endsWith(\".s\")) {\n        \t\t\t\tnasms.add(arg);\n        \t\t\t} else if(lowerArg.endsWith(\".o\") || lowerArg.endsWith(\".c\") || lowerArg.endsWith(\".cpp\")) {\n            \t\t\tadditionals.add(arg);\n            \t\t} else {\n            \t\t\tif(!lowerArg.endsWith(\".ooc\")) {\n            \t\t\t\tmodulePaths.add(arg+\".ooc\");\n            \t\t\t} else {\n            \t\t\t\tmodulePaths.add(arg);\n            \t\t\t}\n            \t\t}\n        \t}\n\t\t}\n\t\t\n\t\tif(modulePaths.isEmpty()) {\n\t\t\tSystem.err.println(\"ooc: no files.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(compiler == null) compiler = new Gcc();\n\t\t\n\t\tif(!nasms.isEmpty()) {\n\t\t\tcompileNasms(nasms, additionals);\n\t\t}\n\t\t\n\t\tif(params.sourcePath.isEmpty()) params.sourcePath.add(\".\");\n\t\tparams.sourcePath.add(params.distLocation + File.separator + \"sdk\");\n\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tdo {\n\t\t\tModuleParser.clearCache();\n\t\t\tint successCount = 0;\n\t\t\tfor(String modulePath: modulePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tint code = parse(modulePath);\n\t\t\t\t\tif(code == 0) successCount++;\n\t\t\t\t} catch(CompilationFailedError err) {\n\t\t\t\t\tSystem.err.println(err);\n\t\t\t\t\tif(!params.editor.isEmpty()) {\n\t\t\t\t\t\tlaunchEditor(params.editor, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(params.clean) FileUtils.deleteRecursive(params.outPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(modulePaths.size() > 1) {\n\t\t\t\tSystem.out.println(modulePaths.size()+\" compiled (\"+successCount\n\t\t\t\t\t\t+\" success, \"+(modulePaths.size() - successCount)+\" failed)\");\n\t\t\t}\n\t\t\tif(params.slave) {\n\t\t\t\tSystem.out.println(\".-------------( ready )-------------.\\n\");\n\t\t\t\treader.readLine();\n\t\t\t}\n\t\t} while(params.slave);\n\t\t\n\t}\n\t\n\tprivate void launchEditor(final String editor, final CompilationFailedError err) {\n\t\t\n\t\tif(err.getLocation() == null) return;\n\t\t\n\t\tThread thread = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\t\tFileLocation location = err.getLocation();\n\t\t\t\t\tString absolutePath = new File(location.getFileName()).getAbsolutePath();\n\t\t\t\t\tif(editor.equals(\"geany\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath+\":\"+location.getLineNumber()+\":\"+(location.getLinePos() - 1));\n\t\t\t\t\t} else if(editor.equals(\"mate\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath, \"-l\", String.valueOf(location.getLineNumber()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessUtils.redirectIO(builder.start());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.setDaemon(true);\n\t\tthread.start();\n\t\t\n\t}\n\n\tprivate void compileNasms(List<String> nasms, Collection<String> list) throws IOException, InterruptedException {\n\t\t\n\t\tboolean has = false;\n\t\t\n\t\tList<String> command = new ArrayList<String>();\n\t\tcommand.add(findExec(\"nasm\").getPath());\n\t\tcommand.add(\"-f\");\n\t\tcommand.add(\"elf\");\n\t\tfor(String nasm: nasms) {\n\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\tcommand.add(nasm);\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(has) {\n\t\t\tProcessBuilder builder = new ProcessBuilder(command);\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tint code = process.waitFor();\n\t\t\tif(code != 0) {\n\t\t\t\tSystem.err.println(\"nasm failed, aborting compilation process\");\n\t\t\t\tSystem.exit(code);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String nasm: nasms) {\n\t\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\t\tlist.add(nasm.substring(0, nasm.length() - 1) + \"o\");\n\t\t\t\t} else {\n\t\t\t\t\tlist.add(nasm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist.addAll(nasms);\n\t\t}\n\t\t\n\t}\n\n\tprotected int parse(String modulePath) throws InterruptedException, IOException {\n\t\t\n\t\tparams.outPath.mkdirs();\n\t\tlong tt1 = System.nanoTime();\n\t\tModule module = new Parser(params).parse(modulePath);\n\t\tmodule.setMain(true);\n\t\tlong tt2 = System.nanoTime();\n\t\ttinker(module, new HashSet<Module>());\n\t\tlong tt3 = System.nanoTime();\n\t\toutput(module, new HashSet<Module>());\n\t\tlong tt4 = System.nanoTime();\n\t\tint code = compile(module);\n\t\tlong tt5 = System.nanoTime();\n\n\t\tif(params.timing) {\n\t\t\tSystem.out.printf(\"parse: %.2f ms\\ttinker: %.2f ms\\toutput: %.2f ms\\tcc: %.2f ms\\tTOTAL %.2f ms\\n\",\n\t\t\t\t\tFloat.valueOf((tt2 - tt1) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt3 - tt2) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt4 - tt3) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt4) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt1) / 1000000.0f));\n\t\t}\n\t\t\n\t\tif(code == 0 && params.run) {\n\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\tbuilder.command(\"./\"+module.getSimpleName());\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tprocess.waitFor();\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\t\n\tprotected void output(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\toutput(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\tnew CGenerator(params.outPath, module).generate(params);\n\t}\n\n\tprotected void tinker(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tnew Tinkerer().process(module, params);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\ttinker(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected int compile(Module module) throws Error,\n\t\t\tIOException, InterruptedException {\n\t\t\n\t\tcompiler.reset();\n\t\t\n\t\tfor(Include inc: module.getIncludes()) {\n\t\t\tif(inc.getMode() == Mode.LOCAL) {\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.copy(new File(inc.getPath() + \".h\"),\n\t\t\t\t\t\tnew File(params.outPath, inc.getPath() + \".h\"));\n\t\t\t\t} catch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(params.debug) compiler.setDebugEnabled();\t\t\n\t\tcompiler.addIncludePath(new File(params.distLocation, \"libs/headers/\").getPath());\n\t\tcompiler.addIncludePath(params.outPath.getPath());\n\t\taddDeps(compiler, module, new HashSet<Module>());\n\t\tfor(String dynamicLib: params.dynamicLibs) {\n\t\t\tcompiler.addDynamicLibrary(dynamicLib);\n\t\t}\n\t\tfor(String additional: additionals) {\n\t\t\tcompiler.addObjectFile(additional);\n\t\t}\n\t\tfor(String compilerArg: compilerArgs) {\n\t\t\tcompiler.addObjectFile(compilerArg);\n\t\t}\n\t\t\n\t\tif(params.link) {\n\t\t\tcompiler.setOutputPath(module.getSimpleName());\n\t\t\tCollection<String> libs = getFlagsFromUse(module);\n\t\t\tfor(String lib: libs) compiler.addObjectFile(lib);\n\t\t\t\n\t\t\tcompiler.addDynamicLibrary(\"pthread\");\n\t\t\tif(params.dynGC) {\n\t\t\t\tcompiler.addDynamicLibrary(\"gc\");\n\t\t\t} else {\n\t\t\t\tcompiler.addObjectFile(new File(params.distLocation, \"libs/\"\n\t\t\t\t\t\t+ Target.guessHost().toString(params.arch.equals(\"\") ? Target.getArch() : params.arch) + \"/libgc.a\").getPath());\n\t\t\t}\n\t\t} else {\n\t\t\tcompiler.setCompileOnly();\n\t\t}\n\t\t\n\t\tif(params.verbose) compiler.printCommandLine();\n\t\t\n\t\tint code = compiler.launch();\n\t\tif(code != 0) {\n\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\n\tprotected Collection<String> getFlagsFromUse(Module module) throws IOException, InterruptedException {\n\n\t\tSet<String> list = new HashSet<String>();\n\t\tSet<Module> done = new HashSet<Module>();\n\t\tgetFlagsFromUse(module, list, done);\n\t\treturn list;\n\t\t\n\t}\n\n\tprotected void getFlagsFromUse(Module module, Set<String> list, Set<Module> done) throws IOException, InterruptedException {\n\n\t\tif(done.contains(module)) return;\n\t\tdone.add(module);\n\t\t\n\t\tfor(Use use: module.getUses()) {\n\t\t\tUseDef useDef = use.getUseDef();\n\t\t\tcompileNasms(useDef.getLibs(), list);\n\t\t\tfor(String pkg: useDef.getPkgs()) {\n\t\t\t\tPkgInfo info = PkgConfigFrontend.getInfo(pkg);\n\t\t\t\tfor(String cflag: info.cflags) {\n\t\t\t\t\tif(!list.contains(cflag)) {\n\t\t\t\t\t\tlist.add(cflag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(String library: info.libraries) {\n\t\t\t\t\tif(!list.contains(library)) {\n\t\t\t\t\t\tlist.add(\"-l\"+library); // FIXME lazy\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tgetFlagsFromUse(imp.getModule(), list, done);\n\t\t}\n\t\t\n\t}\n\n\tprotected File findExec(String name) throws Error {\n\t\t\n\t\tFile execFile = ShellUtils.findExecutable(name);\n\t\tif(execFile == null) {\n\t\t\texecFile = ShellUtils.findExecutable(name+\".exe\");\n\t\t}\n\t\tif(execFile == null) {\n\t\t\tthrow new Error(name+\" not found :/\");\n\t\t}\n\t\treturn execFile;\n\t\t\n\t}\n\n\tprotected void addDeps(AbstractCompiler compiler, Module module, Set<Module> done) {\n\t\t\n\t\tdone.add(module);\n\t\tcompiler.addObjectFile(new File(params.outPath, module.getPath(\".c\")).getPath());\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\taddDeps(compiler, imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.ooc.backend.cdirty.CGenerator;\nimport org.ooc.frontend.compilers.AbstractCompiler;\nimport org.ooc.frontend.compilers.Clang;\nimport org.ooc.frontend.compilers.Gcc;\nimport org.ooc.frontend.compilers.Icc;\nimport org.ooc.frontend.compilers.Tcc;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.Include.Mode;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.frontend.parser.ModuleParser;\nimport org.ooc.frontend.parser.Parser;\nimport org.ooc.frontend.pkgconfig.PkgConfigFrontend;\nimport org.ooc.frontend.pkgconfig.PkgInfo;\nimport org.ooc.middle.Tinkerer;\nimport org.ooc.middle.UseDef;\nimport org.ooc.utils.FileUtils;\nimport org.ooc.utils.ProcessUtils;\nimport org.ooc.utils.ShellUtils;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.FileLocation;\n\npublic class CommandLine {\n\t\n\tpublic static void main(String[] argv) throws InterruptedException, IOException {\n\t\tnew CommandLine(argv);\n\t}\n\t\n\tprotected BuildParams params = new BuildParams();\n\tList<String> additionals = new ArrayList<String>();\n\tList<String> compilerArgs = new ArrayList<String>();\n\tprivate AbstractCompiler compiler = null;\n\t\n\tpublic CommandLine(String[] args) throws InterruptedException, IOException {\n\t\t\n\t\tList<String> modulePaths = new ArrayList<String>();\n\t\tList<String> nasms = new ArrayList<String>();\n\t\t\n\t\tfor(String arg: args) {\n\t\t\tif(arg.startsWith(\"-\")) {\n        \t\tString option = arg.substring(1);\n        \t\tif(option.startsWith(\"sourcepath\")) {\n        \t\t\t\n        \t\t\tString sourcePathOption = arg.substring(arg.indexOf('=') + 1);\n        \t\t\tStringTokenizer tokenizer = new StringTokenizer(sourcePathOption, File.pathSeparator);\n        \t\t\twhile(tokenizer.hasMoreTokens()) {\n        \t\t\t\tparams.sourcePath.add(tokenizer.nextToken());\n        \t\t\t}\n        \t\t\t\n        \t\t} else if(option.startsWith(\"outpath\")) {\n        \t\t\t\n        \t\t\tparams.outPath = new File(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"incpath\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"I\")) {\n        \t\t\t\n        \t\t\tparams.incPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"libpath\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(arg.indexOf('=') + 1));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"editor\")) {\n        \t\t\t\n        \t\t\tparams.editor = arg.substring(arg.indexOf('=') + 1);\n        \t\t\t\n        \t\t} else if(option.equals(\"c\")) {\n        \t\t\t\n        \t\t\tparams.link = false;\n        \t\t\t\n        \t\t} else if(option.startsWith(\"L\")) {\n        \t\t\t\n        \t\t\tparams.libPath.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.startsWith(\"l\")) {\n        \t\t\t\n        \t\t\tparams.dynamicLibs.add(arg.substring(2));\n        \t\t\t\n        \t\t} else if(option.equals(\"dyngc\")) {\n        \t\t\t\n        \t\t\tparams.dynGC = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"noclean\")) {\n        \t\t\t\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"shout\")) {\n        \t\t\t\n        \t\t\tparams.shout = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"timing\") || option.equals(\"t\")) {\n        \t\t\t\n        \t\t\tparams.timing = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"debug\") || option.equals(\"g\")) {\n        \t\t\t\n        \t\t\tparams.debug = true;\n        \t\t\tparams.clean = false;\n        \t\t\t\n        \t\t} else if(option.equals(\"verbose\") || option.equals(\"v\")) {\n        \t\t\t\n        \t\t\tparams.verbose = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"run\") || option.equals(\"r\")) {\n        \t\t\t\n        \t\t\tparams.run = true;\n        \t\t\t\n        \t\t} else if(option.equals(\"V\") || option.equals(\"-version\") || option.equals(\"version\")) {\n        \t\t\t\n        \t\t\tCompilerVersion.printVersion();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"h\") || option.equals(\"-help\") || option.equals(\"help\")) {\n        \t\t\t\n        \t\t\tHelp.printHelp();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"gcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Gcc();\n        \t\t\t\n        \t\t} else if(option.equals(\"icc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Icc();\n        \t\t\t\n        \t\t} else if(option.equals(\"tcc\")) {\n        \t\t\t\n        \t\t\tcompiler = new Tcc();\n        \t\t\t\n\t\t\t\t} else if(option.equals(\"clang\")) {\n        \t\t\t\n        \t\t\tcompiler = new Clang();\n        \t\t\t\n        \t\t} else if(option.equals(\"help-backends\") || option.equals(\"-help-backends\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpBackends();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-gcc\") || option.equals(\"-help-gcc\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpGcc();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-make\") || option.equals(\"-help-make\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpMake();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"help-none\") || option.equals(\"-help-none\")) {\n        \t\t\t\n        \t\t\tHelp.printHelpNone();\n        \t\t\tSystem.exit(0);\n        \t\t\t\n        \t\t} else if(option.equals(\"slave\")) {\n        \t\t\t\n        \t\t\tparams.slave = true;\n\n\t\t\t\t} else if(option.startsWith(\"m\")) {\n\t\t\t\t\t\n\t\t\t\t\tString arch = arg.substring(2);\n\t\t\t\t\tif (arch.equals(\"32\") || arch.equals(\"64\"))\n\t\t\t\t\t\tparams.arch = arg.substring(2);\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(\"Unrecognized architecture: \" + arch);\n\t\t\t\n        \t\t} else {\n        \t\t\t\n        \t\t\tSystem.err.println(\"Unrecognized option: '\"+arg+\"'\");\n        \t\t\t\n        \t\t}\n        \t} else if(arg.startsWith(\"+\")) {\n        \t\tcompilerArgs.add(arg.substring(1));\n        \t} else {\n        \t\t\tString lowerArg = arg.toLowerCase();\n\t\t\t\t\tif(lowerArg.endsWith(\".s\")) {\n        \t\t\t\tnasms.add(arg);\n        \t\t\t} else if(lowerArg.endsWith(\".o\") || lowerArg.endsWith(\".c\") || lowerArg.endsWith(\".cpp\")) {\n            \t\t\tadditionals.add(arg);\n            \t\t} else {\n            \t\t\tif(!lowerArg.endsWith(\".ooc\")) {\n            \t\t\t\tmodulePaths.add(arg+\".ooc\");\n            \t\t\t} else {\n            \t\t\t\tmodulePaths.add(arg);\n            \t\t\t}\n            \t\t}\n        \t}\n\t\t}\n\t\t\n\t\tif(modulePaths.isEmpty()) {\n\t\t\tSystem.err.println(\"ooc: no files.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(compiler == null) compiler = new Gcc();\n\t\t\n\t\tif(!nasms.isEmpty()) {\n\t\t\tcompileNasms(nasms, additionals);\n\t\t}\n\t\t\n\t\tif(params.sourcePath.isEmpty()) params.sourcePath.add(\".\");\n\t\tparams.sourcePath.add(params.distLocation + File.separator + \"sdk\");\n\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tdo {\n\t\t\tModuleParser.clearCache();\n\t\t\tint successCount = 0;\n\t\t\tfor(String modulePath: modulePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tint code = parse(modulePath);\n\t\t\t\t\tif(code == 0) {\n\t\t\t\t\t\tsuccessCount++;\n\t\t\t\t\t\tok();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfail();\t\n\t\t\t\t\t}\n\t\t\t\t} catch(CompilationFailedError err) {\n\t\t\t\t\tSystem.err.println(err);\n\t\t\t\t\tfail();\n\t\t\t\t\tif(!params.editor.isEmpty()) {\n\t\t\t\t\t\tlaunchEditor(params.editor, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(params.clean) FileUtils.deleteRecursive(params.outPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(modulePaths.size() > 1) {\n\t\t\t\tSystem.out.println(modulePaths.size()+\" compiled (\"+successCount\n\t\t\t\t\t\t+\" success, \"+(modulePaths.size() - successCount)+\" failed)\");\n\t\t\t}\n\t\t\t\n\t\t\tif(params.slave) {\n\t\t\t\tSystem.out.println(\".-------------( ready )-------------.\\n\");\n\t\t\t\treader.readLine();\n\t\t\t} else {\n\t\t\t\tif(successCount < modulePaths.size()) {\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} while(params.slave);\n\t\t\n\t}\n\n\tprivate void ok() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;32m[ OK ]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[ OK ]\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void fail() {\n\t\tif(params.shout) {\n\t\t\tif(Target.guessHost() == Target.LINUX) {\n\t\t\t\tSystem.out.println(\"\\033[1;31m[FAIL]\\033[m\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"[FAIL]\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void launchEditor(final String editor, final CompilationFailedError err) {\n\t\t\n\t\tif(err.getLocation() == null) return;\n\t\t\n\t\tThread thread = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\t\t\tFileLocation location = err.getLocation();\n\t\t\t\t\tString absolutePath = new File(location.getFileName()).getAbsolutePath();\n\t\t\t\t\tif(editor.equals(\"geany\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath+\":\"+location.getLineNumber()+\":\"+(location.getLinePos() - 1));\n\t\t\t\t\t} else if(editor.equals(\"mate\")) {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath, \"-l\", String.valueOf(location.getLineNumber()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.command(editor, absolutePath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessUtils.redirectIO(builder.start());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.setDaemon(true);\n\t\tthread.start();\n\t\t\n\t}\n\n\tprivate void compileNasms(List<String> nasms, Collection<String> list) throws IOException, InterruptedException {\n\t\t\n\t\tboolean has = false;\n\t\t\n\t\tList<String> command = new ArrayList<String>();\n\t\tcommand.add(findExec(\"nasm\").getPath());\n\t\tcommand.add(\"-f\");\n\t\tcommand.add(\"elf\");\n\t\tfor(String nasm: nasms) {\n\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\tcommand.add(nasm);\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(has) {\n\t\t\tProcessBuilder builder = new ProcessBuilder(command);\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tint code = process.waitFor();\n\t\t\tif(code != 0) {\n\t\t\t\tSystem.err.println(\"nasm failed, aborting compilation process\");\n\t\t\t\tSystem.exit(code);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String nasm: nasms) {\n\t\t\t\tif(nasm.endsWith(\".s\")) {\n\t\t\t\t\tlist.add(nasm.substring(0, nasm.length() - 1) + \"o\");\n\t\t\t\t} else {\n\t\t\t\t\tlist.add(nasm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist.addAll(nasms);\n\t\t}\n\t\t\n\t}\n\n\tprotected int parse(String modulePath) throws InterruptedException, IOException {\n\t\t\n\t\tparams.outPath.mkdirs();\n\t\tlong tt1 = System.nanoTime();\n\t\tModule module = new Parser(params).parse(modulePath);\n\t\tmodule.setMain(true);\n\t\tlong tt2 = System.nanoTime();\n\t\t\n\t\tArrayList<Module> list = new ArrayList<Module>();\n\t\tcollectModules(module, list);\n\t\ttinker(list);\n\t\t\n\t\tlong tt3 = System.nanoTime();\n\t\toutput(module, new HashSet<Module>());\n\t\tlong tt4 = System.nanoTime();\n\t\tint code = compile(module);\n\t\tlong tt5 = System.nanoTime();\n\n\t\tif(params.timing) {\n\t\t\tSystem.out.printf(\"parse: %.2f ms\\ttinker: %.2f ms\\toutput: %.2f ms\\tcc: %.2f ms\\tTOTAL %.2f ms\\n\",\n\t\t\t\t\tFloat.valueOf((tt2 - tt1) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt3 - tt2) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt4 - tt3) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt4) / 1000000.0f),\n\t\t\t\t\tFloat.valueOf((tt5 - tt1) / 1000000.0f));\n\t\t}\n\t\t\n\t\tif(code == 0 && params.run) {\n\t\t\tProcessBuilder builder = new ProcessBuilder();\n\t\t\tbuilder.command(\"./\"+module.getSimpleName());\n\t\t\tProcess process = builder.start();\n\t\t\tProcessUtils.redirectIO(process);\n\t\t\tprocess.waitFor();\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\t\n\tprotected void output(Module module, Set<Module> done) throws IOException {\n\t\tdone.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\toutput(imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\tnew CGenerator(params.outPath, module).generate(params);\n\t}\n\n\tprotected void collectModules(Module module, List<Module> list) throws IOException {\n\t\tlist.add(module);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!list.contains(imp.getModule())) {\n\t\t\t\tcollectModules(imp.getModule(), list);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected void tinker(List<Module> list) throws IOException {\n\t\tTinkerer tink = new Tinkerer();\n\t\ttink.process(list, params);\n\t}\n\n\tprotected int compile(Module module) throws Error,\n\t\t\tIOException, InterruptedException {\n\t\t\n\t\tcompiler.reset();\n\t\t\n\t\tfor(Include inc: module.getIncludes()) {\n\t\t\tif(inc.getMode() == Mode.LOCAL) {\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.copy(new File(inc.getPath() + \".h\"),\n\t\t\t\t\t\tnew File(params.outPath, inc.getPath() + \".h\"));\n\t\t\t\t} catch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(params.debug) compiler.setDebugEnabled();\t\t\n\t\tcompiler.addIncludePath(new File(params.distLocation, \"libs/headers/\").getPath());\n\t\tcompiler.addIncludePath(params.outPath.getPath());\n\t\taddDeps(compiler, module, new HashSet<Module>());\n\t\tfor(String dynamicLib: params.dynamicLibs) {\n\t\t\tcompiler.addDynamicLibrary(dynamicLib);\n\t\t}\n\t\tfor(String additional: additionals) {\n\t\t\tcompiler.addObjectFile(additional);\n\t\t}\n\t\tfor(String compilerArg: compilerArgs) {\n\t\t\tcompiler.addObjectFile(compilerArg);\n\t\t}\n\t\t\n\t\tif(params.link) {\n\t\t\tcompiler.setOutputPath(module.getSimpleName());\n\t\t\tCollection<String> libs = getFlagsFromUse(module);\n\t\t\tfor(String lib: libs) compiler.addObjectFile(lib);\n\t\t\t\n\t\t\tcompiler.addDynamicLibrary(\"pthread\");\n\t\t\tif(params.dynGC) {\n\t\t\t\tcompiler.addDynamicLibrary(\"gc\");\n\t\t\t} else {\n\t\t\t\tcompiler.addObjectFile(new File(params.distLocation, \"libs/\"\n\t\t\t\t\t\t+ Target.guessHost().toString(params.arch.equals(\"\") ? Target.getArch() : params.arch) + \"/libgc.a\").getPath());\n\t\t\t}\n\t\t} else {\n\t\t\tcompiler.setCompileOnly();\n\t\t}\n\t\t\n\t\tif(params.verbose) compiler.printCommandLine();\n\t\t\n\t\tint code = compiler.launch();\n\t\tif(code != 0) {\n\t\t\tSystem.err.println(\"C compiler failed, aborting compilation process\");\n\t\t}\n\t\treturn code;\n\t\t\n\t}\n\n\tprotected Collection<String> getFlagsFromUse(Module module) throws IOException, InterruptedException {\n\n\t\tSet<String> list = new HashSet<String>();\n\t\tSet<Module> done = new HashSet<Module>();\n\t\tgetFlagsFromUse(module, list, done);\n\t\treturn list;\n\t\t\n\t}\n\n\tprotected void getFlagsFromUse(Module module, Set<String> list, Set<Module> done) throws IOException, InterruptedException {\n\n\t\tif(done.contains(module)) return;\n\t\tdone.add(module);\n\t\t\n\t\tfor(Use use: module.getUses()) {\n\t\t\tUseDef useDef = use.getUseDef();\n\t\t\tcompileNasms(useDef.getLibs(), list);\n\t\t\tfor(String pkg: useDef.getPkgs()) {\n\t\t\t\tPkgInfo info = PkgConfigFrontend.getInfo(pkg);\n\t\t\t\tfor(String cflag: info.cflags) {\n\t\t\t\t\tif(!list.contains(cflag)) {\n\t\t\t\t\t\tlist.add(cflag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(String library: info.libraries) {\n\t\t\t\t\tif(!list.contains(library)) {\n\t\t\t\t\t\tlist.add(\"-l\"+library); // FIXME lazy\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tgetFlagsFromUse(imp.getModule(), list, done);\n\t\t}\n\t\t\n\t}\n\n\tprotected File findExec(String name) throws Error {\n\t\t\n\t\tFile execFile = ShellUtils.findExecutable(name);\n\t\tif(execFile == null) {\n\t\t\texecFile = ShellUtils.findExecutable(name+\".exe\");\n\t\t}\n\t\tif(execFile == null) {\n\t\t\tthrow new Error(name+\" not found :/\");\n\t\t}\n\t\treturn execFile;\n\t\t\n\t}\n\n\tprotected void addDeps(AbstractCompiler compiler, Module module, Set<Module> done) {\n\t\t\n\t\tdone.add(module);\n\t\tcompiler.addObjectFile(new File(params.outPath, module.getPath(\".c\")).getPath());\n\t\t\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tif(!done.contains(imp.getModule())) {\n\t\t\t\taddDeps(compiler, imp.getModule(), done);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","lineNo":407}
{"Smelly Sample":"package org.ooc.frontend.parser;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Declaration;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ooc.middle.OocCompilationError;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class ModuleParser {\n\n\t// path -> module\n\tpublic final static Map<String, Module> cache = new HashMap<String, Module>();\n\t\n\tpublic static void parse(final Module module, final String fullName, final File file, final SourceReader sReader,\n\t\t\tfinal TokenReader reader, final Parser parser) {\n\t\t\n\t\tmodule.lastModified = file.lastModified();\n\t\tcache.put(module.getFullName(), module);\n\t\t\n\t\ttry {\n\t\t\taddLangImports(module, parser);\n\t\t\t\n\t\t\twhile(reader.hasNext()) {\n\t\n\t\t\t\tif(reader.peek().type == TokenType.LINESEP) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tClassDecl classDecl = ClassDeclParser.parse(module, sReader, reader);\n\t\t\t\t\tif(classDecl != null) {\n\t\t\t\t\t\tmodule.getTypes().add(classDecl.getName(), classDecl);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tCoverDecl coverDecl = CoverDeclParser.parse(module, sReader, reader);\n\t\t\t\t\tif(coverDecl != null) {\n\t\t\t\t\t\tmodule.getTypes().add(coverDecl.getName(), coverDecl);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tOpDecl opDecl = OpDeclParser.parse(module, sReader, reader);\n\t\t\t\t\tif(opDecl != null) {\n\t\t\t\t\t\tmodule.getOps().add(opDecl);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tDeclaration declaration = DeclarationParser.parse(module, sReader, reader);\n\t\t\t\tif(declaration != null) {\n\t\t\t\t\tif(declaration instanceof VariableDecl) {\n\t\t\t\t\t\tmodule.getBody().add(new Line(declaration));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmodule.getBody().add(declaration);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(LineParser.fill(module, sReader, reader, module.getLoadFunc().getBody())) continue;\n\t\t\t\tif(IncludeParser.fill(sReader, reader, module.getIncludes())) continue;\n\t\t\t\tif(ImportParser.fill(sReader, reader, module.getImports())) continue;\n\t\t\t\tif(UseParser.fill(sReader, reader, module.getUses())) continue;\n\t\t\t\tif(CommentParser.parse(sReader, reader) != null) continue;\n\t\t\t\t\n\t\t\t\tToken errToken = reader.peek();\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(errToken),\n\t\t\t\t\t\t\"Expected declaration, include, or import in source unit, but got \"+errToken);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tModule cached = cache.get(imp.getName());\n\t\t\t\tFile impFile = parser.params.sourcePath.getFile(imp.getPath());\n\t\t\t\tif(impFile == null) {\n\t\t\t\t\tthrow new OocCompilationError(imp, module, \"Module not found in sourcepath: \"+imp.getPath());\n\t\t\t\t}\n\t\t\t\tif(cached == null || impFile.lastModified() > cached.lastModified) {\n\t\t\t\t\tif(cached != null) {\n\t\t\t\t\t\tSystem.out.println(imp.getPath()+\" has been changed, recompiling...\");\n\t\t\t\t\t}\n\t\t\t\t\tcached = parser.parse(imp.getPath(), impFile, imp);\n\t\t\t\t\tcache.put(imp.getName(), cached);\n\t\t\t\t}\n\t\t\t\timp.setModule(cached);\n\t\t\t}\n\t\t\n\t\t} catch(IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\tstatic void addLangImports(Module module, Parser parser) {\n\t\t\n\t\tif(module.getFullName().startsWith(\"lang.\")) {\n\t\t\tif(!module.getFullName().equals(\"lang.Object\")) {\n\t\t\t\tmodule.getImports().add(new Import(\"lang.Object\", Token.defaultToken));\n\t\t\t}\n\t\t\tif(!module.getFullName().equals(\"lang.ooclib\")) {\n\t\t\t\tmodule.getImports().add(new Import(\"lang.ooclib\", Token.defaultToken));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tCollection<String> paths = parser.params.sourcePath.getRelativePaths(\"lang\");\n\t\tfor(String path: paths) {\n\t\t\tString impName = path.replace('/', '.');\n\t\t\tif(!impName.toLowerCase().endsWith(\".ooc\")) continue;\n\t\t\timpName = impName.substring(0, impName.length() - 4); // ditch the '.ooc'\n\t\t\tif(!impName.equals(module.getFullName())) {\n\t\t\t\tmodule.getImports().add(new Import(impName, Token.defaultToken));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tpublic static void clearCache() {\n\t\tcache.clear();\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.parser;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Declaration;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ooc.middle.OocCompilationError;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class ModuleParser {\n\n\t// path -> module\n\tpublic final static Map<String, Module> cache = new HashMap<String, Module>();\n\t\n\tpublic static void parse(final Module module, final String fullName, final File file, final SourceReader sReader,\n\t\t\tfinal TokenReader reader, final Parser parser) {\n\t\t\n\t\tmodule.lastModified = file.lastModified();\n\t\tcache.put(module.getFullName(), module);\n\t\t\n\t\ttry {\n\t\t\taddLangImports(module, parser);\n\t\t\t\n\t\t\twhile(reader.hasNext()) {\n\t\n\t\t\t\tif(reader.peek().type == TokenType.LINESEP) {\n\t\t\t\t\treader.skip();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tClassDecl classDecl = ClassDeclParser.parse(module, sReader, reader);\n\t\t\t\t\tif(classDecl != null) {\n\t\t\t\t\t\tmodule.getTypes().add(classDecl.getName(), classDecl);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tCoverDecl coverDecl = CoverDeclParser.parse(module, sReader, reader);\n\t\t\t\t\tif(coverDecl != null) {\n\t\t\t\t\t\tmodule.getTypes().add(coverDecl.getName(), coverDecl);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tOpDecl opDecl = OpDeclParser.parse(module, sReader, reader);\n\t\t\t\t\tif(opDecl != null) {\n\t\t\t\t\t\tmodule.getOps().add(opDecl);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tDeclaration declaration = DeclarationParser.parse(module, sReader, reader);\n\t\t\t\tif(declaration != null) {\n\t\t\t\t\tif(declaration instanceof VariableDecl) {\n\t\t\t\t\t\tmodule.getBody().add(new Line(declaration));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmodule.getBody().add(declaration);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(LineParser.fill(module, sReader, reader, module.getLoadFunc().getBody())) continue;\n\t\t\t\tif(IncludeParser.fill(sReader, reader, module.getIncludes())) continue;\n\t\t\t\tif(ImportParser.fill(sReader, reader, module.getImports())) continue;\n\t\t\t\tif(UseParser.fill(sReader, reader, module.getUses())) continue;\n\t\t\t\tif(CommentParser.parse(sReader, reader) != null) continue;\n\t\t\t\t\n\t\t\t\tToken errToken = reader.peek();\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(errToken),\n\t\t\t\t\t\t\"Expected declaration, include, or import in source unit, but got \"+errToken);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tModule cached = cache.get(imp.getName());\n\t\t\t\tString path = imp.getPath();\n\t\t\t\tFile impFile = parser.params.sourcePath.getFile(path);\n\t\t\t\tif(impFile == null) {\n\t\t\t\t\tpath = module.getParentPath() + \"/\" + imp.getPath();\n\t\t\t\t\timpFile = parser.params.sourcePath.getFile(path);\n\t\t\t\t\tif(impFile == null) {\n\t\t\t\t\t\tthrow new OocCompilationError(imp, module, \"Module not found in sourcepath: \"+imp.getPath());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cached == null || impFile.lastModified() > cached.lastModified) {\n\t\t\t\t\tif(cached != null) {\n\t\t\t\t\t\tSystem.out.println(path+\" has been changed, recompiling...\");\n\t\t\t\t\t}\n\t\t\t\t\tcached = parser.parse(path, impFile, imp);\n\t\t\t\t\tcache.put(imp.getName(), cached);\n\t\t\t\t}\n\t\t\t\timp.setModule(cached);\n\t\t\t}\n\t\t\n\t\t} catch(IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\tstatic void addLangImports(Module module, Parser parser) {\n\t\t\n\t\tif(module.getFullName().startsWith(\"lang.\")) {\n\t\t\tif(!module.getFullName().equals(\"lang.Object\")) {\n\t\t\t\tmodule.getImports().add(new Import(\"lang.Object\", Token.defaultToken));\n\t\t\t}\n\t\t\tif(!module.getFullName().equals(\"lang.ooclib\")) {\n\t\t\t\tmodule.getImports().add(new Import(\"lang.ooclib\", Token.defaultToken));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tCollection<String> paths = parser.params.sourcePath.getRelativePaths(\"lang\");\n\t\tfor(String path: paths) {\n\t\t\tString impName = path.replace('/', '.');\n\t\t\tif(!impName.toLowerCase().endsWith(\".ooc\")) continue;\n\t\t\timpName = impName.substring(0, impName.length() - 4); // ditch the '.ooc'\n\t\t\tif(!impName.equals(module.getFullName())) {\n\t\t\t\tmodule.getImports().add(new Import(impName, Token.defaultToken));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tpublic static void clearCache() {\n\t\tcache.clear();\n\t}\n\t\n}\n","lineNo":93}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tif(impl != null) {\n\t\t\tType result = getRealType(impl.getReturnType());\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\t//return impl != null;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) throws IOException {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) resolveConstructorCall(stack, false);\n\t\t\telse if (name.equals(\"super\")) resolveConstructorCall(stack, true);\n\t\t\telse resolveRegular(stack, res, fatal);\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null && fatal) {\n\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n\t\t\tString guess = guessCorrectName(stack, res);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn (impl == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res)\n\t\t\tthrows IOException {\n\n\t\tif(impl == null) return Response.LOOP;\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, GenericType> generics = impl.getGenericTypes();\n\t\tif(!generics.isEmpty()) for(GenericType genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(GenericType genType: impl.getTypeDecl().getGenericTypes().values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tGenericType genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\tunwrapFromVarDecl(stack, genType,  atom);\n\t\t\t\treturn Response.RESTART;\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\tType realType = getRealType(implRetType);\n\t\t\t\tvdfe.setType(realType);\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, GenericType genType) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tprivate void unwrapFromVarDecl(final NodeList<Node> stack,\n\t\t\tGenericType genType, VariableDeclAtom atom) throws OocCompilationError, EOFException {\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\tdecl.setType(getRealType(decl.getType(), genType));\n\t\t/*\n\t\tif(decl.getType().getRef() instanceof GenericType) {\n\t\t\tString endMsg = \"\";\n\t\t\tif(this instanceof MemberCall) {\n\t\t\t\tendMsg = \" - \"+((MemberCall) this).getExpression().getType()\n\t\t\t\t\t+\" should be type-specified, (with <Param1, Param2, ...>)\";\n\t\t\t} else {\n\t\t\t\tendMsg = \" - not enough type information.\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't guess return type of function \"\n\t\t\t\t\t+getProtoRepr()+endMsg);\n\t\t}\n\t\t*/\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic Type getRealType(Type originType) {\n\t\tif(!(originType.getRef() instanceof GenericType)) {\n\t\t\tType result = originType.clone();\n\t\t\trealTypizeChildren(result);\n\t\t\treturn result;\n\t\t}\n\t\tGenericType genType = (GenericType) originType.getRef();\n\t\treturn getRealType(originType, genType);\n\t}\n\n\tpublic Type getRealType(Type originType, GenericType genType) {\n\t\tint i = -1;\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tType result = null;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\tType implType = arg.getType();\n\t\t\tType realType = callArg.getType();\n\t\t\tresult = tryTypeCombination(genType, implType, realType);\n\t\t\tif(result != null) break;\n\t\t}\n\t\t\n\t\t\n\t\tif(result == null) result = originType;\n\t\trealTypizeChildren(result);\n\t\treturn result;\n\t}\n\n\tprivate Type tryTypeCombination(GenericType genType, Type implType, Type realType) {\n\t\tType result = null;\n\t\tif(implType.getName().equals(genType.getName())) {\n\t\t\tint level = implType.getPointerLevel();\n\t\t\tif(level > 0) {\n\t\t\t\tresult = realType.clone();\n\t\t\t\tresult.setPointerLevel(realType.getPointerLevel() - level);\n\t\t\t}\n\t\t\tresult = realType;\n\t\t}\n\t\tif(result == null) {\n\t\t\tDeclaration ref = realType.getRef();\n\t\t\tif(ref instanceof TypeDecl) {\n\t\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\t\tList<Type> realGenTypes = realType.getGenericTypes();\n\t\t\t\tint i = -1;\n\t\t\t\tfor(GenericType subType: typeDecl.getGenericTypes().values()) {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(i >= realGenTypes.size()) break;\n\t\t\t\t\tType subRealType = realGenTypes.get(i);\n\t\t\t\t\tType subImplType = new Type(subType.getName(), startToken);\n\t\t\t\t\tsubImplType.setRef(subType);\n\t\t\t\t\tresult = tryTypeCombination(genType, subImplType, subRealType);\n\t\t\t\t\tif(result != null) return result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected void realTypizeChildren(Type result) {\n\t\tif(result == null) return;\n\t\tint j = -1;\n\t\tfor(Type subType: result.getGenericTypes()) {\n\t\t\tj++;\n\t\t\tresult.getGenericTypes().set(j, getRealType(subType));\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\")) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t}\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack,\n\t\t\tfinal Resolver res) throws IOException {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl func) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = func.getArguments();\n\t\tif(matchesArgs(func)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(func.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> typeParams;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.typeParams = new NodeList<Expression>();\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getTypeParams() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tif(impl != null) {\n\t\t\tType retType = impl.getReturnType();\n\t\t\tif(retType.isGenericRecursive()) {\n\t\t\t\tType realType = realTypize(retType.clone());\n\t\t\t\treturn realType;\n\t\t\t}\n\t\t\treturn retType;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate Type realTypize(Type type) {\n\t\t\n\t\tint i = -1;\n\t\tfor(VariableAccess exprParam: type.getTypeParams()) {\n\t\t\ti++;\n\t\t\tif(exprParam.getType() != null && exprParam.getType().getName().equals(\"Class\")) {\n\t\t\t\tVariableAccess expr = resolveTypeParam(exprParam.getName(), null, true);\n\t\t\t\tif(expr != null){\n\t\t\t\t\ttype.getTypeParams().set(i, expr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn type;\n\t\t\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\ttypeParams.accept(visitor);\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) throws IOException {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) {\n\t\t\t\tresolveConstructorCall(stack, false);\n\t\t\t} else if (name.equals(\"super\")) {\n\t\t\t\tresolveConstructorCall(stack, true);\n\t\t\t}  else {\n\t\t\t\tResponse response = resolveRegular(stack, res, fatal);\n\t\t\t\tif(response != Response.OK) return response;\n\t\t\t}\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res, fatal);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null && fatal) {\n\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n\t\t\tString guess = guessCorrectName(stack, res);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn (impl == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res, boolean fatal)\n\t\t\tthrows IOException {\n\n\t\tif(impl == null) {\n\t\t\tif(fatal) throw new OocCompilationError(this, stack, \"Didn't find implementation for \"\n\t\t\t\t\t+this+\", can't handle generics.\");\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, TypeParam> generics = impl.getTypeParams();\n\t\tif(!generics.isEmpty()) for(TypeParam genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(TypeParam genType: impl.getTypeDecl().getTypeParams().values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tTypeParam genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\treturn unwrapFromVarDecl(stack, genType,  atom, fatal);\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(typeParams.size() < impl.getTypeParams().size()) {\n\t\t\tIterator<TypeParam> iter = impl.getTypeParams().values().iterator();\n\t\t\tfor(int i = 0; i < typeParams.size(); i++) iter.next();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tTypeParam typeParam = iter.next();\n\t\t\t\tExpression result = resolveTypeParam(typeParam.getName(), stack, fatal);\n\t\t\t\tif(result == null) {\n\t\t\t\t\tif(fatal) throwUnresolvedType(stack, typeParam.getName());\n\t\t\t\t\treturn Response.LOOP;\n\t\t\t\t}\n\t\t\t\ttypeParams.add(result);\n\t\t\t}\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprotected VariableAccess resolveTypeParam(String typeParam, NodeList<Node> stack, boolean fatal) {\n\n\t\tif(impl == null) return null;\n\t\t\n\t\tVariableAccess result = null;\n\t\t\n\t\tint i = -1;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\ti++;\n\t\t\tif(arg.getType().getName().equals(typeParam)) {\n\t\t\t\tExpression callArg = arguments.get(i);\n\t\t\t\tresult = new MemberAccess(callArg, \"class\", callArg.startToken);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, TypeParam genType) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tprivate Response unwrapFromVarDecl(final NodeList<Node> stack,\n\t\t\tTypeParam genType, VariableDeclAtom atom, boolean fatal) throws OocCompilationError, EOFException {\n\t\t\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\n\t\tDeclaration typeRef = decl.getType().getRef();\n\t\tif(typeRef == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out ref of type \"+decl);\n\t\t\t}\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\tExpression result = resolveTypeParam(typeRef.getName(), stack, true);\n\t\tdecl.setType(result.getType());\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t\t\n\t\treturn Response.RESTART;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\")) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected Response resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(varDecl.getType() == null) return Response.LOOP;\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t\treturn Response.OK;\n\t\t}\n\t\treturn Response.LOOP;\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack,\n\t\t\tfinal Resolver res) throws IOException {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl func) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = func.getArguments();\n\t\tif(matchesArgs(func)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(func.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\n\tpublic void throwUnresolvedType(NodeList<Node> stack, String typeName) {\n\t\t\n\t\tif(impl != null) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+impl);\n\t\t}\n\t\tthrow new OocCompilationError(this, stack, \"Couldn't figure out generic type <\"+typeName+\"> for \"+getProtoRepr());\n\t\t\n\t}\n\t\n}\n","lineNo":79}
{"Smelly Sample":"package org.ooc.frontend.parser;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Statement;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class LineParser {\n\n\tpublic static boolean fill(Module module, SourceReader sReader, TokenReader reader, NodeList<Line> body) throws IOException {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\treader.skipWhitespace();\n\t\t\n\t\tif(!reader.hasNext()) {\n\t\t\treader.reset(mark);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tStatement statement = StatementParser.parse(module, sReader, reader);\n\t\tif(statement == null) {\n\t\t\treader.reset(mark);\n\t\t\treturn false;\n\t\t}\n\t\tbody.add(new Line(statement));\n\t\t\n\t\twhile(reader.peek().type == TokenType.DOT) {\n\t\t\tExpression expr = null;\n\t\t\tif(statement instanceof MemberCall) {\n\t\t\t\tMemberCall memberCall = (MemberCall) statement;\n\t\t\t\texpr = memberCall.getExpression();\n\t\t\t} else if(statement instanceof VariableDecl) {\n\t\t\t\tVariableDecl varDecl = (VariableDecl) statement;\n\t\t\t\texpr = new VariableAccess(varDecl, statement.startToken);\n\t\t\t} else if(statement instanceof Expression) {\n\t\t\t\texpr = (Expression) statement;\n\t\t\t} else {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Dots '.' for chain-calls should be used after member function calls only\");\n\t\t\t}\n\t\t\treader.skip();\n\t\t\tToken startToken = reader.peek();\n\t\t\tFunctionCall otherCall = FunctionCallParser.parse(module, sReader, reader);\n\t\t\tif(otherCall == null) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\"Expected function call after a dot '.'\");\n\t\t\t}\n\t\t\tstatement = new MemberCall(expr, otherCall, startToken);\n\t\t\tbody.add(new Line(statement));\n\t\t}\n\t\t\n\t\tif(!(statement instanceof ControlStatement)) {\n\t\t\tToken next = reader.peek();\n\t\t\tif(next.type != TokenType.LINESEP && next.type != TokenType.CLOS_BRACK && next.type != TokenType.CLOS_PAREN) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(next),\n\t\t\t\t\t\t\"Missing semi-colon at the end of a line (got a \"+next+\" instead)\");\n\t\t\t}\n\t\t\tif(next.type == TokenType.LINESEP) reader.skip();\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}\n\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.parser;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.BinaryOperation;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Statement;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.VariableDeclFromExpr;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.frontend.model.tokens.TokenReader;\nimport org.ooc.frontend.model.tokens.Token.TokenType;\nimport org.ubi.CompilationFailedError;\nimport org.ubi.SourceReader;\n\npublic class LineParser {\n\n\tpublic static boolean fill(Module module, SourceReader sReader, TokenReader reader, NodeList<Line> body) throws IOException {\n\t\t\n\t\tint mark = reader.mark();\n\t\t\n\t\treader.skipWhitespace();\n\t\t\n\t\tif(!reader.hasNext()) {\n\t\t\treader.reset(mark);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tStatement statement = StatementParser.parse(module, sReader, reader);\n\t\tif(statement == null) {\n\t\t\treader.reset(mark);\n\t\t\treturn false;\n\t\t}\n\t\tLine line = new Line(statement);\n\t\tbody.add(line);\n\t\t\n\t\twhile(reader.peek().type == TokenType.DOT) {\n\t\t\tExpression expr = null;\n\t\t\tif(statement instanceof MemberCall) {\n\t\t\t\tMemberCall memberCall = (MemberCall) statement;\n\t\t\t\texpr = memberCall.getExpression();\n\t\t\t\tif(expr instanceof FunctionCall || expr instanceof BinaryOperation) {\n\t\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\t\tstatement.generateTempName(\"callroot\"), expr, statement.startToken);\n\t\t\t\t\tbody.addBefore(line, new Line(vdfe));\n\t\t\t\t\texpr = new VariableAccess(vdfe, expr.startToken);\n\t\t\t\t\tmemberCall.setExpression(expr);\n\t\t\t\t}\n\t\t\t} else if(statement instanceof VariableDecl) {\n\t\t\t\tVariableDecl varDecl = (VariableDecl) statement;\n\t\t\t\texpr = new VariableAccess(varDecl, statement.startToken);\n\t\t\t} else if(statement instanceof Expression) {\n\t\t\t\texpr = (Expression) statement;\n\t\t\t} else {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\t\"Dots '.' for chain-calls should be used after expressions, not \"\n\t\t\t\t\t\t+statement.getClass().getSimpleName()+\"s.\");\n\t\t\t}\n\t\t\treader.skip();\n\t\t\tToken startToken = reader.peek();\n\t\t\tFunctionCall otherCall = FunctionCallParser.parse(module, sReader, reader);\n\t\t\tif(otherCall == null) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(reader.peek()),\n\t\t\t\t\t\"Expected function call after a dot '.'\");\n\t\t\t}\n\t\t\tstatement = new MemberCall(expr, otherCall, startToken);\n\t\t\tbody.add(new Line(statement));\n\t\t}\n\t\t\n\t\tif(!(statement instanceof ControlStatement)) {\n\t\t\tToken next = reader.peek();\n\t\t\tif(next.type != TokenType.LINESEP && next.type != TokenType.CLOS_BRACK && next.type != TokenType.CLOS_PAREN) {\n\t\t\t\tthrow new CompilationFailedError(sReader.getLocation(next),\n\t\t\t\t\t\t\"Missing semi-colon at the end of a line (got a \"+next+\" instead)\");\n\t\t\t}\n\t\t\tif(next.type == TokenType.LINESEP) reader.skip();\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}\n\n\t\n}\n","lineNo":41}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ValuedReturn extends Return implements MustBeResolved {\n\n\tprotected Expression expression;\n\n\tpublic ValuedReturn(Expression expression, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.expression = expression;\n\t}\n\t\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\t\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\texpression.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(super.replace(oldie, kiddo)) return true;\n\t\t\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.replace(oldie, kiddo);\n\t\t\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal)\n\t\t\tthrows IOException {\n\t\t\n\t\tint funcIndex = stack.find(FunctionDecl.class);\n\t\tif(funcIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, stack, \"'return' outside a function: wtf?\");\n\t\t}\n\t\tFunctionDecl decl = (FunctionDecl) stack.get(funcIndex);\n\t\tType returnType = decl.getReturnType();\n\t\tGenericType param = getGenericType(stack, returnType.getName());\n\t\tif(param != null) {\n\t\t\tunwrapToMemcpy(stack, decl, param);\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void unwrapToMemcpy(NodeList<Node> stack, FunctionDecl decl,\n\t\t\tDeclaration genericType) {\n\t\tFunctionCall call = new FunctionCall(\"memcpy\", \"\", startToken);\n\t\tcall.getArguments().add(new VariableAccess(decl.getReturnArg(), startToken));\n\t\t\n\t\tVariableAccess tAccess = new VariableAccess(genericType.getName(), startToken);\n\t\tMemberAccess sizeAccess = new MemberAccess(tAccess, \"size\", startToken);\n\t\t\n\t\tif(expression instanceof ArrayAccess) {\n\t\t\tArrayAccess arrAccess = (ArrayAccess) expression;\n\t\t\texpression = new Add(new AddressOf(arrAccess.variable, startToken),\n\t\t\t\t\tnew Mul(arrAccess.index, sizeAccess, startToken), startToken);\n\t\t} else {\n\t\t\texpression = new AddressOf(expression, startToken);\n\t\t}\n\t\tcall.getArguments().add(expression);\n\t\t\n\t\tcall.getArguments().add(sizeAccess);\n\t\tstack.peek().replace(this, call);\n\t\t\n\t\tint lineIndex = stack.find(Line.class);\n\t\t((NodeList<Node>) stack.get(lineIndex - 1)).addAfter(stack.get(lineIndex), new Line(new Return(startToken)));\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ValuedReturn extends Return implements MustBeResolved {\n\n\tprotected Expression expression;\n\n\tpublic ValuedReturn(Expression expression, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.expression = expression;\n\t}\n\t\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\t\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\texpression.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(super.replace(oldie, kiddo)) return true;\n\t\t\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.replace(oldie, kiddo);\n\t\t\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal)\n\t\t\tthrows IOException {\n\t\t\n\t\tint funcIndex = stack.find(FunctionDecl.class);\n\t\tif(funcIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, stack, \"'return' outside a function: wtf?\");\n\t\t}\n\t\tFunctionDecl decl = (FunctionDecl) stack.get(funcIndex);\n\t\tType returnType = decl.getReturnType();\n\t\tGenericType param = getGenericType(stack, returnType.getName());\n\t\tif(param != null) {\n\t\t\tunwrapToMemcpy(stack, decl, param);\n\t\t\treturn Response.RESTART;\n\t\t}\n\t\t\n\t\tif(returnType.isSuperOf(expression.getType())) {\n\t\t\texpression = new Cast(expression, returnType, expression.startToken);\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void unwrapToMemcpy(NodeList<Node> stack, FunctionDecl decl,\n\t\t\tDeclaration genericType) {\n\t\tFunctionCall call = new FunctionCall(\"memcpy\", \"\", startToken);\n\t\tVariableAccess returnArgAcc = new VariableAccess(decl.getReturnArg(), startToken);\n\t\tNodeList<Expression> args = call.getArguments();\n\t\targs.add(returnArgAcc);\n\t\t\n\t\tVariableAccess tAccess = new VariableAccess(genericType.getName(), startToken);\n\t\tMemberAccess sizeAccess = new MemberAccess(tAccess, \"size\", startToken);\n\t\t\n\t\tif(expression instanceof ArrayAccess) {\n\t\t\tArrayAccess arrAccess = (ArrayAccess) expression;\n\t\t\texpression = new Add(new AddressOf(arrAccess.variable, startToken),\n\t\t\t\t\tnew Mul(arrAccess.index, sizeAccess, startToken), startToken);\n\t\t} else {\n\t\t\texpression = new AddressOf(expression, startToken);\n\t\t}\n\t\targs.add(expression);\n\t\targs.add(sizeAccess);\n\t\t\n\t\tIf if1 = new If(returnArgAcc, startToken);\n\t\tif1.getBody().add(new Line(call));\n\t\tstack.peek().replace(this, if1);\n\t\t\n\t\tint lineIndex = stack.find(Line.class);\n\t\t((NodeList<Node>) stack.get(lineIndex - 1)).addAfter(stack.get(lineIndex), new Line(new Return(startToken)));\n\t}\n\t\n}\n","lineNo":91}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tif(impl != null) {\n\t\t\tType result = getRealType(impl.getReturnType());\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\t//return impl != null;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) throws IOException {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) resolveConstructorCall(stack, false);\n\t\t\telse if (name.equals(\"super\")) resolveConstructorCall(stack, true);\n\t\t\telse resolveRegular(stack, res, fatal);\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null && fatal) {\n\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n\t\t\tString guess = guessCorrectName(stack, res);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn (impl == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res)\n\t\t\tthrows IOException {\n\n\t\tif(impl == null) return Response.LOOP;\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, GenericType> generics = impl.getGenericTypes();\n\t\tif(!generics.isEmpty()) for(GenericType genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(GenericType genType: impl.getTypeDecl().getGenericTypes().values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tGenericType genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\tunwrapFromVarDecl(stack, genType,  atom);\n\t\t\t\treturn Response.RESTART;\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\tType realType = getRealType(implRetType);\n\t\t\t\tvdfe.setType(realType);\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, GenericType genType) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tprivate void unwrapFromVarDecl(final NodeList<Node> stack,\n\t\t\tGenericType genType, VariableDeclAtom atom) throws OocCompilationError, EOFException {\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\tdecl.setType(getRealType(decl.getType(), genType));\n\t\t/*\n\t\tif(decl.getType().getRef() instanceof GenericType) {\n\t\t\tString endMsg = \"\";\n\t\t\tif(this instanceof MemberCall) {\n\t\t\t\tendMsg = \" - \"+((MemberCall) this).getExpression().getType()\n\t\t\t\t\t+\" should be type-specified, (with <Param1, Param2, ...>)\";\n\t\t\t} else {\n\t\t\t\tendMsg = \" - not enough type information.\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't guess return type of function \"\n\t\t\t\t\t+getProtoRepr()+endMsg);\n\t\t}\n\t\t*/\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic Type getRealType(Type originType) {\n\t\tif(!(originType.getRef() instanceof GenericType)) {\n\t\t\tType result = originType.clone();\n\t\t\trealTypizeChildren(result);\n\t\t\treturn result;\n\t\t}\n\t\tGenericType genType = (GenericType) originType.getRef();\n\t\treturn getRealType(originType, genType);\n\t}\n\n\tpublic Type getRealType(Type originType, GenericType genType) {\n\t\tint i = -1;\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tType result = null;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\tType implType = arg.getType();\n\t\t\tType realType = callArg.getType();\n\t\t\tresult = tryTypeCombination(genType, implType, realType);\n\t\t\tif(result != null) break;\n\t\t}\n\t\t\n\t\t\n\t\tif(result == null) result = originType;\n\t\trealTypizeChildren(result);\n\t\treturn result;\n\t}\n\n\tprivate Type tryTypeCombination(GenericType genType, Type implType, Type realType) {\n\t\tType result = null;\n\t\tif(implType.getName().equals(genType.getName())) {\n\t\t\tint level = implType.getPointerLevel();\n\t\t\tif(level > 0) {\n\t\t\t\tresult = realType.clone();\n\t\t\t\tresult.setPointerLevel(realType.getPointerLevel() - level);\n\t\t\t}\n\t\t\tresult = realType;\n\t\t}\n\t\tif(result == null) {\n\t\t\tDeclaration ref = realType.getRef();\n\t\t\tif(ref instanceof TypeDecl) {\n\t\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\t\tList<Type> realGenTypes = realType.getGenericTypes();\n\t\t\t\tint i = -1;\n\t\t\t\tfor(GenericType subType: typeDecl.getGenericTypes().values()) {\n\t\t\t\t\ti++;\n\t\t\t\t\tType subRealType = realGenTypes.get(i);\n\t\t\t\t\tType subImplType = new Type(subType.getName(), startToken);\n\t\t\t\t\tsubImplType.setRef(subType);\n\t\t\t\t\tresult = tryTypeCombination(genType, subImplType, subRealType);\n\t\t\t\t\tif(result != null) return result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected void realTypizeChildren(Type result) {\n\t\tif(result == null) return;\n\t\tint j = -1;\n\t\tfor(Type subType: result.getGenericTypes()) {\n\t\t\tj++;\n\t\t\tresult.getGenericTypes().set(j, getRealType(subType));\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\")) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t}\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack,\n\t\t\tfinal Resolver res) throws IOException {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tsB.append(iter.next().getType());\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl func) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = func.getArguments();\n\t\tif(matchesArgs(func)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(func.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tif(impl != null) {\n\t\t\tType result = getRealType(impl.getReturnType());\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\t//return impl != null;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) throws IOException {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) resolveConstructorCall(stack, false);\n\t\t\telse if (name.equals(\"super\")) resolveConstructorCall(stack, true);\n\t\t\telse resolveRegular(stack, res, fatal);\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null && fatal) {\n\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n\t\t\tString guess = guessCorrectName(stack, res);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn (impl == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res)\n\t\t\tthrows IOException {\n\n\t\tif(impl == null) return Response.LOOP;\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, GenericType> generics = impl.getGenericTypes();\n\t\tif(!generics.isEmpty()) for(GenericType genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(GenericType genType: impl.getTypeDecl().getGenericTypes().values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tGenericType genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\tunwrapFromVarDecl(stack, genType,  atom);\n\t\t\t\treturn Response.RESTART;\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\tType realType = getRealType(implRetType);\n\t\t\t\tvdfe.setType(realType);\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, GenericType genType) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tprivate void unwrapFromVarDecl(final NodeList<Node> stack,\n\t\t\tGenericType genType, VariableDeclAtom atom) throws OocCompilationError, EOFException {\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\tdecl.setType(getRealType(decl.getType(), genType));\n\t\t/*\n\t\tif(decl.getType().getRef() instanceof GenericType) {\n\t\t\tString endMsg = \"\";\n\t\t\tif(this instanceof MemberCall) {\n\t\t\t\tendMsg = \" - \"+((MemberCall) this).getExpression().getType()\n\t\t\t\t\t+\" should be type-specified, (with <Param1, Param2, ...>)\";\n\t\t\t} else {\n\t\t\t\tendMsg = \" - not enough type information.\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't guess return type of function \"\n\t\t\t\t\t+getProtoRepr()+endMsg);\n\t\t}\n\t\t*/\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic Type getRealType(Type originType) {\n\t\tif(!(originType.getRef() instanceof GenericType)) {\n\t\t\tType result = originType.clone();\n\t\t\trealTypizeChildren(result);\n\t\t\treturn result;\n\t\t}\n\t\tGenericType genType = (GenericType) originType.getRef();\n\t\treturn getRealType(originType, genType);\n\t}\n\n\tpublic Type getRealType(Type originType, GenericType genType) {\n\t\tint i = -1;\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tType result = null;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\tType implType = arg.getType();\n\t\t\tType realType = callArg.getType();\n\t\t\tresult = tryTypeCombination(genType, implType, realType);\n\t\t\tif(result != null) break;\n\t\t}\n\t\t\n\t\t\n\t\tif(result == null) result = originType;\n\t\trealTypizeChildren(result);\n\t\treturn result;\n\t}\n\n\tprivate Type tryTypeCombination(GenericType genType, Type implType, Type realType) {\n\t\tType result = null;\n\t\tif(implType.getName().equals(genType.getName())) {\n\t\t\tint level = implType.getPointerLevel();\n\t\t\tif(level > 0) {\n\t\t\t\tresult = realType.clone();\n\t\t\t\tresult.setPointerLevel(realType.getPointerLevel() - level);\n\t\t\t}\n\t\t\tresult = realType;\n\t\t}\n\t\tif(result == null) {\n\t\t\tDeclaration ref = realType.getRef();\n\t\t\tif(ref instanceof TypeDecl) {\n\t\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\t\tList<Type> realGenTypes = realType.getGenericTypes();\n\t\t\t\tint i = -1;\n\t\t\t\tfor(GenericType subType: typeDecl.getGenericTypes().values()) {\n\t\t\t\t\ti++;\n\t\t\t\t\tType subRealType = realGenTypes.get(i);\n\t\t\t\t\tType subImplType = new Type(subType.getName(), startToken);\n\t\t\t\t\tsubImplType.setRef(subType);\n\t\t\t\t\tresult = tryTypeCombination(genType, subImplType, subRealType);\n\t\t\t\t\tif(result != null) return result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected void realTypizeChildren(Type result) {\n\t\tif(result == null) return;\n\t\tint j = -1;\n\t\tfor(Type subType: result.getGenericTypes()) {\n\t\t\tj++;\n\t\t\tresult.getGenericTypes().set(j, getRealType(subType));\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\")) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t}\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack,\n\t\t\tfinal Resolver res) throws IOException {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression arg = iter.next();\n\t\t\tsB.append(arg.getType()+\":\"+arg);\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl func) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = func.getArguments();\n\t\tif(matchesArgs(func)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(func.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\t\n}\n","lineNo":503}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tif(impl != null) {\n\t\t\tType result = getRealType(impl.getReturnType());\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\t//return impl != null;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) throws IOException {\n\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) resolveConstructorCall(stack, false);\n\t\t\telse if (name.equals(\"super\")) resolveConstructorCall(stack, true);\n\t\t\telse resolveRegular(stack, res, fatal);\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\tif(impl == null && fatal) {\n\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n\t\t\tString guess = guessCorrectName(stack, res);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn (impl == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack)\n\t\t\tthrows EOFException {\n\n\t\tif(impl == null) {\n\t\t\treturn Response.LOOP;\n\t\t}\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, GenericType> generics = impl.getGenericTypes();\n\t\tif(!generics.isEmpty()) for(GenericType genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(GenericType genType: impl.getTypeDecl().getGenericTypes().values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tGenericType genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\tunwrapFromVarDecl(stack, genType,  atom);\n\t\t\t\treturn Response.RESTART;\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tType realType = getRealType(impl.getReturnType());\n\t\t\t\tvdfe.setType(realType);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, GenericType genType)\n\t\t\tthrows EOFException {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tprivate void unwrapFromVarDecl(final NodeList<Node> stack,\n\t\t\tGenericType genType, VariableDeclAtom atom) throws OocCompilationError, EOFException {\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\tdecl.setType(getRealType(decl.getType(), genType));\n\t\t/*\n\t\tif(decl.getType().getRef() instanceof GenericType) {\n\t\t\tString endMsg = \"\";\n\t\t\tif(this instanceof MemberCall) {\n\t\t\t\tendMsg = \" - \"+((MemberCall) this).getExpression().getType()\n\t\t\t\t\t+\" should be type-specified, (with <Param1, Param2, ...>)\";\n\t\t\t} else {\n\t\t\t\tendMsg = \" - not enough type information.\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't guess return type of function \"\n\t\t\t\t\t+getProtoRepr()+endMsg);\n\t\t}\n\t\t*/\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic Type getRealType(Type originType) {\n\t\tif(!(originType.getRef() instanceof GenericType)) {\n\t\t\tType result = originType.clone();\n\t\t\trealTypizeChildren(result);\n\t\t\treturn result;\n\t\t}\n\t\tGenericType genType = (GenericType) originType.getRef();\n\t\treturn getRealType(originType, genType);\n\t}\n\n\tpublic Type getRealType(Type originType, GenericType genType) {\n\t\t\n\t\tint i = -1;\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tType result = null;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\tType implType = arg.getType();\n\t\t\tType realType = callArg.getType();\n\t\t\tresult = tryTypeCombination(genType, implType, realType);\n\t\t\tif(result != null) break;\n\t\t}\n\t\t\n\t\t\n\t\tif(result == null) result = originType;\n\t\trealTypizeChildren(result);\n\t\treturn result;\n\t}\n\n\tprivate Type tryTypeCombination(GenericType genType, Type implType, Type realType) {\n\t\tType result = null;\n\t\tif(implType.getName().equals(genType.getName())) {\n\t\t\tint level = implType.getPointerLevel();\n\t\t\tif(level > 0) {\n\t\t\t\tresult = realType.clone();\n\t\t\t\tresult.setPointerLevel(realType.getPointerLevel() - level);\n\t\t\t}\n\t\t\tresult = realType;\n\t\t}\n\t\tif(result == null) {\n\t\t\tDeclaration ref = realType.getRef();\n\t\t\tif(ref instanceof TypeDecl) {\n\t\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\t\tList<Type> realGenTypes = realType.getGenericTypes();\n\t\t\t\tint i = -1;\n\t\t\t\tfor(GenericType subType: typeDecl.getGenericTypes().values()) {\n\t\t\t\t\ti++;\n\t\t\t\t\tType subRealType = realGenTypes.get(i);\n\t\t\t\t\tType subImplType = new Type(subType.getName(), startToken);\n\t\t\t\t\tsubImplType.setRef(subType);\n\t\t\t\t\tresult = tryTypeCombination(genType, subImplType, subRealType);\n\t\t\t\t\tif(result != null) return result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected void realTypizeChildren(Type result) {\n\t\tif(result == null) return;\n\t\tint j = -1;\n\t\tfor(Type subType: result.getGenericTypes()) {\n\t\t\tj++;\n\t\t\tresult.getGenericTypes().set(j, getRealType(subType));\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError, EOFException {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\")) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t}\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack,\n\t\t\tfinal Resolver res) throws IOException {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tsB.append(iter.next().getType());\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl func) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = func.getArguments();\n\t\tif(matchesArgs(func)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(func.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tif(impl != null) {\n\t\t\tType result = getRealType(impl.getReturnType());\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\t//return impl != null;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) throws IOException {\n\t\t\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) resolveConstructorCall(stack, false);\n\t\t\telse if (name.equals(\"super\")) resolveConstructorCall(stack, true);\n\t\t\telse resolveRegular(stack, res, fatal);\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack, res);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n \t\tif(impl == null && fatal) {\n\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n\t\t\tString guess = guessCorrectName(stack, res);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn (impl == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack, final Resolver res)\n\t\t\tthrows IOException {\n\n\t\tif(impl == null) return Response.LOOP;\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, GenericType> generics = impl.getGenericTypes();\n\t\tif(!generics.isEmpty()) for(GenericType genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(GenericType genType: impl.getTypeDecl().getGenericTypes().values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tGenericType genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\tunwrapFromVarDecl(stack, genType,  atom);\n\t\t\t\treturn Response.RESTART;\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tType implRetType = impl.getReturnType();\n\t\t\t\tif(implRetType.getRef() == null) {\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.push(impl.getTypeDecl());\n\t\t\t\t\tstack.push(impl);\n\t\t\t\t\timplRetType.resolve(stack, res, false);\n\t\t\t\t\tstack.pop(impl);\n\t\t\t\t\tif(impl.getTypeDecl() != null) stack.pop(impl.getTypeDecl());\n\t\t\t\t}\n\t\t\t\tType realType = getRealType(implRetType);\n\t\t\t\tvdfe.setType(realType);\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, GenericType genType) {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"unused\" })\n\tprivate void unwrapFromVarDecl(final NodeList<Node> stack,\n\t\t\tGenericType genType, VariableDeclAtom atom) throws OocCompilationError, EOFException {\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\tdecl.setType(getRealType(decl.getType(), genType));\n\t\t/*\n\t\tif(decl.getType().getRef() instanceof GenericType) {\n\t\t\tString endMsg = \"\";\n\t\t\tif(this instanceof MemberCall) {\n\t\t\t\tendMsg = \" - \"+((MemberCall) this).getExpression().getType()\n\t\t\t\t\t+\" should be type-specified, (with <Param1, Param2, ...>)\";\n\t\t\t} else {\n\t\t\t\tendMsg = \" - not enough type information.\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't guess return type of function \"\n\t\t\t\t\t+getProtoRepr()+endMsg);\n\t\t}\n\t\t*/\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic Type getRealType(Type originType) {\n\t\tif(!(originType.getRef() instanceof GenericType)) {\n\t\t\tType result = originType.clone();\n\t\t\trealTypizeChildren(result);\n\t\t\treturn result;\n\t\t}\n\t\tGenericType genType = (GenericType) originType.getRef();\n\t\treturn getRealType(originType, genType);\n\t}\n\n\tpublic Type getRealType(Type originType, GenericType genType) {\n\t\tint i = -1;\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tType result = null;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tExpression callArg = arguments.get(i);\n\t\t\tType implType = arg.getType();\n\t\t\tType realType = callArg.getType();\n\t\t\tresult = tryTypeCombination(genType, implType, realType);\n\t\t\tif(result != null) break;\n\t\t}\n\t\t\n\t\t\n\t\tif(result == null) result = originType;\n\t\trealTypizeChildren(result);\n\t\treturn result;\n\t}\n\n\tprivate Type tryTypeCombination(GenericType genType, Type implType, Type realType) {\n\t\tType result = null;\n\t\tif(implType.getName().equals(genType.getName())) {\n\t\t\tint level = implType.getPointerLevel();\n\t\t\tif(level > 0) {\n\t\t\t\tresult = realType.clone();\n\t\t\t\tresult.setPointerLevel(realType.getPointerLevel() - level);\n\t\t\t}\n\t\t\tresult = realType;\n\t\t}\n\t\tif(result == null) {\n\t\t\tDeclaration ref = realType.getRef();\n\t\t\tif(ref instanceof TypeDecl) {\n\t\t\t\tTypeDecl typeDecl = (TypeDecl) ref;\n\t\t\t\tList<Type> realGenTypes = realType.getGenericTypes();\n\t\t\t\tint i = -1;\n\t\t\t\tfor(GenericType subType: typeDecl.getGenericTypes().values()) {\n\t\t\t\t\ti++;\n\t\t\t\t\tType subRealType = realGenTypes.get(i);\n\t\t\t\t\tType subImplType = new Type(subType.getName(), startToken);\n\t\t\t\t\tsubImplType.setRef(subType);\n\t\t\t\t\tresult = tryTypeCombination(genType, subImplType, subRealType);\n\t\t\t\t\tif(result != null) return result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected void realTypizeChildren(Type result) {\n\t\tif(result == null) return;\n\t\tint j = -1;\n\t\tfor(Type subType: result.getGenericTypes()) {\n\t\t\tj++;\n\t\t\tresult.getGenericTypes().set(j, getRealType(subType));\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\")) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t}\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack,\n\t\t\tfinal Resolver res) throws IOException {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tsB.append(iter.next().getType());\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl func) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = func.getArguments();\n\t\tif(matchesArgs(func)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(func.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\t\n}\n","lineNo":176}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.GenericType;\nimport org.ooc.frontend.model.VariableAccess;\n\npublic class CastWriter {\n\n\tpublic static void write(Cast cast, CGenerator cgen) throws IOException {\n\t\tif(cast.getExpression().getType().getRef() instanceof GenericType) {\n\t\t\tVariableAccess access = (VariableAccess) cast.getExpression();\n\t\t\tcgen.current.app(\"*((\");\n\t\t\tcast.getType().accept(cgen);\n\t\t\tcgen.current.app(\"*)\");\n\t\t\tAccessWriter.writeVariable(access, false, cgen);\n\t\t\tcgen.current.app(')');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tcgen.current.app(\"((\");\n\t\tcast.getType().accept(cgen);\n\t\tcgen.current.app(\") \");\n\t\tcast.getExpression().accept(cgen);\n\t\tcgen.current.app(\")\");\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.GenericType;\nimport org.ooc.frontend.model.VariableAccess;\n\npublic class CastWriter {\n\n\tpublic static void write(Cast cast, CGenerator cgen) throws IOException {\n\t\tif(cast.getExpression().getType().getRef() instanceof GenericType) {\n\t\t\tExpression expr = cast.getExpression();\n\t\t\tif(expr instanceof VariableAccess) {\n\t\t\t\tVariableAccess access = (VariableAccess) expr;\n\t\t\t\tcgen.current.app(\"*((\");\n\t\t\t\tcast.getType().accept(cgen);\n\t\t\t\tcgen.current.app(\"*)\");\n\t\t\t\tAccessWriter.writeVariable(access, false, cgen);\n\t\t\t\tcgen.current.app(')');\n\t\t\t\treturn;\n\t\t\t} else if(expr instanceof ArrayAccess) {\n\t\t\t\tArrayAccess access = (ArrayAccess) expr;\n\t\t\t\tcgen.current.app(\"*((\");\n\t\t\t\tcast.getType().accept(cgen);\n\t\t\t\tcgen.current.app(\"*) (\");\n\t\t\t\taccess.getVariable().accept(cgen);\n\t\t\t\tcgen.current.app(\" + \");\n\t\t\t\taccess.getIndex().accept(cgen);\n\t\t\t\tcgen.current.app(\" * \").app(cast.getType().getMangledName());\n\t\t\t\tcgen.current.app(\"_class()->size))\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcgen.current.app(\"((\");\n\t\tcast.getType().accept(cgen);\n\t\tcgen.current.app(\") \");\n\t\tcast.getExpression().accept(cgen);\n\t\tcgen.current.app(\")\");\n\t}\n\t\n}\n","lineNo":15}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.model.Argument;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.GenericType;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.middle.OocCompilationError;\n\npublic class CallWriter {\n\n\tpublic static FunctionCall noCast = null;\n\t\n\tpublic static void write(FunctionCall functionCall, CGenerator cgen) throws IOException {\n\n\t\tFunctionDecl impl = functionCall.getImpl();\n\t\twritePrelude(cgen, impl, functionCall);\n\t\t\n\t\tif(functionCall.getName().equals(\"sizeof\")) {\n\t\t\tExpression arg = functionCall.getArguments().getFirst();\n\t\t\tif(!(arg instanceof VariableAccess)) {\n\t\t\t\tthrow new OocCompilationError(arg, cgen.module, \"You can only call sizeof() on a type! What are you doing?\");\n\t\t\t}\n\t\t\tVariableAccess varAcc = (VariableAccess) arg;\n\t\t\tcgen.current.app(\"sizeof(\").app(varAcc.getName()).app(\")\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(functionCall.isConstructorCall()) {\n\t\t\tcgen.current.app(impl.getTypeDecl().getName());\n\t\t\tif(impl.getTypeDecl() instanceof ClassDecl) {\n\t\t\t\tcgen.current.app(\"_init\");\n\t\t\t} else{\n\t\t\t\tcgen.current.app(\"_new\");\n\t\t\t}\n\t\t\tif(!impl.getSuffix().isEmpty()) cgen.current.app('_').app(impl.getSuffix());\n\t\t} else if(impl.isFromPointer()) {\n\t\t\tcgen.current.app(functionCall.getName());\n\t\t} else {\n\t\t\timpl.writeFullName(cgen.current);\n\t\t}\n\t\t\n\t\tcgen.current.app('(');\n\t\twriteCallArgs(functionCall, impl, cgen);\n\t\tcgen.current.app(')');\n\t\t\n\t}\n\n\tprivate static void writePrelude(CGenerator cgen, FunctionDecl impl, FunctionCall call)\n\t\t\tthrows IOException {\n\t\tif(noCast != null && call == noCast) {\n\t\t\tnoCast = null;\n\t\t\treturn;\n\t\t}\n\t\tif(impl.getReturnType().isVoid()) {\n\t\t\tthrow new OocCompilationError(call, cgen.module, \"Trying to use void function as an expression!\");\n\t\t}\n\t\tif(impl.isExternWithName() && !impl.getReturnType().isVoid()) {\n\t\t\tcgen.current.app('(');\n\t\t\timpl.getReturnType().accept(cgen);\n\t\t\tcgen.current.app(\") \");\n\t\t}\n\t}\n\n\tpublic static void writeCallArgs(FunctionCall functionCall, FunctionDecl impl, CGenerator cgen) throws IOException {\n\t\twriteCallArgs(functionCall, impl, true, cgen);\n\t}\n\t\n\tpublic static void writeCallArgs(FunctionCall functionCall, FunctionDecl impl, boolean isFirstParam, CGenerator cgen) throws IOException {\n\t\tNodeList<Expression> callArgs = functionCall.getArguments();\n\t\t\n\t\tboolean isFirst = isFirstParam;\n\t\tif(functionCall.getReturnArg() != null) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tfunctionCall.getReturnArg().accept(cgen);\n\t\t}\n\t\tif(functionCall.isConstructorCall() && impl.getTypeDecl() instanceof ClassDecl) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tcgen.current.app('(');\n\t\t\timpl.getTypeDecl().getInstanceType().accept(cgen);\n\t\t\tcgen.current.app(')');\n\t\t\tcgen.current.app(\" this\");\n\t\t}\n\t\t\n\t\tif(!impl.isGeneric()) {\n\t\t\tIterator<Expression> iter = callArgs.iterator();\n\t\t\tint argIndex = -1;\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\targIndex++;\n\t\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\t\tisFirst = false;\n\t\t\t\twriteCallArg(iter.next(), impl, argIndex, cgen);\n\t\t\t}\n\t\t} else {\n\t\t\twriteGenericCallArgs(callArgs, impl, cgen, isFirst);\n\t\t}\n\t}\n\n\tprivate static void writeCallArg(Expression callArg, FunctionDecl impl, int argIndex, CGenerator cgen)\n\t\t\tthrows IOException {\n\t\tNodeList<Argument> implArgs = impl.getArguments();\n\t\tboolean shouldCast = false;\n\t\tif(argIndex != -1 && argIndex < implArgs.size() && (impl.isExtern() || impl.getName().equals(\"init\"))) {\n\t\t\tArgument arg = implArgs.get(argIndex);\n\t\t\tif(!(arg instanceof VarArg)) {\n\t\t\t\tshouldCast = true;\n\t\t\t\tcgen.current.app(\"((\");\n\t\t\t\targ.getType().accept(cgen);\n\t\t\t\tcgen.current.app(\") (\");\n\t\t\t}\n\t\t}\n\t\tcallArg.accept(cgen);\n\t\tif(shouldCast) cgen.current.app(\"))\");\n\t}\n\n\tpublic static void writeGenericCallArgs(NodeList<Expression> callArgs,\n\t\t\tFunctionDecl impl, CGenerator cgen, boolean isFirstArg) throws IOException {\n\t\t\n\t\tboolean isFirst = isFirstArg;\n\t\tNodeList<Argument> implArgs = impl.getArguments();\n\t\t\n\t\tfor(GenericType typeParam: impl.getGenericTypes().values()) {\n\t\t\tisFirst = writeGenType(callArgs, impl, cgen, isFirst, typeParam);\n\t\t}\n\t\t\n\t\tint argIndex = impl.hasThis() ? 1 : 0;\n\t\tIterator<Expression> iter = callArgs.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tExpression expr = iter.next();\n\t\t\tArgument arg = implArgs.get(argIndex);\n\t\t\tGenericType genericType = impl.getGenericType(arg.getType().getName());\n\t\t\tif(genericType != null) cgen.current.app(\"(Octet*) &\");\n\t\t\twriteCallArg(expr, impl, argIndex, cgen);\n\t\t\targIndex++;\n\t\t}\n\t\t\n\t}\n\n\tprivate static boolean writeGenType(NodeList<Expression> callArgs,\n\t\t\tFunctionDecl impl, CGenerator cgen, boolean isFirstParam,\n\t\t\tGenericType typeParam) throws IOException, OocCompilationError,\n\t\t\tEOFException {\n\t\tboolean isFirst = isFirstParam;\n\t\tboolean done = false;\n\t\tint i = -1;\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument implArg = iter.next();\n\t\t\tif(implArg.getType().getName().equals(typeParam.getName())) {\n\t\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\t\tisFirst = false;\n\t\t\t\tExpression callArg = callArgs.get(i);\n\t\t\t\tif(callArg.getType().getRef() instanceof GenericType) {\n\t\t\t\t\tcgen.current.app(callArg.getType().getName());\n\t\t\t\t} else {\n\t\t\t\t\tcgen.current.app(callArg.getType().getName()).app(\"_class()\");\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(implArg.getName().equals(typeParam.getName())) {\n\t\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\t\tisFirst = false;\n\t\t\t\tcgen.current.app(implArg.getName());\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!done)\n\t\t\tthrow new OocCompilationError(callArgs, cgen.module,\n\t\t\t\t\t\"Couldn't find argument in \"+callArgs+\" to figure out generic type \"+typeParam);\n\t\treturn isFirst;\n\t}\n\n\tpublic static void writeMember(MemberCall memberCall, CGenerator cgen) throws IOException {\n\t\t\n\t\tFunctionDecl impl = memberCall.getImpl();\n\t\twritePrelude(cgen, impl, memberCall);\n\t\tif(impl.isFromPointer()) {\n\t\t\tboolean isArrow = memberCall.getExpression().getType().getRef() instanceof ClassDecl;\n\t\t\t\n\t\t\tExpression expression = memberCall.getExpression();\n\t\t\tif(!isArrow && expression instanceof Dereference) {\n\t\t\t\tDereference deref = (Dereference) expression;\n\t\t\t\texpression = deref.getExpression();\n\t\t\t\tisArrow = true;\n\t\t\t}\n\t\t\texpression.accept(cgen);\n\t\t\t\n\t\t\tif(isArrow) {\n\t\t\t\tcgen.current.app(\"->\");\n\t\t\t} else {\n\t\t\t\tcgen.current.app(\".\");\n\t\t\t}\n\t\t\tcgen.current.app(memberCall.getName());\n\t\t} else {\n\t\t\timpl.writeFullName(cgen.current);\n\t\t}\n\t\t\n\t\tcgen.current.app('(');\n\t\t\n\t\tTypeDecl typeDecl = impl.getTypeDecl();\n\t\tif(!typeDecl.getInstanceType().equals(memberCall.getExpression().getType())) {\n\t\t\tcgen.current.app('(');\n\t\t\ttypeDecl.getInstanceType().accept(cgen);\n\t\t\tcgen.current.app(\") \");\n\t\t}\n\t\tif(!impl.isStatic() && !impl.isFromPointer()) {\n\t\t\tmemberCall.getExpression().accept(cgen);\n\t\t}\n\t\twriteCallArgs(memberCall, impl, false, cgen);\n\t\t\n\t\tcgen.current.app(')');\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.model.Argument;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.GenericType;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.middle.OocCompilationError;\n\npublic class CallWriter {\n\n\tpublic static FunctionCall noCast = null;\n\t\n\tpublic static void write(FunctionCall functionCall, CGenerator cgen) throws IOException {\n\n\t\tFunctionDecl impl = functionCall.getImpl();\n\t\twritePrelude(cgen, impl, functionCall);\n\t\t\n\t\tif(functionCall.getName().equals(\"sizeof\")) {\n\t\t\tExpression arg = functionCall.getArguments().getFirst();\n\t\t\tif(!(arg instanceof VariableAccess)) {\n\t\t\t\tthrow new OocCompilationError(arg, cgen.module, \"You can only call sizeof() on a type! What are you doing?\");\n\t\t\t}\n\t\t\tVariableAccess varAcc = (VariableAccess) arg;\n\t\t\tcgen.current.app(\"sizeof(\").app(varAcc.getName()).app(\")\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(functionCall.isConstructorCall()) {\n\t\t\tcgen.current.app(impl.getTypeDecl().getName());\n\t\t\tif(impl.getTypeDecl() instanceof ClassDecl) {\n\t\t\t\tcgen.current.app(\"_init\");\n\t\t\t} else{\n\t\t\t\tcgen.current.app(\"_new\");\n\t\t\t}\n\t\t\tif(!impl.getSuffix().isEmpty()) cgen.current.app('_').app(impl.getSuffix());\n\t\t} else if(impl.isFromPointer()) {\n\t\t\tcgen.current.app(functionCall.getName());\n\t\t} else {\n\t\t\timpl.writeFullName(cgen.current);\n\t\t}\n\t\t\n\t\tcgen.current.app('(');\n\t\twriteCallArgs(functionCall, impl, cgen);\n\t\tcgen.current.app(')');\n\t\t\n\t}\n\n\tprivate static void writePrelude(CGenerator cgen, FunctionDecl impl, FunctionCall call)\n\t\t\tthrows IOException {\n\t\tif(noCast != null && call == noCast) {\n\t\t\tnoCast = null;\n\t\t\treturn;\n\t\t}\n\t\tif(impl.getReturnType().isVoid()) {\n\t\t\tthrow new OocCompilationError(call, cgen.module, \"Trying to use void function as an expression!\");\n\t\t}\n\t\tif(impl.isExternWithName() && !impl.getReturnType().isVoid()) {\n\t\t\tcgen.current.app('(');\n\t\t\timpl.getReturnType().accept(cgen);\n\t\t\tcgen.current.app(\") \");\n\t\t}\n\t}\n\n\tpublic static void writeCallArgs(FunctionCall functionCall, FunctionDecl impl, CGenerator cgen) throws IOException {\n\t\twriteCallArgs(functionCall, impl, true, cgen);\n\t}\n\t\n\tpublic static void writeCallArgs(FunctionCall functionCall, FunctionDecl impl, boolean isFirstParam, CGenerator cgen) throws IOException {\n\t\tNodeList<Expression> callArgs = functionCall.getArguments();\n\t\t\n\t\tboolean isFirst = isFirstParam;\n\t\tif(functionCall.getReturnArg() != null) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tfunctionCall.getReturnArg().accept(cgen);\n\t\t}\n\t\tif(functionCall.isConstructorCall() && impl.getTypeDecl() instanceof ClassDecl) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tcgen.current.app('(');\n\t\t\timpl.getTypeDecl().getInstanceType().accept(cgen);\n\t\t\tcgen.current.app(')');\n\t\t\tcgen.current.app(\" this\");\n\t\t}\n\t\t\n\t\tif(!impl.isGeneric()) {\n\t\t\tIterator<Expression> iter = callArgs.iterator();\n\t\t\tint argIndex = -1;\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\targIndex++;\n\t\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\t\tisFirst = false;\n\t\t\t\twriteCallArg(iter.next(), impl, argIndex, cgen);\n\t\t\t}\n\t\t} else {\n\t\t\twriteGenericCallArgs(callArgs, impl, cgen, isFirst);\n\t\t}\n\t}\n\n\tprivate static void writeCallArg(Expression callArg, FunctionDecl impl, int argIndex, CGenerator cgen)\n\t\t\tthrows IOException {\n\t\tNodeList<Argument> implArgs = impl.getArguments();\n\t\tboolean shouldCast = false;\n\t\tif(argIndex != -1 && argIndex < implArgs.size() && (impl.isExtern() || impl.getName().equals(\"init\"))) {\n\t\t\tArgument arg = implArgs.get(argIndex);\n\t\t\tif(!(arg instanceof VarArg)) {\n\t\t\t\tshouldCast = true;\n\t\t\t\tcgen.current.app(\"((\");\n\t\t\t\targ.getType().accept(cgen);\n\t\t\t\tcgen.current.app(\") (\");\n\t\t\t}\n\t\t}\n\t\tcallArg.accept(cgen);\n\t\tif(shouldCast) cgen.current.app(\"))\");\n\t}\n\n\tpublic static void writeGenericCallArgs(NodeList<Expression> callArgs,\n\t\t\tFunctionDecl impl, CGenerator cgen, boolean isFirstArg) throws IOException {\n\t\t\n\t\tboolean isFirst = isFirstArg;\n\t\tNodeList<Argument> implArgs = impl.getArguments();\n\t\t\n\t\tfor(GenericType typeParam: impl.getGenericTypes().values()) {\n\t\t\tisFirst = writeGenType(callArgs, impl, cgen, isFirst, typeParam);\n\t\t}\n\t\t\n\t\tint argIndex = impl.hasThis() ? 1 : 0;\n\t\tIterator<Expression> iter = callArgs.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tExpression expr = iter.next();\n\t\t\tArgument arg = implArgs.get(argIndex);\n\t\t\tGenericType genericType = impl.getGenericType(arg.getType().getName());\n\t\t\tif(genericType != null) cgen.current.app(\"(Octet*) &\");\n\t\t\twriteCallArg(expr, impl, argIndex, cgen);\n\t\t\targIndex++;\n\t\t}\n\t\t\n\t}\n\n\tprivate static boolean writeGenType(NodeList<Expression> callArgs,\n\t\t\tFunctionDecl impl, CGenerator cgen, boolean isFirstParam,\n\t\t\tGenericType typeParam) throws IOException, OocCompilationError,\n\t\t\tEOFException {\n\t\tboolean isFirst = isFirstParam;\n\t\tboolean done = false;\n\t\tint i = -1;\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument implArg = iter.next();\n\t\t\tif(implArg.getType().getName().equals(typeParam.getName())) {\n\t\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\t\tisFirst = false;\n\t\t\t\tExpression callArg = callArgs.get(i);\n\t\t\t\tif(callArg.getType().getRef() instanceof GenericType) {\n\t\t\t\t\tcgen.current.app(callArg.getType().getName());\n\t\t\t\t} else {\n\t\t\t\t\tcgen.current.app(callArg.getType().getName()).app(\"_class()\");\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(implArg.getName().equals(typeParam.getName())) {\n\t\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\t\tisFirst = false;\n\t\t\t\tcgen.current.app(implArg.getName());\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!done)\n\t\t\tthrow new OocCompilationError(callArgs, cgen.module,\n\t\t\t\t\t\"Couldn't find argument in \"+callArgs+\" to figure out generic type \"+typeParam);\n\t\treturn isFirst;\n\t}\n\n\tpublic static void writeMember(MemberCall memberCall, CGenerator cgen) throws IOException {\n\t\t\n\t\tFunctionDecl impl = memberCall.getImpl();\n\t\twritePrelude(cgen, impl, memberCall);\n\t\tif(impl.isFromPointer()) {\n\t\t\tboolean isArrow = memberCall.getExpression().getType().getRef() instanceof ClassDecl;\n\t\t\t\n\t\t\tExpression expression = memberCall.getExpression();\n\t\t\tif(!isArrow && expression instanceof Dereference) {\n\t\t\t\tDereference deref = (Dereference) expression;\n\t\t\t\texpression = deref.getExpression();\n\t\t\t\tisArrow = true;\n\t\t\t}\n\t\t\texpression.accept(cgen);\n\t\t\t\n\t\t\tif(isArrow) {\n\t\t\t\tcgen.current.app(\"->\");\n\t\t\t} else {\n\t\t\t\tcgen.current.app(\".\");\n\t\t\t}\n\t\t\tcgen.current.app(memberCall.getName());\n\t\t} else {\n\t\t\timpl.writeFullName(cgen.current);\n\t\t}\n\t\t\n\t\tcgen.current.app('(');\n\t\t\n\t\tTypeDecl typeDecl = impl.getTypeDecl();\n\t\tif(!typeDecl.getInstanceType().equals(memberCall.getExpression().getType())) {\n\t\t\tcgen.current.app('(');\n\t\t\ttypeDecl.getInstanceType().accept(cgen);\n\t\t\tcgen.current.app(\") \");\n\t\t}\n\t\tboolean isFirst = true;\n\t\tif(!impl.isStatic() && !impl.isFromPointer()) {\n\t\t\tisFirst = false;\n\t\t\tmemberCall.getExpression().accept(cgen);\n\t\t}\n\t\twriteCallArgs(memberCall, impl, isFirst, cgen);\n\t\t\n\t\tcgen.current.app(')');\n\t\t\n\t}\n\t\n}\n","lineNo":224}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ClassDecl extends TypeDecl implements MustBeResolved, Generic {\n\n\tprotected boolean isAbstract;\n\t\n\tprotected OocDocComment comment;\n\tprotected LinkedHashMap<String, GenericType> typeParams;\n\t\n\tprotected FunctionDecl defaultInit = null;\n\t\n\tpublic ClassDecl(String name, String superName, boolean isAbstract, Token startToken) {\n\t\tsuper(name, (superName.isEmpty() && !name.equals(\"Object\")) ? \"Object\" : superName, startToken);\n\t\tthis.isAbstract = isAbstract;\n\t\tthis.superRef = null;\n\t\tthis.typeParams = new LinkedHashMap<String, GenericType>();\n\t\t\n\t\taddFunction(new FunctionDecl(\"load\",     \"\", false, true,  false, false, startToken));\n\t\taddFunction(new FunctionDecl(\"defaults\", \"\", false, false, false, false, startToken));\n\t\taddFunction(new FunctionDecl(\"destroy\",  \"\", false, false, false, false, startToken));\n\t\tif(!isAbstract) {\n\t\t\tFunctionDecl init = new FunctionDecl(\"init\",     \"\", false, false, false, false, startToken);\n\t\t\taddFunction(init);\n\t\t\tdefaultInit = init;\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic ClassDecl getSuperRef() {\n\t\treturn (ClassDecl) superRef;\n\t}\n\n\tpublic boolean isObjectClass() {\n\t\treturn name.equals(\"Object\");\n\t}\n\t\n\tpublic boolean isClassClass() {\n\t\treturn name.equals(\"Class\");\n\t}\n\t\n\tpublic boolean isRootClass() {\n\t\treturn isObjectClass() || isClassClass();\n\t}\n\t\n\tpublic OocDocComment getComment() {\n\t\treturn comment;\n\t}\n\t\n\tpublic void setComment(OocDocComment comment) {\n\t\tthis.comment = comment;\n\t}\n\t\n\tpublic boolean isAbstract() {\n\t\treturn isAbstract;\n\t}\n\t\n\tpublic void setAbstract(boolean isAbstract) {\n\t\tthis.isAbstract = isAbstract;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\treturn getInstanceType();\n\t}\n\t\n\t@Override\n\tpublic void addFunction(FunctionDecl decl) {\n\t\t\n\t\t\n\t\tif(decl.getName().equals(\"init\")) {\n\t\t\tif(defaultInit != null) {\n\t\t\t\tFunctionDecl newFunc = getFunction(\"new\", \"\", null);\n\t\t\t\tfunctions.remove(defaultInit);\n\t\t\t\tfunctions.remove(newFunc);\n\t\t\t\tdefaultInit = null;\n\t\t\t}\n\t\t\t\n\t\t\tFunctionDecl constructor = new FunctionDecl(\"new\", decl.getSuffix(), false, true, false, false, decl.startToken);\n\t\t\tconstructor.setReturnType(getType());\n\t\t\tconstructor.arguments.addAll(decl.getArguments());\n\t\t\t\n\t\t\tVariableAccess thisTypeAccess = new VariableAccess(name, decl.startToken);\n\t\t\tthisTypeAccess.setRef(this);\n\t\t\tVariableAccess classAccess = new MemberAccess(thisTypeAccess, \"class\", decl.startToken);\n\t\t\tMemberCall allocCall = new MemberCall(classAccess, \"alloc\", \"\", decl.startToken);\n\t\t\tCast cast = new Cast(allocCall, getType(), decl.startToken);\n\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\"this\", cast, decl.startToken);\n\t\t\tconstructor.body.add(new Line(vdfe));\n\n\t\t\tVariableAccess thisAccess = new VariableAccess(vdfe, decl.startToken);\n\t\t\tthisAccess.setRef(vdfe);\n\t\t\t\n\t\t\tFunctionCall initCall = new FunctionCall(decl, decl.startToken);\n\t\t\tfor(Argument arg: constructor.getArguments()) {\n\t\t\t\tinitCall.getArguments().add(new VariableAccess(arg, decl.startToken));\n\t\t\t}\n\t\t\tconstructor.body.add(new Line(new MemberCall(thisAccess, initCall, decl.startToken)));\n\t\t\tconstructor.body.add(new Line(new ValuedReturn(thisAccess, decl.startToken)));\n\t\t\t\n\t\t\taddFunction(constructor);\n\t\t}\n\t\t\n\t\tsuper.addFunction(decl);\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tvariables.accept(visitor);\n\t\tfunctions.accept(visitor);\n\t\tinstanceType.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tVariableDecl variable = super.getVariable(name);\n\t\tif(variable != null) return variable;\n\t\tif(superRef != null) return superRef.getVariable(name);\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tsuper.getVariables(variables);\n\t\tif(superRef != null) superRef.getVariables(variables);\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn superName.isEmpty() || superRef != null;\n\t}\n\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal)\n\t\t\tthrows IOException {\n\t\t\n\t\tif(isResolved()) return Response.OK;\n\t\tif(!(superRef instanceof ClassDecl)) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Trying to extends a \"\n\t\t\t\t\t+superRef.getClass().getSimpleName()+\". You can only extend classes.\");\n\t\t}\n\t\treturn (superRef == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\t@Override\n\tpublic Map<String, GenericType> getGenericTypes() {\n\t\treturn Collections.unmodifiableMap(typeParams);\n\t}\n\t\n\tpublic void addGenericType(GenericType genType) {\n\t\ttypeParams.put(genType.name, genType);\n\t\tgenType.getArgument().setTypeDecl(this);\n\t\tvariables.add(0, genType.getArgument());\n\t}\n\n\tpublic ClassDecl getBaseClass(FunctionDecl decl) {\n\t\tif(superRef != null) {\n\t\t\tClassDecl base = ((ClassDecl) superRef).getBaseClass(decl);\n\t\t\tif(base != null) return base;\n\t\t}\n\t\tif(getFunction(decl.getName(), decl.getSuffix(), null) != null) return this;\n\t\treturn null;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ClassDecl extends TypeDecl implements MustBeResolved {\n\n\tprotected boolean isAbstract;\n\t\n\tprotected OocDocComment comment;\n\t\n\tprotected FunctionDecl defaultInit = null;\n\t\n\tpublic ClassDecl(String name, String superName, boolean isAbstract, Token startToken) {\n\t\tsuper(name, (superName.isEmpty() && !name.equals(\"Object\")) ? \"Object\" : superName, startToken);\n\t\tthis.isAbstract = isAbstract;\n\t\tthis.superRef = null;\n\t\t\n\t\taddFunction(new FunctionDecl(\"load\",     \"\", false, true,  false, false, startToken));\n\t\taddFunction(new FunctionDecl(\"defaults\", \"\", false, false, false, false, startToken));\n\t\taddFunction(new FunctionDecl(\"destroy\",  \"\", false, false, false, false, startToken));\n\t\tif(!isAbstract) {\n\t\t\tFunctionDecl init = new FunctionDecl(\"init\",     \"\", false, false, false, false, startToken);\n\t\t\taddFunction(init);\n\t\t\tdefaultInit = init;\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic ClassDecl getSuperRef() {\n\t\treturn (ClassDecl) superRef;\n\t}\n\n\tpublic boolean isObjectClass() {\n\t\treturn name.equals(\"Object\");\n\t}\n\t\n\tpublic boolean isClassClass() {\n\t\treturn name.equals(\"Class\");\n\t}\n\t\n\tpublic boolean isRootClass() {\n\t\treturn isObjectClass() || isClassClass();\n\t}\n\t\n\tpublic OocDocComment getComment() {\n\t\treturn comment;\n\t}\n\t\n\tpublic void setComment(OocDocComment comment) {\n\t\tthis.comment = comment;\n\t}\n\t\n\tpublic boolean isAbstract() {\n\t\treturn isAbstract;\n\t}\n\t\n\tpublic void setAbstract(boolean isAbstract) {\n\t\tthis.isAbstract = isAbstract;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\treturn getInstanceType();\n\t}\n\t\n\t@Override\n\tpublic void addFunction(FunctionDecl decl) {\n\t\t\n\t\tif(decl.getName().equals(\"init\")) {\n\t\t\tif(defaultInit != null) {\n\t\t\t\tFunctionDecl newFunc = getFunction(\"new\", \"\", null);\n\t\t\t\tfunctions.remove(defaultInit);\n\t\t\t\tfunctions.remove(newFunc);\n\t\t\t\tdefaultInit = null;\n\t\t\t}\n\t\t\t\n\t\t\tFunctionDecl constructor = new FunctionDecl(\"new\", decl.getSuffix(), false, true, false, false, decl.startToken);\n\t\t\tType retType = getType().clone();\n\t\t\tfor(GenericType genType: genericTypes.values()) {\n\t\t\t\tType e = new Type(genType.getName(), genType.startToken);\n\t\t\t\te.setRef(genType);\n\t\t\t\tretType.getGenericTypes().add(e);\n\t\t\t}\n\t\t\tconstructor.setReturnType(retType);\n\t\t\tconstructor.arguments.addAll(decl.getArguments());\n\t\t\t\n\t\t\tVariableAccess thisTypeAccess = new VariableAccess(name, decl.startToken);\n\t\t\tthisTypeAccess.setRef(this);\n\t\t\tVariableAccess classAccess = new MemberAccess(thisTypeAccess, \"class\", decl.startToken);\n\t\t\tMemberCall allocCall = new MemberCall(classAccess, \"alloc\", \"\", decl.startToken);\n\t\t\tCast cast = new Cast(allocCall, getType(), decl.startToken);\n\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\"this\", cast, decl.startToken);\n\t\t\tconstructor.body.add(new Line(vdfe));\n\n\t\t\tVariableAccess thisAccess = new VariableAccess(vdfe, decl.startToken);\n\t\t\tthisAccess.setRef(vdfe);\n\t\t\t\n\t\t\tFunctionCall initCall = new FunctionCall(decl, decl.startToken);\n\t\t\tfor(Argument arg: constructor.getArguments()) {\n\t\t\t\tinitCall.getArguments().add(new VariableAccess(arg, decl.startToken));\n\t\t\t}\n\t\t\tconstructor.body.add(new Line(new MemberCall(thisAccess, initCall, decl.startToken)));\n\t\t\tconstructor.body.add(new Line(new ValuedReturn(thisAccess, decl.startToken)));\n\t\t\t\n\t\t\taddFunction(constructor);\n\t\t}\n\t\t\n\t\tsuper.addFunction(decl);\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tvariables.accept(visitor);\n\t\tfunctions.accept(visitor);\n\t\tinstanceType.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tVariableDecl variable = super.getVariable(name);\n\t\tif(variable != null) return variable;\n\t\tif(superRef != null) return superRef.getVariable(name);\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tsuper.getVariables(variables);\n\t\tif(superRef != null) superRef.getVariables(variables);\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn superName.isEmpty() || superRef != null;\n\t}\n\n\t@Override\n\tpublic Response resolve(NodeList<Node> stack, Resolver res, boolean fatal)\n\t\t\tthrows IOException {\n\t\t\n\t\tif(isResolved()) return Response.OK;\n\t\tif(!(superRef instanceof ClassDecl)) {\n\t\t\tthrow new OocCompilationError(this, stack, \"Trying to extends a \"\n\t\t\t\t\t+superRef.getClass().getSimpleName()+\". You can only extend classes.\");\n\t\t}\n\t\treturn (superRef == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tpublic ClassDecl getBaseClass(FunctionDecl decl) {\n\t\tif(superRef != null) {\n\t\t\tClassDecl base = ((ClassDecl) superRef).getBaseClass(decl);\n\t\t\tif(base != null) return base;\n\t\t}\n\t\tif(getFunction(decl.getName(), decl.getSuffix(), null) != null) return this;\n\t\treturn null;\n\t}\n\t\n}\n","lineNo":84}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tif(impl != null) {\n\t\t\treturn impl.getReturnType();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\t//return impl != null;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) throws IOException {\n\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) resolveConstructorCall(stack, false);\n\t\t\telse if (name.equals(\"super\")) resolveConstructorCall(stack, true);\n\t\t\telse resolveRegular(stack, res, fatal);\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\tif(impl == null && fatal) {\n\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n\t\t\tString guess = guessCorrectName(stack, res);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn (impl == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack)\n\t\t\tthrows EOFException {\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, GenericType> params = impl.getGenericTypes();\n\t\tif(!params.isEmpty()) {\n\t\t\tfor(GenericType param: params.values()) {\n\t\t\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\t\t\tint i = 0;\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tArgument arg = iter.next();\n\t\t\t\t\tif(!arg.getType().getName().equals(param.getName())) continue;\n\t\t\t\t\tExpression expr = arguments.get(i);\n\t\t\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\t\t\tgenerateTempName(param.getName()+\"param\"), expr, startToken);\n\t\t\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\t\t\tstack.push(this);\n\t\t\t\t\t\tstack.push(arguments);\n\t\t\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\t\t\tstack.pop(arguments);\n\t\t\t\t\t\tstack.pop(this);\n\t\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tif(impl.getGenericTypes().size() > 0) {\n\t\t\tType returnType = impl.getReturnType();\n\t\t\tGenericType genType = impl.getGenericTypes().get(returnType.getName());\n\t\t\tif(genType != null) {\n\t\t\t\tNode parent = stack.peek();\n\t\t\t\tif(parent instanceof Assignment) {\n\t\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\t}\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\t\tunwrapFromVarDecl(stack, genType,  atom);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t\t// alright =)\n\t\t\t\t} else {\n\t\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\t\tthis, startToken);\n\t\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void unwrapFromVarDecl(final NodeList<Node> stack,\n\t\t\tGenericType genType, VariableDeclAtom atom) {\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\tdecl.setType(getRealType(genType));\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getArguments().iterator();\n\t\tif(impl.hasThis() && implArgs.hasNext()) implArgs.next();\n\t\t\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Type getRealType(GenericType genType) {\n\t\tint i = 0;\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\twhile(iter.hasNext()) {\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType().getName().equals(genType.getName())) {\n\t\t\t\tType type = arguments.get(i).getType();\n\t\t\t\tType argType = arg.getType();\n\t\t\t\tint level = argType.getPointerLevel();\n\t\t\t\tif(level > 0) {\n\t\t\t\t\ttype = type.copy();\n\t\t\t\t\ttype.setPointerLevel(type.getPointerLevel() - level);\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError, EOFException {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\")) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t}\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack,\n\t\t\tfinal Resolver res) throws IOException {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tsB.append(iter.next().getType());\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl func) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = func.getArguments();\n\t\tif(matchesArgs(func)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(func.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tif(impl != null) {\n\t\t\tType result = getRealType(impl.getReturnType());\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\t//return impl != null;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Response resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) throws IOException {\n\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) resolveConstructorCall(stack, false);\n\t\t\telse if (name.equals(\"super\")) resolveConstructorCall(stack, true);\n\t\t\telse resolveRegular(stack, res, fatal);\n\t\t}\n\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t\tResponse response = handleGenerics(stack);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\tif(impl == null && fatal) {\n\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n\t\t\tString guess = guessCorrectName(stack, res);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn (impl == null) ? Response.LOOP : Response.OK;\n\t\t\n\t}\n\n\tprotected Response handleGenerics(final NodeList<Node> stack)\n\t\t\tthrows EOFException {\n\t\t\n\t\tif(impl == null) return Response.LOOP;\n\t\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tLinkedHashMap<String, GenericType> generics = impl.getGenericTypes();\n\t\tif(!generics.isEmpty()) for(GenericType genType: generics.values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\tif(impl.getTypeDecl() != null) for(GenericType genType: impl.getTypeDecl().getGenericTypes().values()) {\n\t\t\tResponse response = checkGenType(stack, genType);\n\t\t\tif(response != Response.OK) return response;\n\t\t}\n\t\t\n\t\t// Turn any outer assigned access into a returnArg, unwrap if in varDecl.\n\t\tType returnType = impl.getReturnType();\n\t\tGenericType genType = impl.getGenericType(returnType.getName());\n\t\tif(genType != null) {\n\t\t\tNode parent = stack.peek();\n\t\t\tif(parent instanceof Assignment) {\n\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\tSystem.out.println(\"Replaced assignment!\");\n\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\treturn Response.RESTART;\n\t\t\t\t}\n\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\tunwrapFromVarDecl(stack, genType,  atom);\n\t\t\t\treturn Response.RESTART;\n\t\t\t} else if(parent instanceof Line) {\n\t\t\t\t// alright =)\n\t\t\t} else {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gcall\"),\n\t\t\t\t\t\tthis, startToken);\n\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\tType realType = getRealType(impl.getReturnType());\n\t\t\t\tvdfe.setType(realType);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Response.OK;\n\t\t\n\t}\n\n\tprivate Response checkGenType(final NodeList<Node> stack, GenericType genType)\n\t\t\tthrows EOFException {\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tint i = -1;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(!arg.getType().getName().equals(genType.getName())) continue;\n\t\t\tExpression expr = arguments.get(i);\n\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\tgenerateTempName(genType.getName()+\"param\"), expr, startToken);\n\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\tstack.push(this);\n\t\t\t\tstack.push(arguments);\n\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\tstack.pop(arguments);\n\t\t\t\tstack.pop(this);\n\t\t\t\treturn Response.RESTART;\n\t\t\t}\n\t\t}\n\t\treturn Response.OK;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void unwrapFromVarDecl(final NodeList<Node> stack,\n\t\t\tGenericType genType, VariableDeclAtom atom) throws OocCompilationError, EOFException {\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\tdecl.setType(getRealType(decl.getType(), genType));\n\t\tif(decl.getType().getRef() instanceof GenericType) {\n\t\t\tString endMsg = \"\";\n\t\t\tif(this instanceof MemberCall) {\n\t\t\t\tendMsg = \" - \"+((MemberCall) this).getExpression().getType()\n\t\t\t\t\t+\" should be type-specified, (with <Param1, Param2, ...>)\";\n\t\t\t} else {\n\t\t\t\tendMsg = \" - not enough type information.\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't guess return type of function \"\n\t\t\t\t\t+getProtoRepr()+endMsg);\n\t\t}\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\t\t\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getThisLessArgsIter();\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected Type getRealType(Type originType) {\n\t\tif(!(originType.getRef() instanceof GenericType)) {\n\t\t\tType result = originType.clone();\n\t\t\trealTypizeChildren(result);\n\t\t\treturn result;\n\t\t}\n\t\tGenericType genType = (GenericType) originType.getRef();\n\t\treturn getRealType(originType, genType);\n\t}\n\n\tprivate Type getRealType(Type originType, GenericType genType) {\n\t\tint i = -1;\n\t\tIterator<Argument> iter = impl.getThisLessArgsIter();\n\t\tType result = originType;\n\t\twhile(iter.hasNext()) {\n\t\t\ti++;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg.getType().getName().equals(genType.getName())) {\n\t\t\t\tType callArgType = arguments.get(i).getType();\n\t\t\t\tType argType = arg.getType();\n\t\t\t\tint level = argType.getPointerLevel();\n\t\t\t\tif(level > 0) {\n\t\t\t\t\tcallArgType = callArgType.clone();\n\t\t\t\t\tcallArgType.setPointerLevel(callArgType.getPointerLevel() - level);\n\t\t\t\t}\n\t\t\t\tresult = callArgType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trealTypizeChildren(result);\n\t\treturn result;\n\t}\n\n\tprotected void realTypizeChildren(Type result) {\n\t\tint j = -1;\n\t\tfor(Type subType: result.getGenericTypes()) {\n\t\t\tj++;\n\t\t\tresult.getGenericTypes().set(j, getRealType(subType));\n\t\t}\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError, EOFException {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\")) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t}\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack,\n\t\t\tfinal Resolver res) throws IOException {\n\t\tMemberCall memberCall = null;\n\t\tif(impl.isStatic()) {\n\t\t\tmemberCall = new MemberCall(new VariableAccess(impl.getTypeDecl().getType().getName(), startToken), this, startToken);\n\t\t} else {\n\t\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\t\tthisAccess.resolve(stack, res, true);\n\t\t\tmemberCall = new MemberCall(thisAccess, this, startToken);\n\t\t}\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tsB.append(iter.next().getType());\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl func) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = func.getArguments();\n\t\tif(matchesArgs(func)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size() == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(func.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\t\n}\n","lineNo":73}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.backend.Generator;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ArrayLiteral;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.Block;\nimport org.ooc.frontend.model.BoolLiteral;\nimport org.ooc.frontend.model.BuiltinType;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.CharLiteral;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Else;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FloatLiteral;\nimport org.ooc.frontend.model.FlowControl;\nimport org.ooc.frontend.model.Foreach;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.GenericType;\nimport org.ooc.frontend.model.If;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberArgument;\nimport org.ooc.frontend.model.MemberAssignArgument;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.NullLiteral;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.RegularArgument;\nimport org.ooc.frontend.model.Return;\nimport org.ooc.frontend.model.StringLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.ValuedReturn;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.While;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.parser.TypeArgument;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ubi.SourceReader;\n\npublic class CGenerator extends Generator implements Visitor {\n\n\tpublic final AwesomeWriter hw;\n\tpublic final AwesomeWriter cw;\n\tpublic AwesomeWriter current;\n\n\tpublic CGenerator(File outPath, Module module) throws IOException {\n\t\tsuper(outPath, module);\n\t\tString basePath = module.getFullName().replace('.', File.separatorChar);\n\t\tFile hFile = new File(outPath, basePath + \".h\");\n\t\thFile.getParentFile().mkdirs();\n\t\tthis.hw = new AwesomeWriter(new FileWriter(hFile));\n\t\tFile cFile = new File(outPath, basePath + \".c\");\n\t\tthis.cw = new AwesomeWriter(new FileWriter(cFile));\n\t\tthis.current = hw;\n\t}\n\n\t@Override\n\tpublic void generate() throws IOException {\n\t\tmodule.accept(this);\n\t\thw.close();\n\t\tcw.close();\n\t}\n\n\t@Override\n\tpublic void visit(Module module) throws IOException {\n\t\tModuleWriter.write(module, this);\n\t}\n\n\t@Override\n\tpublic void visit(Add add) throws IOException {\n\t\tadd.getLeft().accept(this);\n\t\tcurrent.app(\" + \");\n\t\tadd.getRight().accept(this);\t\t\n\t}\n\n\t@Override\n\tpublic void visit(Mul mul) throws IOException {\n\t\tmul.getLeft().accept(this);\n\t\tcurrent.app(\" * \");\n\t\tmul.getRight().accept(this);\t\t\n\t}\n\n\t@Override\n\tpublic void visit(Sub sub) throws IOException {\n\t\tsub.getLeft().accept(this);\n\t\tcurrent.app(\" - \");\n\t\tsub.getRight().accept(this);\t\t\n\t}\n\n\t@Override\n\tpublic void visit(Div div) throws IOException {\n\t\tdiv.getLeft().accept(this);\n\t\tcurrent.app(\" / \");\n\t\tdiv.getRight().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(Not not) throws IOException {\n\t\tcurrent.app('!');\n\t\tnot.getExpression().accept(this);\t\t\n\t}\n\t\n\t@Override\n\tpublic void visit(Mod mod) throws IOException {\n\t\tmod.getLeft().accept(this);\n\t\tcurrent.app(\" % \");\n\t\tmod.getRight().accept(this);\n\t}\n\t\n\t@Override\n\tpublic void visit(Compare compare) throws IOException {\n\t\tcompare.getLeft().accept(this);\n\t\tswitch(compare.getCompareType()) {\n\t\t\tcase GREATER: current.app(\" > \"); break;\n\t\t\tcase GREATER_OR_EQUAL: current.app(\" >= \"); break;\n\t\t\tcase LESSER: current.app(\" < \"); break;\n\t\t\tcase LESSER_OR_EQUAL: current.app(\" <= \"); break;\n\t\t\tcase EQUAL: current.app(\" == \"); break;\n\t\t\tcase NOT_EQUAL: current.app(\" != \"); break;\n\t\t}\n\t\tcompare.getRight().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(FunctionCall functionCall) throws IOException {\n\t\tCallWriter.write(functionCall, this);\n\t}\n\n\t@Override\n\tpublic void visit(MemberCall memberCall) throws IOException {\n\t\tCallWriter.writeMember(memberCall, this);\n\t}\n\n\t@Override\n\tpublic void visit(Parenthesis parenthesis) throws IOException {\n\t\tcurrent.app('(');\n\t\tparenthesis.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\t@Override\n\tpublic void visit(Assignment assignment) throws IOException {\n\t\tassignment.getLeft().accept(this);\n\t\tcurrent.app(' ').app(assignment.getSymbol()).app(' ');\n\t\tassignment.getRight().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(ValuedReturn return1) throws IOException {\n\t\tcurrent.app(\"return \");\n\t\treturn1.getExpression().accept(this);\n\t}\n\t\n\t@Override\n\tpublic void visit(Return return1) throws IOException {\n\t\tcurrent.app(\"return\");\n\t}\n\n\t@Override\n\tpublic void visit(NullLiteral nullLiteral) throws IOException {\n\t\tLiteralWriter.writeNull(this);\n\t}\n\n\t@Override\n\tpublic void visit(IntLiteral numberLiteral) throws IOException {\n\t\tLiteralWriter.writeInt(numberLiteral, this);\n\t}\n\t\n\t@Override\n\tpublic void visit(FloatLiteral floatLiteral) throws IOException {\n\t\tLiteralWriter.writeFloat(floatLiteral, this);\n\t}\n\n\t@Override\n\tpublic void visit(StringLiteral stringLiteral) throws IOException {\n\t\tLiteralWriter.writeString(stringLiteral, this);\n\t}\n\n\t@Override\n\tpublic void visit(RangeLiteral rangeLiteral) throws IOException {\n\t\tthrow new OocCompilationError(rangeLiteral, module,\n\t\t\t\t\"Using a range literal outside a foreach is not supported yet.\");\n\t}\n\n\t@Override\n\tpublic void visit(BoolLiteral boolLiteral) throws IOException {\n\t\tcurrent.app(boolLiteral.getValue() ? \"true\" : \"false\");\n\t}\n\n\t@Override\n\tpublic void visit(CharLiteral charLiteral) throws IOException {\n\t\tcurrent.app('\\'').app(SourceReader.spelled(charLiteral.getValue())).app('\\'');\t\t\n\t}\n\n\t@Override\n\tpublic void visit(Line line) throws IOException {\n\t\tcurrent.nl();\n\t\tif(line.getStatement() instanceof FunctionCall) CallWriter.noCast = (FunctionCall) line.getStatement();\n\t\tline.getStatement().accept(this);\n\t\tif(!(line.getStatement() instanceof ControlStatement)) {\n\t\t\tcurrent.app(';');\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visit(Include include) throws IOException {}\n\n\t@Override\n\tpublic void visit(If if1) throws IOException {\n\t\tControlStatementWriter.writeIf(if1, this);\n\t}\n\t\n\t@Override\n\tpublic void visit(Else else1) throws IOException {\n\t\tControlStatementWriter.writeElse(else1, this);\n\t}\n\n\t@Override\n\tpublic void visit(While while1) throws IOException {\n\t\tControlStatementWriter.writeWhile(while1, this);\n\t}\n\n\t@Override\n\tpublic void visit(Foreach foreach) throws IOException {\n\t\tControlStatementWriter.writeForeach(foreach, this);\n\t}\n\n\t@Override\n\tpublic void visit(MemberAccess memberAccess) throws IOException {\n\t\tAccessWriter.writeMember(memberAccess, this);\n\t}\n\t\n\t@Override\n\tpublic void visit(VariableAccess variableAccess) throws IOException {\n\t\tAccessWriter.writeVariable(variableAccess, true, this);\n\t}\n\n\t@Override\n\tpublic void visit(ArrayAccess arrayAccess) throws IOException {\n\t\tAccessWriter.writeArray(arrayAccess, this);\n\t}\n\n\t@Override\n\tpublic void visit(VariableDecl variableDecl) throws IOException {\n\t\tVariableDeclWriter.write(variableDecl, this);\n\t}\n\n\t@Override\n\tpublic void visit(FunctionDecl functionDecl) throws IOException {\n\t\tFunctionDeclWriter.write(functionDecl, this);\n\t}\n\n\t@Override \n\tpublic void visit(ClassDecl classDecl) throws IOException {\n\t\tClassDeclWriter.write(classDecl, this);\n\t}\n\t\n\t@Override\n\tpublic void visit(CoverDecl cover) throws IOException {\n\t\tCoverDeclWriter.write(cover, this);\n\t}\n\t\n\t@Override\n\tpublic void visit(TypeArgument typeArgument) throws IOException {\n\t\ttypeArgument.getType().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(RegularArgument regularArgument) throws IOException {\n\t\tType type = regularArgument.getType();\n\t\tif(type.isArray()) {\n\t\t\tcurrent.app(type.getName()).app(' ').app(regularArgument.getName());\n\t\t\tfor(int i = 0; i < type.getPointerLevel(); i++) {\n\t\t\t\tcurrent.app(\"[]\");\n\t\t\t}\n\t\t} else {\n\t\t\tif(type instanceof FuncType) {\n\t\t\t\tTypeWriter.writeFuncPointer((FunctionDecl) type.getRef(), regularArgument.getName(), this);\n\t\t\t} else {\n\t\t\t\tTypeWriter.writeSpaced(type, this);\n\t\t\t\tcurrent.app(regularArgument.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visit(MemberArgument memberArgument) throws IOException {}\n\n\t@Override\n\tpublic void visit(MemberAssignArgument memberArgument) throws IOException {}\n\n\t@Override\n\tpublic void visit(Type type) throws IOException {\n\t\tTypeWriter.write(type, this);\n\t}\n\n\t@Override\n\tpublic void visit(VarArg varArg) throws IOException {\n\t\tcurrent.app(\"...\");\n\t}\n\t\n\t@Override\n\tpublic void visit(NodeList<? extends Node> list) throws IOException {\n\t\tlist.acceptChildren(this);\n\t}\n\t\n\t@Override\n\tpublic void visit(Block block) throws IOException {\n\t\tcurrent.openBlock();\n\t\tblock.acceptChildren(this);\n\t\tcurrent.closeBlock();\n\t}\n\n\t@Override\n\tpublic void visit(BuiltinType builtinType) throws IOException {}\n\n\t@Override\n\tpublic void visit(VariableDeclAtom variableDeclAtom) throws IOException {}\n\t\n\t@Override\n\tpublic void visit(Cast cast) throws IOException {\n\t\tCastWriter.write(cast, this);\n\t}\n\n\t@Override\n\tpublic void visit(AddressOf addressOf) throws IOException {\n\t\tif(addressOf.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) addressOf.getExpression();\n\t\t\tif(varAcc.getRef().getType().getRef() instanceof GenericType) {\n\t\t\t\tAccessWriter.writeVariable(varAcc, false, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcurrent.app(\"&(\");\n\t\taddressOf.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\t@Override\n\tpublic void visit(Dereference dereference) throws IOException {\n\t\tcurrent.app(\"(*\");\n\t\tdereference.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\t@Override\n\tpublic void visit(OpDecl opDecl) throws IOException {\n\t\topDecl.getFunc().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(Import import1) throws IOException {}\n\t\n\t@Override\n\tpublic void visit(ArrayLiteral arrayLiteral) throws IOException {\n\t\tcurrent.app('{');\n\t\tIterator<Expression> iter = arrayLiteral.getElements().iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\titer.next().accept(this);\n\t\t\tif(iter.hasNext()) current.app(\", \");\n\t\t}\n\t\tcurrent.app('}');\n\t}\n\n\t@Override\n\tpublic void visit(Use use) throws IOException {}\n\n\t@Override\n\tpublic void visit(BinaryCombination binaryCombination) throws IOException {\n\t\tbinaryCombination.getLeft().accept(this);\n\t\tcurrent.app(' ').app(binaryCombination.getOpString()).app(' ');\n\t\tbinaryCombination.getRight().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(MultiMap<?, ?> list) throws IOException {}\n\n\t@Override\n\tpublic void visit(FlowControl flow) throws IOException {\n\t\tcurrent.app(flow.getKeyword()).app(\";\");\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.backend.Generator;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.Access;\nimport org.ooc.frontend.model.Add;\nimport org.ooc.frontend.model.AddressOf;\nimport org.ooc.frontend.model.ArrayAccess;\nimport org.ooc.frontend.model.ArrayLiteral;\nimport org.ooc.frontend.model.Assignment;\nimport org.ooc.frontend.model.BinaryCombination;\nimport org.ooc.frontend.model.Block;\nimport org.ooc.frontend.model.BoolLiteral;\nimport org.ooc.frontend.model.BuiltinType;\nimport org.ooc.frontend.model.Cast;\nimport org.ooc.frontend.model.CharLiteral;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Compare;\nimport org.ooc.frontend.model.ControlStatement;\nimport org.ooc.frontend.model.CoverDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Div;\nimport org.ooc.frontend.model.Else;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FloatLiteral;\nimport org.ooc.frontend.model.FlowControl;\nimport org.ooc.frontend.model.Foreach;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.GenericType;\nimport org.ooc.frontend.model.If;\nimport org.ooc.frontend.model.Import;\nimport org.ooc.frontend.model.Include;\nimport org.ooc.frontend.model.IntLiteral;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.MemberAccess;\nimport org.ooc.frontend.model.MemberArgument;\nimport org.ooc.frontend.model.MemberAssignArgument;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.Mod;\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Mul;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.Not;\nimport org.ooc.frontend.model.NullLiteral;\nimport org.ooc.frontend.model.OpDecl;\nimport org.ooc.frontend.model.Parenthesis;\nimport org.ooc.frontend.model.RangeLiteral;\nimport org.ooc.frontend.model.RegularArgument;\nimport org.ooc.frontend.model.Return;\nimport org.ooc.frontend.model.StringLiteral;\nimport org.ooc.frontend.model.Sub;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.Use;\nimport org.ooc.frontend.model.ValuedReturn;\nimport org.ooc.frontend.model.VarArg;\nimport org.ooc.frontend.model.VariableAccess;\nimport org.ooc.frontend.model.VariableDecl;\nimport org.ooc.frontend.model.While;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.parser.TypeArgument;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ubi.SourceReader;\n\npublic class CGenerator extends Generator implements Visitor {\n\n\tpublic final AwesomeWriter hw;\n\tpublic final AwesomeWriter cw;\n\tpublic AwesomeWriter current;\n\n\tpublic CGenerator(File outPath, Module module) throws IOException {\n\t\tsuper(outPath, module);\n\t\tString basePath = module.getFullName().replace('.', File.separatorChar);\n\t\tFile hFile = new File(outPath, basePath + \".h\");\n\t\thFile.getParentFile().mkdirs();\n\t\tthis.hw = new AwesomeWriter(new FileWriter(hFile));\n\t\tFile cFile = new File(outPath, basePath + \".c\");\n\t\tthis.cw = new AwesomeWriter(new FileWriter(cFile));\n\t\tthis.current = hw;\n\t}\n\n\t@Override\n\tpublic void generate() throws IOException {\n\t\tmodule.accept(this);\n\t\thw.close();\n\t\tcw.close();\n\t}\n\n\t@Override\n\tpublic void visit(Module module) throws IOException {\n\t\tModuleWriter.write(module, this);\n\t}\n\n\t@Override\n\tpublic void visit(Add add) throws IOException {\n\t\tadd.getLeft().accept(this);\n\t\tcurrent.app(\" + \");\n\t\tadd.getRight().accept(this);\t\t\n\t}\n\n\t@Override\n\tpublic void visit(Mul mul) throws IOException {\n\t\tmul.getLeft().accept(this);\n\t\tcurrent.app(\" * \");\n\t\tmul.getRight().accept(this);\t\t\n\t}\n\n\t@Override\n\tpublic void visit(Sub sub) throws IOException {\n\t\tsub.getLeft().accept(this);\n\t\tcurrent.app(\" - \");\n\t\tsub.getRight().accept(this);\t\t\n\t}\n\n\t@Override\n\tpublic void visit(Div div) throws IOException {\n\t\tdiv.getLeft().accept(this);\n\t\tcurrent.app(\" / \");\n\t\tdiv.getRight().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(Not not) throws IOException {\n\t\tcurrent.app('!');\n\t\tnot.getExpression().accept(this);\t\t\n\t}\n\t\n\t@Override\n\tpublic void visit(Mod mod) throws IOException {\n\t\tmod.getLeft().accept(this);\n\t\tcurrent.app(\" % \");\n\t\tmod.getRight().accept(this);\n\t}\n\t\n\t@Override\n\tpublic void visit(Compare compare) throws IOException {\n\t\tcompare.getLeft().accept(this);\n\t\tswitch(compare.getCompareType()) {\n\t\t\tcase GREATER: current.app(\" > \"); break;\n\t\t\tcase GREATER_OR_EQUAL: current.app(\" >= \"); break;\n\t\t\tcase LESSER: current.app(\" < \"); break;\n\t\t\tcase LESSER_OR_EQUAL: current.app(\" <= \"); break;\n\t\t\tcase EQUAL: current.app(\" == \"); break;\n\t\t\tcase NOT_EQUAL: current.app(\" != \"); break;\n\t\t}\n\t\tcompare.getRight().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(FunctionCall functionCall) throws IOException {\n\t\tCallWriter.write(functionCall, this);\n\t}\n\n\t@Override\n\tpublic void visit(MemberCall memberCall) throws IOException {\n\t\tCallWriter.writeMember(memberCall, this);\n\t}\n\n\t@Override\n\tpublic void visit(Parenthesis parenthesis) throws IOException {\n\t\tcurrent.app('(');\n\t\tparenthesis.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\t@Override\n\tpublic void visit(Assignment assignment) throws IOException {\n\t\tExpression left = assignment.getLeft();\n\t\tif(left instanceof Access) {\n\t\t\tAccessWriter.write((Access) left, false, this);\n\t\t} else {\n\t\t\tleft.accept(this);\n\t\t}\n\t\tcurrent.app(' ').app(assignment.getSymbol()).app(' ');\n\t\tassignment.getRight().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(ValuedReturn return1) throws IOException {\n\t\tcurrent.app(\"return \");\n\t\treturn1.getExpression().accept(this);\n\t}\n\t\n\t@Override\n\tpublic void visit(Return return1) throws IOException {\n\t\tcurrent.app(\"return\");\n\t}\n\n\t@Override\n\tpublic void visit(NullLiteral nullLiteral) throws IOException {\n\t\tLiteralWriter.writeNull(this);\n\t}\n\n\t@Override\n\tpublic void visit(IntLiteral numberLiteral) throws IOException {\n\t\tLiteralWriter.writeInt(numberLiteral, this);\n\t}\n\t\n\t@Override\n\tpublic void visit(FloatLiteral floatLiteral) throws IOException {\n\t\tLiteralWriter.writeFloat(floatLiteral, this);\n\t}\n\n\t@Override\n\tpublic void visit(StringLiteral stringLiteral) throws IOException {\n\t\tLiteralWriter.writeString(stringLiteral, this);\n\t}\n\n\t@Override\n\tpublic void visit(RangeLiteral rangeLiteral) throws IOException {\n\t\tthrow new OocCompilationError(rangeLiteral, module,\n\t\t\t\t\"Using a range literal outside a foreach is not supported yet.\");\n\t}\n\n\t@Override\n\tpublic void visit(BoolLiteral boolLiteral) throws IOException {\n\t\tcurrent.app(boolLiteral.getValue() ? \"true\" : \"false\");\n\t}\n\n\t@Override\n\tpublic void visit(CharLiteral charLiteral) throws IOException {\n\t\tcurrent.app('\\'').app(SourceReader.spelled(charLiteral.getValue())).app('\\'');\t\t\n\t}\n\n\t@Override\n\tpublic void visit(Line line) throws IOException {\n\t\tcurrent.nl();\n\t\tif(line.getStatement() instanceof FunctionCall) CallWriter.noCast = (FunctionCall) line.getStatement();\n\t\tline.getStatement().accept(this);\n\t\tif(!(line.getStatement() instanceof ControlStatement)) {\n\t\t\tcurrent.app(';');\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visit(Include include) throws IOException {}\n\n\t@Override\n\tpublic void visit(If if1) throws IOException {\n\t\tControlStatementWriter.writeIf(if1, this);\n\t}\n\t\n\t@Override\n\tpublic void visit(Else else1) throws IOException {\n\t\tControlStatementWriter.writeElse(else1, this);\n\t}\n\n\t@Override\n\tpublic void visit(While while1) throws IOException {\n\t\tControlStatementWriter.writeWhile(while1, this);\n\t}\n\n\t@Override\n\tpublic void visit(Foreach foreach) throws IOException {\n\t\tControlStatementWriter.writeForeach(foreach, this);\n\t}\n\n\t@Override\n\tpublic void visit(MemberAccess memberAccess) throws IOException {\n\t\tAccessWriter.writeMember(memberAccess, this);\n\t}\n\t\n\t@Override\n\tpublic void visit(VariableAccess variableAccess) throws IOException {\n\t\tAccessWriter.writeVariable(variableAccess, true, this);\n\t}\n\n\t@Override\n\tpublic void visit(ArrayAccess arrayAccess) throws IOException {\n\t\tAccessWriter.writeArray(arrayAccess, this);\n\t}\n\n\t@Override\n\tpublic void visit(VariableDecl variableDecl) throws IOException {\n\t\tVariableDeclWriter.write(variableDecl, this);\n\t}\n\n\t@Override\n\tpublic void visit(FunctionDecl functionDecl) throws IOException {\n\t\tFunctionDeclWriter.write(functionDecl, this);\n\t}\n\n\t@Override \n\tpublic void visit(ClassDecl classDecl) throws IOException {\n\t\tClassDeclWriter.write(classDecl, this);\n\t}\n\t\n\t@Override\n\tpublic void visit(CoverDecl cover) throws IOException {\n\t\tCoverDeclWriter.write(cover, this);\n\t}\n\t\n\t@Override\n\tpublic void visit(TypeArgument typeArgument) throws IOException {\n\t\ttypeArgument.getType().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(RegularArgument regularArgument) throws IOException {\n\t\tType type = regularArgument.getType();\n\t\tif(type.isArray()) {\n\t\t\tcurrent.app(type.getName()).app(' ').app(regularArgument.getName());\n\t\t\tfor(int i = 0; i < type.getPointerLevel(); i++) {\n\t\t\t\tcurrent.app(\"[]\");\n\t\t\t}\n\t\t} else {\n\t\t\tif(type instanceof FuncType) {\n\t\t\t\tTypeWriter.writeFuncPointer((FunctionDecl) type.getRef(), regularArgument.getName(), this);\n\t\t\t} else {\n\t\t\t\tTypeWriter.writeSpaced(type, this);\n\t\t\t\tcurrent.app(regularArgument.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visit(MemberArgument memberArgument) throws IOException {}\n\n\t@Override\n\tpublic void visit(MemberAssignArgument memberArgument) throws IOException {}\n\n\t@Override\n\tpublic void visit(Type type) throws IOException {\n\t\tTypeWriter.write(type, this);\n\t}\n\n\t@Override\n\tpublic void visit(VarArg varArg) throws IOException {\n\t\tcurrent.app(\"...\");\n\t}\n\t\n\t@Override\n\tpublic void visit(NodeList<? extends Node> list) throws IOException {\n\t\tlist.acceptChildren(this);\n\t}\n\t\n\t@Override\n\tpublic void visit(Block block) throws IOException {\n\t\tcurrent.openBlock();\n\t\tblock.acceptChildren(this);\n\t\tcurrent.closeBlock();\n\t}\n\n\t@Override\n\tpublic void visit(BuiltinType builtinType) throws IOException {}\n\n\t@Override\n\tpublic void visit(VariableDeclAtom variableDeclAtom) throws IOException {}\n\t\n\t@Override\n\tpublic void visit(Cast cast) throws IOException {\n\t\tCastWriter.write(cast, this);\n\t}\n\n\t@Override\n\tpublic void visit(AddressOf addressOf) throws IOException {\n\t\tif(addressOf.getExpression() instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) addressOf.getExpression();\n\t\t\tif(varAcc.getRef().getType().getRef() instanceof GenericType) {\n\t\t\t\tAccessWriter.writeVariable(varAcc, false, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcurrent.app(\"&(\");\n\t\taddressOf.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\t@Override\n\tpublic void visit(Dereference dereference) throws IOException {\n\t\tcurrent.app(\"(*\");\n\t\tdereference.getExpression().accept(this);\n\t\tcurrent.app(')');\n\t}\n\n\t@Override\n\tpublic void visit(OpDecl opDecl) throws IOException {\n\t\topDecl.getFunc().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(Import import1) throws IOException {}\n\t\n\t@Override\n\tpublic void visit(ArrayLiteral arrayLiteral) throws IOException {\n\t\tcurrent.app('{');\n\t\tIterator<Expression> iter = arrayLiteral.getElements().iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\titer.next().accept(this);\n\t\t\tif(iter.hasNext()) current.app(\", \");\n\t\t}\n\t\tcurrent.app('}');\n\t}\n\n\t@Override\n\tpublic void visit(Use use) throws IOException {}\n\n\t@Override\n\tpublic void visit(BinaryCombination binaryCombination) throws IOException {\n\t\tbinaryCombination.getLeft().accept(this);\n\t\tcurrent.app(' ').app(binaryCombination.getOpString()).app(' ');\n\t\tbinaryCombination.getRight().accept(this);\n\t}\n\n\t@Override\n\tpublic void visit(MultiMap<?, ?> list) throws IOException {}\n\n\t@Override\n\tpublic void visit(FlowControl flow) throws IOException {\n\t\tcurrent.app(flow.getKeyword()).app(\";\");\n\t}\n\n}\n","lineNo":176}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.Argument;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.GenericType;\n\npublic class FunctionDeclWriter {\n\n\tpublic static void write(FunctionDecl functionDecl, CGenerator cgen) throws IOException {\n\t\t\n\t\tif(functionDecl.isProto()) {\n\t\t\tcgen.current = cgen.hw;\n\t\t\tcgen.current.nl().app(\"extern \");\n\t\t\twriteFuncPrototype(functionDecl, cgen);\n\t\t\tcgen.current.app(';');\n\t\t} else if(!functionDecl.isExtern() && !functionDecl.isAbstract()) {\n\t\t\tcgen.current = cgen.hw;\n\t\t\tcgen.current.nl();\n\t\t\twriteFuncPrototype(functionDecl, cgen);\n\t\t\tcgen.current.app(';');\n\t\t\n\t\t\tcgen.current = cgen.cw;\n\t\t\twriteFuncPrototype(functionDecl, cgen);\n\t\t\tcgen.current.openBlock();\n\t\t\t\n\t\t\tif(functionDecl.isEntryPoint()) {\n\t\t\t\tcgen.current.nl().app(\"GC_INIT();\");\n\t\t\t\tcgen.current.nl().app(cgen.module.getLoadFunc().getName()).app(\"();\");\n\t\t\t}\n\t\t\t\n\t\t\tfor(Line line: functionDecl.getBody()) {\n\t\t\t\tline.accept(cgen);\n\t\t\t}\n\t\t\tcgen.current.closeSpacedBlock();\n\t\t}\n\t\t\n\t}\n\n\tpublic static void writeFuncPrototype(FunctionDecl functionDecl, CGenerator cgen) throws IOException {\n\t\t\n\t\tif(functionDecl.isInline()) cgen.current.append(\"inline \");\n\t\t\t\n\t\tType returnType = functionDecl.getReturnType();\n\t\tif (returnType.getRef() instanceof GenericType) {\n\t\t\tcgen.current.append(\"void \");\n\t\t} else if(returnType instanceof FuncType) {\n\t\t\tTypeWriter.writeFuncPointerStart((FunctionDecl) returnType.getRef(), cgen);\n\t\t} else {\n\t\t\tTypeWriter.writeSpaced(returnType, cgen);\n\t\t}\n\t\tfunctionDecl.writeFullName(cgen.current);\n\t\t\n\t\twriteFuncArgs(functionDecl, cgen);\n\t\t\n\t\tif(returnType instanceof FuncType) {\n\t\t\tTypeWriter.writeFuncPointerEnd((FunctionDecl) returnType.getRef(), cgen);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void writeFuncArgs(FunctionDecl functionDecl,\n\t\t\tCGenerator cgen) throws IOException {\n\t\tcgen.current.app('(');\n\t\tboolean isFirst = true;\n\t\tType returnType = functionDecl.getReturnType();\n\t\tif(returnType.getRef() instanceof GenericType) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tfunctionDecl.getReturnArg().accept(cgen);\n\t\t}\n\t\tfor(GenericType param: functionDecl.getGenericTypes().values()) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tparam.getArgument().accept(cgen);\n\t\t}\n\t\t\n\t\tfor(Argument arg: functionDecl.getArguments()) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\targ.accept(cgen);\n\t\t}\n\t\tcgen.current.app(')');\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.model.Argument;\nimport org.ooc.frontend.model.FuncType;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.GenericType;\nimport org.ooc.frontend.model.Line;\nimport org.ooc.frontend.model.Type;\nimport org.ooc.frontend.model.TypeDecl;\n\npublic class FunctionDeclWriter {\n\n\tpublic static void write(FunctionDecl functionDecl, CGenerator cgen) throws IOException {\n\t\t\n\t\tif(functionDecl.isProto()) {\n\t\t\tcgen.current = cgen.hw;\n\t\t\tcgen.current.nl().app(\"extern \");\n\t\t\twriteFuncPrototype(functionDecl, cgen);\n\t\t\tcgen.current.app(';');\n\t\t} else if(!functionDecl.isExtern() && !functionDecl.isAbstract()) {\n\t\t\tcgen.current = cgen.hw;\n\t\t\tcgen.current.nl();\n\t\t\twriteFuncPrototype(functionDecl, cgen);\n\t\t\tcgen.current.app(';');\n\t\t\n\t\t\tcgen.current = cgen.cw;\n\t\t\twriteFuncPrototype(functionDecl, cgen);\n\t\t\tcgen.current.openBlock();\n\t\t\t\n\t\t\tif(functionDecl.isEntryPoint()) {\n\t\t\t\t// FIXME what if we want no gc?\n\t\t\t\tcgen.current.nl().app(\"GC_INIT();\");\n\t\t\t\tcgen.current.nl().app(cgen.module.getLoadFunc().getName()).app(\"();\");\n\t\t\t}\n\t\t\t\n\t\t\tfor(Line line: functionDecl.getBody()) {\n\t\t\t\tline.accept(cgen);\n\t\t\t}\n\t\t\tcgen.current.closeSpacedBlock();\n\t\t}\n\t\t\n\t}\n\n\tpublic static void writeFuncPrototype(FunctionDecl functionDecl, CGenerator cgen) throws IOException {\n\t\twriteFuncPrototype(functionDecl, cgen, null);\n\t}\n\t\n\t\n\tpublic static void writeFuncPrototype(FunctionDecl functionDecl, CGenerator cgen, String additionalSuffix) throws IOException {\n\t\t\n\t\tif(functionDecl.isInline()) cgen.current.append(\"inline \");\n\t\t\t\n\t\tType returnType = functionDecl.getReturnType();\n\t\tif (returnType.getRef() instanceof GenericType) {\n\t\t\tcgen.current.append(\"void \");\n\t\t} else if(returnType instanceof FuncType) {\n\t\t\tTypeWriter.writeFuncPointerStart((FunctionDecl) returnType.getRef(), cgen);\n\t\t} else {\n\t\t\tTypeWriter.writeSpaced(returnType, cgen);\n\t\t}\n\t\tfunctionDecl.writeFullName(cgen.current);\n\t\tif(additionalSuffix != null) cgen.current.append(additionalSuffix);\n\t\t\n\t\twriteFuncArgs(functionDecl, cgen);\n\t\t\n\t\tif(returnType instanceof FuncType) {\n\t\t\tTypeWriter.writeFuncPointerEnd((FunctionDecl) returnType.getRef(), cgen);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void writeFuncArgs(FunctionDecl functionDecl, CGenerator cgen) throws IOException {\n\t\twriteFuncArgs(functionDecl, ArgsWriteMode.FULL, null, cgen);\n\t}\n\t\n\tpublic static enum ArgsWriteMode {\n\t\tFULL,\n\t\tNAMES_ONLY,\n\t\tTYPES_ONLY\n\t}\n\t\n\tpublic static void writeFuncArgs(FunctionDecl functionDecl, ArgsWriteMode mode,\n\t\t\tTypeDecl baseType, CGenerator cgen) throws IOException {\n\t\t\n\t\tcgen.current.app('(');\n\t\tboolean isFirst = true;\n\t\t\n\t\tIterator<Argument> iter = functionDecl.getArguments().iterator();\n\t\tif(functionDecl.hasThis()) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tArgument arg = iter.next();\n\t\t\tif(mode == ArgsWriteMode.NAMES_ONLY) {\n\t\t\t\tif(baseType != null) {\n\t\t\t\t\tcgen.current.app(\"(\");\n\t\t\t\t\tbaseType.getType().accept(cgen);\n\t\t\t\t\tcgen.current.app(\") \");\n\t\t\t\t}\n\t\t\t\tcgen.current.app(arg.getName());\n\t\t\t} else if(mode == ArgsWriteMode.TYPES_ONLY) {\n\t\t\t\targ.getType().accept(cgen);\n\t\t\t} else {\n\t\t\t\targ.accept(cgen);\n\t\t\t}\n\t\t}\n\t\t\n\t\tType returnType = functionDecl.getReturnType();\n\t\tif(returnType.getRef() instanceof GenericType) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tif(mode == ArgsWriteMode.NAMES_ONLY) {\n\t\t\t\tcgen.current.app(functionDecl.getReturnArg().getName());\n\t\t\t} else if(mode == ArgsWriteMode.TYPES_ONLY) {\n\t\t\t\tfunctionDecl.getReturnArg().getType().accept(cgen);\n\t\t\t} else {\n\t\t\t\tfunctionDecl.getReturnArg().accept(cgen);\n\t\t\t}\n\t\t}\n\t\tfor(GenericType param: functionDecl.getGenericTypes().values()) {\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tif(mode == ArgsWriteMode.NAMES_ONLY) {\n\t\t\t\tcgen.current.app(param.getArgument().getName());\n\t\t\t} else if(mode == ArgsWriteMode.TYPES_ONLY) {\n\t\t\t\tparam.getArgument().getType().accept(cgen);\n\t\t\t} else {\n\t\t\t\tparam.getArgument().accept(cgen);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(iter.hasNext()) {\n\t\t\tArgument arg = iter.next();\n\t\t\tif(!isFirst) cgen.current.app(\", \");\n\t\t\tisFirst = false;\n\t\t\tif(mode == ArgsWriteMode.NAMES_ONLY) {\n\t\t\t\tcgen.current.app(arg.getName());\n\t\t\t} else if(mode == ArgsWriteMode.TYPES_ONLY) {\n\t\t\t\targ.getType().accept(cgen);\n\t\t\t} else {\n\t\t\t\targ.accept(cgen);\n\t\t\t}\n\t\t}\n\t\tcgen.current.app(')');\n\t}\n\t\n}\n","lineNo":56}
{"Smelly Sample":"package org.ooc.middle.hobgoblins;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.middle.Hobgoblin;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.walkers.Opportunist;\nimport org.ooc.middle.walkers.SketchyNosy;\n\n\npublic class Resolver implements Hobgoblin {\n\n\tprotected static final int MAX = 2;\n\tboolean running;\n\tboolean fatal = false;\n\t\n\tpublic BuildParams params;\n\tpublic Module module;\n\t\n\t@Override\n\tpublic void process(Module module, BuildParams params) throws IOException {\n\t\t\n\t\tthis.module = module;\n\t\tthis.params = params;\n\t\t\n\t\tSketchyNosy nosy = SketchyNosy.get(new Opportunist<Node>() {\n\t\t\t@Override\n\t\t\tpublic boolean take(Node node, NodeList<Node> stack) throws IOException {\n\t\t\t\tif(node instanceof MustBeResolved) {\n\t\t\t\t\tMustBeResolved must = (MustBeResolved) node;\n\t\t\t\t\tif(!must.isResolved() && must.resolve(stack, Resolver.this, fatal)) {\n\t\t\t\t\t\trunning = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\t\n\t\tint count = 0;\n\t\trunning = true;\n\t\twhile(running) {\n\t\t\tif(count > MAX) {\n\t\t\t\tfatal = true;\n\t\t\t\tnosy.start().visit(module);\n\t\t\t\tthrow new OocCompilationError(module, module, \"Resolver is running in circles. Abandoning.\");\n\t\t\t}\n\t\t\trunning = false;\n\t\t\tnosy.start().visit(module);\n\t\t\tcount++;\n\t\t}\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.middle.hobgoblins;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.model.Module;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.interfaces.MustBeResolved.Response;\nimport org.ooc.frontend.parser.BuildParams;\nimport org.ooc.middle.Hobgoblin;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.walkers.Opportunist;\nimport org.ooc.middle.walkers.SketchyNosy;\n\n\npublic class Resolver implements Hobgoblin {\n\n\tprotected static final int MAX = 1, SAFE_MAX = 1024;\n\tboolean running = false;\n\tboolean restarted = false;\n\tboolean fatal = false;\n\t\n\tpublic BuildParams params;\n\tpublic Module module;\n\t\n\t@Override\n\tpublic void process(Module module, BuildParams params) throws IOException {\n\t\t\n\t\tthis.module = module;\n\t\tthis.params = params;\n\t\t\n\t\tSketchyNosy nosy = SketchyNosy.get(new Opportunist<Node>() {\n\t\t\t@Override\n\t\t\tpublic boolean take(Node node, NodeList<Node> stack) throws IOException {\n\t\t\t\tif(node instanceof MustBeResolved) {\n\t\t\t\t\tMustBeResolved must = (MustBeResolved) node;\n\t\t\t\t\tif(!must.isResolved()) {\n\t\t\t\t\t\tResponse res = must.resolve(stack, Resolver.this, fatal);\n\t\t\t\t\t\tif(res == Response.LOOP) {\n\t\t\t\t\t\t\trunning = true;\n\t\t\t\t\t\t} else if(res == Response.RESTART) {\n\t\t\t\t\t\t\trestarted = true;\n\t\t\t\t\t\t\trunning = true;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\t\n\t\tint count = 0, safeCount = 0;\n\t\trunning = true;\n\t\twhile(running) {\n\t\t\tif(count > MAX || safeCount > SAFE_MAX) {\n\t\t\t\tfatal = true;\n\t\t\t\tnosy.start().visit(module);\n\t\t\t\tthrow new OocCompilationError(module, module, \"Resolver is running in circles. Abandoning. (count = \"\n\t\t\t\t\t\t+count+\"/\"+MAX+\", safeCount = \"+safeCount+\"/\"+SAFE_MAX+\")\");\n\t\t\t}\n\t\t\trunning = false;\n\t\t\tnosy.start().visit(module);\n\t\t\tsafeCount++;\n\t\t\tif(restarted) {\n\t\t\t\trestarted = false;\n\t\t\t} else {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n","lineNo":39}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tif(impl != null) {\n\t\t\treturn impl.getReturnType();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn impl != null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic boolean resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) throws IOException {\n\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) resolveConstructorCall(stack, false);\n\t\t\telse if (name.equals(\"super\")) resolveConstructorCall(stack, true);\n\t\t\telse resolveRegular(stack, res, fatal);\n\t\t}\n\t\n\t\t// If one generic type is not a VariableAccess, turn it into a VDFE and unwrap it\n\t\tif(impl != null) {\n\t\t\tLinkedHashMap<String, GenericType> params = impl.getGenericTypes();\n\t\t\tif(!params.isEmpty()) {\n\t\t\t\tfor(GenericType param: params.values()) {\n\t\t\t\t\tNodeList<Argument> implArgs = impl.getArguments();\n\t\t\t\t\tfor(int i = 0; i < implArgs.size(); i++) {\n\t\t\t\t\t\tArgument arg = implArgs.get(i);\n\t\t\t\t\t\tif(!arg.getType().getName().equals(param.getName())) continue;\n\t\t\t\t\t\tExpression expr = arguments.get(i);\n\t\t\t\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\t\t\t\tgenerateTempName(param.getName()+\"param\"), expr, startToken);\n\t\t\t\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\t\t\t\tstack.push(arguments);\n\t\t\t\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\t\t\t\tstack.pop(arguments);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assign expression into a memcpy\n\t\tif(impl != null && impl.getGenericTypes().size() > 0) {\n\t\t\tType returnType = impl.getReturnType();\n\t\t\tGenericType genType = impl.getGenericTypes().get(returnType.getName());\n\t\t\tif(genType != null) {\n\t\t\t\tNode parent = stack.peek();\n\t\t\t\tif(parent instanceof Assignment) {\n\t\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\t}\n\t\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\t\t\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\t\t\t\tparent.replace(this, null);\n\t\t\t\t\t\n\t\t\t\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\t\t\t\tLine line = (Line) stack.get(lineIndex);\n\t\t\t\t\t\n\t\t\t\t\tif(decl instanceof VariableDeclFromExpr) {\n\t\t\t\t\t\tVariableDecl newDecl = new VariableDecl(getRealType(genType), false, startToken);\n\t\t\t\t\t\tnewDecl.getAtoms().add(atom);\n\t\t\t\t\t\tstack.get(varDeclIndex - 1).replace(decl, newDecl);\n\t\t\t\t\t\tdecl = newDecl;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\t\t\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\t\t\t\tvarAcc.setRef(decl);\n\t\t\t\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\t\t\t\tlist.addAfter(line, new Line(this));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t}\n\t\t\n\t\tif(impl == null && fatal) {\n\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n\t\t\tString guess = guessCorrectName(stack, res);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn impl == null;\n\t\t\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getArguments().iterator();\n\t\tif(impl.hasThis() && implArgs.hasNext()) implArgs.next();\n\t\t\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Type getRealType(GenericType genType) {\n\t\tint i = 0;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(arg.getType().getName().equals(genType.getName())) {\n\t\t\t\treturn arguments.get(i).getType();\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError, EOFException {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\")) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t}\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack,\n\t\t\tfinal Resolver res) throws IOException {\n\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\tthisAccess.resolve(stack, res, true);\n\t\tMemberCall memberCall = new MemberCall(new VariableAccess(\"this\", startToken), this, startToken);\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tsB.append(iter.next().getType());\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName()+\": \"+getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl func) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = func.getArguments();\n\t\tif(matchesArgs(func)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(func.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class FunctionCall extends Access implements MustBeResolved {\n\n\tprotected String name;\n\tprotected String suffix;\n\tprotected final NodeList<Expression> arguments;\n\tprotected FunctionDecl impl;\n\tprotected AddressOf returnArg;\n\t\n\tpublic FunctionCall(String name, String suffix, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.name = name;\n\t\tthis.suffix = suffix;\n\t\tthis.arguments = new NodeList<Expression>(startToken);\n\t\tthis.impl = null;\n\t\tthis.returnArg = null;\n\t}\n\t\n\tpublic FunctionCall(FunctionDecl func, Token startToken) {\n\t\tthis(func.getName(), func.getSuffix(), startToken);\n\t\tsetImpl(func);\n\t}\n\n\tpublic void setImpl(FunctionDecl impl) {\n\t\tthis.impl = impl;\n\t}\n\t\n\tpublic FunctionDecl getImpl() {\n\t\treturn impl;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic NodeList<Expression> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic AddressOf getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tif(impl != null) {\n\t\t\treturn impl.getReturnType();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\targuments.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tif(oldie == impl) {\n\t\t\timpl = (FunctionDecl) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn impl != null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic boolean resolve(final NodeList<Node> stack, final Resolver res, final boolean fatal) throws IOException {\n\n\t\tif(impl == null) {\n\t\t\tif (name.equals(\"this\")) resolveConstructorCall(stack, false);\n\t\t\telse if (name.equals(\"super\")) resolveConstructorCall(stack, true);\n\t\t\telse resolveRegular(stack, res, fatal);\n\t\t}\n\t\n\t\t// If one of the arguments which type is generic is not a VariableAccess\n\t\t// turn it into a VDFE and unwrap it\n\t\tif(impl != null) {\n\t\t\tLinkedHashMap<String, GenericType> params = impl.getGenericTypes();\n\t\t\tif(!params.isEmpty()) {\n\t\t\t\tfor(GenericType param: params.values()) {\n\t\t\t\t\tNodeList<Argument> implArgs = impl.getArguments();\n\t\t\t\t\tfor(int i = 0; i < implArgs.size(); i++) {\n\t\t\t\t\t\tArgument arg = implArgs.get(i);\n\t\t\t\t\t\tif(!arg.getType().getName().equals(param.getName())) continue;\n\t\t\t\t\t\tExpression expr = arguments.get(i);\n\t\t\t\t\t\tif(!(expr instanceof VariableAccess)) {\n\t\t\t\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(\n\t\t\t\t\t\t\t\t\tgenerateTempName(param.getName()+\"param\"), expr, startToken);\n\t\t\t\t\t\t\targuments.replace(expr, vdfe);\n\t\t\t\t\t\t\tstack.push(arguments);\n\t\t\t\t\t\t\tvdfe.unwrapToVarAcc(stack);\n\t\t\t\t\t\t\tstack.pop(arguments);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Turn any outer assign expression into a memcpy\n\t\tif(impl != null && impl.getGenericTypes().size() > 0) {\n\t\t\tType returnType = impl.getReturnType();\n\t\t\tGenericType genType = impl.getGenericTypes().get(returnType.getName());\n\t\t\tif(genType != null) {\n\t\t\t\tNode parent = stack.peek();\n\t\t\t\tif(parent instanceof Assignment) {\n\t\t\t\t\tAssignment ass = (Assignment) parent;\n\t\t\t\t\tif(ass.getLeft() instanceof Access) {\n\t\t\t\t\t\treturnArg = new AddressOf(ass.getLeft(), startToken);\n\t\t\t\t\t\tstack.get(stack.size() - 2).replace(ass, this);\n\t\t\t\t\t}\n\t\t\t\t} else if(parent instanceof VariableDeclAtom) {\n\t\t\t\t\tVariableDeclAtom atom = (VariableDeclAtom) parent;\n\t\t\t\t\tunwrapFromVarDecl(stack, genType,  atom);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"Parent is a \"+parent);\n\t\t\t\t\tVariableDeclFromExpr vdfe = new VariableDeclFromExpr(generateTempName(\"gencall\"),\n\t\t\t\t\t\t\tthis, startToken);\n\t\t\t\t\tparent.replace(this, vdfe);\n\t\t\t\t\tvdfe.unwrap(stack);\n\t\t\t\t\tstack.push(vdfe);\n\t\t\t\t\tstack.push(vdfe.atoms);\n\t\t\t\t\tVariableDeclAtom atom = vdfe.atoms.get(0);\n\t\t\t\t\tstack.push(atom);\n\t\t\t\t\tunwrapFromVarDecl(stack, genType, atom);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl != null) {\n\t\t\tautocast();\n\t\t}\n\t\t\n\t\tif(impl == null && fatal) {\n\t\t\tString message = \"Couldn't resolve call to function \"+name+getArgsRepr()+\".\";\n\t\t\tString guess = guessCorrectName(stack, res);\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn impl == null;\n\t\t\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void unwrapFromVarDecl(final NodeList<Node> stack,\n\t\t\tGenericType genType, VariableDeclAtom atom) {\n\t\tint varDeclIndex = stack.find(VariableDecl.class);\n\t\tVariableDecl decl = (VariableDecl) stack.get(varDeclIndex);\n\t\tatom.replace(this, null);\n\t\t\n\t\tint lineIndex = stack.find(Line.class, varDeclIndex);\n\t\tLine line = (Line) stack.get(lineIndex);\n\t\t\n\t\tif(decl instanceof VariableDeclFromExpr) {\n\t\t\tVariableDecl newDecl = new VariableDecl(getRealType(genType), false, startToken);\n\t\t\tnewDecl.getAtoms().add(atom);\n\t\t\tNode node = stack.get(varDeclIndex - 1);\n\t\t\tSystem.out.println(\"node to replace in = \"+node);\n\t\t\tnode.replace(decl, newDecl);\n\t\t\tdecl = newDecl;\n\t\t}\n\t\t\n\t\tNodeList<Line> list = (NodeList<Line>) stack.get(lineIndex - 1);\n\t\tVariableAccess varAcc = new VariableAccess(atom.getName(), startToken);\n\t\tvarAcc.setRef(decl);\n\t\treturnArg = new AddressOf(varAcc, startToken);\n\t\tlist.addAfter(line, new Line(this));\n\t}\n\n\tprotected void autocast() {\n\t\tif(impl == null) return;\n\n\t\tIterator<Expression> callArgs = arguments.iterator();\n\t\tIterator<Argument> implArgs = impl.getArguments().iterator();\n\t\tif(impl.hasThis() && implArgs.hasNext()) implArgs.next();\n\t\t\n\t\twhile(implArgs.hasNext() && callArgs.hasNext()) {\n\t\t\tExpression callArg = callArgs.next();\n\t\t\tArgument implArg = implArgs.next();\n\t\t\tif(implArg.getType().isSuperOf(callArg.getType())) {\n\t\t\t\targuments.replace(callArg, new Cast(callArg, implArg.getType(), callArg.startToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Type getRealType(GenericType genType) {\n\t\tint i = 0;\n\t\tfor(Argument arg: impl.getArguments()) {\n\t\t\tif(arg.getType().getName().equals(genType.getName())) {\n\t\t\t\treturn arguments.get(i).getType();\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected String guessCorrectName(final NodeList<Node> mainStack, final Resolver res) {\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tNodeList<FunctionDecl> funcs = new NodeList<FunctionDecl>();\n\t\t\n\t\tfor(int i = mainStack.size() - 1; i >= 0; i--) {\n\t\t\tNode node = mainStack.get(i);\n\t\t\tif(!(node instanceof Scope)) continue;\n\t\t\t((Scope) node).getFunctions(funcs);\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: funcs) {\n\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\tif(distance < bestDistance) {\n\t\t\t\tbestDistance = distance;\n\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t}\n\t\t}\n\t\t\n\t\tModule module = (Module) mainStack.get(0);\n\t\tfor(Import imp: module.getImports()) {\n\t\t\tfor(Node node: imp.getModule().body) {\n\t\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\t\tint distance = Levenshtein.distance(name, decl.getName());\n\t\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\t\tbestMatch = decl.getProtoRepr();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprotected void resolveConstructorCall(final NodeList<Node> mainStack, final boolean isSuper) throws OocCompilationError, EOFException {\n\t\t\n\t\tint typeIndex = mainStack.find(TypeDecl.class);\n\t\tif(typeIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, mainStack, (isSuper ? \"super\" : \"this\")\n\t\t\t\t\t+getArgsRepr()+\" call outside a class declaration, doesn't make sense.\");\n\t\t}\n\t\tTypeDecl typeDecl = (TypeDecl) mainStack.get(typeIndex);\n\t\tif(isSuper) {\n\t\t\tif(!(typeDecl instanceof ClassDecl)) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in type def \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which is not a class! wtf?\");\n\t\t\t}\n\t\t\tClassDecl classDecl = ((ClassDecl) typeDecl);\n\t\t\tif(classDecl.getSuperRef() == null) {\n\t\t\t\tthrow new OocCompilationError(this, mainStack, \"super\"+getArgsRepr()+\" call in class \"\n\t\t\t\t\t\t+typeDecl.getName()+\" which has no super-class!\");\n\t\t\t}\n\t\t\ttypeDecl = classDecl.getSuperRef();\n\t\t}\n\t\t\n\t\tfor(FunctionDecl decl: typeDecl.getFunctions()) {\n\t\t\tif(decl.getName().equals(\"init\")) {\n\t\t\t\tif(matchesArgs(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprotected void resolveRegular(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\timpl = getFunction(name, suffix, this, stack);\n\n\t\tif(impl == null) {\n\t\t\tModule module = (Module) stack.get(0);\n\t\t\tfor(Import imp: module.getImports()) {\n\t\t\t\tsearchIn(imp.getModule());\n\t\t\t\tif(impl != null) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tint typeIndex = stack.find(TypeDecl.class);\n\t\t\tif(typeIndex != -1) {\n\t\t\t\tTypeDecl typeDeclaration = (TypeDecl) stack.get(typeIndex);\n\t\t\t\tfor(VariableDecl varDecl: typeDeclaration.getVariables()) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType && varDecl.getName().equals(name)) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\tif(matchesArgs(funcType.getDecl())) {\n\t\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(impl == null) {\n\t\t\tVariableDecl varDecl = getVariable(name, stack);\n\t\t\tif(varDecl != null) {\n\t\t\t\tif(varDecl.getName().equals(name)) {\n\t\t\t\t\tif(varDecl.getType() instanceof FuncType) {\n\t\t\t\t\t\tFuncType funcType = (FuncType) varDecl.getType();\n\t\t\t\t\t\timpl = funcType.getDecl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \"Trying to call \"\n\t\t\t\t\t\t\t\t+name+\", which isn't a function pointer (Func), but a \"+varDecl.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(impl != null) {\n\t\t\tif(impl.isMember()) transformToMemberCall(stack, res);\n\t\t}\n\t\t\n\t}\n\n\tprivate void transformToMemberCall(final NodeList<Node> stack,\n\t\t\tfinal Resolver res) throws IOException {\n\t\tVariableAccess thisAccess = new VariableAccess(\"this\", startToken);\n\t\tthisAccess.resolve(stack, res, true);\n\t\tMemberCall memberCall = new MemberCall(new VariableAccess(\"this\", startToken), this, startToken);\n\t\tmemberCall.setImpl(impl);\n\t\tstack.peek().replace(this, memberCall);\n\t}\n\t\n\tprotected void searchIn(Module module) {\n\t\tfor(Node node: module.getBody()) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl decl = (FunctionDecl) node;\n\t\t\t\tif(matches(decl)) {\n\t\t\t\t\timpl = decl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean matches(FunctionDecl decl) {\n\t\treturn matchesName(decl) && matchesArgs(decl);\n\t}\n\n\tpublic boolean matchesArgs(FunctionDecl decl) {\n\t\tint numArgs = decl.getArguments().size();\n\t\tif(decl.hasThis()) numArgs--;\n\t\t\n\t\tif(numArgs == arguments.size()\n\t\t\t|| ((numArgs > 0 && decl.getArguments().getLast() instanceof VarArg)\n\t\t\t&& (numArgs - 1 <= arguments.size()))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean matchesName(FunctionDecl decl) {\n\t\treturn decl.isNamed(name, suffix);\n\t}\n\t\n\tpublic String getArgsRepr() {\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Expression> iter = arguments.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tsB.append(iter.next().getType());\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t}\n\n\tpublic boolean isConstructorCall() {\n\t\treturn name.equals(\"this\") || name.equals(\"super\");\n\t}\n\t\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtoRepr();\n\t}\n\n\tpublic int getScore(FunctionDecl func) {\n\t\tint score = 0;\n\t\t\n\t\tNodeList<Argument> declArgs = func.getArguments();\n\t\tif(matchesArgs(func)) {\n\t\t\tscore += 10;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(declArgs.size == 0) return score;\n\t\t\n\t\tIterator<Argument> declIter = declArgs.iterator();\n\t\tif(func.hasThis() && declIter.hasNext()) declIter.next();\n\t\tIterator<Expression> callIter = arguments.iterator();\n\t\twhile(callIter.hasNext()) {\n\t\t\tArgument declArg = declIter.next();\n\t\t\tExpression callArg = callIter.next();\n\t\t\tif(declArg.getType().equals(callArg.getType())) {\n\t\t\t\tscore += 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn score;\n\t}\n\t\n}\n","lineNo":202}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\n\npublic class NodeList<T extends Node> extends Node implements Iterable<T> {\n\t\n\tT[] nodes;\n\tint size;\n\t\n\tpublic NodeList() {\n\t\tthis(Token.defaultToken);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic NodeList(Token startToken) {\n\t\tsuper(startToken);\n\t\tnodes = (T[]) new Node[10];\n\t\tsize = 0;\n\t}\n\n\tprivate void realloc() {\n\t\tnodes = Arrays.copyOf(nodes, (size * 3) / 2 + 1);\n\t}\n\t\n\tprivate void ensureCapacity(int minCapacity) {\n\t\tif(minCapacity > nodes.length) {\n\t\t\tnodes = Arrays.copyOf(nodes, minCapacity);\n\t\t}\n\t}\n\t\n\tpublic void add(T element) {\n\t\tif(size >= nodes.length) realloc();\n\t\tnodes[size++] = element;\n\t}\n\n\tpublic void add(int index, T element) {\n\t\tif(size + 1 >= nodes.length) realloc();\n\t\tSystem.arraycopy(nodes, index, nodes, index + 1, size - index);\n\t\tnodes[index] = element;\n\t\tsize++;\n\t}\n\t\n\tpublic boolean remove(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\tfastRemove(index);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic T remove(int index) {\n\t\tT o = nodes[index];\n        fastRemove(index);\n        return o;\n\t}\n\n\tprivate void fastRemove(int index) {\n\t\tint numMoved = size - index - 1;\n\t\tif (numMoved > 0) {\n            System.arraycopy(nodes, index+1, nodes, index, numMoved);\n        }\n\t\tsize--;\n\t}\n\t\n\tpublic boolean contains(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int indexOf(T lostSheep) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(lostSheep.equals(nodes[index])) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic T get(int i) {\n\t\tif(i >= size) throw new ArrayIndexOutOfBoundsException(i);\n\t\treturn nodes[i];\n\t}\n\t\n\tpublic void set(int i, T element) {\n\t\tif(i > size) throw new ArrayIndexOutOfBoundsException(i);\n\t\tnodes[i] = element;\n\t}\n\t\n\tpublic void setAll(NodeList<T> list) {\n\t\tnodes = list.nodes;\n\t}\n\t\n\tpublic T getFirst() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[0];\n\t}\n\t\n\tpublic T getLast() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic T getBeforeLast() {\n\t\tif(size <= 1) throw new ArrayIndexOutOfBoundsException(size - 1);\n\t\treturn nodes[size - 2];\n\t}\n\n\t@Override\n\tpublic Iterator<T> iterator() {\t\t\n\t\treturn new Iterator<T>() {\n\n\t\t\tint index = 0;\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < size;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\tif(index >= size) throw new ArrayIndexOutOfBoundsException(index);\n\t\t\t\treturn nodes[index++];\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tNodeList.this.remove(index);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tnodes[i].accept(visitor);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn size > 0;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tint index = indexOf((T) oldie);\n\t\tif(index == -1) {\n\t\t\tSystem.out.println(\"trying to replace \"+oldie+\" with \"+kiddo+\" in a list with \"+nodes);\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Trying to replace a \"\n\t\t\t\t\t+oldie.getClass().getName()+\" with a \"+kiddo.getClass().getSimpleName()+\n\t\t\t\t\t\" in a \"+this.getClass().getSimpleName()+\", but couldn't find node to replace in NodeList.\");\n\t\t}\n\t\tnodes[index] = (T) kiddo;\n\t\treturn true;\n\t}\n\n\tpublic void addAll(NodeList<T> list) {\n\t\tint newSize = size + list.size;\n\t\tensureCapacity(newSize);\n\t\tSystem.arraycopy(list.nodes, 0, nodes, size, list.size);\n\t\tsize = newSize;\n\t}\n\t\n\tpublic void addAll(List<T> list) {\n\t\tint newSize = size + list.size();\n\t\tensureCapacity(newSize);\n\t\tint index = size;\n\t\tfor(T o : list) {\n\t\t\tnodes[index++] = o;\n\t\t}\n\t}\n\n\tpublic T[] getNodes() {\n\t\treturn nodes;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(false);\n\t}\n\t\n\tpublic String toString(boolean stackLike) {\n\t\treturn toString(stackLike, 0);\n\t}\n\t\n\tpublic String toString(boolean stackLike, int offset) {\n\t\tif(size == 0) return \"[]\";\n\t\tStringBuilder sB = new StringBuilder();\n\t\tif(stackLike) sB.append('\\n');\n\t\tint index = 0;\n\t\twhile(index < size) {\n\t\t\tT node = nodes[index++];\n\t\t\tif(node instanceof NodeList<?>) {\n\t\t\t\tsB.append(((NodeList<?>) node).toString(false, stackLike ? offset + index : offset));\n\t\t\t} else {\n\t\t\t\tfor(int i = 0; i < offset; i++) sB.append(\"  \");\n\t\t\t\tif(stackLike) {\n\t\t\t\t\tfor(int i = 0; i < index; i++) sB.append(\"  \");\n\t\t\t\t}\n\t\t\t\tsB.append(node.toString());\n\t\t\t}\n\t\t\tif(stackLike && index < size) sB.append(\"\\n\");\n\t\t}\n\t\treturn sB.toString();\n\t}\n\n\tpublic void push(T node) {\n\t\tif(size + 1 > nodes.length) realloc();\n\t\tnodes[size++] = node;\n\t}\n\t\n\t/**\n\t * Checked pop: ensures it's this node we are removing\n\t * @param coverDecl\n\t */\n\tpublic void pop(T node) {\n\t\tif(peek() == node)\n\t\t\tpop();\n\t\telse\n\t\t\tthrow new Error(\"Unmatched node in checked pop: \"+node+\". peek is \"+peek());\n\t}\n\n\tpublic void pop() {\n\t\tif(size <= 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\tsize--;\n\t}\n\n\tpublic T peek() {\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic int find(Class<?> clazz) {\n\t\treturn find(clazz, size - 1);\n\t}\n\t\t\n\tpublic int find(Class<?> clazz, int offset) {\n\t\tint i = offset;\n\t\twhile(i >= 0) {\n\t\t\tT node = nodes[i];\n\t\t\tif(clazz.isInstance(node)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tpublic Module getModule() {\n\t\treturn (Module) nodes[0];\n\t}\n\t\n\tpublic void addBefore(T beforeWhat, T kiddo) {\n\t\tint index = indexOf(beforeWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" before \"+beforeWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index, kiddo);\n\t}\n\n\tpublic void addAfter(T afterWhat, T kiddo) {\n\t\tint index = indexOf(afterWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" after \"+afterWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index + 1, kiddo);\n\t}\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\n\npublic class NodeList<T extends Node> extends Node implements Iterable<T> {\n\t\n\tT[] nodes;\n\tint size;\n\t\n\tpublic NodeList() {\n\t\tthis(Token.defaultToken);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic NodeList(Token startToken) {\n\t\tsuper(startToken);\n\t\tnodes = (T[]) new Node[10];\n\t\tsize = 0;\n\t}\n\n\tprivate void realloc() {\n\t\tnodes = Arrays.copyOf(nodes, (size * 3) / 2 + 1);\n\t}\n\t\n\tprivate void ensureCapacity(int minCapacity) {\n\t\tif(minCapacity > nodes.length) {\n\t\t\tnodes = Arrays.copyOf(nodes, minCapacity);\n\t\t}\n\t}\n\t\n\tpublic void add(T element) {\n\t\tif(size >= nodes.length) realloc();\n\t\tnodes[size++] = element;\n\t}\n\n\tpublic void add(int index, T element) {\n\t\tif(size + 1 >= nodes.length) realloc();\n\t\tSystem.arraycopy(nodes, index, nodes, index + 1, size - index);\n\t\tnodes[index] = element;\n\t\tsize++;\n\t}\n\t\n\tpublic boolean remove(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\tfastRemove(index);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic T remove(int index) {\n\t\tT o = nodes[index];\n        fastRemove(index);\n        return o;\n\t}\n\n\tprivate void fastRemove(int index) {\n\t\tint numMoved = size - index - 1;\n\t\tif (numMoved > 0) {\n            System.arraycopy(nodes, index+1, nodes, index, numMoved);\n        }\n\t\tsize--;\n\t}\n\t\n\tpublic boolean contains(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int indexOf(T lostSheep) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(lostSheep.equals(nodes[index])) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic T get(int i) {\n\t\tif(i >= size) throw new ArrayIndexOutOfBoundsException(i);\n\t\treturn nodes[i];\n\t}\n\t\n\tpublic void set(int i, T element) {\n\t\tif(i > size) throw new ArrayIndexOutOfBoundsException(i);\n\t\tnodes[i] = element;\n\t}\n\t\n\tpublic void setAll(NodeList<T> list) {\n\t\tnodes = list.nodes;\n\t}\n\t\n\tpublic T getFirst() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[0];\n\t}\n\t\n\tpublic T getLast() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic T getBeforeLast() {\n\t\tif(size <= 1) throw new ArrayIndexOutOfBoundsException(size - 1);\n\t\treturn nodes[size - 2];\n\t}\n\n\t@Override\n\tpublic Iterator<T> iterator() {\t\t\n\t\treturn new Iterator<T>() {\n\n\t\t\tint index = 0;\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < size;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\tif(index >= size) throw new ArrayIndexOutOfBoundsException(index);\n\t\t\t\treturn nodes[index++];\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tNodeList.this.remove(index);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tnodes[i].accept(visitor);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn size > 0;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tint index = indexOf((T) oldie);\n\t\tif(index == -1) {\n\t\t\tSystem.out.println(\"Trying to replace \"+oldie+\" with \"+kiddo+\" in a list with \"+toString());\n\t\t\tString oldieClassName = oldie == null ? \"null\" : oldie.getClass().getName();\n\t\t\tString kiddoClassName = kiddo == null ? \"null\" : kiddo.getClass().getSimpleName();\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Trying to replace a \"\n\t\t\t\t\t+oldieClassName+\" with a \"+kiddoClassName+\n\t\t\t\t\t\" in a \"+this.getClass().getSimpleName()+\", but couldn't find node to replace in NodeList.\");\n\t\t}\n\t\tnodes[index] = (T) kiddo;\n\t\treturn true;\n\t}\n\n\tpublic void addAll(NodeList<T> list) {\n\t\tint newSize = size + list.size;\n\t\tensureCapacity(newSize);\n\t\tSystem.arraycopy(list.nodes, 0, nodes, size, list.size);\n\t\tsize = newSize;\n\t}\n\t\n\tpublic void addAll(List<T> list) {\n\t\tint newSize = size + list.size();\n\t\tensureCapacity(newSize);\n\t\tint index = size;\n\t\tfor(T o : list) {\n\t\t\tnodes[index++] = o;\n\t\t}\n\t}\n\n\tpublic T[] getNodes() {\n\t\treturn nodes;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(false);\n\t}\n\t\n\tpublic String toString(boolean stackLike) {\n\t\treturn toString(stackLike, 0);\n\t}\n\t\n\tpublic String toString(boolean stackLike, int offset) {\n\t\tif(size == 0) return \"[]\";\n\t\tStringBuilder sB = new StringBuilder();\n\t\tif(stackLike) sB.append('\\n');\n\t\tint index = 0;\n\t\twhile(index < size) {\n\t\t\tT node = nodes[index++];\n\t\t\tif(node instanceof NodeList<?>) {\n\t\t\t\tsB.append(((NodeList<?>) node).toString(false, stackLike ? offset + index : offset));\n\t\t\t} else {\n\t\t\t\tfor(int i = 0; i < offset; i++) sB.append(\"  \");\n\t\t\t\tif(stackLike) {\n\t\t\t\t\tfor(int i = 0; i < index; i++) sB.append(\"  \");\n\t\t\t\t} else if(index > 1) {\n\t\t\t\t\tsB.append(\", \");\n\t\t\t\t}\n\t\t\t\tsB.append(node.toString());\n\t\t\t}\n\t\t\tif(stackLike && index < size) sB.append(\"\\n\");\n\t\t}\n\t\treturn sB.toString();\n\t}\n\n\tpublic void push(T node) {\n\t\tif(size + 1 > nodes.length) realloc();\n\t\tnodes[size++] = node;\n\t}\n\t\n\t/**\n\t * Checked pop: ensures it's this node we are removing\n\t * @param coverDecl\n\t */\n\tpublic void pop(T node) {\n\t\tif(peek() == node)\n\t\t\tpop();\n\t\telse\n\t\t\tthrow new Error(\"Unmatched node in checked pop: \"+node+\". peek is \"+peek());\n\t}\n\n\tpublic void pop() {\n\t\tif(size <= 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\tsize--;\n\t}\n\n\tpublic T peek() {\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic int find(Class<?> clazz) {\n\t\treturn find(clazz, size - 1);\n\t}\n\t\t\n\tpublic int find(Class<?> clazz, int offset) {\n\t\tint i = offset;\n\t\twhile(i >= 0) {\n\t\t\tT node = nodes[i];\n\t\t\tif(clazz.isInstance(node)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tpublic Module getModule() {\n\t\treturn (Module) nodes[0];\n\t}\n\t\n\tpublic void addBefore(T beforeWhat, T kiddo) {\n\t\tint index = indexOf(beforeWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" before \"+beforeWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index, kiddo);\n\t}\n\n\tpublic void addAfter(T afterWhat, T kiddo) {\n\t\tint index = indexOf(afterWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" after \"+afterWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index + 1, kiddo);\n\t}\n}\n","lineNo":177}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\n\npublic class NodeList<T extends Node> extends Node implements Iterable<T> {\n\t\n\tT[] nodes;\n\tint size;\n\t\n\tpublic NodeList() {\n\t\tthis(Token.defaultToken);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic NodeList(Token startToken) {\n\t\tsuper(startToken);\n\t\tnodes = (T[]) new Node[10];\n\t\tsize = 0;\n\t}\n\n\tprivate void realloc() {\n\t\tnodes = Arrays.copyOf(nodes, (size * 3) / 2 + 1);\n\t}\n\t\n\tprivate void ensureCapacity(int minCapacity) {\n\t\tif(minCapacity > nodes.length) {\n\t\t\tnodes = Arrays.copyOf(nodes, minCapacity);\n\t\t}\n\t}\n\t\n\tpublic void add(T element) {\n\t\tif(size >= nodes.length) realloc();\n\t\tnodes[size++] = element;\n\t}\n\n\tpublic void add(int index, T element) {\n\t\tif(size + 1 >= nodes.length) realloc();\n\t\tSystem.arraycopy(nodes, index, nodes, index + 1, size - index);\n\t\tnodes[index] = element;\n\t\tsize++;\n\t}\n\t\n\tpublic boolean remove(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\tfastRemove(index);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic T remove(int index) {\n\t\tT o = nodes[index];\n        fastRemove(index);\n        return o;\n\t}\n\n\tprivate void fastRemove(int index) {\n\t\tint numMoved = size - index - 1;\n\t\tif (numMoved > 0) {\n            System.arraycopy(nodes, index+1, nodes, index, numMoved);\n        }\n\t\tsize--;\n\t}\n\t\n\tpublic boolean contains(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int indexOf(T lostSheep) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(lostSheep.equals(nodes[index])) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic T get(int i) {\n\t\tif(i >= size) throw new ArrayIndexOutOfBoundsException(i);\n\t\treturn nodes[i];\n\t}\n\t\n\tpublic void set(int i, T element) {\n\t\tif(i > size) throw new ArrayIndexOutOfBoundsException(i);\n\t\tnodes[i] = element;\n\t}\n\t\n\tpublic void setAll(NodeList<T> list) {\n\t\tnodes = list.nodes;\n\t}\n\t\n\tpublic T getFirst() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[0];\n\t}\n\t\n\tpublic T getLast() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic T getBeforeLast() {\n\t\tif(size <= 1) throw new ArrayIndexOutOfBoundsException(size - 1);\n\t\treturn nodes[size - 2];\n\t}\n\n\t@Override\n\tpublic Iterator<T> iterator() {\t\t\n\t\treturn new Iterator<T>() {\n\n\t\t\tint index = 0;\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < size;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\tif(index >= size) throw new ArrayIndexOutOfBoundsException(index);\n\t\t\t\treturn nodes[index++];\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tNodeList.this.remove(index);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tnodes[i].accept(visitor);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn size > 0;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tint index = indexOf((T) oldie);\n\t\tif(index == -1) {\n\t\t\tSystem.out.println(\"trying to replace \"+oldie+\" with \"+kiddo+\" in a list with \"+nodes);\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Trying to replace a \"\n\t\t\t\t\t+oldie.getClass().getName()+\" with a \"+kiddo.getClass().getSimpleName()+\n\t\t\t\t\t\" in a \"+this.getClass().getSimpleName()+\", but couldn't find node to replace in NodeList.\");\n\t\t}\n\t\tnodes[index] = (T) kiddo;\n\t\treturn true;\n\t}\n\n\tpublic void addAll(NodeList<T> list) {\n\t\tint newSize = size + list.size;\n\t\tensureCapacity(newSize);\n\t\tSystem.arraycopy(list.nodes, 0, nodes, size, list.size);\n\t\tsize = newSize;\n\t}\n\t\n\tpublic void addAll(List<T> list) {\n\t\tint newSize = size + list.size();\n\t\tensureCapacity(newSize);\n\t\tint index = size;\n\t\tfor(T o : list) {\n\t\t\tnodes[index++] = o;\n\t\t}\n\t}\n\n\tpublic T[] getNodes() {\n\t\treturn nodes;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(false);\n\t}\n\t\n\tpublic String toString(boolean stackLike) {\n\t\treturn toString(stackLike, 0);\n\t}\n\t\n\tpublic String toString(boolean stackLike, int offset) {\n\t\tif(size == 0) return \"[]\";\n\t\tStringBuilder sB = new StringBuilder();\n\t\tif(stackLike) sB.append('\\n');\n\t\tint index = 0;\n\t\twhile(index < size) {\n\t\t\tT node = nodes[index++];\n\t\t\tif(node instanceof NodeList<?>) {\n\t\t\t\tsB.append(((NodeList<?>) node).toString(false, stackLike ? offset + index : offset));\n\t\t\t} else {\n\t\t\t\tfor(int i = 0; i < offset; i++) sB.append(\"  \");\n\t\t\t\tif(stackLike) {\n\t\t\t\t\tfor(int i = 0; i < index; i++) sB.append(\"  \");\n\t\t\t\t}\n\t\t\t\tsB.append(node.toString());\n\t\t\t}\n\t\t\tif(stackLike && index < size) sB.append(\"\\n\");\n\t\t}\n\t\treturn sB.toString();\n\t}\n\n\tpublic void push(T node) {\n\t\tif(size + 1 > nodes.length) realloc();\n\t\tnodes[size++] = node;\n\t}\n\t\n\t/**\n\t * Checked pop: ensures it's this node we are removing\n\t * @param coverDecl\n\t */\n\tpublic void pop(T node) {\n\t\tif(peek() == node)\n\t\t\tpop();\n\t\telse\n\t\t\tthrow new Error(\"Unmatched node in checked pop: \"+node+\". peek is \"+peek());\n\t}\n\n\tpublic void pop() {\n\t\tif(size <= 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\tsize--;\n\t}\n\n\tpublic T peek() {\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic int find(Class<?> clazz) {\n\t\treturn find(clazz, size - 1);\n\t}\n\t\t\n\tpublic int find(Class<?> clazz, int offset) {\n\t\tint i = offset;\n\t\twhile(i >= 0) {\n\t\t\tT node = nodes[i];\n\t\t\tif(clazz.isInstance(node)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tpublic Module getModule() {\n\t\treturn (Module) nodes[0];\n\t}\n\t\n\tpublic void addBefore(T beforeWhat, T kiddo) {\n\t\tint index = indexOf(beforeWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" before \"+beforeWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index, kiddo);\n\t}\n\n\tpublic void addAfter(T afterWhat, T kiddo) {\n\t\tint index = indexOf(afterWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" after \"+afterWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index + 1, kiddo);\n\t}\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\n\npublic class NodeList<T extends Node> extends Node implements Iterable<T> {\n\t\n\tT[] nodes;\n\tint size;\n\t\n\tpublic NodeList() {\n\t\tthis(Token.defaultToken);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic NodeList(Token startToken) {\n\t\tsuper(startToken);\n\t\tnodes = (T[]) new Node[10];\n\t\tsize = 0;\n\t}\n\n\tprivate void realloc() {\n\t\tnodes = Arrays.copyOf(nodes, (size * 3) / 2 + 1);\n\t}\n\t\n\tprivate void ensureCapacity(int minCapacity) {\n\t\tif(minCapacity > nodes.length) {\n\t\t\tnodes = Arrays.copyOf(nodes, minCapacity);\n\t\t}\n\t}\n\t\n\tpublic void add(T element) {\n\t\tif(size >= nodes.length) realloc();\n\t\tnodes[size++] = element;\n\t}\n\n\tpublic void add(int index, T element) {\n\t\tif(size + 1 >= nodes.length) realloc();\n\t\tSystem.arraycopy(nodes, index, nodes, index + 1, size - index);\n\t\tnodes[index] = element;\n\t\tsize++;\n\t}\n\t\n\tpublic boolean remove(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\tfastRemove(index);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic T remove(int index) {\n\t\tT o = nodes[index];\n        fastRemove(index);\n        return o;\n\t}\n\n\tprivate void fastRemove(int index) {\n\t\tint numMoved = size - index - 1;\n\t\tif (numMoved > 0) {\n            System.arraycopy(nodes, index+1, nodes, index, numMoved);\n        }\n\t\tsize--;\n\t}\n\t\n\tpublic boolean contains(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int indexOf(T lostSheep) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(lostSheep.equals(nodes[index])) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic T get(int i) {\n\t\tif(i >= size) throw new ArrayIndexOutOfBoundsException(i);\n\t\treturn nodes[i];\n\t}\n\t\n\tpublic void set(int i, T element) {\n\t\tif(i > size) throw new ArrayIndexOutOfBoundsException(i);\n\t\tnodes[i] = element;\n\t}\n\t\n\tpublic void setAll(NodeList<T> list) {\n\t\tnodes = list.nodes;\n\t}\n\t\n\tpublic T getFirst() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[0];\n\t}\n\t\n\tpublic T getLast() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic T getBeforeLast() {\n\t\tif(size <= 1) throw new ArrayIndexOutOfBoundsException(size - 1);\n\t\treturn nodes[size - 2];\n\t}\n\n\t@Override\n\tpublic Iterator<T> iterator() {\t\t\n\t\treturn new Iterator<T>() {\n\n\t\t\tint index = 0;\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < size;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\tif(index >= size) throw new ArrayIndexOutOfBoundsException(index);\n\t\t\t\treturn nodes[index++];\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tNodeList.this.remove(index);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tnodes[i].accept(visitor);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn size > 0;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tint index = indexOf((T) oldie);\n\t\tif(index == -1) {\n\t\t\tSystem.out.println(\"Trying to replace \"+oldie+\" with \"+kiddo+\" in a list with \"+toString());\n\t\t\tString oldieClassName = oldie == null ? \"null\" : oldie.getClass().getName();\n\t\t\tString kiddoClassName = kiddo == null ? \"null\" : kiddo.getClass().getSimpleName();\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Trying to replace a \"\n\t\t\t\t\t+oldieClassName+\" with a \"+kiddoClassName+\n\t\t\t\t\t\" in a \"+this.getClass().getSimpleName()+\", but couldn't find node to replace in NodeList.\");\n\t\t}\n\t\tnodes[index] = (T) kiddo;\n\t\treturn true;\n\t}\n\n\tpublic void addAll(NodeList<T> list) {\n\t\tint newSize = size + list.size;\n\t\tensureCapacity(newSize);\n\t\tSystem.arraycopy(list.nodes, 0, nodes, size, list.size);\n\t\tsize = newSize;\n\t}\n\t\n\tpublic void addAll(List<T> list) {\n\t\tint newSize = size + list.size();\n\t\tensureCapacity(newSize);\n\t\tint index = size;\n\t\tfor(T o : list) {\n\t\t\tnodes[index++] = o;\n\t\t}\n\t}\n\n\tpublic T[] getNodes() {\n\t\treturn nodes;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(false);\n\t}\n\t\n\tpublic String toString(boolean stackLike) {\n\t\treturn toString(stackLike, 0);\n\t}\n\t\n\tpublic String toString(boolean stackLike, int offset) {\n\t\tif(size == 0) return \"[]\";\n\t\tStringBuilder sB = new StringBuilder();\n\t\tif(stackLike) sB.append('\\n');\n\t\tint index = 0;\n\t\twhile(index < size) {\n\t\t\tT node = nodes[index++];\n\t\t\tif(node instanceof NodeList<?>) {\n\t\t\t\tsB.append(((NodeList<?>) node).toString(false, stackLike ? offset + index : offset));\n\t\t\t} else {\n\t\t\t\tfor(int i = 0; i < offset; i++) sB.append(\"  \");\n\t\t\t\tif(stackLike) {\n\t\t\t\t\tfor(int i = 0; i < index; i++) sB.append(\"  \");\n\t\t\t\t} else if(index > 1) {\n\t\t\t\t\tsB.append(\", \");\n\t\t\t\t}\n\t\t\t\tsB.append(node.toString());\n\t\t\t}\n\t\t\tif(stackLike && index < size) sB.append(\"\\n\");\n\t\t}\n\t\treturn sB.toString();\n\t}\n\n\tpublic void push(T node) {\n\t\tif(size + 1 > nodes.length) realloc();\n\t\tnodes[size++] = node;\n\t}\n\t\n\t/**\n\t * Checked pop: ensures it's this node we are removing\n\t * @param coverDecl\n\t */\n\tpublic void pop(T node) {\n\t\tif(peek() == node)\n\t\t\tpop();\n\t\telse\n\t\t\tthrow new Error(\"Unmatched node in checked pop: \"+node+\". peek is \"+peek());\n\t}\n\n\tpublic void pop() {\n\t\tif(size <= 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\tsize--;\n\t}\n\n\tpublic T peek() {\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic int find(Class<?> clazz) {\n\t\treturn find(clazz, size - 1);\n\t}\n\t\t\n\tpublic int find(Class<?> clazz, int offset) {\n\t\tint i = offset;\n\t\twhile(i >= 0) {\n\t\t\tT node = nodes[i];\n\t\t\tif(clazz.isInstance(node)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tpublic Module getModule() {\n\t\treturn (Module) nodes[0];\n\t}\n\t\n\tpublic void addBefore(T beforeWhat, T kiddo) {\n\t\tint index = indexOf(beforeWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" before \"+beforeWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index, kiddo);\n\t}\n\n\tpublic void addAfter(T afterWhat, T kiddo) {\n\t\tint index = indexOf(afterWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" after \"+afterWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index + 1, kiddo);\n\t}\n}\n","lineNo":178}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class VariableDeclFromExpr extends VariableDecl implements MustBeResolved {\n\n\tprotected boolean isConst;\n\t\n\tpublic VariableDeclFromExpr(String name, Expression expression, Token startToken) {\n\t\tthis(name, expression, false, startToken);\n\t}\n\t\n\tpublic VariableDeclFromExpr(String name, Expression expression, boolean isStatic, Token startToken) {\n\t\tsuper(null, isStatic, startToken);\n\t\tatoms.add(new VariableDeclAtom(name, expression, startToken));\n\t}\n\t\n\tpublic boolean isConst() {\n\t\treturn isConst;\n\t}\n\t\n\tpublic void setConst(boolean isConst) {\n\t\tthis.isConst = isConst;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tVariableDeclAtom atom = atoms.get(0);\n\t\tExpression expr = atom.getExpression();\n\t\tif(expr == null) {\n\t\t\tif(atom.assign != null) {\n\t\t\t\treturn atom.assign.getRight().getType();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn expr.getType();\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tatoms.accept(visitor);\n\t\tType type = getType();\n\t\tif(type != null && !type.getName().equals(\"This\")) {\n\t\t\ttype.accept(visitor);\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName()+\" \"+getName()+\":\"+getType();\n\t}\n\t\n\t@Override\n\tprotected void unwrapToClassInitializers(NodeList<Node> hierarchy,\n\t\t\tClassDecl classDecl) {\n\t\tsuper.unwrapToClassInitializers(hierarchy, classDecl);\n\t\tatoms.get(0).setExpression(null);\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean resolve(NodeList<Node> stack, Resolver res, boolean fatal)\n\t\t\tthrows IOException {\n\t\tVariableDeclAtom atom = atoms.get(0);\n\t\tExpression expr = atom.getExpression();\n\t\tif(expr != null && expr instanceof MustBeResolved) {\n\t\t\t((MustBeResolved) expr).resolve(stack, res, false);\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class VariableDeclFromExpr extends VariableDecl implements MustBeResolved {\n\n\tprotected boolean isConst;\n\t\n\tpublic VariableDeclFromExpr(String name, Expression expression, Token startToken) {\n\t\tthis(name, expression, false, startToken);\n\t}\n\t\n\tpublic VariableDeclFromExpr(String name, Expression expression, boolean isStatic, Token startToken) {\n\t\tsuper(null, isStatic, startToken);\n\t\tatoms.add(new VariableDeclAtom(name, expression, startToken));\n\t}\n\t\n\tpublic boolean isConst() {\n\t\treturn isConst;\n\t}\n\t\n\tpublic void setConst(boolean isConst) {\n\t\tthis.isConst = isConst;\n\t}\n\n\t@Override\n\tpublic Type getType() {\n\t\tVariableDeclAtom atom = atoms.get(0);\n\t\tExpression expr = atom.getExpression();\n\t\tif(expr == null) {\n\t\t\tif(atom.assign != null) {\n\t\t\t\tType retType = atom.assign.getRight().getType();\n\t\t\t\tif(isConst && retType != null) {\n\t\t\t\t\tretType = retType.copy();\n\t\t\t\t\tretType.setConst(true);\n\t\t\t\t}\n\t\t\t\treturn retType;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tType retType = expr.getType();\n\t\tif(isConst && retType != null) {\n\t\t\tretType = retType.copy();\n\t\t\tretType.setConst(true);\n\t\t}\n\t\treturn retType;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tatoms.accept(visitor);\n\t\tType type = getType();\n\t\tif(type != null && !type.getName().equals(\"This\")) {\n\t\t\ttype.accept(visitor);\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName()+\" \"+getName()+\":\"+getType();\n\t}\n\t\n\t@Override\n\tprotected void unwrapToClassInitializers(NodeList<Node> hierarchy,\n\t\t\tClassDecl classDecl) {\n\t\tsuper.unwrapToClassInitializers(hierarchy, classDecl);\n\t\tatoms.get(0).setExpression(null);\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean resolve(NodeList<Node> stack, Resolver res, boolean fatal)\n\t\t\tthrows IOException {\n\t\tVariableDeclAtom atom = atoms.get(0);\n\t\tExpression expr = atom.getExpression();\n\t\tif(expr != null && expr instanceof MustBeResolved) {\n\t\t\t((MustBeResolved) expr).resolve(stack, res, false);\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n}\n","lineNo":37}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class MemberAccess extends VariableAccess {\n\t\n\tprotected Expression expression;\n\n\tpublic MemberAccess(String variable, Token startToken) {\n\t\tthis(new VariableAccess(\"this\", startToken), variable, startToken);\n\t}\n\t\n\tpublic MemberAccess(Expression expression, String variable, Token startToken) {\n\t\tsuper(variable, startToken);\n\t\tthis.expression = expression;\n\t}\n\t\n\tpublic MemberAccess(Expression expression, VariableAccess variableAccess, Token startToken) {\n\t\tsuper(variableAccess.getName(), startToken);\n\t\tthis.expression = expression;\n\t}\n\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\t\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\texpression.accept(visitor);\n\t\tsuper.acceptChildren(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\n\t\tif(super.replace(oldie, kiddo)) return true;\n\t\t\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic boolean resolve(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\tType exprType = expression.getType();\n\t\tif(exprType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Accessing member \"\n\t\t\t\t\t\t+name+\" in an expression \"+expression.getClass().getSimpleName()\n\t\t\t\t\t\t+\" which type hasn't been resolved yet!\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\texprType = exprType.getFlatType(res);\n\t\tif(exprType.getRef() == null) exprType.resolve(res);\n\n\t\tif(!tryResolve(stack, exprType, res)) {\n\t\t\ttryResolve(stack, exprType.getFlatType(res), res);\n\t\t}\n\t\t\n\t\tif(ref != null && ref.getType() == null && ref instanceof MustBeResolved) {\n\t\t\tMustBeResolved must = (MustBeResolved) ref;\n\t\t\tmust.resolve(stack, res, fatal);\n\t\t}\n\t\t\n\t\tif(ref != null) {\n\t\t\tif(expression instanceof VariableAccess) {\n\t\t\t\tVariableAccess varAcc = (VariableAccess) expression;\n\t\t\t\tif(varAcc.getRef() instanceof TypeDecl) {\n\t\t\t\t\tif(ref instanceof VariableDecl) {\n\t\t\t\t\t\tVariableDecl varDecl = (VariableDecl) ref;\n\t\t\t\t\t\tif(!varDecl.isStatic() && !ref.getName().equals(\"class\")) {\n\t\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \n\t\t\t\t\t\t\t\t\t\"Trying to access member variable \"+exprType\n\t\t\t\t\t\t\t\t\t+\".\"+name+\" as if it were static. But it's not.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ref instanceof FunctionDecl && !expression.getType().getName().equals(\"Class\")) {\n\t\t\t\tMemberAccess membAcc = new MemberAccess(expression, \"class\", startToken);\n\t\t\t\tmembAcc.resolve(stack, res, fatal);\n\t\t\t\texpression = membAcc;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(fatal && ref == null) {\n\t\t\tString message = \"Can't resolve access to member \"+exprType+\".\"+name;\n\t\t\tString guess = guessCorrectName((TypeDecl) exprType.getRef());\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+exprType+\".\"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn ref == null;\n\t}\n\n\tprivate String guessCorrectName(final TypeDecl typeDeclaration) {\n\t\t\n\t\tif(typeDeclaration == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tfor(VariableDecl decl: typeDeclaration.getVariables()) {\n\t\t\tfor(VariableDeclAtom atom: decl.atoms) {\n\t\t\t\tint distance = Levenshtein.distance(name, atom.getName());\n\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\tbestMatch = atom.getName();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprivate boolean tryResolve(NodeList<Node> stack, Type exprType, Resolver res)\n\t\t\tthrows OocCompilationError, IOException {\n\t\t\n\t\tDeclaration decl = exprType.getRef();\n\t\tif(decl == null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(!(decl instanceof TypeDecl)) {\n\t\t\tthrow new OocCompilationError(this, stack,\n\t\t\t\t\t\"Trying to access to a member of not a TypeDecl, but a \"+decl);\n\t\t}\n\t\t\n\t\tTypeDecl typeDecl = (TypeDecl) decl;\n\t\tref = typeDecl.getVariable(name);\n\t\t\n\t\tif(ref == null && name.equals(\"size\") && exprType.isArray) {\n\t\t\tFunctionCall sizeofArray = new FunctionCall(\"sizeof\", \"\", startToken);\n\t\t\tsizeofArray.getArguments().add(expression);\n\t\t\tFunctionCall sizeofType = new FunctionCall(\"sizeof\", \"\", startToken);\n\t\t\t // FIXME it should probably be type.dereference()\n\t\t\tsizeofType.getArguments().add(new VariableAccess(expression.getType().getName(), startToken)); \n\t\t\tDiv div = new Div(sizeofArray, sizeofType, startToken);\n\t\t\tstack.peek().replace(this, new Parenthesis(div, startToken));\n\t\t\treturn true;\n\t\t}\n\n\t\tif(ref == null && exprType.getRef() instanceof CoverDecl && name.equals(\"class\")) {\n\t\t\tif(!stack.peek().replace(this, new MemberCall(expression, \"class\", \"\", startToken))) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace class access with member call\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(ref == null && exprType.getRef() instanceof ClassDecl\n\t\t\t\t&& (name.equals(\"name\") || name.equals(\"size\") || name.equals(\"super\")\n\t\t\t\t\t\t || name.equals(\"size\"))) {\n\t\t\tMemberAccess membAcc = new MemberAccess(expression, \"class\", startToken);\n\t\t\tthis.expression = membAcc;\n\t\t\tNodeList<Node> subStack = new NodeList<Node>();\n\t\t\tsubStack.push(this);\n\t\t\tmembAcc.resolve(subStack, res, true);\n\t\t\ttryResolve(stack, expression.getType(), res);\n\t\t}\n\t\t\n\t\tif(ref == null) {\n\t\t\tref = typeDecl.getFunction(name, \"\", null);\n\t\t}\n\t\t\n\t\treturn ref != null;\n\t\t\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tif(expression instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) expression;\n\t\t\treturn getClass().getSimpleName()+\" \"+varAcc.getName()+\":\"+varAcc.getType()\n\t\t\t+\"->\"+name+\":\"+getType();\n\t\t}\n\t\treturn getClass().getSimpleName()+\" \"+expression+\".\"+name+\":\"+getType();\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Levenshtein;\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.VariableDecl.VariableDeclAtom;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class MemberAccess extends VariableAccess {\n\n\tprotected boolean dead = false;\n\tprotected Expression expression;\n\n\tpublic MemberAccess(String variable, Token startToken) {\n\t\tthis(new VariableAccess(\"this\", startToken), variable, startToken);\n\t}\n\t\n\tpublic MemberAccess(Expression expression, String variable, Token startToken) {\n\t\tsuper(variable, startToken);\n\t\tthis.expression = expression;\n\t}\n\t\n\tpublic MemberAccess(Expression expression, VariableAccess variableAccess, Token startToken) {\n\t\tsuper(variableAccess.getName(), startToken);\n\t\tthis.expression = expression;\n\t}\n\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\t\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\texpression.accept(visitor);\n\t\tsuper.acceptChildren(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\n\t\tif(super.replace(oldie, kiddo)) return true;\n\t\t\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic boolean resolve(NodeList<Node> stack, Resolver res, boolean fatal) throws IOException {\n\t\t\n\t\tType exprType = expression.getType();\n\t\tif(exprType == null) {\n\t\t\tif(fatal) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Accessing member \"\n\t\t\t\t\t\t+name+\" in an expression \"+expression.getClass().getSimpleName()\n\t\t\t\t\t\t+\" which type hasn't been resolved yet!\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\texprType = exprType.getFlatType(res);\n\t\tif(exprType.getRef() == null) exprType.resolve(res);\n\n\t\tif(!tryResolve(stack, exprType, res)) {\n\t\t\ttryResolve(stack, exprType.getFlatType(res), res);\n\t\t}\n\t\t\n\t\tif(ref != null && ref.getType() == null && ref instanceof MustBeResolved) {\n\t\t\tMustBeResolved must = (MustBeResolved) ref;\n\t\t\tmust.resolve(stack, res, fatal);\n\t\t}\n\t\t\n\t\tif(ref != null) {\n\t\t\tif(expression instanceof VariableAccess) {\n\t\t\t\tVariableAccess varAcc = (VariableAccess) expression;\n\t\t\t\tif(varAcc.getRef() instanceof TypeDecl && !(varAcc.getRef() instanceof GenericType)) {\n\t\t\t\t\tif(ref instanceof VariableDecl) {\n\t\t\t\t\t\tVariableDecl varDecl = (VariableDecl) ref;\n\t\t\t\t\t\tif(!varDecl.isStatic() && !ref.getName().equals(\"class\")) {\n\t\t\t\t\t\t\tthrow new OocCompilationError(this, stack, \n\t\t\t\t\t\t\t\t\t\"Trying to access member variable \"+exprType\n\t\t\t\t\t\t\t\t\t+\".\"+name+\" as if it were static. But it's not. (btw, expression = \"+varAcc.getRef());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ref instanceof FunctionDecl && !expression.getType().getName().equals(\"Class\")) {\n\t\t\t\tMemberAccess membAcc = new MemberAccess(expression, \"class\", startToken);\n\t\t\t\tmembAcc.resolve(stack, res, fatal);\n\t\t\t\texpression = membAcc;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(fatal && ref == null && !dead) {\n\t\t\tString message = \"Can't resolve access to member \"+exprType+\".\"+name;\n\t\t\tString guess = guessCorrectName((TypeDecl) exprType.getRef());\n\t\t\tif(guess != null) {\n\t\t\t\tmessage += \" Did you mean \"+exprType+\".\"+guess+\" ?\";\n\t\t\t}\n\t\t\tthrow new OocCompilationError(this, stack, message);\n\t\t}\n\t\t\n\t\treturn ref == null;\n\t}\n\n\tprivate String guessCorrectName(final TypeDecl typeDeclaration) {\n\t\t\n\t\tif(typeDeclaration == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tint bestDistance = Integer.MAX_VALUE;\n\t\tString bestMatch = null;\n\t\t\n\t\tfor(VariableDecl decl: typeDeclaration.getVariables()) {\n\t\t\tfor(VariableDeclAtom atom: decl.atoms) {\n\t\t\t\tint distance = Levenshtein.distance(name, atom.getName());\n\t\t\t\tif(distance < bestDistance) {\n\t\t\t\t\tbestDistance = distance;\n\t\t\t\t\tbestMatch = atom.getName();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn bestMatch;\n\t\t\n\t}\n\n\tprivate boolean tryResolve(NodeList<Node> stack, Type exprType, Resolver res)\n\t\t\tthrows OocCompilationError, IOException {\n\t\t\n\t\tDeclaration decl = exprType.getRef();\n\t\tif(decl == null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(!(decl instanceof TypeDecl)) {\n\t\t\tthrow new OocCompilationError(this, stack,\n\t\t\t\t\t\"Trying to access to a member of not a TypeDecl, but a \"+decl);\n\t\t}\n\t\t\n\t\tTypeDecl typeDecl = (TypeDecl) decl;\n\t\tref = typeDecl.getVariable(name);\n\t\t\n\t\tif(ref == null && name.equals(\"size\") && exprType.isArray) {\n\t\t\tFunctionCall sizeofArray = new FunctionCall(\"sizeof\", \"\", startToken);\n\t\t\tsizeofArray.getArguments().add(expression);\n\t\t\tFunctionCall sizeofType = new FunctionCall(\"sizeof\", \"\", startToken);\n\t\t\t // FIXME it should probably be type.dereference()\n\t\t\tsizeofType.getArguments().add(new VariableAccess(expression.getType().getName(), startToken)); \n\t\t\tDiv div = new Div(sizeofArray, sizeofType, startToken);\n\t\t\tstack.peek().replace(this, new Parenthesis(div, startToken));\n\t\t\treturn true;\n\t\t}\n\n\t\tif(ref == null && exprType.getRef() instanceof CoverDecl && name.equals(\"class\")) {\n\t\t\tMemberCall membCall = new MemberCall(expression, \"class\", \"\", startToken);\n\t\t\tif(!stack.peek().replace(this, membCall)) {\n\t\t\t\tthrow new OocCompilationError(this, stack, \"Couldn't replace class access with member call\");\n\t\t\t}\n\t\t\tmembCall.resolve(stack, res, true);\n\t\t\tdead = true;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(ref == null && exprType.getRef() instanceof TypeDecl\n\t\t\t\t&& (name.equals(\"name\") || name.equals(\"size\") || name.equals(\"super\")\n\t\t\t\t\t\t || name.equals(\"size\"))) {\n\t\t\tMemberAccess membAcc = new MemberAccess(expression, \"class\", startToken);\n\t\t\tthis.expression = membAcc;\n\t\t\tstack.push(this);\n\t\t\tmembAcc.resolve(stack, res, true);\n\t\t\tstack.pop(this);\n\t\t\ttryResolve(stack, expression.getType(), res);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(ref == null) {\n\t\t\tref = typeDecl.getFunction(name, \"\", null);\n\t\t}\n\t\t\n\t\treturn ref != null;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tif(expression instanceof VariableAccess) {\n\t\t\tVariableAccess varAcc = (VariableAccess) expression;\n\t\t\treturn getClass().getSimpleName()+\" \"+varAcc.getName()+\":\"+varAcc.getType()\n\t\t\t+\"->\"+name+\":\"+getType();\n\t\t}\n\t\treturn expression+\".\"+name+\":\"+getType();\n\t}\n\n}\n","lineNo":173}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ooc.middle.walkers.Nosy;\nimport org.ooc.middle.walkers.Opportunist;\nimport org.ubi.SourceReader;\n\npublic class Module extends Node implements Scope {\n\n\tprotected String underName;\n\tprotected String fullName;\n\tprotected String name;\n\tprotected NodeList<Include> includes;\n\tprotected NodeList<Import> imports;\n\tprotected NodeList<Use> uses;\n\tprotected MultiMap<String, TypeDecl> types;\n\tprotected MultiMap<String, FunctionDecl> functions;\n\tprotected NodeList<OpDecl> ops;\n\tprotected NodeList<Node> body;\n\tprotected String fileName;\n\tprotected FunctionDecl loadFunc;\n\tprivate boolean isMain;\n\tprivate final transient SourceReader reader;\n\t\n\tpublic NodeList<Node> parseStack = new NodeList<Node>();\n\t\n\tpublic long lastModified;\n\t\n\tpublic Module(String fullName, SourceReader reader) {\n\t\t\n\t\tsuper(Token.defaultToken);\n\t\tthis.reader = reader;\n\t\t\n\t\tthis.fullName = fullName; // just to make sure\n\t\tthis.fileName = fullName.replace('.', File.separatorChar);\n\t\tint index = fullName.lastIndexOf('.');\n\t\tif(index == -1) name = fullName;\n\t\telse name = fullName.substring(index + 1);\n\t\tthis.underName = \"_\"+fullName.replaceAll(\"[^a-zA-Z0-9_]\", \"_\");\n\t\t\n\t\tthis.includes = new NodeList<Include>(startToken);\n\t\tthis.imports = new NodeList<Import>(startToken);\n\t\tthis.uses = new NodeList<Use>(startToken);\n\t\tthis.body = new NodeList<Node>(startToken);\n\t\tthis.ops = new NodeList<OpDecl>();\n\t\tthis.types = new MultiMap<String, TypeDecl>();\n\t\tthis.functions = new MultiMap<String, FunctionDecl>();\n\t\t\n\t\t// set it as extern, so it won't get written implicitly\n\t\tthis.loadFunc = new FunctionDecl(underName + \"_load\", \"\", false, false, false, true, Token.defaultToken);\n\t\t\n\t}\n\t\n\tpublic String getSimpleName() {\n\t\treturn name;\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn fullName;\n\t}\n\t\n\tpublic String getFileName() {\n\t\treturn fileName;\n\t}\n\t\n\tpublic String getPath() {\n\t\treturn getPath(\".ooc\");\n\t}\n\n\tpublic String getPath(String extension) {\n\t\treturn getFileName() + extension;\n\t}\n\n\tpublic NodeList<Include> getIncludes() {\n\t\treturn includes;\n\t}\n\t\n\tpublic NodeList<Import> getImports() {\n\t\treturn imports;\n\t}\n\t\n\tpublic NodeList<Use> getUses() {\n\t\treturn uses;\n\t}\n\t\n\tpublic NodeList<Node> getBody() {\n\t\treturn body;\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tincludes.accept(visitor);\n\t\timports.accept(visitor);\n\t\tuses.accept(visitor);\n\t\tbody.accept(visitor);\n\t\ttypes.accept(visitor);\n\t\tops.accept(visitor);\n\t\tloadFunc.accept(visitor);\n\t}\n\t\n\tpublic <T extends Declaration> MultiMap<Node, T> getDeclarationsMap(final Class<T> clazz) throws IOException {\n\n\t\tfinal MultiMap<Node, T> decls = new MultiMap<Node, T>();\n\t\tthis.getDeclarationsMap(clazz, decls);\n\t\tfor(Import imp: imports) {\n\t\t\timp.getModule().getDeclarationsMap(clazz, decls);\n\t\t}\n\t\treturn decls;\n\t\t\n\t}\n\n\tprotected <T extends Declaration> void getDeclarationsMap(final Class<T> clazz,\n\t\t\tfinal MultiMap<Node, T> decls) throws IOException {\n\t\t\n\t\tnew Nosy<T> (clazz, new Opportunist<T>() {\n\t\n\t\t\t@Override\n\t\t\tpublic boolean take(T node, NodeList<Node> stack) throws IOException {\n\t\t\t\t\n\t\t\t\tint index = stack.find(Scope.class);\n\t\t\t\tif(index == -1) {\n\t\t\t\t\tthrow new Error(\"Found declaration \"+node.getName()+\" of type \"\n\t\t\t\t\t\t\t+node.getType()+\" outside of any NodeList!\");\n\t\t\t\t}\n\t\t\t\tdecls.add(stack.get(index), clazz.cast(node));\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}).visit(this);\n\t\t\n\t}\n\t\n\tpublic <T extends Declaration> NodeList<T> getDeclarationsList(final Class<T> clazz) throws IOException {\n\n\t\tfinal NodeList<T> decls = new NodeList<T>();\n\t\tthis.getDeclarationsList(clazz, decls);\n\t\tfor(Import imp: imports) {\n\t\t\timp.getModule().getDeclarationsList(clazz, decls);\n\t\t}\n\t\treturn decls;\n\t\t\n\t}\n\n\tprotected <T extends Declaration> void getDeclarationsList(final Class<T> clazz,\n\t\t\tfinal NodeList<T> decls) throws IOException {\n\t\tnew Nosy<T> (clazz, new Opportunist<T>() {\n\t\n\t\t\t@Override\n\t\t\tpublic boolean take(T node, NodeList<Node> stack) throws IOException {\n\t\t\t\t\n\t\t\t\tint index = stack.find(Scope.class);\n\t\t\t\tif(index == -1) {\n\t\t\t\t\tthrow new Error(\"Found declaration \"+node.getName()+\" of type \"\n\t\t\t\t\t\t\t+node.getType()+\" outside of any NodeList!\");\n\t\t\t\t}\n\t\t\t\tdecls.add(clazz.cast(node));\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}).visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn super.toString()+\" : \"+name;\n\t}\n\t\n\tpublic String getUnderName() {\n\t\treturn underName;\n\t}\n\n\tpublic FunctionDecl getLoadFunc() {\n\t\treturn loadFunc;\n\t}\n\n\tpublic boolean isMain() {\n\t\treturn isMain;\n\t}\n\t\n\tpublic void setMain(boolean isMain) {\n\t\tthis.isMain = isMain;\n\t}\n\n\tpublic SourceReader getReader() {\n\t\treturn reader;\n\t}\n\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tVariableDecl varDecl = getVariableInBody(name, body);\n\t\tif (varDecl != null) return varDecl;\n\t\tfor(Import imp: imports) {\n\t\t\tvarDecl = getVariableInBody(name, imp.getModule().body);\n\t\t\tif (varDecl != null) return varDecl;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate VariableDecl getVariableInBody(String name, NodeList<Node> list) {\n\t\tfor(Node node: list) {\n\t\t\tif(node instanceof Line) {\n\t\t\t\tnode = ((Line) node).getStatement();\n\t\t\t}\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tVariableDecl varDecl = (VariableDecl) node;\n\t\t\t\tif(varDecl.hasAtom(name)) return varDecl;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tvariables.add((VariableDecl) node);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl func = (FunctionDecl) node;\n\t\t\t\tif(func.isNamed(name, suffix)\n\t\t\t\t\t\t&& (call == null || call.matches(func))) return func;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getFunctions(NodeList<FunctionDecl> functions) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tfunctions.add((FunctionDecl) node);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic MultiMap<String, TypeDecl> getTypes() {\n\t\treturn types;\n\t}\n\t\n\tpublic NodeList<OpDecl> getOps() {\n\t\treturn ops;\n\t}\n\n\tpublic TypeDecl getType(String typeName) {\n\t\tTypeDecl typeDecl = getTypes().get(typeName);\n\t\tif(typeDecl != null) return typeDecl;\n\t\tfor(Import imp: imports) {\n\t\t\tModule module = imp.getModule();\n\t\t\tif(module != null) {\n\t\t\t\ttypeDecl = module.getTypes().get(typeName);\n\t\t\t\tif(typeDecl != null) return typeDecl;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ooc.middle.walkers.Nosy;\nimport org.ooc.middle.walkers.Opportunist;\nimport org.ubi.SourceReader;\n\npublic class Module extends Node implements Scope {\n\n\tprotected String underName;\n\tprotected String fullName;\n\tprotected String name;\n\tprotected NodeList<Include> includes;\n\tprotected NodeList<Import> imports;\n\tprotected NodeList<Use> uses;\n\tprotected MultiMap<String, TypeDecl> types;\n\tprotected MultiMap<String, FunctionDecl> functions;\n\tprotected NodeList<OpDecl> ops;\n\tprotected NodeList<Node> body;\n\tprotected String fileName;\n\tprotected FunctionDecl loadFunc;\n\tprivate boolean isMain;\n\tprivate final transient SourceReader reader;\n\t\n\tpublic NodeList<Node> parseStack = new NodeList<Node>();\n\t\n\tpublic long lastModified;\n\t\n\tpublic Module(String fullName, SourceReader reader) {\n\t\t\n\t\tsuper(Token.defaultToken);\n\t\tthis.reader = reader;\n\t\t\n\t\tthis.fullName = fullName; // just to make sure\n\t\tthis.fileName = fullName.replace('.', File.separatorChar);\n\t\tint index = fullName.lastIndexOf('.');\n\t\tif(index == -1) name = fullName;\n\t\telse name = fullName.substring(index + 1);\n\t\tthis.underName = \"_\"+fullName.replaceAll(\"[^a-zA-Z0-9_]\", \"_\");\n\t\t\n\t\tthis.includes = new NodeList<Include>(startToken);\n\t\tthis.imports = new NodeList<Import>(startToken);\n\t\tthis.uses = new NodeList<Use>(startToken);\n\t\tthis.body = new NodeList<Node>(startToken);\n\t\tthis.ops = new NodeList<OpDecl>();\n\t\tthis.types = new MultiMap<String, TypeDecl>();\n\t\tthis.functions = new MultiMap<String, FunctionDecl>();\n\t\t\n\t\t// set it as extern, so it won't get written implicitly\n\t\tthis.loadFunc = new FunctionDecl(underName + \"_load\", \"\", false, false, false, true, Token.defaultToken);\n\t\t\n\t}\n\t\n\tpublic String getSimpleName() {\n\t\treturn name;\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn fullName;\n\t}\n\t\n\tpublic String getFileName() {\n\t\treturn fileName;\n\t}\n\t\n\tpublic String getPath() {\n\t\treturn getPath(\".ooc\");\n\t}\n\n\tpublic String getPath(String extension) {\n\t\treturn getFileName() + extension;\n\t}\n\n\tpublic NodeList<Include> getIncludes() {\n\t\treturn includes;\n\t}\n\t\n\tpublic NodeList<Import> getImports() {\n\t\treturn imports;\n\t}\n\t\n\tpublic NodeList<Use> getUses() {\n\t\treturn uses;\n\t}\n\t\n\tpublic NodeList<Node> getBody() {\n\t\treturn body;\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tincludes.accept(visitor);\n\t\timports.accept(visitor);\n\t\tuses.accept(visitor);\n\t\tbody.accept(visitor);\n\t\ttypes.accept(visitor);\n\t\tops.accept(visitor);\n\t\tloadFunc.accept(visitor);\n\t}\n\t\n\tpublic <T extends Declaration> MultiMap<Node, T> getDeclarationsMap(final Class<T> clazz) throws IOException {\n\n\t\tfinal MultiMap<Node, T> decls = new MultiMap<Node, T>();\n\t\tthis.getDeclarationsMap(clazz, decls);\n\t\tfor(Import imp: imports) {\n\t\t\timp.getModule().getDeclarationsMap(clazz, decls);\n\t\t}\n\t\treturn decls;\n\t\t\n\t}\n\n\tprotected <T extends Declaration> void getDeclarationsMap(final Class<T> clazz,\n\t\t\tfinal MultiMap<Node, T> decls) throws IOException {\n\t\t\n\t\tnew Nosy<T> (clazz, new Opportunist<T>() {\n\t\n\t\t\t@Override\n\t\t\tpublic boolean take(T node, NodeList<Node> stack) throws IOException {\n\t\t\t\t\n\t\t\t\tint index = stack.find(Scope.class);\n\t\t\t\tif(index == -1) {\n\t\t\t\t\tthrow new Error(\"Found declaration \"+node.getName()+\" of type \"\n\t\t\t\t\t\t\t+node.getType()+\" outside of any NodeList!\");\n\t\t\t\t}\n\t\t\t\tdecls.add(stack.get(index), clazz.cast(node));\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}).visit(this);\n\t\t\n\t}\n\t\n\tpublic <T extends Declaration> NodeList<T> getDeclarationsList(final Class<T> clazz) throws IOException {\n\n\t\tfinal NodeList<T> decls = new NodeList<T>();\n\t\tthis.getDeclarationsList(clazz, decls);\n\t\tfor(Import imp: imports) {\n\t\t\timp.getModule().getDeclarationsList(clazz, decls);\n\t\t}\n\t\treturn decls;\n\t\t\n\t}\n\n\tprotected <T extends Declaration> void getDeclarationsList(final Class<T> clazz,\n\t\t\tfinal NodeList<T> decls) throws IOException {\n\t\tnew Nosy<T> (clazz, new Opportunist<T>() {\n\t\n\t\t\t@Override\n\t\t\tpublic boolean take(T node, NodeList<Node> stack) throws IOException {\n\t\t\t\t\n\t\t\t\tint index = stack.find(Scope.class);\n\t\t\t\tif(index == -1) {\n\t\t\t\t\tthrow new Error(\"Found declaration \"+node.getName()+\" of type \"\n\t\t\t\t\t\t\t+node.getType()+\" outside of any NodeList!\");\n\t\t\t\t}\n\t\t\t\tdecls.add(clazz.cast(node));\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}).visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn super.toString()+\" : \"+name;\n\t}\n\t\n\tpublic String getUnderName() {\n\t\treturn underName;\n\t}\n\n\tpublic FunctionDecl getLoadFunc() {\n\t\treturn loadFunc;\n\t}\n\n\tpublic boolean isMain() {\n\t\treturn isMain;\n\t}\n\t\n\tpublic void setMain(boolean isMain) {\n\t\tthis.isMain = isMain;\n\t}\n\n\tpublic SourceReader getReader() {\n\t\treturn reader;\n\t}\n\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tVariableDecl varDecl = getVariableInBody(name, body);\n\t\tif (varDecl != null) return varDecl;\n\t\tfor(Import imp: imports) {\n\t\t\tvarDecl = getVariableInBody(name, imp.getModule().body);\n\t\t\tif (varDecl != null) return varDecl;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate VariableDecl getVariableInBody(String name, NodeList<Node> list) {\n\t\tfor(Node node: list) {\n\t\t\tif(node instanceof Line) {\n\t\t\t\tnode = ((Line) node).getStatement();\n\t\t\t}\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tVariableDecl varDecl = (VariableDecl) node;\n\t\t\t\tif(varDecl.hasAtom(name)) return varDecl;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tvariables.add((VariableDecl) node);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call) {\n\t\treturn getFunction(name, suffix, call, 0, null);\n\t}\n\t\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call,\n\t\t\tint bestScoreParam, FunctionDecl bestMatchParam) {\n\t\tint bestScore = bestScoreParam;\n\t\tFunctionDecl bestMatch = bestMatchParam;\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl function = (FunctionDecl) node;\n\t\t\t\tif(function.isNamed(name, suffix)) { \n\t\t\t\t\tif (call == null) return function;\n\t\t\t\t\tint score = call.getScore(function);\n\t\t\t\t\tif(score > bestScore) {\n\t\t\t\t\t\tbestScore = score;\n\t\t\t\t\t\tbestMatch = function;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bestMatch;\n\t}\n\n\t@Override\n\tpublic void getFunctions(NodeList<FunctionDecl> functions) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tfunctions.add((FunctionDecl) node);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic MultiMap<String, TypeDecl> getTypes() {\n\t\treturn types;\n\t}\n\t\n\tpublic NodeList<OpDecl> getOps() {\n\t\treturn ops;\n\t}\n\n\tpublic TypeDecl getType(String typeName) {\n\t\tTypeDecl typeDecl = getTypes().get(typeName);\n\t\tif(typeDecl != null) return typeDecl;\n\t\tfor(Import imp: imports) {\n\t\t\tModule module = imp.getModule();\n\t\t\tif(module != null) {\n\t\t\t\ttypeDecl = module.getTypes().get(typeName);\n\t\t\t\tif(typeDecl != null) return typeDecl;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n}\n","lineNo":251}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport org.ooc.frontend.model.tokens.Token;\n\n\npublic abstract class TypeDecl extends Declaration implements Scope {\n\n\tprotected NodeList<VariableDecl> variables;\n\tprotected NodeList<FunctionDecl> functions;\n\t\n\tprotected String superName;\n\tprotected TypeDecl superRef;\n\t\n\tprotected Type instanceType;\n\t\n\tpublic TypeDecl(String name, String superName, Token startToken) {\n\t\tsuper(name, startToken);\n\t\tthis.superName = superName;\n\t\tthis.variables = new NodeList<VariableDecl>(startToken);\n\t\tthis.functions = new NodeList<FunctionDecl>(startToken);\n\t\tthis.instanceType = new Type(name, startToken);\n\t\tinstanceType.setRef(this);\n\t}\n\t\n\tpublic String getSuperName() {\n\t\treturn superName;\n\t}\n\t\n\tpublic void setSuperName(String superName) {\n\t\tthis.superName = superName;\n\t}\n\t\n\tpublic TypeDecl getSuperRef() {\n\t\treturn superRef;\n\t}\n\t\n\tpublic void setSuperRef(TypeDecl superRef) {\n\t\tthis.superRef = superRef;\n\t}\n\t\n\tpublic Type getInstanceType() {\n\t\treturn instanceType;\n\t}\n\t\n\tpublic boolean hasVariables() {\n\t\treturn !variables.isEmpty();\n\t}\n\t\n\tpublic boolean hasFunctions() {\n\t\treturn !functions.isEmpty();\n\t}\n\t\n\tpublic Iterable<VariableDecl> getVariables() {\n\t\treturn variables;\n\t}\n\t\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tvariables.addAll(this.variables);\n\t}\n\t\n\tpublic void addVariable(VariableDecl decl) {\n\t\tdecl.setTypeDecl(this);\n\t\tvariables.add(decl);\n\t}\n\t\n\tpublic Iterable<FunctionDecl> getFunctions() {\n\t\treturn functions;\n\t}\n\t\n\tpublic FunctionDecl getFunction(FunctionCall call) {\n\t\treturn getFunction(call.getName(), call.getSuffix(), call);\n\t}\n\t\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call, boolean recursive) {\n\t\tfor(FunctionDecl func : functions) {\n\t\t\tif(func.getName().equals(name) && (suffix.isEmpty() || func.getSuffix().equals(suffix))\n\t\t\t\t\t&& (call == null || call.matches(func))) {\n\t\t\t\treturn func;\n\t\t\t}\n\t\t}\n\t\tif(recursive && superRef != null) return superRef.getFunction(name, suffix, call);\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call) {\n\t\treturn getFunction(name, suffix, call, true);\n\t}\n\t\n\t@Override\n\tpublic void getFunctions(NodeList<FunctionDecl> functions) {\n\t\tfunctions.addAll(this.functions);\n\t}\n\t\n\tpublic void addFunction(FunctionDecl decl) {\n\t\tdecl.setTypeDecl(this);\n\t\t\n\t\tif(!decl.isStatic()) {\n\t\t\tif(shouldAddThis(decl)) {\n\t\t\t\tToken tok = decl.getArguments().isEmpty() ? startToken : decl.getArguments().getFirst().startToken;\n\t\t\t\tdecl.getArguments().add(0, new RegularArgument(getInstanceType(), \"this\",\n\t\t\t\t\t\ttok));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(decl.isSpecialFunc()) {\n\t\t\tFunctionDecl already = getFunction(decl.getName(), decl.getSuffix(), null);\n\t\t\tif(already != null) functions.remove(already);\n\t\t}\n\t\tfunctions.add(decl);\n\t}\n\n\tprivate boolean shouldAddThis(FunctionDecl decl) {\n\t\tif(decl.isStatic()) return false;\n\t\treturn true;\n\t}\n\t\n\tpublic void getFunctionsRecursive(NodeList<FunctionDecl> functions) {\n\t\tfor(FunctionDecl decl: this.functions) {\n\t\t\tboolean already = false;\n\t\t\tfor(FunctionDecl decl2: functions) {\n\t\t\t\tif(decl != decl2 && decl.sameProto(decl2)) {\n\t\t\t\t\talready = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!already) functions.add(decl);\n\t\t}\n\t\tif(superRef != null) superRef.getFunctionsRecursive(functions);\n\t}\n\t\n\tpublic VariableDecl getVariable(String name) {\n\t\tfor(VariableDecl decl: variables) {\n\t\t\tif(decl.hasAtom(name)) return decl;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic FunctionDecl getNoargFunction(String name) {\n\t\tfor(FunctionDecl decl: functions) {\n\t\t\tif(name.matches(decl.getName()) && decl.getArguments().size() == 1) return decl;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic TypeDecl getTypeDecl() {\n\t\treturn this;\n\t}\n\n\tpublic String getVariablesRepr() {\n\t\treturn variables.toString();\n\t}\n\t\n\tpublic String getFunctionsRepr() {\n\t\treturn functions.toString();\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport org.ooc.frontend.model.tokens.Token;\n\n\npublic abstract class TypeDecl extends Declaration implements Scope {\n\n\tprotected NodeList<VariableDecl> variables;\n\tprotected NodeList<FunctionDecl> functions;\n\t\n\tprotected String superName;\n\tprotected TypeDecl superRef;\n\t\n\tprotected Type instanceType;\n\t\n\tpublic TypeDecl(String name, String superName, Token startToken) {\n\t\tsuper(name, startToken);\n\t\tthis.superName = superName;\n\t\tthis.variables = new NodeList<VariableDecl>(startToken);\n\t\tthis.functions = new NodeList<FunctionDecl>(startToken);\n\t\tthis.instanceType = new Type(name, startToken);\n\t\tinstanceType.setRef(this);\n\t}\n\t\n\tpublic String getSuperName() {\n\t\treturn superName;\n\t}\n\t\n\tpublic void setSuperName(String superName) {\n\t\tthis.superName = superName;\n\t}\n\t\n\tpublic TypeDecl getSuperRef() {\n\t\treturn superRef;\n\t}\n\t\n\tpublic void setSuperRef(TypeDecl superRef) {\n\t\tthis.superRef = superRef;\n\t}\n\t\n\tpublic Type getInstanceType() {\n\t\treturn instanceType;\n\t}\n\t\n\tpublic boolean hasVariables() {\n\t\treturn !variables.isEmpty();\n\t}\n\t\n\tpublic boolean hasFunctions() {\n\t\treturn !functions.isEmpty();\n\t}\n\t\n\tpublic Iterable<VariableDecl> getVariables() {\n\t\treturn variables;\n\t}\n\t\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tvariables.addAll(this.variables);\n\t}\n\t\n\tpublic void addVariable(VariableDecl decl) {\n\t\tdecl.setTypeDecl(this);\n\t\tvariables.add(decl);\n\t}\n\t\n\tpublic Iterable<FunctionDecl> getFunctions() {\n\t\treturn functions;\n\t}\n\t\n\tpublic FunctionDecl getFunction(FunctionCall call) {\n\t\treturn getFunction(call.getName(), call.getSuffix(), call);\n\t}\n\t\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call, boolean recursive) {\n\t\treturn getFunction(name, suffix,call, recursive, 0, null);\n\t}\n\t\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call,\n\t\t\tboolean recursive, int bestScoreParam, FunctionDecl bestMatchParam) {\n\t\tint bestScore = bestScoreParam;\n\t\tFunctionDecl bestMatch = bestMatchParam;\n\t\tfor(FunctionDecl func : functions) {\n\t\t\tif(func.getName().equals(name) && (suffix.isEmpty() || func.getSuffix().equals(suffix))) {\n\t\t\t\tif(call == null) return func;\n\t\t\t\tint score = call.getScore(func);\n\t\t\t\tif(score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestMatch = func;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(recursive && superRef != null) return superRef.getFunction(name, suffix, call, true, bestScore, bestMatch);\n\t\treturn bestMatch;\n\t}\n\t\n\t@Override\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call) {\n\t\treturn getFunction(name, suffix, call, true, 0, null);\n\t}\n\t\n\t@Override\n\tpublic void getFunctions(NodeList<FunctionDecl> functions) {\n\t\tfunctions.addAll(this.functions);\n\t}\n\t\n\tpublic void addFunction(FunctionDecl decl) {\n\t\tdecl.setTypeDecl(this);\n\t\t\n\t\tif(!decl.isStatic()) {\n\t\t\tif(!decl.isStatic()) {\n\t\t\t\tToken tok = decl.getArguments().isEmpty() ? startToken : decl.getArguments().getFirst().startToken;\n\t\t\t\tdecl.getArguments().add(0, new RegularArgument(getInstanceType(), \"this\",\n\t\t\t\t\t\ttok));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(decl.isSpecialFunc()) {\n\t\t\tFunctionDecl already = getFunction(decl.getName(), decl.getSuffix(), null);\n\t\t\tif(already != null) functions.remove(already);\n\t\t}\n\t\tfunctions.add(decl);\n\t}\n\t\n\tpublic void getFunctionsRecursive(NodeList<FunctionDecl> functions) {\n\t\tfor(FunctionDecl decl: this.functions) {\n\t\t\tboolean already = false;\n\t\t\tfor(FunctionDecl decl2: functions) {\n\t\t\t\tif(decl != decl2 && decl.sameProto(decl2)) {\n\t\t\t\t\talready = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!already) functions.add(decl);\n\t\t}\n\t\tif(superRef != null) superRef.getFunctionsRecursive(functions);\n\t}\n\t\n\tpublic VariableDecl getVariable(String name) {\n\t\tfor(VariableDecl decl: variables) {\n\t\t\tif(decl.hasAtom(name)) return decl;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic FunctionDecl getNoargFunction(String name) {\n\t\tfor(FunctionDecl decl: functions) {\n\t\t\tif(name.matches(decl.getName()) && decl.getArguments().size() == 1) return decl;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic TypeDecl getTypeDecl() {\n\t\treturn this;\n\t}\n\n\tpublic String getVariablesRepr() {\n\t\treturn variables.toString();\n\t}\n\t\n\tpublic String getFunctionsRepr() {\n\t\treturn functions.toString();\n\t}\n\n}\n","lineNo":82}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\n\npublic class NodeList<T extends Node> extends Node implements Iterable<T> {\n\t\n\tT[] nodes;\n\tint size;\n\t\n\tpublic NodeList() {\n\t\tthis(Token.defaultToken);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic NodeList(Token startToken) {\n\t\tsuper(startToken);\n\t\tnodes = (T[]) new Node[10];\n\t\tsize = 0;\n\t}\n\n\tprivate void realloc() {\n\t\tnodes = Arrays.copyOf(nodes, (size * 3) / 2 + 1);\n\t}\n\t\n\tprivate void ensureCapacity(int minCapacity) {\n\t\tif(minCapacity > nodes.length) {\n\t\t\tnodes = Arrays.copyOf(nodes, minCapacity);\n\t\t}\n\t}\n\t\n\tpublic void add(T element) {\n\t\tif(size >= nodes.length) realloc();\n\t\tnodes[size++] = element;\n\t}\n\n\tpublic void add(int index, T element) {\n\t\tif(size + 1 >= nodes.length) realloc();\n\t\tSystem.arraycopy(nodes, index, nodes, index + 1, size - index);\n\t\tnodes[index] = element;\n\t\tsize++;\n\t}\n\t\n\tpublic boolean remove(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\tfastRemove(index);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic T remove(int index) {\n\t\tT o = nodes[index];\n        fastRemove(index);\n        return o;\n\t}\n\n\tprivate void fastRemove(int index) {\n\t\tint numMoved = size - index - 1;\n\t\tif (numMoved > 0) {\n            System.arraycopy(nodes, index+1, nodes, index, numMoved);\n        }\n\t\tsize--;\n\t}\n\t\n\tpublic boolean contains(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int indexOf(T lostSheep) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(lostSheep.equals(nodes[index])) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic T get(int i) {\n\t\tif(i >= size) throw new ArrayIndexOutOfBoundsException(i);\n\t\treturn nodes[i];\n\t}\n\t\n\tpublic void set(int i, T element) {\n\t\tif(i > size) throw new ArrayIndexOutOfBoundsException(i);\n\t\tnodes[i] = element;\n\t}\n\t\n\tpublic void setAll(NodeList<T> list) {\n\t\tnodes = list.nodes;\n\t}\n\t\n\tpublic T getFirst() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[0];\n\t}\n\t\n\tpublic T getLast() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic T getBeforeLast() {\n\t\tif(size <= 1) throw new ArrayIndexOutOfBoundsException(size - 1);\n\t\treturn nodes[size - 2];\n\t}\n\n\t@Override\n\tpublic Iterator<T> iterator() {\t\t\n\t\treturn new Iterator<T>() {\n\n\t\t\tint index = 0;\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < size;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\tif(index >= size) throw new ArrayIndexOutOfBoundsException(index);\n\t\t\t\treturn nodes[index++];\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tNodeList.this.remove(index);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tnodes[i].accept(visitor);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn size > 0;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tint index = indexOf((T) oldie);\n\t\tif(index == -1) {\n\t\t\tSystem.out.println(\"trying to replace \"+oldie+\" with \"+kiddo+\" in a list with \"+nodes);\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Trying to replace a \"\n\t\t\t\t\t+oldie.getClass().getName()+\" with a \"+kiddo.getClass().getSimpleName()+\n\t\t\t\t\t\" in a \"+this.getClass().getSimpleName()+\", but couldn't find node to replace in NodeList.\");\n\t\t}\n\t\tnodes[index] = (T) kiddo;\n\t\treturn true;\n\t}\n\n\tpublic void addAll(NodeList<T> list) {\n\t\tint newSize = size + list.size;\n\t\tensureCapacity(newSize);\n\t\tSystem.arraycopy(list.nodes, 0, nodes, size, list.size);\n\t\tsize = newSize;\n\t}\n\t\n\tpublic void addAll(List<T> list) {\n\t\tint newSize = size + list.size();\n\t\tensureCapacity(newSize);\n\t\tint index = size;\n\t\tfor(T o : list) {\n\t\t\tnodes[index++] = o;\n\t\t}\n\t}\n\n\tpublic T[] getNodes() {\n\t\treturn nodes;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tif(size == 0) return \"[]\";\n\t\tStringBuilder sB = new StringBuilder(\"[\");\n\t\tint index = 0;\n\t\twhile(index < size) {\n\t\t\tsB.append(nodes[index++].toString());\n\t\t\tif(index < size) sB.append(\", \");\n\t\t}\n\t\tsB.append(']');\n\t\treturn sB.toString();\n\t}\n\n\tpublic void push(T node) {\n\t\tif(size + 1 > nodes.length) realloc();\n\t\tnodes[size++] = node;\n\t}\n\t\n\t/**\n\t * Checked pop: ensures it's this node we are removing\n\t * @param coverDecl\n\t */\n\tpublic void pop(T node) {\n\t\tif(peek() == node)\n\t\t\tpop();\n\t\telse\n\t\t\tthrow new Error(\"Unmatched node in checked pop: \"+node+\". peek is \"+peek());\n\t}\n\n\tpublic void pop() {\n\t\tif(size <= 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\tsize--;\n\t}\n\n\tpublic T peek() {\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic int find(Class<?> clazz) {\n\t\treturn find(clazz, size - 1);\n\t}\n\t\t\n\tpublic int find(Class<?> clazz, int offset) {\n\t\tint i = offset;\n\t\twhile(i >= 0) {\n\t\t\tT node = nodes[i];\n\t\t\tif(clazz.isInstance(node)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tpublic Module getModule() {\n\t\treturn (Module) nodes[0];\n\t}\n\t\n\tpublic void addBefore(T beforeWhat, T kiddo) {\n\t\tint index = indexOf(beforeWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" before \"+beforeWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index, kiddo);\n\t}\n\n\tpublic void addAfter(T afterWhat, T kiddo) {\n\t\tint index = indexOf(afterWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" after \"+afterWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index + 1, kiddo);\n\t}\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\n\npublic class NodeList<T extends Node> extends Node implements Iterable<T> {\n\t\n\tT[] nodes;\n\tint size;\n\t\n\tpublic NodeList() {\n\t\tthis(Token.defaultToken);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic NodeList(Token startToken) {\n\t\tsuper(startToken);\n\t\tnodes = (T[]) new Node[10];\n\t\tsize = 0;\n\t}\n\n\tprivate void realloc() {\n\t\tnodes = Arrays.copyOf(nodes, (size * 3) / 2 + 1);\n\t}\n\t\n\tprivate void ensureCapacity(int minCapacity) {\n\t\tif(minCapacity > nodes.length) {\n\t\t\tnodes = Arrays.copyOf(nodes, minCapacity);\n\t\t}\n\t}\n\t\n\tpublic void add(T element) {\n\t\tif(size >= nodes.length) realloc();\n\t\tnodes[size++] = element;\n\t}\n\n\tpublic void add(int index, T element) {\n\t\tif(size + 1 >= nodes.length) realloc();\n\t\tSystem.arraycopy(nodes, index, nodes, index + 1, size - index);\n\t\tnodes[index] = element;\n\t\tsize++;\n\t}\n\t\n\tpublic boolean remove(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\tfastRemove(index);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic T remove(int index) {\n\t\tT o = nodes[index];\n        fastRemove(index);\n        return o;\n\t}\n\n\tprivate void fastRemove(int index) {\n\t\tint numMoved = size - index - 1;\n\t\tif (numMoved > 0) {\n            System.arraycopy(nodes, index+1, nodes, index, numMoved);\n        }\n\t\tsize--;\n\t}\n\t\n\tpublic boolean contains(T element) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(element.equals(nodes[index])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int indexOf(T lostSheep) {\n\t\tfor (int index = 0; index < size; index++) {\n\t\t\tif(lostSheep.equals(nodes[index])) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic T get(int i) {\n\t\tif(i >= size) throw new ArrayIndexOutOfBoundsException(i);\n\t\treturn nodes[i];\n\t}\n\t\n\tpublic void set(int i, T element) {\n\t\tif(i > size) throw new ArrayIndexOutOfBoundsException(i);\n\t\tnodes[i] = element;\n\t}\n\t\n\tpublic void setAll(NodeList<T> list) {\n\t\tnodes = list.nodes;\n\t}\n\t\n\tpublic T getFirst() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[0];\n\t}\n\t\n\tpublic T getLast() {\n\t\tif(size == 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic T getBeforeLast() {\n\t\tif(size <= 1) throw new ArrayIndexOutOfBoundsException(size - 1);\n\t\treturn nodes[size - 2];\n\t}\n\n\t@Override\n\tpublic Iterator<T> iterator() {\t\t\n\t\treturn new Iterator<T>() {\n\n\t\t\tint index = 0;\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < size;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\tif(index >= size) throw new ArrayIndexOutOfBoundsException(index);\n\t\t\t\treturn nodes[index++];\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tNodeList.this.remove(index);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tnodes[i].accept(visitor);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn size > 0;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\tint index = indexOf((T) oldie);\n\t\tif(index == -1) {\n\t\t\tSystem.out.println(\"trying to replace \"+oldie+\" with \"+kiddo+\" in a list with \"+nodes);\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Trying to replace a \"\n\t\t\t\t\t+oldie.getClass().getName()+\" with a \"+kiddo.getClass().getSimpleName()+\n\t\t\t\t\t\" in a \"+this.getClass().getSimpleName()+\", but couldn't find node to replace in NodeList.\");\n\t\t}\n\t\tnodes[index] = (T) kiddo;\n\t\treturn true;\n\t}\n\n\tpublic void addAll(NodeList<T> list) {\n\t\tint newSize = size + list.size;\n\t\tensureCapacity(newSize);\n\t\tSystem.arraycopy(list.nodes, 0, nodes, size, list.size);\n\t\tsize = newSize;\n\t}\n\t\n\tpublic void addAll(List<T> list) {\n\t\tint newSize = size + list.size();\n\t\tensureCapacity(newSize);\n\t\tint index = size;\n\t\tfor(T o : list) {\n\t\t\tnodes[index++] = o;\n\t\t}\n\t}\n\n\tpublic T[] getNodes() {\n\t\treturn nodes;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(false);\n\t}\n\t\n\tpublic String toString(boolean stackLike) {\n\t\treturn toString(stackLike, 0);\n\t}\n\t\n\tpublic String toString(boolean stackLike, int offset) {\n\t\tif(size == 0) return \"[]\";\n\t\tStringBuilder sB = new StringBuilder();\n\t\tif(stackLike) sB.append('\\n');\n\t\tint index = 0;\n\t\twhile(index < size) {\n\t\t\tT node = nodes[index++];\n\t\t\tif(node instanceof NodeList<?>) {\n\t\t\t\tsB.append(((NodeList<?>) node).toString(false, stackLike ? offset + index : offset));\n\t\t\t} else {\n\t\t\t\tfor(int i = 0; i < offset; i++) sB.append(\"  \");\n\t\t\t\tif(stackLike) {\n\t\t\t\t\tfor(int i = 0; i < index; i++) sB.append(\"  \");\n\t\t\t\t}\n\t\t\t\tsB.append(node.toString());\n\t\t\t}\n\t\t\tif(index < size) sB.append(\"\\n\");\n\t\t}\n\t\treturn sB.toString();\n\t}\n\n\tpublic void push(T node) {\n\t\tif(size + 1 > nodes.length) realloc();\n\t\tnodes[size++] = node;\n\t}\n\t\n\t/**\n\t * Checked pop: ensures it's this node we are removing\n\t * @param coverDecl\n\t */\n\tpublic void pop(T node) {\n\t\tif(peek() == node)\n\t\t\tpop();\n\t\telse\n\t\t\tthrow new Error(\"Unmatched node in checked pop: \"+node+\". peek is \"+peek());\n\t}\n\n\tpublic void pop() {\n\t\tif(size <= 0) throw new ArrayIndexOutOfBoundsException(0);\n\t\tsize--;\n\t}\n\n\tpublic T peek() {\n\t\treturn nodes[size - 1];\n\t}\n\t\n\tpublic int find(Class<?> clazz) {\n\t\treturn find(clazz, size - 1);\n\t}\n\t\t\n\tpublic int find(Class<?> clazz, int offset) {\n\t\tint i = offset;\n\t\twhile(i >= 0) {\n\t\t\tT node = nodes[i];\n\t\t\tif(clazz.isInstance(node)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tpublic Module getModule() {\n\t\treturn (Module) nodes[0];\n\t}\n\t\n\tpublic void addBefore(T beforeWhat, T kiddo) {\n\t\tint index = indexOf(beforeWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" before \"+beforeWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index, kiddo);\n\t}\n\n\tpublic void addAfter(T afterWhat, T kiddo) {\n\t\tint index = indexOf(afterWhat);\n\t\tif(index == -1) {\n\t\t\tthrow new Error(\"Trying to add \"+kiddo+\" after \"+afterWhat+\", but it can't be found in the list.\");\n\t\t}\n\t\tadd(index + 1, kiddo);\n\t}\n}\n","lineNo":220}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ooc.middle.walkers.Nosy;\nimport org.ooc.middle.walkers.Opportunist;\nimport org.ubi.SourceReader;\n\npublic class Module extends Node implements Scope {\n\n\tprotected String underName;\n\tprotected String fullName;\n\tprotected String name;\n\tprotected NodeList<Include> includes;\n\tprotected NodeList<Import> imports;\n\tprotected NodeList<Use> uses;\n\tprotected MultiMap<String, TypeDecl> types;\n\tprotected MultiMap<String, FunctionDecl> functions;\n\tprotected NodeList<OpDecl> ops;\n\tprotected NodeList<Node> body;\n\tprotected String fileName;\n\tprotected FunctionDecl loadFunc;\n\tprivate boolean isMain;\n\tprivate final transient SourceReader reader;\n\t\n\tpublic long lastModified;\n\t\n\tpublic Module(String fullName, SourceReader reader) {\n\t\t\n\t\tsuper(Token.defaultToken);\n\t\tthis.reader = reader;\n\t\t\n\t\tthis.fullName = fullName; // just to make sure\n\t\tthis.fileName = fullName.replace('.', File.separatorChar);\n\t\tint index = fullName.lastIndexOf('.');\n\t\tif(index == -1) name = fullName;\n\t\telse name = fullName.substring(index + 1);\n\t\tthis.underName = \"_\"+fullName.replaceAll(\"[^a-zA-Z0-9_]\", \"_\");\n\t\t\n\t\tthis.includes = new NodeList<Include>(startToken);\n\t\tthis.imports = new NodeList<Import>(startToken);\n\t\tthis.uses = new NodeList<Use>(startToken);\n\t\tthis.body = new NodeList<Node>(startToken);\n\t\tthis.ops = new NodeList<OpDecl>();\n\t\tthis.types = new MultiMap<String, TypeDecl>();\n\t\tthis.functions = new MultiMap<String, FunctionDecl>();\n\t\t\n\t\t// set it as extern, so it won't get written implicitly\n\t\tthis.loadFunc = new FunctionDecl(underName + \"_load\", \"\", false, false, false, true, Token.defaultToken);\n\t\t\n\t}\n\t\n\tpublic String getSimpleName() {\n\t\treturn name;\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn fullName;\n\t}\n\t\n\tpublic String getFileName() {\n\t\treturn fileName;\n\t}\n\t\n\tpublic String getPath() {\n\t\treturn getPath(\".ooc\");\n\t}\n\n\tpublic String getPath(String extension) {\n\t\treturn getFileName() + extension;\n\t}\n\n\tpublic NodeList<Include> getIncludes() {\n\t\treturn includes;\n\t}\n\t\n\tpublic NodeList<Import> getImports() {\n\t\treturn imports;\n\t}\n\t\n\tpublic NodeList<Use> getUses() {\n\t\treturn uses;\n\t}\n\t\n\tpublic NodeList<Node> getBody() {\n\t\treturn body;\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tincludes.accept(visitor);\n\t\timports.accept(visitor);\n\t\tuses.accept(visitor);\n\t\tbody.accept(visitor);\n\t\ttypes.accept(visitor);\n\t\tops.accept(visitor);\n\t\tloadFunc.accept(visitor);\n\t}\n\t\n\tpublic <T extends Declaration> MultiMap<Node, T> getDeclarationsMap(final Class<T> clazz) throws IOException {\n\n\t\tfinal MultiMap<Node, T> decls = new MultiMap<Node, T>();\n\t\tthis.getDeclarationsMap(clazz, decls);\n\t\tfor(Import imp: imports) {\n\t\t\timp.getModule().getDeclarationsMap(clazz, decls);\n\t\t}\n\t\treturn decls;\n\t\t\n\t}\n\n\tprotected <T extends Declaration> void getDeclarationsMap(final Class<T> clazz,\n\t\t\tfinal MultiMap<Node, T> decls) throws IOException {\n\t\t\n\t\tnew Nosy<T> (clazz, new Opportunist<T>() {\n\t\n\t\t\t@Override\n\t\t\tpublic boolean take(T node, NodeList<Node> stack) throws IOException {\n\t\t\t\t\n\t\t\t\tint index = stack.find(Scope.class);\n\t\t\t\tif(index == -1) {\n\t\t\t\t\tthrow new Error(\"Found declaration \"+node.getName()+\" of type \"\n\t\t\t\t\t\t\t+node.getType()+\" outside of any NodeList!\");\n\t\t\t\t}\n\t\t\t\tdecls.add(stack.get(index), clazz.cast(node));\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}).visit(this);\n\t\t\n\t}\n\t\n\tpublic <T extends Declaration> NodeList<T> getDeclarationsList(final Class<T> clazz) throws IOException {\n\n\t\tfinal NodeList<T> decls = new NodeList<T>();\n\t\tthis.getDeclarationsList(clazz, decls);\n\t\tfor(Import imp: imports) {\n\t\t\timp.getModule().getDeclarationsList(clazz, decls);\n\t\t}\n\t\treturn decls;\n\t\t\n\t}\n\n\tprotected <T extends Declaration> void getDeclarationsList(final Class<T> clazz,\n\t\t\tfinal NodeList<T> decls) throws IOException {\n\t\tnew Nosy<T> (clazz, new Opportunist<T>() {\n\t\n\t\t\t@Override\n\t\t\tpublic boolean take(T node, NodeList<Node> stack) throws IOException {\n\t\t\t\t\n\t\t\t\tint index = stack.find(Scope.class);\n\t\t\t\tif(index == -1) {\n\t\t\t\t\tthrow new Error(\"Found declaration \"+node.getName()+\" of type \"\n\t\t\t\t\t\t\t+node.getType()+\" outside of any NodeList!\");\n\t\t\t\t}\n\t\t\t\tdecls.add(clazz.cast(node));\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}).visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn super.toString()+\" : \"+name;\n\t}\n\t\n\tpublic String getUnderName() {\n\t\treturn underName;\n\t}\n\n\tpublic FunctionDecl getLoadFunc() {\n\t\treturn loadFunc;\n\t}\n\n\tpublic boolean isMain() {\n\t\treturn isMain;\n\t}\n\t\n\tpublic void setMain(boolean isMain) {\n\t\tthis.isMain = isMain;\n\t}\n\n\tpublic SourceReader getReader() {\n\t\treturn reader;\n\t}\n\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tVariableDecl varDecl = getVariableInBody(name, body);\n\t\tif (varDecl != null) return varDecl;\n\t\tfor(Import imp: imports) {\n\t\t\tvarDecl = getVariableInBody(name, imp.getModule().body);\n\t\t\tif (varDecl != null) return varDecl;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate VariableDecl getVariableInBody(String name, NodeList<Node> list) {\n\t\tfor(Node node: list) {\n\t\t\tif(node instanceof Line) {\n\t\t\t\tnode = ((Line) node).getStatement();\n\t\t\t}\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tVariableDecl varDecl = (VariableDecl) node;\n\t\t\t\tif(varDecl.hasAtom(name)) return varDecl;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tvariables.add((VariableDecl) node);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl func = (FunctionDecl) node;\n\t\t\t\tif(func.isNamed(name, suffix)\n\t\t\t\t\t\t&& (call == null || call.matches(func))) return func;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getFunctions(NodeList<FunctionDecl> functions) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tfunctions.add((FunctionDecl) node);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic MultiMap<String, TypeDecl> getTypes() {\n\t\treturn types;\n\t}\n\t\n\tpublic NodeList<OpDecl> getOps() {\n\t\treturn ops;\n\t}\n\n\tpublic TypeDecl getType(String typeName) {\n\t\tTypeDecl typeDecl = getTypes().get(typeName);\n\t\tif(typeDecl != null) return typeDecl;\n\t\tfor(Import imp: imports) {\n\t\t\ttypeDecl = imp.getModule().getTypes().get(typeName);\n\t\t\tif(typeDecl != null) return typeDecl;\n\t\t}\n\t\treturn null;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.structs.MultiMap;\nimport org.ooc.middle.walkers.Nosy;\nimport org.ooc.middle.walkers.Opportunist;\nimport org.ubi.SourceReader;\n\npublic class Module extends Node implements Scope {\n\n\tprotected String underName;\n\tprotected String fullName;\n\tprotected String name;\n\tprotected NodeList<Include> includes;\n\tprotected NodeList<Import> imports;\n\tprotected NodeList<Use> uses;\n\tprotected MultiMap<String, TypeDecl> types;\n\tprotected MultiMap<String, FunctionDecl> functions;\n\tprotected NodeList<OpDecl> ops;\n\tprotected NodeList<Node> body;\n\tprotected String fileName;\n\tprotected FunctionDecl loadFunc;\n\tprivate boolean isMain;\n\tprivate final transient SourceReader reader;\n\t\n\tpublic long lastModified;\n\t\n\tpublic Module(String fullName, SourceReader reader) {\n\t\t\n\t\tsuper(Token.defaultToken);\n\t\tthis.reader = reader;\n\t\t\n\t\tthis.fullName = fullName; // just to make sure\n\t\tthis.fileName = fullName.replace('.', File.separatorChar);\n\t\tint index = fullName.lastIndexOf('.');\n\t\tif(index == -1) name = fullName;\n\t\telse name = fullName.substring(index + 1);\n\t\tthis.underName = \"_\"+fullName.replaceAll(\"[^a-zA-Z0-9_]\", \"_\");\n\t\t\n\t\tthis.includes = new NodeList<Include>(startToken);\n\t\tthis.imports = new NodeList<Import>(startToken);\n\t\tthis.uses = new NodeList<Use>(startToken);\n\t\tthis.body = new NodeList<Node>(startToken);\n\t\tthis.ops = new NodeList<OpDecl>();\n\t\tthis.types = new MultiMap<String, TypeDecl>();\n\t\tthis.functions = new MultiMap<String, FunctionDecl>();\n\t\t\n\t\t// set it as extern, so it won't get written implicitly\n\t\tthis.loadFunc = new FunctionDecl(underName + \"_load\", \"\", false, false, false, true, Token.defaultToken);\n\t\t\n\t}\n\t\n\tpublic String getSimpleName() {\n\t\treturn name;\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn fullName;\n\t}\n\t\n\tpublic String getFileName() {\n\t\treturn fileName;\n\t}\n\t\n\tpublic String getPath() {\n\t\treturn getPath(\".ooc\");\n\t}\n\n\tpublic String getPath(String extension) {\n\t\treturn getFileName() + extension;\n\t}\n\n\tpublic NodeList<Include> getIncludes() {\n\t\treturn includes;\n\t}\n\t\n\tpublic NodeList<Import> getImports() {\n\t\treturn imports;\n\t}\n\t\n\tpublic NodeList<Use> getUses() {\n\t\treturn uses;\n\t}\n\t\n\tpublic NodeList<Node> getBody() {\n\t\treturn body;\n\t}\n\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tincludes.accept(visitor);\n\t\timports.accept(visitor);\n\t\tuses.accept(visitor);\n\t\tbody.accept(visitor);\n\t\ttypes.accept(visitor);\n\t\tops.accept(visitor);\n\t\tloadFunc.accept(visitor);\n\t}\n\t\n\tpublic <T extends Declaration> MultiMap<Node, T> getDeclarationsMap(final Class<T> clazz) throws IOException {\n\n\t\tfinal MultiMap<Node, T> decls = new MultiMap<Node, T>();\n\t\tthis.getDeclarationsMap(clazz, decls);\n\t\tfor(Import imp: imports) {\n\t\t\timp.getModule().getDeclarationsMap(clazz, decls);\n\t\t}\n\t\treturn decls;\n\t\t\n\t}\n\n\tprotected <T extends Declaration> void getDeclarationsMap(final Class<T> clazz,\n\t\t\tfinal MultiMap<Node, T> decls) throws IOException {\n\t\t\n\t\tnew Nosy<T> (clazz, new Opportunist<T>() {\n\t\n\t\t\t@Override\n\t\t\tpublic boolean take(T node, NodeList<Node> stack) throws IOException {\n\t\t\t\t\n\t\t\t\tint index = stack.find(Scope.class);\n\t\t\t\tif(index == -1) {\n\t\t\t\t\tthrow new Error(\"Found declaration \"+node.getName()+\" of type \"\n\t\t\t\t\t\t\t+node.getType()+\" outside of any NodeList!\");\n\t\t\t\t}\n\t\t\t\tdecls.add(stack.get(index), clazz.cast(node));\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}).visit(this);\n\t\t\n\t}\n\t\n\tpublic <T extends Declaration> NodeList<T> getDeclarationsList(final Class<T> clazz) throws IOException {\n\n\t\tfinal NodeList<T> decls = new NodeList<T>();\n\t\tthis.getDeclarationsList(clazz, decls);\n\t\tfor(Import imp: imports) {\n\t\t\timp.getModule().getDeclarationsList(clazz, decls);\n\t\t}\n\t\treturn decls;\n\t\t\n\t}\n\n\tprotected <T extends Declaration> void getDeclarationsList(final Class<T> clazz,\n\t\t\tfinal NodeList<T> decls) throws IOException {\n\t\tnew Nosy<T> (clazz, new Opportunist<T>() {\n\t\n\t\t\t@Override\n\t\t\tpublic boolean take(T node, NodeList<Node> stack) throws IOException {\n\t\t\t\t\n\t\t\t\tint index = stack.find(Scope.class);\n\t\t\t\tif(index == -1) {\n\t\t\t\t\tthrow new Error(\"Found declaration \"+node.getName()+\" of type \"\n\t\t\t\t\t\t\t+node.getType()+\" outside of any NodeList!\");\n\t\t\t\t}\n\t\t\t\tdecls.add(clazz.cast(node));\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}).visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn super.toString()+\" : \"+name;\n\t}\n\t\n\tpublic String getUnderName() {\n\t\treturn underName;\n\t}\n\n\tpublic FunctionDecl getLoadFunc() {\n\t\treturn loadFunc;\n\t}\n\n\tpublic boolean isMain() {\n\t\treturn isMain;\n\t}\n\t\n\tpublic void setMain(boolean isMain) {\n\t\tthis.isMain = isMain;\n\t}\n\n\tpublic SourceReader getReader() {\n\t\treturn reader;\n\t}\n\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tVariableDecl varDecl = getVariableInBody(name, body);\n\t\tif (varDecl != null) return varDecl;\n\t\tfor(Import imp: imports) {\n\t\t\tvarDecl = getVariableInBody(name, imp.getModule().body);\n\t\t\tif (varDecl != null) return varDecl;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate VariableDecl getVariableInBody(String name, NodeList<Node> list) {\n\t\tfor(Node node: list) {\n\t\t\tif(node instanceof Line) {\n\t\t\t\tnode = ((Line) node).getStatement();\n\t\t\t}\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tVariableDecl varDecl = (VariableDecl) node;\n\t\t\t\tif(varDecl.hasAtom(name)) return varDecl;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tvariables.add((VariableDecl) node);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tFunctionDecl func = (FunctionDecl) node;\n\t\t\t\tif(func.isNamed(name, suffix)\n\t\t\t\t\t\t&& (call == null || call.matches(func))) return func;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getFunctions(NodeList<FunctionDecl> functions) {\n\t\tfor(Node node: body) {\n\t\t\tif(node instanceof FunctionDecl) {\n\t\t\t\tfunctions.add((FunctionDecl) node);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic MultiMap<String, TypeDecl> getTypes() {\n\t\treturn types;\n\t}\n\t\n\tpublic NodeList<OpDecl> getOps() {\n\t\treturn ops;\n\t}\n\n\tpublic TypeDecl getType(String typeName) {\n\t\tTypeDecl typeDecl = getTypes().get(typeName);\n\t\tif(typeDecl != null) return typeDecl;\n\t\tfor(Import imp: imports) {\n\t\t\tModule module = imp.getModule();\n\t\t\tif(module != null) {\n\t\t\t\ttypeDecl = module.getTypes().get(typeName);\n\t\t\t\tif(typeDecl != null) return typeDecl;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n}\n","lineNo":274}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.ooc.frontend.model.*;\n\npublic class ClassDeclWriter {\n\t\n\tpublic static void write(ClassDecl classDecl, CGenerator cgen) throws IOException {\n\t\t\n\t\tcgen.current = cgen.hw;\n\t\t\n\t\tString className = classDecl.getName();\n\t\t\n\t\twriteObjectStruct(classDecl, className, cgen);\n\t\twriteClassStruct(classDecl, className, cgen);\n\t\twriteMemberFuncPrototypes(classDecl, className, cgen);\n\t\t\n\t\t/* Now implementations */\n\t\tcgen.current = cgen.cw;\n\t\tcgen.current.nl();\n\t\t\n\t\twriteInitializeClassFunc(classDecl, className, cgen);\n\t\twriteDestroyFunc(classDecl, className, cgen);\n\t\twriteInstanceImplFuncs(classDecl, className, cgen);\n\t\twriteClassGettingFunction(classDecl, cgen);\n\t\twriteInstanceVirtualFuncs(classDecl, className, cgen);\n\t\twriteStaticFuncs(classDecl, className, cgen);\n\t\t\n\t\tcgen.current.nl();\n\t\t\n\t}\n\n\tpublic static void writeTypelessFuncArgs(FunctionDecl decl, CGenerator cgen)\n\t\t\tthrows IOException {\n\n\t\tcgen.current.app('(');\n\t\tIterator<Argument> iter = decl.getArguments().iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tcgen.current.app(iter.next().getName());\n\t\t\tif (iter.hasNext())\n\t\t\t\tcgen.current.app(\", \");\n\t\t}\n\t\tcgen.current.app(')');\n\n\t}\n\n\tpublic static void writeStaticFuncs(ClassDecl classDecl, String className,\n\t\t\tCGenerator cgen) throws IOException {\n\n\t\tfor (FunctionDecl decl : classDecl.getFunctions()) {\n\n\t\t\tif (!decl.isStatic())\n\t\t\t\tcontinue;\n\n\t\t\tcgen.current.nl();\n\t\t\t//writeMemberFuncPrototype(className, decl, cgen);\n\t\t\tFunctionDeclWriter.writeFuncPrototype(decl, cgen);\n\t\t\tcgen.current.openBlock();\n\t\t\tdecl.getBody().accept(cgen);\n\t\t\tcgen.current.closeSpacedBlock();\n\n\t\t}\n\t}\n\n\tpublic static void writeInstanceVirtualFuncs(ClassDecl classDecl,\n\t\t\tString className, CGenerator cgen) throws IOException {\n\n\t\tfor (FunctionDecl decl : classDecl.getFunctions()) {\n\n\t\t\tif (decl.isStatic() || decl.isFinal())\n\t\t\t\tcontinue;\n\n\t\t\tcgen.current.nl();\n\t\t\tFunctionDeclWriter.writeFuncPrototype(decl, cgen);\n\t\t\tcgen.current.openSpacedBlock();\n\n\t\t\tif (!decl.getReturnType().isVoid())\n\t\t\t\tcgen.current.app(\"return \");\n\t\t\tcgen.current.app(\"((\").app(className).app(\n\t\t\t\t\t\"Class *)((Object *)this)->class)->\");\n\t\t\tdecl.writeSuffixedName(cgen.current);\n\n\t\t\twriteTypelessFuncArgs(decl, cgen);\n\t\t\tcgen.current.app(\";\").closeSpacedBlock();\n\n\t\t}\n\t}\n\n\tpublic static void writeBuiltinClassFuncName(String className,\n\t\t\tString returnType, String name, CGenerator cgen) throws IOException {\n\t\tcgen.current.nl().app(\"static \").app(returnType).app(' ')\n\t\t\t\t.app(className).app('_').app(name).app('(').app(className).app(\n\t\t\t\t\t\t\" *this)\");\n\t}\n\n\tpublic static void writeInitializeClassFunc(ClassDecl classDecl,\n\t\t\tString className, CGenerator cgen) throws IOException {\n\n\t\twriteBuiltinClassFuncName(className, \"void\", \"initialize\", cgen);\n\t\tcgen.current.openBlock();\n\t\tif (!classDecl.getSuperName().isEmpty()) {\n\t\t\tcgen.current.nl();\n\t\t\tcgen.current.app(classDecl.getSuperName());\n\t\t\tcgen.current.app(\"_class()->initialize((Object *) this);\");\n\t\t}\n\t\tfor (Line line : classDecl.getInitializeFunc().getBody())\n\t\t\tline.accept(cgen);\n\t\tcgen.current.closeSpacedBlock();\n\n\t\tcgen.current.nl().app(\"void \").app(className).app(\"_load()\")\n\t\t\t\t.openBlock();\n\t\tcgen.current.nl().app(\"static bool __done__ = false;\").nl().app(\n\t\t\t\t\"if (!__done__)\").openBlock();\n\t\tcgen.current.nl().app(\"__done__ = true;\");\n\t\tfor (Line line : classDecl.getLoadFunc().getBody()) {\n\t\t\tline.accept(cgen);\n\t\t}\n\t\tcgen.current.closeBlock().closeSpacedBlock();\n\n\t}\n\n\tpublic static void writeDestroyFunc(ClassDecl classDecl, String className,\n\t\t\tCGenerator cgen) throws IOException {\n\n\t\tcgen.current.nl();\n\t\twriteBuiltinClassFuncName(className, \"void\", \"destroy\", cgen);\n\t\tcgen.current.openBlock().openSpacedBlock();\n\t\tcgen.current\n\t\t\t\t.app(\"const Class *super = ((Object *) this)->class->super;\");\n\t\tcgen.current.nl().app(\"if(super) super->destroy((Object *) this);\");\n\t\tcgen.current.closeSpacedBlock().closeSpacedBlock();\n\t}\n\n\tpublic static void writeInstanceImplFuncs(ClassDecl classDecl,\n\t\t\tString className, CGenerator cgen) throws IOException {\n\n\t\t// Non-static (ie. instance) functions\n\t\tfor (FunctionDecl decl : classDecl.getFunctions()) {\n\t\t\tif (decl.isStatic() || decl.isAbstract())\n\t\t\t\tcontinue;\n\n\t\t\tcgen.current.nl();\n\t\t\tif (!decl.isFinal())\n\t\t\t\tcgen.current.app(\"static \");\n\t\t\tTypeWriter.writeSpaced(decl.getReturnType(), cgen);\n\t\t\tdecl.writeFullName(cgen.current);\n\t\t\tif (!decl.isFinal())\n\t\t\t\tcgen.current.app(\"_impl\");\n\n\t\t\tFunctionDeclWriter.writeFuncArgs(decl, cgen);\n\n\t\t\tcgen.current.openBlock();\n\n\t\t\t/* Special case: constructor */\n\t\t\tif (decl.isConstructor()) {\n\t\t\t\tcgen.current.nl().app(className).app(\" *this = (\").app(\n\t\t\t\t\t\tclassName).app(\" *) Class_newInstance((Class *)\").app(\n\t\t\t\t\t\tclassName).app(\"_class());\");\n\t\t\t\tcgen.current.nl().app(className).app(\"_construct\");\n\t\t\t\tif (!decl.getSuffix().isEmpty())\n\t\t\t\t\tcgen.current.app('_').app(decl.getSuffix());\n\t\t\t\twriteTypelessFuncArgs(decl, cgen);\n\t\t\t\tcgen.current.app(\";\").nl().app(\"return this;\");\n\t\t\t} else {\n\t\t\t\tdecl.getBody().accept(cgen);\n\t\t\t}\n\t\t\tcgen.current.closeSpacedBlock();\n\n\t\t\t// Special case: constructor, now write the corresponding construct\n\t\t\tif (decl.isConstructor()) {\n\t\t\t\tcgen.current.app(\"void \").app(className).app(\"_construct\");\n\t\t\t\tif (!decl.getSuffix().isEmpty())\n\t\t\t\t\tcgen.current.app('_').app(decl.getSuffix());\n\t\t\t\tFunctionDeclWriter.writeFuncArgs(decl, cgen, false);\n\t\t\t\tcgen.current.openBlock();\n\t\t\t\tfor (Line line : decl.getBody())\n\t\t\t\t\tline.accept(cgen);\n\t\t\t\tcgen.current.closeSpacedBlock();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void writeClassGettingFunction(ClassDecl classDecl,\n\t\t\tCGenerator cgen) throws IOException {\n\n\t\tcgen.current.app(\"Class *\").app(classDecl.getName()).app(\"_class()\")\n\t\t\t\t.openSpacedBlock();\n\t\tif (!classDecl.getSuperName().isEmpty())\n\t\t\tcgen.current.app(\"static bool __done__ = false;\").nl();\n\t\tcgen.current.app(\"static \").app(classDecl.getName()).app(\n\t\t\t\t\"Class class = \");\n\t\twriteFuncPointers(classDecl, classDecl, cgen);\n\t\tcgen.current.app(';');\n\t\tcgen.current.nl().app(\"Class *classPtr = (Class *) &class;\");\n\t\tif (!classDecl.getSuperName().isEmpty()) {\n\t\t\tcgen.current.nl().app(\"if(!__done__)\").openBlock().nl().app(\n\t\t\t\t\t\"__done__ = true;\").nl().app(\"classPtr->super = \").app(\n\t\t\t\t\tclassDecl.getSuperName()).app(\"_class();\").closeBlock();\n\t\t}\n\n\t\tcgen.current.nl().app(\"return classPtr;\").closeSpacedBlock();\n\t}\n\n\tpublic static void writeFuncPointers(ClassDecl writerClass,\n\t\t\tClassDecl coreClass, CGenerator cgen) throws IOException {\n\n\t\tcgen.current.openBlock();\n\n\t\tif (!writerClass.isRootClass() && !writerClass.getSuperName().isEmpty()) {\n\n\t\t\twriteFuncPointers(writerClass.getSuperRef(), coreClass, cgen);\n\n\t\t} else {\n\n\t\t\tcgen.current.openBlock();\n\t\t\tcgen.current.nl().app(\".size = \").app(\"sizeof(\").app(\n\t\t\t\t\tcoreClass.getName()).app(\"),\");\n\t\t\tcgen.current.nl().app(\".name = \").app('\"').app(coreClass.getName())\n\t\t\t\t\t.app(\"\\\",\");\n\t\t\twriteDesignatedInit(\"initialize\", \"(void (*)(Object *))\"\n\t\t\t\t\t+ coreClass.getName() + \"_initialize\", cgen);\n\t\t\twriteDesignatedInit(\"destroy\", \"(void (*)(Object *))\"\n\t\t\t\t\t+ coreClass.getName() + \"_destroy\", cgen);\n\n\t\t\tcgen.current.closeBlock().app(',');\n\n\t\t}\n\n\t\tfor (FunctionDecl decl : writerClass.getFunctions()) {\n\t\t\tif (decl.isStatic() || decl.isConstructor())\n\t\t\t\tcontinue;\n\n\t\t\tif (decl.isFinal() || decl.isAbstract()) {\n\t\t\t\twriteDesignatedInit(decl.getSuffixedName(), writerClass.getName() + \"_\"\n\t\t\t\t\t\t+ decl.getSuffixedName(), cgen);\n\t\t\t} else {\n\t\t\t\twriteDesignatedInit(decl.getSuffixedName(), writerClass.getName() + \"_\"\n\t\t\t\t\t\t+ decl.getSuffixedName() + \"_impl\", cgen);\n\t\t\t}\n\n\t\t}\n\n\t\tcgen.current.closeBlock();\n\t\tif (coreClass != writerClass)\n\t\t\tcgen.current.app(',');\n\t}\n\n\tpublic static void writeMemberFuncPrototypes(ClassDecl classDecl,\n\t\t\tString className, CGenerator cgen) throws IOException {\n\n\t\tcgen.current.nl().app(\"Class *\").app(className).app(\"_class();\").nl();\n\t\tfor (FunctionDecl decl : classDecl.getFunctions()) {\n\t\t\tcgen.current.nl();\n\t\t\tTypeWriter.writeSpaced(decl.getReturnType(), cgen);\n\t\t\tdecl.writeFullName(cgen.current);\n\t\t\tFunctionDeclWriter.writeFuncArgs(decl, cgen);\n\t\t\tcgen.current.app(';');\n\n\t\t\tif (decl.getName().equals(\"new\")) {\n\t\t\t\tcgen.current.nl().app(\"void \").app(className).app(\"_construct\");\n\t\t\t\tif (!decl.getSuffix().isEmpty())\n\t\t\t\t\tcgen.current.app('_').app(decl.getSuffix());\n\t\t\t\tFunctionDeclWriter.writeFuncArgs(decl, cgen, false);\n\t\t\t\tcgen.current.app(';');\n\t\t\t}\n\t\t}\n\t\tcgen.current.nl();\n\t}\n\n\tpublic static void writeFuncPointer(FunctionDecl decl, CGenerator cgen)\n\t\t\tthrows IOException {\n\t\tdecl.getReturnType().accept(cgen);\n\t\tcgen.current.app(\" (*\");\n\t\tdecl.writeSuffixedName(cgen.current);\n\t\tcgen.current.app(\")(\");\n\t\tint numArgs = decl.getArguments().size() - 1;\n\t\tNode[] args = decl.getArguments().getNodes();\n\t\tfor (int i = 0; i <= numArgs; i++) {\n\t\t\targs[i].accept(cgen);\n\t\t\tif (i < numArgs)\n\t\t\t\tcgen.current.app(\", \");\n\t\t}\n\t\tcgen.current.app(')');\n\t}\n\n\tpublic static void writeClassStruct(ClassDecl classDecl, String className, CGenerator cgen)\n\t\t\tthrows IOException {\n\n\t\tcgen.current.nl().app(\"struct _\").app(className).app(\"Class\")\n\t\t\t\t.openSpacedBlock();\n\t\tif (classDecl.isRootClass()) {\n\t\t\tcgen.current.app(\"struct _Class __super__;\");\n\t\t} else {\n\t\t\tcgen.current.app(\"struct _\").app(classDecl.getSuperName()).app(\n\t\t\t\t\t\"Class __super__;\");\n\t\t}\n\n\t\t/* Now write all virtual functions prototypes in the class struct */\n\t\tfor (FunctionDecl decl : classDecl.getFunctions()) {\n\t\t\tif (decl.isStatic() || decl.isConstructor())\n\t\t\t\tcontinue;\n\t\t\tcgen.current.nl();\n\t\t\twriteFuncPointer(decl, cgen);\n\t\t\tcgen.current.app(';');\n\t\t}\n\t\tcgen.current.closeBlock().app(';').nl().nl();\n\t}\n\n\tpublic static void writeObjectStruct(ClassDecl classDecl, String className, CGenerator cgen)\n\t\t\tthrows IOException {\n\t\tcgen.current.nl().app(\"struct _\").app(className).openSpacedBlock();\n\n\t\tif (classDecl.isClassClass()) {\n\t\t\tcgen.current.app(\"Class *class;\");\n\t\t} else if (!classDecl.isObjectClass()) {\n\t\t\tcgen.current.app(\"struct _\").app(classDecl.getSuperName()).app(\n\t\t\t\t\t\" __super__;\");\n\t\t}\n\n\t\tfor (VariableDecl decl : classDecl.getVariables()) {\n\t\t\tif (decl.isStatic())\n\t\t\t\tcontinue;\n\t\t\tcgen.current.nl();\n\t\t\tdecl.accept(cgen);\n\t\t\tcgen.current.app(';');\n\t\t}\n\n\t\tcgen.current.closeBlock().app(';').nl().nl();\n\n\t\tfor (VariableDecl decl : classDecl.getVariables()) {\n\t\t\tif (!decl.isStatic())\n\t\t\t\tcontinue;\n\t\t\tcgen.current.nl();\n\t\t\tdecl.accept(cgen);\n\t\t\tcgen.current.app(';');\n\t\t}\n\t}\n\n\tpublic static void writeStructTypedef(String structName, CGenerator cgen) throws IOException {\n\t\tcgen.current.nl().app(\"struct _\").app(structName).app(\";\");\n\t\tcgen.current.nl().app(\"typedef struct _\").app(structName).app(\" \").app(\n\t\t\t\tstructName).app(\";\");\n\t}\n\n\tpublic static void writeDesignatedInit(String contract, String implementation, CGenerator cgen)\n\t\t\tthrows IOException {\n\t\tcgen.current.nl().app('.').app(contract).app(\" = \").app(implementation).app(\n\t\t\t\t',');\n\t}\n\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport org.ooc.frontend.model.Argument;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.Node;\nimport org.ooc.frontend.model.VariableDecl;\n\npublic class ClassDeclWriter {\n\t\n\tpublic static void write(ClassDecl classDecl, CGenerator cgen) throws IOException {\n\t\t\n\t\tcgen.current = cgen.hw;\n\t\t\n\t\twriteObjectStruct(classDecl, cgen);\n\t\twriteClassStruct(classDecl, cgen);\n\t\twriteMemberFuncPrototypes(classDecl, cgen);\n\t\t\n\t\t/* Now implementations */\n\t\tcgen.current = cgen.cw;\n\t\tcgen.current.nl();\n\t\t\n\t\twriteInstanceImplFuncs(classDecl, cgen);\n\t\twriteClassGettingFunction(classDecl, cgen);\n\t\twriteInstanceVirtualFuncs(classDecl, cgen);\n\t\twriteStaticFuncs(classDecl, cgen);\n\t\t\n\t\tcgen.current.nl();\n\t\t\n\t}\n\n\tpublic static void writeTypelessFuncArgs(FunctionDecl decl, ClassDecl baseClass, CGenerator cgen)\n\t\t\tthrows IOException {\n\n\t\tboolean isFirst = true;\n\t\t\n\t\tcgen.current.app('(');\n\t\tIterator<Argument> iter = decl.getArguments().iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tArgument arg = iter.next();\n\t\t\tif(isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t\tif(arg.getName().equals(\"this\")) {\n\t\t\t\t\tcgen.current.app(\"(\");\n\t\t\t\t\tbaseClass.getType().accept(cgen);\n\t\t\t\t\tcgen.current.app(\") \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcgen.current.app(arg.getName());\n\t\t\tif (iter.hasNext())\n\t\t\t\tcgen.current.app(\", \");\n\t\t}\n\t\tcgen.current.app(')');\n\n\t}\n\n\tpublic static void writeStaticFuncs(ClassDecl classDecl, CGenerator cgen) throws IOException {\n\n\t\tfor (FunctionDecl decl : classDecl.getFunctions()) {\n\n\t\t\tif (!decl.isStatic())\n\t\t\t\tcontinue;\n\n\t\t\tcgen.current.nl();\n\t\t\tFunctionDeclWriter.writeFuncPrototype(decl, cgen);\n\t\t\tcgen.current.openBlock();\n\t\t\tdecl.getBody().accept(cgen);\n\t\t\tcgen.current.closeSpacedBlock();\n\n\t\t}\n\t}\n\n\tpublic static void writeInstanceVirtualFuncs(ClassDecl classDecl,\n\t\t\tCGenerator cgen) throws IOException {\n\n\t\tfor (FunctionDecl decl : classDecl.getFunctions()) {\n\n\t\t\tif (decl.isStatic() || decl.isFinal())\n\t\t\t\tcontinue;\n\n\t\t\tcgen.current.nl();\n\t\t\tFunctionDeclWriter.writeFuncPrototype(decl, cgen);\n\t\t\tcgen.current.openSpacedBlock();\n\n\t\t\tClassDecl baseClass = classDecl.getBaseClass(decl);\n\t\t\t\n\t\t\tif (!decl.getReturnType().isVoid())\n\t\t\t\tcgen.current.app(\"return \");\n\t\t\tcgen.current.app(\"((\").app(baseClass.getName()).app(\n\t\t\t\t\t\"Class *)((Object *)this)->class)->\");\n\t\t\tdecl.writeSuffixedName(cgen.current);\n\n\t\t\twriteTypelessFuncArgs(decl, baseClass, cgen);\n\t\t\tcgen.current.app(\";\").closeSpacedBlock();\n\n\t\t}\n\t}\n\n\tpublic static void writeBuiltinClassFuncName(String className,\n\t\t\tString returnType, String name, CGenerator cgen) throws IOException {\n\t\tcgen.current.nl().app(\"static \").app(returnType).app(' ')\n\t\t\t\t.app(className).app('_').app(name).app('(').app(className).app(\n\t\t\t\t\t\t\" *this)\");\n\t}\n\n\tpublic static void writeInstanceImplFuncs(ClassDecl classDecl,\n\t\t\tCGenerator cgen) throws IOException {\n\n\t\t// Non-static (ie. instance) functions\n\t\tfor (FunctionDecl decl : classDecl.getFunctions()) {\n\t\t\tif (decl.isStatic() || decl.isAbstract())\n\t\t\t\tcontinue;\n\n\t\t\tcgen.current.nl();\n\t\t\tif (!decl.isFinal())\n\t\t\t\tcgen.current.app(\"static \");\n\t\t\tTypeWriter.writeSpaced(decl.getReturnType(), cgen);\n\t\t\tdecl.writeFullName(cgen.current);\n\t\t\tif (!decl.isFinal())\n\t\t\t\tcgen.current.app(\"_impl\");\n\n\t\t\tFunctionDeclWriter.writeFuncArgs(decl, cgen);\n\n\t\t\tcgen.current.openBlock();\n\t\t\tdecl.getBody().accept(cgen);\n\t\t\tcgen.current.closeSpacedBlock();\n\t\t}\n\n\t}\n\n\tpublic static void writeClassGettingFunction(ClassDecl classDecl,\n\t\t\tCGenerator cgen) throws IOException {\n\n\t\tcgen.current.app(\"Class *\").app(classDecl.getName()).app(\"_class()\")\n\t\t\t\t.openSpacedBlock();\n\t\tif (!classDecl.getSuperName().isEmpty())\n\t\t\tcgen.current.app(\"static bool __done__ = false;\").nl();\n\t\tcgen.current.app(\"static \").app(classDecl.getName()).app(\n\t\t\t\t\"Class class = \");\n\t\twriteClassStructInitializers(classDecl, classDecl, new HashSet<FunctionDecl>(), cgen);\n\t\tcgen.current.app(';');\n\t\tcgen.current.nl().app(\"Class *classPtr = (Class *) &class;\");\n\t\tif (!classDecl.getSuperName().isEmpty()) {\n\t\t\tcgen.current.nl().app(\"if(!__done__)\").openBlock().nl().app(\n\t\t\t\t\t\"__done__ = true;\").nl().app(\"classPtr->super = \").app(\n\t\t\t\t\tclassDecl.getSuperName()).app(\"_class();\").closeBlock();\n\t\t}\n\n\t\tcgen.current.nl().app(\"return classPtr;\").closeSpacedBlock();\n\t}\n\n\tpublic static void writeClassStructInitializers(ClassDecl writerClass,\n\t\t\tClassDecl coreClass, Set<FunctionDecl> done, CGenerator cgen) throws IOException {\n\n\t\tcgen.current.openBlock();\n\n\t\tif (!writerClass.isRootClass() && !writerClass.getSuperName().isEmpty()) {\n\t\t\twriteClassStructInitializers(writerClass.getSuperRef(), coreClass, done, cgen);\n\t\t} else {\n\t\t\tcgen.current.openBlock();\n\t\t\tcgen.current.nl().app(\".size = \").app(\"sizeof(\").app(\n\t\t\t\t\tcoreClass.getName()).app(\"),\");\n\t\t\tcgen.current.nl().app(\".name = \").app('\"').app(coreClass.getName())\n\t\t\t\t\t.app(\"\\\",\");\n\t\t\tcgen.current.closeBlock().app(',');\n\t\t}\n\n\t\tfor (FunctionDecl currentDecl : writerClass.getFunctions()) {\n\t\t\tif (currentDecl.isStatic())\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif(done.contains(currentDecl)) continue;\n\t\t\t\n\t\t\tFunctionDecl coreDecl = null;\n\t\t\tif(coreClass != writerClass) {\n\t\t\t\tcoreDecl = coreClass.getFunction(currentDecl.getName(), currentDecl.getSuffix(), null, false);\n\t\t\t\tif(done.contains(coreDecl)) continue;\n\t\t\t\tif(coreDecl != null) {\n\t\t\t\t\tdone.add(coreDecl);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (currentDecl.isFinal() || currentDecl.isAbstract()) {\n\t\t\t\twriteDesignatedInit(currentDecl, coreDecl, false, cgen);\n\t\t\t} else {\n\t\t\t\twriteDesignatedInit(currentDecl, coreDecl, true, cgen);\n\t\t\t}\n\n\t\t}\n\n\t\tcgen.current.closeBlock();\n\t\tif (coreClass != writerClass)\n\t\t\tcgen.current.app(',');\n\t}\n\n\tpublic static void writeMemberFuncPrototypes(ClassDecl classDecl,\n\t\t\tCGenerator cgen) throws IOException {\n\n\t\tcgen.current.nl().app(\"Class *\").app(classDecl.getName()).app(\"_class();\").nl();\n\t\tfor (FunctionDecl decl : classDecl.getFunctions()) {\n\t\t\tcgen.current.nl();\n\t\t\tTypeWriter.writeSpaced(decl.getReturnType(), cgen);\n\t\t\tdecl.writeFullName(cgen.current);\n\t\t\tFunctionDeclWriter.writeFuncArgs(decl, cgen);\n\t\t\tcgen.current.app(';');\n\n\t\t\tif (decl.getName().equals(\"new\")) {\n\t\t\t\tcgen.current.nl().app(\"void \").app(classDecl.getName()).app(\"_construct\");\n\t\t\t\tif (!decl.getSuffix().isEmpty())\n\t\t\t\t\tcgen.current.app('_').app(decl.getSuffix());\n\t\t\t\tFunctionDeclWriter.writeFuncArgs(decl, cgen);\n\t\t\t\tcgen.current.app(';');\n\t\t\t}\n\t\t}\n\t\tcgen.current.nl();\n\t}\n\n\tpublic static void writeFuncPointer(FunctionDecl decl, boolean doName, CGenerator cgen)\n\t\t\tthrows IOException {\n\t\tdecl.getReturnType().accept(cgen);\n\t\tcgen.current.app(\" (*\");\n\t\tif(doName) decl.writeSuffixedName(cgen.current);\n\t\tcgen.current.app(\")(\");\n\t\tint numArgs = decl.getArguments().size() - 1;\n\t\tNode[] args = decl.getArguments().getNodes();\n\t\tfor (int i = 0; i <= numArgs; i++) {\n\t\t\targs[i].accept(cgen);\n\t\t\tif (i < numArgs)\n\t\t\t\tcgen.current.app(\", \");\n\t\t}\n\t\tcgen.current.app(')');\n\t}\n\n\tpublic static void writeClassStruct(ClassDecl classDecl, CGenerator cgen)\n\t\t\tthrows IOException {\n\n\t\tcgen.current.nl().app(\"struct _\").app(classDecl.getName()).app(\"Class\")\n\t\t\t\t.openSpacedBlock();\n\t\tif (classDecl.isRootClass()) {\n\t\t\tcgen.current.app(\"struct _Class __super__;\");\n\t\t} else {\n\t\t\tcgen.current.app(\"struct _\").app(classDecl.getSuperName()).app(\n\t\t\t\t\t\"Class __super__;\");\n\t\t}\n\n\t\t/* Now write all virtual functions prototypes in the class struct */\n\t\tfor (FunctionDecl decl : classDecl.getFunctions()) {\n\t\t\tif (decl.isStatic())\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif(classDecl.getSuperRef() != null) {\n\t\t\t\tFunctionDecl superDecl = classDecl.getSuperRef().getFunction(decl.getName(), decl.getSuffix(), null);\n\t\t\t\tif(superDecl != null && !superDecl.isAbstract()) continue;\n\t\t\t}\n\t\t\t\n\t\t\tcgen.current.nl();\n\t\t\twriteFuncPointer(decl, true, cgen);\n\t\t\tcgen.current.app(';');\n\t\t}\n\t\t\n\t\tfor (VariableDecl decl : classDecl.getVariables()) {\n\t\t\tif (!decl.isStatic())\n\t\t\t\tcontinue;\n\t\t\tcgen.current.nl();\n\t\t\tdecl.accept(cgen);\n\t\t\tcgen.current.app(';');\n\t\t}\n\t\t\n\t\tcgen.current.closeBlock().app(';').nl().nl();\n\t}\n\n\tpublic static void writeObjectStruct(ClassDecl classDecl, CGenerator cgen)\n\t\t\tthrows IOException {\n\t\tcgen.current.nl().app(\"struct _\").app(classDecl.getName()).openSpacedBlock();\n\n\t\tif (classDecl.isClassClass()) {\n\t\t\tcgen.current.app(\"Class *class;\");\n\t\t} else if (!classDecl.isObjectClass()) {\n\t\t\tcgen.current.app(\"struct _\").app(classDecl.getSuperName()).app(\n\t\t\t\t\t\" __super__;\");\n\t\t}\n\n\t\tfor (VariableDecl decl : classDecl.getVariables()) {\n\t\t\tif (decl.isStatic())\n\t\t\t\tcontinue;\n\t\t\tcgen.current.nl();\n\t\t\tdecl.accept(cgen);\n\t\t\tcgen.current.app(';');\n\t\t}\n\n\t\tcgen.current.closeBlock().app(';').nl().nl();\n\t}\n\n\tpublic static void writeStructTypedef(String structName, CGenerator cgen) throws IOException {\n\t\tcgen.current.nl().app(\"struct _\").app(structName).app(\";\");\n\t\tcgen.current.nl().app(\"typedef struct _\").app(structName).app(\" \").app(\n\t\t\t\tstructName).app(\";\");\n\t}\n\n\tpublic static void writeDesignatedInit(FunctionDecl decl, FunctionDecl coreDecl, boolean impl, CGenerator cgen)\n\t\t\tthrows IOException {\n\t\t\n\t\t\tcgen.current.nl().app('.').app(decl.getSuffixedName()).app(\" = \");\n\t\t\tif(coreDecl != null) {\n\t\t\t\tcgen.current.app(\"(\");\n\t\t\t\twriteFuncPointer(decl, false, cgen);\n\t\t\t\tcgen.current.app(\") \");\n\t\t\t}\n\t\t\tcgen.current.app(coreDecl != null ? coreDecl.getFullName() : decl.getFullName());\n\t\t\tif(impl) cgen.current.app(\"_impl\");\n\t\t\tcgen.current.app(',');\n\t\t\t\n\t}\n\n}\n","lineNo":45}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeUnwrapped;\nimport org.ooc.frontend.model.tokens.Token;\n\npublic class FunctionDecl extends Declaration implements Scope, Generic, MustBeUnwrapped {\n\n\tpublic static Type type = new Type(\"Func\", Token.defaultToken);\n\t\n\tprotected OocDocComment comment;\n\t\n\tprotected boolean isFinal;\n\tprotected boolean isStatic;\n\tprotected boolean isAbstract;\n\tprotected boolean isProto = false;\n\tprotected boolean fromPointer = false;\n\t\n\tprotected TypeDecl typeDecl;\n\n\tprotected String suffix;\n\tprotected final NodeList<Line> body;\n\t\n\tprotected Type returnType;\n\t// when the return type is generic, the returnArg is a pointer.\n\tprotected Argument returnArg;\n\t\n\tprotected final LinkedHashMap<String, GenericType> typeParams;\n\tprotected final NodeList<Argument> arguments;\n\t\n\tpublic FunctionDecl(String name, String suffix, boolean isFinal,\n\t\t\tboolean isStatic, boolean isAbstract, boolean isExtern, Token startToken) {\n\t\tthis(name, suffix, isFinal, isStatic, isAbstract, isExtern ? \"\" : null, startToken);\n\t}\n\t\n\tpublic FunctionDecl(String name, String suffix, boolean isFinal,\n\t\t\tboolean isStatic, boolean isAbstract, String externName, Token startToken) {\n\t\tsuper(name, externName, startToken);\n\t\tthis.suffix = suffix;\n\t\tthis.isFinal = isFinal;\n\t\tthis.isStatic = isStatic;\n\t\tthis.isAbstract = isAbstract;\n\t\tthis.body = new NodeList<Line>(startToken);\n\t\tthis.returnType = name.equals(\"main\") ? IntLiteral.type : new Type(\"void\", Token.defaultToken);\n\t\tthis.arguments = new NodeList<Argument>(startToken);\n\t\tthis.typeParams = new LinkedHashMap<String, GenericType>();\n\t\tthis.returnArg = new RegularArgument(NullLiteral.type, generateTempName(\"returnArg\"), startToken);\n\t}\n\t\n\tpublic LinkedHashMap<String, GenericType> getGenericTypes() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic void setComment(OocDocComment comment) {\n\t\tthis.comment = comment;\n\t}\n\t\n\tpublic OocDocComment getComment() {\n\t\treturn comment;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic boolean isFromPointer() {\n\t\treturn fromPointer;\n\t}\n\t\n\tpublic void setFromPointer(boolean fromPointer) {\n\t\tthis.fromPointer = fromPointer;\n\t}\n\t\n\tpublic boolean isProto() {\n\t\treturn isProto;\n\t}\n\t\n\tpublic void setProto(boolean isProto) {\n\t\tthis.isProto = isProto;\n\t}\n\t\n\tpublic boolean isAbstract() {\n\t\treturn isAbstract;\n\t}\n\t\n\tpublic void setAbstract(boolean isAbstract) {\n\t\tthis.isAbstract = isAbstract;\n\t}\n\t\n\tpublic boolean isStatic() {\n\t\treturn isStatic;\n\t}\n\t\n\tpublic void setStatic(boolean isStatic) {\n\t\tthis.isStatic = isStatic;\n\t}\n\t\n\tpublic boolean isFinal() {\n\t\treturn isFinal;\n\t}\n\t\n\tpublic void setFinal(boolean isFinal) {\n\t\tthis.isFinal = isFinal;\n\t}\n\t\n\t@Override\n\tpublic TypeDecl getTypeDecl() {\n\t\treturn typeDecl;\n\t}\n\t\n\tpublic void setTypeDecl(TypeDecl typeDecl) {\n\t\tthis.typeDecl = typeDecl;\n\t}\n\t\n\t/**\n\t * @return true if it's a member function\n\t */\n\tpublic boolean isMember() {\n\t\treturn typeDecl != null;\n\t}\n\t\n\tpublic NodeList<Line> getBody() {\n\t\treturn body;\n\t}\n\t\n\tpublic Type getReturnType() {\n\t\treturn returnType;\n\t}\n\t\n\tpublic void setReturnType(Type returnType) {\n\t\tthis.returnType = returnType;\n\t}\n\t\n\tpublic NodeList<Argument> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\t@Override\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif (typeParams.size() > 0) for (GenericType typeParam: typeParams.values()) {\n\t\t\ttypeParam.getType().accept(visitor);\n\t\t}\n\t\targuments.accept(visitor);\n\t\treturnType.accept(visitor);\n\t\treturnArg.getType().accept(visitor);\n\t\tbody.accept(visitor);\n\t}\n\n\tpublic boolean isConstructor() {\n\t\treturn name.equals(\"new\");\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(oldie == returnType) {\n\t\t\treturnType = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tpublic String getArgsRepr() {\n\t\t\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Argument> iter = arguments.iterator();\n\t\tif(isMember() && !isStatic() && iter.hasNext()) iter.next();\n\t\twhile(iter.hasNext()) {\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg instanceof VarArg) sB.append(\"...\");\n\t\t\telse sB.append(arg.getType());\n\t\t\t\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tString repr = getClass().getSimpleName()+\" : \"+name+getArgsRepr();\n\t\tif(isMember()) repr = \"[member] \" + repr;\n\t\treturn repr;\n\t\t\n\t}\n\n\tpublic String getFullName() {\n\t\t\n\t\tStringBuilder sB = new StringBuilder();\n\t\ttry {\n\t\t\twriteFullName(sB);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn sB.toString();\n\t\t\n\t}\n\n\tpublic void writeFullName(Appendable dst) throws IOException {\n\t\t\n\t\tif(externName != null && externName.length() > 0) {\n\t\t\tdst.append(externName);\n\t\t} else {\n\t\t\tif(isMember()) {\n\t\t\t\tdst.append(typeDecl.getExternName()).append('_');\n\t\t\t}\n\t\t\twriteSuffixedName(dst);\n\t\t}\n\t\t\n\t}\n\n\tpublic void writeSuffixedName(Appendable dst) throws IOException {\n\t\t\n\t\tdst.append(getExternName());\n\t\tif(!suffix.isEmpty()) {\n\t\t\tdst.append('_').append(suffix);\n\t\t}\n\t\t\n\t}\n\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\n\tpublic boolean sameProto(FunctionDecl decl2) {\n\t\treturn name.equals(decl2.getName()) && (suffix.equals(decl2.getSuffix()));\n\t}\n\n\tpublic boolean isEntryPoint() {\n\t\treturn name.equals(\"main\");\n\t}\n\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tif(arguments.size > 0) for(Argument argument: arguments) {\n\t\t\tif(argument.hasAtom(name)) return argument;\n\t\t}\n\t\tif(body.size > 0) for(Line line: body) {\n\t\t\tNode node = line.getStatement();\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tVariableDecl varDecl = (VariableDecl) node;\n\t\t\t\tif(varDecl.hasAtom(name)) return varDecl;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tif(arguments.size > 0) for(Argument argument: arguments) {\n\t\t\tif(argument.hasAtom(name)) variables.add(argument);\n\t\t}\n\t\tif(body.size > 0) for(Line line: body) {\n\t\t\tNode node = line.getStatement();\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tVariableDecl varDecl = (VariableDecl) node;\n\t\t\t\tif(varDecl.hasAtom(name)) variables.add(varDecl);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic FunctionDecl getFunction(String name, FunctionCall call) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getFunctions(NodeList<FunctionDecl> functions) {}\n\n\tpublic String getSuffixedName() {\n\t\tif(suffix.isEmpty()) return name;\n\t\treturn name+\"_\"+suffix;\n\t}\n\n\t@Override\n\tpublic boolean unwrap(NodeList<Node> stack) throws IOException {\n\t\tif(name.isEmpty()) {\n\t\t\tModule module = stack.getModule();\n\t\t\tname = stack.get(0).generateTempName(module.getUnderName()+\"_closure\");\n\t\t\tVariableAccess varAcc = new VariableAccess(name, startToken);\n\t\t\tvarAcc.setRef(this);\n\t\t\tstack.peek().replace(this, varAcc);\n\t\t\tmodule.getBody().add(this);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isExternWithName() {\n\t\treturn externName != null && !externName.isEmpty();\n\t}\n\n\tpublic Argument getReturnArg() {\n\t\treturn returnArg;\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeUnwrapped;\nimport org.ooc.frontend.model.tokens.Token;\n\npublic class FunctionDecl extends Declaration implements Scope, Generic, MustBeUnwrapped {\n\n\tpublic static Type type = new Type(\"Func\", Token.defaultToken);\n\t\n\tprotected OocDocComment comment;\n\t\n\tprotected boolean isFinal;\n\tprotected boolean isStatic;\n\tprotected boolean isAbstract;\n\tprotected boolean isProto = false;\n\tprotected boolean fromPointer = false;\n\t\n\tprotected TypeDecl typeDecl;\n\n\tprotected String suffix;\n\tprotected final NodeList<Line> body;\n\t\n\tprotected Type returnType;\n\t// when the return type is generic, the returnArg is a pointer.\n\tprotected Argument returnArg;\n\t\n\tprotected final LinkedHashMap<String, GenericType> typeParams;\n\tprotected final NodeList<Argument> arguments;\n\t\n\tpublic FunctionDecl(String name, String suffix, boolean isFinal,\n\t\t\tboolean isStatic, boolean isAbstract, boolean isExtern, Token startToken) {\n\t\tthis(name, suffix, isFinal, isStatic, isAbstract, isExtern ? \"\" : null, startToken);\n\t}\n\t\n\tpublic FunctionDecl(String name, String suffix, boolean isFinal,\n\t\t\tboolean isStatic, boolean isAbstract, String externName, Token startToken) {\n\t\tsuper(name, externName, startToken);\n\t\tthis.suffix = suffix;\n\t\tthis.isFinal = isFinal;\n\t\tthis.isStatic = isStatic;\n\t\tthis.isAbstract = isAbstract;\n\t\tthis.body = new NodeList<Line>(startToken);\n\t\tthis.returnType = name.equals(\"main\") ? IntLiteral.type : new Type(\"void\", Token.defaultToken);\n\t\tthis.arguments = new NodeList<Argument>(startToken);\n\t\tthis.typeParams = new LinkedHashMap<String, GenericType>();\n\t\tthis.returnArg = new RegularArgument(NullLiteral.type, generateTempName(\"returnArg\"), startToken);\n\t}\n\t\n\tpublic LinkedHashMap<String, GenericType> getGenericTypes() {\n\t\treturn typeParams;\n\t}\n\t\n\tpublic void setComment(OocDocComment comment) {\n\t\tthis.comment = comment;\n\t}\n\t\n\tpublic OocDocComment getComment() {\n\t\treturn comment;\n\t}\n\t\n\tpublic String getSuffix() {\n\t\treturn suffix;\n\t}\n\t\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t\n\tpublic boolean isFromPointer() {\n\t\treturn fromPointer;\n\t}\n\t\n\tpublic void setFromPointer(boolean fromPointer) {\n\t\tthis.fromPointer = fromPointer;\n\t}\n\t\n\tpublic boolean isProto() {\n\t\treturn isProto;\n\t}\n\t\n\tpublic void setProto(boolean isProto) {\n\t\tthis.isProto = isProto;\n\t}\n\t\n\tpublic boolean isAbstract() {\n\t\treturn isAbstract;\n\t}\n\t\n\tpublic void setAbstract(boolean isAbstract) {\n\t\tthis.isAbstract = isAbstract;\n\t}\n\t\n\tpublic boolean isStatic() {\n\t\treturn isStatic;\n\t}\n\t\n\tpublic void setStatic(boolean isStatic) {\n\t\tthis.isStatic = isStatic;\n\t}\n\t\n\tpublic boolean isFinal() {\n\t\treturn isFinal;\n\t}\n\t\n\tpublic void setFinal(boolean isFinal) {\n\t\tthis.isFinal = isFinal;\n\t}\n\t\n\t@Override\n\tpublic TypeDecl getTypeDecl() {\n\t\treturn typeDecl;\n\t}\n\t\n\tpublic void setTypeDecl(TypeDecl typeDecl) {\n\t\tthis.typeDecl = typeDecl;\n\t}\n\t\n\t/**\n\t * @return true if it's a member function\n\t */\n\tpublic boolean isMember() {\n\t\treturn typeDecl != null;\n\t}\n\t\n\tpublic NodeList<Line> getBody() {\n\t\treturn body;\n\t}\n\t\n\tpublic Type getReturnType() {\n\t\treturn returnType;\n\t}\n\t\n\tpublic void setReturnType(Type returnType) {\n\t\tthis.returnType = returnType;\n\t}\n\t\n\tpublic NodeList<Argument> getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\t@Override\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\tif (typeParams.size() > 0) for (GenericType typeParam: typeParams.values()) {\n\t\t\ttypeParam.getType().accept(visitor);\n\t\t}\n\t\targuments.accept(visitor);\n\t\treturnType.accept(visitor);\n\t\treturnArg.getType().accept(visitor);\n\t\tbody.accept(visitor);\n\t}\n\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(oldie == returnType) {\n\t\t\treturnType = (Type) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\n\tpublic String getArgsRepr() {\n\t\t\n\t\tStringBuilder sB = new StringBuilder();\n\t\tsB.append('(');\n\t\tIterator<Argument> iter = arguments.iterator();\n\t\tif(isMember() && !isStatic() && iter.hasNext()) iter.next();\n\t\twhile(iter.hasNext()) {\n\t\t\tArgument arg = iter.next();\n\t\t\tif(arg instanceof VarArg) sB.append(\"...\");\n\t\t\telse sB.append(arg.getType());\n\t\t\t\n\t\t\tif(iter.hasNext()) sB.append(\", \");\n\t\t}\n\t\tsB.append(')');\n\t\t\n\t\treturn sB.toString();\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tString name = isMember() ? typeDecl.getType() + \".\" + getSuffixedName() : getSuffixedName();\n\t\tString repr = getClass().getSimpleName()+\" : \"+name+getArgsRepr();\n\t\treturn repr;\n\t\t\n\t}\n\n\tpublic String getFullName() {\n\t\t\n\t\tStringBuilder sB = new StringBuilder();\n\t\ttry {\n\t\t\twriteFullName(sB);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn sB.toString();\n\t\t\n\t}\n\n\tpublic void writeFullName(Appendable dst) throws IOException {\n\t\t\n\t\tif(externName != null && externName.length() > 0) {\n\t\t\tdst.append(externName);\n\t\t} else {\n\t\t\tif(isMember()) {\n\t\t\t\tdst.append(typeDecl.getExternName()).append('_');\n\t\t\t}\n\t\t\twriteSuffixedName(dst);\n\t\t}\n\t\t\n\t}\n\n\tpublic void writeSuffixedName(Appendable dst) throws IOException {\n\t\t\n\t\tdst.append(getExternName());\n\t\tif(!suffix.isEmpty()) {\n\t\t\tdst.append('_').append(suffix);\n\t\t}\n\t\t\n\t}\n\n\tpublic String getProtoRepr() {\n\t\treturn name+getArgsRepr();\n\t}\n\n\tpublic boolean sameProto(FunctionDecl decl2) {\n\t\treturn name.equals(decl2.getName()) && (suffix.equals(decl2.getSuffix()));\n\t}\n\n\tpublic boolean isEntryPoint() {\n\t\treturn name.equals(\"main\");\n\t}\n\n\t@Override\n\tpublic VariableDecl getVariable(String name) {\n\t\tif(arguments.size > 0) for(Argument argument: arguments) {\n\t\t\tif(argument.hasAtom(name)) return argument;\n\t\t}\n\t\tif(body.size > 0) for(Line line: body) {\n\t\t\tNode node = line.getStatement();\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tVariableDecl varDecl = (VariableDecl) node;\n\t\t\t\tif(varDecl.hasAtom(name)) return varDecl;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getVariables(NodeList<VariableDecl> variables) {\n\t\tif(arguments.size > 0) for(Argument argument: arguments) {\n\t\t\tif(argument.hasAtom(name)) variables.add(argument);\n\t\t}\n\t\tif(body.size > 0) for(Line line: body) {\n\t\t\tNode node = line.getStatement();\n\t\t\tif(node instanceof VariableDecl) {\n\t\t\t\tVariableDecl varDecl = (VariableDecl) node;\n\t\t\t\tif(varDecl.hasAtom(name)) variables.add(varDecl);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic FunctionDecl getFunction(String name, String suffix, FunctionCall call) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void getFunctions(NodeList<FunctionDecl> functions) {}\n\n\tpublic String getSuffixedName() {\n\t\tif(suffix.isEmpty()) return name;\n\t\treturn name+\"_\"+suffix;\n\t}\n\n\t@Override\n\tpublic boolean unwrap(NodeList<Node> stack) throws IOException {\n\t\tif(name.isEmpty()) {\n\t\t\tModule module = stack.getModule();\n\t\t\tname = stack.get(0).generateTempName(module.getUnderName()+\"_closure\");\n\t\t\tVariableAccess varAcc = new VariableAccess(name, startToken);\n\t\t\tvarAcc.setRef(this);\n\t\t\tstack.peek().replace(this, varAcc);\n\t\t\tmodule.getBody().add(this);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isExternWithName() {\n\t\treturn externName != null && !externName.isEmpty();\n\t}\n\n\tpublic Argument getReturnArg() {\n\t\treturn returnArg;\n\t}\n\n\tpublic boolean isNamed(String name, String suffix) {\n\t\treturn this.name.equals(name) && (suffix.isEmpty() || this.suffix.equals(suffix));\n\t}\n\n\tpublic boolean isSpecialFunc() {\n\t\treturn name.equals(\"defaults\") || name.equals(\"destroy\") || name.equals(\"load\");\n\t}\n\t\n}\n","lineNo":206}
{"Smelly Sample":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ValuedReturn extends Return implements MustBeResolved {\n\n\tprotected Expression expression;\n\n\tpublic ValuedReturn(Expression expression, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.expression = expression;\n\t}\n\t\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\t\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\texpression.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(super.replace(oldie, kiddo)) return true;\n\t\t\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.replace(oldie, kiddo);\n\t\t\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic boolean resolve(NodeList<Node> stack, Resolver res, boolean fatal)\n\t\t\tthrows IOException {\n\t\t\n\t\tint funcIndex = stack.find(FunctionDecl.class);\n\t\tif(funcIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, stack, \"'return' outside a function: wtf?\");\n\t\t}\n\t\tFunctionDecl decl = (FunctionDecl) stack.get(funcIndex);\n\t\tType returnType = decl.getReturnType();\n\t\tGenericType param = getGenericType(stack, returnType.getName());\n\t\tif(param != null) {\n\t\t\tFunctionCall call = new FunctionCall(\"memcpy\", \"\", startToken);\n\t\t\tcall.getArguments().add(new VariableAccess(decl.getReturnArg(), startToken));\n\t\t\t\n\t\t\tif(expression instanceof ArrayAccess) {\n\t\t\t\tArrayAccess arrAccess = (ArrayAccess) expression;\n\t\t\t\texpression = new Add(new AddressOf(arrAccess.variable, startToken), arrAccess.index, startToken);\n\t\t\t} else {\n\t\t\t\texpression = new AddressOf(expression, startToken);\n\t\t\t}\n\t\t\tcall.getArguments().add(expression);\n\t\t\t\n\t\t\tVariableAccess tAccess = new VariableAccess(param.getName(), startToken); \n\t\t\ttAccess.setRef(param);\n\t\t\tcall.getArguments().add(new MemberAccess(tAccess, \"size\", startToken));\n\t\t\tstack.peek().replace(this, call);\n\t\t\t\n\t\t\tint lineIndex = stack.find(Line.class);\n\t\t\t((NodeList<Node>) stack.get(lineIndex - 1)).addAfter(stack.get(lineIndex), new Line(new Return(startToken)));\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.frontend.model;\n\nimport java.io.IOException;\n\nimport org.ooc.frontend.Visitor;\nimport org.ooc.frontend.model.interfaces.MustBeResolved;\nimport org.ooc.frontend.model.tokens.Token;\nimport org.ooc.middle.OocCompilationError;\nimport org.ooc.middle.hobgoblins.Resolver;\n\npublic class ValuedReturn extends Return implements MustBeResolved {\n\n\tprotected Expression expression;\n\n\tpublic ValuedReturn(Expression expression, Token startToken) {\n\t\tsuper(startToken);\n\t\tthis.expression = expression;\n\t}\n\t\n\tpublic Expression getExpression() {\n\t\treturn expression;\n\t}\n\t\n\tpublic void setExpression(Expression expression) {\n\t\tthis.expression = expression;\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) throws IOException {\n\t\tvisitor.visit(this);\n\t}\n\t\n\t@Override\n\tpublic boolean hasChildren() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void acceptChildren(Visitor visitor) throws IOException {\n\t\texpression.accept(visitor);\n\t}\n\t\n\t@Override\n\tpublic boolean replace(Node oldie, Node kiddo) {\n\t\t\n\t\tif(super.replace(oldie, kiddo)) return true;\n\t\t\n\t\tif(oldie == expression) {\n\t\t\texpression = (Expression) kiddo;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.replace(oldie, kiddo);\n\t\t\n\t}\n\n\t@Override\n\tpublic boolean isResolved() {\n\t\treturn false;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic boolean resolve(NodeList<Node> stack, Resolver res, boolean fatal)\n\t\t\tthrows IOException {\n\t\t\n\t\tint funcIndex = stack.find(FunctionDecl.class);\n\t\tif(funcIndex == -1) {\n\t\t\tthrow new OocCompilationError(this, stack, \"'return' outside a function: wtf?\");\n\t\t}\n\t\tFunctionDecl decl = (FunctionDecl) stack.get(funcIndex);\n\t\tType returnType = decl.getReturnType();\n\t\tGenericType param = getGenericType(stack, returnType.getName());\n\t\tif(param != null) {\n\t\t\tFunctionCall call = new FunctionCall(\"memcpy\", \"\", startToken);\n\t\t\tcall.getArguments().add(new VariableAccess(decl.getReturnArg(), startToken));\n\t\t\t\n\t\t\tVariableAccess tAccess = new VariableAccess(param.getName(), startToken); \n\t\t\ttAccess.setRef(param);\n\t\t\tMemberAccess sizeAccess = new MemberAccess(tAccess, \"size\", startToken);\n\t\t\t\n\t\t\tif(expression instanceof ArrayAccess) {\n\t\t\t\tArrayAccess arrAccess = (ArrayAccess) expression;\n\t\t\t\texpression = new Add(new AddressOf(arrAccess.variable, startToken),\n\t\t\t\t\t\tnew Mul(arrAccess.index, sizeAccess, startToken), startToken);\n\t\t\t} else {\n\t\t\t\texpression = new AddressOf(expression, startToken);\n\t\t\t}\n\t\t\tcall.getArguments().add(expression);\n\t\t\t\n\t\t\tcall.getArguments().add(sizeAccess);\n\t\t\tstack.peek().replace(this, call);\n\t\t\t\n\t\t\tint lineIndex = stack.find(Line.class);\n\t\t\t((NodeList<Node>) stack.get(lineIndex - 1)).addAfter(stack.get(lineIndex), new Line(new Return(startToken)));\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t\t\n\t}\n\t\n}\n","lineNo":80}
{"Smelly Sample":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.ooc.frontend.model.*;\n\npublic class FunctionCallWriter {\n\n\tpublic static void write(FunctionCall functionCall, CGenerator cgen) throws IOException {\n\n\t\tFunctionDecl impl = functionCall.getImpl();\n\t\tif(functionCall.isConstructorCall()) {\n\t\t\tcgen.current.app(impl.getTypeDecl().getName());\n\t\t\tif(impl.getTypeDecl() instanceof ClassDecl) {\n\t\t\t\tcgen.current.app(\"_construct\");\n\t\t\t} else{\n\t\t\t\tcgen.current.app(\"_new\");\n\t\t\t}\n\t\t\tif(!impl.getSuffix().isEmpty()) cgen.current.app('_').app(impl.getSuffix());\n\t\t} else if(impl.isFromPointer()) {\n\t\t\tcgen.current.app(functionCall.getName());\n\t\t} else {\n\t\t\timpl.writeFullName(cgen.current);\n\t\t}\n\t\t\n\t\tNodeList<Expression> args = functionCall.getArguments();\n\t\tcgen.current.app('(');\n\t\tif(functionCall.isConstructorCall() && impl.getTypeDecl() instanceof ClassDecl) {\n\t\t\tcgen.current.app('(');\n\t\t\timpl.getTypeDecl().getInstanceType().accept(cgen);\n\t\t\tcgen.current.app(')');\n\t\t\tcgen.current.app(\" this\");\n\t\t\tif(!args.isEmpty()) cgen.current.app(\", \");\n\t\t}\n\t\twriteCallArgs(args, impl, cgen);\n\t\tcgen.current.app(')');\n\t\t\n\t}\n\n\tpublic static void writeCallArgs(NodeList<Expression> callArgs, FunctionDecl impl, CGenerator cgen) throws IOException {\n\t\tList<TypeParam> typeParams = impl.getTypeParams();\n\t\tif(typeParams.isEmpty()) {\n\t\t\tIterator<Expression> iter = callArgs.iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\titer.next().accept(cgen);\n\t\t\t\tif(iter.hasNext()) cgen.current.app(\", \");\n\t\t\t}\n\t\t} else {\n\t\t\twriteGenericCallArgs(callArgs, impl, typeParams, cgen);\n\t\t}\n\t}\n\n\tpublic static void writeGenericCallArgs(NodeList<Expression> callArgs,\n\t\t\tFunctionDecl impl, List<TypeParam> typeParams, CGenerator cgen) throws IOException {\n\t\t\n\t\t// FIXME must write a list of expressions given by FunctionCall instead\n\t\tfor(int i = 0; i < typeParams.size(); i++) {\n\t\t\tcgen.current.append(callArgs.get(i).getType().getName()+\"_class(), \");\n\t\t}\n\t\t\n\t\tint i = 0;\n\t\tIterator<Expression> iter = callArgs.iterator();\n\t\tNodeList<Argument> implArgs = impl.getArguments();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression expr = iter.next();\n\t\t\tArgument arg = implArgs.get(i);\n\t\t\tfor(TypeParam param: typeParams) {\n\t\t\t\tSystem.out.println(\"arg.getType().getName() = \"+arg.getType().getName()\n\t\t\t\t\t+\", param.getName() = \"+param.getName());\n\t\t\t\tif(arg.getType().getName().equals(param.getName())) {\n\t\t\t\t\tcgen.current.app(\"&\");\n\t\t\t\t}\n\t\t\t}\n\t\t\texpr.accept(cgen);\n\t\t\tif(iter.hasNext()) cgen.current.app(\", \");\n\t\t\ti++;\n\t\t}\n\t\t\n\t}\n\n\tpublic static void writeMember(MemberCall memberCall, CGenerator cgen) throws IOException {\n\t\t\n\t\tFunctionDecl impl = memberCall.getImpl();\n\t\tif(impl.isFromPointer()) {\n\t\t\tboolean isArrow = memberCall.getExpression().getType().getRef() instanceof ClassDecl;\n\t\t\t\n\t\t\tExpression expression = memberCall.getExpression();\n\t\t\tif(!isArrow && expression instanceof Dereference) {\n\t\t\t\tDereference deref = (Dereference) expression;\n\t\t\t\texpression = deref.getExpression();\n\t\t\t\tisArrow = true;\n\t\t\t}\n\t\t\texpression.accept(cgen);\n\t\t\t\n\t\t\tif(isArrow) {\n\t\t\t\tcgen.current.app(\"->\");\n\t\t\t} else {\n\t\t\t\tcgen.current.app(\".\");\n\t\t\t}\n\t\t\tcgen.current.app(memberCall.getName());\n\t\t} else {\n\t\t\timpl.writeFullName(cgen.current);\n\t\t}\n\t\t\n\t\tcgen.current.app('(');\n\t\t\n\t\tTypeDecl typeDecl = impl.getTypeDecl();\n\t\tif(!typeDecl.getInstanceType().equals(memberCall.getExpression().getType())) {\n\t\t\tcgen.current.app('(');\n\t\t\ttypeDecl.getInstanceType().accept(cgen);\n\t\t\tcgen.current.app(\") \");\n\t\t}\n\t\tif(!impl.isStatic() && !impl.isFromPointer()) {\n\t\t\tmemberCall.getExpression().accept(cgen);\n\t\t\tif(!memberCall.getArguments().isEmpty()) cgen.current.app(\", \");\n\t\t}\n\t\twriteCallArgs(memberCall.getArguments(), impl, cgen);\n\t\t\n\t\tcgen.current.app(')');\n\t\t\n\t}\n\n\tpublic static void writeInst(Instantiation inst, CGenerator cgen) throws IOException {\n\t\tFunctionDecl impl = inst.getImpl();\n\t\timpl.writeFullName(cgen.current);\n\t\tcgen.current.app('(');\n\t\twriteCallArgs(inst.getArguments(), impl, cgen);\n\t\tcgen.current.app(')');\n\t}\n\t\n}\n","Method after Refactoring":"package org.ooc.backend.cdirty;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.ooc.frontend.model.Argument;\nimport org.ooc.frontend.model.ClassDecl;\nimport org.ooc.frontend.model.Dereference;\nimport org.ooc.frontend.model.Expression;\nimport org.ooc.frontend.model.FunctionCall;\nimport org.ooc.frontend.model.FunctionDecl;\nimport org.ooc.frontend.model.Instantiation;\nimport org.ooc.frontend.model.MemberCall;\nimport org.ooc.frontend.model.NodeList;\nimport org.ooc.frontend.model.TypeDecl;\nimport org.ooc.frontend.model.TypeParam;\nimport org.ooc.middle.OocCompilationError;\n\npublic class FunctionCallWriter {\n\n\tpublic static void write(FunctionCall functionCall, CGenerator cgen) throws IOException {\n\n\t\tFunctionDecl impl = functionCall.getImpl();\n\t\tif(functionCall.isConstructorCall()) {\n\t\t\tcgen.current.app(impl.getTypeDecl().getName());\n\t\t\tif(impl.getTypeDecl() instanceof ClassDecl) {\n\t\t\t\tcgen.current.app(\"_construct\");\n\t\t\t} else{\n\t\t\t\tcgen.current.app(\"_new\");\n\t\t\t}\n\t\t\tif(!impl.getSuffix().isEmpty()) cgen.current.app('_').app(impl.getSuffix());\n\t\t} else if(impl.isFromPointer()) {\n\t\t\tcgen.current.app(functionCall.getName());\n\t\t} else {\n\t\t\timpl.writeFullName(cgen.current);\n\t\t}\n\t\t\n\t\tNodeList<Expression> args = functionCall.getArguments();\n\t\tcgen.current.app('(');\n\t\tif(functionCall.isConstructorCall() && impl.getTypeDecl() instanceof ClassDecl) {\n\t\t\tcgen.current.app('(');\n\t\t\timpl.getTypeDecl().getInstanceType().accept(cgen);\n\t\t\tcgen.current.app(')');\n\t\t\tcgen.current.app(\" this\");\n\t\t\tif(!args.isEmpty()) cgen.current.app(\", \");\n\t\t}\n\t\twriteCallArgs(args, impl, cgen);\n\t\tcgen.current.app(')');\n\t\t\n\t}\n\n\tpublic static void writeCallArgs(NodeList<Expression> callArgs, FunctionDecl impl, CGenerator cgen) throws IOException {\n\t\tList<TypeParam> typeParams = impl.getTypeParams();\n\t\tif(typeParams.isEmpty()) {\n\t\t\tIterator<Expression> iter = callArgs.iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\titer.next().accept(cgen);\n\t\t\t\tif(iter.hasNext()) cgen.current.app(\", \");\n\t\t\t}\n\t\t} else {\n\t\t\twriteGenericCallArgs(callArgs, impl, typeParams, cgen);\n\t\t}\n\t}\n\n\tpublic static void writeGenericCallArgs(NodeList<Expression> callArgs,\n\t\t\tFunctionDecl impl, List<TypeParam> typeParams, CGenerator cgen) throws IOException {\n\t\t\n\t\tNodeList<Argument> implArgs = impl.getArguments();\n\t\t\n\t\t// FIXME must write a list of expressions given by FunctionCall instead\n\t\tfor(TypeParam typeParam: typeParams) {\n\t\t\tboolean done = false;\n\t\t\tint i = 0;\n\t\t\tfor(Argument implArg: implArgs) {\n\t\t\t\tif(implArg.getType().getName().equals(typeParam.getName())) {\n\t\t\t\t\tExpression callArg = callArgs.get(i);\n\t\t\t\t\tcgen.current.append(callArg.getType().getName()+\"_class(), \");\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(!done)\n\t\t\t\tthrow new OocCompilationError(callArgs, cgen.module,\n\t\t\t\t\t\t\"Couldn't find argument in \"+callArgs+\" to figure out generic type \"+typeParam);\n\t\t}\n\t\t\n\t\tint i = 0;\n\t\tIterator<Expression> iter = callArgs.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tExpression expr = iter.next();\n\t\t\tArgument arg = implArgs.get(i);\n\t\t\tfor(TypeParam param: typeParams) {\n\t\t\t\tif(arg.getType().getName().equals(param.getName())) {\n\t\t\t\t\tcgen.current.app(\"&\");\n\t\t\t\t}\n\t\t\t}\n\t\t\texpr.accept(cgen);\n\t\t\tif(iter.hasNext()) cgen.current.app(\", \");\n\t\t\ti++;\n\t\t}\n\t\t\n\t}\n\n\tpublic static void writeMember(MemberCall memberCall, CGenerator cgen) throws IOException {\n\t\t\n\t\tFunctionDecl impl = memberCall.getImpl();\n\t\tif(impl.isFromPointer()) {\n\t\t\tboolean isArrow = memberCall.getExpression().getType().getRef() instanceof ClassDecl;\n\t\t\t\n\t\t\tExpression expression = memberCall.getExpression();\n\t\t\tif(!isArrow && expression instanceof Dereference) {\n\t\t\t\tDereference deref = (Dereference) expression;\n\t\t\t\texpression = deref.getExpression();\n\t\t\t\tisArrow = true;\n\t\t\t}\n\t\t\texpression.accept(cgen);\n\t\t\t\n\t\t\tif(isArrow) {\n\t\t\t\tcgen.current.app(\"->\");\n\t\t\t} else {\n\t\t\t\tcgen.current.app(\".\");\n\t\t\t}\n\t\t\tcgen.current.app(memberCall.getName());\n\t\t} else {\n\t\t\timpl.writeFullName(cgen.current);\n\t\t}\n\t\t\n\t\tcgen.current.app('(');\n\t\t\n\t\tTypeDecl typeDecl = impl.getTypeDecl();\n\t\tif(!typeDecl.getInstanceType().equals(memberCall.getExpression().getType())) {\n\t\t\tcgen.current.app('(');\n\t\t\ttypeDecl.getInstanceType().accept(cgen);\n\t\t\tcgen.current.app(\") \");\n\t\t}\n\t\tif(!impl.isStatic() && !impl.isFromPointer()) {\n\t\t\tmemberCall.getExpression().accept(cgen);\n\t\t\tif(!memberCall.getArguments().isEmpty()) cgen.current.app(\", \");\n\t\t}\n\t\twriteCallArgs(memberCall.getArguments(), impl, cgen);\n\t\t\n\t\tcgen.current.app(')');\n\t\t\n\t}\n\n\tpublic static void writeInst(Instantiation inst, CGenerator cgen) throws IOException {\n\t\tFunctionDecl impl = inst.getImpl();\n\t\timpl.writeFullName(cgen.current);\n\t\tcgen.current.app('(');\n\t\twriteCallArgs(inst.getArguments(), impl, cgen);\n\t\tcgen.current.app(')');\n\t}\n\t\n}\n","lineNo":77}
