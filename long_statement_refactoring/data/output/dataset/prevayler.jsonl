{"Smelly Sample":"package org.prevayler.socketserver.server;\n\n/*\n * prevayler.socketServer, a socket-based server (and client library)\n * to help create client-server Prevayler applications\n * \n * Copyright (C) 2003 Advanced Systems Concepts, Inc.\n * \n * Written by David Orme <daveo@swtworkbench.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport org.prevayler.socketserver.util.Log;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * This object allows model objects to notify clients of changes\n *\n * @author DaveO\n */\npublic class Notification extends Thread {\n\n  // Static part of class here----------------------\n  private static List<NotificationThread> clients = new LinkedList<NotificationThread>();\n\n  /**\n   * Use a hash of hashes to keep track of what clients have what messages enabled\n   * <ul>\n   * <li>The first hash indexes by connection ID and contains another hash.\n   * <li>The second hash indexes by message string and contains a count of clients\n   * interested in that message\n   * <\/ul>\n   * <p/>\n   * We do this because on most platforms it is much more expensive to unnecessarily\n   * enable a bunch of threads than to look stuff up in a couple of fairly large hashes.\n   */\n  private static Map<Long, Map<String, Integer>> enabledCallbacks = new HashMap<Long, Map<String, Integer>>();\n\n  /**\n   * Submit a callback message to be sent\n   *\n   * @param message The message to be sent\n   * @param obj     An object (usually a model object) containing information about what happened.\n   */\n  public static synchronized void submit(Long senderID, String message, Object obj) {\n    NotificationThread client;\n\n    Iterator<NotificationThread> i = clients.iterator();\n    while (i.hasNext()) {\n      client = i.next();\n      if (client.isAlive()) {\n        if (enabledCallbacks.containsKey(client.getSocketId())) {\n          Map<String, Integer> callbacks = enabledCallbacks.get(client.getSocketId());\n          if (callbacks.containsKey(message)) {\n            client.submit(senderID, message, obj);\n          }\n        }\n      } else {\n        // If the thread has died (the client disconnected), remove it\n        i.remove();\n\n        // ...and remove any callbacks registered for it\n        enabledCallbacks.remove(client.getSocketId());\n      }\n    }\n  }\n\n  /**\n   * Method registerCallback.  Called internally from the CommandThread server.\n   *\n   * @param myId    The id of the client requesting to receive the callback\n   * @param message The message the client wants to receive\n   */\n  public static void registerCallback(long myId, String message) {\n    Long id = new Long(myId);\n    Map<String, Integer> callbacks;\n\n    // Get the hash of enabled callbacks for this connection ID\n    if (enabledCallbacks.containsKey(id)) {\n      callbacks = enabledCallbacks.get(id);\n    } else {\n      callbacks = new HashMap<String, Integer>();\n      enabledCallbacks.put(id, callbacks);\n    }\n\n    // If this message isn't already registered, register it\n    if (!callbacks.containsKey(message)) {\n      callbacks.put(message, new Integer(1));\n    } else {\n      Integer numInterested = callbacks.get(message);\n      callbacks.put(message, new Integer(numInterested.intValue() + 1));\n    }\n  }\n\n  /**\n   * Method unregisterCallback.  Called internally from the CommandThread server.\n   *\n   * @param myId    The connection id requesting disinterest\n   * @param message The message in which the connection is no longer interested\n   */\n  public static void unregisterCallback(long myId, String message) {\n    Long id = new Long(myId);\n    Map<String, Integer> callbacks = null;\n\n    // Get the hash of enabled callbacks for this connection ID\n    if (enabledCallbacks.containsKey(id)) {\n      callbacks = enabledCallbacks.get(id);\n    }\n\n    // Decrement the count of interested parties in this callback or remove it if nobody is interested\n    if (callbacks != null) {\n      if (callbacks.containsKey(message)) {\n        Integer numInterested = callbacks.get(message);\n\n        // If nobody is interested, remove the callback\n        if (numInterested.intValue() == 1) {\n          callbacks.remove(message);\n        }\n        // Otherwise, decrement the number of interested parties\n        else {\n          callbacks.put(message, new Integer(numInterested.intValue() - 1));\n        }\n      }\n    }\n  }\n\n\n  // Non-static part of class here------------------\n\n  private int port;\n\n  /**\n   * Constructor Notification.\n   *\n   * @param p Port number on which to listen\n   */\n  public Notification(int p) {\n    port = p;\n  }\n\n\n  public void run() {\n    ServerSocket ss = null;\n    boolean listening = true;\n\n    // Listen for a client connection and dispatch a thread to handle it\n    try {\n      ss = new ServerSocket(port);\n    } catch (IOException e) {\n      Log.error(e, \"Couldn't open notification server port\");\n      System.exit(-1);\n    }\n\n    while (listening) {\n      try {\n        NotificationThread client = new NotificationThread(ss.accept());\n        clients.add(client);\n        client.start();\n      } catch (Exception e) {\n        Log.error(e, \"Notification server error\");\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException e) {\n      Log.error(e, \"Error closing notification server socket\");\n    }\n  }\n\n\n}\n\n","Method after Refactoring":"package org.prevayler.socketserver.server;\n\n/*\n * prevayler.socketServer, a socket-based server (and client library)\n * to help create client-server Prevayler applications\n * \n * Copyright (C) 2003 Advanced Systems Concepts, Inc.\n * \n * Written by David Orme <daveo@swtworkbench.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport org.prevayler.socketserver.util.Log;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * This object allows model objects to notify clients of changes\n *\n * @author DaveO\n */\npublic class Notification extends Thread {\n\n  // Static part of class here----------------------\n  private static List<NotificationThread> clients = new LinkedList<NotificationThread>();\n\n  /**\n   * Use a hash of hashes to keep track of what clients have what messages enabled\n   * <ul>\n   * <li>The first hash indexes by connection ID and contains another hash.\n   * <li>The second hash indexes by message string and contains a count of clients\n   * interested in that message\n   * <\/ul>\n   * <p/>\n   * We do this because on most platforms it is much more expensive to unnecessarily\n   * enable a bunch of threads than to look stuff up in a couple of fairly large hashes.\n   */\n  private static Map<Long, Map<String, Integer>> enabledCallbacks = new HashMap<Long, Map<String, Integer>>();\n\n  /**\n   * Submit a callback message to be sent\n   *\n   * @param message The message to be sent\n   * @param obj     An object (usually a model object) containing information about what happened.\n   */\n  public static synchronized void submit(Long senderID, String message, Object obj) {\n    NotificationThread client;\n\n    Iterator<NotificationThread> i = clients.iterator();\n    while (i.hasNext()) {\n      client = i.next();\n      Long id = client.getSocketId();\n      if (client.isAlive()) {\n        if (enabledCallbacks.containsKey(id)) {\n          Map<String, Integer> callbacks = enabledCallbacks.get(id);\n          if (callbacks.containsKey(message)) {\n            client.submit(senderID, message, obj);\n          }\n        }\n      } else {\n        // If the thread has died (the client disconnected), remove it\n        i.remove();\n\n        // ...and remove any callbacks registered for it\n        enabledCallbacks.remove(id);\n      }\n    }\n  }\n\n  /**\n   * Method registerCallback.  Called internally from the CommandThread server.\n   *\n   * @param myId    The id of the client requesting to receive the callback\n   * @param message The message the client wants to receive\n   */\n  public static void registerCallback(long myId, String message) {\n    Map<String, Integer> callbacks;\n    Long id = myId;\n    // Get the hash of enabled callbacks for this connection ID\n    if (enabledCallbacks.containsKey(id)) {\n      callbacks = enabledCallbacks.get(id);\n    } else {\n      callbacks = new HashMap<String, Integer>();\n      enabledCallbacks.put(id, callbacks);\n    }\n\n    // If this message isn't already registered, register it\n    if (!callbacks.containsKey(message)) {\n      callbacks.put(message, 1);\n    } else {\n      Integer numInterested = callbacks.get(message);\n      callbacks.put(message, numInterested.intValue() + 1);\n    }\n  }\n\n  /**\n   * Method unregisterCallback.  Called internally from the CommandThread server.\n   *\n   * @param myId    The connection id requesting disinterest\n   * @param message The message in which the connection is no longer interested\n   */\n  public static void unregisterCallback(long myId, String message) {\n    Map<String, Integer> callbacks = null;\n    Long id = myId;\n    // Get the hash of enabled callbacks for this connection ID\n    if (enabledCallbacks.containsKey(id)) {\n      callbacks = enabledCallbacks.get(id);\n    }\n\n    // Decrement the count of interested parties in this callback or remove it if nobody is interested\n    if (callbacks != null) {\n      if (callbacks.containsKey(message)) {\n        Integer numInterested = callbacks.get(message);\n\n        // If nobody is interested, remove the callback\n        if (numInterested.intValue() == 1) {\n          callbacks.remove(message);\n        }\n        // Otherwise, decrement the number of interested parties\n        else {\n          callbacks.put(message, numInterested.intValue() - 1);\n        }\n      }\n    }\n  }\n\n\n  // Non-static part of class here------------------\n\n  private int port;\n\n  /**\n   * Constructor Notification.\n   *\n   * @param p Port number on which to listen\n   */\n  public Notification(int p) {\n    port = p;\n  }\n\n\n  public void run() {\n    ServerSocket ss = null;\n    boolean listening = true;\n\n    // Listen for a client connection and dispatch a thread to handle it\n    try {\n      ss = new ServerSocket(port);\n    } catch (IOException e) {\n      Log.error(e, \"Couldn't open notification server port\");\n      System.exit(-1);\n    }\n\n    while (listening) {\n      try {\n        NotificationThread client = new NotificationThread(ss.accept());\n        clients.add(client);\n        client.start();\n      } catch (Exception e) {\n        Log.error(e, \"Notification server error\");\n      }\n    }\n    try {\n      ss.close();\n    } catch (IOException e) {\n      Log.error(e, \"Error closing notification server socket\");\n    }\n  }\n\n\n}\n\n","lineNo":71}
{"Smelly Sample":"/*\n * Copyright (c) 2003 Jay Sachs. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name \"Prevayler\" nor the names of its contributors\n *    may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.prevayler.contrib.facade;\n\nimport org.prevayler.PrevaylerFactory;\nimport junit.framework.TestCase;\nimport java.io.Serializable;\n\n\n/**\n * @author Jay Sachs [jay@contravariant.org]\n * @author Jacob Kjome [hoju@visi.com]\n */\npublic class SmokeTest\n    extends TestCase\n{\n\n    public static class RuntimeOops extends RuntimeException\n    {\n        private static final long serialVersionUID = 6697889650105894039L;\n    }\n\n    public static class CheckedOops extends Exception\n    {\n        private static final long serialVersionUID = -6402219678153693704L;\n    }\n\n    public static interface Repository {\n        void storeSomething(String data);\n        void oopsRuntime(String data);\n        void oopsChecked(String data) throws CheckedOops;\n        String getData();\n    }\n\n    public static class RepositoryImpl\n        implements Repository, Serializable\n    {\n        private static final long serialVersionUID = -4401226206133056516L;\n\n        public void storeSomething(String p_data)\n        {\n            m_data = p_data;\n        }\n\n        public void oopsRuntime(String p_data)\n        {\n            m_data = p_data;\n            throw new RuntimeOops();\n        }\n\n        public void oopsChecked(String p_data)\n            throws CheckedOops\n        {\n            m_data = p_data;\n            throw new CheckedOops();\n        }\n\n        public String getData()\n        {\n            return m_data;\n        }\n\n        private String m_data;\n    }\n\n    public void testAndSeeIfItSmokes()\n        throws Exception\n    {\n        Repository repo = (Repository)\n            PrevaylerTransactionsFacade.create\n            (Repository.class,\n             PrevaylerFactory.createTransientPrevayler(new RepositoryImpl()));\n\n        assertEquals(null, repo.getData());\n        final String data = \"someData\";\n        repo.storeSomething(data);\n        assertEquals(data, repo.getData());\n\n        try\n        {\n            repo.oopsRuntime(\"other data\");\n            fail(\"should have thrown RuntimeOops\");\n        }\n        catch (RuntimeOops expected)\n        {\n            // ok\n        }\n\n        assertEquals(data, repo.getData());\n\n        try\n        {\n            repo.oopsChecked(\"more other data\");\n            fail(\"should have thrown CheckedOops\");\n        }\n        catch (CheckedOops expected)\n        {\n            //expected.printStackTrace();\n            // ok\n        }\n\n        //checked exception doesn't trigger rollback\n        //it is assumed that checked exceptions are\n        //expected and should be delbt with manually\n        //where runtime exceptions are unexpected. As\n        //such, internal code may not be prepared to\n        //deal with them so Prevayler rolls back\n        assertEquals(\"more other data\", repo.getData());\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (c) 2003 Jay Sachs. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name \"Prevayler\" nor the names of its contributors\n *    may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.prevayler.contrib.facade;\n\nimport org.prevayler.PrevaylerFactory;\nimport junit.framework.TestCase;\nimport java.io.Serializable;\n\n\n/**\n * @author Jay Sachs [jay@contravariant.org]\n * @author Jacob Kjome [hoju@visi.com]\n */\npublic class SmokeTest\n    extends TestCase\n{\n\n    public static class RuntimeOops extends RuntimeException\n    {\n        private static final long serialVersionUID = 6697889650105894039L;\n    }\n\n    public static class CheckedOops extends Exception\n    {\n        private static final long serialVersionUID = -6402219678153693704L;\n    }\n\n    public static interface Repository {\n        void storeSomething(String data);\n        void oopsRuntime(String data);\n        void oopsChecked(String data) throws CheckedOops;\n        String getData();\n    }\n\n    public static class RepositoryImpl\n        implements Repository, Serializable\n    {\n        private static final long serialVersionUID = -4401226206133056516L;\n\n        public void storeSomething(String p_data)\n        {\n            m_data = p_data;\n        }\n\n        public void oopsRuntime(String p_data)\n        {\n            m_data = p_data;\n            throw new RuntimeOops();\n        }\n\n        public void oopsChecked(String p_data)\n            throws CheckedOops\n        {\n            m_data = p_data;\n            throw new CheckedOops();\n        }\n\n        public String getData()\n        {\n            return m_data;\n        }\n\n        private String m_data;\n    }\n\n    public void testAndSeeIfItSmokes()\n        throws Exception\n    {\n        Repository repo = (Repository)\n            PrevaylerTransactionsFacade.create\n            (Repository.class,\n             PrevaylerFactory.createTransientPrevayler(new RepositoryImpl()));\n\n        assertEquals(null, repo.getData());\n        final String data = \"someData\";\n        repo.storeSomething(data);\n        assertEquals(data, repo.getData());\n\n       final String otherData = \"other data\";\n        try\n        {\n            repo.oopsRuntime(otherData);\n            fail(\"should have thrown RuntimeOops\");\n        }\n        catch (RuntimeOops expected)\n        {\n            System.currentTimeMillis();// ok\n        }\n\n        // previously when rollback was a feature in prevayler\n        // this would have equaled data rather than otherData\n        assertEquals(otherData, repo.getData());\n\n        try\n        {\n            repo.oopsChecked(\"more other data\");\n            fail(\"should have thrown CheckedOops\");\n        }\n        catch (CheckedOops expected)\n        {\n            //expected.printStackTrace();\n            System.currentTimeMillis();// ok\n        }\n\n        //checked exception doesn't trigger rollback\n        //it is assumed that checked exceptions are\n        //expected and should be delbt with manually\n        //where runtime exceptions are unexpected. As\n        //such, internal code may not be prepared to\n        //deal with them so Prevayler rolls back\n        assertEquals(\"more other data\", repo.getData());\n    }\n}\n","lineNo":109}
{"Smelly Sample":"package org.prevayler.demos.demo2;\n\nimport org.prevayler.Prevayler;\nimport org.prevayler.PrevaylerFactory;\nimport org.prevayler.demos.demo2.business.Bank;\n\n\npublic class MainReplica {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tout(    \"This demo shows how your application can be replicated\"\n\t\t\t+ \"\\nwithout changing ONE SINGLE LINE OF CODE in the\"\n\t\t\t+ \"\\nbusiness classes or GUI. This enables query load-\"\n\t\t\t+ \"\\nbalancing and system fault-tolerance.\\n\\n\"\n\t\t);\n\n\t\tif (args.length != 1) {\n\t\t\tout(  \"Usage:   java MainReplica <Server IP Address>\"\n\t\t\t\t+ \"\\nExample: java MainReplica 10.42.10.5\"\n\t\t\t\t+ \"\\nExample: java MainReplica localhost\"\n\t\t\t\t+ \"\\n\\nBefore that, though, you must run: java MainReplicaServer\"\n\t\t\t\t+ \"\\non this machine or any other in your network, if you haven't\"\n\t\t\t\t+ \"\\nalready done so.\\n\\n\"\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(new Bank());\n\t\tfactory.configurePrevalenceDirectory(\"demo2Replica\");\n\t\tfactory.configureReplicationClient(args[0], PrevaylerFactory.DEFAULT_REPLICATION_PORT);\n\t\tPrevayler prevayler = factory.create();\n\n\t\tMain.startSnapshots(prevayler);\n\t}\n\n\n\tprivate static void out(String message) {\n\t\tSystem.out.println(message);\n\t}\t\t\n\n}\n","Method after Refactoring":"package org.prevayler.demos.demo2;\n\nimport org.prevayler.Prevayler;\nimport org.prevayler.PrevaylerFactory;\nimport org.prevayler.demos.demo2.business.Bank;\n\n\npublic class MainReplica {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tout(    \"This demo shows how your application can be replicated\"\n\t\t\t+ \"\\nwithout changing ONE SINGLE LINE OF CODE in the\"\n\t\t\t+ \"\\nbusiness classes or GUI. This enables query load-\"\n\t\t\t+ \"\\nbalancing and system fault-tolerance.\\n\\n\"\n\t\t);\n\n\t\tString serverURI;\n\t\tif (args.length == 1) {\n\t\t\tserverURI = args[0];\n\t\t} else {\n\t\t\tout(  \"Usage:   java MainReplica <Server IP Address>\"\n\t\t\t\t\t+ \"\\nExample: java MainReplica 10.42.10.5\"\n\t\t\t\t\t+ \"\\n\\nBefore that, though, you must run: java MainReplicaServer\"\n\t\t\t\t\t+ \"\\non this machine or any other in your network, if you haven't\"\n\t\t\t\t\t+ \"\\nalready done so.\\n\"\n\t\t\t\t\t+ \"\\nTrying to find server on localhost...\"\n\t\t\t\t);\n\n\t\t\tserverURI = \"localhost\";\n\t\t}\n\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(new Bank());\n\t\tfactory.configurePrevalenceDirectory(\"demo2Replica\");\n\t\tfactory.configureReplicationClient(serverURI, PrevaylerFactory.DEFAULT_REPLICATION_PORT);\n\t\tPrevayler prevayler = factory.create();\n\n\t\tMain.startSnapshots(prevayler);\n\t}\n\n\n\tprivate static void out(String message) {\n\t\tSystem.out.println(message);\n\t}\t\t\n\n}\n","lineNo":17}
{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation.replication;\n\nimport org.prevayler.foundation.network.ObjectSocket;\nimport org.prevayler.implementation.Capsule;\nimport org.prevayler.implementation.TransactionCapsule;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.implementation.publishing.POBox;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\n\nimport java.io.IOException;\nimport java.util.Date;\n\n\n/** Reserved for future implementation.\n */\nclass ServerConnection extends Thread implements TransactionSubscriber {\n\n\tstatic final String SUBSCRIBER_UP_TO_DATE = \"SubscriberUpToDate\";\n\tstatic final String REMOTE_TRANSACTION = \"RemoteTransaction\";\n\tstatic final String CLOCK_TICK = \"ClockTick\";\n\n\tprivate final TransactionPublisher _publisher;\n\tprivate TransactionCapsule _remoteCapsule;\n\n\tprivate final ObjectSocket _remote;\n\tprivate Thread _clockTickSender = createClockTickSender();\n\tprivate boolean _isClosing = false;\n\n\n\tServerConnection(TransactionPublisher publisher, ObjectSocket remoteSocket) throws IOException {\n\t\t_publisher = publisher;\n\t\t_remote = remoteSocket;\n\t\tsetDaemon(true);\n\t\tstart();\n\t}\n\n\n\n\tpublic void run() {\n\t\ttry {\t\t\n\t\t\tlong initialTransaction = ((Long)_remote.readObject()).longValue();\n\t\t\t_publisher.subscribe(new POBox(this), initialTransaction);\n\t\t\tsend(SUBSCRIBER_UP_TO_DATE);\n\t\t\t\n\t\t\tsendClockTicks();\n\t\t\twhile (true) publishRemoteTransaction();\n\t\t} catch (Exception ex) {\n\t\t\tclose();\n\t\t}\n\t}\n\n\n\tprivate void sendClockTicks() {\n\t\t_clockTickSender.setDaemon(true);\n\t\t_clockTickSender.start();\n\t}\n\n\n\tprivate Thread createClockTickSender() {\n\t\treturn new Thread() { //TODO Create foundation.Daemon.\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tsynchronized (_remote) {\n\t\t\t\t\t\t\t\t\t_remote.writeObject(CLOCK_TICK);\n\t\t\t\t\t\t\t\t\t_remote.writeObject(_publisher.clock().time());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (InterruptedException ix) {\n\t\t\t\t\t\t} catch (IOException iox) {\n\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t}\n\n\n\n\tvoid publishRemoteTransaction() throws IOException, ClassNotFoundException {\n\t\t_remoteCapsule = (TransactionCapsule)_remote.readObject();\n\t\ttry {\n\t\t\t_publisher.publish(_remoteCapsule);\n\t\t} catch (RuntimeException rx) {\n\t\t\tsend(rx);\n\t\t} catch (Error error) {\n\t\t\tsend(error);\n\t\t}\n\t}\n\n\n\tpublic void receive(TransactionTimestamp transactionTimestamp) {\n\t\tCapsule capsule = transactionTimestamp.capsule();\n\t\tlong systemVersion = transactionTimestamp.systemVersion();\n\t\tDate executionTime = transactionTimestamp.executionTime();\n\n\t\ttry {\n\t\t\tsynchronized (_remote) {\n\t\t\t\t_remote.writeObject(capsule == _remoteCapsule\n\t\t\t\t\t? (Object)REMOTE_TRANSACTION\n\t\t\t\t\t: capsule\n\t\t\t\t);\n\t\t\t\t_remote.writeObject(executionTime);\n\t\t\t\t_remote.writeObject(new Long(systemVersion));\n\t\t\t}\n\t\t} catch (IOException ex) {\n\t\t\tclose();\n\t\t}\n\t}\n\n\n\tprivate synchronized void close() {\n\t\t_clockTickSender.interrupt();\n\t\tthis.interrupt();\n\t\t_publisher.cancelSubscription(this);\n\t}\n\n\n\n\tprivate void send(Object object) {\n\t\tsynchronized (_remote) {\n\t\t\ttry {\n\t\t\t\t_remote.writeObject(object);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation.replication;\n\nimport org.prevayler.foundation.network.ObjectSocket;\nimport org.prevayler.implementation.Capsule;\nimport org.prevayler.implementation.TransactionCapsule;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.implementation.publishing.POBox;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\n\nimport java.io.IOException;\n\n\n/** Reserved for future implementation.\n */\nclass ServerConnection extends Thread implements TransactionSubscriber {\n\n\tstatic final String SUBSCRIBER_UP_TO_DATE = \"SubscriberUpToDate\";\n\tstatic final String REMOTE_TRANSACTION = \"RemoteTransaction\";\n\n\tprivate final TransactionPublisher _publisher;\n\tprivate Capsule _remoteCapsule;\n\n\tprivate final ObjectSocket _remote;\n\tprivate Thread _clockTickSender = createClockTickSender();\n\tprivate boolean _isClosing = false;\n\n\n\tServerConnection(TransactionPublisher publisher, ObjectSocket remoteSocket) throws IOException {\n\t\t_publisher = publisher;\n\t\t_remote = remoteSocket;\n\t\tsetDaemon(true);\n\t\tstart();\n\t}\n\n\n\n\tpublic void run() {\n\t\ttry {\t\t\n\t\t\tlong initialTransaction = ((Long)_remote.readObject()).longValue();\n\t\t\t\n\t\t\tPOBox poBox = new POBox(this);\n\t\t\t_publisher.subscribe(poBox, initialTransaction);\n\t\t\tpoBox.waitToEmpty();\n\t\t\t\n\t\t\tsend(SUBSCRIBER_UP_TO_DATE);\n\t\t\t\n\t\t\tsendClockTicks();\n\t\t\twhile (true) publishRemoteTransaction();\n\t\t} catch (Exception ex) {\n\t\t\tclose();\n\t\t}\n\t}\n\n\n\tprivate void sendClockTicks() {\n\t\t_clockTickSender.setDaemon(true);\n\t\t_clockTickSender.start();\n\t}\n\n\n\tprivate Thread createClockTickSender() {\n\t\treturn new Thread() { //TODO Create foundation.Daemon.\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tsynchronized (_remote) {\n\t\t\t\t\t\t\t\t\t_remote.writeObject(_publisher.clock().time());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (InterruptedException ix) {\n\t\t\t\t\t\t} catch (IOException iox) {\n\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t}\n\n\n\n\tvoid publishRemoteTransaction() throws IOException, ClassNotFoundException {\n\t\t_remoteCapsule = (TransactionCapsule)_remote.readObject();\n\t\ttry {\n\t\t\t_publisher.publish(_remoteCapsule);\n\t\t} catch (RuntimeException rx) {\n\t\t\tsend(rx);\n\t\t} catch (Error error) {\n\t\t\tsend(error);\n\t\t}\n\t}\n\n\n\tpublic void receive(TransactionTimestamp tt) {\n\t\t\n\t\tif (tt.capsule() == _remoteCapsule)\n\t\t\ttt = new TransactionTimestamp(null, tt.systemVersion(), tt.executionTime()); //TODO This is really ugly. It is using a null capsule inside the TransactionTimestamp to signal that the remote Capsule should be executed.\n\t\t\n\t\ttry {\n\t\t\tsynchronized (_remote) {\n\t\t\t\t_remote.writeObject(tt);\n\t\t\t}\n\t\t} catch (IOException ex) {\n\t\t\tclose();\n\t\t}\n\t}\n\n\n\tprivate synchronized void close() {\n\t\t_clockTickSender.interrupt();\n\t\tthis.interrupt();\n\t\t_publisher.cancelSubscription(this);\n\t}\n\n\n\n\tprivate void send(Object object) {\n\t\tsynchronized (_remote) {\n\t\t\ttry {\n\t\t\t\t_remote.writeObject(object);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n}\n","lineNo":46}
{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Aleksey Aristov, Carlos Villela, Justin Sampson.\n\npackage org.prevayler;\n\nimport org.prevayler.implementation.PrevaylerDirectory;\nimport org.prevayler.foundation.monitor.Monitor;\nimport org.prevayler.foundation.monitor.SimpleMonitor;\nimport org.prevayler.foundation.serialization.JavaSerializer;\nimport org.prevayler.foundation.serialization.Serializer;\nimport org.prevayler.foundation.serialization.SkaringaSerializer;\nimport org.prevayler.foundation.serialization.XStreamSerializer;\nimport org.prevayler.implementation.PrevaylerImpl;\nimport org.prevayler.implementation.clock.MachineClock;\nimport org.prevayler.implementation.journal.Journal;\nimport org.prevayler.implementation.journal.PersistentJournal;\nimport org.prevayler.implementation.journal.TransientJournal;\nimport org.prevayler.implementation.publishing.CentralPublisher;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.censorship.LiberalTransactionCensor;\nimport org.prevayler.implementation.publishing.censorship.StrictTransactionCensor;\nimport org.prevayler.implementation.publishing.censorship.TransactionCensor;\nimport org.prevayler.implementation.replication.ClientPublisher;\nimport org.prevayler.implementation.replication.ServerListener;\nimport org.prevayler.implementation.snapshot.GenericSnapshotManager;\nimport org.prevayler.implementation.snapshot.NullSnapshotManager;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/** Provides easy access to all Prevayler configurations and implementations available in this distribution.\n * Static methods are also provided as short-cuts for the most common configurations. \n * <br>By default, the Prevayler instances created by this class will write their Transactions to .journal files before executing them. The FileDescriptor.sync() method is called to make sure the Java file write-buffers have been written to the operating system. Many operating systems, including most recent versions of Linux and Windows, allow the hard-drive's write-cache to be disabled. This guarantees no executed Transaction will be lost in the event of a power shortage, for example.\n * <br>Also by default, the Prevayler instances created by this class will filter out all Transactions that would throw a RuntimeException or Error if executed on the Prevalent System. This requires enough RAM to hold another copy of the prevalent system. \n * @see Prevayler \n */\npublic class PrevaylerFactory {\n\n\tprivate Object _prevalentSystem;\n\tprivate Clock _clock;\n\n\tprivate boolean _transactionFiltering = true;\n\n\tprivate boolean _transientMode;\n\tprivate String _prevalenceDirectory;\n\tprivate NullSnapshotManager _nullSnapshotManager;\n\n\tprivate long _journalSizeThreshold;\n\tprivate long _journalAgeThreshold;\n\t\n\tprivate int _serverPort = -1;\n\tprivate String _remoteServerIpAddress;\n\tprivate int _remoteServerPort;\n    private Monitor _monitor;\n\tprivate ClassLoader _classLoader;\n\n\tprivate Serializer _journalSerializer;\n\tprivate String _journalSuffix;\n\tprivate Map _snapshotSerializers = new HashMap();\n\tprivate String _primarySnapshotSuffix;\n\n\tpublic static final int DEFAULT_REPLICATION_PORT = 8756;\n\n\n\t/** Creates a Prevayler that will use a directory called \"PrevalenceBase\" under the current directory to read and write its .snapshot and .journal files.\n \t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t */\n\tpublic static Prevayler createPrevayler(Serializable newPrevalentSystem) throws IOException, ClassNotFoundException {\n\t\treturn createPrevayler(newPrevalentSystem, \"PrevalenceBase\");\n\t}\n\n\n\t/** Creates a Prevayler that will use the given prevalenceBase directory to read and write its .snapshot and .journal files.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t * @param prevalenceBase The directory where the .snapshot files and .journal files will be read and written.\n\t */\n\tpublic static Prevayler createPrevayler(Serializable newPrevalentSystem, String prevalenceBase) throws IOException, ClassNotFoundException {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configurePrevalenceDirectory(prevalenceBase);\n\t\treturn factory.create();\n\t}\n\n\n\t/** Creates a Prevayler that will execute Transactions WITHOUT writing them to disk. This is useful for running automated tests or demos MUCH faster than with a regular Prevayler.\n\t * \n\t * Attempts to take snapshots on this transient Prevayler will throw an IOException.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system.\n\t * @see #createCheckpointPrevayler(Serializable newPrevalentSystem, String snapshotDirectory)\n\t */\n\tpublic static Prevayler createTransientPrevayler(Serializable newPrevalentSystem) {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configureNullSnapshotManager(new NullSnapshotManager(newPrevalentSystem, \"Transient Prevaylers are unable to take snapshots.\"));\n\t\tfactory.configureTransientMode(true);\n\t\ttry {\n\t\t\treturn factory.create();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(); //Transient Prevayler creation should not fail.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/** @deprecated Use createCheckpointPrevayler() instead of this method. Deprecated since Prevayler2.00.001.\n\t */\n\tpublic static Prevayler createTransientPrevayler(Serializable newPrevalentSystem, String snapshotDirectory) {\n\t\treturn createCheckpointPrevayler(newPrevalentSystem, snapshotDirectory);\n\t}\n\n\t/** Creates a Prevayler that will execute Transactions WITHOUT writing them to disk. Snapshots will work as \"checkpoints\" for the system, therefore. This is useful for stand-alone applications that have a \"Save\" button, for example.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t * @param snapshotDirectory The directory where the .snapshot files will be read and written.\n\t */\n\tpublic static Prevayler createCheckpointPrevayler(Serializable newPrevalentSystem, String snapshotDirectory) {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configurePrevalenceDirectory(snapshotDirectory);\n\t\tfactory.configureTransientMode(true);\n\t\ttry {\n\t\t\treturn factory.create();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(); //Transient Prevayler creation should not fail.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate Clock clock() {\n\t\treturn _clock != null ? _clock : new MachineClock();\n\t}\n\n\t/**\n\t * Assigns a monitor object to receive notifications from Prevayler. This is useful for logging or sending eMails to system administrators, for example. If this method is not called or if null is passed as a parameter, a SimpleMonitor will be used to log notification on System.err.\n\t * \n\t * @param monitor the Monitor implementation to use.\n\t * @see org.prevayler.foundation.monitor.SimpleMonitor\n\t */\n\tpublic void configureMonitor(Monitor monitor) {\n\t    _monitor = monitor;\n\t}\n\n\t/** Determines whether the Prevayler created by this factory should be transient (transientMode = true) or persistent (transientMode = false). Default is persistent. A transient Prevayler will execute its Transactions WITHOUT writing them to disk. This is useful for stand-alone applications which have a \"Save\" button, for example, or for running automated tests MUCH faster than with a persistent Prevayler.\n\t */\n\tpublic void configureTransientMode(boolean transientMode) {\n\t\t_transientMode = transientMode;\t\t\n\t}\n\n\n\t/** Configures the Clock that will be used by the created Prevayler. The Clock interface can be implemented by the application if it requires Prevayler to use a special time source other than the machine clock (default).\n\t */\n\tpublic void configureClock(Clock clock) {\n\t\t_clock = clock;\n\t}\n\n\n\t/** Configures the directory where the created Prevayler will read and write its .journal and .snapshot files. The default is a directory called \"PrevalenceBase\" under the current directory.\n\t * @param prevalenceDirectory Will be ignored for the .snapshot files if a SnapshotManager is configured.\n\t */\n\tpublic void configurePrevalenceDirectory(String prevalenceDirectory) {\n\t\t_prevalenceDirectory = prevalenceDirectory;\n\t}\n\n\n\t/** Configures the prevalent system that will be used by the Prevayler created by this factory.\n\t * @param newPrevalentSystem If the default Serializer is used, this prevalentSystem must be Serializable. If another Serializer is used, this prevalentSystem must be compatible with it.\n     * @see #configureSnapshotSerializer(String,Serializer)\n\t */\n\tpublic void configurePrevalentSystem(Object newPrevalentSystem) {\n\t\t_prevalentSystem = newPrevalentSystem;\n\t}\n\n\n\t/** Reserved for future implementation.\n\t */\n\tpublic void configureReplicationClient(String remoteServerIpAddress, int remoteServerPort) {\n\t\t_remoteServerIpAddress = remoteServerIpAddress;\n\t\t_remoteServerPort = remoteServerPort;\n\t}\n\n\n\t/** Reserved for future implementation.\n\t */\n\tpublic void configureReplicationServer(int port) {\n\t\t_serverPort = port;\n\t}\n\n\n\tprivate void configureNullSnapshotManager(NullSnapshotManager snapshotManager) {\n\t\t_nullSnapshotManager = snapshotManager;\n\t}\n\n\n\t/** Determines whether the Prevayler created by this factory should filter out all Transactions that would throw a RuntimeException or Error if executed on the Prevalent System (default is true). This requires enough RAM to hold another copy of the prevalent system.\n\t */\n\tpublic void configureTransactionFiltering(boolean transactionFiltering) {\n\t\t_transactionFiltering = transactionFiltering;\n\t}\n\n\n\t/**\n\t * Configures the size (in bytes) of the journal file. When the current journal exceeds this size, a new journal is created.\n\t */\n\tpublic void configureJournalFileSizeThreshold(long sizeInBytes) {\n\t\t_journalSizeThreshold = sizeInBytes;\n\t}\n\n\n\t/**\n\t * Sets the age (in milliseconds) of the journal file. When the current journal expires, a new journal is created.\n\t */\n\tpublic void configureJournalFileAgeThreshold(long ageInMilliseconds) {\n\t\t_journalAgeThreshold = ageInMilliseconds;\n\t}\n\n\n\t/**\n\t * @deprecated Use {@link #configureSnapshotSerializer(String,Serializer)} and {@link #configureJournalSerializer(JavaSerializer)} instead, giving a {@link JavaSerializer} with the desired classloader.\n\t */\n\tpublic void configureClassLoader(ClassLoader classLoader) {\n\t\t_classLoader = classLoader;\n\t}\n\n\n\tpublic void configureJournalSerializer(JavaSerializer serializer) {\n\t\tconfigureJournalSerializer(\"journal\", serializer);\n\t}\n\n\tpublic void configureJournalSerializer(XStreamSerializer serializer) {\n\t\tconfigureJournalSerializer(\"xstreamjournal\", serializer);\n\t}\n\n\tpublic void configureJournalSerializer(SkaringaSerializer serializer) {\n\t\tconfigureJournalSerializer(\"skaringajournal\", serializer);\n\t}\n\n\t/**\n\t * Configures the transaction journal Serializer to be used by the Prevayler created by this factory. Only one Serializer is supported at a time. If you want to change the Serializer of a system in production, you will have to take a snapshot first because the journal files written by the previous Serializer will not be read. \n\t */\n\tpublic void configureJournalSerializer(String suffix, Serializer serializer) {\n\t\tPrevaylerDirectory.checkValidJournalSuffix(suffix);\n\n\t\tif (_journalSerializer != null) {\n\t\t\tthrow new IllegalStateException(\"Read the javadoc to this method.\");\n\t\t}\n\n\t\t_journalSerializer = serializer;\n\t\t_journalSuffix = suffix;\n\t}\n\n\n\tpublic void configureSnapshotSerializer(JavaSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"snapshot\", serializer);\n\t}\n\n\tpublic void configureSnapshotSerializer(XStreamSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"xstreamsnapshot\", serializer);\n\t}\n\n\tpublic void configureSnapshotSerializer(SkaringaSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"skaringasnapshot\", serializer);\n\t}\n\n\t/**\n\t * Configure a serialization strategy for snapshots. This may be called any number of times with\n\t * different suffixes to configure different strategies for reading existing snapshots. The first\n\t * call to this method establishes the <i>primary<\/i> strategy, which will be used for writing\n\t * snapshots as well as for deep-copying the prevalent system whenever necessary.\n\t */\n\tpublic void configureSnapshotSerializer(String suffix, Serializer serializer) {\n\t\tPrevaylerDirectory.checkValidSnapshotSuffix(suffix);\n\t\t_snapshotSerializers.put(suffix, serializer);\n\t\tif (_primarySnapshotSuffix == null) {\n\t\t\t_primarySnapshotSuffix = suffix;\n\t\t}\n\t}\n\n\n\t/** Returns a Prevayler created according to what was defined by calls to the configuration methods above.\n\t * @throws IOException If there is trouble creating the Prevalence Base directory or reading a .journal or .snapshot file.\n\t * @throws ClassNotFoundException If a class of a serialized Object is not found when reading a .journal or .snapshot file.\n\t */\n\tpublic Prevayler create() throws IOException, ClassNotFoundException {\n\t\tGenericSnapshotManager snapshotManager = snapshotManager();\n\t\tTransactionPublisher publisher = publisher(snapshotManager);\n\t\tif (_serverPort != -1) new ServerListener(publisher, _serverPort);\n\t\treturn new PrevaylerImpl(snapshotManager, publisher, monitor(), journalSerializer());\n\t}\n\n\n    private String prevalenceDirectory() {\n\t\treturn _prevalenceDirectory != null ? _prevalenceDirectory : \"Prevalence\";\n\t}\n\n\n\tprivate Object prevalentSystem() {\n\t\tif (_prevalentSystem == null) throw new IllegalStateException(\"The prevalent system must be configured.\");\n\t\treturn _prevalentSystem;\n\t}\n\n\n\tprivate TransactionPublisher publisher(GenericSnapshotManager snapshotManager) throws IOException {\n\t\tif (_remoteServerIpAddress != null) return new ClientPublisher(_remoteServerIpAddress, _remoteServerPort);\n\t\treturn new CentralPublisher(clock(), censor(snapshotManager), journal()); \n\t}\n\n\n\tprivate TransactionCensor censor(GenericSnapshotManager snapshotManager) {\n\t\treturn _transactionFiltering\n\t\t\t? (TransactionCensor) new StrictTransactionCensor(snapshotManager, journalSerializer())\n\t\t\t: new LiberalTransactionCensor(); \n\t}\n\n\n\tprivate Journal journal() throws IOException {\n\t\tif (_transientMode) {\n\t\t\treturn (Journal) new TransientJournal();\n\t\t} else {\n\t\t\tPrevaylerDirectory directory = new PrevaylerDirectory(prevalenceDirectory());\n\t\t\treturn new PersistentJournal(directory, _journalSizeThreshold, _journalAgeThreshold,\n\t\t\t\t\tjournalSuffix(), journalSerializer(), monitor());\n\t\t}\n\t}\n\n\t\n\tprivate Serializer journalSerializer() {\n\t\tif (_journalSerializer != null) return _journalSerializer;\n\t\treturn new JavaSerializer(_classLoader);\n\t}\n\n\tprivate String journalSuffix() {\n\t\tif (_journalSuffix != null) return _journalSuffix;\n\t\treturn \"journal\";\n\t}\n\n\n\tprivate GenericSnapshotManager snapshotManager() throws ClassNotFoundException, IOException {\n\t\tif (_nullSnapshotManager != null) {\n\t\t\treturn _nullSnapshotManager;\n\t\t} else {\n\t\t\tPrevaylerDirectory directory = new PrevaylerDirectory(prevalenceDirectory());\n\t\t\tif (!_snapshotSerializers.isEmpty()) {\n\t\t\t\treturn new GenericSnapshotManager(_snapshotSerializers, _primarySnapshotSuffix, prevalentSystem(), directory);\n\t\t\t} else {\n\t\t\t\treturn new GenericSnapshotManager(new JavaSerializer(_classLoader), prevalentSystem(), directory);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tprivate Monitor monitor() {\n\t\treturn _monitor != null ? _monitor : new SimpleMonitor(System.err);\n    }\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Aleksey Aristov, Carlos Villela, Justin Sampson.\n\npackage org.prevayler;\n\nimport org.prevayler.foundation.monitor.Monitor;\nimport org.prevayler.foundation.monitor.SimpleMonitor;\nimport org.prevayler.foundation.serialization.JavaSerializer;\nimport org.prevayler.foundation.serialization.Serializer;\nimport org.prevayler.foundation.serialization.SkaringaSerializer;\nimport org.prevayler.foundation.serialization.XStreamSerializer;\nimport org.prevayler.implementation.PrevaylerDirectory;\nimport org.prevayler.implementation.PrevaylerImpl;\nimport org.prevayler.implementation.clock.MachineClock;\nimport org.prevayler.implementation.journal.Journal;\nimport org.prevayler.implementation.journal.PersistentJournal;\nimport org.prevayler.implementation.journal.TransientJournal;\nimport org.prevayler.implementation.publishing.CentralPublisher;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.censorship.LiberalTransactionCensor;\nimport org.prevayler.implementation.publishing.censorship.StrictTransactionCensor;\nimport org.prevayler.implementation.publishing.censorship.TransactionCensor;\nimport org.prevayler.implementation.replication.ClientPublisher;\nimport org.prevayler.implementation.replication.ServerListener;\nimport org.prevayler.implementation.snapshot.GenericSnapshotManager;\nimport org.prevayler.implementation.snapshot.NullSnapshotManager;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/** Provides easy access to all Prevayler configurations and implementations available in this distribution.\n * Static methods are also provided as short-cuts for the most common configurations. \n * <br>By default, the Prevayler instances created by this class will write their Transactions to .journal files before executing them. The FileDescriptor.sync() method is called to make sure the Java file write-buffers have been written to the operating system. Many operating systems, including most recent versions of Linux and Windows, allow the hard-drive's write-cache to be disabled. This guarantees no executed Transaction will be lost in the event of a power shortage, for example.\n * <br>Also by default, the Prevayler instances created by this class will filter out all Transactions that would throw a RuntimeException or Error if executed on the Prevalent System. This requires enough RAM to hold another copy of the prevalent system. \n * @see Prevayler \n */\npublic class PrevaylerFactory {\n\n\tprivate Object _prevalentSystem;\n\tprivate Clock _clock;\n\n\tprivate boolean _transactionFiltering = true;\n\n\tprivate boolean _transientMode;\n\tprivate String _prevalenceDirectory;\n\tprivate NullSnapshotManager _nullSnapshotManager;\n\n\tprivate long _journalSizeThreshold;\n\tprivate long _journalAgeThreshold;\n\t\n\tprivate int _serverPort = -1;\n\tprivate String _remoteServerIpAddress;\n\tprivate int _remoteServerPort;\n    private Monitor _monitor;\n\tprivate ClassLoader _classLoader;\n\n\tprivate Serializer _journalSerializer;\n\tprivate String _journalSuffix;\n\tprivate Map _snapshotSerializers = new HashMap();\n\tprivate String _primarySnapshotSuffix;\n\n\tpublic static final int DEFAULT_REPLICATION_PORT = 8756;\n\n\n\t/** Creates a Prevayler that will use a directory called \"PrevalenceBase\" under the current directory to read and write its .snapshot and .journal files.\n \t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t */\n\tpublic static Prevayler createPrevayler(Serializable newPrevalentSystem) throws IOException, ClassNotFoundException {\n\t\treturn createPrevayler(newPrevalentSystem, \"PrevalenceBase\");\n\t}\n\n\n\t/** Creates a Prevayler that will use the given prevalenceBase directory to read and write its .snapshot and .journal files.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t * @param prevalenceBase The directory where the .snapshot files and .journal files will be read and written.\n\t */\n\tpublic static Prevayler createPrevayler(Serializable newPrevalentSystem, String prevalenceBase) throws IOException, ClassNotFoundException {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configurePrevalenceDirectory(prevalenceBase);\n\t\treturn factory.create();\n\t}\n\n\n\t/** Creates a Prevayler that will execute Transactions WITHOUT writing them to disk. This is useful for running automated tests or demos MUCH faster than with a regular Prevayler.\n\t * \n\t * Attempts to take snapshots on this transient Prevayler will throw an IOException.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system.\n\t * @see #createCheckpointPrevayler(Serializable newPrevalentSystem, String snapshotDirectory)\n\t */\n\tpublic static Prevayler createTransientPrevayler(Serializable newPrevalentSystem) {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configureNullSnapshotManager(new NullSnapshotManager(newPrevalentSystem, \"Transient Prevaylers are unable to take snapshots.\"));\n\t\tfactory.configureTransientMode(true);\n\t\ttry {\n\t\t\treturn factory.create();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(); //Transient Prevayler creation should not fail.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/** @deprecated Use createCheckpointPrevayler() instead of this method. Deprecated since Prevayler2.00.001.\n\t */\n\tpublic static Prevayler createTransientPrevayler(Serializable newPrevalentSystem, String snapshotDirectory) {\n\t\treturn createCheckpointPrevayler(newPrevalentSystem, snapshotDirectory);\n\t}\n\n\t/** Creates a Prevayler that will execute Transactions WITHOUT writing them to disk. Snapshots will work as \"checkpoints\" for the system, therefore. This is useful for stand-alone applications that have a \"Save\" button, for example.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t * @param snapshotDirectory The directory where the .snapshot files will be read and written.\n\t */\n\tpublic static Prevayler createCheckpointPrevayler(Serializable newPrevalentSystem, String snapshotDirectory) {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configurePrevalenceDirectory(snapshotDirectory);\n\t\tfactory.configureTransientMode(true);\n\t\ttry {\n\t\t\treturn factory.create();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(); //Transient Prevayler creation should not fail.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate Clock clock() {\n\t\treturn _clock != null ? _clock : new MachineClock();\n\t}\n\n\t/**\n\t * Assigns a monitor object to receive notifications from Prevayler. This is useful for logging or sending eMails to system administrators, for example. If this method is not called or if null is passed as a parameter, a SimpleMonitor will be used to log notification on System.err.\n\t * \n\t * @param monitor the Monitor implementation to use.\n\t * @see org.prevayler.foundation.monitor.SimpleMonitor\n\t */\n\tpublic void configureMonitor(Monitor monitor) {\n\t    _monitor = monitor;\n\t}\n\n\t/** Determines whether the Prevayler created by this factory should be transient (transientMode = true) or persistent (transientMode = false). Default is persistent. A transient Prevayler will execute its Transactions WITHOUT writing them to disk. This is useful for stand-alone applications which have a \"Save\" button, for example, or for running automated tests MUCH faster than with a persistent Prevayler.\n\t */\n\tpublic void configureTransientMode(boolean transientMode) {\n\t\t_transientMode = transientMode;\t\t\n\t}\n\n\n\t/** Configures the Clock that will be used by the created Prevayler. The Clock interface can be implemented by the application if it requires Prevayler to use a special time source other than the machine clock (default).\n\t */\n\tpublic void configureClock(Clock clock) {\n\t\t_clock = clock;\n\t}\n\n\n\t/** Configures the directory where the created Prevayler will read and write its .journal and .snapshot files. The default is a directory called \"PrevalenceBase\" under the current directory.\n\t * @param prevalenceDirectory Will be ignored for the .snapshot files if a SnapshotManager is configured.\n\t */\n\tpublic void configurePrevalenceDirectory(String prevalenceDirectory) {\n\t\t_prevalenceDirectory = prevalenceDirectory;\n\t}\n\n\n\t/** Configures the prevalent system that will be used by the Prevayler created by this factory.\n\t * @param newPrevalentSystem If the default Serializer is used, this prevalentSystem must be Serializable. If another Serializer is used, this prevalentSystem must be compatible with it.\n     * @see #configureSnapshotSerializer(String,Serializer)\n\t */\n\tpublic void configurePrevalentSystem(Object newPrevalentSystem) {\n\t\t_prevalentSystem = newPrevalentSystem;\n\t}\n\n\n\t/** Reserved for future implementation.\n\t */\n\tpublic void configureReplicationClient(String remoteServerIpAddress, int remoteServerPort) {\n\t\t_remoteServerIpAddress = remoteServerIpAddress;\n\t\t_remoteServerPort = remoteServerPort;\n\t}\n\n\n\t/** Reserved for future implementation.\n\t */\n\tpublic void configureReplicationServer(int port) {\n\t\t_serverPort = port;\n\t}\n\n\n\tprivate void configureNullSnapshotManager(NullSnapshotManager snapshotManager) {\n\t\t_nullSnapshotManager = snapshotManager;\n\t}\n\n\n\t/** Determines whether the Prevayler created by this factory should filter out all Transactions that would throw a RuntimeException or Error if executed on the Prevalent System (default is true). This requires enough RAM to hold another copy of the prevalent system.\n\t */\n\tpublic void configureTransactionFiltering(boolean transactionFiltering) {\n\t\t_transactionFiltering = transactionFiltering;\n\t}\n\n\n\t/**\n\t * Configures the size (in bytes) of the journal file. When the current journal exceeds this size, a new journal is created.\n\t */\n\tpublic void configureJournalFileSizeThreshold(long sizeInBytes) {\n\t\t_journalSizeThreshold = sizeInBytes;\n\t}\n\n\n\t/**\n\t * Sets the age (in milliseconds) of the journal file. When the current journal expires, a new journal is created.\n\t */\n\tpublic void configureJournalFileAgeThreshold(long ageInMilliseconds) {\n\t\t_journalAgeThreshold = ageInMilliseconds;\n\t}\n\n\n\t/**\n\t * @deprecated Use {@link #configureSnapshotSerializer(String,Serializer)} and {@link #configureJournalSerializer(JavaSerializer)} instead, giving a {@link JavaSerializer} with the desired classloader.\n\t */\n\tpublic void configureClassLoader(ClassLoader classLoader) {\n\t\t_classLoader = classLoader;\n\t}\n\n\n\tpublic void configureJournalSerializer(JavaSerializer serializer) {\n\t\tconfigureJournalSerializer(\"journal\", serializer);\n\t}\n\n\tpublic void configureJournalSerializer(XStreamSerializer serializer) {\n\t\tconfigureJournalSerializer(\"xstreamjournal\", serializer);\n\t}\n\n\tpublic void configureJournalSerializer(SkaringaSerializer serializer) {\n\t\tconfigureJournalSerializer(\"skaringajournal\", serializer);\n\t}\n\n\t/**\n\t * Configures the transaction journal Serializer to be used by the Prevayler created by this factory. Only one Serializer is supported at a time. If you want to change the Serializer of a system in production, you will have to take a snapshot first because the journal files written by the previous Serializer will not be read. \n\t */\n\tpublic void configureJournalSerializer(String suffix, Serializer serializer) {\n\t\tPrevaylerDirectory.checkValidJournalSuffix(suffix);\n\n\t\tif (_journalSerializer != null) {\n\t\t\tthrow new IllegalStateException(\"Read the javadoc to this method.\");\n\t\t}\n\n\t\t_journalSerializer = serializer;\n\t\t_journalSuffix = suffix;\n\t}\n\n\n\tpublic void configureSnapshotSerializer(JavaSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"snapshot\", serializer);\n\t}\n\n\tpublic void configureSnapshotSerializer(XStreamSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"xstreamsnapshot\", serializer);\n\t}\n\n\tpublic void configureSnapshotSerializer(SkaringaSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"skaringasnapshot\", serializer);\n\t}\n\n\t/**\n\t * Configure a serialization strategy for snapshots. This may be called any number of times with\n\t * different suffixes to configure different strategies for reading existing snapshots. The first\n\t * call to this method establishes the <i>primary<\/i> strategy, which will be used for writing\n\t * snapshots as well as for deep-copying the prevalent system whenever necessary.\n\t */\n\tpublic void configureSnapshotSerializer(String suffix, Serializer serializer) {\n\t\tPrevaylerDirectory.checkValidSnapshotSuffix(suffix);\n\t\t_snapshotSerializers.put(suffix, serializer);\n\t\tif (_primarySnapshotSuffix == null) {\n\t\t\t_primarySnapshotSuffix = suffix;\n\t\t}\n\t}\n\n\n\t/** Returns a Prevayler created according to what was defined by calls to the configuration methods above.\n\t * @throws IOException If there is trouble creating the Prevalence Base directory or reading a .journal or .snapshot file.\n\t * @throws ClassNotFoundException If a class of a serialized Object is not found when reading a .journal or .snapshot file.\n\t */\n\tpublic Prevayler create() throws IOException, ClassNotFoundException {\n\t\tGenericSnapshotManager snapshotManager = snapshotManager();\n\t\tTransactionPublisher publisher = publisher(snapshotManager);\n\t\tSerializer journalSerializer = journalSerializer();\n\t\tif (_serverPort != -1) new ServerListener(publisher, _serverPort, journalSerializer);\n\t\treturn new PrevaylerImpl(snapshotManager, publisher, monitor(), journalSerializer);\n\t}\n\n\n    private String prevalenceDirectory() {\n\t\treturn _prevalenceDirectory != null ? _prevalenceDirectory : \"Prevalence\";\n\t}\n\n\n\tprivate Object prevalentSystem() {\n\t\tif (_prevalentSystem == null) throw new IllegalStateException(\"The prevalent system must be configured.\");\n\t\treturn _prevalentSystem;\n\t}\n\n\n\tprivate TransactionPublisher publisher(GenericSnapshotManager snapshotManager) throws IOException {\n\t\tif (_remoteServerIpAddress != null) return new ClientPublisher(_remoteServerIpAddress, _remoteServerPort, journalSerializer());\n\t\treturn new CentralPublisher(clock(), censor(snapshotManager), journal()); \n\t}\n\n\n\tprivate TransactionCensor censor(GenericSnapshotManager snapshotManager) {\n\t\treturn _transactionFiltering\n\t\t\t? (TransactionCensor) new StrictTransactionCensor(snapshotManager, journalSerializer())\n\t\t\t: new LiberalTransactionCensor(); \n\t}\n\n\n\tprivate Journal journal() throws IOException {\n\t\tif (_transientMode) {\n\t\t\treturn (Journal) new TransientJournal();\n\t\t} else {\n\t\t\tPrevaylerDirectory directory = new PrevaylerDirectory(prevalenceDirectory());\n\t\t\treturn new PersistentJournal(directory, _journalSizeThreshold, _journalAgeThreshold,\n\t\t\t\t\tjournalSuffix(), journalSerializer(), monitor());\n\t\t}\n\t}\n\n\t\n\tprivate Serializer journalSerializer() {\n\t\tif (_journalSerializer != null) return _journalSerializer;\n\t\treturn new JavaSerializer(_classLoader);\n\t}\n\n\tprivate String journalSuffix() {\n\t\tif (_journalSuffix != null) return _journalSuffix;\n\t\treturn \"journal\";\n\t}\n\n\n\tprivate GenericSnapshotManager snapshotManager() throws ClassNotFoundException, IOException {\n\t\tif (_nullSnapshotManager != null) {\n\t\t\treturn _nullSnapshotManager;\n\t\t} else {\n\t\t\tPrevaylerDirectory directory = new PrevaylerDirectory(prevalenceDirectory());\n\t\t\tif (!_snapshotSerializers.isEmpty()) {\n\t\t\t\treturn new GenericSnapshotManager(_snapshotSerializers, _primarySnapshotSuffix, prevalentSystem(), directory);\n\t\t\t} else {\n\t\t\t\treturn new GenericSnapshotManager(new JavaSerializer(_classLoader), prevalentSystem(), directory);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tprivate Monitor monitor() {\n\t\treturn _monitor != null ? _monitor : new SimpleMonitor(System.err);\n    }\n}\n","lineNo":290}
{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation.publishing;\n\nimport org.prevayler.Clock;\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.Cool;\nimport org.prevayler.foundation.Turn;\nimport org.prevayler.implementation.clock.PausableClock;\nimport org.prevayler.implementation.journal.Journal;\nimport org.prevayler.implementation.publishing.censorship.TransactionCensor;\n\nimport java.io.IOException;\nimport java.util.Date;\n\npublic class CentralPublisher extends AbstractPublisher {\n\n\tprivate final PausableClock _pausableClock;\n\tprivate final TransactionCensor _censor;\n\tprivate final Journal _journal;\n\tprivate long _nextTransaction;\n\n\tprivate volatile int _pendingPublications = 0;\n\tprivate final Object _pendingPublicationsMonitor = new Object();\n\n\tprivate Turn _nextTurn = Turn.first();\n\tprivate final Object _nextTurnMonitor = new Object();\n\n\n\tpublic CentralPublisher(Clock clock, TransactionCensor censor, Journal journal) {\n\t\tsuper(new PausableClock(clock));\n\t\t_pausableClock = (PausableClock)_clock; //This is just to avoid casting the inherited _clock every time.\n\n\t\t_censor = censor;\n\t\t_journal = journal;\n\t}\n\n\n\tpublic void publish(Transaction transaction) {\n\t\tsynchronized (_pendingPublicationsMonitor) {  //Blocks all new subscriptions until the publication is over.\n\t\t\tif (_pendingPublications == 0) _pausableClock.pause();\n\t\t\t_pendingPublications++;\n\t\t}\n\n\t\ttry {\n\t\t\tpublishWithoutWorryingAboutNewSubscriptions(transaction);  // Suggestions for a better method name are welcome.  :)\n\t\t} finally {\n\t\t\tsynchronized (_pendingPublicationsMonitor) {\n\t\t\t\t_pendingPublications--;\n\t\t\t\tif (_pendingPublications == 0) {\n\t\t\t\t\t_pausableClock.resume();\n\t\t\t\t\t_pendingPublicationsMonitor.notifyAll();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void publishWithoutWorryingAboutNewSubscriptions(Transaction transaction) {\n\t\tTurn myTurn = nextTurn();\n\n\t\tDate executionTime = realTime(myTurn);  //TODO realTime() and approve in the same turn.\n\t\tlong systemVersion = approve(transaction, executionTime, myTurn);\n\t\t_journal.append(transaction, executionTime, myTurn);\n\t\tnotifySubscribers(transaction, systemVersion, executionTime, myTurn);\n\t}\n\n\n\tprivate Turn nextTurn() {\n\t\tsynchronized (_nextTurnMonitor) {\n\t\t\tTurn result = _nextTurn;\n\t\t\t_nextTurn = _nextTurn.next();\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n\tprivate Date realTime(Turn myTurn) {\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\treturn _pausableClock.realTime();\n\t\t} finally {\tmyTurn.end(); }\n\t}\n\n\n\tprivate long approve(Transaction transaction, Date executionTime, Turn myTurn) throws RuntimeException, Error {\n\t\ttry {\n\t\t\tmyTurn.start();\n\n\t\t\t_censor.approve(transaction, _nextTransaction, executionTime);\n\n\t\t\tlong systemVersion = _nextTransaction++;\n\n\t\t\tmyTurn.end();\n\n\t\t\treturn systemVersion;\n\t\t} catch (RuntimeException r) { myTurn.alwaysSkip(); throw r;\n\t\t} catch (Error e) { myTurn.alwaysSkip(); throw e; }\n\t}\n\n\n\tprivate void notifySubscribers(Transaction transaction, long systemVersion, Date executionTime, Turn myTurn) {\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\t_pausableClock.advanceTo(executionTime);\n\t\t\tnotifySubscribers(transaction, systemVersion, executionTime);\n\t\t} finally {\tmyTurn.end(); }\n\t}\n\n\n\tpublic void addSubscriber(TransactionSubscriber subscriber, long initialTransaction) throws IOException, ClassNotFoundException {\n\t\tsynchronized (_pendingPublicationsMonitor) {\n\t\t\twhile (_pendingPublications != 0) Cool.wait(_pendingPublicationsMonitor);\n\t\t\t\n\t\t\t_journal.update(subscriber, initialTransaction);\n\t\t\t_nextTransaction = _journal.nextTransaction();\n\n\t\t\tsuper.addSubscriber(subscriber);\n\t\t}\n\t}\n\n\n\tpublic void close() throws IOException { _journal.close(); }\n\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation.publishing;\n\nimport org.prevayler.Clock;\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.Cool;\nimport org.prevayler.foundation.Turn;\nimport org.prevayler.implementation.TransactionGuide;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.implementation.clock.PausableClock;\nimport org.prevayler.implementation.journal.Journal;\nimport org.prevayler.implementation.publishing.censorship.TransactionCensor;\n\nimport java.io.IOException;\nimport java.util.Date;\n\npublic class CentralPublisher extends AbstractPublisher {\n\n\tprivate final PausableClock _pausableClock;\n\tprivate final TransactionCensor _censor;\n\tprivate final Journal _journal;\n\tprivate long _nextTransaction;\n\n\tprivate volatile int _pendingPublications = 0;\n\tprivate final Object _pendingPublicationsMonitor = new Object();\n\n\tprivate Turn _nextTurn = Turn.first();\n\tprivate final Object _nextTurnMonitor = new Object();\n\n\n\tpublic CentralPublisher(Clock clock, TransactionCensor censor, Journal journal) {\n\t\tsuper(new PausableClock(clock));\n\t\t_pausableClock = (PausableClock)_clock; //This is just to avoid casting the inherited _clock every time.\n\n\t\t_censor = censor;\n\t\t_journal = journal;\n\t}\n\n\n\tpublic void publish(Transaction transaction) {\n\t\tsynchronized (_pendingPublicationsMonitor) {  //Blocks all new subscriptions until the publication is over.\n\t\t\tif (_pendingPublications == 0) _pausableClock.pause();\n\t\t\t_pendingPublications++;\n\t\t}\n\n\t\ttry {\n\t\t\tpublishWithoutWorryingAboutNewSubscriptions(transaction);  // Suggestions for a better method name are welcome.  :)\n\t\t} finally {\n\t\t\tsynchronized (_pendingPublicationsMonitor) {\n\t\t\t\t_pendingPublications--;\n\t\t\t\tif (_pendingPublications == 0) {\n\t\t\t\t\t_pausableClock.resume();\n\t\t\t\t\t_pendingPublicationsMonitor.notifyAll();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void publishWithoutWorryingAboutNewSubscriptions(Transaction transaction) {\n\t\tTurn myTurn = nextTurn();\n\t\tDate executionTime = realTime(myTurn);  //TODO realTime() and approve in the same turn.\n\t\tlong systemVersion = approve(transaction, executionTime, myTurn);\n\t\tTransactionTimestamp timestamp = new TransactionTimestamp(transaction, systemVersion, executionTime);\n\t\tTransactionGuide guide = new TransactionGuide(timestamp, myTurn);\n\n\t\t_journal.append(guide);\n\t\tnotifySubscribers(guide);\n\t}\n\n\n\tprivate Turn nextTurn() {\n\t\tsynchronized (_nextTurnMonitor) {\n\t\t\tTurn result = _nextTurn;\n\t\t\t_nextTurn = _nextTurn.next();\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n\tprivate Date realTime(Turn myTurn) {\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\treturn _pausableClock.realTime();\n\t\t} finally {\tmyTurn.end(); }\n\t}\n\n\n\tprivate long approve(Transaction transaction, Date executionTime, Turn myTurn) throws RuntimeException, Error {\n\t\ttry {\n\t\t\tmyTurn.start();\n\n\t\t\t_censor.approve(transaction, _nextTransaction, executionTime);\n\n\t\t\tlong systemVersion = _nextTransaction++;\n\n\t\t\tmyTurn.end();\n\n\t\t\treturn systemVersion;\n\t\t} catch (RuntimeException r) { myTurn.alwaysSkip(); throw r;\n\t\t} catch (Error e) { myTurn.alwaysSkip(); throw e; }\n\t}\n\n\n\tprivate void notifySubscribers(TransactionGuide guide) {\n\t\ttry {\n\t\t\tguide.startTurn();\n\t\t\t_pausableClock.advanceTo(guide.executionTime());\n\t\t\tnotifySubscribers(guide.timestamp());\n\t\t} finally {\tguide.endTurn(); }\n\t}\n\n\n\tpublic void addSubscriber(TransactionSubscriber subscriber, long initialTransaction) throws IOException, ClassNotFoundException {\n\t\tsynchronized (_pendingPublicationsMonitor) {\n\t\t\twhile (_pendingPublications != 0) Cool.wait(_pendingPublicationsMonitor);\n\t\t\t\n\t\t\t_journal.update(subscriber, initialTransaction);\n\t\t\t_nextTransaction = _journal.nextTransaction();\n\n\t\t\tsuper.addSubscriber(subscriber);\n\t\t}\n\t}\n\n\n\tpublic void close() throws IOException { _journal.close(); }\n\n}\n","lineNo":67}
{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation.publishing;\n\nimport org.prevayler.Clock;\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.Cool;\nimport org.prevayler.foundation.Turn;\nimport org.prevayler.implementation.clock.PausableClock;\nimport org.prevayler.implementation.journal.Journal;\nimport org.prevayler.implementation.publishing.censorship.TransactionCensor;\n\nimport java.io.IOException;\nimport java.util.Date;\n\npublic class CentralPublisher extends AbstractPublisher {\n\n\tprivate final PausableClock _pausableClock;\n\tprivate final TransactionCensor _censor;\n\tprivate final Journal _journal;\n\tprivate long _nextTransaction;\n\n\tprivate volatile int _pendingPublications = 0;\n\tprivate final Object _pendingPublicationsMonitor = new Object();\n\n\tprivate Turn _nextTurn = Turn.first();\n\tprivate final Object _nextTurnMonitor = new Object();\n\n\n\tpublic CentralPublisher(Clock clock, TransactionCensor censor, Journal journal) {\n\t\tsuper(new PausableClock(clock));\n\t\t_pausableClock = (PausableClock)_clock; //This is just to avoid casting the inherited _clock every time.\n\n\t\t_censor = censor;\n\t\t_journal = journal;\n\t}\n\n\n\tpublic void publish(Transaction transaction) {\n\t\tsynchronized (_pendingPublicationsMonitor) {  //Blocks all new subscriptions until the publication is over.\n\t\t\tif (_pendingPublications == 0) _pausableClock.pause();\n\t\t\t_pendingPublications++;\n\t\t}\n\n\t\ttry {\n\t\t\tpublishWithoutWorryingAboutNewSubscriptions(transaction);  // Suggestions for a better method name are welcome.  :)\n\t\t} finally {\n\t\t\tsynchronized (_pendingPublicationsMonitor) {\n\t\t\t\t_pendingPublications--;\n\t\t\t\tif (_pendingPublications == 0) {\n\t\t\t\t\t_pausableClock.resume();\n\t\t\t\t\t_pendingPublicationsMonitor.notifyAll();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void publishWithoutWorryingAboutNewSubscriptions(Transaction transaction) {\n\t\tTurn myTurn = nextTurn();\n\n\t\tDate executionTime = realTime(myTurn);  //TODO realTime() and approve in the same turn.\n\t\tlong systemVersion = approve(transaction, executionTime, myTurn);\n\t\t_journal.append(transaction, executionTime, myTurn);\n\t\tnotifySubscribers(transaction, systemVersion, executionTime, myTurn);\n\t}\n\n\n\tprivate Turn nextTurn() {\n\t\tsynchronized (_nextTurnMonitor) {\n\t\t\tTurn result = _nextTurn;\n\t\t\t_nextTurn = _nextTurn.next();\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n\tprivate Date realTime(Turn myTurn) {\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\treturn _pausableClock.realTime();\n\t\t} finally {\tmyTurn.end(); }\n\t}\n\n\n\tprivate long approve(Transaction transaction, Date executionTime, Turn myTurn) throws RuntimeException, Error {\n\t\ttry {\n\t\t\tmyTurn.start();\n\n\t\t\t_censor.approve(transaction, _nextTransaction, executionTime);\n\n\t\t\tlong systemVersion = _nextTransaction++;\n\n\t\t\tmyTurn.end();\n\n\t\t\treturn systemVersion;\n\t\t} catch (RuntimeException r) { myTurn.alwaysSkip(); throw r;\n\t\t} catch (Error e) { myTurn.alwaysSkip(); throw e; }\n\t}\n\n\n\tprivate void notifySubscribers(Transaction transaction, long systemVersion, Date executionTime, Turn myTurn) {\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\t_pausableClock.advanceTo(executionTime);\n\t\t\tnotifySubscribers(transaction, systemVersion, executionTime);\n\t\t} finally {\tmyTurn.end(); }\n\t}\n\n\n\tpublic void addSubscriber(TransactionSubscriber subscriber, long initialTransaction) throws IOException, ClassNotFoundException {\n\t\tsynchronized (_pendingPublicationsMonitor) {\n\t\t\twhile (_pendingPublications != 0) Cool.wait(_pendingPublicationsMonitor);\n\t\t\t\n\t\t\t_journal.update(subscriber, initialTransaction);\n\t\t\t_nextTransaction = _journal.nextTransaction();\n\n\t\t\tsuper.addSubscriber(subscriber);\n\t\t}\n\t}\n\n\n\tpublic void close() throws IOException { _journal.close(); }\n\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation.publishing;\n\nimport org.prevayler.Clock;\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.Cool;\nimport org.prevayler.foundation.Turn;\nimport org.prevayler.implementation.TransactionGuide;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.implementation.clock.PausableClock;\nimport org.prevayler.implementation.journal.Journal;\nimport org.prevayler.implementation.publishing.censorship.TransactionCensor;\n\nimport java.io.IOException;\nimport java.util.Date;\n\npublic class CentralPublisher extends AbstractPublisher {\n\n\tprivate final PausableClock _pausableClock;\n\tprivate final TransactionCensor _censor;\n\tprivate final Journal _journal;\n\tprivate long _nextTransaction;\n\n\tprivate volatile int _pendingPublications = 0;\n\tprivate final Object _pendingPublicationsMonitor = new Object();\n\n\tprivate Turn _nextTurn = Turn.first();\n\tprivate final Object _nextTurnMonitor = new Object();\n\n\n\tpublic CentralPublisher(Clock clock, TransactionCensor censor, Journal journal) {\n\t\tsuper(new PausableClock(clock));\n\t\t_pausableClock = (PausableClock)_clock; //This is just to avoid casting the inherited _clock every time.\n\n\t\t_censor = censor;\n\t\t_journal = journal;\n\t}\n\n\n\tpublic void publish(Transaction transaction) {\n\t\tsynchronized (_pendingPublicationsMonitor) {  //Blocks all new subscriptions until the publication is over.\n\t\t\tif (_pendingPublications == 0) _pausableClock.pause();\n\t\t\t_pendingPublications++;\n\t\t}\n\n\t\ttry {\n\t\t\tpublishWithoutWorryingAboutNewSubscriptions(transaction);  // Suggestions for a better method name are welcome.  :)\n\t\t} finally {\n\t\t\tsynchronized (_pendingPublicationsMonitor) {\n\t\t\t\t_pendingPublications--;\n\t\t\t\tif (_pendingPublications == 0) {\n\t\t\t\t\t_pausableClock.resume();\n\t\t\t\t\t_pendingPublicationsMonitor.notifyAll();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void publishWithoutWorryingAboutNewSubscriptions(Transaction transaction) {\n\t\tTurn myTurn = nextTurn();\n\t\tDate executionTime = realTime(myTurn);  //TODO realTime() and approve in the same turn.\n\t\tlong systemVersion = approve(transaction, executionTime, myTurn);\n\t\tTransactionTimestamp timestamp = new TransactionTimestamp(transaction, systemVersion, executionTime);\n\t\tTransactionGuide guide = new TransactionGuide(timestamp, myTurn);\n\n\t\t_journal.append(guide);\n\t\tnotifySubscribers(guide);\n\t}\n\n\n\tprivate Turn nextTurn() {\n\t\tsynchronized (_nextTurnMonitor) {\n\t\t\tTurn result = _nextTurn;\n\t\t\t_nextTurn = _nextTurn.next();\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n\tprivate Date realTime(Turn myTurn) {\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\treturn _pausableClock.realTime();\n\t\t} finally {\tmyTurn.end(); }\n\t}\n\n\n\tprivate long approve(Transaction transaction, Date executionTime, Turn myTurn) throws RuntimeException, Error {\n\t\ttry {\n\t\t\tmyTurn.start();\n\n\t\t\t_censor.approve(transaction, _nextTransaction, executionTime);\n\n\t\t\tlong systemVersion = _nextTransaction++;\n\n\t\t\tmyTurn.end();\n\n\t\t\treturn systemVersion;\n\t\t} catch (RuntimeException r) { myTurn.alwaysSkip(); throw r;\n\t\t} catch (Error e) { myTurn.alwaysSkip(); throw e; }\n\t}\n\n\n\tprivate void notifySubscribers(TransactionGuide guide) {\n\t\ttry {\n\t\t\tguide.startTurn();\n\t\t\t_pausableClock.advanceTo(guide.executionTime());\n\t\t\tnotifySubscribers(guide.timestamp());\n\t\t} finally {\tguide.endTurn(); }\n\t}\n\n\n\tpublic void addSubscriber(TransactionSubscriber subscriber, long initialTransaction) throws IOException, ClassNotFoundException {\n\t\tsynchronized (_pendingPublicationsMonitor) {\n\t\t\twhile (_pendingPublications != 0) Cool.wait(_pendingPublicationsMonitor);\n\t\t\t\n\t\t\t_journal.update(subscriber, initialTransaction);\n\t\t\t_nextTransaction = _journal.nextTransaction();\n\n\t\t\tsuper.addSubscriber(subscriber);\n\t\t}\n\t}\n\n\n\tpublic void close() throws IOException { _journal.close(); }\n\n}\n","lineNo":68}
{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Carlos Villela.\n\npackage org.prevayler.foundation;\n\nimport org.prevayler.foundation.monitor.Monitor;\nimport org.prevayler.foundation.serialization.Serializer;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.Transaction;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.ObjectStreamException;\nimport java.io.UTFDataFormatException;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.util.Date;\n\n\npublic class DurableInputStream {\n\n\tprivate final File _file;\n\tprivate final Serializer _serializer;\n\tprivate boolean _EOF = false;\n\tprivate Monitor _monitor;\n\tprivate InputStream _fileStream;\n\n\n\tpublic DurableInputStream(File file, Serializer serializer, Monitor monitor) throws IOException {\n\t\t_monitor = monitor;\n\t\t_file = file;\n\t\t_fileStream = new BufferedInputStream(new FileInputStream(file));\n\t\t_serializer = serializer;\n\t}\n\n\n\tpublic void skip() throws IOException {\n\t\treadChunk();\n\t}\n\n\tpublic TransactionTimestamp read() throws IOException, ClassNotFoundException {\n\t\tChunk chunk = readChunk();\n\t\tTransaction transaction = (Transaction)_serializer.readObject(new ByteArrayInputStream(chunk.getBytes()));\n\t\treturn new TransactionTimestamp(transaction, new Date(Long.parseLong(chunk.getParameter(\"timestamp\"))));\n\t}\n\n\tprivate Chunk readChunk() throws IOException {\n\t\tif (_EOF) throw new EOFException();\n\n\t\ttry {\n\t\t\tChunk chunk = Chunking.readChunk(_fileStream);\n\t\t\tif (chunk != null) return chunk;\n\t\t} catch (EOFException eofx) {\n\t\t\t// Do nothing.\n\t\t} catch (ObjectStreamException scx) {\n\t\t\tignoreStreamCorruption(scx);\n\t\t} catch (UTFDataFormatException utfx) {\n\t\t\tignoreStreamCorruption(utfx);\n\t\t} catch (RuntimeException rx) {   //Some stream corruptions cause runtime exceptions in JDK1.3.1!\n\t\t\tignoreStreamCorruption(rx);\n\t\t}\n\n\t\t_fileStream.close();\n\t\t_EOF = true;\n\t\tthrow new EOFException();\n\t}\n\n\n\tprivate void ignoreStreamCorruption(Exception ex) {\n\t\tString message = \"Stream corruption found while reading a transaction from the journal. If this is a transaction that was being written when a system crash occurred, there is no problem because it was never executed on the Prevalent System. Before executing each transaction, Prevayler writes it to the journal and calls the java.io.FileDescritor.sync() method to instruct the Java API to physically sync all operating system RAM buffers to disk.\";\n\t\t_monitor.notify(this.getClass(), message, _file, ex);\n\t}\n\n\n\tpublic void close() throws IOException {\n\t\t_fileStream.close();\n\t\t_EOF = true;\n\t}\n\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Carlos Villela.\n\npackage org.prevayler.foundation;\n\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.monitor.Monitor;\nimport org.prevayler.foundation.serialization.Serializer;\nimport org.prevayler.implementation.TransactionTimestamp;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectStreamException;\nimport java.io.UTFDataFormatException;\nimport java.util.Date;\n\n\npublic class DurableInputStream {\n\n\tprivate final File _file;\n\tprivate final Serializer _serializer;\n\tprivate boolean _EOF = false;\n\tprivate Monitor _monitor;\n\tprivate InputStream _fileStream;\n\n\n\tpublic DurableInputStream(File file, Serializer serializer, Monitor monitor) throws IOException {\n\t\t_monitor = monitor;\n\t\t_file = file;\n\t\t_fileStream = new BufferedInputStream(new FileInputStream(file));\n\t\t_serializer = serializer;\n\t}\n\n\n\tpublic void skip() throws IOException {\n\t\treadChunk();\n\t}\n\n\tpublic TransactionTimestamp read() throws IOException, ClassNotFoundException {\n\t\tChunk chunk = readChunk();\n\t\tTransaction transaction = (Transaction)_serializer.readObject(new ByteArrayInputStream(chunk.getBytes()));\n\t\tlong systemVersion = Long.parseLong(chunk.getParameter(\"systemVersion\"));\n\t\tlong executionTime = Long.parseLong(chunk.getParameter(\"executionTime\"));\n\t\treturn new TransactionTimestamp(transaction, systemVersion, new Date(executionTime));\n\t}\n\n\tprivate Chunk readChunk() throws IOException {\n\t\tif (_EOF) throw new EOFException();\n\n\t\ttry {\n\t\t\tChunk chunk = Chunking.readChunk(_fileStream);\n\t\t\tif (chunk != null) return chunk;\n\t\t} catch (EOFException eofx) {\n\t\t\t// Do nothing.\n\t\t} catch (ObjectStreamException scx) {\n\t\t\tignoreStreamCorruption(scx);\n\t\t} catch (UTFDataFormatException utfx) {\n\t\t\tignoreStreamCorruption(utfx);\n\t\t} catch (RuntimeException rx) {   //Some stream corruptions cause runtime exceptions in JDK1.3.1!\n\t\t\tignoreStreamCorruption(rx);\n\t\t}\n\n\t\t_fileStream.close();\n\t\t_EOF = true;\n\t\tthrow new EOFException();\n\t}\n\n\n\tprivate void ignoreStreamCorruption(Exception ex) {\n\t\tString message = \"Stream corruption found while reading a transaction from the journal. If this is a transaction that was being written when a system crash occurred, there is no problem because it was never executed on the Prevalent System. Before executing each transaction, Prevayler writes it to the journal and calls the java.io.FileDescritor.sync() method to instruct the Java API to physically sync all operating system RAM buffers to disk.\";\n\t\t_monitor.notify(this.getClass(), message, _file, ex);\n\t}\n\n\n\tpublic void close() throws IOException {\n\t\t_fileStream.close();\n\t\t_EOF = true;\n\t}\n\n}\n","lineNo":50}
{"Smelly Sample":"package org.prevayler.implementation;\n\nimport org.prevayler.Query;\nimport org.prevayler.Transaction;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\nimport org.prevayler.implementation.snapshot.GenericSnapshotManager;\n\nimport java.io.IOException;\nimport java.util.Date;\n\npublic class PrevalentSystemGuard implements TransactionSubscriber {\n\n\tprivate final Object _prevalentSystem;\n\tprivate long _systemVersion;\n\tprivate boolean _ignoreRuntimeExceptions;\n\n\tpublic PrevalentSystemGuard(Object prevalentSystem, long systemVersion) {\n\t\t_prevalentSystem = prevalentSystem;\n\t\t_systemVersion = systemVersion;\n\t}\n\n\tpublic Object prevalentSystem() {\n\t\treturn _prevalentSystem;\n\t}\n\n\tpublic void subscribeTo(TransactionPublisher publisher) throws IOException, ClassNotFoundException {\n\t\t_ignoreRuntimeExceptions = true;     //During pending transaction recovery (rolling forward), RuntimeExceptions are ignored because they were already thrown and handled during the first transaction execution.\n\t\tpublisher.addSubscriber(this, _systemVersion + 1);\n\t\t_ignoreRuntimeExceptions = false;\n\t}\n\n\tpublic void receive(Transaction transaction, Date executionTime) {\n\t\tsynchronized (_prevalentSystem) {\n\t\t\t_systemVersion++;\n\t\t\ttry {\n\t\t\t\ttransaction.executeOn(_prevalentSystem, executionTime);\n\t\t\t} catch (RuntimeException rx) {\n\t\t\t\tif (!_ignoreRuntimeExceptions) throw rx;  //TODO Guarantee that transactions received from pending transaction recovery don't ever throw RuntimeExceptions. Maybe use a wrapper for that.\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Object executeQuery(Query sensitiveQuery, Date executionTime) throws Exception {\n\t\tsynchronized (_prevalentSystem) {\n\t\t\treturn sensitiveQuery.query(_prevalentSystem, executionTime);\n\t\t}\n\t}\n\n\tpublic void takeSnapshot(GenericSnapshotManager snapshotManager) throws IOException {\n\t\tsynchronized (_prevalentSystem) {\n\t\t\tsnapshotManager.writeSnapshot(_prevalentSystem, _systemVersion);\n\t\t}\n\t}\n\n}\n","Method after Refactoring":"package org.prevayler.implementation;\n\nimport org.prevayler.Clock;\nimport org.prevayler.Query;\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.Cool;\nimport org.prevayler.foundation.DeepCopier;\nimport org.prevayler.foundation.serialization.Serializer;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\nimport org.prevayler.implementation.snapshot.GenericSnapshotManager;\n\nimport java.io.IOException;\nimport java.util.Date;\n\npublic class PrevalentSystemGuard implements TransactionSubscriber {\n\n\tprivate final Object _prevalentSystem; // All access is synchronized on itself\n\tprivate long _systemVersion; // All access is synchronized on \"this\"\n\tprivate boolean _ignoreRuntimeExceptions; // All access is synchronized on \"this\"\n\n\tpublic PrevalentSystemGuard(Object prevalentSystem, long systemVersion) {\n\t\t_prevalentSystem = prevalentSystem;\n\t\t_systemVersion = systemVersion;\n\t\t_ignoreRuntimeExceptions = false;\n\t}\n\n\tpublic Object prevalentSystem() {\n\t\treturn _prevalentSystem;\n\t}\n\n\tpublic void subscribeTo(TransactionPublisher publisher) throws IOException, ClassNotFoundException {\n\t\tlong initialTransaction;\n\t\tsynchronized (this) {\n\t\t\t_ignoreRuntimeExceptions = true;     //During pending transaction recovery (rolling forward), RuntimeExceptions are ignored because they were already thrown and handled during the first transaction execution.\n\t\t\tinitialTransaction = _systemVersion + 1;\n\t\t}\n\n\t\tpublisher.addSubscriber(this, initialTransaction);\n\n\t\tsynchronized (this) {\n\t\t\t_ignoreRuntimeExceptions = false;\n\t\t}\n\t}\n\n\tpublic void receive(Transaction transaction, long systemVersion, Date executionTime) {\n\t\tsynchronized (this) {\n\t\t\tif (systemVersion != _systemVersion + 1) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Attempted to apply transaction \" + systemVersion + \" when prevalent system was only at \" + _systemVersion);\n\t\t\t}\n\n\t\t\t_systemVersion = systemVersion;\n\n\t\t\ttry {\n\t\t\t\tsynchronized (_prevalentSystem) {\n\t\t\t\t\ttransaction.executeOn(_prevalentSystem, executionTime);\n\t\t\t\t}\n\t\t\t} catch (RuntimeException rx) {\n\t\t\t\tif (!_ignoreRuntimeExceptions) throw rx;  //TODO Guarantee that transactions received from pending transaction recovery don't ever throw RuntimeExceptions. Maybe use a wrapper for that.\n\t\t\t} finally {\n\t\t\t\tnotifyAll();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Object executeQuery(Query sensitiveQuery, Clock clock) throws Exception {\n\t\tsynchronized (_prevalentSystem) {\n\t\t\treturn sensitiveQuery.query(_prevalentSystem, clock.time());\n\t\t}\n\t}\n\n\tpublic void takeSnapshot(GenericSnapshotManager snapshotManager) throws IOException {\n\t\tsynchronized (this) {\n\t\t\tsynchronized (_prevalentSystem) {\n\t\t\t\tsnapshotManager.writeSnapshot(_prevalentSystem, _systemVersion);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic PrevalentSystemGuard deepCopy(long systemVersion, Serializer snapshotSerializer) throws IOException, ClassNotFoundException {\n\t\tsynchronized (this) {\n\t\t\twhile (_systemVersion < systemVersion) {\n\t\t\t\tCool.wait(this);\n\t\t\t}\n\n\t\t\tif (_systemVersion > systemVersion) {\n\t\t\t\tthrow new IllegalStateException(\"Already at \" + _systemVersion + \"; can't go back to \" + systemVersion);\n\t\t\t}\n\n\t\t\tsynchronized (_prevalentSystem) {\n\t\t\t\treturn new PrevalentSystemGuard(DeepCopier.deepCopy(_prevalentSystem, snapshotSerializer), _systemVersion);\n\t\t\t}\n\t\t}\n\t}\n\n}\n","lineNo":33}
{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Aleksey Aristov, Carlos Villela, Justin Sampson.\n\npackage org.prevayler;\n\nimport org.prevayler.foundation.monitor.Monitor;\nimport org.prevayler.foundation.monitor.SimpleMonitor;\nimport org.prevayler.foundation.serialization.JavaSerializer;\nimport org.prevayler.foundation.serialization.Serializer;\nimport org.prevayler.foundation.serialization.SkaringaSerializer;\nimport org.prevayler.foundation.serialization.XStreamSerializer;\nimport org.prevayler.implementation.PrevaylerImpl;\nimport org.prevayler.implementation.clock.MachineClock;\nimport org.prevayler.implementation.journal.Journal;\nimport org.prevayler.implementation.journal.PersistentJournal;\nimport org.prevayler.implementation.journal.TransientJournal;\nimport org.prevayler.implementation.publishing.CentralPublisher;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.censorship.LiberalTransactionCensor;\nimport org.prevayler.implementation.publishing.censorship.StrictTransactionCensor;\nimport org.prevayler.implementation.publishing.censorship.TransactionCensor;\nimport org.prevayler.implementation.replication.ClientPublisher;\nimport org.prevayler.implementation.replication.ServerListener;\nimport org.prevayler.implementation.snapshot.GenericSnapshotManager;\nimport org.prevayler.implementation.snapshot.NullSnapshotManager;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/** Provides easy access to all Prevayler configurations and implementations available in this distribution.\n * Static methods are also provided as short-cuts for the most common configurations. \n * <br>By default, the Prevayler instances created by this class will write their Transactions to .journal files before executing them. The FileDescriptor.sync() method is called to make sure the Java file write-buffers have been written to the operating system. Many operating systems, including most recent versions of Linux and Windows, allow the hard-drive's write-cache to be disabled. This guarantees no executed Transaction will be lost in the event of a power shortage, for example.\n * <br>Also by default, the Prevayler instances created by this class will filter out all Transactions that would throw a RuntimeException or Error if executed on the Prevalent System. This requires enough RAM to hold another copy of the prevalent system. \n * @see Prevayler \n */\npublic class PrevaylerFactory {\n\n\tprivate Object _prevalentSystem;\n\tprivate Clock _clock;\n\n\tprivate boolean _transactionFiltering = true;\n\n\tprivate boolean _transientMode;\n\tprivate String _prevalenceDirectory;\n\tprivate NullSnapshotManager _nullSnapshotManager;\n\n\tprivate long _journalSizeThreshold;\n\tprivate long _journalAgeThreshold;\n\t\n\tprivate int _serverPort = -1;\n\tprivate String _remoteServerIpAddress;\n\tprivate int _remoteServerPort;\n    private Monitor _monitor;\n\tprivate ClassLoader _classLoader;\n\n\tprivate Serializer _journalSerializer;\n\tprivate Map _snapshotSerializers = new HashMap();\n\tprivate String _primarySnapshotSuffix;\n\n\tpublic static final int DEFAULT_REPLICATION_PORT = 8756;\n\n\n\t/** Creates a Prevayler that will use a directory called \"PrevalenceBase\" under the current directory to read and write its .snapshot and .journal files.\n \t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t */\n\tpublic static Prevayler createPrevayler(Serializable newPrevalentSystem) throws IOException, ClassNotFoundException {\n\t\treturn createPrevayler(newPrevalentSystem, \"PrevalenceBase\");\n\t}\n\n\n\t/** Creates a Prevayler that will use the given prevalenceBase directory to read and write its .snapshot and .journal files.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t * @param prevalenceBase The directory where the .snapshot files and .journal files will be read and written.\n\t */\n\tpublic static Prevayler createPrevayler(Serializable newPrevalentSystem, String prevalenceBase) throws IOException, ClassNotFoundException {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configurePrevalenceDirectory(prevalenceBase);\n\t\treturn factory.create();\n\t}\n\n\n\t/** Creates a Prevayler that will execute Transactions WITHOUT writing them to disk. This is useful for running automated tests or demos MUCH faster than with a regular Prevayler.\n\t * \n\t * Attempts to take snapshots on this transient Prevayler will throw an IOException.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system.\n\t * @see #createCheckpointPrevayler(Serializable newPrevalentSystem, String snapshotDirectory)\n\t */\n\tpublic static Prevayler createTransientPrevayler(Serializable newPrevalentSystem) {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configureNullSnapshotManager(new NullSnapshotManager(newPrevalentSystem, \"Transient Prevaylers are unable to take snapshots.\"));\n\t\tfactory.configureTransientMode(true);\n\t\ttry {\n\t\t\treturn factory.create();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(); //Transient Prevayler creation should not fail.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/** @deprecated Use createCheckpointPrevayler() instead of this method. Deprecated since Prevayler2.00.001.\n\t */\n\tpublic static Prevayler createTransientPrevayler(Serializable newPrevalentSystem, String snapshotDirectory) {\n\t\treturn createCheckpointPrevayler(newPrevalentSystem, snapshotDirectory);\n\t}\n\n\t/** Creates a Prevayler that will execute Transactions WITHOUT writing them to disk. Snapshots will work as \"checkpoints\" for the system, therefore. This is useful for stand-alone applications that have a \"Save\" button, for example.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t * @param snapshotDirectory The directory where the .snapshot files will be read and written.\n\t */\n\tpublic static Prevayler createCheckpointPrevayler(Serializable newPrevalentSystem, String snapshotDirectory) {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configurePrevalenceDirectory(snapshotDirectory);\n\t\tfactory.configureTransientMode(true);\n\t\ttry {\n\t\t\treturn factory.create();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(); //Transient Prevayler creation should not fail.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate Clock clock() {\n\t\treturn _clock != null ? _clock : new MachineClock();\n\t}\n\n\t/**\n\t * Assigns a monitor object to receive notifications from Prevayler. This is useful for logging or sending eMails to system administrators, for example. If this method is not called or if null is passed as a parameter, a SimpleMonitor will be used to log notification on System.err.\n\t * \n\t * @param monitor the Monitor implementation to use.\n\t * @see org.prevayler.foundation.monitor.SimpleMonitor\n\t */\n\tpublic void configureMonitor(Monitor monitor) {\n\t    _monitor = monitor;\n\t}\n\n\t/** Determines whether the Prevayler created by this factory should be transient (transientMode = true) or persistent (transientMode = false). Default is persistent. A transient Prevayler will execute its Transactions WITHOUT writing them to disk. This is useful for stand-alone applications which have a \"Save\" button, for example, or for running automated tests MUCH faster than with a persistent Prevayler.\n\t */\n\tpublic void configureTransientMode(boolean transientMode) {\n\t\t_transientMode = transientMode;\t\t\n\t}\n\n\n\t/** Configures the Clock that will be used by the created Prevayler. The Clock interface can be implemented by the application if it requires Prevayler to use a special time source other than the machine clock (default).\n\t */\n\tpublic void configureClock(Clock clock) {\n\t\t_clock = clock;\n\t}\n\n\n\t/** Configures the directory where the created Prevayler will read and write its .journal and .snapshot files. The default is a directory called \"PrevalenceBase\" under the current directory.\n\t * @param prevalenceDirectory Will be ignored for the .snapshot files if a SnapshotManager is configured.\n\t */\n\tpublic void configurePrevalenceDirectory(String prevalenceDirectory) {\n\t\t_prevalenceDirectory = prevalenceDirectory;\n\t}\n\n\n\t/** Configures the prevalent system that will be used by the Prevayler created by this factory.\n\t * @param newPrevalentSystem If the default Serializer is used, this prevalentSystem must be Serializable. If another Serializer is used, this prevalentSystem must be compatible with it.\n     * @see #configureSnapshotSerializer(String,Serializer)\n\t */\n\tpublic void configurePrevalentSystem(Object newPrevalentSystem) {\n\t\t_prevalentSystem = newPrevalentSystem;\n\t}\n\n\n\t/** Reserved for future implementation.\n\t */\n\tpublic void configureReplicationClient(String remoteServerIpAddress, int remoteServerPort) {\n\t\t_remoteServerIpAddress = remoteServerIpAddress;\n\t\t_remoteServerPort = remoteServerPort;\n\t}\n\n\n\t/** Reserved for future implementation.\n\t */\n\tpublic void configureReplicationServer(int port) {\n\t\t_serverPort = port;\n\t}\n\n\n\tprivate void configureNullSnapshotManager(NullSnapshotManager snapshotManager) {\n\t\t_nullSnapshotManager = snapshotManager;\n\t}\n\n\n\t/** Determines whether the Prevayler created by this factory should filter out all Transactions that would throw a RuntimeException or Error if executed on the Prevalent System (default is true). This requires enough RAM to hold another copy of the prevalent system.\n\t */\n\tpublic void configureTransactionFiltering(boolean transactionFiltering) {\n\t\t_transactionFiltering = transactionFiltering;\n\t}\n\n\n\t/**\n\t * Configures the size (in bytes) of the journal file. When the current journal exceeds this size, a new journal is created.\n\t */\n\tpublic void configureJournalFileSizeThreshold(long sizeInBytes) {\n\t\t_journalSizeThreshold = sizeInBytes;\n\t}\n\n\n\t/**\n\t * Sets the age (in milliseconds) of the journal file. When the current journal expires, a new journal is created.\n\t */\n\tpublic void configureJournalFileAgeThreshold(long ageInMilliseconds) {\n\t\t_journalAgeThreshold = ageInMilliseconds;\n\t}\n\n\n\t/**\n\t * @deprecated Use {@link #configureSnapshotSerializer(String,Serializer)} and {@link #configureJournalSerializer(Serializer)} instead, giving a {@link JavaSerializer} with the desired classloader.\n\t */\n\tpublic void configureClassLoader(ClassLoader classLoader) {\n\t\t_classLoader = classLoader;\n\t}\n\n\n\tpublic void configureJournalSerializer(Serializer serializer) {\n\t\t_journalSerializer = serializer;\n\t}\n\n\t\n\tpublic void configureSnapshotSerializer(JavaSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"snapshot\", serializer);\n\t}\n\n\tpublic void configureSnapshotSerializer(XStreamSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"xstreamsnapshot\", serializer);\n\t}\n\n\tpublic void configureSnapshotSerializer(SkaringaSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"skaringasnapshot\", serializer);\n\t}\n\n\t/**\n\t * Configure a serialization strategy for snapshots. This may be called any number of times with\n\t * different suffixes to configure different strategies for reading existing snapshots. The first\n\t * call to this method establishes the <i>primary<\/i> strategy, which will be used for writing\n\t * snapshots as well as for deep-copying the prevalent system whenever necessary.\n\t */\n\tpublic void configureSnapshotSerializer(String suffix, Serializer serializer) {\n\t\t_snapshotSerializers.put(suffix, serializer);\n\t\tif (_primarySnapshotSuffix == null) {\n\t\t\t_primarySnapshotSuffix = suffix;\n\t\t}\n\t}\n\n\n\t/** Returns a Prevayler created according to what was defined by calls to the configuration methods above.\n\t * @throws IOException If there is trouble creating the Prevalence Base directory or reading a .journal or .snapshot file.\n\t * @throws ClassNotFoundException If a class of a serialized Object is not found when reading a .journal or .snapshot file.\n\t */\n\tpublic Prevayler create() throws IOException, ClassNotFoundException {\n\t\tGenericSnapshotManager snapshotManager = snapshotManager();\n\t\tTransactionPublisher publisher = publisher(snapshotManager);\n\t\tif (_serverPort != -1) new ServerListener(publisher, _serverPort);\n\t\treturn new PrevaylerImpl(snapshotManager, publisher, monitor(), journalSerializer());\n\t}\n\n\n    private String prevalenceDirectory() {\n\t\treturn _prevalenceDirectory != null ? _prevalenceDirectory : \"Prevalence\";\n\t}\n\n\n\tprivate Object prevalentSystem() {\n\t\tif (_prevalentSystem == null) throw new IllegalStateException(\"The prevalent system must be configured.\");\n\t\treturn _prevalentSystem;\n\t}\n\n\n\tprivate TransactionPublisher publisher(GenericSnapshotManager snapshotManager) throws IOException {\n\t\tif (_remoteServerIpAddress != null) return new ClientPublisher(_remoteServerIpAddress, _remoteServerPort);\n\t\treturn new CentralPublisher(clock(), censor(snapshotManager), journal()); \n\t}\n\n\n\tprivate TransactionCensor censor(GenericSnapshotManager snapshotManager) {\n\t\treturn _transactionFiltering\n\t\t\t? (TransactionCensor) new StrictTransactionCensor(snapshotManager, journalSerializer())\n\t\t\t: new LiberalTransactionCensor(); \n\t}\n\n\n\tprivate Journal journal() throws IOException {\n\t\treturn _transientMode\n\t\t\t? (Journal)new TransientJournal()\n\t\t\t: new PersistentJournal(prevalenceDirectory(), _journalSizeThreshold, _journalAgeThreshold, journalSerializer(), monitor());\n\t}\n\n\t\n\tprivate Serializer journalSerializer() {\n\t\tif (_journalSerializer != null) return _journalSerializer;\n\t\treturn new JavaSerializer(_classLoader);\n\t}\n\n\n\tprivate GenericSnapshotManager snapshotManager() throws ClassNotFoundException, IOException {\n\t\tif (_nullSnapshotManager != null) return _nullSnapshotManager;\n\t\tif (!_snapshotSerializers.isEmpty()) return new GenericSnapshotManager(_snapshotSerializers, _primarySnapshotSuffix, prevalentSystem(), prevalenceDirectory());\n\t\treturn new GenericSnapshotManager(new JavaSerializer(_classLoader), prevalentSystem(), prevalenceDirectory());\n\t}\n\n\t\n\tprivate Monitor monitor() {\n\t\treturn _monitor != null ? _monitor : new SimpleMonitor(System.err);\n    }\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Aleksey Aristov, Carlos Villela, Justin Sampson.\n\npackage org.prevayler;\n\nimport org.prevayler.foundation.monitor.Monitor;\nimport org.prevayler.foundation.monitor.SimpleMonitor;\nimport org.prevayler.foundation.serialization.JavaSerializer;\nimport org.prevayler.foundation.serialization.Serializer;\nimport org.prevayler.foundation.serialization.SkaringaSerializer;\nimport org.prevayler.foundation.serialization.XStreamSerializer;\nimport org.prevayler.foundation.FileManager;\nimport org.prevayler.implementation.PrevaylerImpl;\nimport org.prevayler.implementation.clock.MachineClock;\nimport org.prevayler.implementation.journal.Journal;\nimport org.prevayler.implementation.journal.PersistentJournal;\nimport org.prevayler.implementation.journal.TransientJournal;\nimport org.prevayler.implementation.publishing.CentralPublisher;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.censorship.LiberalTransactionCensor;\nimport org.prevayler.implementation.publishing.censorship.StrictTransactionCensor;\nimport org.prevayler.implementation.publishing.censorship.TransactionCensor;\nimport org.prevayler.implementation.replication.ClientPublisher;\nimport org.prevayler.implementation.replication.ServerListener;\nimport org.prevayler.implementation.snapshot.GenericSnapshotManager;\nimport org.prevayler.implementation.snapshot.NullSnapshotManager;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/** Provides easy access to all Prevayler configurations and implementations available in this distribution.\n * Static methods are also provided as short-cuts for the most common configurations. \n * <br>By default, the Prevayler instances created by this class will write their Transactions to .journal files before executing them. The FileDescriptor.sync() method is called to make sure the Java file write-buffers have been written to the operating system. Many operating systems, including most recent versions of Linux and Windows, allow the hard-drive's write-cache to be disabled. This guarantees no executed Transaction will be lost in the event of a power shortage, for example.\n * <br>Also by default, the Prevayler instances created by this class will filter out all Transactions that would throw a RuntimeException or Error if executed on the Prevalent System. This requires enough RAM to hold another copy of the prevalent system. \n * @see Prevayler \n */\npublic class PrevaylerFactory {\n\n\tprivate Object _prevalentSystem;\n\tprivate Clock _clock;\n\n\tprivate boolean _transactionFiltering = true;\n\n\tprivate boolean _transientMode;\n\tprivate String _prevalenceDirectory;\n\tprivate NullSnapshotManager _nullSnapshotManager;\n\n\tprivate long _journalSizeThreshold;\n\tprivate long _journalAgeThreshold;\n\t\n\tprivate int _serverPort = -1;\n\tprivate String _remoteServerIpAddress;\n\tprivate int _remoteServerPort;\n    private Monitor _monitor;\n\tprivate ClassLoader _classLoader;\n\n\tprivate Serializer _journalSerializer;\n\tprivate Map _snapshotSerializers = new HashMap();\n\tprivate String _primarySnapshotSuffix;\n\n\tpublic static final int DEFAULT_REPLICATION_PORT = 8756;\n\n\n\t/** Creates a Prevayler that will use a directory called \"PrevalenceBase\" under the current directory to read and write its .snapshot and .journal files.\n \t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t */\n\tpublic static Prevayler createPrevayler(Serializable newPrevalentSystem) throws IOException, ClassNotFoundException {\n\t\treturn createPrevayler(newPrevalentSystem, \"PrevalenceBase\");\n\t}\n\n\n\t/** Creates a Prevayler that will use the given prevalenceBase directory to read and write its .snapshot and .journal files.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t * @param prevalenceBase The directory where the .snapshot files and .journal files will be read and written.\n\t */\n\tpublic static Prevayler createPrevayler(Serializable newPrevalentSystem, String prevalenceBase) throws IOException, ClassNotFoundException {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configurePrevalenceDirectory(prevalenceBase);\n\t\treturn factory.create();\n\t}\n\n\n\t/** Creates a Prevayler that will execute Transactions WITHOUT writing them to disk. This is useful for running automated tests or demos MUCH faster than with a regular Prevayler.\n\t * \n\t * Attempts to take snapshots on this transient Prevayler will throw an IOException.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system.\n\t * @see #createCheckpointPrevayler(Serializable newPrevalentSystem, String snapshotDirectory)\n\t */\n\tpublic static Prevayler createTransientPrevayler(Serializable newPrevalentSystem) {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configureNullSnapshotManager(new NullSnapshotManager(newPrevalentSystem, \"Transient Prevaylers are unable to take snapshots.\"));\n\t\tfactory.configureTransientMode(true);\n\t\ttry {\n\t\t\treturn factory.create();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(); //Transient Prevayler creation should not fail.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/** @deprecated Use createCheckpointPrevayler() instead of this method. Deprecated since Prevayler2.00.001.\n\t */\n\tpublic static Prevayler createTransientPrevayler(Serializable newPrevalentSystem, String snapshotDirectory) {\n\t\treturn createCheckpointPrevayler(newPrevalentSystem, snapshotDirectory);\n\t}\n\n\t/** Creates a Prevayler that will execute Transactions WITHOUT writing them to disk. Snapshots will work as \"checkpoints\" for the system, therefore. This is useful for stand-alone applications that have a \"Save\" button, for example.\n\t * @param newPrevalentSystem The newly started, \"empty\" prevalent system that will be used as a starting point for every system startup, until the first snapshot is taken.\n\t * @param snapshotDirectory The directory where the .snapshot files will be read and written.\n\t */\n\tpublic static Prevayler createCheckpointPrevayler(Serializable newPrevalentSystem, String snapshotDirectory) {\n\t\tPrevaylerFactory factory = new PrevaylerFactory();\n\t\tfactory.configurePrevalentSystem(newPrevalentSystem);\n\t\tfactory.configurePrevalenceDirectory(snapshotDirectory);\n\t\tfactory.configureTransientMode(true);\n\t\ttry {\n\t\t\treturn factory.create();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(); //Transient Prevayler creation should not fail.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate Clock clock() {\n\t\treturn _clock != null ? _clock : new MachineClock();\n\t}\n\n\t/**\n\t * Assigns a monitor object to receive notifications from Prevayler. This is useful for logging or sending eMails to system administrators, for example. If this method is not called or if null is passed as a parameter, a SimpleMonitor will be used to log notification on System.err.\n\t * \n\t * @param monitor the Monitor implementation to use.\n\t * @see org.prevayler.foundation.monitor.SimpleMonitor\n\t */\n\tpublic void configureMonitor(Monitor monitor) {\n\t    _monitor = monitor;\n\t}\n\n\t/** Determines whether the Prevayler created by this factory should be transient (transientMode = true) or persistent (transientMode = false). Default is persistent. A transient Prevayler will execute its Transactions WITHOUT writing them to disk. This is useful for stand-alone applications which have a \"Save\" button, for example, or for running automated tests MUCH faster than with a persistent Prevayler.\n\t */\n\tpublic void configureTransientMode(boolean transientMode) {\n\t\t_transientMode = transientMode;\t\t\n\t}\n\n\n\t/** Configures the Clock that will be used by the created Prevayler. The Clock interface can be implemented by the application if it requires Prevayler to use a special time source other than the machine clock (default).\n\t */\n\tpublic void configureClock(Clock clock) {\n\t\t_clock = clock;\n\t}\n\n\n\t/** Configures the directory where the created Prevayler will read and write its .journal and .snapshot files. The default is a directory called \"PrevalenceBase\" under the current directory.\n\t * @param prevalenceDirectory Will be ignored for the .snapshot files if a SnapshotManager is configured.\n\t */\n\tpublic void configurePrevalenceDirectory(String prevalenceDirectory) {\n\t\t_prevalenceDirectory = prevalenceDirectory;\n\t}\n\n\n\t/** Configures the prevalent system that will be used by the Prevayler created by this factory.\n\t * @param newPrevalentSystem If the default Serializer is used, this prevalentSystem must be Serializable. If another Serializer is used, this prevalentSystem must be compatible with it.\n     * @see #configureSnapshotSerializer(String,Serializer)\n\t */\n\tpublic void configurePrevalentSystem(Object newPrevalentSystem) {\n\t\t_prevalentSystem = newPrevalentSystem;\n\t}\n\n\n\t/** Reserved for future implementation.\n\t */\n\tpublic void configureReplicationClient(String remoteServerIpAddress, int remoteServerPort) {\n\t\t_remoteServerIpAddress = remoteServerIpAddress;\n\t\t_remoteServerPort = remoteServerPort;\n\t}\n\n\n\t/** Reserved for future implementation.\n\t */\n\tpublic void configureReplicationServer(int port) {\n\t\t_serverPort = port;\n\t}\n\n\n\tprivate void configureNullSnapshotManager(NullSnapshotManager snapshotManager) {\n\t\t_nullSnapshotManager = snapshotManager;\n\t}\n\n\n\t/** Determines whether the Prevayler created by this factory should filter out all Transactions that would throw a RuntimeException or Error if executed on the Prevalent System (default is true). This requires enough RAM to hold another copy of the prevalent system.\n\t */\n\tpublic void configureTransactionFiltering(boolean transactionFiltering) {\n\t\t_transactionFiltering = transactionFiltering;\n\t}\n\n\n\t/**\n\t * Configures the size (in bytes) of the journal file. When the current journal exceeds this size, a new journal is created.\n\t */\n\tpublic void configureJournalFileSizeThreshold(long sizeInBytes) {\n\t\t_journalSizeThreshold = sizeInBytes;\n\t}\n\n\n\t/**\n\t * Sets the age (in milliseconds) of the journal file. When the current journal expires, a new journal is created.\n\t */\n\tpublic void configureJournalFileAgeThreshold(long ageInMilliseconds) {\n\t\t_journalAgeThreshold = ageInMilliseconds;\n\t}\n\n\n\t/**\n\t * @deprecated Use {@link #configureSnapshotSerializer(String,Serializer)} and {@link #configureJournalSerializer(Serializer)} instead, giving a {@link JavaSerializer} with the desired classloader.\n\t */\n\tpublic void configureClassLoader(ClassLoader classLoader) {\n\t\t_classLoader = classLoader;\n\t}\n\n\n\tpublic void configureJournalSerializer(Serializer serializer) {\n\t\t_journalSerializer = serializer;\n\t}\n\n\t\n\tpublic void configureSnapshotSerializer(JavaSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"snapshot\", serializer);\n\t}\n\n\tpublic void configureSnapshotSerializer(XStreamSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"xstreamsnapshot\", serializer);\n\t}\n\n\tpublic void configureSnapshotSerializer(SkaringaSerializer serializer) {\n\t\tconfigureSnapshotSerializer(\"skaringasnapshot\", serializer);\n\t}\n\n\t/**\n\t * Configure a serialization strategy for snapshots. This may be called any number of times with\n\t * different suffixes to configure different strategies for reading existing snapshots. The first\n\t * call to this method establishes the <i>primary<\/i> strategy, which will be used for writing\n\t * snapshots as well as for deep-copying the prevalent system whenever necessary.\n\t */\n\tpublic void configureSnapshotSerializer(String suffix, Serializer serializer) {\n\t\t_snapshotSerializers.put(suffix, serializer);\n\t\tif (_primarySnapshotSuffix == null) {\n\t\t\t_primarySnapshotSuffix = suffix;\n\t\t}\n\t}\n\n\n\t/** Returns a Prevayler created according to what was defined by calls to the configuration methods above.\n\t * @throws IOException If there is trouble creating the Prevalence Base directory or reading a .journal or .snapshot file.\n\t * @throws ClassNotFoundException If a class of a serialized Object is not found when reading a .journal or .snapshot file.\n\t */\n\tpublic Prevayler create() throws IOException, ClassNotFoundException {\n\t\tGenericSnapshotManager snapshotManager = snapshotManager();\n\t\tTransactionPublisher publisher = publisher(snapshotManager);\n\t\tif (_serverPort != -1) new ServerListener(publisher, _serverPort);\n\t\treturn new PrevaylerImpl(snapshotManager, publisher, monitor(), journalSerializer());\n\t}\n\n\n    private String prevalenceDirectory() {\n\t\treturn _prevalenceDirectory != null ? _prevalenceDirectory : \"Prevalence\";\n\t}\n\n\n\tprivate Object prevalentSystem() {\n\t\tif (_prevalentSystem == null) throw new IllegalStateException(\"The prevalent system must be configured.\");\n\t\treturn _prevalentSystem;\n\t}\n\n\n\tprivate TransactionPublisher publisher(GenericSnapshotManager snapshotManager) throws IOException {\n\t\tif (_remoteServerIpAddress != null) return new ClientPublisher(_remoteServerIpAddress, _remoteServerPort);\n\t\treturn new CentralPublisher(clock(), censor(snapshotManager), journal()); \n\t}\n\n\n\tprivate TransactionCensor censor(GenericSnapshotManager snapshotManager) {\n\t\treturn _transactionFiltering\n\t\t\t? (TransactionCensor) new StrictTransactionCensor(snapshotManager, journalSerializer())\n\t\t\t: new LiberalTransactionCensor(); \n\t}\n\n\n\tprivate Journal journal() throws IOException {\n\t\tif (_transientMode) {\n\t\t\treturn (Journal) new TransientJournal();\n\t\t} else {\n\t\t\tFileManager fileManager = new FileManager(prevalenceDirectory());\n\t\t\treturn new PersistentJournal(fileManager, _journalSizeThreshold, _journalAgeThreshold, journalSerializer(), monitor());\n\t\t}\n\t}\n\n\t\n\tprivate Serializer journalSerializer() {\n\t\tif (_journalSerializer != null) return _journalSerializer;\n\t\treturn new JavaSerializer(_classLoader);\n\t}\n\n\n\tprivate GenericSnapshotManager snapshotManager() throws ClassNotFoundException, IOException {\n\t\tif (_nullSnapshotManager != null) {\n\t\t\treturn _nullSnapshotManager;\n\t\t} else {\n\t\t\tFileManager fileManager = new FileManager(prevalenceDirectory());\n\t\t\tif (!_snapshotSerializers.isEmpty()) {\n\t\t\t\treturn new GenericSnapshotManager(_snapshotSerializers, _primarySnapshotSuffix, prevalentSystem(), fileManager);\n\t\t\t} else {\n\t\t\t\treturn new GenericSnapshotManager(new JavaSerializer(_classLoader), prevalentSystem(), fileManager);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tprivate Monitor monitor() {\n\t\treturn _monitor != null ? _monitor : new SimpleMonitor(System.err);\n    }\n}\n","lineNo":315}
{"Smelly Sample":"package org.prevayler.demos.scalability;\n\nimport org.prevayler.demos.scalability.prevayler.*;\nimport org.prevayler.demos.scalability.jdbc.*;\nimport org.prevayler.foundation.serialization.JavaSerializer;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic private final Properties properties = new Properties();\n\n\n\tstatic public void main(String[] args) {\n\n\t\tout(\"\\n=============================================================\");\n\t\tout(  \"             Prevayler vs JDBC Scalability Tests             \");\n\t\tout(  \"=============================================================\\n\");\n\t\tout(\"If you have any trouble running the tests, just write to\");\n\t\tout(\"prevayler-scalability@lists.sourceforge.net and we will be glad to help.\\n\");\n\n\t\ttry {\n\t\t\tout(\"Reading the properties file:\\n\" + propertiesFile().getAbsolutePath());\n\t\t\tout(\"You can edit this file to configure the tests for the next run.\\n\");\n\n\t\t\tproperties.load(new FileInputStream(propertiesFile()));\n\n\t\t\tif (isPrevaylerQueryChosen()) runPrevaylerQuery();\n\t\t\tif (isPrevaylerTransactionChosen()) runPrevaylerTransaction();\n\t\t\tif (isJdbcQueryChosen()) runJdbcQuery();\n\t\t\tif (isJdbcTransactionChosen()) runJdbcTransaction();\n\n\t\t\tout(\"\\n\\n\\nFor better results, edit the properties file:\");\n\t\t\tout(propertiesFile().getAbsolutePath());\n\t\t\tout(\"\\nYou can publish your best results by mail to:\");\n\t\t\tout(\"prevayler-scalability@lists.sourceforge.net. Please include info about your\");\n\t\t\tout(\"processors (quantity, type, speed), compiler, VM, operating system and DBMS.\");\n\t\t\tout(\"\");\n\t\t\tout(\"Scalability test results are published on www.prevayler.org.\");\n\t\t\tout(\"See you there.\\n\");\n\t\t\tout(\"Klaus Wuestefeld and Daniel Santos.\\n\\n\");\n\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t} catch (OutOfMemoryError err) {\n\t\t\tScalabilityTestRun.outOfMemory();\n\t\t}\n\n\t}\n\n\n\tstatic private void runPrevaylerQuery() throws Exception {\n\t\tnew QueryTestRun(\n\t\t\tnew PrevaylerQuerySubject(),\n\t\t\tnumberOfObjects(),\n\t\t\tprevaylerQueryThreadsMin(),\n\t\t\tprevaylerQueryThreadsMax()\n\t\t);\n\t}\n\n\tstatic private void runPrevaylerTransaction() throws Exception {\n\t\tnew TransactionTestRun(\n\t\t\tnew PrevaylerTransactionSubject(prevaylerTransactionLogDirectory(), prevaylerJournalSerializer()),\n\t\t\tnumberOfObjects(),\n\t\t\tprevaylerTransactionThreadsMin(),\n\t\t\tprevaylerTransactionThreadsMax()\n\t\t);\n\t}\n\n\tstatic private void runJdbcQuery() {\n\t\tnew QueryTestRun(\n\t\t\tnew JDBCQuerySubject(jdbcDriverClassName(), jdbcConnectionURL(), jdbcUser(), jdbcPassword()),\n\t\t\tnumberOfObjects(),\n\t\t\tjdbcQueryThreadsMin(),\n\t\t\tjdbcQueryThreadsMax()\n\t\t);\n\t}\n\n\tstatic private void runJdbcTransaction() {\n\t\tnew TransactionTestRun(\n\t\t\tnew JDBCTransactionSubject(jdbcDriverClassName(), jdbcConnectionURL(), jdbcUser(), jdbcPassword()),\n\t\t\tnumberOfObjects(),\n\t\t\tjdbcTransactionThreadsMin(),\n\t\t\tjdbcTransactionThreadsMax()\n\t\t);\n\t}\n\n\n\tstatic private File propertiesFile() throws IOException {\n\t\tFile result = new File(\"ScalabilityTest.properties\");\n\t\tif (!result.exists()) {\n\t\t\tout(\"Creating the properties file.\");\n\t\t\tcreatePropertiesFile(result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic private void createPropertiesFile(File file) throws IOException {\n\t\tPrintStream stream = new PrintStream(new FileOutputStream(file));\n\t\tstream.println(\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"#                                                         #\\n\" +\n\t\t\t\"#      PREVAYLER VS JDBC SCALABILITY TEST PROPERTIES      #\\n\" +\n\t\t\t\"#                                                         #\\n\" +\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"NumberOfObjects = ONE_HUNDRED_THOUSAND\\n\" +\n\t\t\t\"# NumberOfObjects = ONE_MILLION\\n\" +\n\t\t\t\"# NumberOfObjects = TEN_MILLION\\n\" +\n\t\t\t\"# NumberOfObjects = TWENTY_MILLION\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# The results are only valid if both Prevayler and the\\n\" +\n\t\t\t\"# database can run the tests without paging memory to disk.\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# Running the tests with one hundred thousand objects\\n\" +\n\t\t\t\"# (default option) requires approx. 128MB free RAM.\\n\" +\n\t\t\t\"# The VM must be started with a sufficient maximum heap\\n\" +\n\t\t\t\"# size or you will get an OutOfMemoryError.\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# Example for Linux and Windows:  java -Xmx128000000 ...\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# (This can be set with the scalability.jvmarg property\\n\" +\n\t\t\t\"# in build.properties; see sample.build.properties for\\n\" +\n\t\t\t\"# examples.)\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# Running the tests with one million objects requires\\n\" +\n\t\t\t\"# approx. 940MB free RAM.\\n\" +\n\t\t\t\"# Running the tests with ten million objects requires\\n\" +\n\t\t\t\"# approx. 9.4GB free RAM and a 64bit VM.\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# IMPORTANT: Remember to shutdown all other non-vital\\n\" +\n\t\t\t\"# processes before running the tests. Even the database\\n\" +\n\t\t\t\"# process should be down while running the Prevayler tests\\n\" +\n\t\t\t\"# that do not use it.\\n\" +\n\t\t\t\"\\n\" +\t\n\t\t\t\"\\n\" +\t\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"# PREVAYLER QUERY TEST\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"RunPrevaylerQueryTest = YES\\n\" +\n\t\t\t\"# RunPrevaylerQueryTest = NO\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"PrevaylerQueryThreadsMinimum = 1\\n\" +\n\t\t\t\"PrevaylerQueryThreadsMaximum = 5\\n\" +\n\t\t\t\"# More threads can produce better results on\\n\" +\n\t\t\t\"# multi-processor machines.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"# PREVAYLER TRANSACTION TEST\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"RunPrevaylerTransactionTest = YES\\n\" +\n\t\t\t\"# RunPrevaylerTransactionTest = NO\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"PrevaylerTransactionThreadsMinimum = 1\\n\" +\n\t\t\t\"PrevaylerTransactionThreadsMaximum = 5\\n\" +\n\t\t\t\"# More threads can produce better results on machines with\\n\" +\n\t\t\t\"# multiple disks.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"TransactionLogDirectory = TransactionTest\\n\" +\n\t\t\t\"PrevaylerJournalSerializer = \" + JavaSerializer.class.getName() + \"\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# The full path name can be used. Example for Windows:\\n\" +\n\t\t\t\"# TransactionLogDirectory1 = c:\\\\\\\\temp\\\\\\\\TransactionTest\\n\" +\n\t\t\t\"# The back-slash (\\\\) is the escape character so you must\\n\" +\n\t\t\t\"# use two back-slashes (\\\\\\\\).\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"# JDBC QUERY TEST\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"RunJdbcQueryTest = NO\\n\" +\n\t\t\t\"# RunJdbcQueryTest = YES\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"JdbcQueryThreadsMinimum = 1\\n\" +\n\t\t\t\"JdbcQueryThreadsMaximum = 5\\n\" +\n\t\t\t\"# More threads can produce better results on some machines.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"# JDBC TRANSACTION TEST\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"RunJdbcTransactionTest = NO\\n\" +\n\t\t\t\"# RunJdbcTransactionTest = YES\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"JdbcTransactionThreadsMinimum = 1\\n\" +\n\t\t\t\"JdbcTransactionThreadsMaximum = 5\\n\" +\n\t\t\t\"# More threads can produce better results on some machines.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"# JDBC CONNECTION\\n\" +\n\t\t\t\"# (necessary to run the JDBC tests)\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"JdbcDriverClassName =\\n\" +\n\t\t\t\"JdbcConnectionURL =\\n\" +\n\t\t\t\"JdbcUser =\\n\" +\n\t\t\t\"JdbcPassword =\\n\" +\n\t\t\t\"# These two tables are necessary for the JDBC tests:\\n\" +\n\t\t\t\"# QUERY_TEST and TRANSACTION_TEST.\\n\" +\n\t\t\t\"# Both tables have the same column structure:\\n\" +\n\t\t\t\"#    ID DECIMAL,\\n\" +\n\t\t\t\"#    NAME VARCHAR2(8),\\n\" +\n\t\t\t\"#    STRING1 VARCHAR2(1000),\\n\" +\n\t\t\t\"#    BIGDECIMAL1 DECIMAL,\\n\" +\n\t\t\t\"#    BIGDECIMAL2 DECIMAL,\\n\" +\n\t\t\t\"#    DATE1 DATE,\\n\" +\n\t\t\t\"#    DATE2 DATE.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"# IMPORTANT: For best results, create indices on the\\n\" +\n\t\t\t\"# QUERY_TEST.NAME and TRANSACTION_TEST.ID columns.\\n\" +\n\t\t\t\"# Do not create indices on any other column.\\n\"\n\t\t);\n\t}\n\n\n\tstatic private int numberOfObjects() {\n\t\tString property = property(\"NumberOfObjects\");\n\t\tif (\"ONE_HUNDRED_THOUSAND\".equals(property)) return   100000;\n\t\tif (\"ONE_MILLION\"         .equals(property)) return  1000000;\n\t\tif (\"TEN_MILLION\"         .equals(property)) return 10000000;\n\t\tif (\"TWENTY_MILLION\"      .equals(property)) return 20000000;\n\t\tthrow new RuntimeException(\"NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION, TEN_MILLION or TWENTY_MILLION.\");\n\t}\n\n\tstatic private boolean isPrevaylerQueryChosen() {\n\t\treturn booleanProperty(\"RunPrevaylerQueryTest\");\n\t}\n\n\tstatic private int prevaylerQueryThreadsMin() {\n\t\treturn intProperty(\"PrevaylerQueryThreadsMinimum\");\n\t}\n\n\tstatic private int prevaylerQueryThreadsMax() {\n\t\treturn intProperty(\"PrevaylerQueryThreadsMaximum\");\n\t}\n\n\n\tstatic private boolean isPrevaylerTransactionChosen() {\n\t\treturn booleanProperty(\"RunPrevaylerTransactionTest\");\n\t}\n\n\tstatic private int prevaylerTransactionThreadsMin() {\n\t\treturn intProperty(\"PrevaylerTransactionThreadsMinimum\");\n\t}\n\n\tstatic private int prevaylerTransactionThreadsMax() {\n\t\treturn intProperty(\"PrevaylerTransactionThreadsMaximum\");\n\t}\n\n\tstatic private String prevaylerTransactionLogDirectory() {\n\t\tString result = property(\"TransactionLogDirectory\");\n\t\tout(\"\\n\\nPrevayler TransactionLog Directory: \" + result);\n\t\treturn result;\n\t}\n\n\tstatic private String prevaylerJournalSerializer() {\n\t\tString result = properties.getProperty(\"PrevaylerJournalSerializer\");\n\t\tif (result == null) result = JavaSerializer.class.getName();\n\t\tout(\"\\n\\nPrevayler Journal Serializer: \" + result);\n\t\treturn result;\n\t}\n\n\tstatic private boolean isJdbcQueryChosen() {\n\t\treturn booleanProperty(\"RunJdbcQueryTest\");\n\t}\n\n\tstatic private int jdbcQueryThreadsMin() {\n\t\treturn intProperty(\"JdbcQueryThreadsMinimum\");\n\t}\n\n\tstatic private int jdbcQueryThreadsMax() {\n\t\treturn intProperty(\"JdbcQueryThreadsMaximum\");\n\t}\n\n\n\tstatic private boolean isJdbcTransactionChosen() {\n\t\treturn booleanProperty(\"RunJdbcTransactionTest\");\n\t}\n\n\tstatic private int jdbcTransactionThreadsMin() {\n\t\treturn intProperty(\"JdbcTransactionThreadsMinimum\");\n\t}\n\n\tstatic private int jdbcTransactionThreadsMax() {\n\t\treturn intProperty(\"JdbcTransactionThreadsMaximum\");\n\t}\n\n\n\tstatic private String jdbcDriverClassName() {\n\t\treturn property(\"JdbcDriverClassName\");\n\t}\n\n\tstatic private String jdbcConnectionURL() {\n\t\treturn property(\"JdbcConnectionURL\");\n\t}\n\n\tstatic private String jdbcUser() {\n\t\treturn property(\"JdbcUser\");\n\t}\n\n\tstatic private String jdbcPassword() {\n\t\treturn property(\"JdbcPassword\");\n\t}\n\n\n\tstatic private String property(String name) {\n\t\tString result = properties.getProperty(name);\n\t\tif (result == null) throw new RuntimeException(\"Property \" + name + \" not found.\");\n\t\treturn result;\n\t}\n\n\tstatic private int intProperty(String name) {\n\t\ttry {\n\t\t\treturn Integer.valueOf(property(name)).intValue();\n\t\t} catch (NumberFormatException nfx) {\n\t\t\tout(\"NumberFormatException reading property \" + name);\n\t\t\tthrow nfx;\n\t\t}\n\t}\n\n\tstatic private boolean booleanProperty(String name) {\n\t\tboolean result = \"yes\".equalsIgnoreCase(property(name));\n\t\tif (result) return true;\n\t\tout(\"\\n\\n\\n\" + name + \" property is set to \" + property(name) + \".\");\n\t\tout(\"This test will be skipped (see properties file).\");\n\t\treturn false;\n\t}\n\n\n\tstatic private void out(Object message) {\n\t\tSystem.out.println(message);\n\t}\n}\n","Method after Refactoring":"package org.prevayler.demos.scalability;\n\nimport org.prevayler.demos.scalability.prevayler.*;\nimport org.prevayler.demos.scalability.jdbc.*;\nimport org.prevayler.foundation.serialization.JavaSerializer;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic private final Properties properties = new Properties();\n\n\n\tstatic public void main(String[] args) {\n\n\t\tout(\"\\n=============================================================\");\n\t\tout(  \"             Prevayler vs JDBC Scalability Tests             \");\n\t\tout(  \"=============================================================\\n\");\n\t\tout(\"If you have any trouble running the tests, just write to\");\n\t\tout(\"prevayler-scalability@lists.sourceforge.net and we will be glad to help.\\n\");\n\n\t\ttry {\n\t\t\tout(\"Reading the properties file:\\n\" + propertiesFile().getAbsolutePath());\n\t\t\tout(\"You can edit this file to configure the tests for the next run.\\n\");\n\n\t\t\tproperties.load(new FileInputStream(propertiesFile()));\n\n\t\t\tif (isPrevaylerQueryChosen()) runPrevaylerQuery();\n\t\t\tif (isPrevaylerTransactionChosen()) runPrevaylerTransaction();\n\t\t\tif (isJdbcQueryChosen()) runJdbcQuery();\n\t\t\tif (isJdbcTransactionChosen()) runJdbcTransaction();\n\n\t\t\tout(\"\\n\\n\\nFor better results, edit the properties file:\");\n\t\t\tout(propertiesFile().getAbsolutePath());\n\t\t\tout(\"\\nYou can publish your best results by mail to:\");\n\t\t\tout(\"prevayler-scalability@lists.sourceforge.net. Please include info about your\");\n\t\t\tout(\"processors (quantity, type, speed), compiler, VM, operating system and DBMS.\");\n\t\t\tout(\"\");\n\t\t\tout(\"Scalability test results are published on www.prevayler.org.\");\n\t\t\tout(\"See you there.\\n\");\n\t\t\tout(\"Klaus Wuestefeld and Daniel Santos.\\n\\n\");\n\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t} catch (OutOfMemoryError err) {\n\t\t\tScalabilityTestRun.outOfMemory();\n\t\t}\n\n\t}\n\n\n\tstatic private void runPrevaylerQuery() throws Exception {\n\t\tnew QueryTestRun(\n\t\t\tnew PrevaylerQuerySubject(),\n\t\t\tnumberOfObjects(),\n\t\t\tprevaylerQueryThreadsMin(),\n\t\t\tprevaylerQueryThreadsMax()\n\t\t);\n\t}\n\n\tstatic private void runPrevaylerTransaction() throws Exception {\n\t\tPrevaylerTransactionSubject subject = new PrevaylerTransactionSubject(prevaylerTransactionLogDirectory(), prevaylerJournalSerializer());\n\t\tnew TransactionTestRun(\n\t\t\tsubject,\n\t\t\tnumberOfObjects(),\n\t\t\tprevaylerTransactionThreadsMin(),\n\t\t\tprevaylerTransactionThreadsMax()\n\t\t);\n\t\tif (isPrevaylerTransactionConsistencyChecked()) {\n\t\t\tout(\"Checking transaction log consistency.\");\n\t\t\tif (!subject.isConsistent()) throw new RuntimeException(\"Transaction log consistency check failed.\");\n\t\t\tout(\"Transaction log OK.\\n\");\n\t\t}\n\t}\n\n\tstatic private void runJdbcQuery() {\n\t\tnew QueryTestRun(\n\t\t\tnew JDBCQuerySubject(jdbcDriverClassName(), jdbcConnectionURL(), jdbcUser(), jdbcPassword()),\n\t\t\tnumberOfObjects(),\n\t\t\tjdbcQueryThreadsMin(),\n\t\t\tjdbcQueryThreadsMax()\n\t\t);\n\t}\n\n\tstatic private void runJdbcTransaction() {\n\t\tnew TransactionTestRun(\n\t\t\tnew JDBCTransactionSubject(jdbcDriverClassName(), jdbcConnectionURL(), jdbcUser(), jdbcPassword()),\n\t\t\tnumberOfObjects(),\n\t\t\tjdbcTransactionThreadsMin(),\n\t\t\tjdbcTransactionThreadsMax()\n\t\t);\n\t}\n\n\n\tstatic private File propertiesFile() throws IOException {\n\t\tFile result = new File(\"ScalabilityTest.properties\");\n\t\tif (!result.exists()) {\n\t\t\tout(\"Creating the properties file.\");\n\t\t\tcreatePropertiesFile(result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic private void createPropertiesFile(File file) throws IOException {\n\t\tPrintStream stream = new PrintStream(new FileOutputStream(file));\n\t\tstream.println(\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"#                                                         #\\n\" +\n\t\t\t\"#      PREVAYLER VS JDBC SCALABILITY TEST PROPERTIES      #\\n\" +\n\t\t\t\"#                                                         #\\n\" +\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"NumberOfObjects = ONE_HUNDRED_THOUSAND\\n\" +\n\t\t\t\"# NumberOfObjects = ONE_MILLION\\n\" +\n\t\t\t\"# NumberOfObjects = TEN_MILLION\\n\" +\n\t\t\t\"# NumberOfObjects = TWENTY_MILLION\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# The results are only valid if both Prevayler and the\\n\" +\n\t\t\t\"# database can run the tests without paging memory to disk.\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# Running the tests with one hundred thousand objects\\n\" +\n\t\t\t\"# (default option) requires approx. 128MB free RAM.\\n\" +\n\t\t\t\"# The VM must be started with a sufficient maximum heap\\n\" +\n\t\t\t\"# size or you will get an OutOfMemoryError.\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# Example for Linux and Windows:  java -Xmx128000000 ...\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# (This can be set with the scalability.jvmarg property\\n\" +\n\t\t\t\"# in build.properties; see sample.build.properties for\\n\" +\n\t\t\t\"# examples.)\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# Running the tests with one million objects requires\\n\" +\n\t\t\t\"# approx. 940MB free RAM.\\n\" +\n\t\t\t\"# Running the tests with ten million objects requires\\n\" +\n\t\t\t\"# approx. 9.4GB free RAM and a 64bit VM.\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# IMPORTANT: Remember to shutdown all other non-vital\\n\" +\n\t\t\t\"# processes before running the tests. Even the database\\n\" +\n\t\t\t\"# process should be down while running the Prevayler tests\\n\" +\n\t\t\t\"# that do not use it.\\n\" +\n\t\t\t\"\\n\" +\t\n\t\t\t\"\\n\" +\t\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"# PREVAYLER QUERY TEST\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"RunPrevaylerQueryTest = YES\\n\" +\n\t\t\t\"# RunPrevaylerQueryTest = NO\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"PrevaylerQueryThreadsMinimum = 1\\n\" +\n\t\t\t\"PrevaylerQueryThreadsMaximum = 5\\n\" +\n\t\t\t\"# More threads can produce better results on\\n\" +\n\t\t\t\"# multi-processor machines.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"# PREVAYLER TRANSACTION TEST\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"RunPrevaylerTransactionTest = YES\\n\" +\n\t\t\t\"# RunPrevaylerTransactionTest = NO\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"PrevaylerTransactionThreadsMinimum = 1\\n\" +\n\t\t\t\"PrevaylerTransactionThreadsMaximum = 5\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# More threads can produce better results on machines with\\n\" +\n\t\t\t\"# multiple disks.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"TransactionTestCheckConsistency = YES\\n\" +\n\t\t\t\"# TransactionTestCheckConsistency = NO\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# Verifies the integrity of the journal files produced in\\n\" +\n\t\t\t\"# your particular environment.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"TransactionLogDirectory = TransactionTest\\n\" +\n\t\t\t\"#\\n\" +\n\t\t\t\"# The full path name can be used. Example for Windows:\\n\" +\n\t\t\t\"# TransactionLogDirectory1 = c:\\\\\\\\temp\\\\\\\\TransactionTest\\n\" +\n\t\t\t\"# The back-slash (\\\\) is the escape character so you must\\n\" +\n\t\t\t\"# use two back-slashes (\\\\\\\\).\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"PrevaylerJournalSerializer = \" + JavaSerializer.class.getName() + \"\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"# JDBC QUERY TEST\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"RunJdbcQueryTest = NO\\n\" +\n\t\t\t\"# RunJdbcQueryTest = YES\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"JdbcQueryThreadsMinimum = 1\\n\" +\n\t\t\t\"JdbcQueryThreadsMaximum = 5\\n\" +\n\t\t\t\"# More threads can produce better results on some machines.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"# JDBC TRANSACTION TEST\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"RunJdbcTransactionTest = NO\\n\" +\n\t\t\t\"# RunJdbcTransactionTest = YES\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"JdbcTransactionThreadsMinimum = 1\\n\" +\n\t\t\t\"JdbcTransactionThreadsMaximum = 5\\n\" +\n\t\t\t\"# More threads can produce better results on some machines.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"###########################################################\\n\" +\n\t\t\t\"# JDBC CONNECTION\\n\" +\n\t\t\t\"# (necessary to run the JDBC tests)\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"JdbcDriverClassName =\\n\" +\n\t\t\t\"JdbcConnectionURL =\\n\" +\n\t\t\t\"JdbcUser =\\n\" +\n\t\t\t\"JdbcPassword =\\n\" +\n\t\t\t\"# These two tables are necessary for the JDBC tests:\\n\" +\n\t\t\t\"# QUERY_TEST and TRANSACTION_TEST.\\n\" +\n\t\t\t\"# Both tables have the same column structure:\\n\" +\n\t\t\t\"#    ID DECIMAL,\\n\" +\n\t\t\t\"#    NAME VARCHAR2(8),\\n\" +\n\t\t\t\"#    STRING1 VARCHAR2(1000),\\n\" +\n\t\t\t\"#    BIGDECIMAL1 DECIMAL,\\n\" +\n\t\t\t\"#    BIGDECIMAL2 DECIMAL,\\n\" +\n\t\t\t\"#    DATE1 DATE,\\n\" +\n\t\t\t\"#    DATE2 DATE.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"# IMPORTANT: For best results, create indices on the\\n\" +\n\t\t\t\"# QUERY_TEST.NAME and TRANSACTION_TEST.ID columns.\\n\" +\n\t\t\t\"# Do not create indices on any other column.\\n\"\n\t\t);\n\t}\n\n\n\tstatic private int numberOfObjects() {\n\t\tString property = property(\"NumberOfObjects\");\n\t\tif (\"ONE_HUNDRED_THOUSAND\".equals(property)) return   100000;\n\t\tif (\"ONE_MILLION\"         .equals(property)) return  1000000;\n\t\tif (\"TEN_MILLION\"         .equals(property)) return 10000000;\n\t\tif (\"TWENTY_MILLION\"      .equals(property)) return 20000000;\n\t\tthrow new RuntimeException(\"NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION, TEN_MILLION or TWENTY_MILLION.\");\n\t}\n\n\tstatic private boolean isPrevaylerQueryChosen() {\n\t\treturn booleanProperty(\"RunPrevaylerQueryTest\");\n\t}\n\n\tstatic private int prevaylerQueryThreadsMin() {\n\t\treturn intProperty(\"PrevaylerQueryThreadsMinimum\");\n\t}\n\n\tstatic private int prevaylerQueryThreadsMax() {\n\t\treturn intProperty(\"PrevaylerQueryThreadsMaximum\");\n\t}\n\n\n\tstatic private boolean isPrevaylerTransactionChosen() {\n\t\treturn booleanProperty(\"RunPrevaylerTransactionTest\");\n\t}\n\n\tstatic private int prevaylerTransactionThreadsMin() {\n\t\treturn intProperty(\"PrevaylerTransactionThreadsMinimum\");\n\t}\n\n\tstatic private int prevaylerTransactionThreadsMax() {\n\t\treturn intProperty(\"PrevaylerTransactionThreadsMaximum\");\n\t}\n\n\tstatic private boolean isPrevaylerTransactionConsistencyChecked() {\n\t\treturn booleanProperty(\"TransactionTestCheckConsistency\");\n\t}\n\t\n\tstatic private String prevaylerTransactionLogDirectory() {\n\t\tString result = property(\"TransactionLogDirectory\");\n\t\tout(\"\\n\\nPrevayler TransactionLog Directory: \" + result);\n\t\treturn result;\n\t}\n\n\tstatic private String prevaylerJournalSerializer() {\n\t\tString result = properties.getProperty(\"PrevaylerJournalSerializer\");\n\t\tif (result == null) result = JavaSerializer.class.getName();\n\t\tout(\"\\n\\nPrevayler Journal Serializer: \" + result);\n\t\treturn result;\n\t}\n\n\tstatic private boolean isJdbcQueryChosen() {\n\t\treturn booleanProperty(\"RunJdbcQueryTest\");\n\t}\n\n\tstatic private int jdbcQueryThreadsMin() {\n\t\treturn intProperty(\"JdbcQueryThreadsMinimum\");\n\t}\n\n\tstatic private int jdbcQueryThreadsMax() {\n\t\treturn intProperty(\"JdbcQueryThreadsMaximum\");\n\t}\n\n\n\tstatic private boolean isJdbcTransactionChosen() {\n\t\treturn booleanProperty(\"RunJdbcTransactionTest\");\n\t}\n\n\tstatic private int jdbcTransactionThreadsMin() {\n\t\treturn intProperty(\"JdbcTransactionThreadsMinimum\");\n\t}\n\n\tstatic private int jdbcTransactionThreadsMax() {\n\t\treturn intProperty(\"JdbcTransactionThreadsMaximum\");\n\t}\n\n\n\tstatic private String jdbcDriverClassName() {\n\t\treturn property(\"JdbcDriverClassName\");\n\t}\n\n\tstatic private String jdbcConnectionURL() {\n\t\treturn property(\"JdbcConnectionURL\");\n\t}\n\n\tstatic private String jdbcUser() {\n\t\treturn property(\"JdbcUser\");\n\t}\n\n\tstatic private String jdbcPassword() {\n\t\treturn property(\"JdbcPassword\");\n\t}\n\n\n\tstatic private String property(String name) {\n\t\tString result = properties.getProperty(name);\n\t\tif (result == null) throw new RuntimeException(\"Property \" + name + \" not found.\");\n\t\treturn result;\n\t}\n\n\tstatic private int intProperty(String name) {\n\t\ttry {\n\t\t\treturn Integer.valueOf(property(name)).intValue();\n\t\t} catch (NumberFormatException nfx) {\n\t\t\tout(\"NumberFormatException reading property \" + name);\n\t\t\tthrow nfx;\n\t\t}\n\t}\n\n\tstatic private boolean booleanProperty(String name) {\n\t\tboolean result = \"yes\".equalsIgnoreCase(property(name));\n\t\tif (result) return true;\n\t\tout(\"\\n\\n\\n\" + name + \" property is set to \" + property(name) + \".\");\n\t\tout(\"This test will be skipped (see properties file).\");\n\t\treturn false;\n\t}\n\n\n\tstatic private void out(Object message) {\n\t\tSystem.out.println(message);\n\t}\n}\n","lineNo":63}
{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Justin Sampson.\npackage org.prevayler.foundation;\nimport org.prevayler.foundation.serialization.Serializer;\nimport org.prevayler.implementation.journal.Chunk;\nimport org.prevayler.implementation.journal.Chunking;\nimport org.prevayler.implementation.TransactionTimestamp;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class DurableOutputStream {\n\t/**\n\t * These two locks allow the two main activities of this class,\n\t * serializing transactions to a buffer on the one hand and flushing\n\t * the buffer and syncing to disk on the other hand, to proceed\n\t * concurrently. Note that where both locks are required, we always\n\t * acquire the _syncLock before acquiring the _writeLock to avoid\n\t * deadlock.\n\t */\n\tprivate final Object _writeLock = new Object();\n\tprivate final Object _syncLock = new Object();\n\n\t/** The File object is only stashed for the sake of the file() getter. */\n\tprivate final File _file;\n\n\t/** All access guarded by _writeLock. */\n\tprivate final Serializer _serializer;\n\n\t/** All access guarded by _syncLock. */\n\tprivate final FileOutputStream _fileOutputStream;\n\n\t/** All access guarded by _syncLock. */\n\tprivate final FileDescriptor _fileDescriptor;\n\n\t/** All access guarded by _writeLock. */\n\tprivate ByteArrayOutputStream _active = new ByteArrayOutputStream();\n\n\t/** All access guarded by _syncLock. */\n\tprivate ByteArrayOutputStream _inactive = new ByteArrayOutputStream();\n\n\t/** All access guarded by _writeLock. */\n\tprivate boolean _closed = false;\n\n\t/** All access guarded by _writeLock. */\n\tprivate int _objectsWritten = 0;\n\n\t/** All access guarded by _syncLock. */\n\tprivate int _objectsSynced = 0;\n\n\t/** All access guarded by _syncLock. */\n\tprivate int _fileSyncCount = 0;\n\n\tpublic DurableOutputStream(File file, Serializer serializer) throws IOException {\n\t\t_file = file;\n\t\t_fileOutputStream = new FileOutputStream(file);\n\t\t_fileDescriptor = _fileOutputStream.getFD();\n\t\t_serializer = serializer;\n\t}\n\n\tpublic void sync(TransactionTimestamp timestamp, Turn myTurn) throws IOException {\n\t\tint thisWrite;\n\n\t\t// When a thread arrives here, all we care about at first is that it\n\t\t// gets properly sequenced according to its turn.\n\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\tthisWrite = writeObject(timestamp);\n\t\t} finally {\n\t\t\tmyTurn.end();\n\t\t}\n\n\t\t// Now, having ended the turn, the next thread is allowed to come in\n\t\t// and try to write its object before we get to the sync.\n\n\t\twaitUntilSynced(thisWrite);\n\t}\n\n\tprivate int writeObject(TransactionTimestamp timestamp) throws IOException {\n\t\tsynchronized (_writeLock) {\n\t\t\tif (_closed) {\n\t\t\t\tthrow new IOException(\"already closed\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tByteArrayOutputStream bytes = new ByteArrayOutputStream();\n\t\t\t\t_serializer.writeObject(bytes, timestamp);\n\t\t\t\tChunking.writeChunk(_active, new Chunk(bytes.toByteArray()));\n\t\t\t} catch (IOException exception) {\n\t\t\t\tinternalClose();\n\t\t\t\tthrow exception;\n\t\t\t}\n\n\t\t\t_objectsWritten++;\n\t\t\treturn _objectsWritten;\n\t\t}\n\t}\n\n\tprivate void waitUntilSynced(int thisWrite) throws IOException {\n\t\t// Here's the real magic. If this thread is the first to have written\n\t\t// an object after a period of inactivity, and there are no other\n\t\t// threads coming in, then thisWrite is trivially one greater than\n\t\t// _objectsSynced, so this thread goes right ahead to sync its own\n\t\t// object alone. But then, if another thread comes along and writes\n\t\t// another object while this thread is syncing, it will write to the\n\t\t// _active buffer and then promply block on the _syncLock until this\n\t\t// thread finishes the sync. If threads continue to come in at just\n\t\t// about the rate that syncs can happen, each thread will wait for the\n\t\t// previous sync to complete and then initiate its own sync. The\n\t\t// latency for the first thread is exactly the time for one sync, which\n\t\t// is the minimum possible latency; the latency for any later thread is\n\t\t// somewhere between that minimum and a maximum of two syncs, with the\n\t\t// average being closer to the minimum end.\n\t\t//\n\t\t// Now, consider the steady state under heavy load. Some thread will\n\t\t// always be syncing the _inactive buffer to disk, so every thread that\n\t\t// arrives will write its object to the _active buffer and then wait\n\t\t// here on the _syncLock. If 10 threads arrive during a given sync\n\t\t// operation, then _active will hold 10 objects when that sync\n\t\t// completes. As soon as that earlier thread releases _syncLock, one of\n\t\t// those 10 new threads will acquire the lock and notice that its\n\t\t// object has not yet been synced; it will then swap the buffers and\n\t\t// flush and sync all 10 objects at once. Each of the 10 threads will\n\t\t// acquire _syncLock in turn and now see that their object has already\n\t\t// been synced and do nothing.\n\n\t\tsynchronized (_syncLock) {\n\t\t\tif (_objectsSynced < thisWrite) {\n\t\t\t\tint objectsWritten;\n\t\t\t\tsynchronized (_writeLock) {\n\t\t\t\t\tif (_closed) {\n\t\t\t\t\t\tthrow new IOException(\"already closed\");\n\t\t\t\t\t}\n\n\t\t\t\t\tByteArrayOutputStream swap = _active;\n\t\t\t\t\t_active = _inactive;\n\t\t\t\t\t_inactive = swap;\n\n\t\t\t\t\tobjectsWritten = _objectsWritten;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// Resetting the buffer clears its contents but keeps the\n\t\t\t\t\t// allocated space. Therefore the buffers should quickly\n\t\t\t\t\t// reach a steady state of an appropriate size and then not\n\t\t\t\t\t// need to grow any more.\n\n\t\t\t\t\t_inactive.writeTo(_fileOutputStream);\n\t\t\t\t\t_inactive.reset();\n\t\t\t\t\t_fileOutputStream.flush();\n\n\t\t\t\t\t// Dropping the priority around the sync seems to have a\n\t\t\t\t\t// somewhat favorable effect on throughput, at least on\n\t\t\t\t\t// some Windows machines. Whether the effect has survived\n\t\t\t\t\t// the various rewrites of this class enough to justify\n\t\t\t\t\t// the continuing maintanence of this bit of code needs\n\t\t\t\t\t// to be investigated.\n\n\t\t\t\t\tThread currentThread = Thread.currentThread();\n\t\t\t\t\tint originalPriority = currentThread.getPriority();\n\t\t\t\t\tcurrentThread.setPriority(Thread.MIN_PRIORITY);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_fileDescriptor.sync();\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tcurrentThread.setPriority(originalPriority);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException exception) {\n\t\t\t\t\tinternalClose();\n\t\t\t\t\tthrow exception;\n\t\t\t\t}\n\n\t\t\t\t_objectsSynced = objectsWritten;\n\t\t\t\t_fileSyncCount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void close() throws IOException {\n\t\tsynchronized (_syncLock) {\n\t\t\tsynchronized (_writeLock) {\n\t\t\t\tif (_closed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tinternalClose();\n\t\t\t\t_fileOutputStream.close();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void internalClose() {\n\t\tsynchronized (_writeLock) {\n\t\t\t_closed = true;\n\t\t\t_active = null;\n\t\t\t_inactive = null;\n\t\t}\n\t}\n\n\tpublic File file() {\n\t\treturn _file;\n\t}\n\n\tpublic synchronized int fileSyncCount() {\n\t\tsynchronized (_syncLock) {\n\t\t\treturn _fileSyncCount;\n\t\t}\n\t}\n\n\tpublic boolean reallyClosed() {\n\t\tsynchronized (_writeLock) {\n\t\t\treturn _closed;\n\t\t}\n\t}\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Justin Sampson.\npackage org.prevayler.foundation;\nimport org.prevayler.foundation.serialization.Serializer;\nimport org.prevayler.implementation.journal.Chunk;\nimport org.prevayler.implementation.journal.Chunking;\nimport org.prevayler.implementation.TransactionTimestamp;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class DurableOutputStream {\n\t/**\n\t * These two locks allow the two main activities of this class,\n\t * serializing transactions to a buffer on the one hand and flushing\n\t * the buffer and syncing to disk on the other hand, to proceed\n\t * concurrently. Note that where both locks are required, we always\n\t * acquire the _syncLock before acquiring the _writeLock to avoid\n\t * deadlock.\n\t */\n\tprivate final Object _writeLock = new Object();\n\tprivate final Object _syncLock = new Object();\n\n\t/** The File object is only stashed for the sake of the file() getter. */\n\tprivate final File _file;\n\n\t/** All access guarded by _writeLock. */\n\tprivate final Serializer _serializer;\n\n\t/** All access guarded by _syncLock. */\n\tprivate final FileOutputStream _fileOutputStream;\n\n\t/** All access guarded by _syncLock. */\n\tprivate final FileDescriptor _fileDescriptor;\n\n\t/** All access guarded by _writeLock. */\n\tprivate ByteArrayOutputStream _active = new ByteArrayOutputStream();\n\n\t/** All access guarded by _syncLock. */\n\tprivate ByteArrayOutputStream _inactive = new ByteArrayOutputStream();\n\n\t/** All access guarded by _writeLock. */\n\tprivate boolean _closed = false;\n\n\t/** All access guarded by _writeLock. */\n\tprivate int _objectsWritten = 0;\n\n\t/** All access guarded by _syncLock. */\n\tprivate int _objectsSynced = 0;\n\n\t/** All access guarded by _syncLock. */\n\tprivate int _fileSyncCount = 0;\n\n\tpublic DurableOutputStream(File file, Serializer serializer) throws IOException {\n\t\t_file = file;\n\t\t_fileOutputStream = new FileOutputStream(file);\n\t\t_fileDescriptor = _fileOutputStream.getFD();\n\t\t_serializer = serializer;\n\t}\n\n\tpublic void sync(TransactionTimestamp timestamp, Turn myTurn) throws IOException {\n\t\tint thisWrite;\n\n\t\t// When a thread arrives here, all we care about at first is that it\n\t\t// gets properly sequenced according to its turn.\n\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\tthisWrite = writeObject(timestamp);\n\t\t} finally {\n\t\t\tmyTurn.end();\n\t\t}\n\n\t\t// Now, having ended the turn, the next thread is allowed to come in\n\t\t// and try to write its object before we get to the sync.\n\n\t\twaitUntilSynced(thisWrite);\n\t}\n\n\tprivate int writeObject(TransactionTimestamp timestamp) throws IOException {\n\t\tsynchronized (_writeLock) {\n\t\t\tif (_closed) {\n\t\t\t\tthrow new IOException(\"already closed\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tByteArrayOutputStream bytes = new ByteArrayOutputStream();\n\t\t\t\t_serializer.writeObject(bytes, timestamp.transaction());\n\t\t\t\tChunk chunk = new Chunk(bytes.toByteArray());\n\t\t\t\tchunk.setParameter(\"timestamp\", String.valueOf(timestamp.timestamp().getTime()));\n\t\t\t\tChunking.writeChunk(_active, chunk);\n\t\t\t} catch (IOException exception) {\n\t\t\t\tinternalClose();\n\t\t\t\tthrow exception;\n\t\t\t}\n\n\t\t\t_objectsWritten++;\n\t\t\treturn _objectsWritten;\n\t\t}\n\t}\n\n\tprivate void waitUntilSynced(int thisWrite) throws IOException {\n\t\t// Here's the real magic. If this thread is the first to have written\n\t\t// an object after a period of inactivity, and there are no other\n\t\t// threads coming in, then thisWrite is trivially one greater than\n\t\t// _objectsSynced, so this thread goes right ahead to sync its own\n\t\t// object alone. But then, if another thread comes along and writes\n\t\t// another object while this thread is syncing, it will write to the\n\t\t// _active buffer and then promply block on the _syncLock until this\n\t\t// thread finishes the sync. If threads continue to come in at just\n\t\t// about the rate that syncs can happen, each thread will wait for the\n\t\t// previous sync to complete and then initiate its own sync. The\n\t\t// latency for the first thread is exactly the time for one sync, which\n\t\t// is the minimum possible latency; the latency for any later thread is\n\t\t// somewhere between that minimum and a maximum of two syncs, with the\n\t\t// average being closer to the minimum end.\n\t\t//\n\t\t// Now, consider the steady state under heavy load. Some thread will\n\t\t// always be syncing the _inactive buffer to disk, so every thread that\n\t\t// arrives will write its object to the _active buffer and then wait\n\t\t// here on the _syncLock. If 10 threads arrive during a given sync\n\t\t// operation, then _active will hold 10 objects when that sync\n\t\t// completes. As soon as that earlier thread releases _syncLock, one of\n\t\t// those 10 new threads will acquire the lock and notice that its\n\t\t// object has not yet been synced; it will then swap the buffers and\n\t\t// flush and sync all 10 objects at once. Each of the 10 threads will\n\t\t// acquire _syncLock in turn and now see that their object has already\n\t\t// been synced and do nothing.\n\n\t\tsynchronized (_syncLock) {\n\t\t\tif (_objectsSynced < thisWrite) {\n\t\t\t\tint objectsWritten;\n\t\t\t\tsynchronized (_writeLock) {\n\t\t\t\t\tif (_closed) {\n\t\t\t\t\t\tthrow new IOException(\"already closed\");\n\t\t\t\t\t}\n\n\t\t\t\t\tByteArrayOutputStream swap = _active;\n\t\t\t\t\t_active = _inactive;\n\t\t\t\t\t_inactive = swap;\n\n\t\t\t\t\tobjectsWritten = _objectsWritten;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// Resetting the buffer clears its contents but keeps the\n\t\t\t\t\t// allocated space. Therefore the buffers should quickly\n\t\t\t\t\t// reach a steady state of an appropriate size and then not\n\t\t\t\t\t// need to grow any more.\n\n\t\t\t\t\t_inactive.writeTo(_fileOutputStream);\n\t\t\t\t\t_inactive.reset();\n\t\t\t\t\t_fileOutputStream.flush();\n\n\t\t\t\t\t// Dropping the priority around the sync seems to have a\n\t\t\t\t\t// somewhat favorable effect on throughput, at least on\n\t\t\t\t\t// some Windows machines. Whether the effect has survived\n\t\t\t\t\t// the various rewrites of this class enough to justify\n\t\t\t\t\t// the continuing maintanence of this bit of code needs\n\t\t\t\t\t// to be investigated.\n\n\t\t\t\t\tThread currentThread = Thread.currentThread();\n\t\t\t\t\tint originalPriority = currentThread.getPriority();\n\t\t\t\t\tcurrentThread.setPriority(Thread.MIN_PRIORITY);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_fileDescriptor.sync();\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tcurrentThread.setPriority(originalPriority);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException exception) {\n\t\t\t\t\tinternalClose();\n\t\t\t\t\tthrow exception;\n\t\t\t\t}\n\n\t\t\t\t_objectsSynced = objectsWritten;\n\t\t\t\t_fileSyncCount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void close() throws IOException {\n\t\tsynchronized (_syncLock) {\n\t\t\tsynchronized (_writeLock) {\n\t\t\t\tif (_closed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tinternalClose();\n\t\t\t\t_fileOutputStream.close();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void internalClose() {\n\t\tsynchronized (_writeLock) {\n\t\t\t_closed = true;\n\t\t\t_active = null;\n\t\t\t_inactive = null;\n\t\t}\n\t}\n\n\tpublic File file() {\n\t\treturn _file;\n\t}\n\n\tpublic synchronized int fileSyncCount() {\n\t\tsynchronized (_syncLock) {\n\t\t\treturn _fileSyncCount;\n\t\t}\n\t}\n\n\tpublic boolean reallyClosed() {\n\t\tsynchronized (_writeLock) {\n\t\t\treturn _closed;\n\t\t}\n\t}\n}\n","lineNo":94}
{"Smelly Sample":"package org.prevayler.implementation.journal;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\n\npublic class Chunking {\n\n\tprivate static final String ASCII = \"US-ASCII\";\n\tprivate static final byte[] CRLF = new byte[] {'\\r', '\\n'};\n\tprivate static final String SIZE = \"0|[1-9A-F][0-9A-F]{0,6}|[1-7][0-9A-F]{7}\";\n\tprivate static final String TOKEN = \"[^\\u0000-\\u0020()<>@,;:\\\\\\\\\\\"/\\\\[\\\\]?={}\\u007F-\\uFFFF]+\";\n\tprivate static final String HEADER = \"(\" + SIZE + \")(;\" + TOKEN + \"=\" + TOKEN + \")*\\r\\n\";\n\tprivate static final Pattern TOKEN_PATTERN = Pattern.compile(TOKEN);\n\tprivate static final Pattern HEADER_PATTERN = Pattern.compile(HEADER);\n\n\tprivate static boolean validToken(String token) {\n\t\treturn TOKEN_PATTERN.matcher(token).matches();\n\t}\n\n\tpublic static void writeChunk(OutputStream stream, Chunk chunk) throws IOException {\n\t\tstream.write(Integer.toHexString(chunk.getBytes().length).toUpperCase().getBytes(ASCII));\n\t\tIterator iterator = chunk.getParameters().entrySet().iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry) iterator.next();\n\t\t\tString name = (String) entry.getKey();\n\t\t\tString value = (String) entry.getValue();\n\t\t\tif (!validToken(name)) {\n\t\t\t\tthrow new IOException(\"Invalid parameter name '\" + name + \"'\");\n\t\t\t}\n\t\t\tif (!validToken(value)) {\n\t\t\t\tthrow new IOException(\"Invalid parameter value '\" + value + \"'\");\n\t\t\t}\n\t\t\tstream.write(';');\n\t\t\tstream.write(name.getBytes(ASCII));\n\t\t\tstream.write('=');\n\t\t\tstream.write(value.getBytes(ASCII));\n\t\t}\n\t\tstream.write(CRLF);\n\t\tstream.write(chunk.getBytes());\n\t\tstream.write(CRLF);\n\t}\n\n\tpublic static Chunk readChunk(InputStream stream) throws IOException {\n\t\tString header = readLine(stream);\n\n\t\tif (header == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!HEADER_PATTERN.matcher(header).matches()) {\n\t\t\tthrow new IOException(\"Chunk header corrupted\");\n\t\t}\n\n\t\tStringTokenizer tokenizer = new StringTokenizer(header, \";=\\r\\n\");\n\n\t\tint size = Integer.parseInt(tokenizer.nextToken(), 16);\n\n\t\tMap parameters = new LinkedHashMap();\n\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t\tString name = tokenizer.nextToken();\n\t\t\tString value = tokenizer.nextToken();\n\t\t\tparameters.put(name, value);\n\t\t}\n\n\t\tbyte[] bytes = new byte[size];\n\t\tint total = 0;\n\t\twhile (total < size) {\n\t\t\tint read = stream.read(bytes, total, size - total);\n\t\t\tif (read == -1) {\n\t\t\t\tthrow new IOException(\"Unexpected end of stream in chunk data\");\n\t\t\t}\n\t\t\ttotal += read;\n\t\t}\n\n\t\tif (stream.read() != '\\r' || stream.read() != '\\n') {\n\t\t\tthrow new IOException(\"Chunk trailer corrupted\");\n\t\t}\n\n\t\treturn new Chunk(bytes, parameters);\n\t}\n\n\tprivate static String readLine(InputStream stream) throws IOException {\n\t\tByteArrayOutputStream header = new ByteArrayOutputStream();\n\t\twhile (true) {\n\t\t\tint b = stream.read();\n\t\t\tif (b == -1) {\n\t\t\t\tif (header.size() == 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new IOException(\"Unexpected end of stream in chunk header\");\n\t\t\t\t}\n\t\t\t}\n\t\t\theader.write(b);\n\t\t\tif (b == '\\n') {\n\t\t\t\treturn header.toString(ASCII);\n\t\t\t}\n\t\t}\n\t}\n\n}\n","Method after Refactoring":"package org.prevayler.implementation.journal;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.EOFException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\n\npublic class Chunking {\n\n\tprivate static final String ASCII = \"US-ASCII\";\n\tprivate static final byte[] CRLF = new byte[] {'\\r', '\\n'};\n\tprivate static final String SIZE = \"0|[1-9A-F][0-9A-F]{0,6}|[1-7][0-9A-F]{7}\";\n\tprivate static final String TOKEN = \"[^\\u0000-\\u0020()<>@,;:\\\\\\\\\\\"/\\\\[\\\\]?={}\\u007F-\\uFFFF]+\";\n\tprivate static final String HEADER = \"(\" + SIZE + \")(;\" + TOKEN + \"=\" + TOKEN + \")*\\r\\n\";\n\tprivate static final Pattern TOKEN_PATTERN = Pattern.compile(TOKEN);\n\tprivate static final Pattern HEADER_PATTERN = Pattern.compile(HEADER);\n\n\tprivate static boolean validToken(String token) {\n\t\treturn TOKEN_PATTERN.matcher(token).matches();\n\t}\n\n\tpublic static void writeChunk(OutputStream stream, Chunk chunk) throws IOException {\n\t\tstream.write(Integer.toHexString(chunk.getBytes().length).toUpperCase().getBytes(ASCII));\n\t\tIterator iterator = chunk.getParameters().entrySet().iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry) iterator.next();\n\t\t\tString name = (String) entry.getKey();\n\t\t\tString value = (String) entry.getValue();\n\t\t\tif (!validToken(name)) {\n\t\t\t\tthrow new IOException(\"Invalid parameter name '\" + name + \"'\");\n\t\t\t}\n\t\t\tif (!validToken(value)) {\n\t\t\t\tthrow new IOException(\"Invalid parameter value '\" + value + \"'\");\n\t\t\t}\n\t\t\tstream.write(';');\n\t\t\tstream.write(name.getBytes(ASCII));\n\t\t\tstream.write('=');\n\t\t\tstream.write(value.getBytes(ASCII));\n\t\t}\n\t\tstream.write(CRLF);\n\t\tstream.write(chunk.getBytes());\n\t\tstream.write(CRLF);\n\t}\n\n\tpublic static Chunk readChunk(InputStream stream) throws IOException {\n\t\tString header = readLine(stream);\n\n\t\tif (header == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!HEADER_PATTERN.matcher(header).matches()) {\n\t\t\tthrow new IOException(\"Chunk header corrupted\");\n\t\t}\n\n\t\tStringTokenizer tokenizer = new StringTokenizer(header, \";=\\r\\n\");\n\n\t\tint size = Integer.parseInt(tokenizer.nextToken(), 16);\n\n\t\tMap parameters = new LinkedHashMap();\n\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t\tString name = tokenizer.nextToken();\n\t\t\tString value = tokenizer.nextToken();\n\t\t\tparameters.put(name, value);\n\t\t}\n\n\t\tbyte[] bytes = new byte[size];\n\t\tint total = 0;\n\t\twhile (total < size) {\n\t\t\tint read = stream.read(bytes, total, size - total);\n\t\t\tif (read == -1) {\n\t\t\t\tthrow new EOFException(\"Unexpected end of stream in chunk data\");\n\t\t\t}\n\t\t\ttotal += read;\n\t\t}\n\n\t\tint cr = stream.read();\n\t\tint lf = stream.read();\n\t\tif (cr == -1 || cr == '\\r' && lf == -1) {\n\t\t\tthrow new EOFException(\"Unexpected end of stream in chunk trailer\");\n\t\t} else if (cr != '\\r' || lf != '\\n') {\n\t\t\tthrow new IOException(\"Chunk trailer corrupted\");\n\t\t}\n\n\t\treturn new Chunk(bytes, parameters);\n\t}\n\n\tprivate static String readLine(InputStream stream) throws IOException {\n\t\tByteArrayOutputStream header = new ByteArrayOutputStream();\n\t\twhile (true) {\n\t\t\tint b = stream.read();\n\t\t\tif (b == -1) {\n\t\t\t\tif (header.size() == 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new EOFException(\"Unexpected end of stream in chunk header\");\n\t\t\t\t}\n\t\t\t}\n\t\t\theader.write(b);\n\t\t\tif (b == '\\n') {\n\t\t\t\treturn header.toString(ASCII);\n\t\t\t}\n\t\t}\n\t}\n\n}\n","lineNo":84}
{"Smelly Sample":"package org.prevayler.implementation.journal;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\n\npublic class Chunking {\n\n\tprivate static final String ASCII = \"US-ASCII\";\n\tprivate static final byte[] CRLF = new byte[] {'\\r', '\\n'};\n\tprivate static final String SIZE = \"0|[1-9A-F][0-9A-F]{0,6}|[1-7][0-9A-F]{7}\";\n\tprivate static final String TOKEN = \"[^\\u0000-\\u0020()<>@,;:\\\\\\\\\\\"/\\\\[\\\\]?={}\\u007F-\\uFFFF]+\";\n\tprivate static final String HEADER = \"(\" + SIZE + \")(;\" + TOKEN + \"=\" + TOKEN + \")*\\r\\n\";\n\tprivate static final Pattern TOKEN_PATTERN = Pattern.compile(TOKEN);\n\tprivate static final Pattern HEADER_PATTERN = Pattern.compile(HEADER);\n\n\tprivate static boolean validToken(String token) {\n\t\treturn TOKEN_PATTERN.matcher(token).matches();\n\t}\n\n\tpublic static void writeChunk(OutputStream stream, Chunk chunk) throws IOException {\n\t\tstream.write(Integer.toHexString(chunk.getBytes().length).toUpperCase().getBytes(ASCII));\n\t\tIterator iterator = chunk.getParameters().entrySet().iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry) iterator.next();\n\t\t\tString name = (String) entry.getKey();\n\t\t\tString value = (String) entry.getValue();\n\t\t\tif (!validToken(name)) {\n\t\t\t\tthrow new IOException(\"Invalid parameter name '\" + name + \"'\");\n\t\t\t}\n\t\t\tif (!validToken(value)) {\n\t\t\t\tthrow new IOException(\"Invalid parameter value '\" + value + \"'\");\n\t\t\t}\n\t\t\tstream.write(';');\n\t\t\tstream.write(name.getBytes(ASCII));\n\t\t\tstream.write('=');\n\t\t\tstream.write(value.getBytes(ASCII));\n\t\t}\n\t\tstream.write(CRLF);\n\t\tstream.write(chunk.getBytes());\n\t\tstream.write(CRLF);\n\t}\n\n\tpublic static Chunk readChunk(InputStream stream) throws IOException {\n\t\tString header = readLine(stream);\n\n\t\tif (header == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!HEADER_PATTERN.matcher(header).matches()) {\n\t\t\tthrow new IOException(\"Chunk header corrupted\");\n\t\t}\n\n\t\tStringTokenizer tokenizer = new StringTokenizer(header, \";=\\r\\n\");\n\n\t\tint size = Integer.parseInt(tokenizer.nextToken(), 16);\n\n\t\tMap parameters = new LinkedHashMap();\n\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t\tString name = tokenizer.nextToken();\n\t\t\tString value = tokenizer.nextToken();\n\t\t\tparameters.put(name, value);\n\t\t}\n\n\t\tbyte[] bytes = new byte[size];\n\t\tint total = 0;\n\t\twhile (total < size) {\n\t\t\tint read = stream.read(bytes, total, size - total);\n\t\t\tif (read == -1) {\n\t\t\t\tthrow new IOException(\"Unexpected end of stream in chunk data\");\n\t\t\t}\n\t\t\ttotal += read;\n\t\t}\n\n\t\tif (stream.read() != '\\r' || stream.read() != '\\n') {\n\t\t\tthrow new IOException(\"Chunk trailer corrupted\");\n\t\t}\n\n\t\treturn new Chunk(bytes, parameters);\n\t}\n\n\tprivate static String readLine(InputStream stream) throws IOException {\n\t\tByteArrayOutputStream header = new ByteArrayOutputStream();\n\t\twhile (true) {\n\t\t\tint b = stream.read();\n\t\t\tif (b == -1) {\n\t\t\t\tif (header.size() == 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new IOException(\"Unexpected end of stream in chunk header\");\n\t\t\t\t}\n\t\t\t}\n\t\t\theader.write(b);\n\t\t\tif (b == '\\n') {\n\t\t\t\treturn header.toString(ASCII);\n\t\t\t}\n\t\t}\n\t}\n\n}\n","Method after Refactoring":"package org.prevayler.implementation.journal;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.EOFException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\n\npublic class Chunking {\n\n\tprivate static final String ASCII = \"US-ASCII\";\n\tprivate static final byte[] CRLF = new byte[] {'\\r', '\\n'};\n\tprivate static final String SIZE = \"0|[1-9A-F][0-9A-F]{0,6}|[1-7][0-9A-F]{7}\";\n\tprivate static final String TOKEN = \"[^\\u0000-\\u0020()<>@,;:\\\\\\\\\\\"/\\\\[\\\\]?={}\\u007F-\\uFFFF]+\";\n\tprivate static final String HEADER = \"(\" + SIZE + \")(;\" + TOKEN + \"=\" + TOKEN + \")*\\r\\n\";\n\tprivate static final Pattern TOKEN_PATTERN = Pattern.compile(TOKEN);\n\tprivate static final Pattern HEADER_PATTERN = Pattern.compile(HEADER);\n\n\tprivate static boolean validToken(String token) {\n\t\treturn TOKEN_PATTERN.matcher(token).matches();\n\t}\n\n\tpublic static void writeChunk(OutputStream stream, Chunk chunk) throws IOException {\n\t\tstream.write(Integer.toHexString(chunk.getBytes().length).toUpperCase().getBytes(ASCII));\n\t\tIterator iterator = chunk.getParameters().entrySet().iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry) iterator.next();\n\t\t\tString name = (String) entry.getKey();\n\t\t\tString value = (String) entry.getValue();\n\t\t\tif (!validToken(name)) {\n\t\t\t\tthrow new IOException(\"Invalid parameter name '\" + name + \"'\");\n\t\t\t}\n\t\t\tif (!validToken(value)) {\n\t\t\t\tthrow new IOException(\"Invalid parameter value '\" + value + \"'\");\n\t\t\t}\n\t\t\tstream.write(';');\n\t\t\tstream.write(name.getBytes(ASCII));\n\t\t\tstream.write('=');\n\t\t\tstream.write(value.getBytes(ASCII));\n\t\t}\n\t\tstream.write(CRLF);\n\t\tstream.write(chunk.getBytes());\n\t\tstream.write(CRLF);\n\t}\n\n\tpublic static Chunk readChunk(InputStream stream) throws IOException {\n\t\tString header = readLine(stream);\n\n\t\tif (header == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!HEADER_PATTERN.matcher(header).matches()) {\n\t\t\tthrow new IOException(\"Chunk header corrupted\");\n\t\t}\n\n\t\tStringTokenizer tokenizer = new StringTokenizer(header, \";=\\r\\n\");\n\n\t\tint size = Integer.parseInt(tokenizer.nextToken(), 16);\n\n\t\tMap parameters = new LinkedHashMap();\n\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t\tString name = tokenizer.nextToken();\n\t\t\tString value = tokenizer.nextToken();\n\t\t\tparameters.put(name, value);\n\t\t}\n\n\t\tbyte[] bytes = new byte[size];\n\t\tint total = 0;\n\t\twhile (total < size) {\n\t\t\tint read = stream.read(bytes, total, size - total);\n\t\t\tif (read == -1) {\n\t\t\t\tthrow new EOFException(\"Unexpected end of stream in chunk data\");\n\t\t\t}\n\t\t\ttotal += read;\n\t\t}\n\n\t\tint cr = stream.read();\n\t\tint lf = stream.read();\n\t\tif (cr == -1 || cr == '\\r' && lf == -1) {\n\t\t\tthrow new EOFException(\"Unexpected end of stream in chunk trailer\");\n\t\t} else if (cr != '\\r' || lf != '\\n') {\n\t\t\tthrow new IOException(\"Chunk trailer corrupted\");\n\t\t}\n\n\t\treturn new Chunk(bytes, parameters);\n\t}\n\n\tprivate static String readLine(InputStream stream) throws IOException {\n\t\tByteArrayOutputStream header = new ByteArrayOutputStream();\n\t\twhile (true) {\n\t\t\tint b = stream.read();\n\t\t\tif (b == -1) {\n\t\t\t\tif (header.size() == 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new EOFException(\"Unexpected end of stream in chunk header\");\n\t\t\t\t}\n\t\t\t}\n\t\t\theader.write(b);\n\t\t\tif (b == '\\n') {\n\t\t\t\treturn header.toString(ASCII);\n\t\t\t}\n\t\t}\n\t}\n\n}\n","lineNo":83}
{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Carlos Villela.\n\npackage org.prevayler.implementation.journal;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.util.Date;\n\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.DurableOutputStream;\nimport org.prevayler.foundation.FileManager;\nimport org.prevayler.foundation.SimpleInputStream;\nimport org.prevayler.foundation.StopWatch;\nimport org.prevayler.foundation.Turn;\nimport org.prevayler.foundation.monitor.Monitor;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\n\n\n/** A Journal that will write all transactions to .journal files.\n */\npublic class PersistentJournal implements FileFilter, Journal {\n\n\tprivate final File _directory;\n\tprivate DurableOutputStream _outputJournal;\n\n\tprivate final long _journalSizeThresholdInBytes;\n\tprivate final long _journalAgeThresholdInMillis;\n\tprivate StopWatch _journalAgeTimer;\n\t\n\tprivate long _nextTransaction;\n\tprivate boolean _nextTransactionInitialized = false;\n\tprivate ClassLoader _loader;\n\tprivate Monitor _monitor;\n\n\n\t/**\n\t * @param directory Where transaction journal files will be read and written.\n\t * @param journalSizeThresholdInBytes Size of the current journal file beyond which it is closed and a new one started. Zero indicates no size threshold. This is useful journal backup purposes.\n\t * @param journalAgeThresholdInMillis Age of the current journal file beyond which it is closed and a new one started. Zero indicates no age threshold. This is useful journal backup purposes.\n\t */\n\tpublic PersistentJournal(String directory, long journalSizeThresholdInBytes, long journalAgeThresholdInMillis, ClassLoader loader, Monitor monitor) throws IOException {\n\t    _monitor = monitor;\n\t\t_loader = loader;\n\t\t_directory = FileManager.produceDirectory(directory);\n\t\t_journalSizeThresholdInBytes = journalSizeThresholdInBytes;\n\t\t_journalAgeThresholdInMillis = journalAgeThresholdInMillis;\n\t}\n\n\n\tpublic void append(Transaction transaction, Date executionTime, Turn myTurn) {\n\t\tif (!_nextTransactionInitialized) throw new IllegalStateException(\"Journal.update() has to be called at least once before Journal.append().\");\n\n\t\tDurableOutputStream myOutputJournal;\n\t\tDurableOutputStream outputJournalToClose = null;\n\t\t\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\tif (!isOutputJournalStillValid()) {\n\t\t\t\toutputJournalToClose = _outputJournal;\n\t\t\t\t_outputJournal = createOutputJournal(_nextTransaction);\n\t\t\t\t_journalAgeTimer = StopWatch.start();\n\t\t\t}\n\t\t\t_nextTransaction++;\n\t\t\tmyOutputJournal = _outputJournal;\n\t\t} finally {\n\t\t\tmyTurn.end();\n\t\t}\n\n\t\ttry {\n\t\t\tmyOutputJournal.sync(new TransactionTimestamp(transaction, executionTime), myTurn);\n\t\t} catch (IOException iox) {\n\t\t\thandle(iox, _outputJournal.file(), \"writing to\");\n\t\t}\n\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\ttry {\n\t\t\t\tif (outputJournalToClose != null) outputJournalToClose.close();\n\t\t\t} catch (IOException iox) {\n\t\t\t\thandle(iox, outputJournalToClose.file(), \"closing\");\n\t\t\t}\n\t\t} finally {\n\t\t\tmyTurn.end();\n\t\t}\n\t\t\n\t}\n\n\n\tprivate boolean isOutputJournalStillValid() {\n\t\treturn _outputJournal != null\n\t\t\t&& !isOutputJournalTooBig() \n\t\t\t&& !isOutputJournalTooOld();\n\t}\n\n\n\tprivate boolean isOutputJournalTooOld() {\n\t\treturn _journalAgeThresholdInMillis != 0\n\t\t\t&& _journalAgeTimer.millisEllapsed() >= _journalAgeThresholdInMillis;\n\t}\n\n\n\tprivate boolean isOutputJournalTooBig() {\n\t\treturn _journalSizeThresholdInBytes != 0\n\t\t\t&& _outputJournal.file().length() >= _journalSizeThresholdInBytes;\n\t}\n\n\n\tprivate DurableOutputStream createOutputJournal(long transactionNumber) {\n\t\tFile file = journalFile(transactionNumber);\n\t\ttry {\n\t\t\treturn new DurableOutputStream(file);\n\t\t} catch (IOException iox) {\n\t\t\thandle(iox, file, \"creating\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/** IMPORTANT: This method cannot be called while the log() method is being called in another thread.\n\t * If there are no journal files in the directory (when a snapshot is taken and all journal files are manually deleted, for example), the initialTransaction parameter in the first call to this method will define what the next transaction number will be. We have to find clearer/simpler semantics.\n\t */\n\tpublic void update(TransactionSubscriber subscriber, long initialTransactionWanted) throws IOException, ClassNotFoundException {\n\t\tlong initialLogFile = findInitialJournalFile(initialTransactionWanted);\n\t\t\n\t\tif (initialLogFile == 0) {\n\t\t\tinitializeNextTransaction(initialTransactionWanted, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tlong nextTransaction = recoverPendingTransactions(subscriber, initialTransactionWanted, initialLogFile);\n\t\t\n\t\tinitializeNextTransaction(initialTransactionWanted, nextTransaction);\n\t}\n\n\n\tprivate long findInitialJournalFile(long initialTransactionWanted) {\n\t\tlong initialFileCandidate = initialTransactionWanted;\n\t\twhile (initialFileCandidate != 0) {   //TODO Optimize.\n\t\t\tif (journalFile(initialFileCandidate).exists()) break;\n\t\t\tinitialFileCandidate--;\n\t\t}\n\t\treturn initialFileCandidate;\n\t}\n\n\n\tprivate void initializeNextTransaction(long initialTransactionWanted, long nextTransaction) throws IOException {\n\t\tif (_nextTransactionInitialized) {\n\t\t\tif (_nextTransaction < initialTransactionWanted) throw new IOException(\"The transaction log has not yet reached transaction \" + initialTransactionWanted + \". The last logged transaction was \" + (_nextTransaction - 1) + \".\");\n\t\t\tif (nextTransaction < _nextTransaction) throw new IOException(\"Unable to find journal file containing transaction \" + nextTransaction + \". Might have been manually deleted.\");\n\t\t\tif (nextTransaction > _nextTransaction) throw new IllegalStateException();\n\t\t\treturn;\n\t\t}\n\t\t_nextTransactionInitialized = true;\n\t\t_nextTransaction = initialTransactionWanted > nextTransaction\n\t\t\t? initialTransactionWanted\n\t\t\t: nextTransaction;\n\t}\n\n\n\tprivate long recoverPendingTransactions(TransactionSubscriber subscriber, long initialTransaction, long initialLogFile)\tthrows IOException, ClassNotFoundException {\n\t\tlong recoveringTransaction = initialLogFile;\n\t\tFile logFile = journalFile(recoveringTransaction);\n\t\tSimpleInputStream inputLog = new SimpleInputStream(logFile, _loader, _monitor);\n\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tTransactionTimestamp entry = (TransactionTimestamp)inputLog.readObject();\n\t\t\n\t\t\t\tif (recoveringTransaction >= initialTransaction)\n\t\t\t\t\tsubscriber.receive(entry.transaction(), entry.timestamp());\n\t\t\n\t\t\t\trecoveringTransaction++;\n\t\t\n\t\t\t} catch (EOFException eof) {\n\t\t\t\tFile nextFile = journalFile(recoveringTransaction);\n\t\t\t\tif (logFile.equals(nextFile)) renameUnusedFile(logFile);  //The first transaction in this log file is incomplete. We need to reuse this file name.\n\t\t\t\tlogFile = nextFile;\n\t\t\t\tif (!logFile.exists()) break;\n\t\t\t\tinputLog = new SimpleInputStream(logFile, _loader, _monitor);\n\t\t\t}\n\t\t}\n\t\treturn recoveringTransaction;\n\t}\n\n\n\tprivate void renameUnusedFile(File journalFile) {\n\t\tjournalFile.renameTo(new File(journalFile.getAbsolutePath() + \".unusedFile\" + System.currentTimeMillis()));\n\t}\n\n\n\t/** Implementing FileFilter. 0000000000000000000.transactionJournal is the format of the transaction journal filename. The long number (19 digits) is the number of the next transaction to be written at the moment the file is created. All transactions written to a file, therefore, have a sequence number greater or equal to the number in its filename.\n\t */\n\tpublic boolean accept(File file) {\n\t\tString name = file.getName();\n\t\tif (!name.endsWith(\".journal\")) return false;\n\t\tif (name.length() != 34) return false;\n\t\ttry { number(file); } catch (RuntimeException r) { return false; }\n\t\treturn true;\n\t}\n\n\tprivate File journalFile(long transaction) {\n\t\tString fileName = \"0000000000000000000\" + transaction;\n\t\tfileName = fileName.substring(fileName.length() - 19) + \".journal\";\n\t\treturn new File(_directory, fileName);\n\t}\n\n\tstatic private long number(File file) {\n\t\treturn Long.parseLong(file.getName().substring(0, 19));\n\t}\n\n\n\tprotected void handle(IOException iox, File journal, String action) {\n\t\tString message = \"All transaction processing is now blocked. An IOException was thrown while \" + action + \" a .journal file.\";\n\t    _monitor.notify(this.getClass(), message, journal, iox);\n\t\thang();\n\t}\n\n\tstatic private void hang() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(5000);\n\t\t\t} catch (InterruptedException ignored) {\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic void close() throws IOException {\n\t\tif (_outputJournal != null) _outputJournal.close();\n\t}\n\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Carlos Villela.\n\npackage org.prevayler.implementation.journal;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.util.Date;\n\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.DurableOutputStream;\nimport org.prevayler.foundation.FileManager;\nimport org.prevayler.foundation.SimpleInputStream;\nimport org.prevayler.foundation.StopWatch;\nimport org.prevayler.foundation.Turn;\nimport org.prevayler.foundation.serialization.JavaSerializationStrategy;\nimport org.prevayler.foundation.serialization.SerializationStrategy;\nimport org.prevayler.foundation.monitor.Monitor;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\n\n\n/** A Journal that will write all transactions to .journal files.\n */\npublic class PersistentJournal implements FileFilter, Journal {\n\n\tprivate final File _directory;\n\tprivate DurableOutputStream _outputJournal;\n\n\tprivate final long _journalSizeThresholdInBytes;\n\tprivate final long _journalAgeThresholdInMillis;\n\tprivate StopWatch _journalAgeTimer;\n\t\n\tprivate long _nextTransaction;\n\tprivate boolean _nextTransactionInitialized = false;\n\tprivate ClassLoader _loader;\n\tprivate Monitor _monitor;\n\n\n\t/**\n\t * @param directory Where transaction journal files will be read and written.\n\t * @param journalSizeThresholdInBytes Size of the current journal file beyond which it is closed and a new one started. Zero indicates no size threshold. This is useful journal backup purposes.\n\t * @param journalAgeThresholdInMillis Age of the current journal file beyond which it is closed and a new one started. Zero indicates no age threshold. This is useful journal backup purposes.\n\t */\n\tpublic PersistentJournal(String directory, long journalSizeThresholdInBytes, long journalAgeThresholdInMillis, ClassLoader loader, Monitor monitor) throws IOException {\n\t    _monitor = monitor;\n\t\t_loader = loader;\n\t\t_directory = FileManager.produceDirectory(directory);\n\t\t_journalSizeThresholdInBytes = journalSizeThresholdInBytes;\n\t\t_journalAgeThresholdInMillis = journalAgeThresholdInMillis;\n\t}\n\n\n\tpublic void append(Transaction transaction, Date executionTime, Turn myTurn) {\n\t\tif (!_nextTransactionInitialized) throw new IllegalStateException(\"Journal.update() has to be called at least once before Journal.append().\");\n\n\t\tDurableOutputStream myOutputJournal;\n\t\tDurableOutputStream outputJournalToClose = null;\n\t\t\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\tif (!isOutputJournalStillValid()) {\n\t\t\t\toutputJournalToClose = _outputJournal;\n\t\t\t\t_outputJournal = createOutputJournal(_nextTransaction);\n\t\t\t\t_journalAgeTimer = StopWatch.start();\n\t\t\t}\n\t\t\t_nextTransaction++;\n\t\t\tmyOutputJournal = _outputJournal;\n\t\t} finally {\n\t\t\tmyTurn.end();\n\t\t}\n\n\t\ttry {\n\t\t\tmyOutputJournal.sync(new TransactionTimestamp(transaction, executionTime), myTurn);\n\t\t} catch (IOException iox) {\n\t\t\thandle(iox, _outputJournal.file(), \"writing to\");\n\t\t}\n\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\ttry {\n\t\t\t\tif (outputJournalToClose != null) outputJournalToClose.close();\n\t\t\t} catch (IOException iox) {\n\t\t\t\thandle(iox, outputJournalToClose.file(), \"closing\");\n\t\t\t}\n\t\t} finally {\n\t\t\tmyTurn.end();\n\t\t}\n\t\t\n\t}\n\n\n\tprivate boolean isOutputJournalStillValid() {\n\t\treturn _outputJournal != null\n\t\t\t&& !isOutputJournalTooBig() \n\t\t\t&& !isOutputJournalTooOld();\n\t}\n\n\n\tprivate boolean isOutputJournalTooOld() {\n\t\treturn _journalAgeThresholdInMillis != 0\n\t\t\t&& _journalAgeTimer.millisEllapsed() >= _journalAgeThresholdInMillis;\n\t}\n\n\n\tprivate boolean isOutputJournalTooBig() {\n\t\treturn _journalSizeThresholdInBytes != 0\n\t\t\t&& _outputJournal.file().length() >= _journalSizeThresholdInBytes;\n\t}\n\n\n\tprivate DurableOutputStream createOutputJournal(long transactionNumber) {\n\t\tFile file = journalFile(transactionNumber);\n\t\ttry {\n\t\t\treturn new DurableOutputStream(file);\n\t\t} catch (IOException iox) {\n\t\t\thandle(iox, file, \"creating\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/** IMPORTANT: This method cannot be called while the log() method is being called in another thread.\n\t * If there are no journal files in the directory (when a snapshot is taken and all journal files are manually deleted, for example), the initialTransaction parameter in the first call to this method will define what the next transaction number will be. We have to find clearer/simpler semantics.\n\t */\n\tpublic void update(TransactionSubscriber subscriber, long initialTransactionWanted) throws IOException, ClassNotFoundException {\n\t\tlong initialLogFile = findInitialJournalFile(initialTransactionWanted);\n\t\t\n\t\tif (initialLogFile == 0) {\n\t\t\tinitializeNextTransaction(initialTransactionWanted, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tlong nextTransaction = recoverPendingTransactions(subscriber, initialTransactionWanted, initialLogFile);\n\t\t\n\t\tinitializeNextTransaction(initialTransactionWanted, nextTransaction);\n\t}\n\n\n\tprivate long findInitialJournalFile(long initialTransactionWanted) {\n\t\tlong initialFileCandidate = initialTransactionWanted;\n\t\twhile (initialFileCandidate != 0) {   //TODO Optimize.\n\t\t\tif (journalFile(initialFileCandidate).exists()) break;\n\t\t\tinitialFileCandidate--;\n\t\t}\n\t\treturn initialFileCandidate;\n\t}\n\n\n\tprivate void initializeNextTransaction(long initialTransactionWanted, long nextTransaction) throws IOException {\n\t\tif (_nextTransactionInitialized) {\n\t\t\tif (_nextTransaction < initialTransactionWanted) throw new IOException(\"The transaction log has not yet reached transaction \" + initialTransactionWanted + \". The last logged transaction was \" + (_nextTransaction - 1) + \".\");\n\t\t\tif (nextTransaction < _nextTransaction) throw new IOException(\"Unable to find journal file containing transaction \" + nextTransaction + \". Might have been manually deleted.\");\n\t\t\tif (nextTransaction > _nextTransaction) throw new IllegalStateException();\n\t\t\treturn;\n\t\t}\n\t\t_nextTransactionInitialized = true;\n\t\t_nextTransaction = initialTransactionWanted > nextTransaction\n\t\t\t? initialTransactionWanted\n\t\t\t: nextTransaction;\n\t}\n\n\n\tprivate long recoverPendingTransactions(TransactionSubscriber subscriber, long initialTransaction, long initialLogFile)\tthrows IOException, ClassNotFoundException {\n\t\tSerializationStrategy strategy = new JavaSerializationStrategy(_loader);\n\n\t\tlong recoveringTransaction = initialLogFile;\n\t\tFile logFile = journalFile(recoveringTransaction);\n\t\tSimpleInputStream inputLog = new SimpleInputStream(logFile, strategy, _monitor);\n\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tTransactionTimestamp entry = (TransactionTimestamp)inputLog.readObject();\n\t\t\n\t\t\t\tif (recoveringTransaction >= initialTransaction)\n\t\t\t\t\tsubscriber.receive(entry.transaction(), entry.timestamp());\n\t\t\n\t\t\t\trecoveringTransaction++;\n\t\t\n\t\t\t} catch (EOFException eof) {\n\t\t\t\tFile nextFile = journalFile(recoveringTransaction);\n\t\t\t\tif (logFile.equals(nextFile)) renameUnusedFile(logFile);  //The first transaction in this log file is incomplete. We need to reuse this file name.\n\t\t\t\tlogFile = nextFile;\n\t\t\t\tif (!logFile.exists()) break;\n\t\t\t\tinputLog = new SimpleInputStream(logFile, strategy, _monitor);\n\t\t\t}\n\t\t}\n\t\treturn recoveringTransaction;\n\t}\n\n\n\tprivate void renameUnusedFile(File journalFile) {\n\t\tjournalFile.renameTo(new File(journalFile.getAbsolutePath() + \".unusedFile\" + System.currentTimeMillis()));\n\t}\n\n\n\t/** Implementing FileFilter. 0000000000000000000.transactionJournal is the format of the transaction journal filename. The long number (19 digits) is the number of the next transaction to be written at the moment the file is created. All transactions written to a file, therefore, have a sequence number greater or equal to the number in its filename.\n\t */\n\tpublic boolean accept(File file) {\n\t\tString name = file.getName();\n\t\tif (!name.endsWith(\".journal\")) return false;\n\t\tif (name.length() != 34) return false;\n\t\ttry { number(file); } catch (RuntimeException r) { return false; }\n\t\treturn true;\n\t}\n\n\tprivate File journalFile(long transaction) {\n\t\tString fileName = \"0000000000000000000\" + transaction;\n\t\tfileName = fileName.substring(fileName.length() - 19) + \".journal\";\n\t\treturn new File(_directory, fileName);\n\t}\n\n\tstatic private long number(File file) {\n\t\treturn Long.parseLong(file.getName().substring(0, 19));\n\t}\n\n\n\tprotected void handle(IOException iox, File journal, String action) {\n\t\tString message = \"All transaction processing is now blocked. An IOException was thrown while \" + action + \" a .journal file.\";\n\t    _monitor.notify(this.getClass(), message, journal, iox);\n\t\thang();\n\t}\n\n\tstatic private void hang() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(5000);\n\t\t\t} catch (InterruptedException ignored) {\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic void close() throws IOException {\n\t\tif (_outputJournal != null) _outputJournal.close();\n\t}\n\n}\n","lineNo":169}
{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Carlos Villela.\n\npackage org.prevayler.implementation.journal;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.util.Date;\n\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.DurableOutputStream;\nimport org.prevayler.foundation.FileManager;\nimport org.prevayler.foundation.SimpleInputStream;\nimport org.prevayler.foundation.StopWatch;\nimport org.prevayler.foundation.Turn;\nimport org.prevayler.foundation.monitor.Monitor;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\n\n\n/** A Journal that will write all transactions to .journal files.\n */\npublic class PersistentJournal implements FileFilter, Journal {\n\n\tprivate final File _directory;\n\tprivate DurableOutputStream _outputJournal;\n\n\tprivate final long _journalSizeThresholdInBytes;\n\tprivate final long _journalAgeThresholdInMillis;\n\tprivate StopWatch _journalAgeTimer;\n\t\n\tprivate long _nextTransaction;\n\tprivate final Object _nextTransactionMonitor = new Object();\n\tprivate boolean _nextTransactionInitialized = false;\n\tprivate ClassLoader _loader;\n\tprivate Monitor _monitor;\n\n\n\t/**\n\t * @param directory Where transaction journal files will be read and written.\n\t * @param journalSizeThresholdInBytes Size of the current journal file beyond which it is closed and a new one started. Zero indicates no size threshold. This is useful journal backup purposes.\n\t * @param journalAgeThresholdInMillis Age of the current journal file beyond which it is closed and a new one started. Zero indicates no age threshold. This is useful journal backup purposes.\n\t */\n\tpublic PersistentJournal(String directory, long journalSizeThresholdInBytes, long journalAgeThresholdInMillis, ClassLoader loader, Monitor monitor) throws IOException {\n\t    _monitor = monitor;\n\t\t_loader = loader;\n\t\t_directory = FileManager.produceDirectory(directory);\n\t\t_journalSizeThresholdInBytes = journalSizeThresholdInBytes;\n\t\t_journalAgeThresholdInMillis = journalAgeThresholdInMillis;\n\t}\n\n\n\tpublic void append(Transaction transaction, Date executionTime, Turn myTurn) {\n\t\tif (!_nextTransactionInitialized) throw new IllegalStateException(\"Journal.update() has to be called at least once before Journal.append().\");\n\n\t\tprepareOutputJournal();\n\t\ttry {\n\t\t\t_outputJournal.sync(new TransactionTimestamp(transaction, executionTime), myTurn);\n\t\t} catch (IOException iox) {\n\t\t\thandle(iox, _outputJournal.file(), \"writing to\");\n\t\t}\n\t}\n\n\n\tprivate void prepareOutputJournal() {\n\t\tsynchronized (_nextTransactionMonitor) {\n\t\t\tif (!isOutputJournalValid()) createNewOutputJournal(_nextTransaction);\n\t\t\t_nextTransaction++;  //The transaction count is increased but, because of thread concurrency, it is not guaranteed that this thread will journal the _nextTransaction'th transaction, so don't trust that. It is myTurn that will guarantee execution in the correct order.\n\t\t}\n\t}\n\n\n\tprivate boolean isOutputJournalValid() {\n\t\treturn _outputJournal != null\n\t\t\t&& !isOutputJournalTooBig() \n\t\t\t&& !isOutputJournalTooOld();\n\t}\n\n\n\tprivate boolean isOutputJournalTooOld() {\n\t\treturn _journalAgeThresholdInMillis != 0\n\t\t\t&& _journalAgeTimer.millisEllapsed() >= _journalAgeThresholdInMillis;\n\t}\n\n\n\tprivate boolean isOutputJournalTooBig() {\n\t\treturn _journalSizeThresholdInBytes != 0\n\t\t\t&& _outputJournal.file().length() >= _journalSizeThresholdInBytes;\n\t}\n\n\n\tprivate void createNewOutputJournal(long transactionNumber) {\n\t\tFile file = journalFile(transactionNumber);\n\t\ttry {\n\t\t\tcloseOutputJournal();\n\t\t\t_outputJournal = new DurableOutputStream(file);\n\t\t\t_journalAgeTimer = StopWatch.start();\n\t\t} catch (IOException iox) {\n\t\t\thandle(iox, file, \"creating\");\n\t\t}\n\t}\n\n\n\tprivate void closeOutputJournal() throws IOException {\n\t\tif (_outputJournal != null) _outputJournal.close();\n\t}\n\n\n\t/** IMPORTANT: This method cannot be called while the log() method is being called in another thread.\n\t * If there are no journal files in the directory (when a snapshot is taken and all journal files are manually deleted, for example), the initialTransaction parameter in the first call to this method will define what the next transaction number will be. We have to find clearer/simpler semantics.\n\t */\n\tpublic void update(TransactionSubscriber subscriber, long initialTransactionWanted) throws IOException, ClassNotFoundException {\n\t\tlong initialLogFile = findInitialJournalFile(initialTransactionWanted);\n\t\t\n\t\tif (initialLogFile == 0) {\n\t\t\tinitializeNextTransaction(initialTransactionWanted, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tlong nextTransaction = recoverPendingTransactions(subscriber, initialTransactionWanted, initialLogFile);\n\t\t\n\t\tinitializeNextTransaction(initialTransactionWanted, nextTransaction);\n\t}\n\n\n\tprivate long findInitialJournalFile(long initialTransactionWanted) {\n\t\tlong initialFileCandidate = initialTransactionWanted;\n\t\twhile (initialFileCandidate != 0) {   //TODO Optimize.\n\t\t\tif (journalFile(initialFileCandidate).exists()) break;\n\t\t\tinitialFileCandidate--;\n\t\t}\n\t\treturn initialFileCandidate;\n\t}\n\n\n\tprivate void initializeNextTransaction(long initialTransactionWanted, long nextTransaction) throws IOException {\n\t\tif (_nextTransactionInitialized) {\n\t\t\tif (_nextTransaction < initialTransactionWanted) throw new IOException(\"The transaction log has not yet reached transaction \" + initialTransactionWanted + \". The last logged transaction was \" + (_nextTransaction - 1) + \".\");\n\t\t\tif (nextTransaction < _nextTransaction) throw new IOException(\"Unable to find journal file containing transaction \" + nextTransaction + \". Might have been manually deleted.\");\n\t\t\tif (nextTransaction > _nextTransaction) throw new IllegalStateException();\n\t\t\treturn;\n\t\t}\n\t\t_nextTransactionInitialized = true;\n\t\t_nextTransaction = initialTransactionWanted > nextTransaction\n\t\t\t? initialTransactionWanted\n\t\t\t: nextTransaction;\n\t}\n\n\n\tprivate long recoverPendingTransactions(TransactionSubscriber subscriber, long initialTransaction, long initialLogFile)\tthrows IOException, ClassNotFoundException {\n\t\tlong recoveringTransaction = initialLogFile;\n\t\tFile logFile = journalFile(recoveringTransaction);\n\t\tSimpleInputStream inputLog = new SimpleInputStream(logFile, _loader, _monitor);\n\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tTransactionTimestamp entry = (TransactionTimestamp)inputLog.readObject();\n\t\t\n\t\t\t\tif (recoveringTransaction >= initialTransaction)\n\t\t\t\t\tsubscriber.receive(entry.transaction(), entry.timestamp());\n\t\t\n\t\t\t\trecoveringTransaction++;\n\t\t\n\t\t\t} catch (EOFException eof) {\n\t\t\t\tFile nextFile = journalFile(recoveringTransaction);\n\t\t\t\tif (logFile.equals(nextFile)) renameUnusedFile(logFile);  //The first transaction in this log file is incomplete. We need to reuse this file name.\n\t\t\t\tlogFile = nextFile;\n\t\t\t\tif (!logFile.exists()) break;\n\t\t\t\tinputLog = new SimpleInputStream(logFile, _loader, _monitor);\n\t\t\t}\n\t\t}\n\t\treturn recoveringTransaction;\n\t}\n\n\n\tprivate void renameUnusedFile(File journalFile) {\n\t\tjournalFile.renameTo(new File(journalFile.getAbsolutePath() + \".unusedFile\" + System.currentTimeMillis()));\n\t}\n\n\n\t/** Implementing FileFilter. 0000000000000000000.transactionJournal is the format of the transaction journal filename. The long number (19 digits) is the number of the next transaction to be written at the moment the file is created. All transactions written to a file, therefore, have a sequence number greater or equal to the number in its filename.\n\t */\n\tpublic boolean accept(File file) {\n\t\tString name = file.getName();\n\t\tif (!name.endsWith(\".journal\")) return false;\n\t\tif (name.length() != 34) return false;\n\t\ttry { number(file); } catch (RuntimeException r) { return false; }\n\t\treturn true;\n\t}\n\n\tprivate File journalFile(long transaction) {\n\t\tString fileName = \"0000000000000000000\" + transaction;\n\t\tfileName = fileName.substring(fileName.length() - 19) + \".journal\";\n\t\treturn new File(_directory, fileName);\n\t}\n\n\tstatic private long number(File file) {\n\t\treturn Long.parseLong(file.getName().substring(0, 19));\n\t}\n\n\n\tprotected void handle(IOException iox, File journal, String action) {\n\t\tString message = \"All transaction processing is now blocked. A problem was found while \" + action + \" a .journal file.\";\n\t    _monitor.notify(this.getClass(), message, journal, iox);\n\t\thang();\n\t}\n\n\tstatic private void hang() {\n\t\twhile (true) Thread.yield();\n\t}\n\n\n\tpublic void close() throws IOException {\n\t\tcloseOutputJournal();\n\t}\n\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2004 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Carlos Villela.\n\npackage org.prevayler.implementation.journal;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.util.Date;\n\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.DurableOutputStream;\nimport org.prevayler.foundation.FileManager;\nimport org.prevayler.foundation.SimpleInputStream;\nimport org.prevayler.foundation.StopWatch;\nimport org.prevayler.foundation.Turn;\nimport org.prevayler.foundation.monitor.Monitor;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\n\n\n/** A Journal that will write all transactions to .journal files.\n */\npublic class PersistentJournal implements FileFilter, Journal {\n\n\tprivate final File _directory;\n\tprivate DurableOutputStream _outputJournal;\n\n\tprivate final long _journalSizeThresholdInBytes;\n\tprivate final long _journalAgeThresholdInMillis;\n\tprivate StopWatch _journalAgeTimer;\n\t\n\tprivate long _nextTransaction;\n\tprivate boolean _nextTransactionInitialized = false;\n\tprivate ClassLoader _loader;\n\tprivate Monitor _monitor;\n\n\n\t/**\n\t * @param directory Where transaction journal files will be read and written.\n\t * @param journalSizeThresholdInBytes Size of the current journal file beyond which it is closed and a new one started. Zero indicates no size threshold. This is useful journal backup purposes.\n\t * @param journalAgeThresholdInMillis Age of the current journal file beyond which it is closed and a new one started. Zero indicates no age threshold. This is useful journal backup purposes.\n\t */\n\tpublic PersistentJournal(String directory, long journalSizeThresholdInBytes, long journalAgeThresholdInMillis, ClassLoader loader, Monitor monitor) throws IOException {\n\t    _monitor = monitor;\n\t\t_loader = loader;\n\t\t_directory = FileManager.produceDirectory(directory);\n\t\t_journalSizeThresholdInBytes = journalSizeThresholdInBytes;\n\t\t_journalAgeThresholdInMillis = journalAgeThresholdInMillis;\n\t}\n\n\n\tpublic void append(Transaction transaction, Date executionTime, Turn myTurn) {\n\t\tif (!_nextTransactionInitialized) throw new IllegalStateException(\"Journal.update() has to be called at least once before Journal.append().\");\n\n\t\tDurableOutputStream myOutputJournal;\n\t\tDurableOutputStream outputJournalToClose = null;\n\t\t\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\tif (!isOutputJournalStillValid()) {\n\t\t\t\toutputJournalToClose = _outputJournal;\n\t\t\t\t_outputJournal = createOutputJournal(_nextTransaction);\n\t\t\t\t_journalAgeTimer = StopWatch.start();\n\t\t\t}\n\t\t\t_nextTransaction++;\n\t\t\tmyOutputJournal = _outputJournal;\n\t\t} finally {\n\t\t\tmyTurn.end();\n\t\t}\n\n\t\ttry {\n\t\t\tmyOutputJournal.sync(new TransactionTimestamp(transaction, executionTime), myTurn);\n\t\t} catch (IOException iox) {\n\t\t\thandle(iox, _outputJournal.file(), \"writing to\");\n\t\t}\n\n\t\ttry {\n\t\t\tmyTurn.start();\n\t\t\ttry {\n\t\t\t\tif (outputJournalToClose != null) outputJournalToClose.close();\n\t\t\t} catch (IOException iox) {\n\t\t\t\thandle(iox, outputJournalToClose.file(), \"closing\");\n\t\t\t}\n\t\t} finally {\n\t\t\tmyTurn.end();\n\t\t}\n\t\t\n\t}\n\n\n\tprivate boolean isOutputJournalStillValid() {\n\t\treturn _outputJournal != null\n\t\t\t&& !isOutputJournalTooBig() \n\t\t\t&& !isOutputJournalTooOld();\n\t}\n\n\n\tprivate boolean isOutputJournalTooOld() {\n\t\treturn _journalAgeThresholdInMillis != 0\n\t\t\t&& _journalAgeTimer.millisEllapsed() >= _journalAgeThresholdInMillis;\n\t}\n\n\n\tprivate boolean isOutputJournalTooBig() {\n\t\treturn _journalSizeThresholdInBytes != 0\n\t\t\t&& _outputJournal.file().length() >= _journalSizeThresholdInBytes;\n\t}\n\n\n\tprivate DurableOutputStream createOutputJournal(long transactionNumber) {\n\t\tFile file = journalFile(transactionNumber);\n\t\ttry {\n\t\t\treturn new DurableOutputStream(file);\n\t\t} catch (IOException iox) {\n\t\t\thandle(iox, file, \"creating\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/** IMPORTANT: This method cannot be called while the log() method is being called in another thread.\n\t * If there are no journal files in the directory (when a snapshot is taken and all journal files are manually deleted, for example), the initialTransaction parameter in the first call to this method will define what the next transaction number will be. We have to find clearer/simpler semantics.\n\t */\n\tpublic void update(TransactionSubscriber subscriber, long initialTransactionWanted) throws IOException, ClassNotFoundException {\n\t\tlong initialLogFile = findInitialJournalFile(initialTransactionWanted);\n\t\t\n\t\tif (initialLogFile == 0) {\n\t\t\tinitializeNextTransaction(initialTransactionWanted, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tlong nextTransaction = recoverPendingTransactions(subscriber, initialTransactionWanted, initialLogFile);\n\t\t\n\t\tinitializeNextTransaction(initialTransactionWanted, nextTransaction);\n\t}\n\n\n\tprivate long findInitialJournalFile(long initialTransactionWanted) {\n\t\tlong initialFileCandidate = initialTransactionWanted;\n\t\twhile (initialFileCandidate != 0) {   //TODO Optimize.\n\t\t\tif (journalFile(initialFileCandidate).exists()) break;\n\t\t\tinitialFileCandidate--;\n\t\t}\n\t\treturn initialFileCandidate;\n\t}\n\n\n\tprivate void initializeNextTransaction(long initialTransactionWanted, long nextTransaction) throws IOException {\n\t\tif (_nextTransactionInitialized) {\n\t\t\tif (_nextTransaction < initialTransactionWanted) throw new IOException(\"The transaction log has not yet reached transaction \" + initialTransactionWanted + \". The last logged transaction was \" + (_nextTransaction - 1) + \".\");\n\t\t\tif (nextTransaction < _nextTransaction) throw new IOException(\"Unable to find journal file containing transaction \" + nextTransaction + \". Might have been manually deleted.\");\n\t\t\tif (nextTransaction > _nextTransaction) throw new IllegalStateException();\n\t\t\treturn;\n\t\t}\n\t\t_nextTransactionInitialized = true;\n\t\t_nextTransaction = initialTransactionWanted > nextTransaction\n\t\t\t? initialTransactionWanted\n\t\t\t: nextTransaction;\n\t}\n\n\n\tprivate long recoverPendingTransactions(TransactionSubscriber subscriber, long initialTransaction, long initialLogFile)\tthrows IOException, ClassNotFoundException {\n\t\tlong recoveringTransaction = initialLogFile;\n\t\tFile logFile = journalFile(recoveringTransaction);\n\t\tSimpleInputStream inputLog = new SimpleInputStream(logFile, _loader, _monitor);\n\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tTransactionTimestamp entry = (TransactionTimestamp)inputLog.readObject();\n\t\t\n\t\t\t\tif (recoveringTransaction >= initialTransaction)\n\t\t\t\t\tsubscriber.receive(entry.transaction(), entry.timestamp());\n\t\t\n\t\t\t\trecoveringTransaction++;\n\t\t\n\t\t\t} catch (EOFException eof) {\n\t\t\t\tFile nextFile = journalFile(recoveringTransaction);\n\t\t\t\tif (logFile.equals(nextFile)) renameUnusedFile(logFile);  //The first transaction in this log file is incomplete. We need to reuse this file name.\n\t\t\t\tlogFile = nextFile;\n\t\t\t\tif (!logFile.exists()) break;\n\t\t\t\tinputLog = new SimpleInputStream(logFile, _loader, _monitor);\n\t\t\t}\n\t\t}\n\t\treturn recoveringTransaction;\n\t}\n\n\n\tprivate void renameUnusedFile(File journalFile) {\n\t\tjournalFile.renameTo(new File(journalFile.getAbsolutePath() + \".unusedFile\" + System.currentTimeMillis()));\n\t}\n\n\n\t/** Implementing FileFilter. 0000000000000000000.transactionJournal is the format of the transaction journal filename. The long number (19 digits) is the number of the next transaction to be written at the moment the file is created. All transactions written to a file, therefore, have a sequence number greater or equal to the number in its filename.\n\t */\n\tpublic boolean accept(File file) {\n\t\tString name = file.getName();\n\t\tif (!name.endsWith(\".journal\")) return false;\n\t\tif (name.length() != 34) return false;\n\t\ttry { number(file); } catch (RuntimeException r) { return false; }\n\t\treturn true;\n\t}\n\n\tprivate File journalFile(long transaction) {\n\t\tString fileName = \"0000000000000000000\" + transaction;\n\t\tfileName = fileName.substring(fileName.length() - 19) + \".journal\";\n\t\treturn new File(_directory, fileName);\n\t}\n\n\tstatic private long number(File file) {\n\t\treturn Long.parseLong(file.getName().substring(0, 19));\n\t}\n\n\n\tprotected void handle(IOException iox, File journal, String action) {\n\t\tString message = \"All transaction processing is now blocked. An IOException was thrown while \" + action + \" a .journal file.\";\n\t    _monitor.notify(this.getClass(), message, journal, iox);\n\t\thang();\n\t}\n\n\tstatic private void hang() {\n\t\twhile (true) Thread.yield();\n\t}\n\n\n\tpublic void close() throws IOException {\n\t\tif (_outputJournal != null) _outputJournal.close();\n\t}\n\n}\n","lineNo":59}
{}
{}
{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation.logging;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.util.Date;\n\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.FileManager;\nimport org.prevayler.foundation.SimpleInputStream;\nimport org.prevayler.foundation.DurableOutputStream;\nimport org.prevayler.foundation.Turn;\nimport org.prevayler.implementation.*;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\n\n\n/** A TransactionLogger that will write all transactions to .transactionLog files.\n */\npublic class PersistentLogger implements FileFilter, TransactionLogger {\n\n\tprivate final File _directory;\n\tprivate DurableOutputStream _outputLog;\n\t\n\tprivate long _nextTransaction;\n\tprivate final Object _nextTransactionMonitor = new Object();\n\tprivate boolean _nextTransactionInitialized = false;\n\n\n\tpublic PersistentLogger(String directory, long logSizeThreshold, long logAgeThreshold) throws IOException, ClassNotFoundException {\n\t\t_directory = FileManager.produceDirectory(directory);\n\t}\n\n\n\tpublic void log(Transaction transaction, Date executionTime, Turn myTurn) {\n\t\tif (!_nextTransactionInitialized) throw new IllegalStateException(\"TransactionLogger.update() has to be called at least once before TransactionLogger.log().\");\n\n\t\tsynchronized (_nextTransactionMonitor) {\n\t\t\tif (_outputLog == null) createNewOutputLog(_nextTransaction);   //TODO Create new output log when size threshold surpassed or age expires.\n\t\t\t_nextTransaction++;  //The transaction count is increased but, because of thread concurrency, it is not guaranteed that this transaction is the _nextTransaction'th transaction, so don't trust that. It is myTurn that will guarantee execution in the correct order.\n\t\t}\n\t\ttry {\n\t\t\t_outputLog.sync(new TransactionTimestamp(transaction, executionTime), myTurn);\n\t\t} catch (IOException iox) {\n\t\t\thandleExceptionWhileWriting(iox, _outputLog.file());\n\t\t}\n\t}\n\n\n\tprivate void createNewOutputLog(long transactionNumber) {\n\t\tFile file = transactionLogFile(transactionNumber);\n\t\ttry {\n\t\t\t_outputLog = new DurableOutputStream(file);\n\t\t} catch (IOException iox) {\n\t\t\thandleExceptionWhileCreating(iox, file);\n\t\t}\n\t}\n\n\n\t/** IMPORTANT: This method cannot be called while the log() method is being called in another thread.\n\t * If there are no log files in the directory (when a snapshot is taken and all log files are manually deleted, for example), the initialTransaction parameter in the first call to this method will define what the next transaction number will be. We have to find clearer/simpler semantics.\n\t */\n\tpublic void update(TransactionSubscriber subscriber, long initialTransactionWanted) throws IOException, ClassNotFoundException {\n\t\tlong initialLogFile = findInitialLogFile(initialTransactionWanted);\n\t\t\n\t\tif (initialLogFile == 0) {\n\t\t\tinitializeNextTransaction(initialTransactionWanted, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tlong nextTransaction = recoverPendingTransactions(subscriber, initialTransactionWanted, initialLogFile);\n\t\t\n\t\tinitializeNextTransaction(initialTransactionWanted, nextTransaction);\n\t}\n\n\n\tprivate long findInitialLogFile(long initialTransactionWanted) {\n\t\tlong initialFileCandidate = initialTransactionWanted;\n\t\twhile (initialFileCandidate != 0) {   //TODO Optimize.\n\t\t\tif (transactionLogFile(initialFileCandidate).exists()) break;\n\t\t\tinitialFileCandidate--;\n\t\t}\n\t\treturn initialFileCandidate;\n\t}\n\n\n\tprivate void initializeNextTransaction(long initialTransactionWanted, long nextTransaction) throws IOException {\n\t\tif (_nextTransactionInitialized) {\n\t\t\tif (_nextTransaction < initialTransactionWanted) throw new IOException(\"The transaction log has not yet reached transaction \" + initialTransactionWanted + \". The last logged transaction was \" + (_nextTransaction - 1) + \".\");\n\t\t\tif (nextTransaction < _nextTransaction) throw new IOException(\"Unable to find transactionLog file containing transaction \" + nextTransaction + \". Might have been manually deleted.\");\n\t\t\tif (nextTransaction > _nextTransaction) throw new IllegalStateException();\n\t\t\treturn;\n\t\t}\n\t\t_nextTransactionInitialized = true;\n\t\t_nextTransaction = initialTransactionWanted > nextTransaction\n\t\t\t? initialTransactionWanted\n\t\t\t: nextTransaction;\n\t}\n\n\n\tprivate long recoverPendingTransactions(TransactionSubscriber subscriber, long initialTransaction, long initialLogFile)\tthrows IOException, ClassNotFoundException {\n\t\tlong recoveringTransaction = initialLogFile;\n\t\t\n\t\tSimpleInputStream inputLog = new SimpleInputStream(transactionLogFile(recoveringTransaction));\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tTransactionTimestamp entry = (TransactionTimestamp)inputLog.readObject();\n\t\t\n\t\t\t\tif (recoveringTransaction >= initialTransaction)\n\t\t\t\t\tsubscriber.receive(entry.transaction(), entry.timestamp());\n\t\t\n\t\t\t\trecoveringTransaction++;\n\t\t\n\t\t\t} catch (EOFException eof) {\n\t\t\t\tFile logFile = transactionLogFile(recoveringTransaction);\n\t\t\t\tif (!logFile.exists()) break;\n\t\t\t\tinputLog = new SimpleInputStream(logFile);\n\t\t\t}\n\t\t}\n\t\treturn recoveringTransaction;\n\t}\n\n\n\t/** Implementing FileFilter. 0000000000000000000.transactionLog is the format of the transaction log filename. The long number (19 digits) is the number of the next transaction to be written at the moment the file is created. All transactions written to a file, therefore, have a sequence number greater or equal to the number in its filename.\n\t */\n\tpublic boolean accept(File file) {\n\t\tString name = file.getName();\n\t\tif (!name.endsWith(\".transactionLog\")) return false;\n\t\tif (name.length() != 34) return false;\n\t\ttry { number(file); } catch (RuntimeException r) { return false; }\n\t\treturn true;\n\t}\n\n\tprivate File transactionLogFile(long transaction) {\n\t\tString fileName = \"0000000000000000000\" + transaction;\n\t\tfileName = fileName.substring(fileName.length() - 19) + \".transactionLog\";\n\t\treturn new File(_directory, fileName);\n\t}\n\n\tstatic private long number(File file) {\n\t\treturn Long.parseLong(file.getName().substring(0, 19));\n\t}\n\n\n\tprotected void handleExceptionWhileCreating(IOException iox, File logFile) {\n\t\thang(iox, \"\\nThe exception above was thrown while trying to create file \" + logFile + \" . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the PersistentLogger class and overriding the method called: handleExceptionWhileCreating(IOException iox, File logFile).\");\n\t}\n\n\n\tprotected void handleExceptionWhileWriting(IOException iox, File logFile) {\n\t\thang(iox, \"\\nThe exception above was thrown while trying to write to file \" + logFile + \" . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the PersistentLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile).\");\n\t}\n\n\n\tstatic private void hang(IOException iox, String message) {\n\t\tiox.printStackTrace();\n\t\tSystem.out.println(message);\n\t\twhile (true) Thread.yield();\n\t}\n\n\n\tpublic void close() throws IOException {\n\t\tif (_outputLog != null) _outputLog.close();\n\t}\n\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation.logging;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.util.Date;\n\nimport org.prevayler.Transaction;\nimport org.prevayler.foundation.FileManager;\nimport org.prevayler.foundation.SimpleInputStream;\nimport org.prevayler.foundation.DurableOutputStream;\nimport org.prevayler.foundation.StopWatch;\nimport org.prevayler.foundation.Turn;\nimport org.prevayler.implementation.*;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\n\n\n/** A TransactionLogger that will write all transactions to .transactionLog files.\n */\npublic class PersistentLogger implements FileFilter, TransactionLogger {\n\n\tprivate final File _directory;\n\tprivate DurableOutputStream _outputLog;\n\n\tprivate final long _logSizeThresholdInBytes;\n\tprivate final long _logAgeThresholdInMillis;\n\tprivate StopWatch _logAgeTimer;\n\t\n\tprivate long _nextTransaction;\n\tprivate final Object _nextTransactionMonitor = new Object();\n\tprivate boolean _nextTransactionInitialized = false;\n\n\n\t/**\n\t * @param directory Where transactionLog files will be read and written.\n\t * @param logSizeThresholdInBytes Size of the current transactionLog file beyond which it is closed and a new one started. Zero indicates no size threshold. This is useful transactionLog backup purposes.\n\t * @param logAgeThresholdInMillis Age of the current transactionLog file beyond which it is closed and a new one started. Zero indicates no age threshold. This is useful transactionLog backup purposes.\n\t */\n\tpublic PersistentLogger(String directory, long logSizeThresholdInBytes, long logAgeThresholdInMillis) throws IOException, ClassNotFoundException {\n\t\t_directory = FileManager.produceDirectory(directory);\n\t\t_logSizeThresholdInBytes = logSizeThresholdInBytes;\n\t\t_logAgeThresholdInMillis = logAgeThresholdInMillis;\n\t}\n\n\n\tpublic void log(Transaction transaction, Date executionTime, Turn myTurn) {\n\t\tif (!_nextTransactionInitialized) throw new IllegalStateException(\"TransactionLogger.update() has to be called at least once before TransactionLogger.log().\");\n\n\t\tprepareOutputLog();\n\t\ttry {\n\t\t\t_outputLog.sync(new TransactionTimestamp(transaction, executionTime), myTurn);\n\t\t} catch (IOException iox) {\n\t\t\thandleExceptionWhileWriting(iox, _outputLog.file());\n\t\t}\n\t}\n\n\n\tprivate void prepareOutputLog() {\n\t\tsynchronized (_nextTransactionMonitor) {\n\t\t\tif (!isOutputLogValid()) createNewOutputLog(_nextTransaction);   //TODO Create new output log when size threshold surpassed or age expires.\n\t\t\t_nextTransaction++;  //The transaction count is increased but, because of thread concurrency, it is not guaranteed that this transaction is the _nextTransaction'th transaction, so don't trust that. It is myTurn that will guarantee execution in the correct order.\n\t\t}\n\t}\n\n\n\tprivate boolean isOutputLogValid() {\n\t\treturn _outputLog != null\n\t\t\t&& !isOutputLogTooBig() \n\t\t\t&& !isOutputLogTooOld();\n\t}\n\n\n\tprivate boolean isOutputLogTooOld() {\n\t\treturn _logAgeThresholdInMillis != 0\n\t\t\t&& _logAgeTimer.millisEllapsed() >= _logAgeThresholdInMillis;\n\t}\n\n\n\tprivate boolean isOutputLogTooBig() {\n\t\treturn _logSizeThresholdInBytes != 0\n\t\t\t&& _outputLog.file().length() >= _logSizeThresholdInBytes;\n\t}\n\n\n\tprivate void createNewOutputLog(long transactionNumber) {\n\t\tFile file = transactionLogFile(transactionNumber);\n\t\ttry {\n\t\t\tif (_outputLog != null) _outputLog.close();\n\t\t\t_outputLog = new DurableOutputStream(file);\n\t\t\t_logAgeTimer = StopWatch.start();\n\t\t} catch (IOException iox) {\n\t\t\thandleExceptionWhileCreating(iox, file);\n\t\t}\n\t}\n\n\n\t/** IMPORTANT: This method cannot be called while the log() method is being called in another thread.\n\t * If there are no log files in the directory (when a snapshot is taken and all log files are manually deleted, for example), the initialTransaction parameter in the first call to this method will define what the next transaction number will be. We have to find clearer/simpler semantics.\n\t */\n\tpublic void update(TransactionSubscriber subscriber, long initialTransactionWanted) throws IOException, ClassNotFoundException {\n\t\tlong initialLogFile = findInitialLogFile(initialTransactionWanted);\n\t\t\n\t\tif (initialLogFile == 0) {\n\t\t\tinitializeNextTransaction(initialTransactionWanted, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tlong nextTransaction = recoverPendingTransactions(subscriber, initialTransactionWanted, initialLogFile);\n\t\t\n\t\tinitializeNextTransaction(initialTransactionWanted, nextTransaction);\n\t}\n\n\n\tprivate long findInitialLogFile(long initialTransactionWanted) {\n\t\tlong initialFileCandidate = initialTransactionWanted;\n\t\twhile (initialFileCandidate != 0) {   //TODO Optimize.\n\t\t\tif (transactionLogFile(initialFileCandidate).exists()) break;\n\t\t\tinitialFileCandidate--;\n\t\t}\n\t\treturn initialFileCandidate;\n\t}\n\n\n\tprivate void initializeNextTransaction(long initialTransactionWanted, long nextTransaction) throws IOException {\n\t\tif (_nextTransactionInitialized) {\n\t\t\tif (_nextTransaction < initialTransactionWanted) throw new IOException(\"The transaction log has not yet reached transaction \" + initialTransactionWanted + \". The last logged transaction was \" + (_nextTransaction - 1) + \".\");\n\t\t\tif (nextTransaction < _nextTransaction) throw new IOException(\"Unable to find transactionLog file containing transaction \" + nextTransaction + \". Might have been manually deleted.\");\n\t\t\tif (nextTransaction > _nextTransaction) throw new IllegalStateException();\n\t\t\treturn;\n\t\t}\n\t\t_nextTransactionInitialized = true;\n\t\t_nextTransaction = initialTransactionWanted > nextTransaction\n\t\t\t? initialTransactionWanted\n\t\t\t: nextTransaction;\n\t}\n\n\n\tprivate long recoverPendingTransactions(TransactionSubscriber subscriber, long initialTransaction, long initialLogFile)\tthrows IOException, ClassNotFoundException {\n\t\tlong recoveringTransaction = initialLogFile;\n\t\tFile logFile = transactionLogFile(recoveringTransaction);\n\t\tSimpleInputStream inputLog = new SimpleInputStream(logFile);\n\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tTransactionTimestamp entry = (TransactionTimestamp)inputLog.readObject();\n\t\t\n\t\t\t\tif (recoveringTransaction >= initialTransaction)\n\t\t\t\t\tsubscriber.receive(entry.transaction(), entry.timestamp());\n\t\t\n\t\t\t\trecoveringTransaction++;\n\t\t\n\t\t\t} catch (EOFException eof) {\n\t\t\t\tFile nextFile = transactionLogFile(recoveringTransaction);\n\t\t\t\tif (logFile.equals(nextFile)) renameUnusedFile(logFile);  //The first transaction in this log file is incomplete. We need to reuse this file name.\n\t\t\t\tlogFile = nextFile;\n\t\t\t\tif (!logFile.exists()) break;\n\t\t\t\tinputLog = new SimpleInputStream(logFile);\n\t\t\t}\n\t\t}\n\t\treturn recoveringTransaction;\n\t}\n\n\n\tprivate void renameUnusedFile(File logFile) {\n\t\tlogFile.renameTo(new File(logFile.getAbsolutePath() + \".unusedFile\" + System.currentTimeMillis()));\n\t}\n\n\n\t/** Implementing FileFilter. 0000000000000000000.transactionLog is the format of the transaction log filename. The long number (19 digits) is the number of the next transaction to be written at the moment the file is created. All transactions written to a file, therefore, have a sequence number greater or equal to the number in its filename.\n\t */\n\tpublic boolean accept(File file) {\n\t\tString name = file.getName();\n\t\tif (!name.endsWith(\".transactionLog\")) return false;\n\t\tif (name.length() != 34) return false;\n\t\ttry { number(file); } catch (RuntimeException r) { return false; }\n\t\treturn true;\n\t}\n\n\tprivate File transactionLogFile(long transaction) {\n\t\tString fileName = \"0000000000000000000\" + transaction;\n\t\tfileName = fileName.substring(fileName.length() - 19) + \".transactionLog\";\n\t\treturn new File(_directory, fileName);\n\t}\n\n\tstatic private long number(File file) {\n\t\treturn Long.parseLong(file.getName().substring(0, 19));\n\t}\n\n\n\tprotected void handleExceptionWhileCreating(IOException iox, File logFile) {\n\t\thang(iox, \"\\nThe exception above was thrown while trying to create file \" + logFile + \" . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the PersistentLogger class and overriding the method called: handleExceptionWhileCreating(IOException iox, File logFile).\");\n\t}\n\n\n\tprotected void handleExceptionWhileWriting(IOException iox, File logFile) {\n\t\thang(iox, \"\\nThe exception above was thrown while trying to write to file \" + logFile + \" . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the PersistentLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile).\");\n\t}\n\n\n\tstatic private void hang(IOException iox, String message) {\n\t\tiox.printStackTrace();\n\t\tSystem.out.println(message);\n\t\twhile (true) Thread.yield();\n\t}\n\n\n\tpublic void close() throws IOException {\n\t\tif (_outputLog != null) _outputLog.close();\n\t}\n\n}\n","lineNo":145}
{"Smelly Sample":"// Prevayler(TM) - The Open-Source Prevalence Layer.\n// Copyright (C) 2001-2003 Klaus Wuestefeld.\n// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\npackage org.prevayler.implementation;\n\nimport java.io.IOException;\nimport java.util.Date;\n\nimport org.prevayler.Clock;\nimport org.prevayler.Prevayler;\nimport org.prevayler.Query;\nimport org.prevayler.Transaction;\nimport org.prevayler.TransactionWithQuery;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\nimport org.prevayler.implementation.snapshot.SnapshotManager;\n\n\npublic class PrevaylerImpl implements Prevayler {\n\n\tprivate final Object _prevalentSystem;\n\tprivate long _systemVersion = 0;\n\n\tprivate final Clock _clock;\n\n\tprivate final SnapshotManager _snapshotManager;\n\n\tprivate final TransactionPublisher _publisher;\n\tprivate boolean _ignoreRuntimeExceptions;\n\n\n\t/** Creates a new Prevayler\n\t * @param snapshotManager The SnapshotManager that will be used for reading and writing snapshot files.\n\t * @param transactionPublisher The TransactionPublisher that will be used for publishing transactions executed with this PrevaylerImpl.\n\t */\n\tpublic PrevaylerImpl(SnapshotManager snapshotManager, TransactionPublisher transactionPublisher) throws IOException, ClassNotFoundException {\n\t\t_snapshotManager = snapshotManager;\n\t\t_prevalentSystem = _snapshotManager.recoveredPrevalentSystem();\n\t\t_systemVersion = _snapshotManager.recoveredVersion();\n\n\t\t_publisher = transactionPublisher;\n\t\t_clock = _publisher.clock();\n\n\t\t_ignoreRuntimeExceptions = true;     //During pending transaction recovery (rolling forward), RuntimeExceptions are ignored because they were already thrown and handled during the first transaction execution.\n\t\t_publisher.addSubscriber(subscriber(), _systemVersion + 1);\n\t\t_ignoreRuntimeExceptions = false;\n\t}\n\n\n\tpublic Object prevalentSystem() { return _prevalentSystem; }\n\n\n\tpublic Clock clock() { return _clock; }\n\n\n\tpublic void execute(Transaction transaction) { _publisher.publish(transaction); }\n\n\n\tpublic Object execute(Query query) throws Exception {\n\t\tsynchronized (_prevalentSystem) {\n\t\t\treturn query.query(_prevalentSystem, clock().time());\n\t\t}\n\t}\n\n\n\tpublic Object execute(TransactionWithQuery transactionWithQuery) throws Exception {\n\t\tTransactionWithQueryExecuter executer = new TransactionWithQueryExecuter(transactionWithQuery);\n\t\texecute(executer);\n\t\treturn executer.result();\n\t}\n\n\n\tpublic void takeSnapshot() throws IOException {\n\t    synchronized (_prevalentSystem) {\n\t        _snapshotManager.writeSnapshot(_prevalentSystem, _systemVersion);\n\t    }\n\t}\n\n\n\tprivate TransactionSubscriber subscriber() {\n\t\treturn new TransactionSubscriber() {\n\t\n\t\t\tpublic void receive(Transaction transaction, Date executionTime) {\n\t\t\t\tsynchronized (_prevalentSystem) {\n\t\t\t\t\t_systemVersion++;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttransaction.executeOn(_prevalentSystem, executionTime);\n\t\t\t\t\t} catch (RuntimeException rx) {\n\t\t\t\t\t\tif (!_ignoreRuntimeExceptions) throw rx;\n\t\t\t\t\t\trx.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t};\n\t}\n\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation;\n\nimport java.io.IOException;\nimport java.util.Date;\n\nimport org.prevayler.Clock;\nimport org.prevayler.Prevayler;\nimport org.prevayler.Query;\nimport org.prevayler.Transaction;\nimport org.prevayler.TransactionWithQuery;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\nimport org.prevayler.implementation.snapshot.SnapshotManager;\n\n\npublic class PrevaylerImpl implements Prevayler {\n\n\tprivate final Object _prevalentSystem;\n\tprivate long _systemVersion = 0;\n\n\tprivate final Clock _clock;\n\n\tprivate final SnapshotManager _snapshotManager;\n\n\tprivate final TransactionPublisher _publisher;\n\tprivate boolean _ignoreRuntimeExceptions;\n\n\n\t/** Creates a new Prevayler\n\t * @param snapshotManager The SnapshotManager that will be used for reading and writing snapshot files.\n\t * @param transactionPublisher The TransactionPublisher that will be used for publishing transactions executed with this PrevaylerImpl.\n\t */\n\tpublic PrevaylerImpl(SnapshotManager snapshotManager, TransactionPublisher transactionPublisher) throws IOException, ClassNotFoundException {\n\t\t_snapshotManager = snapshotManager;\n\t\t_prevalentSystem = _snapshotManager.recoveredPrevalentSystem();\n\t\t_systemVersion = _snapshotManager.recoveredVersion();\n\n\t\t_publisher = transactionPublisher;\n\t\t_clock = _publisher.clock();\n\n\t\t_ignoreRuntimeExceptions = true;     //During pending transaction recovery (rolling forward), RuntimeExceptions are ignored because they were already thrown and handled during the first transaction execution.\n\t\t_publisher.addSubscriber(subscriber(), _systemVersion + 1);\n\t\t_ignoreRuntimeExceptions = false;\n\t}\n\n\n\tpublic Object prevalentSystem() { return _prevalentSystem; }\n\n\n\tpublic Clock clock() { return _clock; }\n\n\n\tpublic void execute(Transaction transaction) {\n\t\tpublish((Transaction)deepCopy(transaction));\n\t}\n\n\n\tprivate void publish(Transaction transaction) {\n\t\t_publisher.publish(transaction);\n\t}\n\n\n\tpublic Object execute(Query sensitiveQuery) throws Exception {\n\t\tsynchronized (_prevalentSystem) {\n\t\t\treturn sensitiveQuery.query(_prevalentSystem, clock().time());\n\t\t}\n\t}\n\n\n\tpublic Object execute(TransactionWithQuery transactionWithQuery) throws Exception {\n\t\tTransactionWithQuery copy = (TransactionWithQuery)deepCopy(transactionWithQuery);\n\t\tTransactionWithQueryExecuter executer = new TransactionWithQueryExecuter(copy);\n\t\tpublish(executer);\n\t\treturn executer.result();\n\t}\n\n\n\tpublic void takeSnapshot() throws IOException {\n\t    synchronized (_prevalentSystem) {\n\t        _snapshotManager.writeSnapshot(_prevalentSystem, _systemVersion);\n\t    }\n\t}\n\n\n\tpublic void close() throws IOException { _publisher.close(); }\n\n\n\tprivate Object deepCopy(Object transaction) {   //TODO Optimizations: 1) Publish the byte array of the serialized transaction (this will save the Censor and the Logger from having to serialize the transaction again). This is also a step towards transaction multiplexing (useful to avoid hickups due to very large transactions). The Censor can use the actual given transaction if it is Immutable instead of deserializing a new one from the byte array. 2) Make the baptism fail-fast feature optional (default is on). If it is off, the given transaction can be used instead of deserializing a new one from the byte array.\n\t\treturn _snapshotManager.deepCopy(transaction, \"Unable to produce a deep copy of the transaction. Deep copies of transactions are executed instead of the transactions themselves so that the behaviour of the system during transaction execution is exactly the same as during transaction recovery from the log.\");\n\t}\n\n\n\tprivate TransactionSubscriber subscriber() {\n\t\treturn new TransactionSubscriber() {\n\t\n\t\t\tpublic void receive(Transaction transaction, Date executionTime) {\n\t\t\t\tsynchronized (_prevalentSystem) {\n\t\t\t\t\t_systemVersion++;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttransaction.executeOn(_prevalentSystem, executionTime);\n\t\t\t\t\t} catch (RuntimeException rx) {\n\t\t\t\t\t\tif (!_ignoreRuntimeExceptions) throw rx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t};\n\t}\n\n}\n","lineNo":75}
{"Smelly Sample":"package org.prevayler.implementation.publishing.censorship;\n\nimport org.prevayler.Transaction;\nimport org.prevayler.implementation.snapshot.*;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.util.Date;\n\npublic class StrictTransactionCensor implements TransactionCensor {\n\n\tprivate final Object _king;\n\tprivate Object _royalFoodTaster;\n\tprivate final SnapshotManager _snapshotManager;\n\n\n\tpublic StrictTransactionCensor(SnapshotManager snapshotManager) {\n\t\t_snapshotManager = snapshotManager;\n\t\t_king = _snapshotManager.recoveredPrevalentSystem();\n\t\t//The _royalFoodTaster cannot be initialized here, or else the pending transactions will not be applied to it.\n\t}\n\n\tpublic void approve(Transaction transaction, Date executionTime) throws RuntimeException, Error {\n\t\ttry {\n\t\t\ttransaction.executeOn(royalFoodTaster(), executionTime);\n\t\t} catch (RuntimeException rx) {\n\t\t\tletTheFoodTasterDie();\n\t\t\tthrow rx;\n\t\t} catch (Error error) {\n\t\t\tletTheFoodTasterDie();\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate void letTheFoodTasterDie() {\n\t\t_royalFoodTaster = null; // Producing the new food taster now could avoid the next transaction having to wait for its lazy evaluation. Trying to serialize the whole system in RAM right after an OutOfMemoryError has been thrown, for example, isn't a very good idea, though. In that case, there probably will not even be a next transaction...  ;)\n\t}\n\n\tprivate Object royalFoodTaster() {\n\t\tif (_royalFoodTaster == null) produceNewFoodTaster();\n\t\treturn _royalFoodTaster;\n\t}\n\n\tprivate void produceNewFoodTaster() {\n\t\ttry {\n\t\t\t// TODO Optimization: use some sort of producer-consumer stream so that serialization and deserialization can occur in parallel, avoiding the need for RAM for this array with the whole serialized system. \n\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\t\tsynchronized (_king) { _snapshotManager.writeSnapshot(_king, out); }\n\t\t\t_royalFoodTaster = _snapshotManager.readSnapshot(new ByteArrayInputStream(out.toByteArray()));\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tthrow new RuntimeException(\"Unable to produce a copy of the prevalent system for trying out transactions before applying them to the real system.\");\n\t\t}\n\t}\n\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n//Contributions: Jon Tirsn.\n\npackage org.prevayler.implementation.publishing.censorship;\n\nimport org.prevayler.Transaction;\nimport org.prevayler.implementation.snapshot.*;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.util.Date;\n\npublic class StrictTransactionCensor implements TransactionCensor {\n\n\tprivate final Object _king;\n\tprivate Object _royalFoodTaster;\n\tprivate final SnapshotManager _snapshotManager;\n\n\t\n\tpublic StrictTransactionCensor(SnapshotManager snapshotManager) {\n\t\t_snapshotManager = snapshotManager;\n\t\t_king = _snapshotManager.recoveredPrevalentSystem();\n\t\t//The _royalFoodTaster cannot be initialized here, or else the pending transactions will not be applied to it.\n\t}\n\n\tpublic void approve(Transaction transaction, Date executionTime) throws RuntimeException, Error {\n\t\ttry {\n\t\t\tTransaction transactionCopy = (Transaction)_snapshotManager.deepCopy(transaction, \"Unable to produce a copy of the transaction for trying out before applying it to the real system.\");\n\t\t\ttransactionCopy.executeOn(royalFoodTaster(), executionTime);\n\t\t} catch (RuntimeException rx) {\n\t\t\tletTheFoodTasterDie();\n\t\t\tthrow rx;\n\t\t} catch (Error error) {\n\t\t\tletTheFoodTasterDie();\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate void letTheFoodTasterDie() {\n\t\t_royalFoodTaster = null; // Producing the new food taster now could avoid the next transaction having to wait for its lazy evaluation. Trying to serialize the whole system in RAM right after an OutOfMemoryError has been thrown, for example, isn't a very good idea, though. In that case, there probably will not even be a next transaction...  ;)\n\t}\n\n\tprivate Object royalFoodTaster() {\n\t\tif (_royalFoodTaster == null) produceNewFoodTaster();\n\t\treturn _royalFoodTaster;\n\t}\n\n\tprivate void produceNewFoodTaster() {\n\t\ttry {\n\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\t\tsynchronized (_king) { _snapshotManager.writeSnapshot(_king, out); }\n\t\t\t_royalFoodTaster = _snapshotManager.readSnapshot(new ByteArrayInputStream(out.toByteArray()));\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tthrow new RuntimeException(\"Unable to produce a copy of the prevalent system for trying out transactions before applying them to the real system.\");\n\t\t}\n\t}\n\n}\n\n\n","lineNo":30}
{"Smelly Sample":"package org.prevayler.implementation;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.prevayler.Prevayler;\nimport org.prevayler.Transaction;\n\n\npublic class TransientPrevayler implements Prevayler {\n\n    private final Object prevalentSystem;\n\n\n    public TransientPrevayler(Object prevalentSystem) {\n        this.prevalentSystem = prevalentSystem;\n    }\n\n\tsynchronized public void execute(Transaction transaction) {\n\t\tserializeInMemory(transaction).executeOn(prevalentSystem);\n\t}\n\n\tpublic Object prevalentSystem() {\n        return prevalentSystem;\n    }\n\n\tstatic private Transaction serializeInMemory(Transaction transaction) {\n\t\tByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tnew ObjectOutputStream(buffer).writeObject(transaction);\n\t\t\tByteArrayInputStream input = new ByteArrayInputStream(buffer.toByteArray()); \n\t\t\treturn (Transaction)(new ObjectInputStream(input).readObject());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(\"Unexpected Exception. Serialization in memory should not fail.\");\n\t\t}\n\t}\n\n}\n","Method after Refactoring":"// Prevayler(TM) - The Open-Source Prevalence Layer.\n// Copyright (C) 2001-2003 Klaus Wuestefeld.\n// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\npackage org.prevayler.implementation;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.prevayler.Prevayler;\nimport org.prevayler.Transaction;\n\n\npublic class TransientPrevayler implements Prevayler {\n\n    private final Object _prevalentSystem;\n\n\n    public TransientPrevayler(Object prevalentSystem) {\n        _prevalentSystem = prevalentSystem;\n    }\n\n\tpublic Object prevalentSystem() {\n        return _prevalentSystem;\n    }\n\n\tpublic void execute(Transaction transaction) {\n\t\tTransaction copy = serializeInMemory(transaction);\n\t\tsynchronized (_prevalentSystem) {\n\t\t\tcopy.executeOn(_prevalentSystem);\n\t\t}\n\t}\n\n\n\tstatic private Transaction serializeInMemory(Transaction transaction) {\n\t\tByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tnew ObjectOutputStream(buffer).writeObject(transaction);\n\t\t\tByteArrayInputStream input = new ByteArrayInputStream(buffer.toByteArray()); \n\t\t\treturn (Transaction)(new ObjectInputStream(input).readObject());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(\"Unexpected Exception. Serialization in memory should not fail.\");\n\t\t}\n\t}\n\n}\n","lineNo":30}
{"Smelly Sample":"package org.prevayler.test;\n\nimport org.prevayler.implementation.RollbackPrevayler;\nimport junit.framework.TestCase;\n\nimport java.io.File;\n\npublic class RollbackTest extends TestCase {\n    static private RollbackPrevayler prevayler;\n    private static String prevaylerBase;\n\n    protected void setUp() throws Exception {\n        super.setUp();\n\n        File tempFile = File.createTempFile(\"Prevalence\", \"Base\");\n        tempFile.delete();\n        tempFile.mkdirs();\n        tempFile.deleteOnExit();\n        prevaylerBase = tempFile.getAbsolutePath();\n    }\n\n    protected void tearDown() throws Exception {\n        delete(prevaylerBase);\n    }\n\n    public void testRollback() throws Exception {\n\n        prevayler = new RollbackPrevayler(new AddingSystem(), prevaylerBase);\n        add(10, 10);\n        add(20, 30);\n        addRollback(30, 30);\n        add(30, 60);\n\n        prevayler = new RollbackPrevayler(new AddingSystem(), prevaylerBase);\n        assertEquals(60, system().total());\n        addRollback(30, 60);\n        add(10, 70);\n    }\n\n    private void addRollback(int value, int expectedTotal) throws Exception {\n    \tboolean isThrown = false;\n\t\ttry {\n\t        prevayler.execute(new RollbackAddition(value));\n\t\t} catch (RuntimeException e) {\n\t\t\tisThrown = true;\n\t\t}\n\t\tif (!isThrown) throw new RuntimeException(\"RuntimeException expected and not thrown.\");\n        assertEquals(expectedTotal, system().total());\n    }\n\n    private void add(long value, long expectedTotal) throws Exception {\n        prevayler.execute(new Addition(value));\n        assertEquals(expectedTotal, system().total());\n    }\n\n    private AddingSystem system() {\n        return (AddingSystem) prevayler.prevalentSystem();\n    }\n\n    public static void delete(String dir) {\n        delete(new File(dir));\n    }\n\n    public static void delete(File file) {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            if (files != null) {\n                for (int i = 0; i < files.length; i++) {\n                    File sub = files[i];\n                    delete(sub);\n                }\n            }\n        }\n        file.delete();\n    }\n}\n","Method after Refactoring":"package org.prevayler.test;\n\nimport org.prevayler.implementation.*;\nimport org.prevayler.implementation.log.TransactionLogger;\nimport junit.framework.TestCase;\n\nimport java.io.File;\n\npublic class RollbackTest extends TestCase {\n    static private SnapshotPrevayler prevayler;\n    private static String prevaylerBase;\n\n    protected void setUp() throws Exception {\n        super.setUp();\n\n        File tempFile = File.createTempFile(\"Prevalence\", \"Base\");\n        tempFile.delete();\n        tempFile.mkdirs();\n        tempFile.deleteOnExit();\n        prevaylerBase = tempFile.getAbsolutePath();\n    }\n\n    protected void tearDown() throws Exception {\n        delete(prevaylerBase);\n    }\n\n    public void testRollback() throws Exception {\n\n        SnapshotManager snapshotManager = new SnapshotManager(prevaylerBase);\n        TransactionLogger logger = new TransactionLogger(prevaylerBase);\n        RollbackTransactionPublisher publisher = new RollbackTransactionPublisher(snapshotManager, logger);\n        prevayler = new SnapshotPrevayler(new AddingSystem(), snapshotManager, publisher);\n        publisher.initKing(prevayler.prevalentSystem());\n        add(10, 10);\n        add(20, 30);\n        addRollback(30, 30);\n        add(30, 60);\n\n        prevayler = new RollbackPrevayler(new AddingSystem(), prevaylerBase);\n        assertEquals(60, system().total());\n        addRollback(30, 60);\n        add(10, 70);\n    }\n\n    private void addRollback(int value, int expectedTotal) throws Exception {\n    \tboolean isThrown = false;\n\t\ttry {\n\t        prevayler.execute(new RollbackAddition(value));\n\t\t} catch (RuntimeException e) {\n\t\t\tisThrown = true;\n\t\t}\n\t\tif (!isThrown) throw new RuntimeException(\"RuntimeException expected and not thrown.\");\n        assertEquals(expectedTotal, system().total());\n    }\n\n    private void add(long value, long expectedTotal) throws Exception {\n        prevayler.execute(new Addition(value));\n        assertEquals(expectedTotal, system().total());\n    }\n\n    private AddingSystem system() {\n        return (AddingSystem) prevayler.prevalentSystem();\n    }\n\n    public static void delete(String dir) {\n        delete(new File(dir));\n    }\n\n    public static void delete(File file) {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            if (files != null) {\n                for (int i = 0; i < files.length; i++) {\n                    File sub = files[i];\n                    delete(sub);\n                }\n            }\n        }\n        file.delete();\n    }\n}\n","lineNo":30}
{"Smelly Sample":"// Prevayler(TM) - The Open-Source Prevalence Layer.\n// Copyright (C) 2001 Klaus Wuestefeld.\n// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\npackage org.prevayler.implementation;\n\nimport org.prevayler.*;\nimport org.prevayler.util.StopWatch;\nimport java.io.*;\n\n\n/**\n * Serializes commands to commandLog files, along with their execution time and execution sequence number.\n * @see SnapshotPrevayler on the use of the org.prevayler.SafeCommandLogs, org.prevayler.CommandLogsThresholdBytes and org.prevayler.CommandLogsThresholdMinutes system properties.\n * @see CommandLogRecoverer\n */\nclass CommandLogger {\n\n  private final boolean safeCommandLogs = safeCommandLogsSystemProperty();\n  private final long commandLogsThresholdBytes = parseSystemProperty(\"org.prevayler.CommandLogsThresholdBytes\");\n  private final long commandLogsThresholdMillis = 1000 * 60 * parseSystemProperty(\"org.prevayler.CommandLogsThresholdMinutes\");\n\n  private final File logFile;\n  private final FileOutputStream fileOutputStream;\n  private final ObjectOutputStream objectOutputStream;\n\n  private long executionTime;\n  private long executionSequence;\n\n  private final StopWatch stopWatch = StopWatch.start();\n\n\n  CommandLogger(File logFile, boolean sequenceRestarted) throws IOException {\n    this.logFile = logFile;\n    fileOutputStream = new FileOutputStream(logFile);\n    objectOutputStream = new ObjectOutputStream(fileOutputStream);\n\n    objectOutputStream.writeChar(sequenceRestarted ? 'R' : 'C');   //R - Restart. C - Continue.\n    flushStreams(true);\n  }\n\n\n  void writeCommand(Command command) throws IOException {\n    objectOutputStream.writeObject(command);\n  }\n\n\n  void executionSequence (long executionTime, long executionSequence) {\n    this.executionTime = executionTime;\n    this.executionSequence = executionSequence;\n  }\n\n\n  void flushToDisk() throws IOException {\n    objectOutputStream.writeLong(executionTime);\n    objectOutputStream.writeLong(executionSequence);\n\n    flushStreams(safeCommandLogs);\n  }\n\n\n  private void flushStreams(boolean sync) throws IOException {\n    objectOutputStream.flush();\n    if (sync) fileOutputStream.getFD().sync();\n  }\n\n\n  boolean isValid() {\n    return !isExpired() && !isFull();\n  }\n\n  private boolean isExpired() {\n    if (commandLogsThresholdMillis == 0) return false;\n    return stopWatch.millisEllapsed() >= commandLogsThresholdMillis;\n  }\n\n  private boolean isFull() {\n    if (commandLogsThresholdBytes == 0) return false;\n    return logFile.length() >= commandLogsThresholdBytes;\n  }\n\n\n  void close() throws IOException {\n    objectOutputStream.close();\n  }\n\n\n  File directory() {\n    return logFile.getParentFile();\n  }\n\n\n  static private long parseSystemProperty(String propertyName) {\n    try {\n      return Long.parseLong(System.getProperty(propertyName));\n    } catch (NumberFormatException nfx) {\n      return 0;\n    }\n  }\n\n  static private boolean safeCommandLogsSystemProperty() {\n    boolean safe = !\"off\".equalsIgnoreCase(System.getProperty(\"org.prevayler.SafeCommandLogs\"));\n    safeCommandLogsMessage(safe);\n    return safe;\n  }\n\n  static private void safeCommandLogsMessage(boolean safe) {\n    if (!safe && lastTimeWasSafe) {\n      out(\"\\n=====================================\");\n      out(\"The org.prevayler.SafeCommandLogs system property is OFF.\");\n      out(\"Writes to the commandLog files will be cached for greater performance. In the event of a system crash, some of the last executed commands might be lost.\");\n      out(\"=====================================\\n\");\n    }\n    if (safe && !lastTimeWasSafe) {\n      out(\"\\n=====================================\");\n      out(\"The org.prevayler.SafeCommandLogs system property is ON.\");\n      out(\"Writes to the commandLog files will be flushed to the underlying device before each command is executed.\");\n      out(\"=====================================\\n\");\n    }\n    lastTimeWasSafe = safe;\n  }\n  static private boolean lastTimeWasSafe = true;\n\n\n  static private void out(Object message) {\n    System.out.println(message);\n  }\n}\n","Method after Refactoring":"// Prevayler(TM) - The Open-Source Prevalence Layer.\n// Copyright (C) 2001 Klaus Wuestefeld.\n// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\npackage org.prevayler.implementation;\n\nimport org.prevayler.*;\nimport org.prevayler.util.StopWatch;\nimport java.io.*;\n\n\n/**\n * Serializes commands to commandLog files, along with their execution time and execution sequence number.\n * @see SnapshotPrevayler on the use of the org.prevayler.SafeCommandLogs, org.prevayler.CommandLogsThresholdBytes and org.prevayler.CommandLogsThresholdMinutes system properties.\n * @see CommandLogRecoverer\n */\nclass CommandLogger {\n\n  private final boolean safeCommandLogs = safeCommandLogsSystemProperty();\n  private final long commandLogsThresholdBytes = parseSystemProperty(\"org.prevayler.CommandLogsThresholdBytes\");\n  private final long commandLogsThresholdMillis = 1000 * 60 * parseSystemProperty(\"org.prevayler.CommandLogsThresholdMinutes\");\n\n  private final File logFile;\n  private final FileOutputStream fileOutputStream;\n  private final ObjectOutputStream objectOutputStream;\n\n  private long executionTime;\n  private long executionSequence;\n\n  private final StopWatch stopWatch = StopWatch.start();\n\n\n  CommandLogger(File logFile, boolean sequenceRestarted) throws IOException {\n    this.logFile = logFile;\n    fileOutputStream = new FileOutputStream(logFile);\n    objectOutputStream = new ObjectOutputStream(fileOutputStream);\n\n    objectOutputStream.writeObject(new Character(sequenceRestarted ? 'R' : 'C'));   //R - Restart. C - Continue.\n    flushStreams(true);\n  }\n\n\n  void writeCommand(Command command) throws IOException {\n    objectOutputStream.writeObject(command);\n  }\n\n\n  void executionSequence (long executionTime, long executionSequence) {\n    this.executionTime = executionTime;\n    this.executionSequence = executionSequence;\n  }\n\n\n  void flushToDisk() throws IOException {\n    objectOutputStream.writeLong(executionTime);\n    objectOutputStream.writeLong(executionSequence);\n\n    flushStreams(safeCommandLogs);\n  }\n\n\n  private void flushStreams(boolean sync) throws IOException {\n    objectOutputStream.flush();\n    if (sync) fileOutputStream.getFD().sync();\n  }\n\n\n  boolean isValid() {\n    return !isExpired() && !isFull();\n  }\n\n  private boolean isExpired() {\n    if (commandLogsThresholdMillis == 0) return false;\n    return stopWatch.millisEllapsed() >= commandLogsThresholdMillis;\n  }\n\n  private boolean isFull() {\n    if (commandLogsThresholdBytes == 0) return false;\n    return logFile.length() >= commandLogsThresholdBytes;\n  }\n\n\n  void close() throws IOException {\n    objectOutputStream.close();\n  }\n\n\n  File directory() {\n    return logFile.getParentFile();\n  }\n\n\n  static private long parseSystemProperty(String propertyName) {\n  \tString property = System.getProperty(propertyName);\n  \tif (property == null) return 0;\n    try {\n      return Long.parseLong(property);\n    } catch (NumberFormatException nfx) {\n      return 0;\n    }\n  }\n\n  static private boolean safeCommandLogsSystemProperty() {\n    boolean safe = !\"off\".equalsIgnoreCase(System.getProperty(\"org.prevayler.SafeCommandLogs\"));\n    safeCommandLogsMessage(safe);\n    return safe;\n  }\n\n  static private void safeCommandLogsMessage(boolean safe) {\n    if (!safe && lastTimeWasSafe) {\n      out(\"\\n=====================================\");\n      out(\"The org.prevayler.SafeCommandLogs system property is OFF.\");\n      out(\"Writes to the commandLog files will be cached for greater performance. In the event of a system crash, some of the last executed commands might be lost.\");\n      out(\"=====================================\\n\");\n    }\n    if (safe && !lastTimeWasSafe) {\n      out(\"\\n=====================================\");\n      out(\"The org.prevayler.SafeCommandLogs system property is ON.\");\n      out(\"Writes to the commandLog files will be flushed to the underlying device before each command is executed.\");\n      out(\"=====================================\\n\");\n    }\n    lastTimeWasSafe = safe;\n  }\n  static private boolean lastTimeWasSafe = true;\n\n\n  static private void out(Object message) {\n    System.out.println(message);\n  }\n}\n","lineNo":94}
{"Smelly Sample":"// Prevayler(TM) - The Open-Source Prevalence Layer.\n// Copyright (C) 2001 Klaus Wuestefeld.\n// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\npackage org.prevayler.test.scalability;\n\nimport java.util.*;\nimport java.text.DecimalFormat;\nimport org.prevayler.util.*;\n\n/** Represents a single run of a scalability test. To understand the implementation of this class, you must be familiar with Prevayler's Scalability Test (run org.prevayler.test.scalability.ScalabilityTest).\n*/\nabstract class ScalabilityTestRun {\n\n\tstatic private final long ROUND_DURATION_MILLIS = 1000 * 60;\n\n\tprivate ScalabilityTestSubject subject;\n\tprivate double bestRoundOperationsPerSecond;\n\tprivate int bestRoundThreads;\n\n\tprivate final List connectionCache = new LinkedList();\n\n\tprivate long operationCount = 0;\n\tprivate final Object roundMonitor = new Object();\n\tprivate boolean isRoundFinished;\n\tprivate int activeRoundThreads = 0;\n\n\n\t/** @return Example: \"123.12 operations/second (12 threads)\".\n\t*/\n\tpublic String getResult() {\n\t\treturn toResultString(bestRoundOperationsPerSecond, bestRoundThreads);\n\t}\n\n\n\tpublic double getOperationsPerSecond() {\n\t\treturn bestRoundOperationsPerSecond;\n\t}\n\n\n\tprotected ScalabilityTestRun(ScalabilityTestSubject subject, int minThreads, int maxThreads) {\n\t\tif (minThreads > maxThreads) throw new IllegalArgumentException(\"The minimum number of threads cannot be greater than the maximum number.\");\n\t\tif (minThreads < 1) throw new IllegalArgumentException(\"The minimum number of threads cannot be smaller than one.\");\n\n\t\tout(\"\\nRunning \" + name() + \" (Subject: \" + subject.name() + \").\");\n\n\t\tthis.subject = subject;\n\t\tsubject.replaceAllRecords(new RecordIterator());\n\n\t\tSystem.gc();\n\t\tout(\"Each round will take approx. \" + ROUND_DURATION_MILLIS / 1000 + \" seconds to run...\");\n\t\tperformTest(minThreads, maxThreads);\n\n\t\tout(\"BEST ROUND: \" + getResult());\n\t}\n\n\n\t/** @return The name of the test to be executed. Example: \"Prevayler Query Test\".\n\t*/\n\tprotected abstract String name();\n\n\n\tprivate void performTest(int minThreads, int maxThreads) {\n\n\t\tint threads = minThreads;\n\t\twhile (threads <= maxThreads) {\n\t\t\tdouble operationsPerSecond = performRound(threads);\n\n\t\t\tif (operationsPerSecond > bestRoundOperationsPerSecond) {\n\t\t\t\tbestRoundOperationsPerSecond = operationsPerSecond;\n\t\t\t\tbestRoundThreads = threads;\n\t\t\t}\n\n\t\t\tout(toResultString(operationsPerSecond, threads));\n\t\t\tout(\"Total memory: \" + Runtime.getRuntime().totalMemory());\n\n\t\t\tthreads++;\n\t\t}\n\t}\n\n\n\t/** @return The number of operations the test managed to execute per second with the given number of threads.\n\t*/\n\tprivate double performRound(int threads) {\n\t\tlong initialOperationCount = operationCount;\n\t\tStopWatch stopWatch = StopWatch.start();\n\n\t\tstartThreads(threads);\n\t\tsleep();\n\t\tstopThreads();\n\t\t\n\t\treturn (operationCount - initialOperationCount) / stopWatch.secondsEllapsed();\n\t}\n\n\n\tprivate void startThreads(int threads) {\n\t\tisRoundFinished = false;\n\n\t\tfor(int i = 1; i <= threads; i++) {\n\t\t\tstartThread();\n\t\t}\n\t}\n\n\n\tprivate void startThread() {\n\t\t(new Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tObject connection = acquireConnection();\n\n\t\t\t\twhile (!isRoundFinished) {\n\t\t\t\t\tlong operation;\n\t\t\t\t\tsynchronized (roundMonitor) {\n\t\t\t\t\t\toperation = operationCount;\n\t\t\t\t\t\toperationCount++;\n\t\t\t\t\t}\n\t\t\t\t\texecuteOperation(connection, operation);\n\t\t\t\t}\n\n\t\t\t\tsynchronized (roundMonitor) {\n\t\t\t\t\tconnectionCache.add(connection);\n\t\t\t\t\tactiveRoundThreads--;\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\n\t\tactiveRoundThreads++;\n\t}\n\n\n\tprotected abstract void executeOperation(Object connection, long operation);\n\n\n\tprivate Object acquireConnection() {\n\t\tsynchronized (roundMonitor) {\n\t\t\treturn connectionCache.isEmpty()\n\t\t\t\t? subject.createTestConnection()\n\t\t\t\t: connectionCache.remove(0);\n\t\t}\n\t}\n\n\n\tprivate void stopThreads() {\n\t\tisRoundFinished = true;\n\t\twhile (activeRoundThreads != 0) {\n\t\t\tThread.yield();\n\t\t}\n\t}\n\n\n\tstatic private String toResultString(double operationsPerSecond, int threads) {\n\t\tString operations = new DecimalFormat(\"0.00\").format(operationsPerSecond);\n\t\treturn \"\" + operations + \" operations/second (\" + threads + \" threads)\";\n\t}\n\n\n\tstatic private void sleep() {\n\t\ttry {\n\t\t\tThread.sleep(ROUND_DURATION_MILLIS);\n\t\t} catch (InterruptedException ix) {\n\t\t\tthrow new RuntimeException(\"Unexpected InterruptedException.\");\n\t\t}\n\t}\n\n\t\n\tstatic private void out(Object obj) {\n\t\tSystem.out.println(obj);\n\t}\n}\n","Method after Refactoring":"// Prevayler(TM) - The Open-Source Prevalence Layer.\n// Copyright (C) 2001 Klaus Wuestefeld.\n// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\npackage org.prevayler.test.scalability;\n\nimport java.util.*;\nimport java.text.DecimalFormat;\nimport org.prevayler.util.*;\n\n/** Represents a single run of a scalability test. To understand the implementation of this class, you must be familiar with Prevayler's Scalability Test (run org.prevayler.test.scalability.ScalabilityTest).\n*/\nabstract class ScalabilityTestRun {\n\n\tstatic private final long ROUND_DURATION_MILLIS = 1000 * 60;\n\n\tprivate final ScalabilityTestSubject subject;\n\tprotected final int numberOfObjects;\n\n\tprivate double bestRoundOperationsPerSecond;\n\tprivate int bestRoundThreads;\n\n\tprivate final List connectionCache = new LinkedList();\n\n\tprivate long operationCount = 0;\n\tprivate final Object roundMonitor = new Object();\n\tprivate boolean isRoundFinished;\n\tprivate int activeRoundThreads = 0;\n\n\n\t/** @return Example: \"123.12 operations/second (12 threads)\".\n\t*/\n\tpublic String getResult() {\n\t\treturn toResultString(bestRoundOperationsPerSecond, bestRoundThreads);\n\t}\n\n\n\tpublic double getOperationsPerSecond() {\n\t\treturn bestRoundOperationsPerSecond;\n\t}\n\n\n\tprotected ScalabilityTestRun(ScalabilityTestSubject subject, int numberOfObjects, int minThreads, int maxThreads) {\n\t\tif (minThreads > maxThreads) throw new IllegalArgumentException(\"The minimum number of threads cannot be greater than the maximum number.\");\n\t\tif (minThreads < 1) throw new IllegalArgumentException(\"The minimum number of threads cannot be smaller than one.\");\n\n\t\tthis.subject = subject;\n\t\tthis.numberOfObjects = numberOfObjects;\n\n\t\tout(\"\\n\\n========= Running \" + name() + \" (\" + (maxThreads - minThreads + 1) + \" rounds). Subject: \" + subject.name() + \"...\");\n\t\tprepare();\n\n\t\tout(\"Each round will take approx. \" + ROUND_DURATION_MILLIS / 1000 + \" seconds to run...\");\n\t\tperformTest(minThreads, maxThreads);\n\t\tout(\"\\n----------- BEST ROUND: \" + getResult());\n\t}\n\n\tprotected void prepare() {\n\t\tsubject.replaceAllRecords(new RecordIterator(numberOfObjects));\n\t\tSystem.gc();\n\t}\n\n\n\t/** @return The name of the test to be executed. Example: \"Prevayler Query Test\".\n\t*/\n\tprotected abstract String name();\n\n\n\tprivate void performTest(int minThreads, int maxThreads) {\n\n\t\tint threads = minThreads;\n\t\twhile (threads <= maxThreads) {\n\t\t\tdouble operationsPerSecond = performRound(threads);\n\n\t\t\tif (operationsPerSecond > bestRoundOperationsPerSecond) {\n\t\t\t\tbestRoundOperationsPerSecond = operationsPerSecond;\n\t\t\t\tbestRoundThreads = threads;\n\t\t\t}\n\n\t\t\tthreads++;\n\t\t}\n\t}\n\n\n\t/** @return The number of operations the test managed to execute per second with the given number of threads.\n\t*/\n\tprivate double performRound(int threads) {\n\t\tlong initialOperationCount = operationCount;\n\t\tStopWatch stopWatch = StopWatch.start();\n\n\t\tstartThreads(threads);\n\t\tsleep();\n\t\tstopThreads();\n\n\t\tdouble secondsEllapsed = stopWatch.secondsEllapsed();\n\t\tdouble operationsPerSecond = (operationCount - initialOperationCount) / secondsEllapsed;\n\n\t\tout(\"\\nMemory used: \" + Runtime.getRuntime().totalMemory());\n\t\tout(\"Seconds ellapsed: \" + secondsEllapsed);\n\t\tout(\"--------- Round Result: \" + toResultString(operationsPerSecond, threads));\n\n\t\treturn operationsPerSecond;\n\t}\n\n\n\tprivate void startThreads(int threads) {\n\t\tisRoundFinished = false;\n\n\t\tfor(int i = 1; i <= threads; i++) {\n\t\t\tstartThread();\n\t\t}\n\t}\n\n\n\tprivate void startThread() {\n\t\t(new Thread() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tObject connection = acquireConnection();\n\n\t\t\t\t\twhile (!isRoundFinished) {\n\t\t\t\t\t\tlong operation;\n\t\t\t\t\t\tsynchronized (roundMonitor) {\n\t\t\t\t\t\t\toperation = operationCount;\n\t\t\t\t\t\t\toperationCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texecuteOperation(connection, operation);\n\t\t\t\t\t}\n\n\t\t\t\t\tsynchronized (roundMonitor) {\n\t\t\t\t\t\tconnectionCache.add(connection);\n\t\t\t\t\t\tactiveRoundThreads--;\n\t\t\t\t\t}\n\n\t\t\t\t} catch (OutOfMemoryError err) {\n\t\t\t\t\toutOfMemory();\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\n\t\tactiveRoundThreads++;\n\t}\n\n\n\tprotected abstract void executeOperation(Object connection, long operation);\n\n\n\tprivate Object acquireConnection() {\n\t\tsynchronized (roundMonitor) {\n\t\t\treturn connectionCache.isEmpty()\n\t\t\t\t? subject.createTestConnection()\n\t\t\t\t: connectionCache.remove(0);\n\t\t}\n\t}\n\n\n\tprivate void stopThreads() {\n\t\tisRoundFinished = true;\n\t\twhile (activeRoundThreads != 0) {\n\t\t\tThread.yield();\n\t\t}\n\t}\n\n\n\tstatic private String toResultString(double operationsPerSecond, int threads) {\n\t\tString operations = new DecimalFormat(\"0.00\").format(operationsPerSecond);\n\t\treturn \"\" + operations + \" operations/second (\" + threads + \" threads)\";\n\t}\n\n\tstatic void outOfMemory() {\n\t\tSystem.gc();\n\t\tout(\n\t\t\t\"\\n\\nOutOfMemoryError.\\n\" +\n\t\t\t\"===========================================================\\n\" +\n\t\t\t\"The VM must be started with a sufficient maximum heap size.\\n\" +\n\t\t\t\"Example for Linux and Windows:  java -Xmx512000000 ...\\n\\n\"\n\t\t);\n\t}\n\n\tstatic private void sleep() {\n\t\ttry {\n\t\t\tThread.sleep(ROUND_DURATION_MILLIS);\n\t\t} catch (InterruptedException ix) {\n\t\t\tthrow new RuntimeException(\"Unexpected InterruptedException.\");\n\t\t}\n\t}\n\n\t\n\tstatic private void out(Object obj) {\n\t\tSystem.out.println(obj);\n\t}\n}\n","lineNo":95}
{"Smelly Sample":"// Prevayler(TM) - The Open-Source Prevalence Layer.\n// Copyright (C) 2001 Klaus Wuestefeld.\n// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\npackage org.prevayler.implementation;\n\nimport org.prevayler.*;\nimport java.util.Date;\n\n/** An AlarmClock that uses the local system clock as its time source.\n* This class can be extended so that other time sources can be used.\n* @see currentTimeMillis()\n*/\npublic class SystemClock implements AlarmClock {\n\n    private Date time;\n    private long millis;\n    private boolean isPaused = true;\n\n\n    /** A newly created SystemClock starts off paused with time() equal to new Date(Long.MIN_VALUE).\n    */\n    public SystemClock() {\n        set(new Date(Long.MIN_VALUE));\n    }\n\n\n    /** Returns the time.\n    * @return If the time is the same as the last call, the SAME Date object will be returned and not a new, equal one.\n    */\n    public synchronized Date time() {\n        if (isPaused) return time;\n\n        if (currentTimeMillis() != millis) {\n            set(new Date(currentTimeMillis()));\n        }\n\n        return time;\n    }\n\n    /** Causes time() to return always the same value as if the clock had stopped.\n    * The clock does NOT STOP internally though. This method is called by Prevayler before each Command is executed so that it can be executed in a known moment in time.\n    * @see resume()\n    */\n    synchronized void pause() {\n        if (isPaused) throw new IllegalStateException(\"AlarmClock was already paused.\");\n\n        time();           //Guarantees the time is up-to-date.\n        isPaused = true;\n    }\n\n    /** Causes time() to return the actual current time again. This method is called by Prevayler after each Command is executed so that the clock can run again.\n    * @see pause()\n    */\n    synchronized void resume() {\n        if (!isPaused) throw new IllegalStateException(\"AlarmClock was not paused.\");\n\n        isPaused = false;\n    }\n\n    /** Sets the time forward, recovering some of the time that was \"lost\" since the clock was paused. The clock must be paused. This method is called by the PrevaylerFactory when recovering Commands from the log file so that they can be re-executed in the \"same\" time as they had been originally.\n    * @param newMillis cannot be earlier than time().getTime() and cannot be later than the current machine time (new Date().getTime() or System.currentTimeMillis()).\n    */\n    synchronized void recover(long newMillis) {\n        if (!isPaused) throw new RuntimeException(\"AlarmClock must be paused for recovering.\");\n\n        if (newMillis == millis) return;\n        if (newMillis < millis) throw new RuntimeException(\"AlarmClock's time cannot be set backwards.\");\n        if (newMillis > currentTimeMillis()) throw new RuntimeException(\"AlarmClock's time cannot be set after the current time.\");\n\n        set(new Date(newMillis));\n    }\n\n    /** Returns the current system time. Override this method if you want to use a different time source.\n    */\n    protected long currentTimeMillis() {\n        return System.currentTimeMillis();\n    }\n\n    private void set(Date time) {\n        this.time = time;\n        this.millis = time.getTime();\n    }\n}\n","Method after Refactoring":"// Prevayler(TM) - The Open-Source Prevalence Layer.\n// Copyright (C) 2001 Klaus Wuestefeld.\n// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\npackage org.prevayler.implementation;\n\nimport org.prevayler.*;\nimport java.util.Date;\n\n/**\n * An AlarmClock that uses the local system clock as its current-time source.\n * This class can be extended so that other time sources can be used.\n * @see #currentTimeMillis()\n */\npublic class SystemClock implements AlarmClock {\n\n  private Date time;\n  private long millis;\n  private boolean isPaused = true;\n\n\n  /** \n   * A newly created SystemClock starts off paused with time() equal to new Date(Long.MIN_VALUE).\n   */\n  public SystemClock() {\n    set(new Date(Long.MIN_VALUE));\n  }\n\n\n  public synchronized Date time() {\n    if (isPaused) return time;\n\n    long currentMillis = currentTimeMillis();\n    if (currentMillis != millis) {\n      set(new Date(currentMillis));\n    }\n\n    return time;\n  }\n\n\n  /**\n   * Causes time() to return always the same value as if the clock had stopped.\n   * The clock does NOT STOP internally though. This method is called by Prevayler before each Command is executed so that it can be executed in a known moment in time.\n   * @see #resume()\n   */\n  synchronized void pause() {\n    if (isPaused) throw new IllegalStateException(\"AlarmClock was already paused.\");\n\n    time();           //Guarantees the time is up-to-date.\n    isPaused = true;\n  }\n\n\n  /**\n   * Causes time() to return the current time again. This method is called by Prevayler after each Command is executed so that the clock can start running again.\n   * @see #pause()\n   */\n  synchronized void resume() {\n    if (!isPaused) throw new IllegalStateException(\"AlarmClock was not paused.\");\n\n    isPaused = false;\n  }\n\n\n  /**\n   * Sets the time forward, recovering some of the time that was \"lost\" since the clock was paused. The clock must be paused. This method is called by Prevayler when recovering commands from the commandLog file so that they can be re-executed in the \"same\" time as they had been originally.\n   * @param newMillis the new time in milliseconds. Cannot be earlier than time().getTime() and cannot be later than currentTimeMillis().\n   */\n  synchronized void recover(long newMillis) {\n    if (!isPaused) throw new IllegalStateException(\"AlarmClock must be paused for recovering.\");\n\n    if (newMillis == millis) return;\n    if (newMillis < millis) throw new IllegalArgumentException(\"AlarmClock's time cannot be set backwards.\");\n    if (newMillis > currentTimeMillis()) throw new IllegalArgumentException(\"AlarmClock's time cannot be set after the current time.\");\n\n    set(new Date(newMillis));\n  }\n\n\n  /**\n   * Returns System.currentTimeMillis(). Override this method if you want to use a different time source for your system.\n   */\n  protected long currentTimeMillis() {\n    return System.currentTimeMillis();\n  }\n\n\n  private void set(Date time) {\n    this.time = time;\n    this.millis = time.getTime();\n  }\n\n}\n","lineNo":33}
{"Smelly Sample":"// Prevayler(TM) - The Open-Source Prevalence Layer.\n// Copyright (C) 2001 Klaus Wuestefeld.\n// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\npackage prevayler.implementation;\n\nimport java.io.*;\nimport java.util.Arrays;\nimport java.text.*;\n\n/** Finds the last .snapshot file by number and finds all the subsequent pending .log files.\n*/\npublic class NumberFileFinder {\n\n    private File directory;\n\tprivate File lastSnapshot;\n    private long fileNumber;\n    private NumberFileCreator fileCreator;\n\n    /** @throws IOException if location does not exist and cannot be created as a directory.\n    * @throws IllegalArgumentException If location exists and is not a directory.\n    */\n    public NumberFileFinder(String directoryName) throws IOException {\n        this.directory = new File(directoryName);\n        if (!directory.exists() && !directory.mkdirs()) throw new IOException(\"Directory doesn't exist and could not be created: \" + directoryName);\n        if (!directory.isDirectory()) throw new IllegalArgumentException(\"Path exists but is not a directory: \" + directoryName);\n\n        init();\n\t}\n\n    /** Returns the last snapshot file. Returns null if there are no snapshots.\n    */\n    public File lastSnapshot() {\n        return lastSnapshot;\n\t}\n\n    /** @throws EOFException if there are no more pending .log files.\n    */\n    public File nextPendingLog() throws EOFException {\n        File log = new File(directory, NumberFileCreator.LOG_FORMAT.format(fileNumber + 1));\n        if (!log.exists()) {\n            fileCreator = new NumberFileCreator(directory, fileNumber + 1);\n            throw new EOFException();\n        }\n        ++fileNumber;\n        return log;\n\t}\n\n    /** Returns a NumberFileCreator that will start off with the first number after the last .log file number.\n    * @return null if there are still .log files pending.\n    */\n    public NumberFileCreator fileCreator() {\n        return fileCreator;\n    }\n\n    private void init() throws IOException {\n        findLastSnapshot();\n        fileNumber = lastSnapshot == null\n            ? 0\n            : number(lastSnapshot);\n\t}\n\n    private long number(File snapshot) {\n        try {\n            return (NumberFileCreator.SNAPSHOT_FORMAT.parse(snapshot.getName())).longValue();\n        } catch(ParseException pe) {\n            throw new InternalParseException();\n\t\t}\n\t}\n\n    private void findLastSnapshot() throws IOException {\n        File[] snapshots = directory.listFiles(new SnapshotFilter());\n        if (snapshots == null) throw new IOException(\"Error reading file list from directory \" + directory);\n\n        Arrays.sort(snapshots);\n\n        lastSnapshot = snapshots.length > 0\n            ? snapshots[snapshots.length - 1]\n            : null;\n\t}\n\n\n    private class SnapshotFilter implements FileFilter {\n\n        public boolean accept(File file) {\n            try {\n                number(file);\n            } catch (InternalParseException ipe) {\n                return false;\n            }\n            return true;\n\t\t}\n\t}\n\n    private static class InternalParseException extends RuntimeException {\n    }\n}\n","Method after Refactoring":"// Prevayler(TM) - The Open-Source Prevalence Layer.\n// Copyright (C) 2001 Klaus Wuestefeld.\n// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\npackage prevayler.implementation;\n\nimport java.io.*;\nimport java.util.Arrays;\nimport java.text.*;\n\n/** Finds the last .snapshot file by number and finds all the subsequent pending .log files.\n*/\npublic class NumberFileFinder {\n\n    private File directory;\n\tprivate File lastSnapshot;\n    private long fileNumber;\n    private NumberFileCreator fileCreator;\n\n    /** @throws IOException if location does not exist and cannot be created as a directory.\n    * @throws IllegalArgumentException If location exists and is not a directory.\n    */\n    public NumberFileFinder(String directoryName) throws IOException {\n        this.directory = new File(directoryName);\n        if (!directory.exists() && !directory.mkdirs()) throw new IOException(\"Directory doesn't exist and could not be created: \" + directoryName);\n        if (!directory.isDirectory()) throw new IllegalArgumentException(\"Path exists but is not a directory: \" + directoryName);\n\n        init();\n\t}\n\n    /** Returns the last snapshot file. Returns null if there are no snapshots.\n    */\n    public File lastSnapshot() {\n        return lastSnapshot;\n\t}\n\n    /** @throws EOFException if there are no more pending .log files.\n    */\n    public File nextPendingLog() throws EOFException {\n        File log = new File(directory, NumberFileCreator.LOG_FORMAT.format(fileNumber + 1));\n        if (!log.exists()) {\n            fileCreator = new NumberFileCreator(directory, fileNumber + 1);\n            throw new EOFException();\n        }\n        ++fileNumber;\n        return log;\n\t}\n\n    /** Returns a NumberFileCreator that will start off with the first number after the last .log file number.\n    * @return null if there are still .log files pending.\n    */\n    public NumberFileCreator fileCreator() {\n        return fileCreator;\n    }\n\n    private void init() throws IOException {\n        findLastSnapshot();\n        fileNumber = lastSnapshot == null\n            ? 0\n            : number(lastSnapshot);\n\t}\n\n    private long number(File snapshot) throws NumberFormatException {  //NumberFomatException is a RuntimeException.\n        String name = snapshot.getName();\n        if (!name.endsWith(\".\" + NumberFileCreator.SNAPSHOT_SUFFIX)) throw new NumberFormatException();\n        return Long.parseLong(name.substring(0,name.indexOf('.')));    // \"00000.snapshot\" becomes \"00000\".\n        //The following doesn't work! It throws ParseException (UnparseableNumber): return (NumberFileCreator.SNAPSHOT_FORMAT.parse(snapshot.getName())).longValue();\n\t}\n\n    private void findLastSnapshot() throws IOException {\n        File[] snapshots = directory.listFiles(new SnapshotFilter());\n        if (snapshots == null) throw new IOException(\"Error reading file list from directory \" + directory);\n\n        Arrays.sort(snapshots);\n\n        lastSnapshot = snapshots.length > 0\n            ? snapshots[snapshots.length - 1]\n            : null;\n\t}\n\n\n    private class SnapshotFilter implements FileFilter {\n\n        public boolean accept(File file) {\n            try {\n                number(file);\n            } catch (NumberFormatException nfx) {\n                return false;\n            }\n            return true;\n\t\t}\n\t}\n\n}\n","lineNo":64}
