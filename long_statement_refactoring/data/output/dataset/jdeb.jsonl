{"Smelly Sample":"/*\n * Copyright 2007-2023 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarConstants;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.compressors.CompressorException;\nimport org.vafer.jdeb.utils.Utils;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Builds the data archive of the Debian package.\n */\nclass DataBuilder {\n\n    private Console console;\n\n    private ZipEncoding encoding;\n\n    private final Long outputTimestampMs;\n\n    private static final class Total {\n        private BigInteger count = BigInteger.valueOf(0);\n\n        public void add( long size ) {\n            count = count.add(BigInteger.valueOf(size));\n        }\n\n        public String toString() {\n            return \"\" + count;\n        }\n    }\n\n    DataBuilder(Console console, Long outputTimestampMs) {\n        this.console = console;\n        this.encoding = ZipEncodingHelper.getZipEncoding(null);\n        this.outputTimestampMs = outputTimestampMs;\n    }\n\n    private void checkField(String name, int length) throws IOException {\n        if (name != null) {\n            ByteBuffer b = encoding.encode(name);\n            if (b.limit() > length) {\n                throw new IllegalArgumentException(\"Field '\" + name + \"' too long, maximum is \" + length);\n            }\n        }\n    }\n\n    /**\n     * Build the data archive of the deb from the provided DataProducers\n     *\n     * @param producers\n     * @param output\n     * @param checksums\n     * @param options Options used to build the data file\n     * @return\n     * @throws java.security.NoSuchAlgorithmException\n     * @throws java.io.IOException\n     * @throws org.apache.commons.compress.compressors.CompressorException\n     */\n    BigInteger buildData(Collection<DataProducer> producers, File output, final StringBuilder checksums, TarOptions options) throws NoSuchAlgorithmException, IOException, CompressorException {\n\n        final File dir = output.getParentFile();\n        if (dir != null && (!dir.exists() || !dir.isDirectory())) {\n            throw new IOException(\"Cannot write data file at '\" + output.getAbsolutePath() + \"'\");\n        }\n\n        final TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(\n            options.compression().toCompressedOutputStream(new FileOutputStream(output))\n        );\n        tarOutputStream.setLongFileMode(options.longFileMode());\n        tarOutputStream.setBigNumberMode(options.bigNumberMode());\n\n        final MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\n        final Total dataSize = new Total();\n\n        final List<String> addedDirectories = new ArrayList<>();\n        final DataConsumer receiver = new DataConsumer() {\n\n            public void onEachDir(TarArchiveEntry dirEntry) throws IOException {\n                // Check link name\n                checkField(dirEntry.getLinkName(), TarConstants.NAMELEN);\n                // Check user name\n                checkField(dirEntry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(dirEntry.getUserName(), TarConstants.GNAMELEN);\n\n                dirEntry.setName(fixPathTar(dirEntry.getName()));\n\n                createParentDirectories(dirEntry.getName(), dirEntry.getUserName(), dirEntry.getLongUserId(), dirEntry.getGroupName(), dirEntry.getLongGroupId());\n\n                // The directory passed in explicitly by the caller also gets the passed-in mode.  (Unlike\n                // the parent directories for now.  See related comments at \"int mode =\" in\n                // createParentDirectories, including about a possible bug.)\n                createDirectory(dirEntry.getName(), dirEntry.getUserName(), dirEntry.getLongUserId(), dirEntry.getGroupName(), dirEntry.getLongGroupId(), dirEntry.getMode(), 0);\n\n                console.debug(\"dir: \" + dirEntry.getName());\n            }\n\n            public void onEachFile(InputStream input, TarArchiveEntry fileEntry) throws IOException {\n                // Check link name\n                checkField(fileEntry.getLinkName(), TarConstants.NAMELEN);\n                // Check user name\n                checkField(fileEntry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(fileEntry.getGroupName(), TarConstants.GNAMELEN);\n\n                // For md5sum\n                String rawFileEntryName = fileEntry.getName();\n\n                fileEntry.setName(fixPathTar(fileEntry.getName()));\n                if (outputTimestampMs != null) {\n                    fileEntry.setModTime(outputTimestampMs);\n                }\n\n                createParentDirectories(fileEntry.getName(), fileEntry.getUserName(), fileEntry.getLongUserId(), fileEntry.getGroupName(), fileEntry.getLongGroupId());\n\n                tarOutputStream.putArchiveEntry(fileEntry);\n\n                dataSize.add(fileEntry.getSize());\n                digest.reset();\n\n                Utils.copy(input, new DigestOutputStream(tarOutputStream, digest));\n\n                final String md5 = Utils.toHex(digest.digest());\n\n                tarOutputStream.closeArchiveEntry();\n\n                console.debug(\n                    \"file:\" + fileEntry.getName() +\n                        \" size:\" + fileEntry.getSize() +\n                        \" mode:\" + fileEntry.getMode() +\n                        \" linkname:\" + fileEntry.getLinkName() +\n                        \" username:\" + fileEntry.getUserName() +\n                        \" userid:\" + fileEntry.getLongUserId() +\n                        \" groupname:\" + fileEntry.getGroupName() +\n                        \" groupid:\" + fileEntry.getLongGroupId() +\n                        \" modtime:\" + fileEntry.getModTime() +\n                        \" md5: \" + md5\n                );\n\n                // append to file md5 list, two spaces to be compatible with GNU coreutils md5sum\n                checksums.append(md5).append(\"  \").append(fixPathMd5(rawFileEntryName)).append('\\n');\n            }\n\n            public void onEachLink(TarArchiveEntry entry) throws IOException {\n                // Check user name\n                checkField(entry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(entry.getGroupName(), TarConstants.GNAMELEN);\n\n                entry.setName(fixPathTar(entry.getName()));\n                if (outputTimestampMs != null) {\n                    entry.setModTime(outputTimestampMs);\n                }\n\n                createParentDirectories(entry.getName(), entry.getUserName(), entry.getLongUserId(), entry.getGroupName(), entry.getLongGroupId());\n\n                tarOutputStream.putArchiveEntry(entry);\n                tarOutputStream.closeArchiveEntry();\n\n                console.debug(\n                    \"link:\" + entry.getName() +\n                    \" mode:\" + entry.getMode() +\n                    \" linkname:\" + entry.getLinkName() +\n                    \" username:\" + entry.getUserName() +\n                    \" userid:\" + entry.getLongUserId() +\n                    \" groupname:\" + entry.getGroupName() +\n                    \" groupid:\" + entry.getLongGroupId()\n                 );\n            }\n\n\n            private void createDirectory( String directory, String user, long uid, String group, long gid, int mode, long size ) throws IOException {\n                // All dirs should end with \"/\" when created, or the test DebAndTaskTestCase.testTarFileSet() thinks its a file\n                // and so thinks it has the wrong permission.\n                // This consistency also helps when checking if a directory already exists in addedDirectories.\n\n                if (!directory.endsWith(\"/\")) {\n                    directory += \"/\";\n                }\n\n                if (!addedDirectories.contains(directory)) {\n                    TarArchiveEntry entry = new TarArchiveEntry(directory, true);\n                    entry.setUserName(user);\n                    entry.setUserId(uid);\n                    entry.setGroupName(group);\n                    entry.setGroupId(gid);\n                    entry.setMode(mode);\n                    entry.setSize(size);\n\n                    if (outputTimestampMs != null) {\n                        entry.setModTime(outputTimestampMs);\n                    }\n\n                    tarOutputStream.putArchiveEntry(entry);\n                    tarOutputStream.closeArchiveEntry();\n                    addedDirectories.add(directory); // so addedDirectories consistently have \"/\" for finding duplicates.\n                }\n            }\n\n            private void createParentDirectories( String filename, String user, long uid, String group, long gid ) throws IOException {\n                String dirname = fixPathTar(new File(filename).getParent());\n\n                // Debian packages must have parent directories created\n                // before sub-directories or files can be installed.\n                // For example, if an entry of ./usr/lib/foo/bar existed\n                // in a .deb package, but the ./usr/lib/foo directory didn't\n                // exist, the package installation would fail.  The .deb must\n                // then have an entry for ./usr/lib/foo and then ./usr/lib/foo/bar\n\n                if (dirname == null) {\n                    return;\n                }\n\n                // The loop below will create entries for all parent directories\n                // to ensure that .deb packages will install correctly.\n                String[] pathParts = dirname.split(\"/\");\n                String parentDir = \"./\";\n                for (int i = 1; i < pathParts.length; i++) {\n                    parentDir += pathParts[i] + \"/\";\n                    // Make it so the dirs can be traversed by users.\n                    // We could instead try something more granular, like setting the directory\n                    // permission to 'rx' for each of the 3 user/group/other read permissions\n                    // found on the file being added (ie, only if \"other\" has read\n                    // permission on the main node, then add o+rx permission on all the containing\n                    // directories, same w/ user & group), and then also we'd have to\n                    // check the parentDirs collection of those already added to\n                    // see if those permissions need to be similarly updated.  (Note, it hasn't\n                    // been demonstrated, but there might be a bug if a user specifically\n                    // requests a directory with certain permissions,\n                    // that has already been auto-created because it was a parent, and if so, go set\n                    // the user-requested mode on that directory instead of this automatic one.)\n                    // But for now, keeping it simple by making every dir a+rx.   Examples are:\n                    // drw-r----- fs/fs   # what you get with setMode(mode)\n                    // drwxr-xr-x fs/fs   # Usable. Too loose?\n                    int mode = TarArchiveEntry.DEFAULT_DIR_MODE;\n\n                    createDirectory(parentDir, user, uid, group, gid, mode, 0);\n                }\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } finally {\n            tarOutputStream.close();\n        }\n\n        console.debug(\"Total size: \" + dataSize);\n\n        return dataSize.count;\n    }\n\n    private String fixPathBase( String path ) {\n        if (path == null || path.equals(\".\")) {\n            return path;\n        }\n\n        // If we're receiving directory names from Windows, then we'll convert to use slash\n        // This does eliminate the ability to use of a backslash in a directory name on *NIX,\n        // but in practice, this is a non-issue\n        if (path.contains(\"\\\\\")) {\n            path = path.replace('\\\\', '/');\n        }\n        return path;\n    }\n\n    private String fixPathTar( String path ) {\n        if (path == null || path.equals(\".\")) {\n            return path;\n        }\n\n        path = fixPathBase(path);\n\n        // ensure the path is like : ./foo/bar\n        if (path.startsWith(\"/\")) {\n            path = \".\" + path;\n        } else if (!path.startsWith(\"./\")) {\n            path = \"./\" + path;\n        }\n        return path;\n    }\n\n    private String fixPathMd5( String path ) {\n        if (path == null || path.equals(\".\")) {\n            return path;\n        }\n\n        path = fixPathBase(path);\n\n        // ensure the path is like : foo/bar\n        if (path.startsWith(\"/\")) {\n            path = path.substring(1);\n        } else if (path.startsWith(\"./\")) {\n            path = path.substring(2);\n        }\n        return path;\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2007-2023 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarConstants;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.compressors.CompressorException;\nimport org.vafer.jdeb.utils.Utils;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Builds the data archive of the Debian package.\n */\nclass DataBuilder {\n\n    private Console console;\n\n    private ZipEncoding encoding;\n\n    private final Long outputTimestampMs;\n\n    private static final class Total {\n        private BigInteger count = BigInteger.valueOf(0);\n\n        public void add( long size ) {\n            count = count.add(BigInteger.valueOf(size));\n        }\n\n        public String toString() {\n            return \"\" + count;\n        }\n    }\n\n    DataBuilder(Console console, Long outputTimestampMs) {\n        this.console = console;\n        String empty = null;\n        this.encoding = ZipEncodingHelper.getZipEncoding(empty);\n        this.outputTimestampMs = outputTimestampMs;\n    }\n\n    private void checkField(String name, int length) throws IOException {\n        if (name != null) {\n            ByteBuffer b = encoding.encode(name);\n            if (b.limit() > length) {\n                throw new IllegalArgumentException(\"Field '\" + name + \"' too long, maximum is \" + length);\n            }\n        }\n    }\n\n    /**\n     * Build the data archive of the deb from the provided DataProducers\n     *\n     * @param producers\n     * @param output\n     * @param checksums\n     * @param options Options used to build the data file\n     * @return\n     * @throws java.security.NoSuchAlgorithmException\n     * @throws java.io.IOException\n     * @throws org.apache.commons.compress.compressors.CompressorException\n     */\n    BigInteger buildData(Collection<DataProducer> producers, File output, final StringBuilder checksums, TarOptions options) throws NoSuchAlgorithmException, IOException, CompressorException {\n\n        final File dir = output.getParentFile();\n        if (dir != null && (!dir.exists() || !dir.isDirectory())) {\n            throw new IOException(\"Cannot write data file at '\" + output.getAbsolutePath() + \"'\");\n        }\n\n        final TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(\n            options.compression().toCompressedOutputStream(new FileOutputStream(output))\n        );\n        tarOutputStream.setLongFileMode(options.longFileMode());\n        tarOutputStream.setBigNumberMode(options.bigNumberMode());\n\n        final MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\n        final Total dataSize = new Total();\n\n        final List<String> addedDirectories = new ArrayList<>();\n        final DataConsumer receiver = new DataConsumer() {\n\n            public void onEachDir(TarArchiveEntry dirEntry) throws IOException {\n                // Check link name\n                checkField(dirEntry.getLinkName(), TarConstants.NAMELEN);\n                // Check user name\n                checkField(dirEntry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(dirEntry.getUserName(), TarConstants.GNAMELEN);\n\n                dirEntry.setName(fixPathTar(dirEntry.getName()));\n\n                createParentDirectories(dirEntry.getName(), dirEntry.getUserName(), dirEntry.getLongUserId(), dirEntry.getGroupName(), dirEntry.getLongGroupId());\n\n                // The directory passed in explicitly by the caller also gets the passed-in mode.  (Unlike\n                // the parent directories for now.  See related comments at \"int mode =\" in\n                // createParentDirectories, including about a possible bug.)\n                createDirectory(dirEntry.getName(), dirEntry.getUserName(), dirEntry.getLongUserId(), dirEntry.getGroupName(), dirEntry.getLongGroupId(), dirEntry.getMode(), 0);\n\n                console.debug(\"dir: \" + dirEntry.getName());\n            }\n\n            public void onEachFile(InputStream input, TarArchiveEntry fileEntry) throws IOException {\n                // Check link name\n                checkField(fileEntry.getLinkName(), TarConstants.NAMELEN);\n                // Check user name\n                checkField(fileEntry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(fileEntry.getGroupName(), TarConstants.GNAMELEN);\n\n                // For md5sum\n                String rawFileEntryName = fileEntry.getName();\n\n                fileEntry.setName(fixPathTar(fileEntry.getName()));\n                if (outputTimestampMs != null) {\n                    fileEntry.setModTime(outputTimestampMs);\n                }\n\n                createParentDirectories(fileEntry.getName(), fileEntry.getUserName(), fileEntry.getLongUserId(), fileEntry.getGroupName(), fileEntry.getLongGroupId());\n\n                tarOutputStream.putArchiveEntry(fileEntry);\n\n                dataSize.add(fileEntry.getSize());\n                digest.reset();\n\n                Utils.copy(input, new DigestOutputStream(tarOutputStream, digest));\n\n                final String md5 = Utils.toHex(digest.digest());\n\n                tarOutputStream.closeArchiveEntry();\n\n                console.debug(\n                    \"file:\" + fileEntry.getName() +\n                        \" size:\" + fileEntry.getSize() +\n                        \" mode:\" + fileEntry.getMode() +\n                        \" linkname:\" + fileEntry.getLinkName() +\n                        \" username:\" + fileEntry.getUserName() +\n                        \" userid:\" + fileEntry.getLongUserId() +\n                        \" groupname:\" + fileEntry.getGroupName() +\n                        \" groupid:\" + fileEntry.getLongGroupId() +\n                        \" modtime:\" + fileEntry.getModTime() +\n                        \" md5: \" + md5\n                );\n\n                // append to file md5 list, two spaces to be compatible with GNU coreutils md5sum\n                checksums.append(md5).append(\"  \").append(fixPathMd5(rawFileEntryName)).append('\\n');\n            }\n\n            public void onEachLink(TarArchiveEntry entry) throws IOException {\n                // Check user name\n                checkField(entry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(entry.getGroupName(), TarConstants.GNAMELEN);\n\n                entry.setName(fixPathTar(entry.getName()));\n                if (outputTimestampMs != null) {\n                    entry.setModTime(outputTimestampMs);\n                }\n\n                createParentDirectories(entry.getName(), entry.getUserName(), entry.getLongUserId(), entry.getGroupName(), entry.getLongGroupId());\n\n                tarOutputStream.putArchiveEntry(entry);\n                tarOutputStream.closeArchiveEntry();\n\n                console.debug(\n                    \"link:\" + entry.getName() +\n                    \" mode:\" + entry.getMode() +\n                    \" linkname:\" + entry.getLinkName() +\n                    \" username:\" + entry.getUserName() +\n                    \" userid:\" + entry.getLongUserId() +\n                    \" groupname:\" + entry.getGroupName() +\n                    \" groupid:\" + entry.getLongGroupId()\n                 );\n            }\n\n\n            private void createDirectory( String directory, String user, long uid, String group, long gid, int mode, long size ) throws IOException {\n                // All dirs should end with \"/\" when created, or the test DebAndTaskTestCase.testTarFileSet() thinks its a file\n                // and so thinks it has the wrong permission.\n                // This consistency also helps when checking if a directory already exists in addedDirectories.\n\n                if (!directory.endsWith(\"/\")) {\n                    directory += \"/\";\n                }\n\n                if (!addedDirectories.contains(directory)) {\n                    TarArchiveEntry entry = new TarArchiveEntry(directory, true);\n                    entry.setUserName(user);\n                    entry.setUserId(uid);\n                    entry.setGroupName(group);\n                    entry.setGroupId(gid);\n                    entry.setMode(mode);\n                    entry.setSize(size);\n\n                    if (outputTimestampMs != null) {\n                        entry.setModTime(outputTimestampMs);\n                    }\n\n                    tarOutputStream.putArchiveEntry(entry);\n                    tarOutputStream.closeArchiveEntry();\n                    addedDirectories.add(directory); // so addedDirectories consistently have \"/\" for finding duplicates.\n                }\n            }\n\n            private void createParentDirectories( String filename, String user, long uid, String group, long gid ) throws IOException {\n                String dirname = fixPathTar(new File(filename).getParent());\n\n                // Debian packages must have parent directories created\n                // before sub-directories or files can be installed.\n                // For example, if an entry of ./usr/lib/foo/bar existed\n                // in a .deb package, but the ./usr/lib/foo directory didn't\n                // exist, the package installation would fail.  The .deb must\n                // then have an entry for ./usr/lib/foo and then ./usr/lib/foo/bar\n\n                if (dirname == null) {\n                    return;\n                }\n\n                // The loop below will create entries for all parent directories\n                // to ensure that .deb packages will install correctly.\n                String[] pathParts = dirname.split(\"/\");\n                String parentDir = \"./\";\n                for (int i = 1; i < pathParts.length; i++) {\n                    parentDir += pathParts[i] + \"/\";\n                    // Make it so the dirs can be traversed by users.\n                    // We could instead try something more granular, like setting the directory\n                    // permission to 'rx' for each of the 3 user/group/other read permissions\n                    // found on the file being added (ie, only if \"other\" has read\n                    // permission on the main node, then add o+rx permission on all the containing\n                    // directories, same w/ user & group), and then also we'd have to\n                    // check the parentDirs collection of those already added to\n                    // see if those permissions need to be similarly updated.  (Note, it hasn't\n                    // been demonstrated, but there might be a bug if a user specifically\n                    // requests a directory with certain permissions,\n                    // that has already been auto-created because it was a parent, and if so, go set\n                    // the user-requested mode on that directory instead of this automatic one.)\n                    // But for now, keeping it simple by making every dir a+rx.   Examples are:\n                    // drw-r----- fs/fs   # what you get with setMode(mode)\n                    // drwxr-xr-x fs/fs   # Usable. Too loose?\n                    int mode = TarArchiveEntry.DEFAULT_DIR_MODE;\n\n                    createDirectory(parentDir, user, uid, group, gid, mode, 0);\n                }\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } finally {\n            tarOutputStream.close();\n        }\n\n        console.debug(\"Total size: \" + dataSize);\n\n        return dataSize.count;\n    }\n\n    private String fixPathBase( String path ) {\n        if (path == null || path.equals(\".\")) {\n            return path;\n        }\n\n        // If we're receiving directory names from Windows, then we'll convert to use slash\n        // This does eliminate the ability to use of a backslash in a directory name on *NIX,\n        // but in practice, this is a non-issue\n        if (path.contains(\"\\\\\")) {\n            path = path.replace('\\\\', '/');\n        }\n        return path;\n    }\n\n    private String fixPathTar( String path ) {\n        if (path == null || path.equals(\".\")) {\n            return path;\n        }\n\n        path = fixPathBase(path);\n\n        // ensure the path is like : ./foo/bar\n        if (path.startsWith(\"/\")) {\n            path = \".\" + path;\n        } else if (!path.startsWith(\"./\")) {\n            path = \"./\" + path;\n        }\n        return path;\n    }\n\n    private String fixPathMd5( String path ) {\n        if (path == null || path.equals(\".\")) {\n            return path;\n        }\n\n        path = fixPathBase(path);\n\n        // ensure the path is like : foo/bar\n        if (path.startsWith(\"/\")) {\n            path = path.substring(1);\n        } else if (path.startsWith(\"./\")) {\n            path = path.substring(2);\n        }\n        return path;\n    }\n\n}\n","lineNo":65}
{"Smelly Sample":"/*\n * Copyright 2007-2018 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.tools.ant.types.selectors.SelectorUtils;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.mapping.Mapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\n/**\n * Base Producer class providing including/excluding.\n */\npublic abstract class AbstractDataProducer implements DataProducer {\n\n    private final String[] includes;\n    private final String[] excludes;\n    private final Mapper[] mappers;\n\n\n    public AbstractDataProducer( final String[] pIncludes, final String[] pExcludes, final Mapper[] pMapper ) {\n        excludes = (pExcludes != null) ? pExcludes : new String[0];\n        includes = (pIncludes != null) ? pIncludes : new String[] { \"**\" };\n        mappers = (pMapper != null) ? pMapper : new Mapper[0];\n    }\n\n    public boolean isIncluded( final String pName ) {\n        if (!isIncluded(pName, includes)) {\n            return false;\n        }\n        if (isExcluded(pName, excludes)) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean isIncluded( String name, String[] includes ) {\n        for (String include : includes) {\n            if (SelectorUtils.matchPath(include, name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    private boolean isExcluded( String name, String[] excludes ) {\n        for (String exclude : excludes) {\n            if (SelectorUtils.matchPath(exclude, name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void produceDir( final DataConsumer consumer,\n                            final String dirName ) throws IOException {\n        TarArchiveEntry entry = Producers.defaultDirEntryWithName(dirName);\n        entry = map(entry);\n        entry.setSize(0);\n        Producers.produceDirEntry(consumer, entry);\n    }\n\n    public void produceFile( final DataConsumer consumer,\n                             final File file,\n                             final String fileName ) throws IOException {\n        TarArchiveEntry fileEntry = Producers.defaultFileEntryWithName(fileName);\n        fileEntry.setSize(file.length());\n        fileEntry = map(fileEntry);\n        Producers.produceInputStreamWithEntry(consumer, new FileInputStream(file), fileEntry);\n    }\n\n    public TarArchiveEntry map( final TarArchiveEntry pEntry ) {\n\n        TarArchiveEntry entry = pEntry;\n\n        for (Mapper mapper : mappers) {\n            entry = mapper.map(entry);\n        }\n\n        return entry;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2007-2018 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.tools.ant.types.selectors.SelectorUtils;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.mapping.Mapper;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\n/**\n * Base Producer class providing including/excluding.\n */\npublic abstract class AbstractDataProducer implements DataProducer {\n\n    private final String[] includes;\n    private final String[] excludes;\n    private final Mapper[] mappers;\n\n\n    public AbstractDataProducer( final String[] pIncludes, final String[] pExcludes, final Mapper[] pMapper ) {\n        excludes = (pExcludes != null) ? pExcludes : new String[0];\n        includes = (pIncludes != null) ? pIncludes : new String[] { \"**\" };\n        mappers = (pMapper != null) ? pMapper : new Mapper[0];\n    }\n\n    public boolean isIncluded( final String pName ) {\n        if (!isIncluded(pName, includes)) {\n            return false;\n        }\n        if (isExcluded(pName, excludes)) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean isIncluded( String name, String[] includes ) {\n        for (String include : includes) {\n            if (SelectorUtils.matchPath(include, name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    private boolean isExcluded( String name, String[] excludes ) {\n        for (String exclude : excludes) {\n            if (SelectorUtils.matchPath(exclude, name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void produceDir( final DataConsumer consumer,\n                            final String dirName ) throws IOException {\n        final String name = dirName.endsWith(\"/\") ? dirName : dirName + \"/\";\n        TarArchiveEntry entry = Producers.defaultDirEntryWithName(name);\n        entry = map(entry);\n        entry.setSize(0);\n        Producers.produceDirEntry(consumer, entry);\n    }\n\n    public void produceFile( final DataConsumer consumer,\n                             final File file,\n                             final String fileName ) throws IOException {\n        TarArchiveEntry fileEntry = Producers.defaultFileEntryWithName(fileName);\n        fileEntry.setSize(file.length());\n        fileEntry = map(fileEntry);\n        Producers.produceInputStreamWithEntry(consumer, new FileInputStream(file), fileEntry);\n    }\n\n    public TarArchiveEntry map( final TarArchiveEntry pEntry ) {\n\n        TarArchiveEntry entry = pEntry;\n\n        for (Mapper mapper : mappers) {\n            entry = mapper.map(entry);\n        }\n\n        return entry;\n    }\n}\n","lineNo":75}
{"Smelly Sample":"package org.vafer.jdeb.producers;\n\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.argThat;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.Assert;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.hamcrest.BaseMatcher;\nimport org.hamcrest.Description;\nimport org.vafer.jdeb.DataConsumer;\n\n/**\n * Tests for {@link org.vafer.jdeb.producers.DataProducerFiles}.\n */\npublic final class DataProducerFilesTestCase extends Assert {\n\n    File file1;\n    File file2;\n\n    @Before\n    public void setUp() throws Exception {\n        file1 = File.createTempFile(getClass().getSimpleName() + \".1\", \"txt\");\n        file2 = File.createTempFile(getClass().getSimpleName() + \".2\", \"txt\");\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        file1.delete();\n        file2.delete();\n    }\n\n    @Test\n    public void testProducesMultiplePaths() throws IOException {\n        DataConsumer consumer = mock(DataConsumer.class);\n        new DataProducerFiles(\n                new String[]{\n                        file1.getAbsolutePath(),\n                        file2.getAbsolutePath()\n                },\n                \"/usr/include\",\n                null\n        ).produce(consumer);\n\n        for (final File f : Arrays.asList(file1, file2)) {\n            verify(consumer).onEachFile(\n                    any(FileInputStream.class),\n                    argThat(new BaseMatcher<TarArchiveEntry>() {\n                        public boolean matches(final Object o) {\n                            if (!(o instanceof TarArchiveEntry)) {\n                                return false;\n                            }\n                            final TarArchiveEntry e = (TarArchiveEntry) o;\n\n                            System.out.println(\"f.size:\" + f.length());\n                            System.out.println(\"e.size:\" + e.getSize());\n\n                            System.out.println(\"f.name:\" + \"/usr/include/\" + f.getName());\n                            System.out.println(\"e.name:\" + e.getName());\n\n                            System.out.println(\"e.uid:\" + e.getLongUserId());\n                            System.out.println(\"e.gid:\" + e.getLongGroupId());\n\n                            System.out.println(\"e.uid:\" + e.getUserName());\n                            System.out.println(\"e.gid:\" + e.getGroupName());\n\n                            boolean matches =\n                                   e.getSize() == f.length()\n                                && e.getLongGroupId() == 0\n                                && e.getLongUserId() == 0\n                                && \"root\".equals(e.getUserName())\n                                && \"root\".equals(e.getGroupName())\n                                && (\"/usr/include/\" + f.getName()).equals(e.getName())\n                                   ;\n\n                            System.out.println(\"matches:\" + matches);\n\n                            return matches;\n                        }\n\n                        public void describeTo(final Description description) {\n                        }\n                    })\n            );\n        }\n    }\n\n    @Test\n    public void testProducesMultiplePathsNoDestination() throws IOException {\n        DataConsumer consumer = mock(DataConsumer.class);\n        new DataProducerFiles(\n                new String[]{\n                        file1.getAbsolutePath(),\n                        file2.getAbsolutePath()\n                },\n                null,\n                null\n        ).produce(consumer);\n\n        for (final File f : Arrays.asList(file1, file2)) {\n            verify(consumer).onEachFile(\n                    any(FileInputStream.class),\n                    argThat(new BaseMatcher<TarArchiveEntry>() {\n                        public boolean matches(final Object o) {\n                            if (!(o instanceof TarArchiveEntry)) {\n                                return false;\n                            }\n                            final TarArchiveEntry e = (TarArchiveEntry) o;\n\n                            // Turns out compress is stripping the drive letter\n                            // https://github.com/apache/commons-compress/blob/master/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java#L1337\n                            // Which is bad - but needs to be fixed there.\n                            // We have to work around in the test for now.\n                            final String s = f.getAbsolutePath().replace(File.separator, \"/\").replace(\"C:/\", \"/\");\n\n                            return e.getSize() == f.length()\n                                    && e.getLongGroupId() == 0\n                                    && e.getLongUserId() == 0\n                                    && \"root\".equals(e.getUserName())\n                                    && \"root\".equals(e.getGroupName())\n                                    && s.equals(e.getName())\n                                    ;\n                        }\n\n                        public void describeTo(final Description description) {\n                        }\n                    })\n            );\n        }\n    }\n}\n","Method after Refactoring":"package org.vafer.jdeb.producers;\n\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.argThat;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.Assert;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.hamcrest.BaseMatcher;\nimport org.hamcrest.Description;\nimport org.vafer.jdeb.DataConsumer;\n\n/**\n * Tests for {@link org.vafer.jdeb.producers.DataProducerFiles}.\n */\npublic final class DataProducerFilesTestCase extends Assert {\n\n    File file1;\n    File file2;\n\n    @Before\n    public void setUp() throws Exception {\n        file1 = File.createTempFile(getClass().getSimpleName() + \".1\", \"txt\");\n        file2 = File.createTempFile(getClass().getSimpleName() + \".2\", \"txt\");\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        file1.delete();\n        file2.delete();\n    }\n\n    @Test\n    public void testProducesMultiplePaths() throws IOException {\n        DataConsumer consumer = mock(DataConsumer.class);\n        new DataProducerFiles(\n                new String[]{\n                        file1.getAbsolutePath(),\n                        file2.getAbsolutePath()\n                },\n                \"/usr/include\",\n                null\n        ).produce(consumer);\n\n        for (final File f : Arrays.asList(file1, file2)) {\n            verify(consumer).onEachFile(\n                    any(FileInputStream.class),\n                    argThat(new BaseMatcher<TarArchiveEntry>() {\n                        public boolean matches(final Object o) {\n                            if (!(o instanceof TarArchiveEntry)) {\n                                return false;\n                            }\n                            final TarArchiveEntry e = (TarArchiveEntry) o;\n\n                            final String name = \"/usr/include/\" + f.getName();\n\n                            boolean matches =\n                                   e.getSize() == f.length()\n                                && e.getLongGroupId() == 0\n                                && e.getLongUserId() == 0\n                                && \"root\".equals(e.getUserName())\n                                && \"root\".equals(e.getGroupName())\n                                && name.equals(e.getName())\n                                   ;\n\n                            System.out.println(\"matches:\" + matches);\n\n                            return matches;\n                        }\n\n                        public void describeTo(final Description description) {\n                        }\n                    })\n            );\n        }\n    }\n\n    @Test\n    public void testProducesMultiplePathsNoDestination() throws IOException {\n        DataConsumer consumer = mock(DataConsumer.class);\n        new DataProducerFiles(\n                new String[]{\n                        file1.getAbsolutePath(),\n                        file2.getAbsolutePath()\n                },\n                null,\n                null\n        ).produce(consumer);\n\n        for (final File f : Arrays.asList(file1, file2)) {\n            verify(consumer).onEachFile(\n                    any(FileInputStream.class),\n                    argThat(new BaseMatcher<TarArchiveEntry>() {\n                        public boolean matches(final Object o) {\n                            if (!(o instanceof TarArchiveEntry)) {\n                                return false;\n                            }\n                            final TarArchiveEntry e = (TarArchiveEntry) o;\n\n                            // Turns out compress is stripping the drive letter\n                            // https://github.com/apache/commons-compress/blob/master/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java#L1337\n                            // Which is bad - but needs to be fixed there.\n                            // We have to work around in the test for now.\n                            final String name  = f.getAbsolutePath().replace(File.separator, \"/\").replace(\"C:/\", \"/\");\n\n                            boolean matches =\n                                   e.getSize() == f.length()\n                                && e.getLongGroupId() == 0\n                                && e.getLongUserId() == 0\n                                && \"root\".equals(e.getUserName())\n                                && \"root\".equals(e.getGroupName())\n                                && name.equals(e.getName())\n                                ;\n\n                            System.out.println(\"matches:\" + matches);\n\n                            if (!matches) {\n                                System.out.println(\"f.size:\" + f.length());\n                                System.out.println(\"e.size:\" + e.getSize());\n\n                                System.out.println(\"f.name:\" + name);\n                                System.out.println(\"e.name:\" + e.getName());\n\n                                System.out.println(\"e.uid:\" + e.getLongUserId());\n                                System.out.println(\"e.gid:\" + e.getLongGroupId());\n\n                                System.out.println(\"e.uid:\" + e.getUserName());\n                                System.out.println(\"e.gid:\" + e.getGroupName());\n                            }\n\n                            return matches;\n                        }\n\n                        public void describeTo(final Description description) {\n                        }\n                    })\n            );\n        }\n    }\n}\n","lineNo":65}
{"Smelly Sample":"/*\n * Copyright 2016 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarConstants;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.compressors.CompressorException;\nimport org.vafer.jdeb.utils.Utils;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Builds the data archive of the Debian package.\n */\nclass DataBuilder {\n\n    private Console console;\n\n    private ZipEncoding encoding;\n\n    private static final class Total {\n        private BigInteger count = BigInteger.valueOf(0);\n\n        public void add( long size ) {\n            count = count.add(BigInteger.valueOf(size));\n        }\n\n        public String toString() {\n            return \"\" + count;\n        }\n    }\n\n    DataBuilder(Console console) {\n        this.console = console;\n        this.encoding = ZipEncodingHelper.getZipEncoding(null);\n    }\n\n    private void checkField(String name, int length) throws IOException {\n        if (name != null) {\n            ByteBuffer b = encoding.encode(name);\n            if (b.limit() > length) {\n                throw new IllegalArgumentException(\"Field '\" + name + \"' too long, maximum is \" + length);\n            }\n        }\n    }\n\n    /**\n     * Build the data archive of the deb from the provided DataProducers\n     *\n     * @param producers\n     * @param output\n     * @param checksums\n     * @param options Options used to build the data file\n     * @return\n     * @throws java.security.NoSuchAlgorithmException\n     * @throws java.io.IOException\n     * @throws org.apache.commons.compress.compressors.CompressorException\n     */\n    BigInteger buildData(Collection<DataProducer> producers, File output, final StringBuilder checksums, TarOptions options) throws NoSuchAlgorithmException, IOException, CompressorException {\n\n        final File dir = output.getParentFile();\n        if (dir != null && (!dir.exists() || !dir.isDirectory())) {\n            throw new IOException(\"Cannot write data file at '\" + output.getAbsolutePath() + \"'\");\n        }\n\n        final TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(\n            options.compression().toCompressedOutputStream(new FileOutputStream(output))\n        );\n        tarOutputStream.setLongFileMode(options.longFileMode());\n        tarOutputStream.setBigNumberMode(options.bigNumberMode());\n\n        final MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\n        final Total dataSize = new Total();\n\n        final List<String> addedDirectories = new ArrayList<String>();\n        final DataConsumer receiver = new DataConsumer() {\n\n            public void onEachDir(TarArchiveEntry dirEntry) throws IOException {\n                // Check link name\n                checkField(dirEntry.getLinkName(), TarConstants.NAMELEN);\n                // Check user name\n                checkField(dirEntry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(dirEntry.getUserName(), TarConstants.GNAMELEN);\n\n                dirEntry.setName(fixPath(dirEntry.getName()));\n\n                createParentDirectories(dirEntry.getName(), dirEntry.getUserName(), dirEntry.getLongUserId(), dirEntry.getGroupName(), dirEntry.getLongGroupId());\n\n                // The directory passed in explicitly by the caller also gets the passed-in mode.  (Unlike\n                // the parent directories for now.  See related comments at \"int mode =\" in\n                // createParentDirectories, including about a possible bug.)\n                createDirectory(dirEntry.getName(), dirEntry.getUserName(), dirEntry.getLongUserId(), dirEntry.getGroupName(), dirEntry.getLongGroupId(), dirEntry.getMode(), 0);\n\n                console.debug(\"dir: \" + dirEntry.getName());\n            }\n\n            public void onEachFile(InputStream input, TarArchiveEntry fileEntry) throws IOException {\n                // Check link name\n                checkField(fileEntry.getLinkName(), TarConstants.NAMELEN);\n                // Check user name\n                checkField(fileEntry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(fileEntry.getGroupName(), TarConstants.GNAMELEN);\n\n                fileEntry.setName(fixPath(fileEntry.getName()));\n\n                createParentDirectories(fileEntry.getName(), fileEntry.getUserName(), fileEntry.getLongUserId(), fileEntry.getGroupName(), fileEntry.getLongGroupId());\n\n                tarOutputStream.putArchiveEntry(fileEntry);\n\n                dataSize.add(fileEntry.getSize());\n                digest.reset();\n\n                Utils.copy(input, new DigestOutputStream(tarOutputStream, digest));\n\n                final String md5 = Utils.toHex(digest.digest());\n\n                tarOutputStream.closeArchiveEntry();\n\n                console.debug(\n                    \"file:\" + fileEntry.getName() +\n                        \" size:\" + fileEntry.getSize() +\n                        \" mode:\" + fileEntry.getMode() +\n                        \" linkname:\" + fileEntry.getLinkName() +\n                        \" username:\" + fileEntry.getUserName() +\n                        \" userid:\" + fileEntry.getLongUserId() +\n                        \" groupname:\" + fileEntry.getGroupName() +\n                        \" groupid:\" + fileEntry.getLongGroupId() +\n                        \" modtime:\" + fileEntry.getModTime() +\n                        \" md5: \" + md5\n                );\n\n                // append to file md5 list, two spaces to be compatible with GNU coreutils md5sum\n                checksums.append(md5).append(\"  \").append(fileEntry.getName()).append('\\n');\n            }\n\n            public void onEachLink(TarArchiveEntry entry) throws IOException {\n                // Check link name\n                checkField(entry.getLinkName(), TarConstants.NAMELEN);\n                // Check user name\n                checkField(entry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(entry.getGroupName(), TarConstants.GNAMELEN);\n\n                entry.setName(fixPath(entry.getName()));\n\n                createParentDirectories(entry.getName(), entry.getUserName(), entry.getLongUserId(), entry.getGroupName(), entry.getLongGroupId());\n\n                tarOutputStream.putArchiveEntry(entry);\n                tarOutputStream.closeArchiveEntry();\n\n                console.debug(\n                    \"link:\" + entry.getName() +\n                    \" mode:\" + entry.getMode() +\n                    \" linkname:\" + entry.getLinkName() +\n                    \" username:\" + entry.getUserName() +\n                    \" userid:\" + entry.getLongUserId() +\n                    \" groupname:\" + entry.getGroupName() +\n                    \" groupid:\" + entry.getLongGroupId()\n                 );\n            }\n\n\n            private void createDirectory( String directory, String user, long uid, String group, long gid, int mode, long size ) throws IOException {\n                // All dirs should end with \"/\" when created, or the test DebAndTaskTestCase.testTarFileSet() thinks its a file\n                // and so thinks it has the wrong permission.\n                // This consistency also helps when checking if a directory already exists in addedDirectories.\n\n                if (!directory.endsWith(\"/\")) {\n                    directory += \"/\";\n                }\n\n                if (!addedDirectories.contains(directory)) {\n                    TarArchiveEntry entry = new TarArchiveEntry(directory, true);\n                    entry.setUserName(user);\n                    entry.setUserId(uid);\n                    entry.setGroupName(group);\n                    entry.setGroupId(gid);\n                    entry.setMode(mode);\n                    entry.setSize(size);\n\n                    tarOutputStream.putArchiveEntry(entry);\n                    tarOutputStream.closeArchiveEntry();\n                    addedDirectories.add(directory); // so addedDirectories consistently have \"/\" for finding duplicates.\n                }\n            }\n\n            private void createParentDirectories( String filename, String user, long uid, String group, long gid ) throws IOException {\n                String dirname = fixPath(new File(filename).getParent());\n\n                // Debian packages must have parent directories created\n                // before sub-directories or files can be installed.\n                // For example, if an entry of ./usr/lib/foo/bar existed\n                // in a .deb package, but the ./usr/lib/foo directory didn't\n                // exist, the package installation would fail.  The .deb must\n                // then have an entry for ./usr/lib/foo and then ./usr/lib/foo/bar\n\n                if (dirname == null) {\n                    return;\n                }\n\n                // The loop below will create entries for all parent directories\n                // to ensure that .deb packages will install correctly.\n                String[] pathParts = dirname.split(\"/\");\n                String parentDir = \"./\";\n                for (int i = 1; i < pathParts.length; i++) {\n                    parentDir += pathParts[i] + \"/\";\n                    // Make it so the dirs can be traversed by users.\n                    // We could instead try something more granular, like setting the directory\n                    // permission to 'rx' for each of the 3 user/group/other read permissions\n                    // found on the file being added (ie, only if \"other\" has read\n                    // permission on the main node, then add o+rx permission on all the containing\n                    // directories, same w/ user & group), and then also we'd have to\n                    // check the parentDirs collection of those already added to\n                    // see if those permissions need to be similarly updated.  (Note, it hasn't\n                    // been demonstrated, but there might be a bug if a user specifically\n                    // requests a directory with certain permissions,\n                    // that has already been auto-created because it was a parent, and if so, go set\n                    // the user-requested mode on that directory instead of this automatic one.)\n                    // But for now, keeping it simple by making every dir a+rx.   Examples are:\n                    // drw-r----- fs/fs   # what you get with setMode(mode)\n                    // drwxr-xr-x fs/fs   # Usable. Too loose?\n                    int mode = TarArchiveEntry.DEFAULT_DIR_MODE;\n\n                    createDirectory(parentDir, user, uid, group, gid, mode, 0);\n                }\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } finally {\n            tarOutputStream.close();\n        }\n\n        console.debug(\"Total size: \" + dataSize);\n\n        return dataSize.count;\n    }\n\n    private String fixPath( String path ) {\n        if (path == null || path.equals(\".\")) {\n            return path;\n        }\n\n        // If we're receiving directory names from Windows, then we'll convert to use slash\n        // This does eliminate the ability to use of a backslash in a directory name on *NIX,\n        // but in practice, this is a non-issue\n        if (path.contains(\"\\\\\")) {\n            path = path.replace('\\\\', '/');\n        }\n        // ensure the path is like : ./foo/bar\n        if (path.startsWith(\"/\")) {\n            path = \".\" + path;\n        } else if (!path.startsWith(\"./\")) {\n            path = \"./\" + path;\n        }\n        return path;\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2016 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarConstants;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\nimport org.apache.commons.compress.compressors.CompressorException;\nimport org.vafer.jdeb.utils.Utils;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Builds the data archive of the Debian package.\n */\nclass DataBuilder {\n\n    private Console console;\n\n    private ZipEncoding encoding;\n\n    private static final class Total {\n        private BigInteger count = BigInteger.valueOf(0);\n\n        public void add( long size ) {\n            count = count.add(BigInteger.valueOf(size));\n        }\n\n        public String toString() {\n            return \"\" + count;\n        }\n    }\n\n    DataBuilder(Console console) {\n        this.console = console;\n        this.encoding = ZipEncodingHelper.getZipEncoding(null);\n    }\n\n    private void checkField(String name, int length) throws IOException {\n        if (name != null) {\n            ByteBuffer b = encoding.encode(name);\n            if (b.limit() > length) {\n                throw new IllegalArgumentException(\"Field '\" + name + \"' too long, maximum is \" + length);\n            }\n        }\n    }\n\n    /**\n     * Build the data archive of the deb from the provided DataProducers\n     *\n     * @param producers\n     * @param output\n     * @param checksums\n     * @param options Options used to build the data file\n     * @return\n     * @throws java.security.NoSuchAlgorithmException\n     * @throws java.io.IOException\n     * @throws org.apache.commons.compress.compressors.CompressorException\n     */\n    BigInteger buildData(Collection<DataProducer> producers, File output, final StringBuilder checksums, TarOptions options) throws NoSuchAlgorithmException, IOException, CompressorException {\n\n        final File dir = output.getParentFile();\n        if (dir != null && (!dir.exists() || !dir.isDirectory())) {\n            throw new IOException(\"Cannot write data file at '\" + output.getAbsolutePath() + \"'\");\n        }\n\n        final TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(\n            options.compression().toCompressedOutputStream(new FileOutputStream(output))\n        );\n        tarOutputStream.setLongFileMode(options.longFileMode());\n        tarOutputStream.setBigNumberMode(options.bigNumberMode());\n\n        final MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\n        final Total dataSize = new Total();\n\n        final List<String> addedDirectories = new ArrayList<String>();\n        final DataConsumer receiver = new DataConsumer() {\n\n            public void onEachDir(TarArchiveEntry dirEntry) throws IOException {\n                // Check link name\n                checkField(dirEntry.getLinkName(), TarConstants.NAMELEN);\n                // Check user name\n                checkField(dirEntry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(dirEntry.getUserName(), TarConstants.GNAMELEN);\n\n                dirEntry.setName(fixPathTar(dirEntry.getName()));\n\n                createParentDirectories(dirEntry.getName(), dirEntry.getUserName(), dirEntry.getLongUserId(), dirEntry.getGroupName(), dirEntry.getLongGroupId());\n\n                // The directory passed in explicitly by the caller also gets the passed-in mode.  (Unlike\n                // the parent directories for now.  See related comments at \"int mode =\" in\n                // createParentDirectories, including about a possible bug.)\n                createDirectory(dirEntry.getName(), dirEntry.getUserName(), dirEntry.getLongUserId(), dirEntry.getGroupName(), dirEntry.getLongGroupId(), dirEntry.getMode(), 0);\n\n                console.debug(\"dir: \" + dirEntry.getName());\n            }\n\n            public void onEachFile(InputStream input, TarArchiveEntry fileEntry) throws IOException {\n                // Check link name\n                checkField(fileEntry.getLinkName(), TarConstants.NAMELEN);\n                // Check user name\n                checkField(fileEntry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(fileEntry.getGroupName(), TarConstants.GNAMELEN);\n\n                // For md5sum\n                String rawFileEntryName = fileEntry.getName();\n\n                fileEntry.setName(fixPathTar(fileEntry.getName()));\n\n                createParentDirectories(fileEntry.getName(), fileEntry.getUserName(), fileEntry.getLongUserId(), fileEntry.getGroupName(), fileEntry.getLongGroupId());\n\n                tarOutputStream.putArchiveEntry(fileEntry);\n\n                dataSize.add(fileEntry.getSize());\n                digest.reset();\n\n                Utils.copy(input, new DigestOutputStream(tarOutputStream, digest));\n\n                final String md5 = Utils.toHex(digest.digest());\n\n                tarOutputStream.closeArchiveEntry();\n\n                console.debug(\n                    \"file:\" + fileEntry.getName() +\n                        \" size:\" + fileEntry.getSize() +\n                        \" mode:\" + fileEntry.getMode() +\n                        \" linkname:\" + fileEntry.getLinkName() +\n                        \" username:\" + fileEntry.getUserName() +\n                        \" userid:\" + fileEntry.getLongUserId() +\n                        \" groupname:\" + fileEntry.getGroupName() +\n                        \" groupid:\" + fileEntry.getLongGroupId() +\n                        \" modtime:\" + fileEntry.getModTime() +\n                        \" md5: \" + md5\n                );\n\n                // append to file md5 list, two spaces to be compatible with GNU coreutils md5sum\n                checksums.append(md5).append(\"  \").append(fixPathMd5(rawFileEntryName)).append('\\n');\n            }\n\n            public void onEachLink(TarArchiveEntry entry) throws IOException {\n                // Check link name\n                checkField(entry.getLinkName(), TarConstants.NAMELEN);\n                // Check user name\n                checkField(entry.getUserName(), TarConstants.UNAMELEN);\n                // Check group name\n                checkField(entry.getGroupName(), TarConstants.GNAMELEN);\n\n                entry.setName(fixPathTar(entry.getName()));\n\n                createParentDirectories(entry.getName(), entry.getUserName(), entry.getLongUserId(), entry.getGroupName(), entry.getLongGroupId());\n\n                tarOutputStream.putArchiveEntry(entry);\n                tarOutputStream.closeArchiveEntry();\n\n                console.debug(\n                    \"link:\" + entry.getName() +\n                    \" mode:\" + entry.getMode() +\n                    \" linkname:\" + entry.getLinkName() +\n                    \" username:\" + entry.getUserName() +\n                    \" userid:\" + entry.getLongUserId() +\n                    \" groupname:\" + entry.getGroupName() +\n                    \" groupid:\" + entry.getLongGroupId()\n                 );\n            }\n\n\n            private void createDirectory( String directory, String user, long uid, String group, long gid, int mode, long size ) throws IOException {\n                // All dirs should end with \"/\" when created, or the test DebAndTaskTestCase.testTarFileSet() thinks its a file\n                // and so thinks it has the wrong permission.\n                // This consistency also helps when checking if a directory already exists in addedDirectories.\n\n                if (!directory.endsWith(\"/\")) {\n                    directory += \"/\";\n                }\n\n                if (!addedDirectories.contains(directory)) {\n                    TarArchiveEntry entry = new TarArchiveEntry(directory, true);\n                    entry.setUserName(user);\n                    entry.setUserId(uid);\n                    entry.setGroupName(group);\n                    entry.setGroupId(gid);\n                    entry.setMode(mode);\n                    entry.setSize(size);\n\n                    tarOutputStream.putArchiveEntry(entry);\n                    tarOutputStream.closeArchiveEntry();\n                    addedDirectories.add(directory); // so addedDirectories consistently have \"/\" for finding duplicates.\n                }\n            }\n\n            private void createParentDirectories( String filename, String user, long uid, String group, long gid ) throws IOException {\n                String dirname = fixPathTar(new File(filename).getParent());\n\n                // Debian packages must have parent directories created\n                // before sub-directories or files can be installed.\n                // For example, if an entry of ./usr/lib/foo/bar existed\n                // in a .deb package, but the ./usr/lib/foo directory didn't\n                // exist, the package installation would fail.  The .deb must\n                // then have an entry for ./usr/lib/foo and then ./usr/lib/foo/bar\n\n                if (dirname == null) {\n                    return;\n                }\n\n                // The loop below will create entries for all parent directories\n                // to ensure that .deb packages will install correctly.\n                String[] pathParts = dirname.split(\"/\");\n                String parentDir = \"./\";\n                for (int i = 1; i < pathParts.length; i++) {\n                    parentDir += pathParts[i] + \"/\";\n                    // Make it so the dirs can be traversed by users.\n                    // We could instead try something more granular, like setting the directory\n                    // permission to 'rx' for each of the 3 user/group/other read permissions\n                    // found on the file being added (ie, only if \"other\" has read\n                    // permission on the main node, then add o+rx permission on all the containing\n                    // directories, same w/ user & group), and then also we'd have to\n                    // check the parentDirs collection of those already added to\n                    // see if those permissions need to be similarly updated.  (Note, it hasn't\n                    // been demonstrated, but there might be a bug if a user specifically\n                    // requests a directory with certain permissions,\n                    // that has already been auto-created because it was a parent, and if so, go set\n                    // the user-requested mode on that directory instead of this automatic one.)\n                    // But for now, keeping it simple by making every dir a+rx.   Examples are:\n                    // drw-r----- fs/fs   # what you get with setMode(mode)\n                    // drwxr-xr-x fs/fs   # Usable. Too loose?\n                    int mode = TarArchiveEntry.DEFAULT_DIR_MODE;\n\n                    createDirectory(parentDir, user, uid, group, gid, mode, 0);\n                }\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } finally {\n            tarOutputStream.close();\n        }\n\n        console.debug(\"Total size: \" + dataSize);\n\n        return dataSize.count;\n    }\n\n    private String fixPathBase( String path ) {\n        if (path == null || path.equals(\".\")) {\n            return path;\n        }\n\n        // If we're receiving directory names from Windows, then we'll convert to use slash\n        // This does eliminate the ability to use of a backslash in a directory name on *NIX,\n        // but in practice, this is a non-issue\n        if (path.contains(\"\\\\\")) {\n            path = path.replace('\\\\', '/');\n        }\n        return path;\n    }\n\n    private String fixPathTar( String path ) {\n        if (path == null || path.equals(\".\")) {\n            return path;\n        }\n\n        path = fixPathBase(path);\n\n        // ensure the path is like : ./foo/bar\n        if (path.startsWith(\"/\")) {\n            path = \".\" + path;\n        } else if (!path.startsWith(\"./\")) {\n            path = \"./\" + path;\n        }\n        return path;\n    }\n\n    private String fixPathMd5( String path ) {\n        if (path == null || path.equals(\".\")) {\n            return path;\n        }\n\n        path = fixPathBase(path);\n\n        // ensure the path is like : foo/bar\n        if (path.startsWith(\"/\")) {\n            path = path.substring(1);\n        } else if (path.startsWith(\"./\")) {\n            path = path.substring(2);\n        }\n        return path;\n    }\n\n}\n","lineNo":136}
{"Smelly Sample":"/*\n * Copyright 2016 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.bouncycastle.bcpg.HashAlgorithmTags;\nimport org.bouncycastle.crypto.digests.MD5Digest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.signing.PGPSigner;\nimport org.vafer.jdeb.utils.PGPSignatureOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\n/**\n * A generic class for creating Debian archives. Even supports signed changes\n * files.\n */\npublic class DebMaker {\n\n    /** A console to output log message with */\n    private Console console;\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The name of the package. Default value if not specified in the control file */\n    private String packageName;\n\n    /** The section of the package. Default value if not specified in the control file */\n    private String section = \"java\";\n\n    /** The dependencies of the package. */\n    private String depends;\n\n    /** The description of the package. Default value if not specified in the control file */\n    private String description;\n\n    /** The homepage of the application. Default value if not specified in the control file */\n    private String homepage;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip, bzip2 or xz) */\n    private String compression = \"gzip\";\n\n    /** Whether to sign the package that is created */\n    private boolean signPackage;\n\n    /** Whether to sign the changes file that is created */\n    private boolean signChanges;\n\n    /** Defines which utility is used to verify the signed package */\n    private String signMethod;\n\n    /** Defines the role to sign with */\n    private String signRole;\n\n    private VariableResolver variableResolver;\n    private String openReplaceToken;\n    private String closeReplaceToken;\n\n    private final Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    private final Collection<DataProducer> conffilesProducers = new ArrayList<DataProducer>();\n    private String digest = \"SHA1\";\n\n    public DebMaker(Console console, Collection<DataProducer> dataProducers, Collection<DataProducer> conffileProducers) {\n        this.console = console;\n        if (dataProducers != null) {\n            this.dataProducers.addAll(dataProducers);\n        }\n        if (conffileProducers != null) {\n            this.conffilesProducers.addAll(conffileProducers);\n        }\n\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    public void setDeb(File deb) {\n        this.deb = deb;\n    }\n\n    public void setControl(File control) {\n        this.control = control;\n    }\n\n    public void setPackage(String packageName) {\n        this.packageName = packageName;\n    }\n\n    public void setSection(String section) {\n        this.section = section;\n    }\n\n    public void setDepends(String depends) {\n        this.depends = depends;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public void setHomepage(String homepage) {\n        this.homepage = homepage;\n    }\n\n    public void setChangesIn(File changes) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut(File changes) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave(File changes) {\n        this.changesSave = changes;\n    }\n\n    public void setSignPackage(boolean signPackage) {\n        this.signPackage = signPackage;\n    }\n\n    public void setSignChanges(boolean signChanges) {\n        this.signChanges = signChanges;\n    }\n\n    public void setSignMethod(String signMethod) {\n        this.signMethod = signMethod;\n    }\n\n    public void setSignRole(String signRole) {\n        this.signRole = signRole;\n    }\n\n    public void setKeyring(File keyring) {\n        this.keyring = keyring;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void setPassphrase(String passphrase) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression(String compression) {\n        this.compression = compression;\n    }\n\n    public void setResolver(VariableResolver variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    private boolean isWritableFile(File file) {\n        return !file.exists() || file.isFile() && file.canWrite();\n    }\n\n    public String getDigest() {\n        return digest;\n    }\n\n    public void setDigest(String digest) {\n        this.digest = digest;\n    }\n\n    /**\n     * Validates the input parameters.\n     */\n    public void validate() throws PackagingException {\n        if (control == null || !control.isDirectory()) {\n            throw new PackagingException(\"The 'control' attribute doesn't point to a directory. \" + control);\n        }\n\n        if (changesIn != null) {\n\n            if (changesIn.exists() && (!changesIn.isFile() || !changesIn.canRead())) {\n                throw new PackagingException(\"The 'changesIn' setting needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n\n            if (changesOut != null && !isWritableFile(changesOut)) {\n                throw new PackagingException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isWritableFile(changesSave)) {\n                throw new PackagingException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new PackagingException(\"The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new PackagingException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip', 'bzip2' or 'xz')\");\n        }\n\n        if (deb == null) {\n            throw new PackagingException(\"You need to specify where the deb file is supposed to be created.\");\n        }\n\n        getDigestCode(digest);\n    }\n\n    static int getDigestCode(String digestName) throws PackagingException {\n        if (\"SHA1\".equals(digestName)) {\n            return HashAlgorithmTags.SHA1;\n        } else if (\"MD2\".equals(digestName)) {\n            return HashAlgorithmTags.MD2;\n        } else if (\"MD5\".equals(digestName)) {\n            return HashAlgorithmTags.MD5;\n        } else if (\"RIPEMD160\".equals(digestName)) {\n            return HashAlgorithmTags.RIPEMD160;\n        } else if (\"SHA256\".equals(digestName)) {\n            return HashAlgorithmTags.SHA256;\n        } else if (\"SHA384\".equals(digestName)) {\n            return HashAlgorithmTags.SHA384;\n        } else if (\"SHA512\".equals(digestName)) {\n            return HashAlgorithmTags.SHA512;\n        } else if (\"SHA224\".equals(digestName)) {\n            return HashAlgorithmTags.SHA224;\n        } else {\n            throw new PackagingException(\"unknown hash algorithm tag in digestName: \" + digestName);\n        }\n    }\n\n    public void makeDeb() throws PackagingException {\n        BinaryPackageControlFile packageControlFile;\n        try {\n            console.info(\"Creating debian package: \" + deb);\n\n            // If we should sign the package\n            boolean doSign = signPackage;\n\n            if (doSign) {\n\n                if (keyring == null || !keyring.exists()) {\n                    doSign = false;\n                    console.warn(\"Signing requested, but no keyring supplied\");\n                }\n\n                if (key == null) {\n                    doSign = false;\n                    console.warn(\"Signing requested, but no key supplied\");\n                }\n\n                if (passphrase == null) {\n                    doSign = false;\n                    console.warn(\"Signing requested, but no passphrase supplied\");\n                }\n\n                FileInputStream keyRingInput = new FileInputStream(keyring);\n                PGPSigner signer = null;\n                try {\n                    signer = new PGPSigner(new FileInputStream(keyring), key, passphrase, getDigestCode(digest));\n                } finally {\n                    keyRingInput.close();\n                }\n\n                PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(signer.getSecretKey().getPublicKey().getAlgorithm(), getDigestCode(digest)));\n                signatureGenerator.init(PGPSignature.BINARY_DOCUMENT, signer.getPrivateKey());\n\n                packageControlFile = createSignedDeb(Compression.toEnum(compression), signatureGenerator, signer);\n            } else {\n                packageControlFile = createDeb(Compression.toEnum(compression));\n            }\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create debian package \" + deb, e);\n        }\n\n        makeChangesFiles(packageControlFile);\n    }\n\n    private void makeChangesFiles(final BinaryPackageControlFile packageControlFile) throws PackagingException {\n        if (changesOut == null) {\n            changesOut = new File(deb.getParentFile(), deb.getName().replace(\".deb\", \".changes\"));\n        }\n\n        ChangesProvider changesProvider;\n        FileOutputStream out = null;\n\n        try {\n            console.info(\"Creating changes file: \" + changesOut);\n\n            out = new FileOutputStream(changesOut);\n\n            if (changesIn != null && changesIn.exists()) {\n                // read the changes form a textfile provider\n                changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            } else {\n                // create an empty changelog\n                changesProvider = new ChangesProvider() {\n                    public ChangeSet[] getChangesSets() {\n                        return new ChangeSet[] {\n                                new ChangeSet(packageControlFile.get(\"Package\"),\n                                        packageControlFile.get(\"Version\"),\n                                        new Date(),\n                                        packageControlFile.get(\"Distribution\"),\n                                        packageControlFile.get(\"Urgency\"),\n                                        packageControlFile.get(\"Maintainer\"),\n                                        new String[0])\n                        };\n                    }\n                };\n            }\n\n            ChangesFileBuilder builder = new ChangesFileBuilder();\n            ChangesFile changesFile = builder.createChanges(packageControlFile, deb, changesProvider);\n\n            //(signChanges || signPackage) - for backward compatibility. signPackage is signing both changes and deb.\n            if ((signChanges || signPackage) && keyring != null && key != null && passphrase != null) {\n                console.info(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase, getDigestCode(digest));\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n\n        if (changesSave == null || !(changesProvider instanceof TextfileChangesProvider)) {\n            return;\n        }\n\n        try {\n            console.info(\"Saving changes to file: \" + changesSave);\n\n            ((TextfileChangesProvider) changesProvider).save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n\n    private List<String> populateConffiles(Collection<DataProducer> producers) {\n        final List<String> result = new ArrayList<String>();\n\n        if (producers == null || producers.isEmpty()) {\n            return result;\n        }\n\n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachFile(InputStream input, TarArchiveEntry entry)  {\n                String tempConffileItem = entry.getName();\n                if (tempConffileItem.startsWith(\".\")) {\n                    tempConffileItem = tempConffileItem.substring(1);\n                }\n                console.info(\"Adding conffile: \" + tempConffileItem);\n                result.add(tempConffileItem);\n            }\n\n            public void onEachLink(TarArchiveEntry entry)  {\n            }\n\n            public void onEachDir(TarArchiveEntry tarArchiveEntry)  {\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } catch(Exception e) {\n            //\n        }\n\n        return result;\n    }\n\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file\n     * @return BinaryPackageControlFile\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createDeb(Compression compression) throws PackagingException {\n        return createSignedDeb(compression, null, null);\n    }\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @param signatureGenerator   the signature generator\n     *\n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createSignedDeb(Compression compression, final PGPSignatureGenerator signatureGenerator, PGPSigner signer ) throws PackagingException {\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.debug(\"Building data\");\n            DataBuilder dataBuilder = new DataBuilder(console);\n            StringBuilder md5s = new StringBuilder();\n            BigInteger size = dataBuilder.buildData(dataProducers, tempData, md5s, compression);\n\n            console.info(\"Building conffiles\");\n            List<String> tempConffiles = populateConffiles(conffilesProducers);\n\n            console.debug(\"Building control\");\n            ControlBuilder controlBuilder = new ControlBuilder(console, variableResolver, openReplaceToken, closeReplaceToken);\n            BinaryPackageControlFile packageControlFile = controlBuilder.createPackageControlFile(new File(control, \"control\"), size);\n            if (packageControlFile.get(\"Package\") == null) {\n                packageControlFile.set(\"Package\", packageName);\n            }\n            if (packageControlFile.get(\"Section\") == null) {\n                packageControlFile.set(\"Section\", section);\n            }\n            if (packageControlFile.get(\"Description\") == null) {\n                packageControlFile.set(\"Description\", description);\n            }\n            if (packageControlFile.get(\"Homepage\") == null) {\n                packageControlFile.set(\"Homepage\", homepage);\n            }\n\n            controlBuilder.buildControl(packageControlFile, control.listFiles(), tempConffiles , md5s, tempControl);\n\n            if (!packageControlFile.isValid()) {\n                throw new PackagingException(\"Control file fields are invalid \" + packageControlFile.invalidFields() +\n                        \". The following fields are mandatory: \" + packageControlFile.getMandatoryFields() +\n                        \". Please check your pom.xml/build.xml and your control file.\");\n            }\n\n            deb.getParentFile().mkdirs();\n\n            ArArchiveOutputStream ar = new ArArchiveOutputStream(new FileOutputStream(deb));\n\n            String binaryName = \"debian-binary\";\n            String binaryContent = \"2.0\\n\";\n            String controlName = \"control.tar.gz\";\n            String dataName = \"data.tar\" + compression.getExtension();\n\n            addTo(ar, binaryName, binaryContent);\n            addTo(ar, controlName, tempControl);\n            addTo(ar, dataName, tempData);\n\n            if (signatureGenerator != null) {\n                console.info(\"Signing package with key \" + key);\n\n                if(signRole == null) {\n                    signRole = \"origin\";\n                }\n\n                // Use debsig-verify as default\n                if(signMethod == null || !\"dpkg-sig\".equals(signMethod)) {\n                    // Sign file to verify with debsig-verify\n                    PGPSignatureOutputStream sigStream = new PGPSignatureOutputStream(signatureGenerator);\n\n                    addTo(sigStream, binaryContent);\n                    addTo(sigStream, tempControl);\n                    addTo(sigStream, tempData);\n                    addTo(ar, \"_gpg\" + signRole, sigStream.generateASCIISignature());\n\n                } else {\n\n                    // Sign file to verify with dpkg-sig --verify\n                    final String outputStr =\n                            \"Version: 4\\n\" +\n                                    \"Signer: \\n\" +\n                                    \"Date: \" + new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy\", Locale.ENGLISH).format(new Date()) + \"\\n\" +\n                                    \"Role: \" + signRole +\"\\n\" +\n                                    \"Files: \\n\" +\n                                    addFile(binaryName, binaryContent) +\n                                    addFile(controlName, tempControl) +\n                                    addFile(dataName, tempData);\n\n                    ByteArrayOutputStream message = new ByteArrayOutputStream();\n                    signer.clearSign(outputStr, message);\n\n                    addTo(ar, \"_gpg\" + signRole, message.toString());\n                }\n            }\n\n            ar.close();\n\n            return packageControlFile;\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempControl);\n                }\n            }\n        }\n    }\n\n    private String addFile(String name, String input){\n        return addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n\n    private String addFile(String name, File input){\n        return addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n\n    private String addLine(String md5, String sha1, long size, String name){\n        return \"\\t\" + md5 + \" \" + sha1 + \" \" + size + \" \" + name + \"\\n\";\n    }\n\n    private String md5Hash(String input){\n        return md5Hash(input.getBytes());\n    }\n\n    private String md5Hash(File input){\n        try {\n            return md5Hash(FileUtils.readFileToByteArray(input));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    private String md5Hash(byte input[]){\n        //update the input of MD5\n        MD5Digest md5 = new MD5Digest();\n        md5.update(input, 0, input.length);\n\n        //get the output/ digest size and hash it\n        byte[] digest = new byte[md5.getDigestSize()];\n        md5.doFinal(digest, 0);\n\n        return new String(Hex.encode(digest));\n    }\n\n    private String sha1Hash(String input){\n        return sha1Hash(input.getBytes());\n    }\n\n    private String sha1Hash(File input){\n        try {\n            return sha1Hash(FileUtils.readFileToByteArray(input));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    private String sha1Hash(byte input[]){\n        try\n        {\n            //prepare the input\n            MessageDigest hash = MessageDigest.getInstance(digest);\n            hash.update(input);\n\n            //proceed ....\n            byte[] digest = hash.digest();\n\n            return new String(Hex.encode(digest));\n        }\n        catch (NoSuchAlgorithmException e)\n        {\n            System.err.println(\"No such algorithm\");\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, File pContent) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.write(content);\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final File pContent) throws IOException {\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n    }\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2016 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.bouncycastle.bcpg.HashAlgorithmTags;\nimport org.bouncycastle.crypto.digests.MD5Digest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.signing.PGPSigner;\nimport org.vafer.jdeb.utils.PGPSignatureOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\n/**\n * A generic class for creating Debian archives. Even supports signed changes\n * files.\n */\npublic class DebMaker {\n\n    /** A console to output log message with */\n    private Console console;\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The name of the package. Default value if not specified in the control file */\n    private String packageName;\n\n    /** The section of the package. Default value if not specified in the control file */\n    private String section = \"java\";\n\n    /** The dependencies of the package. */\n    private String depends;\n\n    /** The description of the package. Default value if not specified in the control file */\n    private String description;\n\n    /** The homepage of the application. Default value if not specified in the control file */\n    private String homepage;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip, bzip2 or xz) */\n    private String compression = \"gzip\";\n\n    /** Whether to sign the package that is created */\n    private boolean signPackage;\n\n    /** Whether to sign the changes file that is created */\n    private boolean signChanges;\n\n    /** Defines which utility is used to verify the signed package */\n    private String signMethod;\n\n    /** Defines the role to sign with */\n    private String signRole;\n\n    /** Defines the longFileMode of the tar file that is built */\n    private String tarLongFileMode;\n\n    /** Defines the bigNumberMode of the tar file that is built */\n    private String tarBigNumberMode;\n\n    private VariableResolver variableResolver;\n    private String openReplaceToken;\n    private String closeReplaceToken;\n\n    private final Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    private final Collection<DataProducer> conffilesProducers = new ArrayList<DataProducer>();\n    private String digest = \"SHA1\";\n\n    public DebMaker(Console console, Collection<DataProducer> dataProducers, Collection<DataProducer> conffileProducers) {\n        this.console = console;\n        if (dataProducers != null) {\n            this.dataProducers.addAll(dataProducers);\n        }\n        if (conffileProducers != null) {\n            this.conffilesProducers.addAll(conffileProducers);\n        }\n\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    public void setDeb(File deb) {\n        this.deb = deb;\n    }\n\n    public void setControl(File control) {\n        this.control = control;\n    }\n\n    public void setPackage(String packageName) {\n        this.packageName = packageName;\n    }\n\n    public void setSection(String section) {\n        this.section = section;\n    }\n\n    public void setDepends(String depends) {\n        this.depends = depends;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public void setHomepage(String homepage) {\n        this.homepage = homepage;\n    }\n\n    public void setChangesIn(File changes) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut(File changes) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave(File changes) {\n        this.changesSave = changes;\n    }\n\n    public void setSignPackage(boolean signPackage) {\n        this.signPackage = signPackage;\n    }\n\n    public void setSignChanges(boolean signChanges) {\n        this.signChanges = signChanges;\n    }\n\n    public void setSignMethod(String signMethod) {\n        this.signMethod = signMethod;\n    }\n\n    public void setSignRole(String signRole) {\n        this.signRole = signRole;\n    }\n\n    public void setKeyring(File keyring) {\n        this.keyring = keyring;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void setPassphrase(String passphrase) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression(String compression) {\n        this.compression = compression;\n    }\n\n    public void setResolver(VariableResolver variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    private boolean isWritableFile(File file) {\n        return !file.exists() || file.isFile() && file.canWrite();\n    }\n\n    public String getDigest() {\n        return digest;\n    }\n\n    public void setDigest(String digest) {\n        this.digest = digest;\n    }\n\n    public void setTarLongFileMode(String tarLongFileMode) {\n        this.tarLongFileMode = tarLongFileMode;\n    }\n\n    public void setTarBigNumberMode(String tarBigNumberMode) {\n        this.tarBigNumberMode = tarBigNumberMode;\n    }\n\n    /**\n     * Validates the input parameters.\n     */\n    public void validate() throws PackagingException {\n        if (control == null || !control.isDirectory()) {\n            throw new PackagingException(\"The 'control' attribute doesn't point to a directory. \" + control);\n        }\n\n        if (changesIn != null) {\n\n            if (changesIn.exists() && (!changesIn.isFile() || !changesIn.canRead())) {\n                throw new PackagingException(\"The 'changesIn' setting needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n\n            if (changesOut != null && !isWritableFile(changesOut)) {\n                throw new PackagingException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isWritableFile(changesSave)) {\n                throw new PackagingException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new PackagingException(\"The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new PackagingException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip', 'bzip2' or 'xz')\");\n        }\n\n        if (deb == null) {\n            throw new PackagingException(\"You need to specify where the deb file is supposed to be created.\");\n        }\n\n        getDigestCode(digest);\n    }\n\n    static int getDigestCode(String digestName) throws PackagingException {\n        if (\"SHA1\".equals(digestName)) {\n            return HashAlgorithmTags.SHA1;\n        } else if (\"MD2\".equals(digestName)) {\n            return HashAlgorithmTags.MD2;\n        } else if (\"MD5\".equals(digestName)) {\n            return HashAlgorithmTags.MD5;\n        } else if (\"RIPEMD160\".equals(digestName)) {\n            return HashAlgorithmTags.RIPEMD160;\n        } else if (\"SHA256\".equals(digestName)) {\n            return HashAlgorithmTags.SHA256;\n        } else if (\"SHA384\".equals(digestName)) {\n            return HashAlgorithmTags.SHA384;\n        } else if (\"SHA512\".equals(digestName)) {\n            return HashAlgorithmTags.SHA512;\n        } else if (\"SHA224\".equals(digestName)) {\n            return HashAlgorithmTags.SHA224;\n        } else {\n            throw new PackagingException(\"unknown hash algorithm tag in digestName: \" + digestName);\n        }\n    }\n\n    public void makeDeb() throws PackagingException {\n        BinaryPackageControlFile packageControlFile;\n        try {\n            console.info(\"Creating debian package: \" + deb);\n\n            // If we should sign the package\n            boolean doSign = signPackage;\n\n            if (doSign) {\n\n                if (keyring == null || !keyring.exists()) {\n                    doSign = false;\n                    console.warn(\"Signing requested, but no keyring supplied\");\n                }\n\n                if (key == null) {\n                    doSign = false;\n                    console.warn(\"Signing requested, but no key supplied\");\n                }\n\n                if (passphrase == null) {\n                    doSign = false;\n                    console.warn(\"Signing requested, but no passphrase supplied\");\n                }\n\n                FileInputStream keyRingInput = new FileInputStream(keyring);\n                PGPSigner signer = null;\n                try {\n                    signer = new PGPSigner(new FileInputStream(keyring), key, passphrase, getDigestCode(digest));\n                } finally {\n                    keyRingInput.close();\n                }\n\n                PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(signer.getSecretKey().getPublicKey().getAlgorithm(), getDigestCode(digest)));\n                signatureGenerator.init(PGPSignature.BINARY_DOCUMENT, signer.getPrivateKey());\n\n                packageControlFile = createSignedDeb(Compression.toEnum(compression), signatureGenerator, signer);\n            } else {\n                packageControlFile = createDeb(Compression.toEnum(compression));\n            }\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create debian package \" + deb, e);\n        }\n\n        makeChangesFiles(packageControlFile);\n    }\n\n    private void makeChangesFiles(final BinaryPackageControlFile packageControlFile) throws PackagingException {\n        if (changesOut == null) {\n            changesOut = new File(deb.getParentFile(), deb.getName().replace(\".deb\", \".changes\"));\n        }\n\n        ChangesProvider changesProvider;\n        FileOutputStream out = null;\n\n        try {\n            console.info(\"Creating changes file: \" + changesOut);\n\n            out = new FileOutputStream(changesOut);\n\n            if (changesIn != null && changesIn.exists()) {\n                // read the changes form a textfile provider\n                changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            } else {\n                // create an empty changelog\n                changesProvider = new ChangesProvider() {\n                    public ChangeSet[] getChangesSets() {\n                        return new ChangeSet[] {\n                                new ChangeSet(packageControlFile.get(\"Package\"),\n                                        packageControlFile.get(\"Version\"),\n                                        new Date(),\n                                        packageControlFile.get(\"Distribution\"),\n                                        packageControlFile.get(\"Urgency\"),\n                                        packageControlFile.get(\"Maintainer\"),\n                                        new String[0])\n                        };\n                    }\n                };\n            }\n\n            ChangesFileBuilder builder = new ChangesFileBuilder();\n            ChangesFile changesFile = builder.createChanges(packageControlFile, deb, changesProvider);\n\n            //(signChanges || signPackage) - for backward compatibility. signPackage is signing both changes and deb.\n            if ((signChanges || signPackage) && keyring != null && key != null && passphrase != null) {\n                console.info(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase, getDigestCode(digest));\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n\n        if (changesSave == null || !(changesProvider instanceof TextfileChangesProvider)) {\n            return;\n        }\n\n        try {\n            console.info(\"Saving changes to file: \" + changesSave);\n\n            ((TextfileChangesProvider) changesProvider).save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n\n    private List<String> populateConffiles(Collection<DataProducer> producers) {\n        final List<String> result = new ArrayList<String>();\n\n        if (producers == null || producers.isEmpty()) {\n            return result;\n        }\n\n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachFile(InputStream input, TarArchiveEntry entry)  {\n                String tempConffileItem = entry.getName();\n                if (tempConffileItem.startsWith(\".\")) {\n                    tempConffileItem = tempConffileItem.substring(1);\n                }\n                console.info(\"Adding conffile: \" + tempConffileItem);\n                result.add(tempConffileItem);\n            }\n\n            public void onEachLink(TarArchiveEntry entry)  {\n            }\n\n            public void onEachDir(TarArchiveEntry tarArchiveEntry)  {\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } catch(Exception e) {\n            //\n        }\n\n        return result;\n    }\n\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file\n     * @return BinaryPackageControlFile\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createDeb(Compression compression) throws PackagingException {\n        return createSignedDeb(compression, null, null);\n    }\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @param signatureGenerator   the signature generator\n     *\n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createSignedDeb(Compression compression, final PGPSignatureGenerator signatureGenerator, PGPSigner signer ) throws PackagingException {\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.debug(\"Building data\");\n            DataBuilder dataBuilder = new DataBuilder(console);\n            StringBuilder md5s = new StringBuilder();\n            TarOptions options = new TarOptions()\n                .compression(compression)\n                .longFileMode(tarLongFileMode)\n                .bigNumberMode(tarBigNumberMode);\n            BigInteger size = dataBuilder.buildData(dataProducers, tempData, md5s, options);\n\n            console.info(\"Building conffiles\");\n            List<String> tempConffiles = populateConffiles(conffilesProducers);\n\n            console.debug(\"Building control\");\n            ControlBuilder controlBuilder = new ControlBuilder(console, variableResolver, openReplaceToken, closeReplaceToken);\n            BinaryPackageControlFile packageControlFile = controlBuilder.createPackageControlFile(new File(control, \"control\"), size);\n            if (packageControlFile.get(\"Package\") == null) {\n                packageControlFile.set(\"Package\", packageName);\n            }\n            if (packageControlFile.get(\"Section\") == null) {\n                packageControlFile.set(\"Section\", section);\n            }\n            if (packageControlFile.get(\"Description\") == null) {\n                packageControlFile.set(\"Description\", description);\n            }\n            if (packageControlFile.get(\"Homepage\") == null) {\n                packageControlFile.set(\"Homepage\", homepage);\n            }\n\n            controlBuilder.buildControl(packageControlFile, control.listFiles(), tempConffiles , md5s, tempControl);\n\n            if (!packageControlFile.isValid()) {\n                throw new PackagingException(\"Control file fields are invalid \" + packageControlFile.invalidFields() +\n                        \". The following fields are mandatory: \" + packageControlFile.getMandatoryFields() +\n                        \". Please check your pom.xml/build.xml and your control file.\");\n            }\n\n            deb.getParentFile().mkdirs();\n\n            ArArchiveOutputStream ar = new ArArchiveOutputStream(new FileOutputStream(deb));\n\n            String binaryName = \"debian-binary\";\n            String binaryContent = \"2.0\\n\";\n            String controlName = \"control.tar.gz\";\n            String dataName = \"data.tar\" + compression.getExtension();\n\n            addTo(ar, binaryName, binaryContent);\n            addTo(ar, controlName, tempControl);\n            addTo(ar, dataName, tempData);\n\n            if (signatureGenerator != null) {\n                console.info(\"Signing package with key \" + key);\n\n                if(signRole == null) {\n                    signRole = \"origin\";\n                }\n\n                // Use debsig-verify as default\n                if(signMethod == null || !\"dpkg-sig\".equals(signMethod)) {\n                    // Sign file to verify with debsig-verify\n                    PGPSignatureOutputStream sigStream = new PGPSignatureOutputStream(signatureGenerator);\n\n                    addTo(sigStream, binaryContent);\n                    addTo(sigStream, tempControl);\n                    addTo(sigStream, tempData);\n                    addTo(ar, \"_gpg\" + signRole, sigStream.generateASCIISignature());\n\n                } else {\n\n                    // Sign file to verify with dpkg-sig --verify\n                    final String outputStr =\n                            \"Version: 4\\n\" +\n                                    \"Signer: \\n\" +\n                                    \"Date: \" + new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy\", Locale.ENGLISH).format(new Date()) + \"\\n\" +\n                                    \"Role: \" + signRole +\"\\n\" +\n                                    \"Files: \\n\" +\n                                    addFile(binaryName, binaryContent) +\n                                    addFile(controlName, tempControl) +\n                                    addFile(dataName, tempData);\n\n                    ByteArrayOutputStream message = new ByteArrayOutputStream();\n                    signer.clearSign(outputStr, message);\n\n                    addTo(ar, \"_gpg\" + signRole, message.toString());\n                }\n            }\n\n            ar.close();\n\n            return packageControlFile;\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempControl);\n                }\n            }\n        }\n    }\n\n    private String addFile(String name, String input){\n        return addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n\n    private String addFile(String name, File input){\n        return addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n\n    private String addLine(String md5, String sha1, long size, String name){\n        return \"\\t\" + md5 + \" \" + sha1 + \" \" + size + \" \" + name + \"\\n\";\n    }\n\n    private String md5Hash(String input){\n        return md5Hash(input.getBytes());\n    }\n\n    private String md5Hash(File input){\n        try {\n            return md5Hash(FileUtils.readFileToByteArray(input));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    private String md5Hash(byte input[]){\n        //update the input of MD5\n        MD5Digest md5 = new MD5Digest();\n        md5.update(input, 0, input.length);\n\n        //get the output/ digest size and hash it\n        byte[] digest = new byte[md5.getDigestSize()];\n        md5.doFinal(digest, 0);\n\n        return new String(Hex.encode(digest));\n    }\n\n    private String sha1Hash(String input){\n        return sha1Hash(input.getBytes());\n    }\n\n    private String sha1Hash(File input){\n        try {\n            return sha1Hash(FileUtils.readFileToByteArray(input));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    private String sha1Hash(byte input[]){\n        try\n        {\n            //prepare the input\n            MessageDigest hash = MessageDigest.getInstance(digest);\n            hash.update(input);\n\n            //proceed ....\n            byte[] digest = hash.digest();\n\n            return new String(Hex.encode(digest));\n        }\n        catch (NoSuchAlgorithmException e)\n        {\n            System.err.println(\"No such algorithm\");\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, File pContent) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.write(content);\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final File pContent) throws IOException {\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n    }\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n    }\n}\n","lineNo":484}
{"Smelly Sample":"/*\n * Copyright 2016 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarConstants;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.taskdefs.Tar;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.utils.SymlinkUtils;\n\n/**\n * DataProducer providing data from an Ant fileset. TarFileSets are also\n * supported with their permissions.\n */\npublic final class DataProducerFileSet implements DataProducer {\n\n    private final FileSet fileset;\n\n    public DataProducerFileSet( final FileSet fileset ) {\n        this.fileset = fileset;\n    }\n\n    public void produce( final DataConsumer pReceiver ) throws IOException {\n        String user = Producers.ROOT_NAME;\n        int uid = Producers.ROOT_UID;\n        String group = Producers.ROOT_NAME;\n        int gid = Producers.ROOT_UID;\n        int filemode = TarEntry.DEFAULT_FILE_MODE;\n        int dirmode = TarEntry.DEFAULT_DIR_MODE;\n        String prefix = \"\";\n\n        if (fileset instanceof Tar.TarFileSet) {\n            Tar.TarFileSet tarfileset = (Tar.TarFileSet) fileset;\n            user = tarfileset.getUserName();\n            uid = tarfileset.getUid();\n            group = tarfileset.getGroup();\n            gid = tarfileset.getGid();\n            filemode = tarfileset.getMode();\n            dirmode = tarfileset.getDirMode(tarfileset.getProject());\n            prefix = tarfileset.getPrefix(tarfileset.getProject());\n        }\n\n        final DirectoryScanner scanner = fileset.getDirectoryScanner(fileset.getProject());\n        scanner.scan();\n\n        final File basedir = scanner.getBasedir();\n\n        for (String directory : scanner.getIncludedDirectories()) {\n            String name = directory.replace('\\\\', '/');\n\n            pReceiver.onEachDir(prefix + \"/\" + name, null, user, uid, group, gid, dirmode, 0);\n        }\n\n        for (String filename : scanner.getIncludedFiles()) {\n            final String name = filename.replace('\\\\', '/');\n            final File file = new File(basedir, name);\n\n            final InputStream inputStream = new FileInputStream(file);\n            try {\n                final String entryName = prefix + \"/\" + name;\n\n                final File entryPath = new File(entryName);\n\n                final boolean symbolicLink = SymlinkUtils.isSymbolicLink(entryPath);\n                final TarArchiveEntry e;\n                if (symbolicLink) {\n                    e = new TarArchiveEntry(entryName, TarConstants.LF_SYMLINK);\n                    e.setLinkName(SymlinkUtils.readSymbolicLink(entryPath));\n                } else {\n                    e = new TarArchiveEntry(entryName, true);\n                }\n\n                e.setUserId(uid);\n                e.setGroupId(gid);\n                e.setUserName(user);\n                e.setGroupName(group);\n                e.setMode(filemode);\n                e.setSize(file.length());\n\n                pReceiver.onEachFile(inputStream, e);\n            } finally {\n                inputStream.close();\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2016 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarConstants;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.taskdefs.Tar;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.utils.SymlinkUtils;\n\n/**\n * DataProducer providing data from an Ant fileset. TarFileSets are also\n * supported with their permissions.\n */\npublic final class DataProducerFileSet implements DataProducer {\n\n    private final FileSet fileset;\n\n    public DataProducerFileSet( final FileSet fileset ) {\n        this.fileset = fileset;\n    }\n\n    public void produce( final DataConsumer pReceiver ) throws IOException {\n        String user = Producers.ROOT_NAME;\n        int uid = Producers.ROOT_UID;\n        String group = Producers.ROOT_NAME;\n        int gid = Producers.ROOT_UID;\n        int filemode = TarEntry.DEFAULT_FILE_MODE;\n        int dirmode = TarEntry.DEFAULT_DIR_MODE;\n        String prefix = \"\";\n\n        if (fileset instanceof Tar.TarFileSet) {\n            Tar.TarFileSet tarfileset = (Tar.TarFileSet) fileset;\n            user = tarfileset.getUserName();\n            uid = tarfileset.getUid();\n            group = tarfileset.getGroup();\n            gid = tarfileset.getGid();\n            filemode = tarfileset.getMode();\n            dirmode = tarfileset.getDirMode(tarfileset.getProject());\n            prefix = tarfileset.getPrefix(tarfileset.getProject());\n        }\n\n        final DirectoryScanner scanner = fileset.getDirectoryScanner(fileset.getProject());\n        scanner.scan();\n\n        final File basedir = scanner.getBasedir();\n\n        for (String directory : scanner.getIncludedDirectories()) {\n            String name = directory.replace('\\\\', '/');\n\n            final TarArchiveEntry entry = new TarArchiveEntry(prefix + \"/\" + name);\n            entry.setUserName(user);\n            entry.setUserId(uid);\n            entry.setGroupName(group);\n            entry.setGroupId(gid);\n            entry.setMode(dirmode);\n\n            pReceiver.onEachDir(entry);\n        }\n\n        for (String filename : scanner.getIncludedFiles()) {\n            final String name = filename.replace('\\\\', '/');\n            final File file = new File(basedir, name);\n\n            final InputStream inputStream = new FileInputStream(file);\n            try {\n                final String entryName = prefix + \"/\" + name;\n\n                final File entryPath = new File(entryName);\n\n                final boolean symbolicLink = SymlinkUtils.isSymbolicLink(entryPath);\n                final TarArchiveEntry e;\n                if (symbolicLink) {\n                    e = new TarArchiveEntry(entryName, TarConstants.LF_SYMLINK);\n                    e.setLinkName(SymlinkUtils.readSymbolicLink(entryPath));\n                } else {\n                    e = new TarArchiveEntry(entryName, true);\n                }\n\n                e.setUserId(uid);\n                e.setGroupId(gid);\n                e.setUserName(user);\n                e.setGroupName(group);\n                e.setMode(filemode);\n                e.setSize(file.length());\n\n                pReceiver.onEachFile(inputStream, e);\n            } finally {\n                inputStream.close();\n            }\n        }\n    }\n}\n","lineNo":73}
{"Smelly Sample":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.taskdefs.Tar;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\n\n/**\n * DataProducer providing data from an Ant fileset. TarFileSets are also\n * supported with their permissions.\n *\n * @author Emmanuel Bourg\n */\npublic final class DataProducerFileSet implements DataProducer {\n\n    private final FileSet fileset;\n\n    public DataProducerFileSet( final FileSet fileset ) {\n        this.fileset = fileset;\n    }\n\n    public void produce( final DataConsumer pReceiver ) throws IOException {\n        String user = Producers.ROOT_NAME;\n        int uid = Producers.ROOT_UID;\n        String group = Producers.ROOT_NAME;\n        int gid = Producers.ROOT_UID;\n        int filemode = TarEntry.DEFAULT_FILE_MODE;\n        int dirmode = TarEntry.DEFAULT_DIR_MODE;\n        String prefix = \"\";\n\n        if (fileset instanceof Tar.TarFileSet) {\n            Tar.TarFileSet tarfileset = (Tar.TarFileSet) fileset;\n            user = tarfileset.getUserName();\n            uid = tarfileset.getUid();\n            group = tarfileset.getGroup();\n            gid = tarfileset.getGid();\n            filemode = tarfileset.getMode();\n            dirmode = tarfileset.getDirMode(tarfileset.getProject());\n            prefix = tarfileset.getPrefix(tarfileset.getProject());\n        }\n\n        final DirectoryScanner scanner = fileset.getDirectoryScanner(fileset.getProject());\n        scanner.scan();\n\n        final File basedir = scanner.getBasedir();\n        \n        for (String directory : scanner.getIncludedDirectories()) {\n            String name = directory.replace('\\\\', '/');\n\n            pReceiver.onEachDir(prefix + \"/\" + name, null, user, uid, group, gid, dirmode, 0);\n        }\n        \n        for (String filename : scanner.getIncludedFiles()) {\n            final String name = filename.replace('\\\\', '/');\n            final File file = new File(basedir, name);\n\n            final InputStream inputStream = new FileInputStream(file);\n            try {\n                pReceiver.onEachFile(inputStream, prefix + \"/\" + name, null, user, uid, group, gid, filemode, file.length());\n            } finally {\n                inputStream.close();\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarConstants;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.taskdefs.Tar;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\n/**\n * DataProducer providing data from an Ant fileset. TarFileSets are also\n * supported with their permissions.\n *\n * @author Emmanuel Bourg\n */\npublic final class DataProducerFileSet implements DataProducer {\n\n    private final FileSet fileset;\n\n    public DataProducerFileSet( final FileSet fileset ) {\n        this.fileset = fileset;\n    }\n\n    public void produce( final DataConsumer pReceiver ) throws IOException {\n        String user = Producers.ROOT_NAME;\n        int uid = Producers.ROOT_UID;\n        String group = Producers.ROOT_NAME;\n        int gid = Producers.ROOT_UID;\n        int filemode = TarEntry.DEFAULT_FILE_MODE;\n        int dirmode = TarEntry.DEFAULT_DIR_MODE;\n        String prefix = \"\";\n\n        if (fileset instanceof Tar.TarFileSet) {\n            Tar.TarFileSet tarfileset = (Tar.TarFileSet) fileset;\n            user = tarfileset.getUserName();\n            uid = tarfileset.getUid();\n            group = tarfileset.getGroup();\n            gid = tarfileset.getGid();\n            filemode = tarfileset.getMode();\n            dirmode = tarfileset.getDirMode(tarfileset.getProject());\n            prefix = tarfileset.getPrefix(tarfileset.getProject());\n        }\n\n        final DirectoryScanner scanner = fileset.getDirectoryScanner(fileset.getProject());\n        scanner.scan();\n\n        final File basedir = scanner.getBasedir();\n\n        for (String directory : scanner.getIncludedDirectories()) {\n            String name = directory.replace('\\\\', '/');\n\n            pReceiver.onEachDir(prefix + \"/\" + name, null, user, uid, group, gid, dirmode, 0);\n        }\n\n        for (final String filename : scanner.getIncludedFiles()) {\n            final String name = filename.replace('\\\\', '/');\n            final File file = new File(basedir, name);\n\n            final InputStream inputStream = new FileInputStream(file);\n            try {\n                final String entryName = prefix + \"/\" + name;\n\n                final Path entryPath = Paths.get(entryName);\n                final boolean symbolicLink = Files.isSymbolicLink(entryPath);\n                final TarArchiveEntry e;\n                if (symbolicLink) {\n                    e = new TarArchiveEntry(entryName, TarConstants.LF_SYMLINK);\n                    e.setLinkName(Files.readSymbolicLink(entryPath).toFile().getPath());\n                } else {\n                    e = new TarArchiveEntry(entryName, true);\n                }\n\n                e.setUserId(uid);\n                e.setGroupId(gid);\n                e.setUserName(user);\n                e.setGroupName(group);\n                e.setMode(filemode);\n                e.setSize(file.length());\n\n                pReceiver.onEachFile(inputStream, e);\n            } finally {\n                inputStream.close();\n            }\n        }\n    }\n}\n","lineNo":86}
{"Smelly Sample":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.bouncycastle.crypto.digests.MD5Digest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.signing.PGPSigner;\nimport org.vafer.jdeb.utils.PGPSignatureOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * A generic class for creating Debian archives. Even supports signed changes\n * files.\n *\n * @author Torsten Curdt\n * @author Bryan Sant\n */\npublic class DebMaker {\n\n    /** A console to output log message with */\n    private Console console;\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The name of the package. Default value if not specified in the control file */\n    private String packageName;\n\n    /** The section of the package. Default value if not specified in the control file */\n    private String section = \"java\";\n\n    /** The dependencies of the package. Default value if not specified in the control file */\n    private String depends = \"default-jre | java6-runtime\";\n\n    /** The description of the package. Default value if not specified in the control file */\n    private String description;\n\n    /** The homepage of the application. Default value if not specified in the control file */\n    private String homepage;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip, bzip2 or xz) */\n    private String compression = \"gzip\";\n\n    /** Whether to sign the package that is created */\n    private boolean signPackage;\n\n    private VariableResolver variableResolver;\n    private String openReplaceToken;\n    private String closeReplaceToken;\n\n    private final Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    private final Collection<DataProducer> conffilesProducers = new ArrayList<DataProducer>();\n\n\n    public DebMaker(Console console, Collection<DataProducer> dataProducers, Collection<DataProducer> conffileProducers) {\n        this.console = console;\n        if (dataProducers != null) {\n            this.dataProducers.addAll(dataProducers);\n        }\n        if (conffileProducers != null) {\n            this.conffilesProducers.addAll(conffileProducers);\n        }\n    }\n\n    public void setDeb(File deb) {\n        this.deb = deb;\n    }\n\n    public void setControl(File control) {\n        this.control = control;\n    }\n\n    public void setPackage(String packageName) {\n        this.packageName = packageName;\n    }\n\n    public void setSection(String section) {\n        this.section = section;\n    }\n\n    public void setDepends(String depends) {\n        this.depends = depends;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public void setHomepage(String homepage) {\n        this.homepage = homepage;\n    }\n\n    public void setChangesIn(File changes) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut(File changes) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave(File changes) {\n        this.changesSave = changes;\n    }\n\n    public void setSignPackage(boolean signPackage) {\n        this.signPackage = signPackage;\n    }\n\n    public void setKeyring(File keyring) {\n        this.keyring = keyring;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void setPassphrase(String passphrase) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression(String compression) {\n        this.compression = compression;\n    }\n\n    public void setResolver(VariableResolver variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    private boolean isWritableFile(File file) {\n        return !file.exists() || file.isFile() && file.canWrite();\n    }\n\n    /**\n     * Validates the input parameters.\n     */\n    public void validate() throws PackagingException {\n        if (control == null || !control.isDirectory()) {\n            throw new PackagingException(\"The 'control' attribute doesn't point to a directory.\");\n        }\n\n        if (changesIn != null) {\n\n            if (changesIn.exists() && (!changesIn.isFile() || !changesIn.canRead())) {\n                throw new PackagingException(\"The 'changesIn' setting needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n            \n            if (changesOut != null && !isWritableFile(changesOut)) {\n                throw new PackagingException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isWritableFile(changesSave)) {\n                throw new PackagingException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new PackagingException(\"The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new PackagingException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip', 'bzip2' or 'xz')\");\n        }\n\n        if (deb == null) {\n            throw new PackagingException(\"You need to specify where the deb file is supposed to be created.\");\n        }\n        \n        if (dataProducers.size() == 0) {\n            throw new PackagingException(\"You need to provide at least one reference to a tgz or directory with data.\");\n        }\n    }\n\n    public void makeDeb() throws PackagingException {\n        BinaryPackageControlFile packageControlFile;\n        try {\n            console.info(\"Creating debian package: \" + deb);\n\n            // If we should sign the package\n            boolean doSign = signPackage;\n\n            if (keyring == null || !keyring.exists()) {\n                doSign = false;\n                console.warn(\"Signing requested, but no keyring supplied\");\n            }\n\n            if (key == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no key supplied\");\n            }\n\n            if (passphrase == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no passphrase supplied\");\n            }\n\n            if (doSign) {\n                FileInputStream keyRingInput = new FileInputStream(keyring);\n                PGPSigner signer = null;\n                try {\n                    signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                } finally {\n                    keyRingInput.close();\n                }\n\n                int digest = PGPUtil.SHA1;\n\n                PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(signer.getSecretKey().getPublicKey().getAlgorithm(), digest));\n                signatureGenerator.init(PGPSignature.BINARY_DOCUMENT, signer.getPrivateKey());\n\n                packageControlFile = createSignedDeb(Compression.toEnum(compression), signatureGenerator, signer);\n            } else {\n                packageControlFile = createDeb(Compression.toEnum(compression));\n            }\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create debian package \" + deb, e);\n        }\n        \n        makeChangesFiles(packageControlFile);\n    }\n\n    private void makeChangesFiles(final BinaryPackageControlFile packageControlFile) throws PackagingException {\n        if (changesOut == null) {\n            changesOut = new File(deb.getParentFile(), deb.getName().replace(\".deb\", \".changes\"));\n        }\n        \n        ChangesProvider changesProvider;\n        FileOutputStream out = null;\n        \n        try {\n            console.info(\"Creating changes file: \" + changesOut);\n            \n            out = new FileOutputStream(changesOut);\n            \n            if (changesIn != null && changesIn.exists()) {\n                // read the changes form a textfile provider\n                changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            } else {\n                // create an empty changelog\n                changesProvider = new ChangesProvider() {\n                    @Override\n                    public ChangeSet[] getChangesSets() {\n                        return new ChangeSet[] {\n                                new ChangeSet(packageControlFile.get(\"Package\"),\n                                        packageControlFile.get(\"Version\"),\n                                        new Date(),\n                                        packageControlFile.get(\"Distribution\"),\n                                        packageControlFile.get(\"Urgency\"),\n                                        packageControlFile.get(\"Maintainer\"),\n                                        new String[0])\n                        };\n                    }\n                };\n            }\n            \n            ChangesFileBuilder builder = new ChangesFileBuilder();\n            ChangesFile changesFile = builder.createChanges(packageControlFile, deb, changesProvider);\n            \n            if (keyring != null && key != null && passphrase != null) {\n                console.info(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n        \n        if (changesSave == null || !(changesProvider instanceof TextfileChangesProvider)) {\n            return;\n        }\n        \n        try {\n            console.info(\"Saving changes to file: \" + changesSave);\n\n            ((TextfileChangesProvider) changesProvider).save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n    \n    private List<String> populateConffiles(Collection<DataProducer> producers) {\n        final List<String> result = new ArrayList<String>();\n        \n        if (producers == null || producers.isEmpty()) {\n            return result;\n        }\n        \n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachDir( String dirname, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                //\n            }\n            \n            public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                String tempConffileItem = filename;\n                if (tempConffileItem.startsWith(\".\")) {\n                    tempConffileItem = tempConffileItem.substring(1);\n                }\n                console.info(\"Adding conffile: \" + tempConffileItem);\n                result.add(tempConffileItem);\n            }\n\n            public void onEachLink(String path, String linkname, boolean symlink, String user, int uid, String group, int gid, int mode) throws IOException {\n                //\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } catch(Exception e) {\n            //\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param pControlFiles\n     * @param pData\n     * @param deb\n     * @param compression   the compression method used for the data file\n     * @return BinaryPackageControlFile\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createDeb(Compression compression) throws PackagingException {\n        return createSignedDeb(compression, null, null);\n    }\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @param signatureGenerator   the signature generator\n     * \n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createSignedDeb(Compression compression, final PGPSignatureGenerator signatureGenerator, PGPSigner signer ) throws PackagingException {\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.debug(\"Building data\");\n            DataBuilder dataBuilder = new DataBuilder(console);\n            StringBuilder md5s = new StringBuilder();\n            BigInteger size = dataBuilder.buildData(dataProducers, tempData, md5s, compression);\n\n            console.info(\"Building conffiles\");\n            List<String> tempConffiles = populateConffiles(conffilesProducers);\n            \n            console.debug(\"Building control\");\n            ControlBuilder controlBuilder = new ControlBuilder(console, variableResolver, openReplaceToken, closeReplaceToken);\n            BinaryPackageControlFile packageControlFile = controlBuilder.createPackageControlFile(new File(control, \"control\"), size);\n            if (packageControlFile.get(\"Package\") == null) {\n                packageControlFile.set(\"Package\", packageName);\n            }\n            if (packageControlFile.get(\"Depends\") == null) {\n                packageControlFile.set(\"Depends\", depends);\n            }\n            if (packageControlFile.get(\"Section\") == null) {\n                packageControlFile.set(\"Section\", section);\n            }\n            if (packageControlFile.get(\"Description\") == null) {\n                packageControlFile.set(\"Description\", description);\n            }\n            if (packageControlFile.get(\"Homepage\") == null) {\n                packageControlFile.set(\"Homepage\", homepage);\n            }\n            \n            controlBuilder.buildControl(packageControlFile, control.listFiles(), tempConffiles , md5s, tempControl);\n            \n            if (!packageControlFile.isValid()) {\n                throw new PackagingException(\"Control file fields are invalid \" + packageControlFile.invalidFields() +\n                    \". The following fields are mandatory: \" + packageControlFile.getMandatoryFields() +\n                    \". Please check your pom.xml/build.xml and your control file.\");\n            }\n\n            deb.getParentFile().mkdirs();\n            \n            \n            ArArchiveOutputStream ar = new ArArchiveOutputStream(new FileOutputStream(deb));\n            \n            addTo(ar, \"debian-binary\", \"2.0\\n\");\n            addTo(ar, \"control.tar.gz\", tempControl);\n            addTo(ar, \"data.tar\" + compression.getExtension(), tempData);\n            \n            if (signatureGenerator != null) {\n                console.info(\"Signing package with key \" + key);\n                \n                // Sign file to verify with debsign-verify\n                PGPSignatureOutputStream sigStream = new PGPSignatureOutputStream(signatureGenerator);\n\n                addTo(sigStream, \"2.0\\n\");\n                addTo(sigStream, tempControl);\n                addTo(sigStream, tempData);\n                addTo(ar, \"_gpgorigin\", sigStream.generateASCIISignature());\n                \n                // Sign file to verify with dpkg-sig --verify\n                final String outputStr =\n                            \"Version: 4\\n\" +\n                            \"Signer: \\n\" +\n                            \"Date: \" + new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy\", Locale.ENGLISH).format(new Date()).replaceFirst(\"0\", \" \") + \"\\n\" + \n                            \"Role: builder\\n\" + \n                            \"Files: \\n\" +\n                            addFile(\"2.0\\n\", \"debian-binary\") +\n                            addFile(tempControl, \"control.tar.gz\") +\n                            addFile(tempData, \"data.tar\" + compression.getExtension());\n                \n                ByteArrayOutputStream message = new ByteArrayOutputStream();\n                signer.clearSign(outputStr, message);\n                \n                addTo(ar, \"_gpgbuilder\", message.toString());\n            }\n\n            ar.close();\n            \n            return packageControlFile;\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempControl);\n                }\n            }\n        }\n    }\n\n    private String addFile(String input, String name){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addFile(File input, String name){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addLine(String md5, String sha1, long size, String name){\n    \treturn \"\\t\" + md5 + \" \" + sha1 + \" \" + size + \" \" + name + \"\\n\";\n    }\n    \n    private String md5Hash(String input){\n    \treturn md5Hash(input.getBytes());\n    }\n    \n    private String md5Hash(File input){\n    \ttry {\n\t\t\treturn md5Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String md5Hash(byte input[]){\n    \t//add the security provider\n        //not required if you have Install the library\n        //by Configuring the Java Runtime\n        Security.addProvider(new BouncyCastleProvider());\n\n        //update the input of MD5\n        MD5Digest md5 = new MD5Digest();\n        md5.update(input, 0, input.length);\n\n        //get the output/ digest size and hash it\n        byte[] digest = new byte[md5.getDigestSize()];\n        md5.doFinal(digest, 0);\n\n        return new String(Hex.encode(digest));\n    }\n    \n    private String sha1Hash(String input){\n    \treturn sha1Hash(input.getBytes());\n    }\n    \n    private String sha1Hash(File input){\n    \ttry {\n\t\t\treturn sha1Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String sha1Hash(byte input[]){\n    \t Security.addProvider(new BouncyCastleProvider());\n    \t \n         try\n         {\n               //prepare the input\n               //MessageDigest hash = MessageDigest.getInstance(\"SHA-1\", \"BC\");\n               MessageDigest hash = MessageDigest.getInstance(\"SHA1\");\n               hash.update(input);\n\n               //proceed ....\n               byte[] digest = hash.digest();\n\n               return new String(Hex.encode(digest));\n         }\n         catch (NoSuchAlgorithmException e)\n         {\n               System.err.println(\"No such algorithm\");\n               e.printStackTrace();\n         }\n//         catch (NoSuchProviderException e)\n//         {\n//               System.err.println(\"No such provider\");\n//               e.printStackTrace();\n//         }\n         \n         return null;\n    }\n    \n    private void addTo(ArArchiveOutputStream pOutput, String pName, String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, File pContent) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.write(content);\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final File pContent) throws IOException {\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n    }\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.bouncycastle.crypto.digests.MD5Digest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.signing.PGPSigner;\nimport org.vafer.jdeb.utils.PGPSignatureOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * A generic class for creating Debian archives. Even supports signed changes\n * files.\n *\n * @author Torsten Curdt\n * @author Bryan Sant\n */\npublic class DebMaker {\n\n    /** A console to output log message with */\n    private Console console;\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The name of the package. Default value if not specified in the control file */\n    private String packageName;\n\n    /** The section of the package. Default value if not specified in the control file */\n    private String section = \"java\";\n\n    /** The dependencies of the package. Default value if not specified in the control file */\n    private String depends = \"default-jre | java6-runtime\";\n\n    /** The description of the package. Default value if not specified in the control file */\n    private String description;\n\n    /** The homepage of the application. Default value if not specified in the control file */\n    private String homepage;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip, bzip2 or xz) */\n    private String compression = \"gzip\";\n\n    /** Whether to sign the package that is created */\n    private boolean signPackage;\n\n    /** Whether to sign the package that is created */\n    private String signMethod;\n    \n    private VariableResolver variableResolver;\n    private String openReplaceToken;\n    private String closeReplaceToken;\n\n    private final Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    private final Collection<DataProducer> conffilesProducers = new ArrayList<DataProducer>();\n\n\n    public DebMaker(Console console, Collection<DataProducer> dataProducers, Collection<DataProducer> conffileProducers) {\n        this.console = console;\n        if (dataProducers != null) {\n            this.dataProducers.addAll(dataProducers);\n        }\n        if (conffileProducers != null) {\n            this.conffilesProducers.addAll(conffileProducers);\n        }\n        \n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    public void setDeb(File deb) {\n        this.deb = deb;\n    }\n\n    public void setControl(File control) {\n        this.control = control;\n    }\n\n    public void setPackage(String packageName) {\n        this.packageName = packageName;\n    }\n\n    public void setSection(String section) {\n        this.section = section;\n    }\n\n    public void setDepends(String depends) {\n        this.depends = depends;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public void setHomepage(String homepage) {\n        this.homepage = homepage;\n    }\n\n    public void setChangesIn(File changes) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut(File changes) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave(File changes) {\n        this.changesSave = changes;\n    }\n\n    public void setSignPackage(boolean signPackage) {\n        this.signPackage = signPackage;\n    }\n    \n    public void setSignMethod(String signMethod) {\n        this.signMethod = signMethod;\n    }\n\n    public void setKeyring(File keyring) {\n        this.keyring = keyring;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void setPassphrase(String passphrase) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression(String compression) {\n        this.compression = compression;\n    }\n\n    public void setResolver(VariableResolver variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    private boolean isWritableFile(File file) {\n        return !file.exists() || file.isFile() && file.canWrite();\n    }\n\n    /**\n     * Validates the input parameters.\n     */\n    public void validate() throws PackagingException {\n        if (control == null || !control.isDirectory()) {\n            throw new PackagingException(\"The 'control' attribute doesn't point to a directory.\");\n        }\n\n        if (changesIn != null) {\n\n            if (changesIn.exists() && (!changesIn.isFile() || !changesIn.canRead())) {\n                throw new PackagingException(\"The 'changesIn' setting needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n            \n            if (changesOut != null && !isWritableFile(changesOut)) {\n                throw new PackagingException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isWritableFile(changesSave)) {\n                throw new PackagingException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new PackagingException(\"The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new PackagingException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip', 'bzip2' or 'xz')\");\n        }\n\n        if (deb == null) {\n            throw new PackagingException(\"You need to specify where the deb file is supposed to be created.\");\n        }\n        \n        if (dataProducers.size() == 0) {\n            throw new PackagingException(\"You need to provide at least one reference to a tgz or directory with data.\");\n        }\n    }\n\n    public void makeDeb() throws PackagingException {\n        BinaryPackageControlFile packageControlFile;\n        try {\n            console.info(\"Creating debian package: \" + deb);\n\n            // If we should sign the package\n            boolean doSign = signPackage;\n\n            if (keyring == null || !keyring.exists()) {\n                doSign = false;\n                console.warn(\"Signing requested, but no keyring supplied\");\n            }\n\n            if (key == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no key supplied\");\n            }\n\n            if (passphrase == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no passphrase supplied\");\n            }\n\n            if (doSign) {\n                FileInputStream keyRingInput = new FileInputStream(keyring);\n                PGPSigner signer = null;\n                try {\n                    signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                } finally {\n                    keyRingInput.close();\n                }\n\n                int digest = PGPUtil.SHA1;\n\n                PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(signer.getSecretKey().getPublicKey().getAlgorithm(), digest));\n                signatureGenerator.init(PGPSignature.BINARY_DOCUMENT, signer.getPrivateKey());\n\n                packageControlFile = createSignedDeb(Compression.toEnum(compression), signatureGenerator, signer);\n            } else {\n                packageControlFile = createDeb(Compression.toEnum(compression));\n            }\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create debian package \" + deb, e);\n        }\n        \n        makeChangesFiles(packageControlFile);\n    }\n\n    private void makeChangesFiles(final BinaryPackageControlFile packageControlFile) throws PackagingException {\n        if (changesOut == null) {\n            changesOut = new File(deb.getParentFile(), deb.getName().replace(\".deb\", \".changes\"));\n        }\n        \n        ChangesProvider changesProvider;\n        FileOutputStream out = null;\n        \n        try {\n            console.info(\"Creating changes file: \" + changesOut);\n            \n            out = new FileOutputStream(changesOut);\n            \n            if (changesIn != null && changesIn.exists()) {\n                // read the changes form a textfile provider\n                changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            } else {\n                // create an empty changelog\n                changesProvider = new ChangesProvider() {\n                    @Override\n                    public ChangeSet[] getChangesSets() {\n                        return new ChangeSet[] {\n                                new ChangeSet(packageControlFile.get(\"Package\"),\n                                        packageControlFile.get(\"Version\"),\n                                        new Date(),\n                                        packageControlFile.get(\"Distribution\"),\n                                        packageControlFile.get(\"Urgency\"),\n                                        packageControlFile.get(\"Maintainer\"),\n                                        new String[0])\n                        };\n                    }\n                };\n            }\n            \n            ChangesFileBuilder builder = new ChangesFileBuilder();\n            ChangesFile changesFile = builder.createChanges(packageControlFile, deb, changesProvider);\n            \n            if (keyring != null && key != null && passphrase != null) {\n                console.info(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n        \n        if (changesSave == null || !(changesProvider instanceof TextfileChangesProvider)) {\n            return;\n        }\n        \n        try {\n            console.info(\"Saving changes to file: \" + changesSave);\n\n            ((TextfileChangesProvider) changesProvider).save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n    \n    private List<String> populateConffiles(Collection<DataProducer> producers) {\n        final List<String> result = new ArrayList<String>();\n        \n        if (producers == null || producers.isEmpty()) {\n            return result;\n        }\n        \n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachDir( String dirname, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                //\n            }\n            \n            public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                String tempConffileItem = filename;\n                if (tempConffileItem.startsWith(\".\")) {\n                    tempConffileItem = tempConffileItem.substring(1);\n                }\n                console.info(\"Adding conffile: \" + tempConffileItem);\n                result.add(tempConffileItem);\n            }\n\n            public void onEachLink(String path, String linkname, boolean symlink, String user, int uid, String group, int gid, int mode) throws IOException {\n                //\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } catch(Exception e) {\n            //\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param pControlFiles\n     * @param pData\n     * @param deb\n     * @param compression   the compression method used for the data file\n     * @return BinaryPackageControlFile\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createDeb(Compression compression) throws PackagingException {\n        return createSignedDeb(compression, null, null);\n    }\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @param signatureGenerator   the signature generator\n     * \n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createSignedDeb(Compression compression, final PGPSignatureGenerator signatureGenerator, PGPSigner signer ) throws PackagingException {\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.debug(\"Building data\");\n            DataBuilder dataBuilder = new DataBuilder(console);\n            StringBuilder md5s = new StringBuilder();\n            BigInteger size = dataBuilder.buildData(dataProducers, tempData, md5s, compression);\n\n            console.info(\"Building conffiles\");\n            List<String> tempConffiles = populateConffiles(conffilesProducers);\n            \n            console.debug(\"Building control\");\n            ControlBuilder controlBuilder = new ControlBuilder(console, variableResolver, openReplaceToken, closeReplaceToken);\n            BinaryPackageControlFile packageControlFile = controlBuilder.createPackageControlFile(new File(control, \"control\"), size);\n            if (packageControlFile.get(\"Package\") == null) {\n                packageControlFile.set(\"Package\", packageName);\n            }\n            if (packageControlFile.get(\"Depends\") == null) {\n                packageControlFile.set(\"Depends\", depends);\n            }\n            if (packageControlFile.get(\"Section\") == null) {\n                packageControlFile.set(\"Section\", section);\n            }\n            if (packageControlFile.get(\"Description\") == null) {\n                packageControlFile.set(\"Description\", description);\n            }\n            if (packageControlFile.get(\"Homepage\") == null) {\n                packageControlFile.set(\"Homepage\", homepage);\n            }\n            \n            controlBuilder.buildControl(packageControlFile, control.listFiles(), tempConffiles , md5s, tempControl);\n            \n            if (!packageControlFile.isValid()) {\n                throw new PackagingException(\"Control file fields are invalid \" + packageControlFile.invalidFields() +\n                    \". The following fields are mandatory: \" + packageControlFile.getMandatoryFields() +\n                    \". Please check your pom.xml/build.xml and your control file.\");\n            }\n\n            deb.getParentFile().mkdirs();\n            \n            ArArchiveOutputStream ar = new ArArchiveOutputStream(new FileOutputStream(deb));\n            \n            String binaryName = \"debian-binary\";\n            String binaryContent = \"2.0\\n\";\n            String controlName = \"control.tar.gz\";\n            String dataName = \"data.tar\" + compression.getExtension();\n            \n            addTo(ar, binaryName, binaryContent);\n            addTo(ar, controlName, tempControl);\n            addTo(ar, dataName, tempData);\n            \n            if (signatureGenerator != null) {\n                console.info(\"Signing package with key \" + key);\n                \n                // Use debsig-verify as default\n                if(!signMethod.equals(\"dpkg-sig\")) {\n                \t// Sign file to verify with debsig-verify\n\t                PGPSignatureOutputStream sigStream = new PGPSignatureOutputStream(signatureGenerator);\n\t\n\t                addTo(sigStream, binaryContent);\n\t                addTo(sigStream, tempControl);\n\t                addTo(sigStream, tempData);\n\t                addTo(ar, \"_gpgorigin\", sigStream.generateASCIISignature());\n                } else {\n\t                // Sign file to verify with dpkg-sig --verify\n\t                final String outputStr =\n\t                            \"Version: 4\\n\" +\n\t                            \"Signer: \\n\" +\n\t                            \"Date: \" + new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy\", Locale.ENGLISH).format(new Date()) + \"\\n\" + \n\t                            \"Role: builder\\n\" + \n\t                            \"Files: \\n\" +\n\t                            addFile(binaryName, binaryContent) +\n\t                            addFile(controlName, tempControl) +\n\t                            addFile(dataName, tempData);\n\t                \n\t                ByteArrayOutputStream message = new ByteArrayOutputStream();\n\t                signer.clearSign(outputStr, message);\n\t                \n\t                addTo(ar, \"_gpgbuilder\", message.toString());\n                }\n            }\n\n            ar.close();\n            \n            return packageControlFile;\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempControl);\n                }\n            }\n        }\n    }\n\n    private String addFile(String name, String input){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addFile(String name, File input){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addLine(String md5, String sha1, long size, String name){\n    \treturn \"\\t\" + md5 + \" \" + sha1 + \" \" + size + \" \" + name + \"\\n\";\n    }\n    \n    private String md5Hash(String input){\n    \treturn md5Hash(input.getBytes());\n    }\n    \n    private String md5Hash(File input){\n    \ttry {\n\t\t\treturn md5Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String md5Hash(byte input[]){\n        //update the input of MD5\n        MD5Digest md5 = new MD5Digest();\n        md5.update(input, 0, input.length);\n\n        //get the output/ digest size and hash it\n        byte[] digest = new byte[md5.getDigestSize()];\n        md5.doFinal(digest, 0);\n\n        return new String(Hex.encode(digest));\n    }\n    \n    private String sha1Hash(String input){\n    \treturn sha1Hash(input.getBytes());\n    }\n    \n    private String sha1Hash(File input){\n    \ttry {\n\t\t\treturn sha1Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String sha1Hash(byte input[]){\n         try\n         {\n               //prepare the input\n               MessageDigest hash = MessageDigest.getInstance(\"SHA1\");\n               hash.update(input);\n\n               //proceed ....\n               byte[] digest = hash.digest();\n\n               return new String(Hex.encode(digest));\n         }\n         catch (NoSuchAlgorithmException e)\n         {\n               System.err.println(\"No such algorithm\");\n               e.printStackTrace();\n         }\n         \n         return null;\n    }\n    \n    private void addTo(ArArchiveOutputStream pOutput, String pName, String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, File pContent) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.write(content);\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final File pContent) throws IOException {\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n    }\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n    }\n}\n","lineNo":472}
{"Smelly Sample":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.bouncycastle.crypto.digests.MD5Digest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.signing.PGPSigner;\nimport org.vafer.jdeb.utils.PGPSignatureOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * A generic class for creating Debian archives. Even supports signed changes\n * files.\n *\n * @author Torsten Curdt\n * @author Bryan Sant\n */\npublic class DebMaker {\n\n    /** A console to output log message with */\n    private Console console;\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The name of the package. Default value if not specified in the control file */\n    private String packageName;\n\n    /** The section of the package. Default value if not specified in the control file */\n    private String section = \"java\";\n\n    /** The dependencies of the package. Default value if not specified in the control file */\n    private String depends = \"default-jre | java6-runtime\";\n\n    /** The description of the package. Default value if not specified in the control file */\n    private String description;\n\n    /** The homepage of the application. Default value if not specified in the control file */\n    private String homepage;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip, bzip2 or xz) */\n    private String compression = \"gzip\";\n\n    /** Whether to sign the package that is created */\n    private boolean signPackage;\n\n    private VariableResolver variableResolver;\n    private String openReplaceToken;\n    private String closeReplaceToken;\n\n    private final Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    private final Collection<DataProducer> conffilesProducers = new ArrayList<DataProducer>();\n\n\n    public DebMaker(Console console, Collection<DataProducer> dataProducers, Collection<DataProducer> conffileProducers) {\n        this.console = console;\n        if (dataProducers != null) {\n            this.dataProducers.addAll(dataProducers);\n        }\n        if (conffileProducers != null) {\n            this.conffilesProducers.addAll(conffileProducers);\n        }\n    }\n\n    public void setDeb(File deb) {\n        this.deb = deb;\n    }\n\n    public void setControl(File control) {\n        this.control = control;\n    }\n\n    public void setPackage(String packageName) {\n        this.packageName = packageName;\n    }\n\n    public void setSection(String section) {\n        this.section = section;\n    }\n\n    public void setDepends(String depends) {\n        this.depends = depends;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public void setHomepage(String homepage) {\n        this.homepage = homepage;\n    }\n\n    public void setChangesIn(File changes) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut(File changes) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave(File changes) {\n        this.changesSave = changes;\n    }\n\n    public void setSignPackage(boolean signPackage) {\n        this.signPackage = signPackage;\n    }\n\n    public void setKeyring(File keyring) {\n        this.keyring = keyring;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void setPassphrase(String passphrase) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression(String compression) {\n        this.compression = compression;\n    }\n\n    public void setResolver(VariableResolver variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    private boolean isWritableFile(File file) {\n        return !file.exists() || file.isFile() && file.canWrite();\n    }\n\n    /**\n     * Validates the input parameters.\n     */\n    public void validate() throws PackagingException {\n        if (control == null || !control.isDirectory()) {\n            throw new PackagingException(\"The 'control' attribute doesn't point to a directory.\");\n        }\n\n        if (changesIn != null) {\n\n            if (changesIn.exists() && (!changesIn.isFile() || !changesIn.canRead())) {\n                throw new PackagingException(\"The 'changesIn' setting needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n            \n            if (changesOut != null && !isWritableFile(changesOut)) {\n                throw new PackagingException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isWritableFile(changesSave)) {\n                throw new PackagingException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new PackagingException(\"The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new PackagingException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip', 'bzip2' or 'xz')\");\n        }\n\n        if (deb == null) {\n            throw new PackagingException(\"You need to specify where the deb file is supposed to be created.\");\n        }\n        \n        if (dataProducers.size() == 0) {\n            throw new PackagingException(\"You need to provide at least one reference to a tgz or directory with data.\");\n        }\n    }\n\n    public void makeDeb() throws PackagingException {\n        BinaryPackageControlFile packageControlFile;\n        try {\n            console.info(\"Creating debian package: \" + deb);\n\n            // If we should sign the package\n            boolean doSign = signPackage;\n\n            if (keyring == null || !keyring.exists()) {\n                doSign = false;\n                console.warn(\"Signing requested, but no keyring supplied\");\n            }\n\n            if (key == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no key supplied\");\n            }\n\n            if (passphrase == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no passphrase supplied\");\n            }\n\n            if (doSign) {\n                FileInputStream keyRingInput = new FileInputStream(keyring);\n                PGPSigner signer = null;\n                try {\n                    signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                } finally {\n                    keyRingInput.close();\n                }\n\n                int digest = PGPUtil.SHA1;\n\n                PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(signer.getSecretKey().getPublicKey().getAlgorithm(), digest));\n                signatureGenerator.init(PGPSignature.BINARY_DOCUMENT, signer.getPrivateKey());\n\n                packageControlFile = createSignedDeb(Compression.toEnum(compression), signatureGenerator, signer);\n            } else {\n                packageControlFile = createDeb(Compression.toEnum(compression));\n            }\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create debian package \" + deb, e);\n        }\n        \n        makeChangesFiles(packageControlFile);\n    }\n\n    private void makeChangesFiles(final BinaryPackageControlFile packageControlFile) throws PackagingException {\n        if (changesOut == null) {\n            changesOut = new File(deb.getParentFile(), deb.getName().replace(\".deb\", \".changes\"));\n        }\n        \n        ChangesProvider changesProvider;\n        FileOutputStream out = null;\n        \n        try {\n            console.info(\"Creating changes file: \" + changesOut);\n            \n            out = new FileOutputStream(changesOut);\n            \n            if (changesIn != null && changesIn.exists()) {\n                // read the changes form a textfile provider\n                changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            } else {\n                // create an empty changelog\n                changesProvider = new ChangesProvider() {\n                    @Override\n                    public ChangeSet[] getChangesSets() {\n                        return new ChangeSet[] {\n                                new ChangeSet(packageControlFile.get(\"Package\"),\n                                        packageControlFile.get(\"Version\"),\n                                        new Date(),\n                                        packageControlFile.get(\"Distribution\"),\n                                        packageControlFile.get(\"Urgency\"),\n                                        packageControlFile.get(\"Maintainer\"),\n                                        new String[0])\n                        };\n                    }\n                };\n            }\n            \n            ChangesFileBuilder builder = new ChangesFileBuilder();\n            ChangesFile changesFile = builder.createChanges(packageControlFile, deb, changesProvider);\n            \n            if (keyring != null && key != null && passphrase != null) {\n                console.info(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n        \n        if (changesSave == null || !(changesProvider instanceof TextfileChangesProvider)) {\n            return;\n        }\n        \n        try {\n            console.info(\"Saving changes to file: \" + changesSave);\n\n            ((TextfileChangesProvider) changesProvider).save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n    \n    private List<String> populateConffiles(Collection<DataProducer> producers) {\n        final List<String> result = new ArrayList<String>();\n        \n        if (producers == null || producers.isEmpty()) {\n            return result;\n        }\n        \n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachDir( String dirname, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                //\n            }\n            \n            public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                String tempConffileItem = filename;\n                if (tempConffileItem.startsWith(\".\")) {\n                    tempConffileItem = tempConffileItem.substring(1);\n                }\n                console.info(\"Adding conffile: \" + tempConffileItem);\n                result.add(tempConffileItem);\n            }\n\n            public void onEachLink(String path, String linkname, boolean symlink, String user, int uid, String group, int gid, int mode) throws IOException {\n                //\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } catch(Exception e) {\n            //\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param pControlFiles\n     * @param pData\n     * @param deb\n     * @param compression   the compression method used for the data file\n     * @return BinaryPackageControlFile\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createDeb(Compression compression) throws PackagingException {\n        return createSignedDeb(compression, null, null);\n    }\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @param signatureGenerator   the signature generator\n     * \n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createSignedDeb(Compression compression, final PGPSignatureGenerator signatureGenerator, PGPSigner signer ) throws PackagingException {\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.debug(\"Building data\");\n            DataBuilder dataBuilder = new DataBuilder(console);\n            StringBuilder md5s = new StringBuilder();\n            BigInteger size = dataBuilder.buildData(dataProducers, tempData, md5s, compression);\n\n            console.info(\"Building conffiles\");\n            List<String> tempConffiles = populateConffiles(conffilesProducers);\n            \n            console.debug(\"Building control\");\n            ControlBuilder controlBuilder = new ControlBuilder(console, variableResolver, openReplaceToken, closeReplaceToken);\n            BinaryPackageControlFile packageControlFile = controlBuilder.createPackageControlFile(new File(control, \"control\"), size);\n            if (packageControlFile.get(\"Package\") == null) {\n                packageControlFile.set(\"Package\", packageName);\n            }\n            if (packageControlFile.get(\"Depends\") == null) {\n                packageControlFile.set(\"Depends\", depends);\n            }\n            if (packageControlFile.get(\"Section\") == null) {\n                packageControlFile.set(\"Section\", section);\n            }\n            if (packageControlFile.get(\"Description\") == null) {\n                packageControlFile.set(\"Description\", description);\n            }\n            if (packageControlFile.get(\"Homepage\") == null) {\n                packageControlFile.set(\"Homepage\", homepage);\n            }\n            \n            controlBuilder.buildControl(packageControlFile, control.listFiles(), tempConffiles , md5s, tempControl);\n            \n            if (!packageControlFile.isValid()) {\n                throw new PackagingException(\"Control file fields are invalid \" + packageControlFile.invalidFields() +\n                    \". The following fields are mandatory: \" + packageControlFile.getMandatoryFields() +\n                    \". Please check your pom.xml/build.xml and your control file.\");\n            }\n\n            deb.getParentFile().mkdirs();\n            \n            \n            ArArchiveOutputStream ar = new ArArchiveOutputStream(new FileOutputStream(deb));\n            \n            addTo(ar, \"debian-binary\", \"2.0\\n\");\n            addTo(ar, \"control.tar.gz\", tempControl);\n            addTo(ar, \"data.tar\" + compression.getExtension(), tempData);\n            \n            if (signatureGenerator != null) {\n                console.info(\"Signing package with key \" + key);\n                \n                // Sign file to verify with debsign-verify\n                PGPSignatureOutputStream sigStream = new PGPSignatureOutputStream(signatureGenerator);\n\n                addTo(sigStream, \"2.0\\n\");\n                addTo(sigStream, tempControl);\n                addTo(sigStream, tempData);\n                addTo(ar, \"_gpgorigin\", sigStream.generateASCIISignature());\n                \n                // Sign file to verify with dpkg-sig --verify\n                final String outputStr =\n                            \"Version: 4\\n\" +\n                            \"Signer: \\n\" +\n                            \"Date: \" + new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy\", Locale.ENGLISH).format(new Date()).replaceFirst(\"0\", \" \") + \"\\n\" + \n                            \"Role: builder\\n\" + \n                            \"Files: \\n\" +\n                            addFile(\"2.0\\n\", \"debian-binary\") +\n                            addFile(tempControl, \"control.tar.gz\") +\n                            addFile(tempData, \"data.tar\" + compression.getExtension());\n                \n                ByteArrayOutputStream message = new ByteArrayOutputStream();\n                signer.clearSign(outputStr, message);\n                \n                addTo(ar, \"_gpgbuilder\", message.toString());\n            }\n\n            ar.close();\n            \n            return packageControlFile;\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempControl);\n                }\n            }\n        }\n    }\n\n    private String addFile(String input, String name){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addFile(File input, String name){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addLine(String md5, String sha1, long size, String name){\n    \treturn \"\\t\" + md5 + \" \" + sha1 + \" \" + size + \" \" + name + \"\\n\";\n    }\n    \n    private String md5Hash(String input){\n    \treturn md5Hash(input.getBytes());\n    }\n    \n    private String md5Hash(File input){\n    \ttry {\n\t\t\treturn md5Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String md5Hash(byte input[]){\n    \t//add the security provider\n        //not required if you have Install the library\n        //by Configuring the Java Runtime\n        Security.addProvider(new BouncyCastleProvider());\n\n        //update the input of MD5\n        MD5Digest md5 = new MD5Digest();\n        md5.update(input, 0, input.length);\n\n        //get the output/ digest size and hash it\n        byte[] digest = new byte[md5.getDigestSize()];\n        md5.doFinal(digest, 0);\n\n        return new String(Hex.encode(digest));\n    }\n    \n    private String sha1Hash(String input){\n    \treturn sha1Hash(input.getBytes());\n    }\n    \n    private String sha1Hash(File input){\n    \ttry {\n\t\t\treturn sha1Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String sha1Hash(byte input[]){\n    \t Security.addProvider(new BouncyCastleProvider());\n    \t \n         try\n         {\n               //prepare the input\n               //MessageDigest hash = MessageDigest.getInstance(\"SHA-1\", \"BC\");\n               MessageDigest hash = MessageDigest.getInstance(\"SHA1\");\n               hash.update(input);\n\n               //proceed ....\n               byte[] digest = hash.digest();\n\n               return new String(Hex.encode(digest));\n         }\n         catch (NoSuchAlgorithmException e)\n         {\n               System.err.println(\"No such algorithm\");\n               e.printStackTrace();\n         }\n//         catch (NoSuchProviderException e)\n//         {\n//               System.err.println(\"No such provider\");\n//               e.printStackTrace();\n//         }\n         \n         return null;\n    }\n    \n    private void addTo(ArArchiveOutputStream pOutput, String pName, String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, File pContent) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.write(content);\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final File pContent) throws IOException {\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n    }\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.bouncycastle.crypto.digests.MD5Digest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.signing.PGPSigner;\nimport org.vafer.jdeb.utils.PGPSignatureOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * A generic class for creating Debian archives. Even supports signed changes\n * files.\n *\n * @author Torsten Curdt\n * @author Bryan Sant\n */\npublic class DebMaker {\n\n    /** A console to output log message with */\n    private Console console;\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The name of the package. Default value if not specified in the control file */\n    private String packageName;\n\n    /** The section of the package. Default value if not specified in the control file */\n    private String section = \"java\";\n\n    /** The dependencies of the package. Default value if not specified in the control file */\n    private String depends = \"default-jre | java6-runtime\";\n\n    /** The description of the package. Default value if not specified in the control file */\n    private String description;\n\n    /** The homepage of the application. Default value if not specified in the control file */\n    private String homepage;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip, bzip2 or xz) */\n    private String compression = \"gzip\";\n\n    /** Whether to sign the package that is created */\n    private boolean signPackage;\n\n    /** Whether to sign the package that is created */\n    private String signMethod;\n    \n    private VariableResolver variableResolver;\n    private String openReplaceToken;\n    private String closeReplaceToken;\n\n    private final Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    private final Collection<DataProducer> conffilesProducers = new ArrayList<DataProducer>();\n\n\n    public DebMaker(Console console, Collection<DataProducer> dataProducers, Collection<DataProducer> conffileProducers) {\n        this.console = console;\n        if (dataProducers != null) {\n            this.dataProducers.addAll(dataProducers);\n        }\n        if (conffileProducers != null) {\n            this.conffilesProducers.addAll(conffileProducers);\n        }\n        \n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    public void setDeb(File deb) {\n        this.deb = deb;\n    }\n\n    public void setControl(File control) {\n        this.control = control;\n    }\n\n    public void setPackage(String packageName) {\n        this.packageName = packageName;\n    }\n\n    public void setSection(String section) {\n        this.section = section;\n    }\n\n    public void setDepends(String depends) {\n        this.depends = depends;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public void setHomepage(String homepage) {\n        this.homepage = homepage;\n    }\n\n    public void setChangesIn(File changes) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut(File changes) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave(File changes) {\n        this.changesSave = changes;\n    }\n\n    public void setSignPackage(boolean signPackage) {\n        this.signPackage = signPackage;\n    }\n    \n    public void setSignMethod(String signMethod) {\n        this.signMethod = signMethod;\n    }\n\n    public void setKeyring(File keyring) {\n        this.keyring = keyring;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void setPassphrase(String passphrase) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression(String compression) {\n        this.compression = compression;\n    }\n\n    public void setResolver(VariableResolver variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    private boolean isWritableFile(File file) {\n        return !file.exists() || file.isFile() && file.canWrite();\n    }\n\n    /**\n     * Validates the input parameters.\n     */\n    public void validate() throws PackagingException {\n        if (control == null || !control.isDirectory()) {\n            throw new PackagingException(\"The 'control' attribute doesn't point to a directory.\");\n        }\n\n        if (changesIn != null) {\n\n            if (changesIn.exists() && (!changesIn.isFile() || !changesIn.canRead())) {\n                throw new PackagingException(\"The 'changesIn' setting needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n            \n            if (changesOut != null && !isWritableFile(changesOut)) {\n                throw new PackagingException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isWritableFile(changesSave)) {\n                throw new PackagingException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new PackagingException(\"The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new PackagingException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip', 'bzip2' or 'xz')\");\n        }\n\n        if (deb == null) {\n            throw new PackagingException(\"You need to specify where the deb file is supposed to be created.\");\n        }\n        \n        if (dataProducers.size() == 0) {\n            throw new PackagingException(\"You need to provide at least one reference to a tgz or directory with data.\");\n        }\n    }\n\n    public void makeDeb() throws PackagingException {\n        BinaryPackageControlFile packageControlFile;\n        try {\n            console.info(\"Creating debian package: \" + deb);\n\n            // If we should sign the package\n            boolean doSign = signPackage;\n\n            if (keyring == null || !keyring.exists()) {\n                doSign = false;\n                console.warn(\"Signing requested, but no keyring supplied\");\n            }\n\n            if (key == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no key supplied\");\n            }\n\n            if (passphrase == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no passphrase supplied\");\n            }\n\n            if (doSign) {\n                FileInputStream keyRingInput = new FileInputStream(keyring);\n                PGPSigner signer = null;\n                try {\n                    signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                } finally {\n                    keyRingInput.close();\n                }\n\n                int digest = PGPUtil.SHA1;\n\n                PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(signer.getSecretKey().getPublicKey().getAlgorithm(), digest));\n                signatureGenerator.init(PGPSignature.BINARY_DOCUMENT, signer.getPrivateKey());\n\n                packageControlFile = createSignedDeb(Compression.toEnum(compression), signatureGenerator, signer);\n            } else {\n                packageControlFile = createDeb(Compression.toEnum(compression));\n            }\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create debian package \" + deb, e);\n        }\n        \n        makeChangesFiles(packageControlFile);\n    }\n\n    private void makeChangesFiles(final BinaryPackageControlFile packageControlFile) throws PackagingException {\n        if (changesOut == null) {\n            changesOut = new File(deb.getParentFile(), deb.getName().replace(\".deb\", \".changes\"));\n        }\n        \n        ChangesProvider changesProvider;\n        FileOutputStream out = null;\n        \n        try {\n            console.info(\"Creating changes file: \" + changesOut);\n            \n            out = new FileOutputStream(changesOut);\n            \n            if (changesIn != null && changesIn.exists()) {\n                // read the changes form a textfile provider\n                changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            } else {\n                // create an empty changelog\n                changesProvider = new ChangesProvider() {\n                    @Override\n                    public ChangeSet[] getChangesSets() {\n                        return new ChangeSet[] {\n                                new ChangeSet(packageControlFile.get(\"Package\"),\n                                        packageControlFile.get(\"Version\"),\n                                        new Date(),\n                                        packageControlFile.get(\"Distribution\"),\n                                        packageControlFile.get(\"Urgency\"),\n                                        packageControlFile.get(\"Maintainer\"),\n                                        new String[0])\n                        };\n                    }\n                };\n            }\n            \n            ChangesFileBuilder builder = new ChangesFileBuilder();\n            ChangesFile changesFile = builder.createChanges(packageControlFile, deb, changesProvider);\n            \n            if (keyring != null && key != null && passphrase != null) {\n                console.info(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n        \n        if (changesSave == null || !(changesProvider instanceof TextfileChangesProvider)) {\n            return;\n        }\n        \n        try {\n            console.info(\"Saving changes to file: \" + changesSave);\n\n            ((TextfileChangesProvider) changesProvider).save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n    \n    private List<String> populateConffiles(Collection<DataProducer> producers) {\n        final List<String> result = new ArrayList<String>();\n        \n        if (producers == null || producers.isEmpty()) {\n            return result;\n        }\n        \n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachDir( String dirname, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                //\n            }\n            \n            public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                String tempConffileItem = filename;\n                if (tempConffileItem.startsWith(\".\")) {\n                    tempConffileItem = tempConffileItem.substring(1);\n                }\n                console.info(\"Adding conffile: \" + tempConffileItem);\n                result.add(tempConffileItem);\n            }\n\n            public void onEachLink(String path, String linkname, boolean symlink, String user, int uid, String group, int gid, int mode) throws IOException {\n                //\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } catch(Exception e) {\n            //\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param pControlFiles\n     * @param pData\n     * @param deb\n     * @param compression   the compression method used for the data file\n     * @return BinaryPackageControlFile\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createDeb(Compression compression) throws PackagingException {\n        return createSignedDeb(compression, null, null);\n    }\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @param signatureGenerator   the signature generator\n     * \n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createSignedDeb(Compression compression, final PGPSignatureGenerator signatureGenerator, PGPSigner signer ) throws PackagingException {\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.debug(\"Building data\");\n            DataBuilder dataBuilder = new DataBuilder(console);\n            StringBuilder md5s = new StringBuilder();\n            BigInteger size = dataBuilder.buildData(dataProducers, tempData, md5s, compression);\n\n            console.info(\"Building conffiles\");\n            List<String> tempConffiles = populateConffiles(conffilesProducers);\n            \n            console.debug(\"Building control\");\n            ControlBuilder controlBuilder = new ControlBuilder(console, variableResolver, openReplaceToken, closeReplaceToken);\n            BinaryPackageControlFile packageControlFile = controlBuilder.createPackageControlFile(new File(control, \"control\"), size);\n            if (packageControlFile.get(\"Package\") == null) {\n                packageControlFile.set(\"Package\", packageName);\n            }\n            if (packageControlFile.get(\"Depends\") == null) {\n                packageControlFile.set(\"Depends\", depends);\n            }\n            if (packageControlFile.get(\"Section\") == null) {\n                packageControlFile.set(\"Section\", section);\n            }\n            if (packageControlFile.get(\"Description\") == null) {\n                packageControlFile.set(\"Description\", description);\n            }\n            if (packageControlFile.get(\"Homepage\") == null) {\n                packageControlFile.set(\"Homepage\", homepage);\n            }\n            \n            controlBuilder.buildControl(packageControlFile, control.listFiles(), tempConffiles , md5s, tempControl);\n            \n            if (!packageControlFile.isValid()) {\n                throw new PackagingException(\"Control file fields are invalid \" + packageControlFile.invalidFields() +\n                    \". The following fields are mandatory: \" + packageControlFile.getMandatoryFields() +\n                    \". Please check your pom.xml/build.xml and your control file.\");\n            }\n\n            deb.getParentFile().mkdirs();\n            \n            ArArchiveOutputStream ar = new ArArchiveOutputStream(new FileOutputStream(deb));\n            \n            String binaryName = \"debian-binary\";\n            String binaryContent = \"2.0\\n\";\n            String controlName = \"control.tar.gz\";\n            String dataName = \"data.tar\" + compression.getExtension();\n            \n            addTo(ar, binaryName, binaryContent);\n            addTo(ar, controlName, tempControl);\n            addTo(ar, dataName, tempData);\n            \n            if (signatureGenerator != null) {\n                console.info(\"Signing package with key \" + key);\n                \n                // Use debsig-verify as default\n                if(!signMethod.equals(\"dpkg-sig\")) {\n                \t// Sign file to verify with debsig-verify\n\t                PGPSignatureOutputStream sigStream = new PGPSignatureOutputStream(signatureGenerator);\n\t\n\t                addTo(sigStream, binaryContent);\n\t                addTo(sigStream, tempControl);\n\t                addTo(sigStream, tempData);\n\t                addTo(ar, \"_gpgorigin\", sigStream.generateASCIISignature());\n                } else {\n\t                // Sign file to verify with dpkg-sig --verify\n\t                final String outputStr =\n\t                            \"Version: 4\\n\" +\n\t                            \"Signer: \\n\" +\n\t                            \"Date: \" + new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy\", Locale.ENGLISH).format(new Date()) + \"\\n\" + \n\t                            \"Role: builder\\n\" + \n\t                            \"Files: \\n\" +\n\t                            addFile(binaryName, binaryContent) +\n\t                            addFile(controlName, tempControl) +\n\t                            addFile(dataName, tempData);\n\t                \n\t                ByteArrayOutputStream message = new ByteArrayOutputStream();\n\t                signer.clearSign(outputStr, message);\n\t                \n\t                addTo(ar, \"_gpgbuilder\", message.toString());\n                }\n            }\n\n            ar.close();\n            \n            return packageControlFile;\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempControl);\n                }\n            }\n        }\n    }\n\n    private String addFile(String name, String input){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addFile(String name, File input){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addLine(String md5, String sha1, long size, String name){\n    \treturn \"\\t\" + md5 + \" \" + sha1 + \" \" + size + \" \" + name + \"\\n\";\n    }\n    \n    private String md5Hash(String input){\n    \treturn md5Hash(input.getBytes());\n    }\n    \n    private String md5Hash(File input){\n    \ttry {\n\t\t\treturn md5Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String md5Hash(byte input[]){\n        //update the input of MD5\n        MD5Digest md5 = new MD5Digest();\n        md5.update(input, 0, input.length);\n\n        //get the output/ digest size and hash it\n        byte[] digest = new byte[md5.getDigestSize()];\n        md5.doFinal(digest, 0);\n\n        return new String(Hex.encode(digest));\n    }\n    \n    private String sha1Hash(String input){\n    \treturn sha1Hash(input.getBytes());\n    }\n    \n    private String sha1Hash(File input){\n    \ttry {\n\t\t\treturn sha1Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String sha1Hash(byte input[]){\n         try\n         {\n               //prepare the input\n               MessageDigest hash = MessageDigest.getInstance(\"SHA1\");\n               hash.update(input);\n\n               //proceed ....\n               byte[] digest = hash.digest();\n\n               return new String(Hex.encode(digest));\n         }\n         catch (NoSuchAlgorithmException e)\n         {\n               System.err.println(\"No such algorithm\");\n               e.printStackTrace();\n         }\n         \n         return null;\n    }\n    \n    private void addTo(ArArchiveOutputStream pOutput, String pName, String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, File pContent) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.write(content);\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final File pContent) throws IOException {\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n    }\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n    }\n}\n","lineNo":473}
{"Smelly Sample":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.bouncycastle.crypto.digests.MD5Digest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.signing.PGPSigner;\nimport org.vafer.jdeb.utils.PGPSignatureOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * A generic class for creating Debian archives. Even supports signed changes\n * files.\n *\n * @author Torsten Curdt\n * @author Bryan Sant\n */\npublic class DebMaker {\n\n    /** A console to output log message with */\n    private Console console;\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The name of the package. Default value if not specified in the control file */\n    private String packageName;\n\n    /** The section of the package. Default value if not specified in the control file */\n    private String section = \"java\";\n\n    /** The dependencies of the package. Default value if not specified in the control file */\n    private String depends = \"default-jre | java6-runtime\";\n\n    /** The description of the package. Default value if not specified in the control file */\n    private String description;\n\n    /** The homepage of the application. Default value if not specified in the control file */\n    private String homepage;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip, bzip2 or xz) */\n    private String compression = \"gzip\";\n\n    /** Whether to sign the package that is created */\n    private boolean signPackage;\n\n    private VariableResolver variableResolver;\n    private String openReplaceToken;\n    private String closeReplaceToken;\n\n    private final Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    private final Collection<DataProducer> conffilesProducers = new ArrayList<DataProducer>();\n\n\n    public DebMaker(Console console, Collection<DataProducer> dataProducers, Collection<DataProducer> conffileProducers) {\n        this.console = console;\n        if (dataProducers != null) {\n            this.dataProducers.addAll(dataProducers);\n        }\n        if (conffileProducers != null) {\n            this.conffilesProducers.addAll(conffileProducers);\n        }\n    }\n\n    public void setDeb(File deb) {\n        this.deb = deb;\n    }\n\n    public void setControl(File control) {\n        this.control = control;\n    }\n\n    public void setPackage(String packageName) {\n        this.packageName = packageName;\n    }\n\n    public void setSection(String section) {\n        this.section = section;\n    }\n\n    public void setDepends(String depends) {\n        this.depends = depends;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public void setHomepage(String homepage) {\n        this.homepage = homepage;\n    }\n\n    public void setChangesIn(File changes) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut(File changes) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave(File changes) {\n        this.changesSave = changes;\n    }\n\n    public void setSignPackage(boolean signPackage) {\n        this.signPackage = signPackage;\n    }\n\n    public void setKeyring(File keyring) {\n        this.keyring = keyring;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void setPassphrase(String passphrase) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression(String compression) {\n        this.compression = compression;\n    }\n\n    public void setResolver(VariableResolver variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    private boolean isWritableFile(File file) {\n        return !file.exists() || file.isFile() && file.canWrite();\n    }\n\n    /**\n     * Validates the input parameters.\n     */\n    public void validate() throws PackagingException {\n        if (control == null || !control.isDirectory()) {\n            throw new PackagingException(\"The 'control' attribute doesn't point to a directory.\");\n        }\n\n        if (changesIn != null) {\n\n            if (changesIn.exists() && (!changesIn.isFile() || !changesIn.canRead())) {\n                throw new PackagingException(\"The 'changesIn' setting needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n            \n            if (changesOut != null && !isWritableFile(changesOut)) {\n                throw new PackagingException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isWritableFile(changesSave)) {\n                throw new PackagingException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new PackagingException(\"The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new PackagingException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip', 'bzip2' or 'xz')\");\n        }\n\n        if (deb == null) {\n            throw new PackagingException(\"You need to specify where the deb file is supposed to be created.\");\n        }\n        \n        if (dataProducers.size() == 0) {\n            throw new PackagingException(\"You need to provide at least one reference to a tgz or directory with data.\");\n        }\n    }\n\n    public void makeDeb() throws PackagingException {\n        BinaryPackageControlFile packageControlFile;\n        try {\n            console.info(\"Creating debian package: \" + deb);\n\n            // If we should sign the package\n            boolean doSign = signPackage;\n\n            if (keyring == null || !keyring.exists()) {\n                doSign = false;\n                console.warn(\"Signing requested, but no keyring supplied\");\n            }\n\n            if (key == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no key supplied\");\n            }\n\n            if (passphrase == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no passphrase supplied\");\n            }\n\n            if (doSign) {\n                FileInputStream keyRingInput = new FileInputStream(keyring);\n                PGPSigner signer = null;\n                try {\n                    signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                } finally {\n                    keyRingInput.close();\n                }\n\n                int digest = PGPUtil.SHA1;\n\n                PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(signer.getSecretKey().getPublicKey().getAlgorithm(), digest));\n                signatureGenerator.init(PGPSignature.BINARY_DOCUMENT, signer.getPrivateKey());\n\n                packageControlFile = createSignedDeb(Compression.toEnum(compression), signatureGenerator, signer);\n            } else {\n                packageControlFile = createDeb(Compression.toEnum(compression));\n            }\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create debian package \" + deb, e);\n        }\n        \n        makeChangesFiles(packageControlFile);\n    }\n\n    private void makeChangesFiles(final BinaryPackageControlFile packageControlFile) throws PackagingException {\n        if (changesOut == null) {\n            changesOut = new File(deb.getParentFile(), deb.getName().replace(\".deb\", \".changes\"));\n        }\n        \n        ChangesProvider changesProvider;\n        FileOutputStream out = null;\n        \n        try {\n            console.info(\"Creating changes file: \" + changesOut);\n            \n            out = new FileOutputStream(changesOut);\n            \n            if (changesIn != null && changesIn.exists()) {\n                // read the changes form a textfile provider\n                changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            } else {\n                // create an empty changelog\n                changesProvider = new ChangesProvider() {\n                    @Override\n                    public ChangeSet[] getChangesSets() {\n                        return new ChangeSet[] {\n                                new ChangeSet(packageControlFile.get(\"Package\"),\n                                        packageControlFile.get(\"Version\"),\n                                        new Date(),\n                                        packageControlFile.get(\"Distribution\"),\n                                        packageControlFile.get(\"Urgency\"),\n                                        packageControlFile.get(\"Maintainer\"),\n                                        new String[0])\n                        };\n                    }\n                };\n            }\n            \n            ChangesFileBuilder builder = new ChangesFileBuilder();\n            ChangesFile changesFile = builder.createChanges(packageControlFile, deb, changesProvider);\n            \n            if (keyring != null && key != null && passphrase != null) {\n                console.info(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n        \n        if (changesSave == null || !(changesProvider instanceof TextfileChangesProvider)) {\n            return;\n        }\n        \n        try {\n            console.info(\"Saving changes to file: \" + changesSave);\n\n            ((TextfileChangesProvider) changesProvider).save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n    \n    private List<String> populateConffiles(Collection<DataProducer> producers) {\n        final List<String> result = new ArrayList<String>();\n        \n        if (producers == null || producers.isEmpty()) {\n            return result;\n        }\n        \n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachDir( String dirname, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                //\n            }\n            \n            public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                String tempConffileItem = filename;\n                if (tempConffileItem.startsWith(\".\")) {\n                    tempConffileItem = tempConffileItem.substring(1);\n                }\n                console.info(\"Adding conffile: \" + tempConffileItem);\n                result.add(tempConffileItem);\n            }\n\n            public void onEachLink(String path, String linkname, boolean symlink, String user, int uid, String group, int gid, int mode) throws IOException {\n                //\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } catch(Exception e) {\n            //\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param pControlFiles\n     * @param pData\n     * @param deb\n     * @param compression   the compression method used for the data file\n     * @return BinaryPackageControlFile\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createDeb(Compression compression) throws PackagingException {\n        return createSignedDeb(compression, null, null);\n    }\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @param signatureGenerator   the signature generator\n     * \n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createSignedDeb(Compression compression, final PGPSignatureGenerator signatureGenerator, PGPSigner signer ) throws PackagingException {\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.debug(\"Building data\");\n            DataBuilder dataBuilder = new DataBuilder(console);\n            StringBuilder md5s = new StringBuilder();\n            BigInteger size = dataBuilder.buildData(dataProducers, tempData, md5s, compression);\n\n            console.info(\"Building conffiles\");\n            List<String> tempConffiles = populateConffiles(conffilesProducers);\n            \n            console.debug(\"Building control\");\n            ControlBuilder controlBuilder = new ControlBuilder(console, variableResolver, openReplaceToken, closeReplaceToken);\n            BinaryPackageControlFile packageControlFile = controlBuilder.createPackageControlFile(new File(control, \"control\"), size);\n            if (packageControlFile.get(\"Package\") == null) {\n                packageControlFile.set(\"Package\", packageName);\n            }\n            if (packageControlFile.get(\"Depends\") == null) {\n                packageControlFile.set(\"Depends\", depends);\n            }\n            if (packageControlFile.get(\"Section\") == null) {\n                packageControlFile.set(\"Section\", section);\n            }\n            if (packageControlFile.get(\"Description\") == null) {\n                packageControlFile.set(\"Description\", description);\n            }\n            if (packageControlFile.get(\"Homepage\") == null) {\n                packageControlFile.set(\"Homepage\", homepage);\n            }\n            \n            controlBuilder.buildControl(packageControlFile, control.listFiles(), tempConffiles , md5s, tempControl);\n            \n            if (!packageControlFile.isValid()) {\n                throw new PackagingException(\"Control file fields are invalid \" + packageControlFile.invalidFields() +\n                    \". The following fields are mandatory: \" + packageControlFile.getMandatoryFields() +\n                    \". Please check your pom.xml/build.xml and your control file.\");\n            }\n\n            deb.getParentFile().mkdirs();\n            \n            \n            ArArchiveOutputStream ar = new ArArchiveOutputStream(new FileOutputStream(deb));\n            \n            addTo(ar, \"debian-binary\", \"2.0\\n\");\n            addTo(ar, \"control.tar.gz\", tempControl);\n            addTo(ar, \"data.tar\" + compression.getExtension(), tempData);\n            \n            if (signatureGenerator != null) {\n                console.info(\"Signing package with key \" + key);\n                \n                // Sign file to verify with debsign-verify\n                PGPSignatureOutputStream sigStream = new PGPSignatureOutputStream(signatureGenerator);\n\n                addTo(sigStream, \"2.0\\n\");\n                addTo(sigStream, tempControl);\n                addTo(sigStream, tempData);\n                addTo(ar, \"_gpgorigin\", sigStream.generateASCIISignature());\n                \n                // Sign file to verify with dpkg-sig --verify\n                final String outputStr =\n                            \"Version: 4\\n\" +\n                            \"Signer: \\n\" +\n                            \"Date: \" + new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy\", Locale.ENGLISH).format(new Date()).replaceFirst(\"0\", \" \") + \"\\n\" + \n                            \"Role: builder\\n\" + \n                            \"Files: \\n\" +\n                            addFile(\"2.0\\n\", \"debian-binary\") +\n                            addFile(tempControl, \"control.tar.gz\") +\n                            addFile(tempData, \"data.tar\" + compression.getExtension());\n                \n                ByteArrayOutputStream message = new ByteArrayOutputStream();\n                signer.clearSign(outputStr, message);\n                \n                addTo(ar, \"_gpgbuilder\", message.toString());\n            }\n\n            ar.close();\n            \n            return packageControlFile;\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempControl);\n                }\n            }\n        }\n    }\n\n    private String addFile(String input, String name){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addFile(File input, String name){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addLine(String md5, String sha1, long size, String name){\n    \treturn \"\\t\" + md5 + \" \" + sha1 + \" \" + size + \" \" + name + \"\\n\";\n    }\n    \n    private String md5Hash(String input){\n    \treturn md5Hash(input.getBytes());\n    }\n    \n    private String md5Hash(File input){\n    \ttry {\n\t\t\treturn md5Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String md5Hash(byte input[]){\n    \t//add the security provider\n        //not required if you have Install the library\n        //by Configuring the Java Runtime\n        Security.addProvider(new BouncyCastleProvider());\n\n        //update the input of MD5\n        MD5Digest md5 = new MD5Digest();\n        md5.update(input, 0, input.length);\n\n        //get the output/ digest size and hash it\n        byte[] digest = new byte[md5.getDigestSize()];\n        md5.doFinal(digest, 0);\n\n        return new String(Hex.encode(digest));\n    }\n    \n    private String sha1Hash(String input){\n    \treturn sha1Hash(input.getBytes());\n    }\n    \n    private String sha1Hash(File input){\n    \ttry {\n\t\t\treturn sha1Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String sha1Hash(byte input[]){\n    \t Security.addProvider(new BouncyCastleProvider());\n    \t \n         try\n         {\n               //prepare the input\n               //MessageDigest hash = MessageDigest.getInstance(\"SHA-1\", \"BC\");\n               MessageDigest hash = MessageDigest.getInstance(\"SHA1\");\n               hash.update(input);\n\n               //proceed ....\n               byte[] digest = hash.digest();\n\n               return new String(Hex.encode(digest));\n         }\n         catch (NoSuchAlgorithmException e)\n         {\n               System.err.println(\"No such algorithm\");\n               e.printStackTrace();\n         }\n//         catch (NoSuchProviderException e)\n//         {\n//               System.err.println(\"No such provider\");\n//               e.printStackTrace();\n//         }\n         \n         return null;\n    }\n    \n    private void addTo(ArArchiveOutputStream pOutput, String pName, String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, File pContent) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.write(content);\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final File pContent) throws IOException {\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n    }\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.bouncycastle.crypto.digests.MD5Digest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.signing.PGPSigner;\nimport org.vafer.jdeb.utils.PGPSignatureOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * A generic class for creating Debian archives. Even supports signed changes\n * files.\n *\n * @author Torsten Curdt\n * @author Bryan Sant\n */\npublic class DebMaker {\n\n    /** A console to output log message with */\n    private Console console;\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The name of the package. Default value if not specified in the control file */\n    private String packageName;\n\n    /** The section of the package. Default value if not specified in the control file */\n    private String section = \"java\";\n\n    /** The dependencies of the package. Default value if not specified in the control file */\n    private String depends = \"default-jre | java6-runtime\";\n\n    /** The description of the package. Default value if not specified in the control file */\n    private String description;\n\n    /** The homepage of the application. Default value if not specified in the control file */\n    private String homepage;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip, bzip2 or xz) */\n    private String compression = \"gzip\";\n\n    /** Whether to sign the package that is created */\n    private boolean signPackage;\n\n    /** Whether to sign the package that is created */\n    private String signMethod;\n    \n    private VariableResolver variableResolver;\n    private String openReplaceToken;\n    private String closeReplaceToken;\n\n    private final Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    private final Collection<DataProducer> conffilesProducers = new ArrayList<DataProducer>();\n\n\n    public DebMaker(Console console, Collection<DataProducer> dataProducers, Collection<DataProducer> conffileProducers) {\n        this.console = console;\n        if (dataProducers != null) {\n            this.dataProducers.addAll(dataProducers);\n        }\n        if (conffileProducers != null) {\n            this.conffilesProducers.addAll(conffileProducers);\n        }\n        \n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    public void setDeb(File deb) {\n        this.deb = deb;\n    }\n\n    public void setControl(File control) {\n        this.control = control;\n    }\n\n    public void setPackage(String packageName) {\n        this.packageName = packageName;\n    }\n\n    public void setSection(String section) {\n        this.section = section;\n    }\n\n    public void setDepends(String depends) {\n        this.depends = depends;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public void setHomepage(String homepage) {\n        this.homepage = homepage;\n    }\n\n    public void setChangesIn(File changes) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut(File changes) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave(File changes) {\n        this.changesSave = changes;\n    }\n\n    public void setSignPackage(boolean signPackage) {\n        this.signPackage = signPackage;\n    }\n    \n    public void setSignMethod(String signMethod) {\n        this.signMethod = signMethod;\n    }\n\n    public void setKeyring(File keyring) {\n        this.keyring = keyring;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void setPassphrase(String passphrase) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression(String compression) {\n        this.compression = compression;\n    }\n\n    public void setResolver(VariableResolver variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    private boolean isWritableFile(File file) {\n        return !file.exists() || file.isFile() && file.canWrite();\n    }\n\n    /**\n     * Validates the input parameters.\n     */\n    public void validate() throws PackagingException {\n        if (control == null || !control.isDirectory()) {\n            throw new PackagingException(\"The 'control' attribute doesn't point to a directory.\");\n        }\n\n        if (changesIn != null) {\n\n            if (changesIn.exists() && (!changesIn.isFile() || !changesIn.canRead())) {\n                throw new PackagingException(\"The 'changesIn' setting needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n            \n            if (changesOut != null && !isWritableFile(changesOut)) {\n                throw new PackagingException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isWritableFile(changesSave)) {\n                throw new PackagingException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new PackagingException(\"The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new PackagingException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip', 'bzip2' or 'xz')\");\n        }\n\n        if (deb == null) {\n            throw new PackagingException(\"You need to specify where the deb file is supposed to be created.\");\n        }\n        \n        if (dataProducers.size() == 0) {\n            throw new PackagingException(\"You need to provide at least one reference to a tgz or directory with data.\");\n        }\n    }\n\n    public void makeDeb() throws PackagingException {\n        BinaryPackageControlFile packageControlFile;\n        try {\n            console.info(\"Creating debian package: \" + deb);\n\n            // If we should sign the package\n            boolean doSign = signPackage;\n\n            if (keyring == null || !keyring.exists()) {\n                doSign = false;\n                console.warn(\"Signing requested, but no keyring supplied\");\n            }\n\n            if (key == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no key supplied\");\n            }\n\n            if (passphrase == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no passphrase supplied\");\n            }\n\n            if (doSign) {\n                FileInputStream keyRingInput = new FileInputStream(keyring);\n                PGPSigner signer = null;\n                try {\n                    signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                } finally {\n                    keyRingInput.close();\n                }\n\n                int digest = PGPUtil.SHA1;\n\n                PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(signer.getSecretKey().getPublicKey().getAlgorithm(), digest));\n                signatureGenerator.init(PGPSignature.BINARY_DOCUMENT, signer.getPrivateKey());\n\n                packageControlFile = createSignedDeb(Compression.toEnum(compression), signatureGenerator, signer);\n            } else {\n                packageControlFile = createDeb(Compression.toEnum(compression));\n            }\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create debian package \" + deb, e);\n        }\n        \n        makeChangesFiles(packageControlFile);\n    }\n\n    private void makeChangesFiles(final BinaryPackageControlFile packageControlFile) throws PackagingException {\n        if (changesOut == null) {\n            changesOut = new File(deb.getParentFile(), deb.getName().replace(\".deb\", \".changes\"));\n        }\n        \n        ChangesProvider changesProvider;\n        FileOutputStream out = null;\n        \n        try {\n            console.info(\"Creating changes file: \" + changesOut);\n            \n            out = new FileOutputStream(changesOut);\n            \n            if (changesIn != null && changesIn.exists()) {\n                // read the changes form a textfile provider\n                changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            } else {\n                // create an empty changelog\n                changesProvider = new ChangesProvider() {\n                    @Override\n                    public ChangeSet[] getChangesSets() {\n                        return new ChangeSet[] {\n                                new ChangeSet(packageControlFile.get(\"Package\"),\n                                        packageControlFile.get(\"Version\"),\n                                        new Date(),\n                                        packageControlFile.get(\"Distribution\"),\n                                        packageControlFile.get(\"Urgency\"),\n                                        packageControlFile.get(\"Maintainer\"),\n                                        new String[0])\n                        };\n                    }\n                };\n            }\n            \n            ChangesFileBuilder builder = new ChangesFileBuilder();\n            ChangesFile changesFile = builder.createChanges(packageControlFile, deb, changesProvider);\n            \n            if (keyring != null && key != null && passphrase != null) {\n                console.info(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n        \n        if (changesSave == null || !(changesProvider instanceof TextfileChangesProvider)) {\n            return;\n        }\n        \n        try {\n            console.info(\"Saving changes to file: \" + changesSave);\n\n            ((TextfileChangesProvider) changesProvider).save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n    \n    private List<String> populateConffiles(Collection<DataProducer> producers) {\n        final List<String> result = new ArrayList<String>();\n        \n        if (producers == null || producers.isEmpty()) {\n            return result;\n        }\n        \n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachDir( String dirname, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                //\n            }\n            \n            public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                String tempConffileItem = filename;\n                if (tempConffileItem.startsWith(\".\")) {\n                    tempConffileItem = tempConffileItem.substring(1);\n                }\n                console.info(\"Adding conffile: \" + tempConffileItem);\n                result.add(tempConffileItem);\n            }\n\n            public void onEachLink(String path, String linkname, boolean symlink, String user, int uid, String group, int gid, int mode) throws IOException {\n                //\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } catch(Exception e) {\n            //\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param pControlFiles\n     * @param pData\n     * @param deb\n     * @param compression   the compression method used for the data file\n     * @return BinaryPackageControlFile\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createDeb(Compression compression) throws PackagingException {\n        return createSignedDeb(compression, null, null);\n    }\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @param signatureGenerator   the signature generator\n     * \n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createSignedDeb(Compression compression, final PGPSignatureGenerator signatureGenerator, PGPSigner signer ) throws PackagingException {\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.debug(\"Building data\");\n            DataBuilder dataBuilder = new DataBuilder(console);\n            StringBuilder md5s = new StringBuilder();\n            BigInteger size = dataBuilder.buildData(dataProducers, tempData, md5s, compression);\n\n            console.info(\"Building conffiles\");\n            List<String> tempConffiles = populateConffiles(conffilesProducers);\n            \n            console.debug(\"Building control\");\n            ControlBuilder controlBuilder = new ControlBuilder(console, variableResolver, openReplaceToken, closeReplaceToken);\n            BinaryPackageControlFile packageControlFile = controlBuilder.createPackageControlFile(new File(control, \"control\"), size);\n            if (packageControlFile.get(\"Package\") == null) {\n                packageControlFile.set(\"Package\", packageName);\n            }\n            if (packageControlFile.get(\"Depends\") == null) {\n                packageControlFile.set(\"Depends\", depends);\n            }\n            if (packageControlFile.get(\"Section\") == null) {\n                packageControlFile.set(\"Section\", section);\n            }\n            if (packageControlFile.get(\"Description\") == null) {\n                packageControlFile.set(\"Description\", description);\n            }\n            if (packageControlFile.get(\"Homepage\") == null) {\n                packageControlFile.set(\"Homepage\", homepage);\n            }\n            \n            controlBuilder.buildControl(packageControlFile, control.listFiles(), tempConffiles , md5s, tempControl);\n            \n            if (!packageControlFile.isValid()) {\n                throw new PackagingException(\"Control file fields are invalid \" + packageControlFile.invalidFields() +\n                    \". The following fields are mandatory: \" + packageControlFile.getMandatoryFields() +\n                    \". Please check your pom.xml/build.xml and your control file.\");\n            }\n\n            deb.getParentFile().mkdirs();\n            \n            ArArchiveOutputStream ar = new ArArchiveOutputStream(new FileOutputStream(deb));\n            \n            String binaryName = \"debian-binary\";\n            String binaryContent = \"2.0\\n\";\n            String controlName = \"control.tar.gz\";\n            String dataName = \"data.tar\" + compression.getExtension();\n            \n            addTo(ar, binaryName, binaryContent);\n            addTo(ar, controlName, tempControl);\n            addTo(ar, dataName, tempData);\n            \n            if (signatureGenerator != null) {\n                console.info(\"Signing package with key \" + key);\n                \n                // Use debsig-verify as default\n                if(!signMethod.equals(\"dpkg-sig\")) {\n                \t// Sign file to verify with debsig-verify\n\t                PGPSignatureOutputStream sigStream = new PGPSignatureOutputStream(signatureGenerator);\n\t\n\t                addTo(sigStream, binaryContent);\n\t                addTo(sigStream, tempControl);\n\t                addTo(sigStream, tempData);\n\t                addTo(ar, \"_gpgorigin\", sigStream.generateASCIISignature());\n                } else {\n\t                // Sign file to verify with dpkg-sig --verify\n\t                final String outputStr =\n\t                            \"Version: 4\\n\" +\n\t                            \"Signer: \\n\" +\n\t                            \"Date: \" + new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy\", Locale.ENGLISH).format(new Date()) + \"\\n\" + \n\t                            \"Role: builder\\n\" + \n\t                            \"Files: \\n\" +\n\t                            addFile(binaryName, binaryContent) +\n\t                            addFile(controlName, tempControl) +\n\t                            addFile(dataName, tempData);\n\t                \n\t                ByteArrayOutputStream message = new ByteArrayOutputStream();\n\t                signer.clearSign(outputStr, message);\n\t                \n\t                addTo(ar, \"_gpgbuilder\", message.toString());\n                }\n            }\n\n            ar.close();\n            \n            return packageControlFile;\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempControl);\n                }\n            }\n        }\n    }\n\n    private String addFile(String name, String input){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addFile(String name, File input){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addLine(String md5, String sha1, long size, String name){\n    \treturn \"\\t\" + md5 + \" \" + sha1 + \" \" + size + \" \" + name + \"\\n\";\n    }\n    \n    private String md5Hash(String input){\n    \treturn md5Hash(input.getBytes());\n    }\n    \n    private String md5Hash(File input){\n    \ttry {\n\t\t\treturn md5Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String md5Hash(byte input[]){\n        //update the input of MD5\n        MD5Digest md5 = new MD5Digest();\n        md5.update(input, 0, input.length);\n\n        //get the output/ digest size and hash it\n        byte[] digest = new byte[md5.getDigestSize()];\n        md5.doFinal(digest, 0);\n\n        return new String(Hex.encode(digest));\n    }\n    \n    private String sha1Hash(String input){\n    \treturn sha1Hash(input.getBytes());\n    }\n    \n    private String sha1Hash(File input){\n    \ttry {\n\t\t\treturn sha1Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String sha1Hash(byte input[]){\n         try\n         {\n               //prepare the input\n               MessageDigest hash = MessageDigest.getInstance(\"SHA1\");\n               hash.update(input);\n\n               //proceed ....\n               byte[] digest = hash.digest();\n\n               return new String(Hex.encode(digest));\n         }\n         catch (NoSuchAlgorithmException e)\n         {\n               System.err.println(\"No such algorithm\");\n               e.printStackTrace();\n         }\n         \n         return null;\n    }\n    \n    private void addTo(ArArchiveOutputStream pOutput, String pName, String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, File pContent) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.write(content);\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final File pContent) throws IOException {\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n    }\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n    }\n}\n","lineNo":474}
{"Smelly Sample":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.bouncycastle.crypto.digests.MD5Digest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.signing.PGPSigner;\nimport org.vafer.jdeb.utils.PGPSignatureOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * A generic class for creating Debian archives. Even supports signed changes\n * files.\n *\n * @author Torsten Curdt\n * @author Bryan Sant\n */\npublic class DebMaker {\n\n    /** A console to output log message with */\n    private Console console;\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The name of the package. Default value if not specified in the control file */\n    private String packageName;\n\n    /** The section of the package. Default value if not specified in the control file */\n    private String section = \"java\";\n\n    /** The dependencies of the package. Default value if not specified in the control file */\n    private String depends = \"default-jre | java6-runtime\";\n\n    /** The description of the package. Default value if not specified in the control file */\n    private String description;\n\n    /** The homepage of the application. Default value if not specified in the control file */\n    private String homepage;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip, bzip2 or xz) */\n    private String compression = \"gzip\";\n\n    /** Whether to sign the package that is created */\n    private boolean signPackage;\n\n    private VariableResolver variableResolver;\n    private String openReplaceToken;\n    private String closeReplaceToken;\n\n    private final Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    private final Collection<DataProducer> conffilesProducers = new ArrayList<DataProducer>();\n\n\n    public DebMaker(Console console, Collection<DataProducer> dataProducers, Collection<DataProducer> conffileProducers) {\n        this.console = console;\n        if (dataProducers != null) {\n            this.dataProducers.addAll(dataProducers);\n        }\n        if (conffileProducers != null) {\n            this.conffilesProducers.addAll(conffileProducers);\n        }\n    }\n\n    public void setDeb(File deb) {\n        this.deb = deb;\n    }\n\n    public void setControl(File control) {\n        this.control = control;\n    }\n\n    public void setPackage(String packageName) {\n        this.packageName = packageName;\n    }\n\n    public void setSection(String section) {\n        this.section = section;\n    }\n\n    public void setDepends(String depends) {\n        this.depends = depends;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public void setHomepage(String homepage) {\n        this.homepage = homepage;\n    }\n\n    public void setChangesIn(File changes) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut(File changes) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave(File changes) {\n        this.changesSave = changes;\n    }\n\n    public void setSignPackage(boolean signPackage) {\n        this.signPackage = signPackage;\n    }\n\n    public void setKeyring(File keyring) {\n        this.keyring = keyring;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void setPassphrase(String passphrase) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression(String compression) {\n        this.compression = compression;\n    }\n\n    public void setResolver(VariableResolver variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    private boolean isWritableFile(File file) {\n        return !file.exists() || file.isFile() && file.canWrite();\n    }\n\n    /**\n     * Validates the input parameters.\n     */\n    public void validate() throws PackagingException {\n        if (control == null || !control.isDirectory()) {\n            throw new PackagingException(\"The 'control' attribute doesn't point to a directory.\");\n        }\n\n        if (changesIn != null) {\n\n            if (changesIn.exists() && (!changesIn.isFile() || !changesIn.canRead())) {\n                throw new PackagingException(\"The 'changesIn' setting needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n            \n            if (changesOut != null && !isWritableFile(changesOut)) {\n                throw new PackagingException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isWritableFile(changesSave)) {\n                throw new PackagingException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new PackagingException(\"The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new PackagingException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip', 'bzip2' or 'xz')\");\n        }\n\n        if (deb == null) {\n            throw new PackagingException(\"You need to specify where the deb file is supposed to be created.\");\n        }\n        \n        if (dataProducers.size() == 0) {\n            throw new PackagingException(\"You need to provide at least one reference to a tgz or directory with data.\");\n        }\n    }\n\n    public void makeDeb() throws PackagingException {\n        BinaryPackageControlFile packageControlFile;\n        try {\n            console.info(\"Creating debian package: \" + deb);\n\n            // If we should sign the package\n            boolean doSign = signPackage;\n\n            if (keyring == null || !keyring.exists()) {\n                doSign = false;\n                console.warn(\"Signing requested, but no keyring supplied\");\n            }\n\n            if (key == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no key supplied\");\n            }\n\n            if (passphrase == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no passphrase supplied\");\n            }\n\n            if (doSign) {\n                FileInputStream keyRingInput = new FileInputStream(keyring);\n                PGPSigner signer = null;\n                try {\n                    signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                } finally {\n                    keyRingInput.close();\n                }\n\n                int digest = PGPUtil.SHA1;\n\n                PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(signer.getSecretKey().getPublicKey().getAlgorithm(), digest));\n                signatureGenerator.init(PGPSignature.BINARY_DOCUMENT, signer.getPrivateKey());\n\n                packageControlFile = createSignedDeb(Compression.toEnum(compression), signatureGenerator, signer);\n            } else {\n                packageControlFile = createDeb(Compression.toEnum(compression));\n            }\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create debian package \" + deb, e);\n        }\n        \n        makeChangesFiles(packageControlFile);\n    }\n\n    private void makeChangesFiles(final BinaryPackageControlFile packageControlFile) throws PackagingException {\n        if (changesOut == null) {\n            changesOut = new File(deb.getParentFile(), deb.getName().replace(\".deb\", \".changes\"));\n        }\n        \n        ChangesProvider changesProvider;\n        FileOutputStream out = null;\n        \n        try {\n            console.info(\"Creating changes file: \" + changesOut);\n            \n            out = new FileOutputStream(changesOut);\n            \n            if (changesIn != null && changesIn.exists()) {\n                // read the changes form a textfile provider\n                changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            } else {\n                // create an empty changelog\n                changesProvider = new ChangesProvider() {\n                    @Override\n                    public ChangeSet[] getChangesSets() {\n                        return new ChangeSet[] {\n                                new ChangeSet(packageControlFile.get(\"Package\"),\n                                        packageControlFile.get(\"Version\"),\n                                        new Date(),\n                                        packageControlFile.get(\"Distribution\"),\n                                        packageControlFile.get(\"Urgency\"),\n                                        packageControlFile.get(\"Maintainer\"),\n                                        new String[0])\n                        };\n                    }\n                };\n            }\n            \n            ChangesFileBuilder builder = new ChangesFileBuilder();\n            ChangesFile changesFile = builder.createChanges(packageControlFile, deb, changesProvider);\n            \n            if (keyring != null && key != null && passphrase != null) {\n                console.info(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n        \n        if (changesSave == null || !(changesProvider instanceof TextfileChangesProvider)) {\n            return;\n        }\n        \n        try {\n            console.info(\"Saving changes to file: \" + changesSave);\n\n            ((TextfileChangesProvider) changesProvider).save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n    \n    private List<String> populateConffiles(Collection<DataProducer> producers) {\n        final List<String> result = new ArrayList<String>();\n        \n        if (producers == null || producers.isEmpty()) {\n            return result;\n        }\n        \n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachDir( String dirname, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                //\n            }\n            \n            public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                String tempConffileItem = filename;\n                if (tempConffileItem.startsWith(\".\")) {\n                    tempConffileItem = tempConffileItem.substring(1);\n                }\n                console.info(\"Adding conffile: \" + tempConffileItem);\n                result.add(tempConffileItem);\n            }\n\n            public void onEachLink(String path, String linkname, boolean symlink, String user, int uid, String group, int gid, int mode) throws IOException {\n                //\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } catch(Exception e) {\n            //\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param pControlFiles\n     * @param pData\n     * @param deb\n     * @param compression   the compression method used for the data file\n     * @return BinaryPackageControlFile\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createDeb(Compression compression) throws PackagingException {\n        return createSignedDeb(compression, null, null);\n    }\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @param signatureGenerator   the signature generator\n     * \n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createSignedDeb(Compression compression, final PGPSignatureGenerator signatureGenerator, PGPSigner signer ) throws PackagingException {\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.debug(\"Building data\");\n            DataBuilder dataBuilder = new DataBuilder(console);\n            StringBuilder md5s = new StringBuilder();\n            BigInteger size = dataBuilder.buildData(dataProducers, tempData, md5s, compression);\n\n            console.info(\"Building conffiles\");\n            List<String> tempConffiles = populateConffiles(conffilesProducers);\n            \n            console.debug(\"Building control\");\n            ControlBuilder controlBuilder = new ControlBuilder(console, variableResolver, openReplaceToken, closeReplaceToken);\n            BinaryPackageControlFile packageControlFile = controlBuilder.createPackageControlFile(new File(control, \"control\"), size);\n            if (packageControlFile.get(\"Package\") == null) {\n                packageControlFile.set(\"Package\", packageName);\n            }\n            if (packageControlFile.get(\"Depends\") == null) {\n                packageControlFile.set(\"Depends\", depends);\n            }\n            if (packageControlFile.get(\"Section\") == null) {\n                packageControlFile.set(\"Section\", section);\n            }\n            if (packageControlFile.get(\"Description\") == null) {\n                packageControlFile.set(\"Description\", description);\n            }\n            if (packageControlFile.get(\"Homepage\") == null) {\n                packageControlFile.set(\"Homepage\", homepage);\n            }\n            \n            controlBuilder.buildControl(packageControlFile, control.listFiles(), tempConffiles , md5s, tempControl);\n            \n            if (!packageControlFile.isValid()) {\n                throw new PackagingException(\"Control file fields are invalid \" + packageControlFile.invalidFields() +\n                    \". The following fields are mandatory: \" + packageControlFile.getMandatoryFields() +\n                    \". Please check your pom.xml/build.xml and your control file.\");\n            }\n\n            deb.getParentFile().mkdirs();\n            \n            \n            ArArchiveOutputStream ar = new ArArchiveOutputStream(new FileOutputStream(deb));\n            \n            addTo(ar, \"debian-binary\", \"2.0\\n\");\n            addTo(ar, \"control.tar.gz\", tempControl);\n            addTo(ar, \"data.tar\" + compression.getExtension(), tempData);\n            \n            if (signatureGenerator != null) {\n                console.info(\"Signing package with key \" + key);\n                \n                // Sign file to verify with debsign-verify\n                PGPSignatureOutputStream sigStream = new PGPSignatureOutputStream(signatureGenerator);\n\n                addTo(sigStream, \"2.0\\n\");\n                addTo(sigStream, tempControl);\n                addTo(sigStream, tempData);\n                addTo(ar, \"_gpgorigin\", sigStream.generateASCIISignature());\n                \n                // Sign file to verify with dpkg-sig --verify\n                final String outputStr =\n                            \"Version: 4\\n\" +\n                            \"Signer: \\n\" +\n                            \"Date: \" + new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy\", Locale.ENGLISH).format(new Date()).replaceFirst(\"0\", \" \") + \"\\n\" + \n                            \"Role: builder\\n\" + \n                            \"Files: \\n\" +\n                            addFile(\"2.0\\n\", \"debian-binary\") +\n                            addFile(tempControl, \"control.tar.gz\") +\n                            addFile(tempData, \"data.tar\" + compression.getExtension());\n                \n                ByteArrayOutputStream message = new ByteArrayOutputStream();\n                signer.clearSign(outputStr, message);\n                \n                addTo(ar, \"_gpgbuilder\", message.toString());\n            }\n\n            ar.close();\n            \n            return packageControlFile;\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempControl);\n                }\n            }\n        }\n    }\n\n    private String addFile(String input, String name){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addFile(File input, String name){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addLine(String md5, String sha1, long size, String name){\n    \treturn \"\\t\" + md5 + \" \" + sha1 + \" \" + size + \" \" + name + \"\\n\";\n    }\n    \n    private String md5Hash(String input){\n    \treturn md5Hash(input.getBytes());\n    }\n    \n    private String md5Hash(File input){\n    \ttry {\n\t\t\treturn md5Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String md5Hash(byte input[]){\n    \t//add the security provider\n        //not required if you have Install the library\n        //by Configuring the Java Runtime\n        Security.addProvider(new BouncyCastleProvider());\n\n        //update the input of MD5\n        MD5Digest md5 = new MD5Digest();\n        md5.update(input, 0, input.length);\n\n        //get the output/ digest size and hash it\n        byte[] digest = new byte[md5.getDigestSize()];\n        md5.doFinal(digest, 0);\n\n        return new String(Hex.encode(digest));\n    }\n    \n    private String sha1Hash(String input){\n    \treturn sha1Hash(input.getBytes());\n    }\n    \n    private String sha1Hash(File input){\n    \ttry {\n\t\t\treturn sha1Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String sha1Hash(byte input[]){\n    \t Security.addProvider(new BouncyCastleProvider());\n    \t \n         try\n         {\n               //prepare the input\n               //MessageDigest hash = MessageDigest.getInstance(\"SHA-1\", \"BC\");\n               MessageDigest hash = MessageDigest.getInstance(\"SHA1\");\n               hash.update(input);\n\n               //proceed ....\n               byte[] digest = hash.digest();\n\n               return new String(Hex.encode(digest));\n         }\n         catch (NoSuchAlgorithmException e)\n         {\n               System.err.println(\"No such algorithm\");\n               e.printStackTrace();\n         }\n//         catch (NoSuchProviderException e)\n//         {\n//               System.err.println(\"No such provider\");\n//               e.printStackTrace();\n//         }\n         \n         return null;\n    }\n    \n    private void addTo(ArArchiveOutputStream pOutput, String pName, String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, File pContent) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.write(content);\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final File pContent) throws IOException {\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n    }\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.bouncycastle.crypto.digests.MD5Digest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.signing.PGPSigner;\nimport org.vafer.jdeb.utils.PGPSignatureOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * A generic class for creating Debian archives. Even supports signed changes\n * files.\n *\n * @author Torsten Curdt\n * @author Bryan Sant\n */\npublic class DebMaker {\n\n    /** A console to output log message with */\n    private Console console;\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The name of the package. Default value if not specified in the control file */\n    private String packageName;\n\n    /** The section of the package. Default value if not specified in the control file */\n    private String section = \"java\";\n\n    /** The dependencies of the package. Default value if not specified in the control file */\n    private String depends = \"default-jre | java6-runtime\";\n\n    /** The description of the package. Default value if not specified in the control file */\n    private String description;\n\n    /** The homepage of the application. Default value if not specified in the control file */\n    private String homepage;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip, bzip2 or xz) */\n    private String compression = \"gzip\";\n\n    /** Whether to sign the package that is created */\n    private boolean signPackage;\n\n    /** Whether to sign the package that is created */\n    private String signMethod;\n    \n    private VariableResolver variableResolver;\n    private String openReplaceToken;\n    private String closeReplaceToken;\n\n    private final Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    private final Collection<DataProducer> conffilesProducers = new ArrayList<DataProducer>();\n\n\n    public DebMaker(Console console, Collection<DataProducer> dataProducers, Collection<DataProducer> conffileProducers) {\n        this.console = console;\n        if (dataProducers != null) {\n            this.dataProducers.addAll(dataProducers);\n        }\n        if (conffileProducers != null) {\n            this.conffilesProducers.addAll(conffileProducers);\n        }\n        \n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    public void setDeb(File deb) {\n        this.deb = deb;\n    }\n\n    public void setControl(File control) {\n        this.control = control;\n    }\n\n    public void setPackage(String packageName) {\n        this.packageName = packageName;\n    }\n\n    public void setSection(String section) {\n        this.section = section;\n    }\n\n    public void setDepends(String depends) {\n        this.depends = depends;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public void setHomepage(String homepage) {\n        this.homepage = homepage;\n    }\n\n    public void setChangesIn(File changes) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut(File changes) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave(File changes) {\n        this.changesSave = changes;\n    }\n\n    public void setSignPackage(boolean signPackage) {\n        this.signPackage = signPackage;\n    }\n    \n    public void setSignMethod(String signMethod) {\n        this.signMethod = signMethod;\n    }\n\n    public void setKeyring(File keyring) {\n        this.keyring = keyring;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public void setPassphrase(String passphrase) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression(String compression) {\n        this.compression = compression;\n    }\n\n    public void setResolver(VariableResolver variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    private boolean isWritableFile(File file) {\n        return !file.exists() || file.isFile() && file.canWrite();\n    }\n\n    /**\n     * Validates the input parameters.\n     */\n    public void validate() throws PackagingException {\n        if (control == null || !control.isDirectory()) {\n            throw new PackagingException(\"The 'control' attribute doesn't point to a directory.\");\n        }\n\n        if (changesIn != null) {\n\n            if (changesIn.exists() && (!changesIn.isFile() || !changesIn.canRead())) {\n                throw new PackagingException(\"The 'changesIn' setting needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n            \n            if (changesOut != null && !isWritableFile(changesOut)) {\n                throw new PackagingException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isWritableFile(changesSave)) {\n                throw new PackagingException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new PackagingException(\"The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new PackagingException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip', 'bzip2' or 'xz')\");\n        }\n\n        if (deb == null) {\n            throw new PackagingException(\"You need to specify where the deb file is supposed to be created.\");\n        }\n        \n        if (dataProducers.size() == 0) {\n            throw new PackagingException(\"You need to provide at least one reference to a tgz or directory with data.\");\n        }\n    }\n\n    public void makeDeb() throws PackagingException {\n        BinaryPackageControlFile packageControlFile;\n        try {\n            console.info(\"Creating debian package: \" + deb);\n\n            // If we should sign the package\n            boolean doSign = signPackage;\n\n            if (keyring == null || !keyring.exists()) {\n                doSign = false;\n                console.warn(\"Signing requested, but no keyring supplied\");\n            }\n\n            if (key == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no key supplied\");\n            }\n\n            if (passphrase == null) {\n                doSign = false;\n                console.warn(\"Signing requested, but no passphrase supplied\");\n            }\n\n            if (doSign) {\n                FileInputStream keyRingInput = new FileInputStream(keyring);\n                PGPSigner signer = null;\n                try {\n                    signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                } finally {\n                    keyRingInput.close();\n                }\n\n                int digest = PGPUtil.SHA1;\n\n                PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(signer.getSecretKey().getPublicKey().getAlgorithm(), digest));\n                signatureGenerator.init(PGPSignature.BINARY_DOCUMENT, signer.getPrivateKey());\n\n                packageControlFile = createSignedDeb(Compression.toEnum(compression), signatureGenerator, signer);\n            } else {\n                packageControlFile = createDeb(Compression.toEnum(compression));\n            }\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create debian package \" + deb, e);\n        }\n        \n        makeChangesFiles(packageControlFile);\n    }\n\n    private void makeChangesFiles(final BinaryPackageControlFile packageControlFile) throws PackagingException {\n        if (changesOut == null) {\n            changesOut = new File(deb.getParentFile(), deb.getName().replace(\".deb\", \".changes\"));\n        }\n        \n        ChangesProvider changesProvider;\n        FileOutputStream out = null;\n        \n        try {\n            console.info(\"Creating changes file: \" + changesOut);\n            \n            out = new FileOutputStream(changesOut);\n            \n            if (changesIn != null && changesIn.exists()) {\n                // read the changes form a textfile provider\n                changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            } else {\n                // create an empty changelog\n                changesProvider = new ChangesProvider() {\n                    @Override\n                    public ChangeSet[] getChangesSets() {\n                        return new ChangeSet[] {\n                                new ChangeSet(packageControlFile.get(\"Package\"),\n                                        packageControlFile.get(\"Version\"),\n                                        new Date(),\n                                        packageControlFile.get(\"Distribution\"),\n                                        packageControlFile.get(\"Urgency\"),\n                                        packageControlFile.get(\"Maintainer\"),\n                                        new String[0])\n                        };\n                    }\n                };\n            }\n            \n            ChangesFileBuilder builder = new ChangesFileBuilder();\n            ChangesFile changesFile = builder.createChanges(packageControlFile, deb, changesProvider);\n            \n            if (keyring != null && key != null && passphrase != null) {\n                console.info(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n        \n        if (changesSave == null || !(changesProvider instanceof TextfileChangesProvider)) {\n            return;\n        }\n        \n        try {\n            console.info(\"Saving changes to file: \" + changesSave);\n\n            ((TextfileChangesProvider) changesProvider).save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n    \n    private List<String> populateConffiles(Collection<DataProducer> producers) {\n        final List<String> result = new ArrayList<String>();\n        \n        if (producers == null || producers.isEmpty()) {\n            return result;\n        }\n        \n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachDir( String dirname, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                //\n            }\n            \n            public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                String tempConffileItem = filename;\n                if (tempConffileItem.startsWith(\".\")) {\n                    tempConffileItem = tempConffileItem.substring(1);\n                }\n                console.info(\"Adding conffile: \" + tempConffileItem);\n                result.add(tempConffileItem);\n            }\n\n            public void onEachLink(String path, String linkname, boolean symlink, String user, int uid, String group, int gid, int mode) throws IOException {\n                //\n            }\n        };\n\n        try {\n            for (DataProducer data : producers) {\n                data.produce(receiver);\n            }\n        } catch(Exception e) {\n            //\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param pControlFiles\n     * @param pData\n     * @param deb\n     * @param compression   the compression method used for the data file\n     * @return BinaryPackageControlFile\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createDeb(Compression compression) throws PackagingException {\n        return createSignedDeb(compression, null, null);\n    }\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param compression   the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @param signatureGenerator   the signature generator\n     * \n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public BinaryPackageControlFile createSignedDeb(Compression compression, final PGPSignatureGenerator signatureGenerator, PGPSigner signer ) throws PackagingException {\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.debug(\"Building data\");\n            DataBuilder dataBuilder = new DataBuilder(console);\n            StringBuilder md5s = new StringBuilder();\n            BigInteger size = dataBuilder.buildData(dataProducers, tempData, md5s, compression);\n\n            console.info(\"Building conffiles\");\n            List<String> tempConffiles = populateConffiles(conffilesProducers);\n            \n            console.debug(\"Building control\");\n            ControlBuilder controlBuilder = new ControlBuilder(console, variableResolver, openReplaceToken, closeReplaceToken);\n            BinaryPackageControlFile packageControlFile = controlBuilder.createPackageControlFile(new File(control, \"control\"), size);\n            if (packageControlFile.get(\"Package\") == null) {\n                packageControlFile.set(\"Package\", packageName);\n            }\n            if (packageControlFile.get(\"Depends\") == null) {\n                packageControlFile.set(\"Depends\", depends);\n            }\n            if (packageControlFile.get(\"Section\") == null) {\n                packageControlFile.set(\"Section\", section);\n            }\n            if (packageControlFile.get(\"Description\") == null) {\n                packageControlFile.set(\"Description\", description);\n            }\n            if (packageControlFile.get(\"Homepage\") == null) {\n                packageControlFile.set(\"Homepage\", homepage);\n            }\n            \n            controlBuilder.buildControl(packageControlFile, control.listFiles(), tempConffiles , md5s, tempControl);\n            \n            if (!packageControlFile.isValid()) {\n                throw new PackagingException(\"Control file fields are invalid \" + packageControlFile.invalidFields() +\n                    \". The following fields are mandatory: \" + packageControlFile.getMandatoryFields() +\n                    \". Please check your pom.xml/build.xml and your control file.\");\n            }\n\n            deb.getParentFile().mkdirs();\n            \n            ArArchiveOutputStream ar = new ArArchiveOutputStream(new FileOutputStream(deb));\n            \n            String binaryName = \"debian-binary\";\n            String binaryContent = \"2.0\\n\";\n            String controlName = \"control.tar.gz\";\n            String dataName = \"data.tar\" + compression.getExtension();\n            \n            addTo(ar, binaryName, binaryContent);\n            addTo(ar, controlName, tempControl);\n            addTo(ar, dataName, tempData);\n            \n            if (signatureGenerator != null) {\n                console.info(\"Signing package with key \" + key);\n                \n                // Use debsig-verify as default\n                if(!signMethod.equals(\"dpkg-sig\")) {\n                \t// Sign file to verify with debsig-verify\n\t                PGPSignatureOutputStream sigStream = new PGPSignatureOutputStream(signatureGenerator);\n\t\n\t                addTo(sigStream, binaryContent);\n\t                addTo(sigStream, tempControl);\n\t                addTo(sigStream, tempData);\n\t                addTo(ar, \"_gpgorigin\", sigStream.generateASCIISignature());\n                } else {\n\t                // Sign file to verify with dpkg-sig --verify\n\t                final String outputStr =\n\t                            \"Version: 4\\n\" +\n\t                            \"Signer: \\n\" +\n\t                            \"Date: \" + new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy\", Locale.ENGLISH).format(new Date()) + \"\\n\" + \n\t                            \"Role: builder\\n\" + \n\t                            \"Files: \\n\" +\n\t                            addFile(binaryName, binaryContent) +\n\t                            addFile(controlName, tempControl) +\n\t                            addFile(dataName, tempData);\n\t                \n\t                ByteArrayOutputStream message = new ByteArrayOutputStream();\n\t                signer.clearSign(outputStr, message);\n\t                \n\t                addTo(ar, \"_gpgbuilder\", message.toString());\n                }\n            }\n\n            ar.close();\n            \n            return packageControlFile;\n\n        } catch (Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    console.warn(\"Could not delete the temporary file \" + tempControl);\n                }\n            }\n        }\n    }\n\n    private String addFile(String name, String input){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addFile(String name, File input){\n    \treturn addLine(md5Hash(input), sha1Hash(input), input.length(), name);\n    }\n    \n    private String addLine(String md5, String sha1, long size, String name){\n    \treturn \"\\t\" + md5 + \" \" + sha1 + \" \" + size + \" \" + name + \"\\n\";\n    }\n    \n    private String md5Hash(String input){\n    \treturn md5Hash(input.getBytes());\n    }\n    \n    private String md5Hash(File input){\n    \ttry {\n\t\t\treturn md5Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String md5Hash(byte input[]){\n        //update the input of MD5\n        MD5Digest md5 = new MD5Digest();\n        md5.update(input, 0, input.length);\n\n        //get the output/ digest size and hash it\n        byte[] digest = new byte[md5.getDigestSize()];\n        md5.doFinal(digest, 0);\n\n        return new String(Hex.encode(digest));\n    }\n    \n    private String sha1Hash(String input){\n    \treturn sha1Hash(input.getBytes());\n    }\n    \n    private String sha1Hash(File input){\n    \ttry {\n\t\t\treturn sha1Hash(FileUtils.readFileToByteArray(input));\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t\n    \treturn null;\n    }\n    \n    private String sha1Hash(byte input[]){\n         try\n         {\n               //prepare the input\n               MessageDigest hash = MessageDigest.getInstance(\"SHA1\");\n               hash.update(input);\n\n               //proceed ....\n               byte[] digest = hash.digest();\n\n               return new String(Hex.encode(digest));\n         }\n         catch (NoSuchAlgorithmException e)\n         {\n               System.err.println(\"No such algorithm\");\n               e.printStackTrace();\n         }\n         \n         return null;\n    }\n    \n    private void addTo(ArArchiveOutputStream pOutput, String pName, String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(ArArchiveOutputStream pOutput, String pName, File pContent) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final String pContent) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.write(content);\n    }\n\n    private void addTo(final PGPSignatureOutputStream pOutput, final File pContent) throws IOException {\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n    }\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n    }\n}\n","lineNo":475}
{"Smelly Sample":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.tools.ant.filters.FixCrLfFilter;\nimport org.apache.tools.ant.util.ReaderInputStream;\n\n/**\n * Simple utils functions.\n *\n * ATTENTION: don't use outside of jdeb\n *\n * @author Torsten Curdt <tcurdt@vafer.org>\n */\npublic final class Utils {\n\n    public static int copy( final InputStream pInput, final OutputStream pOutput ) throws IOException {\n        final byte[] buffer = new byte[2048];\n        int count = 0;\n        int n;\n        while (-1 != (n = pInput.read(buffer))) {\n            pOutput.write(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    public static String toHex( final byte[] bytes ) {\n        final StringBuilder sb = new StringBuilder();\n\n        for (byte b : bytes) {\n            sb.append(Integer.toHexString((b >> 4) & 0x0f));\n            sb.append(Integer.toHexString(b & 0x0f));\n        }\n\n        return sb.toString();\n    }\n\n    public static String stripPath( final int p, final String s ) {\n\n        if (p <= 0) {\n            return s;\n        }\n\n        int x = 0;\n        for (int i = 0; i < p; i++) {\n            x = s.indexOf('/', x + 1);\n            if (x < 0) {\n                return s;\n            }\n        }\n\n        return s.substring(x + 1);\n    }\n\n    public static String stripLeadingSlash( final String s ) {\n        if (s == null) {\n            return s;\n        }\n        if (s.length() == 0) {\n            return s;\n        }\n        if (s.charAt(0) == '/' || s.charAt(0) == '\\\\') {\n            return s.substring(1);\n        }\n        return s;\n    }\n\n    /**\n     * Substitute the variables in the given expression with the\n     * values from the resolver\n     *\n     * @param pResolver\n     * @param pExpression\n     */\n    public static String replaceVariables( final VariableResolver pResolver, final String pExpression, final String pOpen, final String pClose ) {\n        final char[] open = pOpen.toCharArray();\n        final char[] close = pClose.toCharArray();\n        \n        final StringBuilder out = new StringBuilder();\n        StringBuilder sb = new StringBuilder();\n        char[] last = null;\n        int wo = 0;\n        int wc = 0;\n        int level = 0;\n        for (char c : pExpression.toCharArray()) {\n            if (c == open[wo]) {\n                wo++;\n                if (open.length == wo) {\n                    // found open\n                    if (last == open) {\n                        out.append(open);\n                    }\n                    level++;\n                    out.append(sb);\n                    sb = new StringBuilder();\n                    wo = 0;\n                    last = open;\n                }\n            } else if (c == close[wc]) {\n                wc++;\n                if (close.length == wc) {\n                    // found close\n                    if (last == open) {\n                        final String variable = pResolver.get(sb.toString());\n                        if (variable != null) {\n                            out.append(variable);\n                        } else {\n                            out.append(open);\n                            out.append(sb);\n                            out.append(close);\n                        }\n                    } else {\n                        out.append(sb);\n                        out.append(close);\n                    }\n                    sb = new StringBuilder();\n                    level--;\n                    wc = 0;\n                    last = close;\n                }\n            } else {\n\n                if (wo > 0) {\n                    sb.append(open, 0, wo);\n                }\n\n                if (wc > 0) {\n                    sb.append(close, 0, wc);\n                }\n\n                sb.append(c);\n\n                wo = wc = 0;\n            }\n        }\n\n        if (level > 0) {\n            out.append(open);\n        }\n        out.append(sb);\n\n        return out.toString();\n    }\n\n    /**\n     * Replaces new line delimiters in the input stream with the Unix line feed.\n     *\n     * @param input\n     */\n    public static byte[] toUnixLineEndings( InputStream input ) throws IOException {\n        String encoding = \"ISO-8859-1\";\n        FixCrLfFilter filter = new FixCrLfFilter(new InputStreamReader(input, encoding));\n        filter.setEol(FixCrLfFilter.CrLf.newInstance(\"unix\"));\n\n        ByteArrayOutputStream filteredFile = new ByteArrayOutputStream();\n        Utils.copy(new ReaderInputStream(filter, encoding), filteredFile);\n\n        return filteredFile.toByteArray();\n    }\n\n    /**\n     * Convert the project version to a version suitable for a Debian package.\n     * -SNAPSHOT suffixes are replaced with a timestamp (~yyyyMMddHHmmss).\n     * The separator before a rc, alpha or beta version is replaced with '~'\n     * such that the version is always ordered before the final or GA release.\n     * \n     * @param version the project version to convert to a Debian package version\n     * @param timestamp the date used as the timestamp to replace the SNAPSHOT suffix\n     */\n    public static String convertToDebianVersion( String version, Date timestamp ) {\n        Pattern pattern1 = Pattern.compile(\"(.*)[\\\\-\\\\+]SNAPSHOT\");\n        Matcher matcher = pattern1.matcher(version);\n        if (matcher.matches()) {\n            version = matcher.group(1) + \"~\";\n            if (timestamp != null) {\n                version += new SimpleDateFormat(\"yyyyMMddHHmmss\").format(timestamp);\n            } else {\n                version += \"SNAPSHOT\";\n            }\n        }\n        \n        Pattern pattern2 = Pattern.compile(\"(.*?)([\\\\.\\\\-_]?)(alpha|beta|rc)(.*)\", Pattern.CASE_INSENSITIVE);\n        matcher = pattern2.matcher(version);\n        if (matcher.matches()) {\n            version = matcher.group(1) + \"~\" + matcher.group(3) + matcher.group(4);\n        }\n        \n        version = version.replace('-', '+');\n        \n        return version;\n    }\n\n    /**\n     * Construct new path by replacing file directory part. No\n     * files are actually modified.\n     * @param file path to move\n     * @param target new path directory\n     */\n    public static String movePath( final String file,\n                                   final String target ) {\n        final String name = new File(file).getName();\n        return target.endsWith(\"/\") ? target + name : target + '/' + name;\n    }\n\n    /**\n     * Extracts value from map if given value is null.\n     * @param value current value\n     * @param props properties to extract value from\n     * @param key property name to extract\n     * @return initial value or value extracted from map\n     */\n    public static String lookupIfEmpty( final String value,\n                                        final Map<String, String> props,\n                                        final String key ) {\n        return value != null ? value : props.get(key);\n    }\n    \n    /**\n     * Get the known locations where the secure keyring can be located.\n     * Looks through known locations of the GNU PG secure keyring.\n     * \n     * @return The location of the PGP secure keyring if it was found,\n     *         null otherwise\n     */\n    public static Collection<String> getKnownPGPSecureRingLocations() {\n        final LinkedHashSet<String> locations = new LinkedHashSet<String>();\n\n        final String os = System.getProperty(\"os.name\");\n        final boolean runOnWindows = os == null || os.toLowerCase().contains(\"win\");\n\n        if (runOnWindows) {\n            // The user's roaming profile on Windows, via environment\n            final String windowsRoaming = System.getenv(\"APPDATA\");\n            if (windowsRoaming != null) {\n                locations.add(joinPaths(windowsRoaming, \"gnupg\", \"secring.gpg\"));\n            }\n\n            // The user's local profile on Windows, via environment\n            final String windowsLocal = System.getenv(\"LOCALAPPDATA\");\n            if (windowsLocal != null) {\n                locations.add(joinPaths(windowsLocal, \"gnupg\", \"secring.gpg\"));\n            }\n\n            // The Windows installation directory\n            final String windir = System.getProperty(\"WINDIR\");\n            if (windir != null) {\n                // Local Profile on Windows 98 and ME\n                locations.add(joinPaths(windir, \"Application Data\", \"gnupg\", \"secring.gpg\"));\n            }\n        }\n\n        final String home = System.getProperty(\"user.home\");\n\n        if (home != null && runOnWindows) {\n            // These are for various flavours of Windows\n            // if the environment variables above have failed\n\n            // Roaming profile on Vista and later\n            locations.add(joinPaths(home, \"AppData\", \"Roaming\", \"gnupg\", \"secring.gpg\"));\n            // Local profile on Vista and later\n            locations.add(joinPaths(home, \"AppData\", \"Local\", \"gnupg\", \"secring.gpg\"));\n            // Roaming profile on 2000 and XP\n            locations.add(joinPaths(home, \"Application Data\", \"gnupg\", \"secring.gpg\"));\n            // Local profile on 2000 and XP\n            locations.add(joinPaths(home, \"Local Settings\", \"Application Data\", \"gnupg\", \"secring.gpg\"));\n        }\n\n        // *nix, including OS X\n        if (home != null) {\n            locations.add(joinPaths(home, \".gnupg\", \"secring.gpg\"));\n        }\n\n        return locations;\n    }\n\n    /**\n     * Tries to guess location of the user secure keyring using various\n     * heuristics.\n     *\n     * @return path to the keyring file\n     * @throws FileNotFoundException if no keyring file found\n     */\n    public static File guessKeyRingFile() throws FileNotFoundException {\n        final Collection<String> possibleLocations = getKnownPGPSecureRingLocations();\n        for (final String location : possibleLocations) {\n            final File candidate = new File(location);\n            if (candidate.exists()) {\n                return candidate;\n            }\n        }\n        final StringBuilder message = new StringBuilder(\"Could not locate secure keyring, locations tried: \");\n        final Iterator<String> it = possibleLocations.iterator();\n        while (it.hasNext()) {\n            message.append(it.next());\n            if (it.hasNext()) {\n                message.append(\", \");\n            }\n        }\n        throw new FileNotFoundException(message.toString());\n    }\n\n    /**\n     * Join together path elements with File.separator. Filters out null\n     * elements.\n     * \n     * @param elements The path elements to join\n     * @return elements concatenated together with File.separator\n     */\n    public static String joinPaths(String... elements) {\n        StringBuilder builder = new StringBuilder();\n        boolean first = true;\n        for (String element : elements) {\n            // Skip null elements\n            if (element == null) {\n                // This won't change the value of first if we skip elements\n                // in the beginning of the array\n                continue;\n            }\n            if (!first) {\n                builder.append(File.separatorChar);\n            }\n            builder.append(element);\n            first = false;\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Returns true if string is null or empty.\n     */\n    public static boolean isNullOrEmpty(final String str) {\n        return str == null || str.length() == 0;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2014 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.tools.ant.filters.FixCrLfFilter;\nimport org.apache.tools.ant.util.ReaderInputStream;\n\n/**\n * Simple utils functions.\n *\n * ATTENTION: don't use outside of jdeb\n *\n * @author Torsten Curdt <tcurdt@vafer.org>\n */\npublic final class Utils {\n\n    public static int copy( final InputStream pInput, final OutputStream pOutput ) throws IOException {\n        final byte[] buffer = new byte[2048];\n        int count = 0;\n        int n;\n        while (-1 != (n = pInput.read(buffer))) {\n            pOutput.write(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    public static String toHex( final byte[] bytes ) {\n        final StringBuilder sb = new StringBuilder();\n\n        for (byte b : bytes) {\n            sb.append(Integer.toHexString((b >> 4) & 0x0f));\n            sb.append(Integer.toHexString(b & 0x0f));\n        }\n\n        return sb.toString();\n    }\n\n    public static String stripPath( final int p, final String s ) {\n\n        if (p <= 0) {\n            return s;\n        }\n\n        int x = 0;\n        for (int i = 0; i < p; i++) {\n            x = s.indexOf('/', x + 1);\n            if (x < 0) {\n                return s;\n            }\n        }\n\n        return s.substring(x + 1);\n    }\n\n    public static String stripLeadingSlash( final String s ) {\n        if (s == null) {\n            return s;\n        }\n        if (s.length() == 0) {\n            return s;\n        }\n        if (s.charAt(0) == '/' || s.charAt(0) == '\\\\') {\n            return s.substring(1);\n        }\n        return s;\n    }\n\n    /**\n     * Substitute the variables in the given expression with the\n     * values from the resolver\n     *\n     * @param pResolver\n     * @param pExpression\n     */\n    public static String replaceVariables( final VariableResolver pResolver, final String pExpression, final String pOpen, final String pClose ) {\n        final char[] open = pOpen.toCharArray();\n        final char[] close = pClose.toCharArray();\n        \n        final StringBuilder out = new StringBuilder();\n        StringBuilder sb = new StringBuilder();\n        char[] last = null;\n        int wo = 0;\n        int wc = 0;\n        int level = 0;\n        for (char c : pExpression.toCharArray()) {\n            if (c == open[wo]) {\n                wo++;\n                if (open.length == wo) {\n                    // found open\n                    if (last == open) {\n                        out.append(open);\n                    }\n                    level++;\n                    out.append(sb);\n                    sb = new StringBuilder();\n                    wo = 0;\n                    last = open;\n                }\n            } else if (c == close[wc]) {\n                wc++;\n                if (close.length == wc) {\n                    // found close\n                    if (last == open) {\n                        final String variable = pResolver.get(sb.toString());\n                        if (variable != null) {\n                            out.append(variable);\n                        } else {\n                            out.append(open);\n                            out.append(sb);\n                            out.append(close);\n                        }\n                    } else {\n                        out.append(sb);\n                        out.append(close);\n                    }\n                    sb = new StringBuilder();\n                    level--;\n                    wc = 0;\n                    last = close;\n                }\n            } else {\n\n                if (wo > 0) {\n                    sb.append(open, 0, wo);\n                }\n\n                if (wc > 0) {\n                    sb.append(close, 0, wc);\n                }\n\n                sb.append(c);\n\n                wo = wc = 0;\n            }\n        }\n\n        if (level > 0) {\n            out.append(open);\n        }\n        out.append(sb);\n\n        return out.toString();\n    }\n\n    /**\n     * Replaces new line delimiters in the input stream with the Unix line feed.\n     *\n     * @param input\n     */\n    public static byte[] toUnixLineEndings( InputStream input ) throws IOException {\n        String encoding = \"ISO-8859-1\";\n        FixCrLfFilter filter = new FixCrLfFilter(new InputStreamReader(input, encoding));\n        filter.setEol(FixCrLfFilter.CrLf.newInstance(\"unix\"));\n\n        ByteArrayOutputStream filteredFile = new ByteArrayOutputStream();\n        Utils.copy(new ReaderInputStream(filter, encoding), filteredFile);\n\n        return filteredFile.toByteArray();\n    }\n\n    /**\n     * Convert the project version to a version suitable for a Debian package.\n     * -SNAPSHOT suffixes are replaced with a timestamp (~yyyyMMddHHmmss).\n     * The separator before a rc, alpha or beta version is replaced with '~'\n     * such that the version is always ordered before the final or GA release.\n     * \n     * @param version the project version to convert to a Debian package version\n     * @param timestamp the date used as the timestamp to replace the SNAPSHOT suffix\n     */\n    public static String convertToDebianVersion( String version, boolean apply, String envName, Date timestamp ) {\n        Pattern pattern1 = Pattern.compile(\"(.*)[\\\\-\\\\+]SNAPSHOT\");\n        Matcher matcher = pattern1.matcher(version);\n        if (matcher.matches()) {\n            version = matcher.group(1) + \"~\";\n\n            if (apply) {\n                final String envValue = System.getenv(envName);\n                final String snapshot = (envValue != null && envValue.length() > 0)\n                        ? envValue\n                        : new SimpleDateFormat(\"yyyyMMddHHmmss\").format(timestamp);\n                version += snapshot;\n            } else {\n                version += \"SNAPSHOT\";\n            }\n        }\n        \n        Pattern pattern2 = Pattern.compile(\"(.*?)([\\\\.\\\\-_]?)(alpha|beta|rc)(.*)\", Pattern.CASE_INSENSITIVE);\n        matcher = pattern2.matcher(version);\n        if (matcher.matches()) {\n            version = matcher.group(1) + \"~\" + matcher.group(3) + matcher.group(4);\n        }\n        \n        version = version.replace('-', '+');\n        \n        return version;\n    }\n\n    /**\n     * Construct new path by replacing file directory part. No\n     * files are actually modified.\n     * @param file path to move\n     * @param target new path directory\n     */\n    public static String movePath( final String file,\n                                   final String target ) {\n        final String name = new File(file).getName();\n        return target.endsWith(\"/\") ? target + name : target + '/' + name;\n    }\n\n    /**\n     * Extracts value from map if given value is null.\n     * @param value current value\n     * @param props properties to extract value from\n     * @param key property name to extract\n     * @return initial value or value extracted from map\n     */\n    public static String lookupIfEmpty( final String value,\n                                        final Map<String, String> props,\n                                        final String key ) {\n        return value != null ? value : props.get(key);\n    }\n    \n    /**\n     * Get the known locations where the secure keyring can be located.\n     * Looks through known locations of the GNU PG secure keyring.\n     * \n     * @return The location of the PGP secure keyring if it was found,\n     *         null otherwise\n     */\n    public static Collection<String> getKnownPGPSecureRingLocations() {\n        final LinkedHashSet<String> locations = new LinkedHashSet<String>();\n\n        final String os = System.getProperty(\"os.name\");\n        final boolean runOnWindows = os == null || os.toLowerCase().contains(\"win\");\n\n        if (runOnWindows) {\n            // The user's roaming profile on Windows, via environment\n            final String windowsRoaming = System.getenv(\"APPDATA\");\n            if (windowsRoaming != null) {\n                locations.add(joinPaths(windowsRoaming, \"gnupg\", \"secring.gpg\"));\n            }\n\n            // The user's local profile on Windows, via environment\n            final String windowsLocal = System.getenv(\"LOCALAPPDATA\");\n            if (windowsLocal != null) {\n                locations.add(joinPaths(windowsLocal, \"gnupg\", \"secring.gpg\"));\n            }\n\n            // The Windows installation directory\n            final String windir = System.getProperty(\"WINDIR\");\n            if (windir != null) {\n                // Local Profile on Windows 98 and ME\n                locations.add(joinPaths(windir, \"Application Data\", \"gnupg\", \"secring.gpg\"));\n            }\n        }\n\n        final String home = System.getProperty(\"user.home\");\n\n        if (home != null && runOnWindows) {\n            // These are for various flavours of Windows\n            // if the environment variables above have failed\n\n            // Roaming profile on Vista and later\n            locations.add(joinPaths(home, \"AppData\", \"Roaming\", \"gnupg\", \"secring.gpg\"));\n            // Local profile on Vista and later\n            locations.add(joinPaths(home, \"AppData\", \"Local\", \"gnupg\", \"secring.gpg\"));\n            // Roaming profile on 2000 and XP\n            locations.add(joinPaths(home, \"Application Data\", \"gnupg\", \"secring.gpg\"));\n            // Local profile on 2000 and XP\n            locations.add(joinPaths(home, \"Local Settings\", \"Application Data\", \"gnupg\", \"secring.gpg\"));\n        }\n\n        // *nix, including OS X\n        if (home != null) {\n            locations.add(joinPaths(home, \".gnupg\", \"secring.gpg\"));\n        }\n\n        return locations;\n    }\n\n    /**\n     * Tries to guess location of the user secure keyring using various\n     * heuristics.\n     *\n     * @return path to the keyring file\n     * @throws FileNotFoundException if no keyring file found\n     */\n    public static File guessKeyRingFile() throws FileNotFoundException {\n        final Collection<String> possibleLocations = getKnownPGPSecureRingLocations();\n        for (final String location : possibleLocations) {\n            final File candidate = new File(location);\n            if (candidate.exists()) {\n                return candidate;\n            }\n        }\n        final StringBuilder message = new StringBuilder(\"Could not locate secure keyring, locations tried: \");\n        final Iterator<String> it = possibleLocations.iterator();\n        while (it.hasNext()) {\n            message.append(it.next());\n            if (it.hasNext()) {\n                message.append(\", \");\n            }\n        }\n        throw new FileNotFoundException(message.toString());\n    }\n\n    /**\n     * Join together path elements with File.separator. Filters out null\n     * elements.\n     * \n     * @param elements The path elements to join\n     * @return elements concatenated together with File.separator\n     */\n    public static String joinPaths(String... elements) {\n        StringBuilder builder = new StringBuilder();\n        boolean first = true;\n        for (String element : elements) {\n            // Skip null elements\n            if (element == null) {\n                // This won't change the value of first if we skip elements\n                // in the beginning of the array\n                continue;\n            }\n            if (!first) {\n                builder.append(File.separatorChar);\n            }\n            builder.append(element);\n            first = false;\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Returns true if string is null or empty.\n     */\n    public static boolean isNullOrEmpty(final String str) {\n        return str == null || str.length() == 0;\n    }\n}\n","lineNo":208}
{"Smelly Sample":"/*\n * Copyright 2013 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.DebMaker;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.utils.FilteredFile;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * Creates Debian package\n */\n@Mojo(name = \"jdeb\", defaultPhase = LifecyclePhase.PACKAGE)\npublic class DebMojo extends AbstractPluginMojo {\n\n    @Component\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the name of deb package.\n     */\n    @Parameter\n    private String name;\n\n    /**\n     * Defines the pattern of the name of final artifacts. Possible\n     * substitutions are [[baseDir]] [[buildDir]] [[artifactId]] [[version]]\n     * [[extension]] and [[groupId]].\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.[[extension]]\")\n    private String deb;\n\n    /**\n     * Explicitly defines the path to the control directory. At least the\n     * control file is mandatory.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/src/deb/control\")\n    private String controlDir;\n\n    /**\n     * Explicitly define the file to read the changes from.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesIn;\n\n    /**\n     * Explicitly define the file where to write the changes to.\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.changes\")\n    private String changesOut;\n\n    /**\n     * Explicitly define the file where to write the changes of the changes input to.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip, bzip2 or xz)\n     */\n    @Parameter(defaultValue = \"gzip\")\n    private String compression;\n\n    /**\n     * Boolean option whether to attach the artifact to the project\n     */\n    @Parameter(defaultValue = \"true\")\n    private String attach;\n\n    /**\n     * The location where all package files will be installed. By default, all\n     * packages are installed in /opt (see the FHS here:\n     * http://www.pathname.com/\n     * fhs/pub/fhs-2.3.html#OPTADDONAPPLICATIONSOFTWAREPACKAGES)\n     */\n    @Parameter(defaultValue = \"/opt/[[artifactId]]\")\n    private String installDir;\n\n    /**\n     * The type of attached artifact\n     */\n    @Parameter(defaultValue = \"deb\")\n    private String type;\n\n    /**\n     * The project base directory\n     */\n    @Parameter(defaultValue = \"${basedir}\", required = true, readonly = true)\n    private File baseDir;\n\n    /**\n     * Run the plugin on all sub-modules.\n     * If set to false, the plugin will be run in the same folder where the\n     * mvn command was invoked\n     */\n    @Parameter(defaultValue = \"true\")\n    private boolean submodules;\n\n    /**\n     * The Maven Session Object\n     */\n    @Component\n    private MavenSession session;\n\n    /**\n     * The classifier of attached artifact\n     */\n    @Parameter\n    private String classifier;\n\n    /**\n     * \"data\" entries used to determine which files should be added to this deb.\n     * The \"data\" entries may specify a tarball (tar.gz, tar.bz2, tgz), a\n     * directory, or a normal file. An entry would look something like this in\n     * your pom.xml:\n     *\n     * <pre>\n     *   <build>\n     *     <plugins>\n     *       <plugin>\n     *       <artifactId>jdeb<\/artifactId>\n     *       <groupId>org.vafer<\/groupId>\n     *       ...\n     *       <configuration>\n     *         ...\n     *         <dataSet>\n     *           <data>\n     *             <src>${project.basedir}/target/my_archive.tar.gz<\/src>\n     *             <include>...<\/include>\n     *             <exclude>...<\/exclude>\n     *             <mapper>\n     *               <type>perm<\/type>\n     *               <strip>1<\/strip>\n     *               <prefix>/somewhere/else<\/prefix>\n     *               <user>santbj<\/user>\n     *               <group>santbj<\/group>\n     *               <mode>600<\/mode>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.build.directory}/data<\/src>\n     *             <include><\/include>\n     *             <exclude>**&#47;.svn<\/exclude>\n     *             <mapper>\n     *               <type>ls<\/type>\n     *               <src>mapping.txt<\/src>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <type>link<\/type>\n     *             <linkName>/a/path/on/the/target/fs<\/linkName>\n     *             <linkTarget>/a/sym/link/to/the/scr/file<\/linkTarget>\n     *             <symlink>true<\/symlink>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.basedir}/README.txt<\/src>\n     *           <\/data>\n     *         <\/dataSet>\n     *       <\/configuration>\n     *     <\/plugins>\n     *   <\/build>\n     * <\/pre>\n     */\n    @Parameter\n    private Data[] dataSet;\n\n    /**\n     * When SNAPSHOT version replace <code>SNAPSHOT<\/code> with current date\n     * and time to make sure each build is unique.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean timestamped;\n\n    /**\n     * If verbose is true more build messages are logged.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean verbose;\n\n    /**\n     * Indicates if the execution should be disabled. If <code>true<\/code>, nothing will occur during execution.\n     * \n     * @since 1.1\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean skip;\n\n    /* end of parameters */\n\n    private String openReplaceToken = \"[[\";\n    private String closeReplaceToken = \"]]\";\n    private Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    public void setOpenReplaceToken( String openReplaceToken ) {\n        this.openReplaceToken = openReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setOpenToken(openReplaceToken);\n    }\n\n    public void setCloseReplaceToken( String closeReplaceToken ) {\n        this.closeReplaceToken = closeReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setCloseToken(closeReplaceToken);\n    }\n\n    protected void setData( Data[] dataSet ) {\n        this.dataSet = dataSet;\n        dataProducers.clear();\n        if (dataSet != null) {\n            Collections.addAll(dataProducers, dataSet);\n        }\n    }\n\n    protected VariableResolver initializeVariableResolver( Map<String, String> variables ) {\n        ((Map) variables).putAll(getProject().getProperties());\n        ((Map) variables).putAll(System.getProperties());\n        variables.put(\"name\", name != null ? name : getProject().getName());\n        variables.put(\"artifactId\", getProject().getArtifactId());\n        variables.put(\"groupId\", getProject().getGroupId());\n        variables.put(\"version\", getProjectVersion());\n        variables.put(\"description\", getProject().getDescription());\n        variables.put(\"extension\", \"deb\");\n        variables.put(\"baseDir\", getProject().getBasedir().getAbsolutePath());\n        variables.put(\"buildDir\", buildDirectory.getAbsolutePath());\n        variables.put(\"project.version\", getProject().getVersion());\n        variables.put(\"url\", getProject().getUrl());\n\n        return new MapVariableResolver(variables);\n    }\n\n    /**\n     * Doc some cleanup and conversion on the Maven project version.\n     * <ul>\n     * <li>any \"-\" is replaced by \"+\"<\/li>\n     * <li>\"SNAPSHOT\" is replaced with the current time and date, prepended by \"~\"<\/li>\n     * <\/ul>\n     *\n     * @return the Maven project version\n     */\n    private String getProjectVersion() {\n        return Utils.convertToDebianVersion(getProject().getVersion(), this.timestamped ? session.getStartTime() : null);\n    }\n\n    /**\n     * @return whether or not Maven is currently operating in the execution root\n     */\n    private boolean isSubmodule() {\n        // FIXME there must be a better way\n        return !session.getExecutionRootDirectory().equalsIgnoreCase(baseDir.toString());\n    }\n\n    /**\n     * @return whether or not the main artifact was created\n     */\n    private boolean hasMainArtifact() {\n        final MavenProject project = getProject();\n        final Artifact artifact = project.getArtifact();\n        return artifact.getFile() != null && artifact.getFile().isFile();\n    }\n\n    /**\n     * Main entry point\n     *\n     * @throws MojoExecutionException on error\n     */\n    @Override\n    public void execute() throws MojoExecutionException {\n\n        final MavenProject project = getProject();\n\n        if (skip){\n            getLog().info(\"skipping execution\");\n            return;\n        }\n\n        if (isSubmodule() && !submodules) {\n            getLog().info(\"skipping sub module: jdeb executing at top-level only\");\n            return;\n        }\n\n        setData(dataSet);\n\n        Console console = new MojoConsole(getLog(), verbose);\n\n        final VariableResolver resolver = initializeVariableResolver(new HashMap<String, String>());\n\n        final File debFile = new File(Utils.replaceVariables(resolver, deb, openReplaceToken, closeReplaceToken));\n        final File controlDirFile = new File(Utils.replaceVariables(resolver, controlDir, openReplaceToken, closeReplaceToken));\n        final File installDirFile = new File(Utils.replaceVariables(resolver, installDir, openReplaceToken, closeReplaceToken));\n        final File changesInFile = new File(Utils.replaceVariables(resolver, changesIn, openReplaceToken, closeReplaceToken));\n        final File changesOutFile = new File(Utils.replaceVariables(resolver, changesOut, openReplaceToken, closeReplaceToken));\n        final File changesSaveFile = new File(Utils.replaceVariables(resolver, changesSave, openReplaceToken, closeReplaceToken));\n\n        // if there are no producers defined we try to use the artifacts\n        if (dataProducers.isEmpty()) {\n\n            if (!hasMainArtifact()) {\n\n                final String packaging = project.getPackaging();\n                if (\"pom\".equalsIgnoreCase(packaging)) {\n                    getLog().warn(\"Creating empty debian package.\");\n                } else {\n                    throw new MojoExecutionException(\n                        \"Nothing to include into the debian package. \" +\n                            \"Did you maybe forget to add a <data> tag or call the plugin directly?\");\n                }\n\n            } else {\n\n                Set<Artifact> artifacts = new HashSet<Artifact>();\n\n                artifacts.add(project.getArtifact());\n\n                for (Artifact artifact : (Set<Artifact>) project.getArtifacts()) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : (List<Artifact>) project.getAttachedArtifacts()) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : artifacts) {\n                    final File file = artifact.getFile();\n                    if (file != null) {\n                        dataProducers.add(new DataProducer() {\n                            @Override\n                            public void produce( final DataConsumer receiver ) {\n                                try {\n                                    receiver.onEachFile(\n                                        new FileInputStream(file),\n                                        new File(installDirFile, file.getName()).getAbsolutePath(),\n                                        \"\",\n                                        \"root\", 0, \"root\", 0,\n                                        TarEntry.DEFAULT_FILE_MODE,\n                                        file.length());\n                                } catch (Exception e) {\n                                    getLog().error(e);\n                                }\n                            }\n                        });\n                    } else {\n                        getLog().error(\"No file for artifact \" + artifact);\n                    }\n                }\n            }\n        }\n\n        try {\n            DebMaker debMaker = new DebMaker(console, dataProducers);\n            debMaker.setDeb(debFile);\n            debMaker.setControl(controlDirFile);\n            debMaker.setPackage(getProject().getArtifactId());\n            debMaker.setDescription(getProject().getDescription());\n            debMaker.setHomepage(getProject().getUrl());\n            debMaker.setChangesIn(changesInFile);\n            debMaker.setChangesOut(changesOutFile);\n            debMaker.setChangesSave(changesSaveFile);\n            debMaker.setCompression(compression);\n            debMaker.setResolver(resolver);\n            debMaker.validate();\n            debMaker.makeDeb();\n\n            // Always attach unless explicitly set to false\n            if (\"true\".equalsIgnoreCase(attach)) {\n                console.info(\"Attaching created debian package \" + debFile);\n                projectHelper.attachArtifact(project, type, classifier, debFile);\n            }\n\n        } catch (PackagingException e) {\n            getLog().error(\"Failed to create debian package \" + debFile, e);\n            throw new MojoExecutionException(\"Failed to create debian package \" + debFile, e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2013 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.maven.settings.Profile;\nimport org.apache.maven.settings.Settings;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.DebMaker;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.utils.FilteredFile;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\nimport static org.vafer.jdeb.utils.Utils.lookupIfEmpty;\n\n/**\n * Creates Debian package\n */\n@SuppressWarnings(\"unused\")\n@Mojo(name = \"jdeb\", defaultPhase = LifecyclePhase.PACKAGE)\npublic class DebMojo extends AbstractPluginMojo {\n\n    @Component\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the name of deb package.\n     */\n    @Parameter\n    private String name;\n\n    /**\n     * Defines the pattern of the name of final artifacts. Possible\n     * substitutions are [[baseDir]] [[buildDir]] [[artifactId]] [[version]]\n     * [[extension]] and [[groupId]].\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.[[extension]]\")\n    private String deb;\n\n    /**\n     * Explicitly defines the path to the control directory. At least the\n     * control file is mandatory.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/src/deb/control\")\n    private String controlDir;\n\n    /**\n     * Explicitly define the file to read the changes from.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesIn;\n\n    /**\n     * Explicitly define the file where to write the changes to.\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.changes\")\n    private String changesOut;\n\n    /**\n     * Explicitly define the file where to write the changes of the changes input to.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip, bzip2 or xz)\n     */\n    @Parameter(defaultValue = \"gzip\")\n    private String compression;\n\n    /**\n     * Boolean option whether to attach the artifact to the project\n     */\n    @Parameter(defaultValue = \"true\")\n    private String attach;\n\n    /**\n     * The location where all package files will be installed. By default, all\n     * packages are installed in /opt (see the FHS here:\n     * http://www.pathname.com/\n     * fhs/pub/fhs-2.3.html#OPTADDONAPPLICATIONSOFTWAREPACKAGES)\n     */\n    @Parameter(defaultValue = \"/opt/[[artifactId]]\")\n    private String installDir;\n\n    /**\n     * The type of attached artifact\n     */\n    @Parameter(defaultValue = \"deb\")\n    private String type;\n\n    /**\n     * The project base directory\n     */\n    @Parameter(defaultValue = \"${basedir}\", required = true, readonly = true)\n    private File baseDir;\n\n    /**\n     * Run the plugin on all sub-modules.\n     * If set to false, the plugin will be run in the same folder where the\n     * mvn command was invoked\n     */\n    @Parameter(defaultValue = \"true\")\n    private boolean submodules;\n\n    /**\n     * The Maven Session Object\n     */\n    @Component\n    private MavenSession session;\n\n    /**\n     * The classifier of attached artifact\n     */\n    @Parameter\n    private String classifier;\n\n    /**\n     * \"data\" entries used to determine which files should be added to this deb.\n     * The \"data\" entries may specify a tarball (tar.gz, tar.bz2, tgz), a\n     * directory, or a normal file. An entry would look something like this in\n     * your pom.xml:\n     *\n     * <pre>\n     *   <build>\n     *     <plugins>\n     *       <plugin>\n     *       <artifactId>jdeb<\/artifactId>\n     *       <groupId>org.vafer<\/groupId>\n     *       ...\n     *       <configuration>\n     *         ...\n     *         <dataSet>\n     *           <data>\n     *             <src>${project.basedir}/target/my_archive.tar.gz<\/src>\n     *             <include>...<\/include>\n     *             <exclude>...<\/exclude>\n     *             <mapper>\n     *               <type>perm<\/type>\n     *               <strip>1<\/strip>\n     *               <prefix>/somewhere/else<\/prefix>\n     *               <user>santbj<\/user>\n     *               <group>santbj<\/group>\n     *               <mode>600<\/mode>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.build.directory}/data<\/src>\n     *             <include><\/include>\n     *             <exclude>**&#47;.svn<\/exclude>\n     *             <mapper>\n     *               <type>ls<\/type>\n     *               <src>mapping.txt<\/src>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <type>link<\/type>\n     *             <linkName>/a/path/on/the/target/fs<\/linkName>\n     *             <linkTarget>/a/sym/link/to/the/scr/file<\/linkTarget>\n     *             <symlink>true<\/symlink>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.basedir}/README.txt<\/src>\n     *           <\/data>\n     *         <\/dataSet>\n     *       <\/configuration>\n     *     <\/plugins>\n     *   <\/build>\n     * <\/pre>\n     */\n    @Parameter\n    private Data[] dataSet;\n\n    /**\n     * When SNAPSHOT version replace <code>SNAPSHOT<\/code> with current date\n     * and time to make sure each build is unique.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean timestamped;\n\n    /**\n     * If verbose is true more build messages are logged.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean verbose;\n\n    /**\n     * Indicates if the execution should be disabled. If <code>true<\/code>, nothing will occur during execution.\n     * \n     * @since 1.1\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean skip;\n\n    /**\n     * If signPackage is true then a origin signature will be placed\n     * in the generated package.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean signPackage;\n\n    /**\n     * The keyring to use for signing operations.\n     */\n    @Parameter\n    private String keyring;\n\n    /**\n     * The key to use for signing operations.\n     */\n    @Parameter\n    private String key;\n\n    /**\n     * The passphrase to use for signing operations.\n     */\n    @Parameter\n    private String passphrase; \n\n    /**\n     * The prefix to use when reading signing variables\n     * from settings.\n     */\n    @Parameter(defaultValue = \"jdeb.\")\n    private String signCfgPrefix;\n\n    /**\n     * The settings.\n     */\n    @Parameter(defaultValue = \"${settings}\")\n    private Settings settings;\n\n    /* end of parameters */\n\n\n    private static final String KEY = \"key\";\n    private static final String KEYRING = \"keyring\";\n    private static final String PASSPHRASE = \"passphrase\";\n\n    private String openReplaceToken = \"[[\";\n    private String closeReplaceToken = \"]]\";\n    private Console console;\n    private Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    public void setOpenReplaceToken( String openReplaceToken ) {\n        this.openReplaceToken = openReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setOpenToken(openReplaceToken);\n    }\n\n    public void setCloseReplaceToken( String closeReplaceToken ) {\n        this.closeReplaceToken = closeReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setCloseToken(closeReplaceToken);\n    }\n\n    protected void setData( Data[] dataSet ) {\n        this.dataSet = dataSet;\n        dataProducers.clear();\n        if (dataSet != null) {\n            Collections.addAll(dataProducers, dataSet);\n        }\n    }\n\n    protected VariableResolver initializeVariableResolver( Map<String, String> variables ) {\n        @SuppressWarnings(\"unchecked\")\n        final Map<String, String> projectProperties = Map.class.cast(getProject().getProperties());\n        @SuppressWarnings(\"unchecked\")\n        final Map<String, String> systemProperties = Map.class.cast(System.getProperties());\n\n        variables.putAll(projectProperties);\n        variables.putAll(systemProperties);\n        variables.put(\"name\", name != null ? name : getProject().getName());\n        variables.put(\"artifactId\", getProject().getArtifactId());\n        variables.put(\"groupId\", getProject().getGroupId());\n        variables.put(\"version\", getProjectVersion());\n        variables.put(\"description\", getProject().getDescription());\n        variables.put(\"extension\", \"deb\");\n        variables.put(\"baseDir\", getProject().getBasedir().getAbsolutePath());\n        variables.put(\"buildDir\", buildDirectory.getAbsolutePath());\n        variables.put(\"project.version\", getProject().getVersion());\n        variables.put(\"url\", getProject().getUrl());\n\n        return new MapVariableResolver(variables);\n    }\n\n    /**\n     * Doc some cleanup and conversion on the Maven project version.\n     * <ul>\n     * <li>any \"-\" is replaced by \"+\"<\/li>\n     * <li>\"SNAPSHOT\" is replaced with the current time and date, prepended by \"~\"<\/li>\n     * <\/ul>\n     *\n     * @return the Maven project version\n     */\n    private String getProjectVersion() {\n        return Utils.convertToDebianVersion(getProject().getVersion(), this.timestamped ? session.getStartTime() : null);\n    }\n\n    /**\n     * @return whether or not Maven is currently operating in the execution root\n     */\n    private boolean isSubmodule() {\n        // FIXME there must be a better way\n        return !session.getExecutionRootDirectory().equalsIgnoreCase(baseDir.toString());\n    }\n\n    /**\n     * @return whether or not the main artifact was created\n     */\n    private boolean hasMainArtifact() {\n        final MavenProject project = getProject();\n        final Artifact artifact = project.getArtifact();\n        return artifact.getFile() != null && artifact.getFile().isFile();\n    }\n\n    /**\n     * Main entry point\n     *\n     * @throws MojoExecutionException on error\n     */\n    @Override\n    public void execute() throws MojoExecutionException {\n\n        final MavenProject project = getProject();\n\n        if (skip) {\n            getLog().info(\"skipping execution\");\n            return;\n        }\n\n        if (isSubmodule() && !submodules) {\n            getLog().info(\"skipping sub module: jdeb executing at top-level only\");\n            return;\n        }\n\n        setData(dataSet);\n\n        console = new MojoConsole(getLog(), verbose);\n\n        initializeSignProperties();\n\n        final VariableResolver resolver = initializeVariableResolver(new HashMap<String, String>());\n\n        final File debFile = new File(Utils.replaceVariables(resolver, deb, openReplaceToken, closeReplaceToken));\n        final File controlDirFile = new File(Utils.replaceVariables(resolver, controlDir, openReplaceToken, closeReplaceToken));\n        final File installDirFile = new File(Utils.replaceVariables(resolver, installDir, openReplaceToken, closeReplaceToken));\n        final File changesInFile = new File(Utils.replaceVariables(resolver, changesIn, openReplaceToken, closeReplaceToken));\n        final File changesOutFile = new File(Utils.replaceVariables(resolver, changesOut, openReplaceToken, closeReplaceToken));\n        final File changesSaveFile = new File(Utils.replaceVariables(resolver, changesSave, openReplaceToken, closeReplaceToken));\n        final File keyringFile = keyring == null ? null : new File(Utils.replaceVariables(resolver, keyring, openReplaceToken, closeReplaceToken));\n\n        // if there are no producers defined we try to use the artifacts\n        if (dataProducers.isEmpty()) {\n\n            if (!hasMainArtifact()) {\n\n                final String packaging = project.getPackaging();\n                if (\"pom\".equalsIgnoreCase(packaging)) {\n                    getLog().warn(\"Creating empty debian package.\");\n                } else {\n                    throw new MojoExecutionException(\n                        \"Nothing to include into the debian package. \" +\n                            \"Did you maybe forget to add a <data> tag or call the plugin directly?\");\n                }\n\n            } else {\n\n                Set<Artifact> artifacts = new HashSet<Artifact>();\n\n                artifacts.add(project.getArtifact());\n\n                @SuppressWarnings(\"unchecked\")\n                final Set<Artifact> projectArtifacts = project.getArtifacts();\n\n                for (Artifact artifact : projectArtifacts) {\n                    artifacts.add(artifact);\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                final List<Artifact> attachedArtifacts = project.getAttachedArtifacts();\n\n                for (Artifact artifact : attachedArtifacts) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : artifacts) {\n                    final File file = artifact.getFile();\n                    if (file != null) {\n                        dataProducers.add(new DataProducer() {\n                            @Override\n                            public void produce( final DataConsumer receiver ) {\n                                try {\n                                    receiver.onEachFile(\n                                        new FileInputStream(file),\n                                        new File(installDirFile, file.getName()).getAbsolutePath(),\n                                        \"\",\n                                        \"root\", 0, \"root\", 0,\n                                        TarEntry.DEFAULT_FILE_MODE,\n                                        file.length());\n                                } catch (Exception e) {\n                                    getLog().error(e);\n                                }\n                            }\n                        });\n                    } else {\n                        getLog().error(\"No file for artifact \" + artifact);\n                    }\n                }\n            }\n        }\n\n        try {\n            DebMaker debMaker = new DebMaker(console, dataProducers);\n            debMaker.setDeb(debFile);\n            debMaker.setControl(controlDirFile);\n            debMaker.setPackage(getProject().getArtifactId());\n            debMaker.setDescription(getProject().getDescription());\n            debMaker.setHomepage(getProject().getUrl());\n            debMaker.setChangesIn(changesInFile);\n            debMaker.setChangesOut(changesOutFile);\n            debMaker.setChangesSave(changesSaveFile);\n            debMaker.setCompression(compression);\n            debMaker.setKeyring(keyringFile);\n            debMaker.setKey(key);\n            debMaker.setPassphrase(passphrase);\n            debMaker.setSignPackage(signPackage);\n            debMaker.setResolver(resolver);\n            debMaker.validate();\n            debMaker.makeDeb();\n\n            // Always attach unless explicitly set to false\n            if (\"true\".equalsIgnoreCase(attach)) {\n                console.info(\"Attaching created debian package \" + debFile);\n                projectHelper.attachArtifact(project, type, classifier, debFile);\n            }\n\n        } catch (PackagingException e) {\n            getLog().error(\"Failed to create debian package \" + debFile, e);\n            throw new MojoExecutionException(\"Failed to create debian package \" + debFile, e);\n        }\n    }\n\n    /**\n     * Initializes unspecified sign properties using available defaults\n     * and global settings.\n     */\n    private void initializeSignProperties() {\n        if (!signPackage) {\n            return;\n        }\n\n        if (key != null && keyring != null && passphrase != null) {\n            return;\n        }\n\n        Map<String, String> properties =\n                readPropertiesFromActiveProfiles(signCfgPrefix, KEY, KEYRING, PASSPHRASE);\n\n        key = lookupIfEmpty(key, properties, KEY);\n        keyring = lookupIfEmpty(keyring, properties, KEYRING);\n        passphrase = lookupIfEmpty(passphrase, properties, PASSPHRASE);\n\n        if (keyring == null) {\n            try {\n                keyring = Utils.guessKeyRingFile().getAbsolutePath();\n                console.info(\"Located keyring at \" + keyring);\n            } catch (FileNotFoundException e) {\n                console.warn(e.getMessage());\n            }\n        }\n    }\n\n\n    /**\n     * Read properties from the active profiles.\n     *\n     * Goes through all active profiles (in the order the\n     * profiles are defined in settings.xml) and extracts\n     * the desired properties (if present). The prefix is\n     * used when looking up properties in the profile but\n     * not in the returned map.\n     *\n     * @param prefix The prefix to use or null if no prefix should be used\n     * @param properties The properties to read\n     *\n     * @return A map containing the values for the properties that were found\n     */\n    public Map<String, String> readPropertiesFromActiveProfiles( final String prefix,\n                                                                 final String... properties ) {\n        if (settings == null) {\n            console.debug(\"No maven setting injected\");\n            return Collections.emptyMap();\n        }\n\n        final List<String> activeProfilesList = settings.getActiveProfiles();\n        if (activeProfilesList.isEmpty()) {\n            console.debug(\"No active profiles found\");\n            return Collections.emptyMap();\n        }\n\n        final Map<String, String> map = new HashMap<String, String>();\n        final Set<String> activeProfiles = new HashSet<String>(activeProfilesList);\n\n        // Iterate over all active profiles in order\n        for (final Profile profile : settings.getProfiles()) {\n            // Check if the profile is active\n            final String profileId = profile.getId();\n            if (activeProfiles.contains(profileId)) {\n                console.debug(\"Trying active profile \" + profileId);\n                for (final String property : properties) {\n                    final String propKey = prefix != null ? prefix + property : property;\n                    final String value = profile.getProperties().getProperty(propKey);\n                    if (value != null) {\n                        console.debug(\"Found property \" + property + \" in profile \" + profileId);\n                        map.put(property, value);\n                    }\n                }\n            }\n        }\n\n        return map;\n    }\n\n}\n","lineNo":306}
{"Smelly Sample":"/*\n * Copyright 2013 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.DebMaker;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.utils.FilteredFile;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * Creates Debian package\n */\n@Mojo(name = \"jdeb\", defaultPhase = LifecyclePhase.PACKAGE)\npublic class DebMojo extends AbstractPluginMojo {\n\n    @Component\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the name of deb package.\n     */\n    @Parameter\n    private String name;\n\n    /**\n     * Defines the pattern of the name of final artifacts. Possible\n     * substitutions are [[baseDir]] [[buildDir]] [[artifactId]] [[version]]\n     * [[extension]] and [[groupId]].\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.[[extension]]\")\n    private String deb;\n\n    /**\n     * Explicitly defines the path to the control directory. At least the\n     * control file is mandatory.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/src/deb/control\")\n    private String controlDir;\n\n    /**\n     * Explicitly define the file to read the changes from.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesIn;\n\n    /**\n     * Explicitly define the file where to write the changes to.\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.changes\")\n    private String changesOut;\n\n    /**\n     * Explicitly define the file where to write the changes of the changes input to.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip, bzip2 or xz)\n     */\n    @Parameter(defaultValue = \"gzip\")\n    private String compression;\n\n    /**\n     * Boolean option whether to attach the artifact to the project\n     */\n    @Parameter(defaultValue = \"true\")\n    private String attach;\n\n    /**\n     * The location where all package files will be installed. By default, all\n     * packages are installed in /opt (see the FHS here:\n     * http://www.pathname.com/\n     * fhs/pub/fhs-2.3.html#OPTADDONAPPLICATIONSOFTWAREPACKAGES)\n     */\n    @Parameter(defaultValue = \"/opt/[[artifactId]]\")\n    private String installDir;\n\n    /**\n     * The type of attached artifact\n     */\n    @Parameter(defaultValue = \"deb\")\n    private String type;\n\n    /**\n     * The project base directory\n     */\n    @Parameter(defaultValue = \"${basedir}\", required = true, readonly = true)\n    private File baseDir;\n\n    /**\n     * Run the plugin on all sub-modules.\n     * If set to false, the plugin will be run in the same folder where the\n     * mvn command was invoked\n     */\n    @Parameter(defaultValue = \"true\")\n    private boolean submodules;\n\n    /**\n     * The Maven Session Object\n     */\n    @Component\n    private MavenSession session;\n\n    /**\n     * The classifier of attached artifact\n     */\n    @Parameter\n    private String classifier;\n\n    /**\n     * \"data\" entries used to determine which files should be added to this deb.\n     * The \"data\" entries may specify a tarball (tar.gz, tar.bz2, tgz), a\n     * directory, or a normal file. An entry would look something like this in\n     * your pom.xml:\n     *\n     * <pre>\n     *   <build>\n     *     <plugins>\n     *       <plugin>\n     *       <artifactId>jdeb<\/artifactId>\n     *       <groupId>org.vafer<\/groupId>\n     *       ...\n     *       <configuration>\n     *         ...\n     *         <dataSet>\n     *           <data>\n     *             <src>${project.basedir}/target/my_archive.tar.gz<\/src>\n     *             <include>...<\/include>\n     *             <exclude>...<\/exclude>\n     *             <mapper>\n     *               <type>perm<\/type>\n     *               <strip>1<\/strip>\n     *               <prefix>/somewhere/else<\/prefix>\n     *               <user>santbj<\/user>\n     *               <group>santbj<\/group>\n     *               <mode>600<\/mode>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.build.directory}/data<\/src>\n     *             <include><\/include>\n     *             <exclude>**&#47;.svn<\/exclude>\n     *             <mapper>\n     *               <type>ls<\/type>\n     *               <src>mapping.txt<\/src>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <type>link<\/type>\n     *             <linkName>/a/path/on/the/target/fs<\/linkName>\n     *             <linkTarget>/a/sym/link/to/the/scr/file<\/linkTarget>\n     *             <symlink>true<\/symlink>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.basedir}/README.txt<\/src>\n     *           <\/data>\n     *         <\/dataSet>\n     *       <\/configuration>\n     *     <\/plugins>\n     *   <\/build>\n     * <\/pre>\n     */\n    @Parameter\n    private Data[] dataSet;\n\n    /**\n     * When SNAPSHOT version replace <code>SNAPSHOT<\/code> with current date\n     * and time to make sure each build is unique.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean timestamped;\n\n    /**\n     * If verbose is true more build messages are logged.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean verbose;\n\n    /**\n     * Indicates if the execution should be disabled. If <code>true<\/code>, nothing will occur during execution.\n     * \n     * @since 1.1\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean skip;\n\n    /* end of parameters */\n\n    private String openReplaceToken = \"[[\";\n    private String closeReplaceToken = \"]]\";\n    private Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    public void setOpenReplaceToken( String openReplaceToken ) {\n        this.openReplaceToken = openReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setOpenToken(openReplaceToken);\n    }\n\n    public void setCloseReplaceToken( String closeReplaceToken ) {\n        this.closeReplaceToken = closeReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setCloseToken(closeReplaceToken);\n    }\n\n    protected void setData( Data[] dataSet ) {\n        this.dataSet = dataSet;\n        dataProducers.clear();\n        if (dataSet != null) {\n            Collections.addAll(dataProducers, dataSet);\n        }\n    }\n\n    protected VariableResolver initializeVariableResolver( Map<String, String> variables ) {\n        ((Map) variables).putAll(getProject().getProperties());\n        ((Map) variables).putAll(System.getProperties());\n        variables.put(\"name\", name != null ? name : getProject().getName());\n        variables.put(\"artifactId\", getProject().getArtifactId());\n        variables.put(\"groupId\", getProject().getGroupId());\n        variables.put(\"version\", getProjectVersion());\n        variables.put(\"description\", getProject().getDescription());\n        variables.put(\"extension\", \"deb\");\n        variables.put(\"baseDir\", getProject().getBasedir().getAbsolutePath());\n        variables.put(\"buildDir\", buildDirectory.getAbsolutePath());\n        variables.put(\"project.version\", getProject().getVersion());\n        variables.put(\"url\", getProject().getUrl());\n\n        return new MapVariableResolver(variables);\n    }\n\n    /**\n     * Doc some cleanup and conversion on the Maven project version.\n     * <ul>\n     * <li>any \"-\" is replaced by \"+\"<\/li>\n     * <li>\"SNAPSHOT\" is replaced with the current time and date, prepended by \"~\"<\/li>\n     * <\/ul>\n     *\n     * @return the Maven project version\n     */\n    private String getProjectVersion() {\n        return Utils.convertToDebianVersion(getProject().getVersion(), this.timestamped ? session.getStartTime() : null);\n    }\n\n    /**\n     * @return whether or not Maven is currently operating in the execution root\n     */\n    private boolean isSubmodule() {\n        // FIXME there must be a better way\n        return !session.getExecutionRootDirectory().equalsIgnoreCase(baseDir.toString());\n    }\n\n    /**\n     * @return whether or not the main artifact was created\n     */\n    private boolean hasMainArtifact() {\n        final MavenProject project = getProject();\n        final Artifact artifact = project.getArtifact();\n        return artifact.getFile() != null && artifact.getFile().isFile();\n    }\n\n    /**\n     * Main entry point\n     *\n     * @throws MojoExecutionException on error\n     */\n    @Override\n    public void execute() throws MojoExecutionException {\n\n        final MavenProject project = getProject();\n\n        if (skip){\n            getLog().info(\"skipping execution\");\n            return;\n        }\n\n        if (isSubmodule() && !submodules) {\n            getLog().info(\"skipping sub module: jdeb executing at top-level only\");\n            return;\n        }\n\n        setData(dataSet);\n\n        Console console = new MojoConsole(getLog(), verbose);\n\n        final VariableResolver resolver = initializeVariableResolver(new HashMap<String, String>());\n\n        final File debFile = new File(Utils.replaceVariables(resolver, deb, openReplaceToken, closeReplaceToken));\n        final File controlDirFile = new File(Utils.replaceVariables(resolver, controlDir, openReplaceToken, closeReplaceToken));\n        final File installDirFile = new File(Utils.replaceVariables(resolver, installDir, openReplaceToken, closeReplaceToken));\n        final File changesInFile = new File(Utils.replaceVariables(resolver, changesIn, openReplaceToken, closeReplaceToken));\n        final File changesOutFile = new File(Utils.replaceVariables(resolver, changesOut, openReplaceToken, closeReplaceToken));\n        final File changesSaveFile = new File(Utils.replaceVariables(resolver, changesSave, openReplaceToken, closeReplaceToken));\n\n        // if there are no producers defined we try to use the artifacts\n        if (dataProducers.isEmpty()) {\n\n            if (!hasMainArtifact()) {\n\n                final String packaging = project.getPackaging();\n                if (\"pom\".equalsIgnoreCase(packaging)) {\n                    getLog().warn(\"Creating empty debian package.\");\n                } else {\n                    throw new MojoExecutionException(\n                        \"Nothing to include into the debian package. \" +\n                            \"Did you maybe forget to add a <data> tag or call the plugin directly?\");\n                }\n\n            } else {\n\n                Set<Artifact> artifacts = new HashSet<Artifact>();\n\n                artifacts.add(project.getArtifact());\n\n                for (Artifact artifact : (Set<Artifact>) project.getArtifacts()) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : (List<Artifact>) project.getAttachedArtifacts()) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : artifacts) {\n                    final File file = artifact.getFile();\n                    if (file != null) {\n                        dataProducers.add(new DataProducer() {\n                            @Override\n                            public void produce( final DataConsumer receiver ) {\n                                try {\n                                    receiver.onEachFile(\n                                        new FileInputStream(file),\n                                        new File(installDirFile, file.getName()).getAbsolutePath(),\n                                        \"\",\n                                        \"root\", 0, \"root\", 0,\n                                        TarEntry.DEFAULT_FILE_MODE,\n                                        file.length());\n                                } catch (Exception e) {\n                                    getLog().error(e);\n                                }\n                            }\n                        });\n                    } else {\n                        getLog().error(\"No file for artifact \" + artifact);\n                    }\n                }\n            }\n        }\n\n        try {\n            DebMaker debMaker = new DebMaker(console, dataProducers);\n            debMaker.setDeb(debFile);\n            debMaker.setControl(controlDirFile);\n            debMaker.setPackage(getProject().getArtifactId());\n            debMaker.setDescription(getProject().getDescription());\n            debMaker.setHomepage(getProject().getUrl());\n            debMaker.setChangesIn(changesInFile);\n            debMaker.setChangesOut(changesOutFile);\n            debMaker.setChangesSave(changesSaveFile);\n            debMaker.setCompression(compression);\n            debMaker.setResolver(resolver);\n            debMaker.validate();\n            debMaker.makeDeb();\n\n            // Always attach unless explicitly set to false\n            if (\"true\".equalsIgnoreCase(attach)) {\n                console.info(\"Attaching created debian package \" + debFile);\n                projectHelper.attachArtifact(project, type, classifier, debFile);\n            }\n\n        } catch (PackagingException e) {\n            getLog().error(\"Failed to create debian package \" + debFile, e);\n            throw new MojoExecutionException(\"Failed to create debian package \" + debFile, e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2013 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.maven.settings.Profile;\nimport org.apache.maven.settings.Settings;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.DebMaker;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.utils.FilteredFile;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\nimport static org.vafer.jdeb.utils.Utils.lookupIfEmpty;\n\n/**\n * Creates Debian package\n */\n@SuppressWarnings(\"unused\")\n@Mojo(name = \"jdeb\", defaultPhase = LifecyclePhase.PACKAGE)\npublic class DebMojo extends AbstractPluginMojo {\n\n    @Component\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the name of deb package.\n     */\n    @Parameter\n    private String name;\n\n    /**\n     * Defines the pattern of the name of final artifacts. Possible\n     * substitutions are [[baseDir]] [[buildDir]] [[artifactId]] [[version]]\n     * [[extension]] and [[groupId]].\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.[[extension]]\")\n    private String deb;\n\n    /**\n     * Explicitly defines the path to the control directory. At least the\n     * control file is mandatory.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/src/deb/control\")\n    private String controlDir;\n\n    /**\n     * Explicitly define the file to read the changes from.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesIn;\n\n    /**\n     * Explicitly define the file where to write the changes to.\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.changes\")\n    private String changesOut;\n\n    /**\n     * Explicitly define the file where to write the changes of the changes input to.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip, bzip2 or xz)\n     */\n    @Parameter(defaultValue = \"gzip\")\n    private String compression;\n\n    /**\n     * Boolean option whether to attach the artifact to the project\n     */\n    @Parameter(defaultValue = \"true\")\n    private String attach;\n\n    /**\n     * The location where all package files will be installed. By default, all\n     * packages are installed in /opt (see the FHS here:\n     * http://www.pathname.com/\n     * fhs/pub/fhs-2.3.html#OPTADDONAPPLICATIONSOFTWAREPACKAGES)\n     */\n    @Parameter(defaultValue = \"/opt/[[artifactId]]\")\n    private String installDir;\n\n    /**\n     * The type of attached artifact\n     */\n    @Parameter(defaultValue = \"deb\")\n    private String type;\n\n    /**\n     * The project base directory\n     */\n    @Parameter(defaultValue = \"${basedir}\", required = true, readonly = true)\n    private File baseDir;\n\n    /**\n     * Run the plugin on all sub-modules.\n     * If set to false, the plugin will be run in the same folder where the\n     * mvn command was invoked\n     */\n    @Parameter(defaultValue = \"true\")\n    private boolean submodules;\n\n    /**\n     * The Maven Session Object\n     */\n    @Component\n    private MavenSession session;\n\n    /**\n     * The classifier of attached artifact\n     */\n    @Parameter\n    private String classifier;\n\n    /**\n     * \"data\" entries used to determine which files should be added to this deb.\n     * The \"data\" entries may specify a tarball (tar.gz, tar.bz2, tgz), a\n     * directory, or a normal file. An entry would look something like this in\n     * your pom.xml:\n     *\n     * <pre>\n     *   <build>\n     *     <plugins>\n     *       <plugin>\n     *       <artifactId>jdeb<\/artifactId>\n     *       <groupId>org.vafer<\/groupId>\n     *       ...\n     *       <configuration>\n     *         ...\n     *         <dataSet>\n     *           <data>\n     *             <src>${project.basedir}/target/my_archive.tar.gz<\/src>\n     *             <include>...<\/include>\n     *             <exclude>...<\/exclude>\n     *             <mapper>\n     *               <type>perm<\/type>\n     *               <strip>1<\/strip>\n     *               <prefix>/somewhere/else<\/prefix>\n     *               <user>santbj<\/user>\n     *               <group>santbj<\/group>\n     *               <mode>600<\/mode>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.build.directory}/data<\/src>\n     *             <include><\/include>\n     *             <exclude>**&#47;.svn<\/exclude>\n     *             <mapper>\n     *               <type>ls<\/type>\n     *               <src>mapping.txt<\/src>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <type>link<\/type>\n     *             <linkName>/a/path/on/the/target/fs<\/linkName>\n     *             <linkTarget>/a/sym/link/to/the/scr/file<\/linkTarget>\n     *             <symlink>true<\/symlink>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.basedir}/README.txt<\/src>\n     *           <\/data>\n     *         <\/dataSet>\n     *       <\/configuration>\n     *     <\/plugins>\n     *   <\/build>\n     * <\/pre>\n     */\n    @Parameter\n    private Data[] dataSet;\n\n    /**\n     * When SNAPSHOT version replace <code>SNAPSHOT<\/code> with current date\n     * and time to make sure each build is unique.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean timestamped;\n\n    /**\n     * If verbose is true more build messages are logged.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean verbose;\n\n    /**\n     * Indicates if the execution should be disabled. If <code>true<\/code>, nothing will occur during execution.\n     * \n     * @since 1.1\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean skip;\n\n    /**\n     * If signPackage is true then a origin signature will be placed\n     * in the generated package.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean signPackage;\n\n    /**\n     * The keyring to use for signing operations.\n     */\n    @Parameter\n    private String keyring;\n\n    /**\n     * The key to use for signing operations.\n     */\n    @Parameter\n    private String key;\n\n    /**\n     * The passphrase to use for signing operations.\n     */\n    @Parameter\n    private String passphrase; \n\n    /**\n     * The prefix to use when reading signing variables\n     * from settings.\n     */\n    @Parameter(defaultValue = \"jdeb.\")\n    private String signCfgPrefix;\n\n    /**\n     * The settings.\n     */\n    @Parameter(defaultValue = \"${settings}\")\n    private Settings settings;\n\n    /* end of parameters */\n\n\n    private static final String KEY = \"key\";\n    private static final String KEYRING = \"keyring\";\n    private static final String PASSPHRASE = \"passphrase\";\n\n    private String openReplaceToken = \"[[\";\n    private String closeReplaceToken = \"]]\";\n    private Console console;\n    private Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    public void setOpenReplaceToken( String openReplaceToken ) {\n        this.openReplaceToken = openReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setOpenToken(openReplaceToken);\n    }\n\n    public void setCloseReplaceToken( String closeReplaceToken ) {\n        this.closeReplaceToken = closeReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setCloseToken(closeReplaceToken);\n    }\n\n    protected void setData( Data[] dataSet ) {\n        this.dataSet = dataSet;\n        dataProducers.clear();\n        if (dataSet != null) {\n            Collections.addAll(dataProducers, dataSet);\n        }\n    }\n\n    protected VariableResolver initializeVariableResolver( Map<String, String> variables ) {\n        @SuppressWarnings(\"unchecked\")\n        final Map<String, String> projectProperties = Map.class.cast(getProject().getProperties());\n        @SuppressWarnings(\"unchecked\")\n        final Map<String, String> systemProperties = Map.class.cast(System.getProperties());\n\n        variables.putAll(projectProperties);\n        variables.putAll(systemProperties);\n        variables.put(\"name\", name != null ? name : getProject().getName());\n        variables.put(\"artifactId\", getProject().getArtifactId());\n        variables.put(\"groupId\", getProject().getGroupId());\n        variables.put(\"version\", getProjectVersion());\n        variables.put(\"description\", getProject().getDescription());\n        variables.put(\"extension\", \"deb\");\n        variables.put(\"baseDir\", getProject().getBasedir().getAbsolutePath());\n        variables.put(\"buildDir\", buildDirectory.getAbsolutePath());\n        variables.put(\"project.version\", getProject().getVersion());\n        variables.put(\"url\", getProject().getUrl());\n\n        return new MapVariableResolver(variables);\n    }\n\n    /**\n     * Doc some cleanup and conversion on the Maven project version.\n     * <ul>\n     * <li>any \"-\" is replaced by \"+\"<\/li>\n     * <li>\"SNAPSHOT\" is replaced with the current time and date, prepended by \"~\"<\/li>\n     * <\/ul>\n     *\n     * @return the Maven project version\n     */\n    private String getProjectVersion() {\n        return Utils.convertToDebianVersion(getProject().getVersion(), this.timestamped ? session.getStartTime() : null);\n    }\n\n    /**\n     * @return whether or not Maven is currently operating in the execution root\n     */\n    private boolean isSubmodule() {\n        // FIXME there must be a better way\n        return !session.getExecutionRootDirectory().equalsIgnoreCase(baseDir.toString());\n    }\n\n    /**\n     * @return whether or not the main artifact was created\n     */\n    private boolean hasMainArtifact() {\n        final MavenProject project = getProject();\n        final Artifact artifact = project.getArtifact();\n        return artifact.getFile() != null && artifact.getFile().isFile();\n    }\n\n    /**\n     * Main entry point\n     *\n     * @throws MojoExecutionException on error\n     */\n    @Override\n    public void execute() throws MojoExecutionException {\n\n        final MavenProject project = getProject();\n\n        if (skip) {\n            getLog().info(\"skipping execution\");\n            return;\n        }\n\n        if (isSubmodule() && !submodules) {\n            getLog().info(\"skipping sub module: jdeb executing at top-level only\");\n            return;\n        }\n\n        setData(dataSet);\n\n        console = new MojoConsole(getLog(), verbose);\n\n        initializeSignProperties();\n\n        final VariableResolver resolver = initializeVariableResolver(new HashMap<String, String>());\n\n        final File debFile = new File(Utils.replaceVariables(resolver, deb, openReplaceToken, closeReplaceToken));\n        final File controlDirFile = new File(Utils.replaceVariables(resolver, controlDir, openReplaceToken, closeReplaceToken));\n        final File installDirFile = new File(Utils.replaceVariables(resolver, installDir, openReplaceToken, closeReplaceToken));\n        final File changesInFile = new File(Utils.replaceVariables(resolver, changesIn, openReplaceToken, closeReplaceToken));\n        final File changesOutFile = new File(Utils.replaceVariables(resolver, changesOut, openReplaceToken, closeReplaceToken));\n        final File changesSaveFile = new File(Utils.replaceVariables(resolver, changesSave, openReplaceToken, closeReplaceToken));\n        final File keyringFile = keyring == null ? null : new File(Utils.replaceVariables(resolver, keyring, openReplaceToken, closeReplaceToken));\n\n        // if there are no producers defined we try to use the artifacts\n        if (dataProducers.isEmpty()) {\n\n            if (!hasMainArtifact()) {\n\n                final String packaging = project.getPackaging();\n                if (\"pom\".equalsIgnoreCase(packaging)) {\n                    getLog().warn(\"Creating empty debian package.\");\n                } else {\n                    throw new MojoExecutionException(\n                        \"Nothing to include into the debian package. \" +\n                            \"Did you maybe forget to add a <data> tag or call the plugin directly?\");\n                }\n\n            } else {\n\n                Set<Artifact> artifacts = new HashSet<Artifact>();\n\n                artifacts.add(project.getArtifact());\n\n                @SuppressWarnings(\"unchecked\")\n                final Set<Artifact> projectArtifacts = project.getArtifacts();\n\n                for (Artifact artifact : projectArtifacts) {\n                    artifacts.add(artifact);\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                final List<Artifact> attachedArtifacts = project.getAttachedArtifacts();\n\n                for (Artifact artifact : attachedArtifacts) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : artifacts) {\n                    final File file = artifact.getFile();\n                    if (file != null) {\n                        dataProducers.add(new DataProducer() {\n                            @Override\n                            public void produce( final DataConsumer receiver ) {\n                                try {\n                                    receiver.onEachFile(\n                                        new FileInputStream(file),\n                                        new File(installDirFile, file.getName()).getAbsolutePath(),\n                                        \"\",\n                                        \"root\", 0, \"root\", 0,\n                                        TarEntry.DEFAULT_FILE_MODE,\n                                        file.length());\n                                } catch (Exception e) {\n                                    getLog().error(e);\n                                }\n                            }\n                        });\n                    } else {\n                        getLog().error(\"No file for artifact \" + artifact);\n                    }\n                }\n            }\n        }\n\n        try {\n            DebMaker debMaker = new DebMaker(console, dataProducers);\n            debMaker.setDeb(debFile);\n            debMaker.setControl(controlDirFile);\n            debMaker.setPackage(getProject().getArtifactId());\n            debMaker.setDescription(getProject().getDescription());\n            debMaker.setHomepage(getProject().getUrl());\n            debMaker.setChangesIn(changesInFile);\n            debMaker.setChangesOut(changesOutFile);\n            debMaker.setChangesSave(changesSaveFile);\n            debMaker.setCompression(compression);\n            debMaker.setKeyring(keyringFile);\n            debMaker.setKey(key);\n            debMaker.setPassphrase(passphrase);\n            debMaker.setSignPackage(signPackage);\n            debMaker.setResolver(resolver);\n            debMaker.validate();\n            debMaker.makeDeb();\n\n            // Always attach unless explicitly set to false\n            if (\"true\".equalsIgnoreCase(attach)) {\n                console.info(\"Attaching created debian package \" + debFile);\n                projectHelper.attachArtifact(project, type, classifier, debFile);\n            }\n\n        } catch (PackagingException e) {\n            getLog().error(\"Failed to create debian package \" + debFile, e);\n            throw new MojoExecutionException(\"Failed to create debian package \" + debFile, e);\n        }\n    }\n\n    /**\n     * Initializes unspecified sign properties using available defaults\n     * and global settings.\n     */\n    private void initializeSignProperties() {\n        if (!signPackage) {\n            return;\n        }\n\n        if (key != null && keyring != null && passphrase != null) {\n            return;\n        }\n\n        Map<String, String> properties =\n                readPropertiesFromActiveProfiles(signCfgPrefix, KEY, KEYRING, PASSPHRASE);\n\n        key = lookupIfEmpty(key, properties, KEY);\n        keyring = lookupIfEmpty(keyring, properties, KEYRING);\n        passphrase = lookupIfEmpty(passphrase, properties, PASSPHRASE);\n\n        if (keyring == null) {\n            try {\n                keyring = Utils.guessKeyRingFile().getAbsolutePath();\n                console.info(\"Located keyring at \" + keyring);\n            } catch (FileNotFoundException e) {\n                console.warn(e.getMessage());\n            }\n        }\n    }\n\n\n    /**\n     * Read properties from the active profiles.\n     *\n     * Goes through all active profiles (in the order the\n     * profiles are defined in settings.xml) and extracts\n     * the desired properties (if present). The prefix is\n     * used when looking up properties in the profile but\n     * not in the returned map.\n     *\n     * @param prefix The prefix to use or null if no prefix should be used\n     * @param properties The properties to read\n     *\n     * @return A map containing the values for the properties that were found\n     */\n    public Map<String, String> readPropertiesFromActiveProfiles( final String prefix,\n                                                                 final String... properties ) {\n        if (settings == null) {\n            console.debug(\"No maven setting injected\");\n            return Collections.emptyMap();\n        }\n\n        final List<String> activeProfilesList = settings.getActiveProfiles();\n        if (activeProfilesList.isEmpty()) {\n            console.debug(\"No active profiles found\");\n            return Collections.emptyMap();\n        }\n\n        final Map<String, String> map = new HashMap<String, String>();\n        final Set<String> activeProfiles = new HashSet<String>(activeProfilesList);\n\n        // Iterate over all active profiles in order\n        for (final Profile profile : settings.getProfiles()) {\n            // Check if the profile is active\n            final String profileId = profile.getId();\n            if (activeProfiles.contains(profileId)) {\n                console.debug(\"Trying active profile \" + profileId);\n                for (final String property : properties) {\n                    final String propKey = prefix != null ? prefix + property : property;\n                    final String value = profile.getProperties().getProperty(propKey);\n                    if (value != null) {\n                        console.debug(\"Found property \" + property + \" in profile \" + profileId);\n                        map.put(property, value);\n                    }\n                }\n            }\n        }\n\n        return map;\n    }\n\n}\n","lineNo":308}
{"Smelly Sample":"/*\n * Copyright 2013 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.DebMaker;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.utils.FilteredFile;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * Creates Debian package\n */\n@Mojo(name = \"jdeb\", defaultPhase = LifecyclePhase.PACKAGE)\npublic class DebMojo extends AbstractPluginMojo {\n\n    @Component\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the name of deb package.\n     */\n    @Parameter\n    private String name;\n\n    /**\n     * Defines the pattern of the name of final artifacts. Possible\n     * substitutions are [[baseDir]] [[buildDir]] [[artifactId]] [[version]]\n     * [[extension]] and [[groupId]].\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.[[extension]]\")\n    private String deb;\n\n    /**\n     * Explicitly defines the path to the control directory. At least the\n     * control file is mandatory.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/src/deb/control\")\n    private String controlDir;\n\n    /**\n     * Explicitly define the file to read the changes from.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesIn;\n\n    /**\n     * Explicitly define the file where to write the changes to.\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.changes\")\n    private String changesOut;\n\n    /**\n     * Explicitly define the file where to write the changes of the changes input to.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip, bzip2 or xz)\n     */\n    @Parameter(defaultValue = \"gzip\")\n    private String compression;\n\n    /**\n     * Boolean option whether to attach the artifact to the project\n     */\n    @Parameter(defaultValue = \"true\")\n    private String attach;\n\n    /**\n     * The location where all package files will be installed. By default, all\n     * packages are installed in /opt (see the FHS here:\n     * http://www.pathname.com/\n     * fhs/pub/fhs-2.3.html#OPTADDONAPPLICATIONSOFTWAREPACKAGES)\n     */\n    @Parameter(defaultValue = \"/opt/[[artifactId]]\")\n    private String installDir;\n\n    /**\n     * The type of attached artifact\n     */\n    @Parameter(defaultValue = \"deb\")\n    private String type;\n\n    /**\n     * The project base directory\n     */\n    @Parameter(defaultValue = \"${basedir}\", required = true, readonly = true)\n    private File baseDir;\n\n    /**\n     * Run the plugin on all sub-modules.\n     * If set to false, the plugin will be run in the same folder where the\n     * mvn command was invoked\n     */\n    @Parameter(defaultValue = \"true\")\n    private boolean submodules;\n\n    /**\n     * The Maven Session Object\n     */\n    @Component\n    private MavenSession session;\n\n    /**\n     * The classifier of attached artifact\n     */\n    @Parameter\n    private String classifier;\n\n    /**\n     * \"data\" entries used to determine which files should be added to this deb.\n     * The \"data\" entries may specify a tarball (tar.gz, tar.bz2, tgz), a\n     * directory, or a normal file. An entry would look something like this in\n     * your pom.xml:\n     *\n     * <pre>\n     *   <build>\n     *     <plugins>\n     *       <plugin>\n     *       <artifactId>jdeb<\/artifactId>\n     *       <groupId>org.vafer<\/groupId>\n     *       ...\n     *       <configuration>\n     *         ...\n     *         <dataSet>\n     *           <data>\n     *             <src>${project.basedir}/target/my_archive.tar.gz<\/src>\n     *             <include>...<\/include>\n     *             <exclude>...<\/exclude>\n     *             <mapper>\n     *               <type>perm<\/type>\n     *               <strip>1<\/strip>\n     *               <prefix>/somewhere/else<\/prefix>\n     *               <user>santbj<\/user>\n     *               <group>santbj<\/group>\n     *               <mode>600<\/mode>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.build.directory}/data<\/src>\n     *             <include><\/include>\n     *             <exclude>**&#47;.svn<\/exclude>\n     *             <mapper>\n     *               <type>ls<\/type>\n     *               <src>mapping.txt<\/src>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <type>link<\/type>\n     *             <linkName>/a/path/on/the/target/fs<\/linkName>\n     *             <linkTarget>/a/sym/link/to/the/scr/file<\/linkTarget>\n     *             <symlink>true<\/symlink>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.basedir}/README.txt<\/src>\n     *           <\/data>\n     *         <\/dataSet>\n     *       <\/configuration>\n     *     <\/plugins>\n     *   <\/build>\n     * <\/pre>\n     */\n    @Parameter\n    private Data[] dataSet;\n\n    /**\n     * When SNAPSHOT version replace <code>SNAPSHOT<\/code> with current date\n     * and time to make sure each build is unique.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean timestamped;\n\n    /**\n     * If verbose is true more build messages are logged.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean verbose;\n\n    /**\n     * Indicates if the execution should be disabled. If <code>true<\/code>, nothing will occur during execution.\n     * \n     * @since 1.1\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean skip;\n\n    /* end of parameters */\n\n    private String openReplaceToken = \"[[\";\n    private String closeReplaceToken = \"]]\";\n    private Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    public void setOpenReplaceToken( String openReplaceToken ) {\n        this.openReplaceToken = openReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setOpenToken(openReplaceToken);\n    }\n\n    public void setCloseReplaceToken( String closeReplaceToken ) {\n        this.closeReplaceToken = closeReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setCloseToken(closeReplaceToken);\n    }\n\n    protected void setData( Data[] dataSet ) {\n        this.dataSet = dataSet;\n        dataProducers.clear();\n        if (dataSet != null) {\n            Collections.addAll(dataProducers, dataSet);\n        }\n    }\n\n    protected VariableResolver initializeVariableResolver( Map<String, String> variables ) {\n        ((Map) variables).putAll(getProject().getProperties());\n        ((Map) variables).putAll(System.getProperties());\n        variables.put(\"name\", name != null ? name : getProject().getName());\n        variables.put(\"artifactId\", getProject().getArtifactId());\n        variables.put(\"groupId\", getProject().getGroupId());\n        variables.put(\"version\", getProjectVersion());\n        variables.put(\"description\", getProject().getDescription());\n        variables.put(\"extension\", \"deb\");\n        variables.put(\"baseDir\", getProject().getBasedir().getAbsolutePath());\n        variables.put(\"buildDir\", buildDirectory.getAbsolutePath());\n        variables.put(\"project.version\", getProject().getVersion());\n        variables.put(\"url\", getProject().getUrl());\n\n        return new MapVariableResolver(variables);\n    }\n\n    /**\n     * Doc some cleanup and conversion on the Maven project version.\n     * <ul>\n     * <li>any \"-\" is replaced by \"+\"<\/li>\n     * <li>\"SNAPSHOT\" is replaced with the current time and date, prepended by \"~\"<\/li>\n     * <\/ul>\n     *\n     * @return the Maven project version\n     */\n    private String getProjectVersion() {\n        return Utils.convertToDebianVersion(getProject().getVersion(), this.timestamped ? session.getStartTime() : null);\n    }\n\n    /**\n     * @return whether or not Maven is currently operating in the execution root\n     */\n    private boolean isSubmodule() {\n        // FIXME there must be a better way\n        return !session.getExecutionRootDirectory().equalsIgnoreCase(baseDir.toString());\n    }\n\n    /**\n     * @return whether or not the main artifact was created\n     */\n    private boolean hasMainArtifact() {\n        final MavenProject project = getProject();\n        final Artifact artifact = project.getArtifact();\n        return artifact.getFile() != null && artifact.getFile().isFile();\n    }\n\n    /**\n     * Main entry point\n     *\n     * @throws MojoExecutionException on error\n     */\n    @Override\n    public void execute() throws MojoExecutionException {\n\n        final MavenProject project = getProject();\n\n        if (skip){\n            getLog().info(\"skipping execution\");\n            return;\n        }\n\n        if (isSubmodule() && !submodules) {\n            getLog().info(\"skipping sub module: jdeb executing at top-level only\");\n            return;\n        }\n\n        setData(dataSet);\n\n        Console console = new MojoConsole(getLog(), verbose);\n\n        final VariableResolver resolver = initializeVariableResolver(new HashMap<String, String>());\n\n        final File debFile = new File(Utils.replaceVariables(resolver, deb, openReplaceToken, closeReplaceToken));\n        final File controlDirFile = new File(Utils.replaceVariables(resolver, controlDir, openReplaceToken, closeReplaceToken));\n        final File installDirFile = new File(Utils.replaceVariables(resolver, installDir, openReplaceToken, closeReplaceToken));\n        final File changesInFile = new File(Utils.replaceVariables(resolver, changesIn, openReplaceToken, closeReplaceToken));\n        final File changesOutFile = new File(Utils.replaceVariables(resolver, changesOut, openReplaceToken, closeReplaceToken));\n        final File changesSaveFile = new File(Utils.replaceVariables(resolver, changesSave, openReplaceToken, closeReplaceToken));\n\n        // if there are no producers defined we try to use the artifacts\n        if (dataProducers.isEmpty()) {\n\n            if (!hasMainArtifact()) {\n\n                final String packaging = project.getPackaging();\n                if (\"pom\".equalsIgnoreCase(packaging)) {\n                    getLog().warn(\"Creating empty debian package.\");\n                } else {\n                    throw new MojoExecutionException(\n                        \"Nothing to include into the debian package. \" +\n                            \"Did you maybe forget to add a <data> tag or call the plugin directly?\");\n                }\n\n            } else {\n\n                Set<Artifact> artifacts = new HashSet<Artifact>();\n\n                artifacts.add(project.getArtifact());\n\n                for (Artifact artifact : (Set<Artifact>) project.getArtifacts()) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : (List<Artifact>) project.getAttachedArtifacts()) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : artifacts) {\n                    final File file = artifact.getFile();\n                    if (file != null) {\n                        dataProducers.add(new DataProducer() {\n                            @Override\n                            public void produce( final DataConsumer receiver ) {\n                                try {\n                                    receiver.onEachFile(\n                                        new FileInputStream(file),\n                                        new File(installDirFile, file.getName()).getAbsolutePath(),\n                                        \"\",\n                                        \"root\", 0, \"root\", 0,\n                                        TarEntry.DEFAULT_FILE_MODE,\n                                        file.length());\n                                } catch (Exception e) {\n                                    getLog().error(e);\n                                }\n                            }\n                        });\n                    } else {\n                        getLog().error(\"No file for artifact \" + artifact);\n                    }\n                }\n            }\n        }\n\n        try {\n            DebMaker debMaker = new DebMaker(console, dataProducers);\n            debMaker.setDeb(debFile);\n            debMaker.setControl(controlDirFile);\n            debMaker.setPackage(getProject().getArtifactId());\n            debMaker.setDescription(getProject().getDescription());\n            debMaker.setHomepage(getProject().getUrl());\n            debMaker.setChangesIn(changesInFile);\n            debMaker.setChangesOut(changesOutFile);\n            debMaker.setChangesSave(changesSaveFile);\n            debMaker.setCompression(compression);\n            debMaker.setResolver(resolver);\n            debMaker.validate();\n            debMaker.makeDeb();\n\n            // Always attach unless explicitly set to false\n            if (\"true\".equalsIgnoreCase(attach)) {\n                console.info(\"Attaching created debian package \" + debFile);\n                projectHelper.attachArtifact(project, type, classifier, debFile);\n            }\n\n        } catch (PackagingException e) {\n            getLog().error(\"Failed to create debian package \" + debFile, e);\n            throw new MojoExecutionException(\"Failed to create debian package \" + debFile, e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2013 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.maven.settings.Profile;\nimport org.apache.maven.settings.Settings;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.DebMaker;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.utils.FilteredFile;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\nimport static org.vafer.jdeb.utils.Utils.lookupIfEmpty;\n\n/**\n * Creates Debian package\n */\n@SuppressWarnings(\"unused\")\n@Mojo(name = \"jdeb\", defaultPhase = LifecyclePhase.PACKAGE)\npublic class DebMojo extends AbstractPluginMojo {\n\n    @Component\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the name of deb package.\n     */\n    @Parameter\n    private String name;\n\n    /**\n     * Defines the pattern of the name of final artifacts. Possible\n     * substitutions are [[baseDir]] [[buildDir]] [[artifactId]] [[version]]\n     * [[extension]] and [[groupId]].\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.[[extension]]\")\n    private String deb;\n\n    /**\n     * Explicitly defines the path to the control directory. At least the\n     * control file is mandatory.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/src/deb/control\")\n    private String controlDir;\n\n    /**\n     * Explicitly define the file to read the changes from.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesIn;\n\n    /**\n     * Explicitly define the file where to write the changes to.\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.changes\")\n    private String changesOut;\n\n    /**\n     * Explicitly define the file where to write the changes of the changes input to.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip, bzip2 or xz)\n     */\n    @Parameter(defaultValue = \"gzip\")\n    private String compression;\n\n    /**\n     * Boolean option whether to attach the artifact to the project\n     */\n    @Parameter(defaultValue = \"true\")\n    private String attach;\n\n    /**\n     * The location where all package files will be installed. By default, all\n     * packages are installed in /opt (see the FHS here:\n     * http://www.pathname.com/\n     * fhs/pub/fhs-2.3.html#OPTADDONAPPLICATIONSOFTWAREPACKAGES)\n     */\n    @Parameter(defaultValue = \"/opt/[[artifactId]]\")\n    private String installDir;\n\n    /**\n     * The type of attached artifact\n     */\n    @Parameter(defaultValue = \"deb\")\n    private String type;\n\n    /**\n     * The project base directory\n     */\n    @Parameter(defaultValue = \"${basedir}\", required = true, readonly = true)\n    private File baseDir;\n\n    /**\n     * Run the plugin on all sub-modules.\n     * If set to false, the plugin will be run in the same folder where the\n     * mvn command was invoked\n     */\n    @Parameter(defaultValue = \"true\")\n    private boolean submodules;\n\n    /**\n     * The Maven Session Object\n     */\n    @Component\n    private MavenSession session;\n\n    /**\n     * The classifier of attached artifact\n     */\n    @Parameter\n    private String classifier;\n\n    /**\n     * \"data\" entries used to determine which files should be added to this deb.\n     * The \"data\" entries may specify a tarball (tar.gz, tar.bz2, tgz), a\n     * directory, or a normal file. An entry would look something like this in\n     * your pom.xml:\n     *\n     * <pre>\n     *   <build>\n     *     <plugins>\n     *       <plugin>\n     *       <artifactId>jdeb<\/artifactId>\n     *       <groupId>org.vafer<\/groupId>\n     *       ...\n     *       <configuration>\n     *         ...\n     *         <dataSet>\n     *           <data>\n     *             <src>${project.basedir}/target/my_archive.tar.gz<\/src>\n     *             <include>...<\/include>\n     *             <exclude>...<\/exclude>\n     *             <mapper>\n     *               <type>perm<\/type>\n     *               <strip>1<\/strip>\n     *               <prefix>/somewhere/else<\/prefix>\n     *               <user>santbj<\/user>\n     *               <group>santbj<\/group>\n     *               <mode>600<\/mode>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.build.directory}/data<\/src>\n     *             <include><\/include>\n     *             <exclude>**&#47;.svn<\/exclude>\n     *             <mapper>\n     *               <type>ls<\/type>\n     *               <src>mapping.txt<\/src>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <type>link<\/type>\n     *             <linkName>/a/path/on/the/target/fs<\/linkName>\n     *             <linkTarget>/a/sym/link/to/the/scr/file<\/linkTarget>\n     *             <symlink>true<\/symlink>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.basedir}/README.txt<\/src>\n     *           <\/data>\n     *         <\/dataSet>\n     *       <\/configuration>\n     *     <\/plugins>\n     *   <\/build>\n     * <\/pre>\n     */\n    @Parameter\n    private Data[] dataSet;\n\n    /**\n     * When SNAPSHOT version replace <code>SNAPSHOT<\/code> with current date\n     * and time to make sure each build is unique.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean timestamped;\n\n    /**\n     * If verbose is true more build messages are logged.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean verbose;\n\n    /**\n     * Indicates if the execution should be disabled. If <code>true<\/code>, nothing will occur during execution.\n     * \n     * @since 1.1\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean skip;\n\n    /**\n     * If signPackage is true then a origin signature will be placed\n     * in the generated package.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean signPackage;\n\n    /**\n     * The keyring to use for signing operations.\n     */\n    @Parameter\n    private String keyring;\n\n    /**\n     * The key to use for signing operations.\n     */\n    @Parameter\n    private String key;\n\n    /**\n     * The passphrase to use for signing operations.\n     */\n    @Parameter\n    private String passphrase; \n\n    /**\n     * The prefix to use when reading signing variables\n     * from settings.\n     */\n    @Parameter(defaultValue = \"jdeb.\")\n    private String signCfgPrefix;\n\n    /**\n     * The settings.\n     */\n    @Parameter(defaultValue = \"${settings}\")\n    private Settings settings;\n\n    /* end of parameters */\n\n\n    private static final String KEY = \"key\";\n    private static final String KEYRING = \"keyring\";\n    private static final String PASSPHRASE = \"passphrase\";\n\n    private String openReplaceToken = \"[[\";\n    private String closeReplaceToken = \"]]\";\n    private Console console;\n    private Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    public void setOpenReplaceToken( String openReplaceToken ) {\n        this.openReplaceToken = openReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setOpenToken(openReplaceToken);\n    }\n\n    public void setCloseReplaceToken( String closeReplaceToken ) {\n        this.closeReplaceToken = closeReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setCloseToken(closeReplaceToken);\n    }\n\n    protected void setData( Data[] dataSet ) {\n        this.dataSet = dataSet;\n        dataProducers.clear();\n        if (dataSet != null) {\n            Collections.addAll(dataProducers, dataSet);\n        }\n    }\n\n    protected VariableResolver initializeVariableResolver( Map<String, String> variables ) {\n        @SuppressWarnings(\"unchecked\")\n        final Map<String, String> projectProperties = Map.class.cast(getProject().getProperties());\n        @SuppressWarnings(\"unchecked\")\n        final Map<String, String> systemProperties = Map.class.cast(System.getProperties());\n\n        variables.putAll(projectProperties);\n        variables.putAll(systemProperties);\n        variables.put(\"name\", name != null ? name : getProject().getName());\n        variables.put(\"artifactId\", getProject().getArtifactId());\n        variables.put(\"groupId\", getProject().getGroupId());\n        variables.put(\"version\", getProjectVersion());\n        variables.put(\"description\", getProject().getDescription());\n        variables.put(\"extension\", \"deb\");\n        variables.put(\"baseDir\", getProject().getBasedir().getAbsolutePath());\n        variables.put(\"buildDir\", buildDirectory.getAbsolutePath());\n        variables.put(\"project.version\", getProject().getVersion());\n        variables.put(\"url\", getProject().getUrl());\n\n        return new MapVariableResolver(variables);\n    }\n\n    /**\n     * Doc some cleanup and conversion on the Maven project version.\n     * <ul>\n     * <li>any \"-\" is replaced by \"+\"<\/li>\n     * <li>\"SNAPSHOT\" is replaced with the current time and date, prepended by \"~\"<\/li>\n     * <\/ul>\n     *\n     * @return the Maven project version\n     */\n    private String getProjectVersion() {\n        return Utils.convertToDebianVersion(getProject().getVersion(), this.timestamped ? session.getStartTime() : null);\n    }\n\n    /**\n     * @return whether or not Maven is currently operating in the execution root\n     */\n    private boolean isSubmodule() {\n        // FIXME there must be a better way\n        return !session.getExecutionRootDirectory().equalsIgnoreCase(baseDir.toString());\n    }\n\n    /**\n     * @return whether or not the main artifact was created\n     */\n    private boolean hasMainArtifact() {\n        final MavenProject project = getProject();\n        final Artifact artifact = project.getArtifact();\n        return artifact.getFile() != null && artifact.getFile().isFile();\n    }\n\n    /**\n     * Main entry point\n     *\n     * @throws MojoExecutionException on error\n     */\n    @Override\n    public void execute() throws MojoExecutionException {\n\n        final MavenProject project = getProject();\n\n        if (skip) {\n            getLog().info(\"skipping execution\");\n            return;\n        }\n\n        if (isSubmodule() && !submodules) {\n            getLog().info(\"skipping sub module: jdeb executing at top-level only\");\n            return;\n        }\n\n        setData(dataSet);\n\n        console = new MojoConsole(getLog(), verbose);\n\n        initializeSignProperties();\n\n        final VariableResolver resolver = initializeVariableResolver(new HashMap<String, String>());\n\n        final File debFile = new File(Utils.replaceVariables(resolver, deb, openReplaceToken, closeReplaceToken));\n        final File controlDirFile = new File(Utils.replaceVariables(resolver, controlDir, openReplaceToken, closeReplaceToken));\n        final File installDirFile = new File(Utils.replaceVariables(resolver, installDir, openReplaceToken, closeReplaceToken));\n        final File changesInFile = new File(Utils.replaceVariables(resolver, changesIn, openReplaceToken, closeReplaceToken));\n        final File changesOutFile = new File(Utils.replaceVariables(resolver, changesOut, openReplaceToken, closeReplaceToken));\n        final File changesSaveFile = new File(Utils.replaceVariables(resolver, changesSave, openReplaceToken, closeReplaceToken));\n        final File keyringFile = keyring == null ? null : new File(Utils.replaceVariables(resolver, keyring, openReplaceToken, closeReplaceToken));\n\n        // if there are no producers defined we try to use the artifacts\n        if (dataProducers.isEmpty()) {\n\n            if (!hasMainArtifact()) {\n\n                final String packaging = project.getPackaging();\n                if (\"pom\".equalsIgnoreCase(packaging)) {\n                    getLog().warn(\"Creating empty debian package.\");\n                } else {\n                    throw new MojoExecutionException(\n                        \"Nothing to include into the debian package. \" +\n                            \"Did you maybe forget to add a <data> tag or call the plugin directly?\");\n                }\n\n            } else {\n\n                Set<Artifact> artifacts = new HashSet<Artifact>();\n\n                artifacts.add(project.getArtifact());\n\n                @SuppressWarnings(\"unchecked\")\n                final Set<Artifact> projectArtifacts = project.getArtifacts();\n\n                for (Artifact artifact : projectArtifacts) {\n                    artifacts.add(artifact);\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                final List<Artifact> attachedArtifacts = project.getAttachedArtifacts();\n\n                for (Artifact artifact : attachedArtifacts) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : artifacts) {\n                    final File file = artifact.getFile();\n                    if (file != null) {\n                        dataProducers.add(new DataProducer() {\n                            @Override\n                            public void produce( final DataConsumer receiver ) {\n                                try {\n                                    receiver.onEachFile(\n                                        new FileInputStream(file),\n                                        new File(installDirFile, file.getName()).getAbsolutePath(),\n                                        \"\",\n                                        \"root\", 0, \"root\", 0,\n                                        TarEntry.DEFAULT_FILE_MODE,\n                                        file.length());\n                                } catch (Exception e) {\n                                    getLog().error(e);\n                                }\n                            }\n                        });\n                    } else {\n                        getLog().error(\"No file for artifact \" + artifact);\n                    }\n                }\n            }\n        }\n\n        try {\n            DebMaker debMaker = new DebMaker(console, dataProducers);\n            debMaker.setDeb(debFile);\n            debMaker.setControl(controlDirFile);\n            debMaker.setPackage(getProject().getArtifactId());\n            debMaker.setDescription(getProject().getDescription());\n            debMaker.setHomepage(getProject().getUrl());\n            debMaker.setChangesIn(changesInFile);\n            debMaker.setChangesOut(changesOutFile);\n            debMaker.setChangesSave(changesSaveFile);\n            debMaker.setCompression(compression);\n            debMaker.setKeyring(keyringFile);\n            debMaker.setKey(key);\n            debMaker.setPassphrase(passphrase);\n            debMaker.setSignPackage(signPackage);\n            debMaker.setResolver(resolver);\n            debMaker.validate();\n            debMaker.makeDeb();\n\n            // Always attach unless explicitly set to false\n            if (\"true\".equalsIgnoreCase(attach)) {\n                console.info(\"Attaching created debian package \" + debFile);\n                projectHelper.attachArtifact(project, type, classifier, debFile);\n            }\n\n        } catch (PackagingException e) {\n            getLog().error(\"Failed to create debian package \" + debFile, e);\n            throw new MojoExecutionException(\"Failed to create debian package \" + debFile, e);\n        }\n    }\n\n    /**\n     * Initializes unspecified sign properties using available defaults\n     * and global settings.\n     */\n    private void initializeSignProperties() {\n        if (!signPackage) {\n            return;\n        }\n\n        if (key != null && keyring != null && passphrase != null) {\n            return;\n        }\n\n        Map<String, String> properties =\n                readPropertiesFromActiveProfiles(signCfgPrefix, KEY, KEYRING, PASSPHRASE);\n\n        key = lookupIfEmpty(key, properties, KEY);\n        keyring = lookupIfEmpty(keyring, properties, KEYRING);\n        passphrase = lookupIfEmpty(passphrase, properties, PASSPHRASE);\n\n        if (keyring == null) {\n            try {\n                keyring = Utils.guessKeyRingFile().getAbsolutePath();\n                console.info(\"Located keyring at \" + keyring);\n            } catch (FileNotFoundException e) {\n                console.warn(e.getMessage());\n            }\n        }\n    }\n\n\n    /**\n     * Read properties from the active profiles.\n     *\n     * Goes through all active profiles (in the order the\n     * profiles are defined in settings.xml) and extracts\n     * the desired properties (if present). The prefix is\n     * used when looking up properties in the profile but\n     * not in the returned map.\n     *\n     * @param prefix The prefix to use or null if no prefix should be used\n     * @param properties The properties to read\n     *\n     * @return A map containing the values for the properties that were found\n     */\n    public Map<String, String> readPropertiesFromActiveProfiles( final String prefix,\n                                                                 final String... properties ) {\n        if (settings == null) {\n            console.debug(\"No maven setting injected\");\n            return Collections.emptyMap();\n        }\n\n        final List<String> activeProfilesList = settings.getActiveProfiles();\n        if (activeProfilesList.isEmpty()) {\n            console.debug(\"No active profiles found\");\n            return Collections.emptyMap();\n        }\n\n        final Map<String, String> map = new HashMap<String, String>();\n        final Set<String> activeProfiles = new HashSet<String>(activeProfilesList);\n\n        // Iterate over all active profiles in order\n        for (final Profile profile : settings.getProfiles()) {\n            // Check if the profile is active\n            final String profileId = profile.getId();\n            if (activeProfiles.contains(profileId)) {\n                console.debug(\"Trying active profile \" + profileId);\n                for (final String property : properties) {\n                    final String propKey = prefix != null ? prefix + property : property;\n                    final String value = profile.getProperties().getProperty(propKey);\n                    if (value != null) {\n                        console.debug(\"Found property \" + property + \" in profile \" + profileId);\n                        map.put(property, value);\n                    }\n                }\n            }\n        }\n\n        return map;\n    }\n\n}\n","lineNo":413}
{"Smelly Sample":"/*\n * Copyright 2013 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.DebMaker;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.utils.FilteredFile;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * Creates Debian package\n */\n@Mojo(name = \"jdeb\", defaultPhase = LifecyclePhase.PACKAGE)\npublic class DebMojo extends AbstractPluginMojo {\n\n    @Component\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the name of deb package.\n     */\n    @Parameter\n    private String name;\n\n    /**\n     * Defines the pattern of the name of final artifacts. Possible\n     * substitutions are [[baseDir]] [[buildDir]] [[artifactId]] [[version]]\n     * [[extension]] and [[groupId]].\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.[[extension]]\")\n    private String deb;\n\n    /**\n     * Explicitly defines the path to the control directory. At least the\n     * control file is mandatory.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/src/deb/control\")\n    private String controlDir;\n\n    /**\n     * Explicitly define the file to read the changes from.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesIn;\n\n    /**\n     * Explicitly define the file where to write the changes to.\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.changes\")\n    private String changesOut;\n\n    /**\n     * Explicitly define the file where to write the changes of the changes input to.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip, bzip2 or xz)\n     */\n    @Parameter(defaultValue = \"gzip\")\n    private String compression;\n\n    /**\n     * Boolean option whether to attach the artifact to the project\n     */\n    @Parameter(defaultValue = \"true\")\n    private String attach;\n\n    /**\n     * The location where all package files will be installed. By default, all\n     * packages are installed in /opt (see the FHS here:\n     * http://www.pathname.com/\n     * fhs/pub/fhs-2.3.html#OPTADDONAPPLICATIONSOFTWAREPACKAGES)\n     */\n    @Parameter(defaultValue = \"/opt/[[artifactId]]\")\n    private String installDir;\n\n    /**\n     * The type of attached artifact\n     */\n    @Parameter(defaultValue = \"deb\")\n    private String type;\n\n    /**\n     * The project base directory\n     */\n    @Parameter(defaultValue = \"${basedir}\", required = true, readonly = true)\n    private File baseDir;\n\n    /**\n     * Run the plugin on all sub-modules.\n     * If set to false, the plugin will be run in the same folder where the\n     * mvn command was invoked\n     */\n    @Parameter(defaultValue = \"true\")\n    private boolean submodules;\n\n    /**\n     * The Maven Session Object\n     */\n    @Component\n    private MavenSession session;\n\n    /**\n     * The classifier of attached artifact\n     */\n    @Parameter\n    private String classifier;\n\n    /**\n     * \"data\" entries used to determine which files should be added to this deb.\n     * The \"data\" entries may specify a tarball (tar.gz, tar.bz2, tgz), a\n     * directory, or a normal file. An entry would look something like this in\n     * your pom.xml:\n     *\n     * <pre>\n     *   <build>\n     *     <plugins>\n     *       <plugin>\n     *       <artifactId>jdeb<\/artifactId>\n     *       <groupId>org.vafer<\/groupId>\n     *       ...\n     *       <configuration>\n     *         ...\n     *         <dataSet>\n     *           <data>\n     *             <src>${project.basedir}/target/my_archive.tar.gz<\/src>\n     *             <include>...<\/include>\n     *             <exclude>...<\/exclude>\n     *             <mapper>\n     *               <type>perm<\/type>\n     *               <strip>1<\/strip>\n     *               <prefix>/somewhere/else<\/prefix>\n     *               <user>santbj<\/user>\n     *               <group>santbj<\/group>\n     *               <mode>600<\/mode>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.build.directory}/data<\/src>\n     *             <include><\/include>\n     *             <exclude>**&#47;.svn<\/exclude>\n     *             <mapper>\n     *               <type>ls<\/type>\n     *               <src>mapping.txt<\/src>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <type>link<\/type>\n     *             <linkName>/a/path/on/the/target/fs<\/linkName>\n     *             <linkTarget>/a/sym/link/to/the/scr/file<\/linkTarget>\n     *             <symlink>true<\/symlink>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.basedir}/README.txt<\/src>\n     *           <\/data>\n     *         <\/dataSet>\n     *       <\/configuration>\n     *     <\/plugins>\n     *   <\/build>\n     * <\/pre>\n     */\n    @Parameter\n    private Data[] dataSet;\n\n    /**\n     * When SNAPSHOT version replace <code>SNAPSHOT<\/code> with current date\n     * and time to make sure each build is unique.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean timestamped;\n\n    /**\n     * If verbose is true more build messages are logged.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean verbose;\n\n    /**\n     * Indicates if the execution should be disabled. If <code>true<\/code>, nothing will occur during execution.\n     * \n     * @since 1.1\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean skip;\n\n    /* end of parameters */\n\n    private String openReplaceToken = \"[[\";\n    private String closeReplaceToken = \"]]\";\n    private Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    public void setOpenReplaceToken( String openReplaceToken ) {\n        this.openReplaceToken = openReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setOpenToken(openReplaceToken);\n    }\n\n    public void setCloseReplaceToken( String closeReplaceToken ) {\n        this.closeReplaceToken = closeReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setCloseToken(closeReplaceToken);\n    }\n\n    protected void setData( Data[] dataSet ) {\n        this.dataSet = dataSet;\n        dataProducers.clear();\n        if (dataSet != null) {\n            Collections.addAll(dataProducers, dataSet);\n        }\n    }\n\n    protected VariableResolver initializeVariableResolver( Map<String, String> variables ) {\n        ((Map) variables).putAll(getProject().getProperties());\n        ((Map) variables).putAll(System.getProperties());\n        variables.put(\"name\", name != null ? name : getProject().getName());\n        variables.put(\"artifactId\", getProject().getArtifactId());\n        variables.put(\"groupId\", getProject().getGroupId());\n        variables.put(\"version\", getProjectVersion());\n        variables.put(\"description\", getProject().getDescription());\n        variables.put(\"extension\", \"deb\");\n        variables.put(\"baseDir\", getProject().getBasedir().getAbsolutePath());\n        variables.put(\"buildDir\", buildDirectory.getAbsolutePath());\n        variables.put(\"project.version\", getProject().getVersion());\n        variables.put(\"url\", getProject().getUrl());\n\n        return new MapVariableResolver(variables);\n    }\n\n    /**\n     * Doc some cleanup and conversion on the Maven project version.\n     * <ul>\n     * <li>any \"-\" is replaced by \"+\"<\/li>\n     * <li>\"SNAPSHOT\" is replaced with the current time and date, prepended by \"~\"<\/li>\n     * <\/ul>\n     *\n     * @return the Maven project version\n     */\n    private String getProjectVersion() {\n        return Utils.convertToDebianVersion(getProject().getVersion(), this.timestamped ? session.getStartTime() : null);\n    }\n\n    /**\n     * @return whether or not Maven is currently operating in the execution root\n     */\n    private boolean isSubmodule() {\n        // FIXME there must be a better way\n        return !session.getExecutionRootDirectory().equalsIgnoreCase(baseDir.toString());\n    }\n\n    /**\n     * @return whether or not the main artifact was created\n     */\n    private boolean hasMainArtifact() {\n        final MavenProject project = getProject();\n        final Artifact artifact = project.getArtifact();\n        return artifact.getFile() != null && artifact.getFile().isFile();\n    }\n\n    /**\n     * Main entry point\n     *\n     * @throws MojoExecutionException on error\n     */\n    @Override\n    public void execute() throws MojoExecutionException {\n\n        final MavenProject project = getProject();\n\n        if (skip){\n            getLog().info(\"skipping execution\");\n            return;\n        }\n\n        if (isSubmodule() && !submodules) {\n            getLog().info(\"skipping sub module: jdeb executing at top-level only\");\n            return;\n        }\n\n        setData(dataSet);\n\n        Console console = new MojoConsole(getLog(), verbose);\n\n        final VariableResolver resolver = initializeVariableResolver(new HashMap<String, String>());\n\n        final File debFile = new File(Utils.replaceVariables(resolver, deb, openReplaceToken, closeReplaceToken));\n        final File controlDirFile = new File(Utils.replaceVariables(resolver, controlDir, openReplaceToken, closeReplaceToken));\n        final File installDirFile = new File(Utils.replaceVariables(resolver, installDir, openReplaceToken, closeReplaceToken));\n        final File changesInFile = new File(Utils.replaceVariables(resolver, changesIn, openReplaceToken, closeReplaceToken));\n        final File changesOutFile = new File(Utils.replaceVariables(resolver, changesOut, openReplaceToken, closeReplaceToken));\n        final File changesSaveFile = new File(Utils.replaceVariables(resolver, changesSave, openReplaceToken, closeReplaceToken));\n\n        // if there are no producers defined we try to use the artifacts\n        if (dataProducers.isEmpty()) {\n\n            if (!hasMainArtifact()) {\n\n                final String packaging = project.getPackaging();\n                if (\"pom\".equalsIgnoreCase(packaging)) {\n                    getLog().warn(\"Creating empty debian package.\");\n                } else {\n                    throw new MojoExecutionException(\n                        \"Nothing to include into the debian package. \" +\n                            \"Did you maybe forget to add a <data> tag or call the plugin directly?\");\n                }\n\n            } else {\n\n                Set<Artifact> artifacts = new HashSet<Artifact>();\n\n                artifacts.add(project.getArtifact());\n\n                for (Artifact artifact : (Set<Artifact>) project.getArtifacts()) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : (List<Artifact>) project.getAttachedArtifacts()) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : artifacts) {\n                    final File file = artifact.getFile();\n                    if (file != null) {\n                        dataProducers.add(new DataProducer() {\n                            @Override\n                            public void produce( final DataConsumer receiver ) {\n                                try {\n                                    receiver.onEachFile(\n                                        new FileInputStream(file),\n                                        new File(installDirFile, file.getName()).getAbsolutePath(),\n                                        \"\",\n                                        \"root\", 0, \"root\", 0,\n                                        TarEntry.DEFAULT_FILE_MODE,\n                                        file.length());\n                                } catch (Exception e) {\n                                    getLog().error(e);\n                                }\n                            }\n                        });\n                    } else {\n                        getLog().error(\"No file for artifact \" + artifact);\n                    }\n                }\n            }\n        }\n\n        try {\n            DebMaker debMaker = new DebMaker(console, dataProducers);\n            debMaker.setDeb(debFile);\n            debMaker.setControl(controlDirFile);\n            debMaker.setPackage(getProject().getArtifactId());\n            debMaker.setDescription(getProject().getDescription());\n            debMaker.setHomepage(getProject().getUrl());\n            debMaker.setChangesIn(changesInFile);\n            debMaker.setChangesOut(changesOutFile);\n            debMaker.setChangesSave(changesSaveFile);\n            debMaker.setCompression(compression);\n            debMaker.setResolver(resolver);\n            debMaker.validate();\n            debMaker.makeDeb();\n\n            // Always attach unless explicitly set to false\n            if (\"true\".equalsIgnoreCase(attach)) {\n                console.info(\"Attaching created debian package \" + debFile);\n                projectHelper.attachArtifact(project, type, classifier, debFile);\n            }\n\n        } catch (PackagingException e) {\n            getLog().error(\"Failed to create debian package \" + debFile, e);\n            throw new MojoExecutionException(\"Failed to create debian package \" + debFile, e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2013 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.maven.settings.Profile;\nimport org.apache.maven.settings.Settings;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.DebMaker;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.utils.FilteredFile;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\nimport static org.vafer.jdeb.utils.Utils.lookupIfEmpty;\n\n/**\n * Creates Debian package\n */\n@SuppressWarnings(\"unused\")\n@Mojo(name = \"jdeb\", defaultPhase = LifecyclePhase.PACKAGE)\npublic class DebMojo extends AbstractPluginMojo {\n\n    @Component\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the name of deb package.\n     */\n    @Parameter\n    private String name;\n\n    /**\n     * Defines the pattern of the name of final artifacts. Possible\n     * substitutions are [[baseDir]] [[buildDir]] [[artifactId]] [[version]]\n     * [[extension]] and [[groupId]].\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.[[extension]]\")\n    private String deb;\n\n    /**\n     * Explicitly defines the path to the control directory. At least the\n     * control file is mandatory.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/src/deb/control\")\n    private String controlDir;\n\n    /**\n     * Explicitly define the file to read the changes from.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesIn;\n\n    /**\n     * Explicitly define the file where to write the changes to.\n     */\n    @Parameter(defaultValue = \"[[buildDir]]/[[artifactId]]_[[version]]_all.changes\")\n    private String changesOut;\n\n    /**\n     * Explicitly define the file where to write the changes of the changes input to.\n     */\n    @Parameter(defaultValue = \"[[baseDir]]/CHANGES.txt\")\n    private String changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip, bzip2 or xz)\n     */\n    @Parameter(defaultValue = \"gzip\")\n    private String compression;\n\n    /**\n     * Boolean option whether to attach the artifact to the project\n     */\n    @Parameter(defaultValue = \"true\")\n    private String attach;\n\n    /**\n     * The location where all package files will be installed. By default, all\n     * packages are installed in /opt (see the FHS here:\n     * http://www.pathname.com/\n     * fhs/pub/fhs-2.3.html#OPTADDONAPPLICATIONSOFTWAREPACKAGES)\n     */\n    @Parameter(defaultValue = \"/opt/[[artifactId]]\")\n    private String installDir;\n\n    /**\n     * The type of attached artifact\n     */\n    @Parameter(defaultValue = \"deb\")\n    private String type;\n\n    /**\n     * The project base directory\n     */\n    @Parameter(defaultValue = \"${basedir}\", required = true, readonly = true)\n    private File baseDir;\n\n    /**\n     * Run the plugin on all sub-modules.\n     * If set to false, the plugin will be run in the same folder where the\n     * mvn command was invoked\n     */\n    @Parameter(defaultValue = \"true\")\n    private boolean submodules;\n\n    /**\n     * The Maven Session Object\n     */\n    @Component\n    private MavenSession session;\n\n    /**\n     * The classifier of attached artifact\n     */\n    @Parameter\n    private String classifier;\n\n    /**\n     * \"data\" entries used to determine which files should be added to this deb.\n     * The \"data\" entries may specify a tarball (tar.gz, tar.bz2, tgz), a\n     * directory, or a normal file. An entry would look something like this in\n     * your pom.xml:\n     *\n     * <pre>\n     *   <build>\n     *     <plugins>\n     *       <plugin>\n     *       <artifactId>jdeb<\/artifactId>\n     *       <groupId>org.vafer<\/groupId>\n     *       ...\n     *       <configuration>\n     *         ...\n     *         <dataSet>\n     *           <data>\n     *             <src>${project.basedir}/target/my_archive.tar.gz<\/src>\n     *             <include>...<\/include>\n     *             <exclude>...<\/exclude>\n     *             <mapper>\n     *               <type>perm<\/type>\n     *               <strip>1<\/strip>\n     *               <prefix>/somewhere/else<\/prefix>\n     *               <user>santbj<\/user>\n     *               <group>santbj<\/group>\n     *               <mode>600<\/mode>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.build.directory}/data<\/src>\n     *             <include><\/include>\n     *             <exclude>**&#47;.svn<\/exclude>\n     *             <mapper>\n     *               <type>ls<\/type>\n     *               <src>mapping.txt<\/src>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <type>link<\/type>\n     *             <linkName>/a/path/on/the/target/fs<\/linkName>\n     *             <linkTarget>/a/sym/link/to/the/scr/file<\/linkTarget>\n     *             <symlink>true<\/symlink>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.basedir}/README.txt<\/src>\n     *           <\/data>\n     *         <\/dataSet>\n     *       <\/configuration>\n     *     <\/plugins>\n     *   <\/build>\n     * <\/pre>\n     */\n    @Parameter\n    private Data[] dataSet;\n\n    /**\n     * When SNAPSHOT version replace <code>SNAPSHOT<\/code> with current date\n     * and time to make sure each build is unique.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean timestamped;\n\n    /**\n     * If verbose is true more build messages are logged.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean verbose;\n\n    /**\n     * Indicates if the execution should be disabled. If <code>true<\/code>, nothing will occur during execution.\n     * \n     * @since 1.1\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean skip;\n\n    /**\n     * If signPackage is true then a origin signature will be placed\n     * in the generated package.\n     */\n    @Parameter(defaultValue = \"false\")\n    private boolean signPackage;\n\n    /**\n     * The keyring to use for signing operations.\n     */\n    @Parameter\n    private String keyring;\n\n    /**\n     * The key to use for signing operations.\n     */\n    @Parameter\n    private String key;\n\n    /**\n     * The passphrase to use for signing operations.\n     */\n    @Parameter\n    private String passphrase; \n\n    /**\n     * The prefix to use when reading signing variables\n     * from settings.\n     */\n    @Parameter(defaultValue = \"jdeb.\")\n    private String signCfgPrefix;\n\n    /**\n     * The settings.\n     */\n    @Parameter(defaultValue = \"${settings}\")\n    private Settings settings;\n\n    /* end of parameters */\n\n\n    private static final String KEY = \"key\";\n    private static final String KEYRING = \"keyring\";\n    private static final String PASSPHRASE = \"passphrase\";\n\n    private String openReplaceToken = \"[[\";\n    private String closeReplaceToken = \"]]\";\n    private Console console;\n    private Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n    public void setOpenReplaceToken( String openReplaceToken ) {\n        this.openReplaceToken = openReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setOpenToken(openReplaceToken);\n    }\n\n    public void setCloseReplaceToken( String closeReplaceToken ) {\n        this.closeReplaceToken = closeReplaceToken;\n        // FIXME yuck!\n        FilteredFile.setCloseToken(closeReplaceToken);\n    }\n\n    protected void setData( Data[] dataSet ) {\n        this.dataSet = dataSet;\n        dataProducers.clear();\n        if (dataSet != null) {\n            Collections.addAll(dataProducers, dataSet);\n        }\n    }\n\n    protected VariableResolver initializeVariableResolver( Map<String, String> variables ) {\n        @SuppressWarnings(\"unchecked\")\n        final Map<String, String> projectProperties = Map.class.cast(getProject().getProperties());\n        @SuppressWarnings(\"unchecked\")\n        final Map<String, String> systemProperties = Map.class.cast(System.getProperties());\n\n        variables.putAll(projectProperties);\n        variables.putAll(systemProperties);\n        variables.put(\"name\", name != null ? name : getProject().getName());\n        variables.put(\"artifactId\", getProject().getArtifactId());\n        variables.put(\"groupId\", getProject().getGroupId());\n        variables.put(\"version\", getProjectVersion());\n        variables.put(\"description\", getProject().getDescription());\n        variables.put(\"extension\", \"deb\");\n        variables.put(\"baseDir\", getProject().getBasedir().getAbsolutePath());\n        variables.put(\"buildDir\", buildDirectory.getAbsolutePath());\n        variables.put(\"project.version\", getProject().getVersion());\n        variables.put(\"url\", getProject().getUrl());\n\n        return new MapVariableResolver(variables);\n    }\n\n    /**\n     * Doc some cleanup and conversion on the Maven project version.\n     * <ul>\n     * <li>any \"-\" is replaced by \"+\"<\/li>\n     * <li>\"SNAPSHOT\" is replaced with the current time and date, prepended by \"~\"<\/li>\n     * <\/ul>\n     *\n     * @return the Maven project version\n     */\n    private String getProjectVersion() {\n        return Utils.convertToDebianVersion(getProject().getVersion(), this.timestamped ? session.getStartTime() : null);\n    }\n\n    /**\n     * @return whether or not Maven is currently operating in the execution root\n     */\n    private boolean isSubmodule() {\n        // FIXME there must be a better way\n        return !session.getExecutionRootDirectory().equalsIgnoreCase(baseDir.toString());\n    }\n\n    /**\n     * @return whether or not the main artifact was created\n     */\n    private boolean hasMainArtifact() {\n        final MavenProject project = getProject();\n        final Artifact artifact = project.getArtifact();\n        return artifact.getFile() != null && artifact.getFile().isFile();\n    }\n\n    /**\n     * Main entry point\n     *\n     * @throws MojoExecutionException on error\n     */\n    @Override\n    public void execute() throws MojoExecutionException {\n\n        final MavenProject project = getProject();\n\n        if (skip) {\n            getLog().info(\"skipping execution\");\n            return;\n        }\n\n        if (isSubmodule() && !submodules) {\n            getLog().info(\"skipping sub module: jdeb executing at top-level only\");\n            return;\n        }\n\n        setData(dataSet);\n\n        console = new MojoConsole(getLog(), verbose);\n\n        initializeSignProperties();\n\n        final VariableResolver resolver = initializeVariableResolver(new HashMap<String, String>());\n\n        final File debFile = new File(Utils.replaceVariables(resolver, deb, openReplaceToken, closeReplaceToken));\n        final File controlDirFile = new File(Utils.replaceVariables(resolver, controlDir, openReplaceToken, closeReplaceToken));\n        final File installDirFile = new File(Utils.replaceVariables(resolver, installDir, openReplaceToken, closeReplaceToken));\n        final File changesInFile = new File(Utils.replaceVariables(resolver, changesIn, openReplaceToken, closeReplaceToken));\n        final File changesOutFile = new File(Utils.replaceVariables(resolver, changesOut, openReplaceToken, closeReplaceToken));\n        final File changesSaveFile = new File(Utils.replaceVariables(resolver, changesSave, openReplaceToken, closeReplaceToken));\n        final File keyringFile = keyring == null ? null : new File(Utils.replaceVariables(resolver, keyring, openReplaceToken, closeReplaceToken));\n\n        // if there are no producers defined we try to use the artifacts\n        if (dataProducers.isEmpty()) {\n\n            if (!hasMainArtifact()) {\n\n                final String packaging = project.getPackaging();\n                if (\"pom\".equalsIgnoreCase(packaging)) {\n                    getLog().warn(\"Creating empty debian package.\");\n                } else {\n                    throw new MojoExecutionException(\n                        \"Nothing to include into the debian package. \" +\n                            \"Did you maybe forget to add a <data> tag or call the plugin directly?\");\n                }\n\n            } else {\n\n                Set<Artifact> artifacts = new HashSet<Artifact>();\n\n                artifacts.add(project.getArtifact());\n\n                @SuppressWarnings(\"unchecked\")\n                final Set<Artifact> projectArtifacts = project.getArtifacts();\n\n                for (Artifact artifact : projectArtifacts) {\n                    artifacts.add(artifact);\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                final List<Artifact> attachedArtifacts = project.getAttachedArtifacts();\n\n                for (Artifact artifact : attachedArtifacts) {\n                    artifacts.add(artifact);\n                }\n\n                for (Artifact artifact : artifacts) {\n                    final File file = artifact.getFile();\n                    if (file != null) {\n                        dataProducers.add(new DataProducer() {\n                            @Override\n                            public void produce( final DataConsumer receiver ) {\n                                try {\n                                    receiver.onEachFile(\n                                        new FileInputStream(file),\n                                        new File(installDirFile, file.getName()).getAbsolutePath(),\n                                        \"\",\n                                        \"root\", 0, \"root\", 0,\n                                        TarEntry.DEFAULT_FILE_MODE,\n                                        file.length());\n                                } catch (Exception e) {\n                                    getLog().error(e);\n                                }\n                            }\n                        });\n                    } else {\n                        getLog().error(\"No file for artifact \" + artifact);\n                    }\n                }\n            }\n        }\n\n        try {\n            DebMaker debMaker = new DebMaker(console, dataProducers);\n            debMaker.setDeb(debFile);\n            debMaker.setControl(controlDirFile);\n            debMaker.setPackage(getProject().getArtifactId());\n            debMaker.setDescription(getProject().getDescription());\n            debMaker.setHomepage(getProject().getUrl());\n            debMaker.setChangesIn(changesInFile);\n            debMaker.setChangesOut(changesOutFile);\n            debMaker.setChangesSave(changesSaveFile);\n            debMaker.setCompression(compression);\n            debMaker.setKeyring(keyringFile);\n            debMaker.setKey(key);\n            debMaker.setPassphrase(passphrase);\n            debMaker.setSignPackage(signPackage);\n            debMaker.setResolver(resolver);\n            debMaker.validate();\n            debMaker.makeDeb();\n\n            // Always attach unless explicitly set to false\n            if (\"true\".equalsIgnoreCase(attach)) {\n                console.info(\"Attaching created debian package \" + debFile);\n                projectHelper.attachArtifact(project, type, classifier, debFile);\n            }\n\n        } catch (PackagingException e) {\n            getLog().error(\"Failed to create debian package \" + debFile, e);\n            throw new MojoExecutionException(\"Failed to create debian package \" + debFile, e);\n        }\n    }\n\n    /**\n     * Initializes unspecified sign properties using available defaults\n     * and global settings.\n     */\n    private void initializeSignProperties() {\n        if (!signPackage) {\n            return;\n        }\n\n        if (key != null && keyring != null && passphrase != null) {\n            return;\n        }\n\n        Map<String, String> properties =\n                readPropertiesFromActiveProfiles(signCfgPrefix, KEY, KEYRING, PASSPHRASE);\n\n        key = lookupIfEmpty(key, properties, KEY);\n        keyring = lookupIfEmpty(keyring, properties, KEYRING);\n        passphrase = lookupIfEmpty(passphrase, properties, PASSPHRASE);\n\n        if (keyring == null) {\n            try {\n                keyring = Utils.guessKeyRingFile().getAbsolutePath();\n                console.info(\"Located keyring at \" + keyring);\n            } catch (FileNotFoundException e) {\n                console.warn(e.getMessage());\n            }\n        }\n    }\n\n\n    /**\n     * Read properties from the active profiles.\n     *\n     * Goes through all active profiles (in the order the\n     * profiles are defined in settings.xml) and extracts\n     * the desired properties (if present). The prefix is\n     * used when looking up properties in the profile but\n     * not in the returned map.\n     *\n     * @param prefix The prefix to use or null if no prefix should be used\n     * @param properties The properties to read\n     *\n     * @return A map containing the values for the properties that were found\n     */\n    public Map<String, String> readPropertiesFromActiveProfiles( final String prefix,\n                                                                 final String... properties ) {\n        if (settings == null) {\n            console.debug(\"No maven setting injected\");\n            return Collections.emptyMap();\n        }\n\n        final List<String> activeProfilesList = settings.getActiveProfiles();\n        if (activeProfilesList.isEmpty()) {\n            console.debug(\"No active profiles found\");\n            return Collections.emptyMap();\n        }\n\n        final Map<String, String> map = new HashMap<String, String>();\n        final Set<String> activeProfiles = new HashSet<String>(activeProfilesList);\n\n        // Iterate over all active profiles in order\n        for (final Profile profile : settings.getProfiles()) {\n            // Check if the profile is active\n            final String profileId = profile.getId();\n            if (activeProfiles.contains(profileId)) {\n                console.debug(\"Trying active profile \" + profileId);\n                for (final String property : properties) {\n                    final String propKey = prefix != null ? prefix + property : property;\n                    final String value = profile.getProperties().getProperty(propKey);\n                    if (value != null) {\n                        console.debug(\"Found property \" + property + \" in profile \" + profileId);\n                        map.put(property, value);\n                    }\n                }\n            }\n        }\n\n        return map;\n    }\n\n}\n","lineNo":420}
{"Smelly Sample":"/*\n * Copyright 2013 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb.ant;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.taskdefs.MatchingTask;\nimport org.apache.tools.ant.taskdefs.Tar;\nimport org.apache.tools.ant.types.FileSet;\nimport org.vafer.jdeb.Compression;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.Processor;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.debian.BinaryPackageControlFile;\nimport org.vafer.jdeb.debian.ChangesFile;\nimport org.vafer.jdeb.producers.DataProducerFileSet;\nimport org.vafer.jdeb.signing.PGPSigner;\n\n/**\n * TODO generalize with DebMaker\n *\n * AntTask for creating debian archives.\n * Even supports signed changes files.\n *\n * @author Torsten Curdt\n */\npublic class DebAntTask extends MatchingTask {\n\n    /**\n     * The Debian package produced\n     */\n    private File deb;\n\n    /**\n     * The directory containing the control files to build the package\n     */\n    private File control;\n\n    /**\n     * The file containing the PGP keys\n     */\n    private File keyring;\n\n    /**\n     * The key to use in the keyring\n     */\n    private String key;\n\n    /**\n     * The passphrase for the key to sign the changes file\n     */\n    private String passphrase;\n\n    /**\n     * The file to read the changes from\n     */\n    private File changesIn;\n\n    /**\n     * The file where to write the changes to\n     */\n    private File changesOut;\n\n    /**\n     * The file where to write the changes of the changes input to\n     */\n    private File changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip or bzip2)\n     */\n    private String compression = \"gzip\";\n\n    /**\n     * Trigger the verbose mode detailing all operations\n     */\n    private boolean verbose;\n\n    private Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n\n    public void setDestfile( File deb ) {\n        this.deb = deb;\n    }\n\n    public void setControl( File control ) {\n        this.control = control;\n    }\n\n    public void setChangesIn( File changes ) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut( File changes ) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave( File changes ) {\n        this.changesSave = changes;\n    }\n\n    public void setKeyring( File keyring ) {\n        this.keyring = keyring;\n    }\n\n    public void setKey( String key ) {\n        this.key = key;\n    }\n\n    public void setPassphrase( String passphrase ) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression( String compression ) {\n        this.compression = compression;\n    }\n\n    public void setVerbose( boolean verbose ) {\n        this.verbose = verbose;\n    }\n\n    public void addFileSet( FileSet fileset ) {\n        dataProducers.add(new DataProducerFileSet(fileset));\n    }\n\n    public void addTarFileSet( Tar.TarFileSet fileset ) {\n        dataProducers.add(new DataProducerFileSet(fileset));\n    }\n\n    public void addData( Data data ) {\n        dataProducers.add(data);\n    }\n\n    private boolean isPossibleOutput( File file ) {\n\n        if (file == null) {\n            return false;\n        }\n\n        if (file.exists()) {\n            return file.isFile() && file.canWrite();\n        }\n\n        return true;\n    }\n\n    public void execute() {\n\n        if (control == null || !control.isDirectory()) {\n            throw new BuildException(\"You need to point the 'control' attribute to the control directory.\");\n        }\n\n        if (changesIn != null) {\n\n            if (!changesIn.isFile() || !changesIn.canRead()) {\n                throw new BuildException(\"The 'changesIn' attribute needs to point to a readable file. \" + changesIn + \" was not found/readable.\");\n            }\n\n            if (changesOut == null) {\n                throw new BuildException(\"A 'changesIn' without a 'changesOut' does not make much sense.\");\n            }\n\n            if (!isPossibleOutput(changesOut)) {\n                throw new BuildException(\"Cannot write the output for 'changesOut' to \" + changesOut);\n            }\n\n            if (changesSave != null && !isPossibleOutput(changesSave)) {\n                throw new BuildException(\"Cannot write the output for 'changesSave' to \" + changesSave);\n            }\n\n        } else {\n            if (changesOut != null || changesSave != null) {\n                throw new BuildException(\"The 'changesOut' or 'changesSave' attributes may only be used when there is a 'changesIn' specified.\");\n            }\n        }\n\n        if (Compression.toEnum(compression) == null) {\n            throw new BuildException(\"The compression method '\" + compression + \"' is not supported (expected 'none', 'gzip' or 'bzip2')\");\n        }\n\n        if (dataProducers.size() == 0) {\n            throw new BuildException(\"You need to provide at least one reference to a tgz or directory with data.\");\n        }\n\n        // validation of the type of the <data> elements\n        for (DataProducer dataProducer : dataProducers) {\n            if (dataProducer instanceof Data) {\n                Data data = (Data) dataProducer;\n                if (data.getType() == null) {\n                    throw new BuildException(\"The type of the data element wasn't specified (expected 'file', 'directory' or 'archive')\");\n                } else if (!Arrays.asList(\"file\", \"directory\", \"archive\").contains(data.getType().toLowerCase())) {\n                    throw new BuildException(\"The type '\" + data.getType() + \"' of the data element is unknown (expected 'file', 'directory' or 'archive')\");\n                }\n            }\n        }\n        \n        if (deb == null) {\n            throw new BuildException(\"You need to point the 'destfile' attribute to where the deb is supposed to be created.\");\n        }\n\n        final File[] controlFiles = control.listFiles();\n\n        final DataProducer[] data = new DataProducer[dataProducers.size()];\n        dataProducers.toArray(data);\n\n        final Processor processor = new Processor(new TaskConsole(this, verbose), null);\n\n        final BinaryPackageControlFile packageControlFile;\n        try {\n\n            log(\"Creating debian package: \" + deb);\n\n            packageControlFile = processor.createDeb(controlFiles, data, deb, Compression.toEnum(compression));\n\n        } catch (Exception e) {\n            // what the fuck ant? why are you not printing the exception chain?\n            e.printStackTrace();\n            throw new BuildException(\"Failed to create debian package \" + deb, e);\n        }\n        \n        makeChangesFiles(processor, packageControlFile);\n    }\n\n    private void makeChangesFiles(Processor processor, BinaryPackageControlFile packageControlFile) throws BuildException {\n        if (changesOut == null) {\n            return;\n        }\n        \n        TextfileChangesProvider changesProvider;\n        FileOutputStream out = null;\n        \n        try {\n            log(\"Creating changes file: \" + changesOut);\n            \n            out = new FileOutputStream(changesOut);\n            \n            // for now only support reading the changes form a textfile provider\n            changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageControlFile);\n            \n            ChangesFile changesFile = processor.createChanges(packageControlFile, changesProvider);\n            \n            if (keyring != null && key != null && passphrase != null) {\n                log(\"Signing the changes file with the key \" + key);\n                PGPSigner signer = new PGPSigner(new FileInputStream(keyring), key, passphrase);\n                signer.clearSign(changesFile.toString(), out);\n            } else {\n                out.write(changesFile.toString().getBytes(\"UTF-8\"));\n            }\n            out.flush();\n\n        } catch (Exception e) {\n            throw new BuildException(\"Failed to create the Debian changes file \" + changesOut, e);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n        \n        if (changesSave == null) {\n            return;\n        }\n        \n        try {\n            log(\"Saving changes to file: \" + changesSave);\n\n            changesProvider.save(new FileOutputStream(changesSave));\n\n        } catch (Exception e) {\n            throw new BuildException(\"Failed to save debian changes file \" + changesSave, e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2013 The jdeb developers.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb.ant;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.taskdefs.MatchingTask;\nimport org.apache.tools.ant.taskdefs.Tar;\nimport org.apache.tools.ant.types.FileSet;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.DebMaker;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.producers.DataProducerFileSet;\n\n/**\n * AntTask for creating debian archives.\n *\n * @author Torsten Curdt\n */\npublic class DebAntTask extends MatchingTask {\n\n    /** The Debian package produced */\n    private File deb;\n\n    /** The directory containing the control files to build the package */\n    private File control;\n\n    /** The file containing the PGP keys */\n    private File keyring;\n\n    /** The key to use in the keyring */\n    private String key;\n\n    /** The passphrase for the key to sign the changes file */\n    private String passphrase;\n\n    /** The file to read the changes from */\n    private File changesIn;\n\n    /** The file where to write the changes to */\n    private File changesOut;\n\n    /** The file where to write the changes of the changes input to */\n    private File changesSave;\n\n    /** The compression method used for the data file (none, gzip or bzip2) */\n    private String compression = \"gzip\";\n\n    /** Trigger the verbose mode detailing all operations */\n    private boolean verbose;\n\n    private Collection<DataProducer> dataProducers = new ArrayList<DataProducer>();\n\n\n    public void setDestfile( File deb ) {\n        this.deb = deb;\n    }\n\n    public void setControl( File control ) {\n        this.control = control;\n    }\n\n    public void setChangesIn( File changes ) {\n        this.changesIn = changes;\n    }\n\n    public void setChangesOut( File changes ) {\n        this.changesOut = changes;\n    }\n\n    public void setChangesSave( File changes ) {\n        this.changesSave = changes;\n    }\n\n    public void setKeyring( File keyring ) {\n        this.keyring = keyring;\n    }\n\n    public void setKey( String key ) {\n        this.key = key;\n    }\n\n    public void setPassphrase( String passphrase ) {\n        this.passphrase = passphrase;\n    }\n\n    public void setCompression( String compression ) {\n        this.compression = compression;\n    }\n\n    public void setVerbose( boolean verbose ) {\n        this.verbose = verbose;\n    }\n\n    public void addFileSet( FileSet fileset ) {\n        dataProducers.add(new DataProducerFileSet(fileset));\n    }\n\n    public void addTarFileSet( Tar.TarFileSet fileset ) {\n        dataProducers.add(new DataProducerFileSet(fileset));\n    }\n\n    public void addData( Data data ) {\n        dataProducers.add(data);\n    }\n\n    public void execute() {\n        // validate the type of the <data> elements\n        for (DataProducer dataProducer : dataProducers) {\n            if (dataProducer instanceof Data) {\n                Data data = (Data) dataProducer;\n                if (data.getType() == null) {\n                    throw new BuildException(\"The type of the data element wasn't specified (expected 'file', 'directory' or 'archive')\");\n                } else if (!Arrays.asList(\"file\", \"directory\", \"archive\").contains(data.getType().toLowerCase())) {\n                    throw new BuildException(\"The type '\" + data.getType() + \"' of the data element is unknown (expected 'file', 'directory' or 'archive')\");\n                }\n            }\n        }\n        \n        Console console = new TaskConsole(this, verbose);\n        \n        DebMaker debMaker = new DebMaker(console, dataProducers);\n        debMaker.setDeb(deb);\n        debMaker.setControl(control);\n        debMaker.setChangesIn(changesIn);\n        debMaker.setChangesOut(changesOut);\n        debMaker.setChangesSave(changesSave);\n        debMaker.setKeyring(keyring);\n        debMaker.setKey(key);\n        debMaker.setPassphrase(passphrase);\n        debMaker.setCompression(compression);\n        \n        try {\n            debMaker.validate();\n            debMaker.makeDeb();\n            \n        } catch (PackagingException e) {\n            log(\"Failed to create the Debian package \" + deb, e, Project.MSG_ERR);\n            throw new BuildException(\"Failed to create the Debian package \" + deb, e);\n        }\n    }\n}\n","lineNo":140}
{"Smelly Sample":"/*\n * Copyright 2013 Emmanuel Bourg\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.zip.GZIPInputStream;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n\n/**\n * Support class for inspecting the content of an archive.\n * \n * @author Emmanuel Bourg\n */\npublic class ArchiveWalker {\n    \n    public static void walk(ArchiveInputStream in, ArchiveVisitor visitor) throws IOException {\n        try {\n            ArchiveEntry entry;\n            while ((entry = in.getNextEntry()) != null) {\n                byte[] content = new byte[(int) entry.getSize()];\n                if (entry.getSize() > 0) {\n                    int length = in.read(content);\n                    if (length != entry.getSize()) {\n                        throw new IOException(\"Couldn't read entry \" + entry.getName() + \" : read \" + length + \", expected \" + entry.getSize());\n                    }\n                }\n                \n                visitor.visit(entry, content);\n            }\n        } finally {\n            in.close();\n        }\n    }\n\n    public static void walkControlFiles(File deb, final ArchiveVisitor<TarArchiveEntry> visitor) throws IOException {\n        ArArchiveInputStream in = new ArArchiveInputStream(new FileInputStream(deb));\n        ArchiveWalker.walk(in, new ArchiveVisitor<ArArchiveEntry>() {\n            public void visit(ArArchiveEntry entry, byte[] content) throws IOException {\n                if (entry.getName().equals(\"control.tar.gz\")) {\n                    TarArchiveInputStream tar = new TarArchiveInputStream(new GZIPInputStream(new ByteArrayInputStream(content)));\n                    ArchiveWalker.walk(tar, visitor);\n                }\n            }\n        });\n    }\n\n    public static void walkData(File deb, final ArchiveVisitor<TarArchiveEntry> visitor, final Compression compression) throws IOException {\n        ArArchiveInputStream in = new ArArchiveInputStream(new FileInputStream(deb));\n        ArchiveWalker.walk(in, new ArchiveVisitor<ArArchiveEntry>() {\n            public void visit(ArArchiveEntry entry, byte[] content) throws IOException {\n                if (entry.getName().equals(\"data.tar\" + compression.getExtension())) {\n                    InputStream in = new ByteArrayInputStream(content);\n                    if (compression == Compression.GZIP) {\n                        in = new GZIPInputStream(in);\n                    } else if (compression == Compression.BZIP2) {\n                        in = new BZip2CompressorInputStream(in);\n                    }\n                    \n                    ArchiveWalker.walk(new TarArchiveInputStream(in), visitor);\n                }\n            }\n        });\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2013 Emmanuel Bourg\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.zip.GZIPInputStream;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n\n/**\n * Support class for inspecting the content of an archive.\n * \n * @author Emmanuel Bourg\n */\npublic class ArchiveWalker {\n    \n    public static void walk(ArchiveInputStream in, ArchiveVisitor visitor) throws IOException {\n        try {\n            ArchiveEntry entry;\n            while ((entry = in.getNextEntry()) != null) {\n                byte[] content = new byte[(int) entry.getSize()];\n                if (entry.getSize() > 0) {\n                    int length = in.read(content);\n                    if (length != entry.getSize()) {\n                        throw new IOException(\"Couldn't read entry \" + entry.getName() + \" : read \" + length + \", expected \" + entry.getSize());\n                    }\n                }\n                \n                visitor.visit(entry, content);\n            }\n        } finally {\n            in.close();\n        }\n    }\n\n    public static boolean walkControl(File deb, final ArchiveVisitor<TarArchiveEntry> visitor) throws IOException {\n        return walkEmbedded(deb, \"control.tar\", visitor, Compression.GZIP);\n    }\n\n    public static boolean walkData(File deb, final ArchiveVisitor<TarArchiveEntry> visitor, final Compression compression) throws IOException {\n        return walkEmbedded(deb, \"data.tar\", visitor, compression);\n    }\n\n    public static boolean walkEmbedded(File deb, final String name, final ArchiveVisitor<TarArchiveEntry> visitor, final Compression compression) throws IOException {\n        final AtomicBoolean found = new AtomicBoolean(false);\n        ArArchiveInputStream in = new ArArchiveInputStream(new FileInputStream(deb));\n        ArchiveWalker.walk(in, new ArchiveVisitor<ArArchiveEntry>() {\n            public void visit(ArArchiveEntry entry, byte[] content) throws IOException {\n                if (entry.getName().equals(name + compression.getExtension())) {\n                    InputStream in = new ByteArrayInputStream(content);\n                    if (compression == Compression.GZIP) {\n                        in = new GZIPInputStream(in);\n                    } else if (compression == Compression.BZIP2) {\n                        in = new BZip2CompressorInputStream(in);\n                    }\n                    \n                    ArchiveWalker.walk(new TarArchiveInputStream(in), new ArchiveVisitor<TarArchiveEntry>() {\n                        public void visit(TarArchiveEntry entry, byte[] content) throws IOException {\n                            found.set(true);\n                            visitor.visit(entry, content);\n                        }\n                    });\n                }\n            }\n        });\n        return found.get();\n    }\n}\n","lineNo":75}
{"Smelly Sample":"/*\n * Copyright 2012 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.mapping.Mapper;\n\n/**\n * DataProducer representing a single file\n * For cross-platform permissions and ownerships you probably want to use a Mapper, too.\n *\n * @author Torsten Curdt <tcurdt@vafer.org>\n */\npublic final class DataProducerFile extends AbstractDataProducer implements DataProducer {\n\n    private final File file;\n\n    public DataProducerFile(final File pFile, String[] pIncludes, String[] pExcludes, Mapper[] pMapper) {\n        super(pIncludes, pExcludes, pMapper);\n        file = pFile;\n    }\n\n    public void produce( final DataConsumer pReceiver ) throws IOException {\n\n        TarEntry entry = new TarEntry(file.getName());\n        entry.setUserId(0);\n        entry.setUserName(\"root\");\n        entry.setGroupId(0);\n        entry.setGroupName(\"root\");\n        entry.setMode(TarEntry.DEFAULT_FILE_MODE);\n\n        entry = map(entry);\n\n        entry.setSize(file.length());\n\n        final InputStream inputStream = new FileInputStream(file);\n        try {\n            pReceiver.onEachFile(inputStream, entry.getName(), entry.getLinkName(), entry.getUserName(), entry.getUserId(), entry.getGroupName(), entry.getGroupId(), entry.getMode(), entry.getSize());\n        } finally {\n            inputStream.close();\n        }\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2012 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.mapping.Mapper;\n\n/**\n * DataProducer representing a single file For cross-platform permissions and ownerships you probably want to use a\n * Mapper, too.\n * \n * @author Torsten Curdt <tcurdt@vafer.org>\n */\npublic final class DataProducerFile extends AbstractDataProducer implements DataProducer {\n\n    private final File file;\n\n    private final String destinationName;\n\n    public DataProducerFile( final File pFile, String pDestinationName, String[] pIncludes, String[] pExcludes, Mapper[] pMapper ) {\n        super(pIncludes, pExcludes, pMapper);\n        file = pFile;\n        destinationName = pDestinationName;\n    }\n\n    @Override\n    public void produce( final DataConsumer pReceiver ) throws IOException {\n        String fileName;\n        if (destinationName != null && destinationName.trim().length() > 0) {\n            fileName = destinationName.trim();\n        } else {\n            fileName = file.getName();\n        }\n        TarEntry entry = new TarEntry(fileName);\n        entry.setUserId(0);\n        entry.setUserName(\"root\");\n        entry.setGroupId(0);\n        entry.setGroupName(\"root\");\n        entry.setMode(TarEntry.DEFAULT_FILE_MODE);\n\n        entry = map(entry);\n\n        entry.setSize(file.length());\n\n        final InputStream inputStream = new FileInputStream(file);\n        try {\n            pReceiver.onEachFile(inputStream, entry.getName(), entry.getLinkName(), entry.getUserName(), entry.getUserId(), entry.getGroupName(), entry.getGroupId(), entry.getMode(), entry.getSize());\n        } finally {\n            inputStream.close();\n        }\n\n    }\n\n}\n","lineNo":48}
{"Smelly Sample":"/*\n * Copyright 2012 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.descriptors.AbstractDescriptor;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * Creates deb archive\n *\n * @goal jdeb\n */\npublic class DebMojo extends AbstractPluginMojo {\n\n    /**\n     * @component\n     */\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the pattern of the name of final artifacts. Possible\n     * substitutions are [[baseDir]] [[buildDir]] [[artifactId]] [[version]]\n     * [[extension]] and [[groupId]].\n     *\n     * @parameter default-value=\"[[buildDir]]/[[artifactId]]_[[version]].[[extension]]\"\n     */\n    private String deb;\n\n    /**\n     * Explicitly defines the path to the control directory. At least the\n     * control file is mandatory.\n     *\n     * @parameter default-value=\"[[baseDir]]/src/deb/control\"\n     */\n    private String controlDir;\n\n    /**\n     * Explicitly define the file to read the changes from.\n     *\n     * @parameter default-value=\"[[baseDir]]/CHANGES.txt\"\n     */\n    private String changesIn;\n\n    /**\n     * Explicitly define the file where to write the changes to.\n     *\n     * @parameter default-value=\"[[buildDir]]/[[artifactId]]_[[version]].changes\"\n     */\n    private String changesOut;\n\n    /**\n     * Explicitly define the file where to write the changes of the changes\n     * input to.\n     *\n     * @parameter default-value=\"[[baseDir]]/CHANGES.txt\"\n     */\n    private String changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip or bzip2)\n     *\n     * @parameter default-value=\"gzip\"\n     */\n    private String compression;\n\n\n    /**\n     * Boolean option whether to attach the artifact to the project\n     *\n     *  @parameter default-value=\"true\"\n     */\n    private String attach;\n\n    /**\n     * The location where all package files will be installed. By default, all\n     * packages are installed in /opt (see the FHS here:\n     * http://www.pathname.com/\n     * fhs/pub/fhs-2.3.html#OPTADDONAPPLICATIONSOFTWAREPACKAGES)\n     *\n     * @parameter default-value=\"/opt/[[artifactId]]\"\n     */\n    private String installDir;\n\n\n    /**\n     * The type of attached artifact\n     *\n     * @parameter default-value=\"deb\"\n     */\n    private String type;\n\n    /**\n     * The project base directory\n     *\n     * @parameter default-value=\"${basedir}\"\n     * @required\n     * @readonly\n     */\n    private File baseDir;\n\n    /**\n     * Run the plugin on all sub-modules.\n     * If set to false, the plugin will be run in the same folder where the\n     * mvn command was invoked\n     * @parameter expression=\"${submodules}\" default-value=\"true\"\n     */\n    private boolean submodules;\n\n    /**\n     * The Maven Session Object\n     *\n     * @parameter expression=\"${session}\"\n     * @required\n     * @readonly\n     */\n    private MavenSession session;\n\n    /**\n     * The classifier of attached artifact\n     *\n     * @parameter\n     */\n    private String classifier;\n\n    /**\n     * \"data\" entries used to determine which files should be added to this deb.\n     * The \"data\" entries may specify a tarball (tar.gz, tar.bz2, tgz), a\n     * directory, or a normal file. An entry would look something like this in\n     * your pom.xml:\n     *\n     * <pre>\n     *   <build>\n     *     <plugins>\n     *       <plugin>\n     *       <artifactId>jdeb<\/artifactId>\n     *       <groupId>org.vafer<\/groupId>\n     *       ...\n     *       <configuration>\n     *         ...\n     *         <dataSet>\n     *           <data>\n     *             <src>${project.basedir}/target/my_archive.tar.gz<\/src>\n     *             <include>...<\/include>\n     *             <exclude>...<\/exclude>\n     *             <mapper>\n     *               <type>perm<\/type>\n     *               <strip>1<\/strip>\n     *               <prefix>/somewhere/else<\/prefix>\n     *               <user>santbj<\/user>\n     *               <group>santbj<\/group>\n     *               <mode>600<\/mode>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.build.directory}/data<\/src>\n     *             <include><\/include>\n     *             <exclude>**&#47;.svn<\/exclude>\n     *             <mapper>\n     *               <type>ls<\/type>\n     *               <src>mapping.txt<\/src>\n     *             <\/mapper>\n     *           <\/data>\n     *         <data>\n     *           <src>${project.basedir}/README.txt<\/src>\n     *         <\/data>\n     *         <\/dataSet>\n     *       <\/configuration>\n     *     <\/plugins>\n     *   <\/build>\n     * <\/pre>\n     *\n     * @parameter expression=\"${dataSet}\"\n     */\n    private Data[] dataSet;\n\n    /**\n     * When SNAPSHOT version replace <code>SNAPSHOT<\/code> with current date\n     * and time to make sure each build is unique.\n     *\n     * @parameter expression=\"${timestamped}\" default-value=\"false\"\n     */\n    private boolean timestamped;\n\n    /* end of parameters */\n\n    private String openReplaceToken = \"[[\";\n    private String closeReplaceToken = \"]]\";\n    private Collection dataProducers = new ArrayList();\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n        AbstractDescriptor.setOpenToken(openReplaceToken);\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n        AbstractDescriptor.setCloseToken(closeReplaceToken);\n    }\n\n    protected void setData(Data[] pData) {\n        dataSet = pData;\n        dataProducers.clear();\n        if (pData != null) {\n            for (int i = 0; i < pData.length; i++) {\n                dataProducers.add(pData[i]);\n            }\n        }\n    }\n\n    protected VariableResolver initializeVariableResolver(Map variables) {\n        variables.put(\"name\", getProject().getName());\n        variables.put(\"artifactId\", getProject().getArtifactId());\n        variables.put(\"groupId\", getProject().getGroupId());\n        variables.put(\"version\", getProjectVersion());\n        variables.put(\"description\", getProject().getDescription());\n        variables.put(\"extension\", \"deb\");\n        variables.put(\"baseDir\", getProject().getBasedir().getAbsolutePath());\n        variables.put(\"buildDir\", buildDirectory.getAbsolutePath());\n        variables.put(\"project.version\", getProject().getVersion());\n        variables.put(\"url\", getProject().getUrl());\n        return new MapVariableResolver(variables);\n    }\n\n    /**\n     * Doc some cleanup and conversion on the Maven project version.\n     * <ul>\n     * <li>-: any - is replaced by +<\/li>\n     * <li>SNAPSHOT: replace \"SNAPSHOT\" par of the version with the current time and date<\/li>\n     * <\/ul>\n     *\n     * @return the Maven project version\n     */\n    private String getProjectVersion() {\n        String version = getProject().getVersion().replace('-', '+');\n\n        if (this.timestamped && version.endsWith(\"+SNAPSHOT\")) {\n            version = version.substring(0, version.length() - \"+SNAPSHOT\".length());\n            version += \"~\";\n            version += new SimpleDateFormat(\"yyyyMMdd.HHmmss.SSS\").format(new Date());\n        }\n\n        return version;\n    }\n\n    /**\n     *\n     * @return whether or not Maven is currently operating in the execution root\n     */\n    private boolean inExecRoot() {\n       return session.getExecutionRootDirectory().equalsIgnoreCase(baseDir.toString());\n    }\n\n    /**\n     * Main entry point\n     *\n     * @throws MojoExecutionException on error\n     */\n    public void execute() throws MojoExecutionException {\n\n        setData(dataSet);\n\n        if(! inExecRoot() && !submodules) {\n          getLog().info(\"skipping sub module: jdeb executing at top-level only\");\n          return;\n        }\n\n        try {\n\n            final VariableResolver resolver = initializeVariableResolver(new HashMap());\n\n            final File debFile = new File(Utils.replaceVariables(resolver, deb, openReplaceToken, closeReplaceToken));\n            final File controlDirFile = new File(Utils.replaceVariables(resolver, controlDir, openReplaceToken, closeReplaceToken));\n            final File installDirFile = new File(Utils.replaceVariables(resolver, installDir, openReplaceToken, closeReplaceToken));\n            final File changesInFile = new File(Utils.replaceVariables(resolver, changesIn, openReplaceToken, closeReplaceToken));\n            final File changesOutFile = new File(Utils.replaceVariables(resolver, changesOut, openReplaceToken, closeReplaceToken));\n            final File changesSaveFile = new File(Utils.replaceVariables(resolver, changesSave, openReplaceToken, closeReplaceToken));\n\n            // If there are no dataProducers, then we'll add a single producer that\n            // processes the\n            // maven artifact file (be it a jar, war, etc.)\n            if (dataProducers.isEmpty()) {\n                final File file = getProject().getArtifact().getFile();\n\n                if (file == null) {\n                  getLog().warn(\"There is no artifact to include if you call jdeb directly. The jdeb plugin is run during the install phase anyway.\");\n                  throw new MojoExecutionException(\"No artifact to include into deb\");\n                }\n\n                dataProducers.add(new DataProducer() {\n                    public void produce(final DataConsumer receiver) {\n                        try {\n                            receiver.onEachFile(new FileInputStream(file),\n                                    new File(installDirFile, file.getName()).getAbsolutePath(), \"\",\n                                    \"root\", 0, \"root\", 0,\n                                    TarEntry.DEFAULT_FILE_MODE, file.length());\n                        } catch (Exception e) {\n                            getLog().error(e);\n                        }\n                    }\n                });\n            }\n\n            Console infoConsole = new Console() {\n                public void println(String s) {\n                    getLog().info(s);\n                }\n            };\n\n            try {\n\n                DebMaker debMaker = new DebMaker(infoConsole, debFile, controlDirFile, dataProducers, resolver);\n\n                if (changesInFile.exists() && changesInFile.canRead()) {\n                    debMaker.setChangesIn(changesInFile);\n                    debMaker.setChangesOut(changesOutFile);\n                    debMaker.setChangesSave(changesSaveFile);\n                }\n\n                debMaker.setCompression(compression);\n                debMaker.makeDeb();\n\n                // Always attach unless explicitly set to false\n                if (\"true\".equalsIgnoreCase(attach)) {\n                    getLog().info(\"Attaching created debian archive \" + debFile);\n                    projectHelper.attachArtifact(getProject(), type, classifier, debFile);\n                }\n\n            } catch (PackagingException e) {\n                getLog().error(\"Failed to create debian package \" + debFile, e);\n                throw new MojoExecutionException(\"Failed to create debian package \" + debFile, e);\n            }\n\n        } catch (ParseException e) {\n            throw new MojoExecutionException(\"Failed parsing pattern\", e);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2012 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.PackagingException;\nimport org.vafer.jdeb.descriptors.AbstractDescriptor;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * Creates deb archive\n *\n * @goal jdeb\n */\npublic class DebMojo extends AbstractPluginMojo {\n\n    /**\n     * @component\n     */\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the pattern of the name of final artifacts. Possible\n     * substitutions are [[baseDir]] [[buildDir]] [[artifactId]] [[version]]\n     * [[extension]] and [[groupId]].\n     *\n     * @parameter default-value=\"[[buildDir]]/[[artifactId]]_[[version]].[[extension]]\"\n     */\n    private String deb;\n\n    /**\n     * Explicitly defines the path to the control directory. At least the\n     * control file is mandatory.\n     *\n     * @parameter default-value=\"[[baseDir]]/src/deb/control\"\n     */\n    private String controlDir;\n\n    /**\n     * Explicitly define the file to read the changes from.\n     *\n     * @parameter default-value=\"[[baseDir]]/CHANGES.txt\"\n     */\n    private String changesIn;\n\n    /**\n     * Explicitly define the file where to write the changes to.\n     *\n     * @parameter default-value=\"[[buildDir]]/[[artifactId]]_[[version]].changes\"\n     */\n    private String changesOut;\n\n    /**\n     * Explicitly define the file where to write the changes of the changes\n     * input to.\n     *\n     * @parameter default-value=\"[[baseDir]]/CHANGES.txt\"\n     */\n    private String changesSave;\n\n    /**\n     * The compression method used for the data file (none, gzip or bzip2)\n     *\n     * @parameter default-value=\"gzip\"\n     */\n    private String compression;\n\n\n    /**\n     * Boolean option whether to attach the artifact to the project\n     *\n     *  @parameter default-value=\"true\"\n     */\n    private String attach;\n\n    /**\n     * The location where all package files will be installed. By default, all\n     * packages are installed in /opt (see the FHS here:\n     * http://www.pathname.com/\n     * fhs/pub/fhs-2.3.html#OPTADDONAPPLICATIONSOFTWAREPACKAGES)\n     *\n     * @parameter default-value=\"/opt/[[artifactId]]\"\n     */\n    private String installDir;\n\n\n    /**\n     * The type of attached artifact\n     *\n     * @parameter default-value=\"deb\"\n     */\n    private String type;\n\n    /**\n     * The project base directory\n     *\n     * @parameter default-value=\"${basedir}\"\n     * @required\n     * @readonly\n     */\n    private File baseDir;\n\n    /**\n     * Run the plugin on all sub-modules.\n     * If set to false, the plugin will be run in the same folder where the\n     * mvn command was invoked\n     * @parameter expression=\"${submodules}\" default-value=\"true\"\n     */\n    private boolean submodules;\n\n    /**\n     * The Maven Session Object\n     *\n     * @parameter expression=\"${session}\"\n     * @required\n     * @readonly\n     */\n    private MavenSession session;\n\n    /**\n     * The classifier of attached artifact\n     *\n     * @parameter\n     */\n    private String classifier;\n\n    /**\n     * \"data\" entries used to determine which files should be added to this deb.\n     * The \"data\" entries may specify a tarball (tar.gz, tar.bz2, tgz), a\n     * directory, or a normal file. An entry would look something like this in\n     * your pom.xml:\n     *\n     * <pre>\n     *   <build>\n     *     <plugins>\n     *       <plugin>\n     *       <artifactId>jdeb<\/artifactId>\n     *       <groupId>org.vafer<\/groupId>\n     *       ...\n     *       <configuration>\n     *         ...\n     *         <dataSet>\n     *           <data>\n     *             <src>${project.basedir}/target/my_archive.tar.gz<\/src>\n     *             <include>...<\/include>\n     *             <exclude>...<\/exclude>\n     *             <mapper>\n     *               <type>perm<\/type>\n     *               <strip>1<\/strip>\n     *               <prefix>/somewhere/else<\/prefix>\n     *               <user>santbj<\/user>\n     *               <group>santbj<\/group>\n     *               <mode>600<\/mode>\n     *             <\/mapper>\n     *           <\/data>\n     *           <data>\n     *             <src>${project.build.directory}/data<\/src>\n     *             <include><\/include>\n     *             <exclude>**&#47;.svn<\/exclude>\n     *             <mapper>\n     *               <type>ls<\/type>\n     *               <src>mapping.txt<\/src>\n     *             <\/mapper>\n     *           <\/data>\n     *         <data>\n     *           <src>${project.basedir}/README.txt<\/src>\n     *         <\/data>\n     *         <\/dataSet>\n     *       <\/configuration>\n     *     <\/plugins>\n     *   <\/build>\n     * <\/pre>\n     *\n     * @parameter expression=\"${dataSet}\"\n     */\n    private Data[] dataSet;\n\n    /**\n     * When SNAPSHOT version replace <code>SNAPSHOT<\/code> with current date\n     * and time to make sure each build is unique.\n     *\n     * @parameter expression=\"${timestamped}\" default-value=\"false\"\n     */\n    private boolean timestamped;\n\n    /* end of parameters */\n\n    private String openReplaceToken = \"[[\";\n    private String closeReplaceToken = \"]]\";\n    private Collection dataProducers = new ArrayList();\n\n    public void setOpenReplaceToken(String openReplaceToken) {\n        this.openReplaceToken = openReplaceToken;\n        AbstractDescriptor.setOpenToken(openReplaceToken);\n    }\n\n    public void setCloseReplaceToken(String closeReplaceToken) {\n        this.closeReplaceToken = closeReplaceToken;\n        AbstractDescriptor.setCloseToken(closeReplaceToken);\n    }\n\n    protected void setData(Data[] pData) {\n        dataSet = pData;\n        dataProducers.clear();\n        if (pData != null) {\n            for (int i = 0; i < pData.length; i++) {\n                dataProducers.add(pData[i]);\n            }\n        }\n    }\n\n    protected VariableResolver initializeVariableResolver(Map variables) {\n        variables.put(\"name\", getProject().getName());\n        variables.put(\"artifactId\", getProject().getArtifactId());\n        variables.put(\"groupId\", getProject().getGroupId());\n        variables.put(\"version\", getProjectVersion());\n        variables.put(\"description\", getProject().getDescription());\n        variables.put(\"extension\", \"deb\");\n        variables.put(\"baseDir\", getProject().getBasedir().getAbsolutePath());\n        variables.put(\"buildDir\", buildDirectory.getAbsolutePath());\n        variables.put(\"project.version\", getProject().getVersion());\n        variables.put(\"url\", getProject().getUrl());\n        return new MapVariableResolver(variables);\n    }\n\n    /**\n     * Doc some cleanup and conversion on the Maven project version.\n     * <ul>\n     * <li>-: any - is replaced by +<\/li>\n     * <li>SNAPSHOT: replace \"SNAPSHOT\" par of the version with the current time and date<\/li>\n     * <\/ul>\n     *\n     * @return the Maven project version\n     */\n    private String getProjectVersion() {\n        String version = getProject().getVersion().replace('-', '+');\n\n        if (this.timestamped && version.endsWith(\"+SNAPSHOT\")) {\n            version = version.substring(0, version.length() - \"+SNAPSHOT\".length());\n            version += \"~\";\n            version += new SimpleDateFormat(\"yyyyMMdd.HHmmss.SSS\").format(new Date());\n        }\n\n        return version;\n    }\n\n    /**\n     * @return whether or not Maven is currently operating in the execution root\n     */\n    private boolean isSubmodule() {\n        // FIXME there must be a better way\n        return !session.getExecutionRootDirectory().equalsIgnoreCase(baseDir.toString());\n    }\n\n    /**\n     * Main entry point\n     *\n     * @throws MojoExecutionException on error\n     */\n    public void execute() throws MojoExecutionException {\n\n        final MavenProject project = getProject();\n\n        if(isSubmodule() && !submodules) {\n            getLog().info(\"skipping sub module: jdeb executing at top-level only\");\n            return;\n        }\n\n        setData(dataSet);\n\n        try {\n\n            final VariableResolver resolver = initializeVariableResolver(new HashMap());\n\n            final File debFile = new File(Utils.replaceVariables(resolver, deb, openReplaceToken, closeReplaceToken));\n            final File controlDirFile = new File(Utils.replaceVariables(resolver, controlDir, openReplaceToken, closeReplaceToken));\n            final File installDirFile = new File(Utils.replaceVariables(resolver, installDir, openReplaceToken, closeReplaceToken));\n            final File changesInFile = new File(Utils.replaceVariables(resolver, changesIn, openReplaceToken, closeReplaceToken));\n            final File changesOutFile = new File(Utils.replaceVariables(resolver, changesOut, openReplaceToken, closeReplaceToken));\n            final File changesSaveFile = new File(Utils.replaceVariables(resolver, changesSave, openReplaceToken, closeReplaceToken));\n\n            // if there are no producers defined we try to use the artifacts\n            if (dataProducers.isEmpty()) {\n\n                final Set<Artifact> artifacts = project.getArtifacts();\n                if (artifacts.size() == 0) {\n                    // no artifacts\n                    final String packaging = project.getPackaging();\n                    if (\"pom\".equalsIgnoreCase(packaging)) {\n                        getLog().warn(\"Creating empty debian package.\");\n                    } else {\n                        throw new MojoExecutionException(\n                            \"Nothing to include into the debian package. \" +\n                            \"Did you maybe forget to add a <data> tag or call the plugin directly?\");\n                    }\n\n                } else {\n\n                    // attach artifacts (jar, war, etc)\n                    for(Artifact artifact : artifacts) {\n                        final File file = artifact.getFile();\n                        if (file != null) {\n                            dataProducers.add(new DataProducer() {\n                                public void produce(final DataConsumer receiver) {\n                                    try {\n                                        receiver.onEachFile(\n                                                new FileInputStream(file),\n                                                new File(installDirFile, file.getName()).getAbsolutePath(),\n                                                \"\",\n                                                \"root\", 0, \"root\", 0,\n                                                TarEntry.DEFAULT_FILE_MODE,\n                                                file.length());\n                                    } catch (Exception e) {\n                                        getLog().error(e);\n                                    }\n                                }\n                            });\n                        } else {\n                            getLog().error(\"No file for artifact \" + artifact);\n                        }\n                    }\n                }\n            }\n\n            Console infoConsole = new Console() {\n                public void println(String s) {\n                    getLog().info(s);\n                }\n            };\n\n            try {\n\n                DebMaker debMaker = new DebMaker(infoConsole, debFile, controlDirFile, dataProducers, resolver);\n\n                if (changesInFile.exists() && changesInFile.canRead()) {\n                    debMaker.setChangesIn(changesInFile);\n                    debMaker.setChangesOut(changesOutFile);\n                    debMaker.setChangesSave(changesSaveFile);\n                }\n\n                debMaker.setCompression(compression);\n                debMaker.makeDeb();\n\n                // Always attach unless explicitly set to false\n                if (\"true\".equalsIgnoreCase(attach)) {\n                    getLog().info(\"Attaching created debian archive \" + debFile);\n                    projectHelper.attachArtifact(project, type, classifier, debFile);\n                }\n\n            } catch (PackagingException e) {\n                getLog().error(\"Failed to create debian package \" + debFile, e);\n                throw new MojoExecutionException(\"Failed to create debian package \" + debFile, e);\n            }\n\n        } catch (ParseException e) {\n            throw new MojoExecutionException(\"Failed parsing pattern\", e);\n        }\n    }\n}\n","lineNo":296}
{"Smelly Sample":"/*\n * Copyright 2012 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.descriptors;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.StringReader;\nimport java.text.ParseException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * A descriptor holds the usual key value pairs.\n *\n * @see <a href=\"http://www.debian.org/doc/debian-policy/ch-controlfields.html\">Debian Policy Manual - Control files and their fields<\/a>\n *\n * @author Torsten Curdt <tcurdt@vafer.org>\n */\npublic abstract class AbstractDescriptor {\n\n    private final Map values = new HashMap();\n    private final VariableResolver resolver;\n    private static String openToken = \"[[\";\n    private static String closeToken = \"]]\";\n\n    public AbstractDescriptor( final VariableResolver pResolver ) {\n        resolver = pResolver;\n    }\n\n    public AbstractDescriptor( final AbstractDescriptor pDescriptor ) {\n        values.putAll(pDescriptor.values);\n        resolver = pDescriptor.resolver;\n    }\n\n    public static void setOpenToken( final String pToken ) {\n        openToken = pToken;\n    }\n\n    public static void setCloseToken( final String pToken ) {\n        closeToken = pToken;\n    }\n\n    protected void parse( final InputStream pInput ) throws IOException, ParseException {\n        final BufferedReader br = new BufferedReader(new InputStreamReader(pInput));\n        StringBuffer buffer = new StringBuffer();\n        String key = null;\n        int linenr = 0;\n        while(true) {\n            final String line = br.readLine();\n\n            if (line == null) {\n                if (buffer.length() > 0) {\n                    // flush value of previous key\n                    set(key, buffer.toString());\n                    buffer = null;\n                }\n                break;\n            }\n\n            linenr++;\n\n            if (line.length() == 0) {\n                throw new ParseException(\"Empty line\", linenr);\n            }\n\n            final char first = line.charAt(0);\n            if (Character.isLetter(first)) {\n\n                // new key\n\n                if (buffer.length() > 0) {\n                    // flush value of previous key\n                    set(key, buffer.toString());\n                    buffer = new StringBuffer();\n                }\n\n\n                final int i = line.indexOf(':');\n\n                if (i < 0) {\n                    throw new ParseException(\"Line misses ':' delimitter\", linenr);\n                }\n\n                key = line.substring(0, i);\n                buffer.append(line.substring(i+1).trim());\n\n                continue;\n            }\n\n            // continuing old value\n            buffer.append('\\n').append(line.substring(1));\n        }\n        br.close();\n\n    }\n\n    public void set( final String pKey, final String pValue ) {\n\n        if (resolver != null) {\n            try {\n                values.put(pKey, Utils.replaceVariables(resolver, pValue, openToken, closeToken));\n                return;\n            } catch (ParseException e) {\n                // FIXME maybe throw an Exception?\n            }\n        }\n\n        values.put(pKey, pValue);\n    }\n\n    public String get( final String pKey ) {\n        return (String)values.get(pKey);\n    }\n\n    public abstract String[] getMandatoryKeys();\n\n    public boolean isValid() {\n        return invalidKeys().size() == 0;\n    }\n\n    public Set invalidKeys() {\n        final Set invalid = new HashSet();\n\n        final String[] mk = getMandatoryKeys();\n        for (int i = 0; i < mk.length; i++) {\n            if (get(mk[i]) == null) {\n                invalid.add(mk[i]);\n            }\n        }\n\n        return invalid;\n    }\n\n    public String toString( final String[] pKeys ) {\n        final StringBuffer s = new StringBuffer();\n        for (int i = 0; i < pKeys.length; i++) {\n            final String key = pKeys[i];\n            final String value = (String) values.get(key);\n            if (value != null) {\n                s.append(key).append(\":\");\n\n                try {\n                    BufferedReader reader = new BufferedReader(new StringReader(value));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        if (line.length() != 0 && !Character.isWhitespace(line.charAt(0))) {\n                            s.append(' ');\n                        }\n\n                        s.append(line).append('\\n');\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return s.toString();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2012 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.descriptors;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.StringReader;\nimport java.text.ParseException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * A descriptor holds the usual key value pairs.\n *\n * @see <a href=\"http://www.debian.org/doc/debian-policy/ch-controlfields.html\">Debian Policy Manual - Control files and their fields<\/a>\n *\n * @author Torsten Curdt <tcurdt@vafer.org>\n */\npublic abstract class AbstractDescriptor {\n\n    private final Map values = new HashMap();\n    private final VariableResolver resolver;\n    private static String openToken = \"[[\";\n    private static String closeToken = \"]]\";\n\n    public AbstractDescriptor( final VariableResolver pResolver ) {\n        resolver = pResolver;\n    }\n\n    public AbstractDescriptor( final AbstractDescriptor pDescriptor ) {\n        this(pDescriptor.resolver);\n        values.putAll(pDescriptor.values);\n    }\n\n    public static void setOpenToken( final String pToken ) {\n        openToken = pToken;\n    }\n\n    public static void setCloseToken( final String pToken ) {\n        closeToken = pToken;\n    }\n\n    protected void parse( final InputStream pInput ) throws IOException, ParseException {\n        final BufferedReader br = new BufferedReader(new InputStreamReader(pInput));\n        StringBuilder buffer = new StringBuilder();\n        String key = null;\n        int linenr = 0;\n        while(true) {\n            final String line = br.readLine();\n\n            if (line == null) {\n                if (buffer.length() > 0) {\n                    // flush value of previous key\n                    set(key, buffer.toString());\n                    buffer = null;\n                }\n                break;\n            }\n\n            linenr++;\n\n            if (line.length() == 0) {\n                throw new ParseException(\"Empty line\", linenr);\n            }\n\n            final char first = line.charAt(0);\n            if (Character.isLetter(first)) {\n\n                // new key\n\n                if (buffer.length() > 0) {\n                    // flush value of previous key\n                    set(key, buffer.toString());\n                    buffer = new StringBuilder();\n                }\n\n\n                final int i = line.indexOf(':');\n\n                if (i < 0) {\n                    throw new ParseException(\"Line misses ':' delimitter\", linenr);\n                }\n\n                key = line.substring(0, i);\n                buffer.append(line.substring(i+1).trim());\n\n                continue;\n            }\n\n            // continuing old value\n            buffer.append('\\n').append(line.substring(1));\n        }\n        br.close();\n\n    }\n\n    public void set( final String pKey, final String pValue ) {\n      String value = null;\n      try {\n        value = Utils.replaceVariables(resolver, pValue, openToken, closeToken);\n          if (\"\".equals(value)) {\n              value = null;\n          }\n      } catch(ParseException e) {\n      }\n        values.put(pKey, value);\n    }\n\n    public String get( final String pKey ) {\n        return (String)values.get(pKey);\n    }\n\n    public abstract String[] getMandatoryKeys();\n\n    public boolean isValid() {\n        return invalidKeys().size() == 0;\n    }\n\n    public Set invalidKeys() {\n        final Set invalid = new HashSet();\n\n        final String[] mk = getMandatoryKeys();\n        for (int i = 0; i < mk.length; i++) {\n            if (get(mk[i]) == null) {\n                invalid.add(mk[i]);\n            }\n        }\n\n        return invalid;\n    }\n\n    public String toString( final String[] pKeys ) {\n        final StringBuilder s = new StringBuilder();\n        for (int i = 0; i < pKeys.length; i++) {\n            final String key = pKeys[i];\n            final String value = (String) values.get(key);\n            if (value != null) {\n                s.append(key).append(\":\");\n\n                try {\n                    BufferedReader reader = new BufferedReader(new StringReader(value));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        if (line.length() != 0 && !Character.isWhitespace(line.charAt(0))) {\n                            s.append(' ');\n                        }\n\n                        s.append(line).append('\\n');\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return s.toString();\n    }\n}\n","lineNo":118}
{"Smelly Sample":"/*\n * Copyright 2010 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.tools.bzip2.CBZip2OutputStream;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarOutputStream;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.descriptors.ChangesDescriptor;\nimport org.vafer.jdeb.descriptors.InvalidDescriptorException;\nimport org.vafer.jdeb.descriptors.PackageDescriptor;\nimport org.vafer.jdeb.mapping.PermMapper;\nimport org.vafer.jdeb.signing.SigningUtils;\nimport org.vafer.jdeb.utils.InformationOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * The processor does the actual work of building the deb related files.\n * It is been used by the ant task and (later) the maven plugin.\n *\n * @author Torsten Curdt <tcurdt@vafer.org>\n */\npublic class Processor {\n\n    private final Console console;\n    private final VariableResolver resolver;\n\n    private static final class Total {\n        private BigInteger count = BigInteger.valueOf(0);\n\n        public void add(long size) {\n            count = count.add(BigInteger.valueOf(size));\n        }\n\n        public String toString() {\n            return \"\" + count;\n        }\n\n//        public BigInteger toBigInteger() {\n//            return count;\n//        }\n    }\n\n    public Processor( final Console pConsole, final VariableResolver pResolver ) {\n        console = pConsole;\n        resolver = pResolver;\n    }\n\n    private void addTo( final ArArchiveOutputStream pOutput, final String pName, final String pContent ) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo( final ArArchiveOutputStream pOutput, final String pName, final File pContent ) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param pControlFiles\n     * @param pData\n     * @param pOutput\n     * @param compression the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public PackageDescriptor createDeb( final File[] pControlFiles, final DataProducer[] pData, final File pOutput, String compression ) throws PackagingException, InvalidDescriptorException {\n\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.println(\"Building data\");\n            final StringBuffer md5s = new StringBuffer();\n            final BigInteger size = buildData(pData, tempData, md5s, compression);\n\n            console.println(\"Building control\");\n            final PackageDescriptor packageDescriptor = buildControl(pControlFiles, size, md5s, tempControl);\n\n            if (!packageDescriptor.isValid()) {\n                throw new InvalidDescriptorException(packageDescriptor);\n            }\n\n            pOutput.getParentFile().mkdirs();\n            final InformationOutputStream md5output = new InformationOutputStream(new FileOutputStream(pOutput), MessageDigest.getInstance(\"MD5\"));\n            //Add chain of filters in order to calculate sha1 and sha256 for 1.8 format\n            final InformationOutputStream sha1output = new InformationOutputStream(md5output, MessageDigest.getInstance(\"SHA1\"));\n            final InformationOutputStream sha256output = new InformationOutputStream(sha1output, MessageDigest.getInstance(\"SHA-256\"));\n\n            final ArArchiveOutputStream ar = new ArArchiveOutputStream(sha256output);\n\n            addTo(ar, \"debian-binary\", \"2.0\\n\");\n            addTo(ar, \"control.tar.gz\", tempControl);\n            addTo(ar, \"data.tar\" + getExtension(compression), tempData);\n\n            ar.close();\n\n            // intermediate values\n            packageDescriptor.set(\"MD5\", md5output.getHexDigest());\n            packageDescriptor.set(\"SHA1\", sha1output.getHexDigest());\n            packageDescriptor.set(\"SHA256\", sha256output.getHexDigest());\n            packageDescriptor.set(\"Size\", \"\" + md5output.getSize());\n            packageDescriptor.set(\"File\", pOutput.getName());\n\n            return packageDescriptor;\n\n        } catch(InvalidDescriptorException e) {\n            throw e;\n        } catch(Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    throw new PackagingException(\"Could not delete \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    throw new PackagingException(\"Could not delete \" + tempControl);\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the extension of a file compressed with the specified method.\n     *\n     * @param pCompression the compression method used\n     * @return\n     */\n    private String getExtension( final String pCompression ) {\n        if (\"gzip\".equals(pCompression)) {\n            return \".gz\";\n        } else if (\"bzip2\".equals(pCompression)) {\n            return \".bz2\";\n        } else {\n            return \"\";\n        }\n    }\n\n    /**\n     * Create changes file based on the provided PackageDescriptor.\n     * If pRing, pKey and pPassphrase are provided the changes file will also be signed.\n     * It returns a ChangesDescriptor reflecting the changes\n     * @param pPackageDescriptor\n     * @param pChangesProvider\n     * @param pRing\n     * @param pKey\n     * @param pPassphrase\n     * @param pOutput\n     * @return ChangesDescriptor\n     * @throws IOException\n     */\n    public ChangesDescriptor createChanges( final PackageDescriptor pPackageDescriptor, final ChangesProvider pChangesProvider, final InputStream pRing, final String pKey, final String pPassphrase, final OutputStream pOutput ) throws IOException, InvalidDescriptorException {\n\n        final ChangeSet[] changeSets = pChangesProvider.getChangesSets();\n        final ChangesDescriptor changesDescriptor = new ChangesDescriptor(pPackageDescriptor, changeSets);\n\n        changesDescriptor.set(\"Format\", \"1.8\");\n\n        if (changesDescriptor.get(\"Binary\") == null) {\n            changesDescriptor.set(\"Binary\", changesDescriptor.get(\"Package\"));\n        }\n\n        if (changesDescriptor.get(\"Source\") == null) {\n            changesDescriptor.set(\"Source\", changesDescriptor.get(\"Package\"));\n        }\n\n        if (changesDescriptor.get(\"Description\") == null) {\n            changesDescriptor.set(\"Description\", \"update to \" + changesDescriptor.get(\"Version\"));\n        }\n\n        final StringBuilder checksumsSha1 = new StringBuilder(\"\\n\");\n        // Checksums-Sha1:\n        // 56ef4c6249dc3567fd2967f809c42d1f9b61adf7 45964 jdeb.deb\n        checksumsSha1.append(' ').append(changesDescriptor.get(\"SHA1\"));\n        checksumsSha1.append(' ').append(changesDescriptor.get(\"Size\"));\n        checksumsSha1.append(' ').append(changesDescriptor.get(\"File\"));\n        changesDescriptor.set(\"Checksums-Sha1\", checksumsSha1.toString());\n\n        final StringBuilder checksumsSha256 = new StringBuilder(\"\\n\");\n        // Checksums-Sha256:\n        // 38c6fa274eb9299a69b739bcbdbd05c7ffd1d8d6472f4245ed732a25c0e5d616 45964 jdeb.deb\n        checksumsSha256.append(' ').append(changesDescriptor.get(\"SHA256\"));\n        checksumsSha256.append(' ').append(changesDescriptor.get(\"Size\"));\n        checksumsSha256.append(' ').append(changesDescriptor.get(\"File\"));\n        changesDescriptor.set(\"Checksums-Sha256\", checksumsSha256.toString());\n\n\n        final StringBuffer files = new StringBuffer(\"\\n\");\n        files.append(' ').append(changesDescriptor.get(\"MD5\"));\n        files.append(' ').append(changesDescriptor.get(\"Size\"));\n        files.append(' ').append(changesDescriptor.get(\"Section\"));\n        files.append(' ').append(changesDescriptor.get(\"Priority\"));\n        files.append(' ').append(changesDescriptor.get(\"File\"));\n        changesDescriptor.set(\"Files\", files.toString());\n\n        if (!changesDescriptor.isValid()) {\n            throw new InvalidDescriptorException(changesDescriptor);\n        }\n\n        final String changes = changesDescriptor.toString();\n        //console.println(changes);\n\n        final byte[] changesBytes = changes.getBytes(\"UTF-8\");\n\n        if (pRing == null || pKey == null || pPassphrase == null) {\n            pOutput.write(changesBytes);\n            pOutput.close();\n            return changesDescriptor;\n        }\n\n        console.println(\"Signing changes with key \" + pKey);\n\n        final InputStream input = new ByteArrayInputStream(changesBytes);\n\n        try {\n            SigningUtils.clearSign(input, pRing, pKey, pPassphrase, pOutput);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        pOutput.close();\n\n        return changesDescriptor;\n    }\n\n    /**\n     * Build control archive of the deb\n     * @param pControlFiles\n     * @param pDataSize\n     * @param pChecksums\n     * @param pOutput\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     * @throws ParseException\n     */\n    private PackageDescriptor buildControl( final File[] pControlFiles, final BigInteger pDataSize, final StringBuffer pChecksums, final File pOutput ) throws IOException, ParseException {\n\n        PackageDescriptor packageDescriptor = null;\n\n        final TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(pOutput)));\n        outputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n        for (int i = 0; i < pControlFiles.length; i++) {\n            final File file = pControlFiles[i];\n\n            if (file.isDirectory()) {\n                continue;\n            }\n\n            final TarEntry entry = new TarEntry(file);\n\n            final String name = file.getName();\n\n            entry.setName(\"./\" + name);\n            entry.setNames(\"root\", \"root\");\n            entry.setMode(PermMapper.toMode(\"755\"));\n\n            if (\"control\".equals(name)) {\n                packageDescriptor = new PackageDescriptor(new FileInputStream(file), resolver);\n\n                if (packageDescriptor.get(\"Date\") == null) {\n                    SimpleDateFormat fmt = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss Z\", Locale.ENGLISH); // Mon, 26 Mar 2007 11:44:04 +0200 (RFC 2822)\n                    // FIXME Is this field allowed in package descriptors ?\n                    packageDescriptor.set(\"Date\", fmt.format(new Date()));\n                }\n\n                if (packageDescriptor.get(\"Distribution\") == null) {\n                    packageDescriptor.set(\"Distribution\", \"unknown\");\n                }\n\n                if (packageDescriptor.get(\"Urgency\") == null) {\n                    packageDescriptor.set(\"Urgency\", \"low\");\n                }\n\n                final String debFullName = System.getenv(\"DEBFULLNAME\");\n                final String debEmail = System.getenv(\"DEBEMAIL\");\n\n                if (debFullName != null && debEmail != null) {\n                    packageDescriptor.set(\"Maintainer\", debFullName + \" <\" + debEmail + \">\");\n                    console.println(\"Using maintainer from the environment variables.\");\n                }\n\n                continue;\n            }\n\n            final InputStream inputStream = new FileInputStream(file);\n\n            outputStream.putNextEntry(entry);\n\n            Utils.copy(inputStream, outputStream);\n\n            outputStream.closeEntry();\n\n            inputStream.close();\n\n        }\n\n        if (packageDescriptor == null) {\n            throw new FileNotFoundException(\"No control file in \" + Arrays.toString(pControlFiles));\n        }\n\n        packageDescriptor.set(\"Installed-Size\", pDataSize.divide(BigInteger.valueOf(1024)).toString());\n\n        addEntry(\"control\", packageDescriptor.toString(), outputStream);\n\n        addEntry(\"md5sums\", pChecksums.toString(), outputStream);\n\n        outputStream.close();\n\n        return packageDescriptor;\n    }\n\n    /**\n     * Build the data archive of the deb from the provided DataProducers\n     * @param pData\n     * @param pOutput\n     * @param pChecksums\n     * @param pCompression the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @return\n     * @throws NoSuchAlgorithmException\n     * @throws IOException\n     */\n    BigInteger buildData( final DataProducer[] pData, final File pOutput, final StringBuffer pChecksums, String pCompression ) throws NoSuchAlgorithmException, IOException {\n\n        OutputStream out = new FileOutputStream(pOutput);\n        if (\"gzip\".equals(pCompression)) {\n            out = new GZIPOutputStream(out);\n        } else if (\"bzip2\".equals(pCompression)) {\n            out.write(\"BZ\".getBytes());\n            out = new CBZip2OutputStream(out);\n        }\n\n        final TarOutputStream outputStream = new TarOutputStream(out);\n        outputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n        final MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\n        final Total dataSize = new Total();\n\n        final List addedDirectories = new ArrayList();\n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachDir( String dirname, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                dirname = fixPath(dirname);\n\n                createParentDirectories((new File(dirname)).getParent(), user, uid, group, gid);\n\n                // The directory passed in explicitly by the caller also gets the passed-in mode.  (Unlike\n                // the parent directories for now.  See related comments at \"int mode =\" in\n                // createParentDirectories, including about a possible bug.)\n                createDirectory(dirname, user, uid, group, gid, mode, 0);\n\n                console.println(\"dir: \" + dirname);\n            }\n\n            public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                filename = fixPath(filename);\n\n                createParentDirectories((new File(filename)).getParent(), user, uid, group, gid);\n\n                TarEntry entry = new TarEntry(filename);\n\n                // FIXME: link is in the constructor\n                entry.setUserName(user);\n                entry.setUserId(uid);\n                entry.setGroupName(group);\n                entry.setGroupId(gid);\n                entry.setMode(mode);\n                entry.setSize(size);\n\n                outputStream.putNextEntry(entry);\n\n                dataSize.add(size);\n\n                digest.reset();\n\n                Utils.copy(inputStream, new DigestOutputStream(outputStream, digest));\n\n                final String md5 = Utils.toHex(digest.digest());\n\n                outputStream.closeEntry();\n\n                console.println(\n                        \"file:\" + entry.getName() +\n                        \" size:\" + entry.getSize() +\n                        \" mode:\" + entry.getMode() +\n                        \" linkname:\" + entry.getLinkName() +\n                        \" username:\" + entry.getUserName() +\n                        \" userid:\" + entry.getUserId() +\n                        \" groupname:\" + entry.getGroupName() +\n                        \" groupid:\" + entry.getGroupId() +\n                        \" modtime:\" + entry.getModTime() +\n                        \" md5: \" + md5\n                );\n\n                pChecksums.append(md5).append(\" \").append(entry.getName()).append('\\n');\n\n            }\n\n            private String fixPath(String path) {\n                // If we're receiving directory names from Windows, then we'll convert to use slash\n                // This does eliminate the ability to use of a backslash in a directory name on *NIX, but in practice, this is a non-issue\n                if (path.indexOf('\\\\') > -1) {\n                    path = path.replace('\\\\', '/');\n                }\n                // ensure the path is like : ./foo/bar\n                if (path.startsWith(\"/\")) {\n                    path = \".\" + path;\n                } else if (!path.startsWith(\"./\")) {\n                    path = \"./\" + path;\n                }\n                return path;\n            }\n\n            private void createDirectory(String directory, String user, int uid, String group, int gid, int mode, long size) throws IOException {\n                // All dirs should end with \"/\" when created, or the test DebAndTaskTestCase.testTarFileSet() thinks its a file\n                // and so thinks it has the wrong permission.\n                // This consistency also helps when checking if a directory already exists in addedDirectories.\n\n                if (!directory.endsWith(\"/\")) {\n                    directory += \"/\";\n                }\n\n                if (!addedDirectories.contains(directory)) {\n                    TarEntry entry = new TarEntry(directory);\n                    // FIXME: link is in the constructor\n                    entry.setUserName(user);\n                    entry.setUserId(uid);\n                    entry.setGroupName(group);\n                    entry.setGroupId(gid);\n                    entry.setMode(mode);\n                    entry.setSize(size);\n\n                    outputStream.putNextEntry(entry);\n                    outputStream.closeEntry();\n                    addedDirectories.add(directory); // so addedDirectories consistently have \"/\" for finding duplicates.\n                }\n            }\n\n            private void createParentDirectories(String dirname, String user, int uid, String group, int gid) throws IOException {\n                // Debian packages must have parent directories created\n                // before sub-directories or files can be installed.\n                // For example, if an entry of ./usr/lib/foo/bar existed\n                // in a .deb package, but the ./usr/lib/foo directory didn't\n                // exist, the package installation would fail.  The .deb must\n                // then have an entry for ./usr/lib/foo and then ./usr/lib/foo/bar\n\n                if (dirname == null) {\n                  return;\n                }\n\n                // The loop below will create entries for all parent directories\n                // to ensure that .deb packages will install correctly.\n                String[] pathParts = dirname.split(\"\\\\/\");\n                String parentDir = \"./\";\n                for (int i = 1; i < pathParts.length; i++) {\n                    parentDir += pathParts[i] + \"/\";\n                    // Make it so the dirs can be traversed by users.\n                    // We could instead try something more granular, like setting the directory\n                    // permission to 'rx' for each of the 3 user/group/other read permissions\n                    // found on the file being added (ie, only if \"other\" has read\n                    // permission on the main node, then add o+rx permission on all the containing\n                    // directories, same w/ user & group), and then also we'd have to\n                    // check the parentDirs collection of those already added to\n                    // see if those permissions need to be similarly updated.  (Note, it hasn't\n                    // been demonstrated, but there might be a bug if a user specifically\n                    // requests a directory with certain permissions,\n                    // that has already been auto-created because it was a parent, and if so, go set\n                    // the user-requested mode on that directory instead of this automatic one.)\n                    // But for now, keeping it simple by making every dir a+rx.   Examples are:\n                    // drw-r----- fs/fs   # what you get with setMode(mode)\n                    // drwxr-xr-x fs/fs   # Usable. Too loose?\n                    int mode = TarEntry.DEFAULT_DIR_MODE;\n\n                    createDirectory(parentDir, user, uid, group, gid, mode, 0);\n                }\n            }\n        };\n\n        for (int i = 0; i < pData.length; i++) {\n            final DataProducer data = pData[i];\n            data.produce(receiver);\n        }\n\n        outputStream.close();\n\n        console.println(\"Total size: \" + dataSize);\n\n        return dataSize.count;\n    }\n\n    private static void addEntry( final String pName, final String pContent, final TarOutputStream pOutput ) throws IOException {\n        final byte[] data = pContent.getBytes(\"UTF-8\");\n\n        final TarEntry entry = new TarEntry(\"./\" + pName);\n        entry.setSize(data.length);\n        entry.setNames(\"root\", \"root\");\n\n        pOutput.putNextEntry(entry);\n        pOutput.write(data);\n        pOutput.closeEntry();\n    }\n\n\n}\n","Method after Refactoring":"/*\n * Copyright 2012 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveEntry;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.compress.compressors.CompressorException;\nimport org.apache.commons.compress.compressors.CompressorStreamFactory;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarOutputStream;\nimport org.vafer.jdeb.changes.ChangeSet;\nimport org.vafer.jdeb.changes.ChangesProvider;\nimport org.vafer.jdeb.descriptors.ChangesDescriptor;\nimport org.vafer.jdeb.descriptors.PackageDescriptor;\nimport org.vafer.jdeb.mapping.PermMapper;\nimport org.vafer.jdeb.signing.SigningUtils;\nimport org.vafer.jdeb.utils.InformationOutputStream;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * The processor does the actual work of building the deb related files.\n * It is been used by the ant task and (later) the maven plugin.\n *\n * @author Torsten Curdt <tcurdt@vafer.org>\n */\npublic class Processor {\n\n    private final Console console;\n    private final VariableResolver resolver;\n\n    private static final class Total {\n        private BigInteger count = BigInteger.valueOf(0);\n\n        public void add(long size) {\n            count = count.add(BigInteger.valueOf(size));\n        }\n\n        public String toString() {\n            return \"\" + count;\n        }\n    }\n\n    public Processor( final Console pConsole, final VariableResolver pResolver ) {\n        console = pConsole;\n        resolver = pResolver;\n    }\n\n    private void addTo( final ArArchiveOutputStream pOutput, final String pName, final String pContent ) throws IOException {\n        final byte[] content = pContent.getBytes();\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, content.length));\n        pOutput.write(content);\n        pOutput.closeArchiveEntry();\n    }\n\n    private void addTo( final ArArchiveOutputStream pOutput, final String pName, final File pContent ) throws IOException {\n        pOutput.putArchiveEntry(new ArArchiveEntry(pName, pContent.length()));\n\n        final InputStream input = new FileInputStream(pContent);\n        try {\n            Utils.copy(input, pOutput);\n        } finally {\n            input.close();\n        }\n\n        pOutput.closeArchiveEntry();\n    }\n\n    /**\n     * Create the debian archive with from the provided control files and data producers.\n     *\n     * @param pControlFiles\n     * @param pData\n     * @param pOutput\n     * @param compression the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @return PackageDescriptor\n     * @throws PackagingException\n     */\n    public PackageDescriptor createDeb( final File[] pControlFiles, final DataProducer[] pData, final File pOutput, String compression ) throws PackagingException {\n\n        File tempData = null;\n        File tempControl = null;\n\n        try {\n            tempData = File.createTempFile(\"deb\", \"data\");\n            tempControl = File.createTempFile(\"deb\", \"control\");\n\n            console.println(\"Building data\");\n            final StringBuffer md5s = new StringBuffer();\n            final BigInteger size = buildData(pData, tempData, md5s, compression);\n\n            console.println(\"Building control\");\n            final PackageDescriptor packageDescriptor = buildControl(pControlFiles, size, md5s, tempControl);\n\n            if (!packageDescriptor.isValid()) {\n            \tthrow new PackagingException(\"Control file descriptor keys are invalid \" + packageDescriptor.invalidKeys());\n            }\n\n            pOutput.getParentFile().mkdirs();\n        \n            // pass through stream chain to calculate all the different digests\n            final InformationOutputStream md5output = new InformationOutputStream(new FileOutputStream(pOutput), MessageDigest.getInstance(\"MD5\"));\n            final InformationOutputStream sha1output = new InformationOutputStream(md5output, MessageDigest.getInstance(\"SHA1\"));\n            final InformationOutputStream sha256output = new InformationOutputStream(sha1output, MessageDigest.getInstance(\"SHA-256\"));\n            final ArArchiveOutputStream ar = new ArArchiveOutputStream(sha256output);\n\n            addTo(ar, \"debian-binary\", \"2.0\\n\");\n            addTo(ar, \"control.tar.gz\", tempControl);\n            addTo(ar, \"data.tar\" + getExtension(compression), tempData);\n\n            ar.close();\n\n            // intermediate values\n            packageDescriptor.set(\"MD5\", md5output.getHexDigest());\n            packageDescriptor.set(\"SHA1\", sha1output.getHexDigest());\n            packageDescriptor.set(\"SHA256\", sha256output.getHexDigest());\n            packageDescriptor.set(\"Size\", \"\" + md5output.getSize());\n            packageDescriptor.set(\"File\", pOutput.getName());\n\n            return packageDescriptor;\n\n        } catch(Exception e) {\n            throw new PackagingException(\"Could not create deb package\", e);\n        } finally {\n            if (tempData != null) {\n                if (!tempData.delete()) {\n                    throw new PackagingException(\"Could not delete \" + tempData);\n                }\n            }\n            if (tempControl != null) {\n                if (!tempControl.delete()) {\n                    throw new PackagingException(\"Could not delete \" + tempControl);\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the extension of a file compressed with the specified method.\n     *\n     * @param pCompression the compression method used\n     * @return\n     */\n    private String getExtension( final String pCompression ) {\n        if (\"gzip\".equals(pCompression)) {\n            return \".gz\";\n        } else if (\"bzip2\".equals(pCompression)) {\n            return \".bz2\";\n        } else {\n            return \"\";\n        }\n    }\n\n    /**\n     * Create changes file based on the provided PackageDescriptor.\n     * If pRing, pKey and pPassphrase are provided the changes file will also be signed.\n     * It returns a ChangesDescriptor reflecting the changes\n     * @param pPackageDescriptor\n     * @param pChangesProvider\n     * @param pRing\n     * @param pKey\n     * @param pPassphrase\n     * @param pOutput\n     * @return ChangesDescriptor\n     * @throws IOException\n     * @throws PackagingException \n     */\n    public ChangesDescriptor createChanges( final PackageDescriptor pPackageDescriptor, final ChangesProvider pChangesProvider, final InputStream pRing, final String pKey, final String pPassphrase, final OutputStream pOutput ) throws IOException, PackagingException {\n\n        final ChangeSet[] changeSets = pChangesProvider.getChangesSets();\n        final ChangesDescriptor changesDescriptor = new ChangesDescriptor(pPackageDescriptor, changeSets);\n\n        changesDescriptor.set(\"Format\", \"1.8\");\n\n        if (changesDescriptor.get(\"Binary\") == null) {\n            changesDescriptor.set(\"Binary\", changesDescriptor.get(\"Package\"));\n        }\n\n        if (changesDescriptor.get(\"Source\") == null) {\n            changesDescriptor.set(\"Source\", changesDescriptor.get(\"Package\"));\n        }\n\n        if (changesDescriptor.get(\"Description\") == null) {\n            changesDescriptor.set(\"Description\", \"update to \" + changesDescriptor.get(\"Version\"));\n        }\n\n        final StringBuilder checksumsSha1 = new StringBuilder(\"\\n\");\n        // Checksums-Sha1:\n        // 56ef4c6249dc3567fd2967f809c42d1f9b61adf7 45964 jdeb.deb\n        checksumsSha1.append(' ').append(changesDescriptor.get(\"SHA1\"));\n        checksumsSha1.append(' ').append(changesDescriptor.get(\"Size\"));\n        checksumsSha1.append(' ').append(changesDescriptor.get(\"File\"));\n        changesDescriptor.set(\"Checksums-Sha1\", checksumsSha1.toString());\n\n        final StringBuilder checksumsSha256 = new StringBuilder(\"\\n\");\n        // Checksums-Sha256:\n        // 38c6fa274eb9299a69b739bcbdbd05c7ffd1d8d6472f4245ed732a25c0e5d616 45964 jdeb.deb\n        checksumsSha256.append(' ').append(changesDescriptor.get(\"SHA256\"));\n        checksumsSha256.append(' ').append(changesDescriptor.get(\"Size\"));\n        checksumsSha256.append(' ').append(changesDescriptor.get(\"File\"));\n        changesDescriptor.set(\"Checksums-Sha256\", checksumsSha256.toString());\n\n\n        final StringBuffer files = new StringBuffer(\"\\n\");\n        files.append(' ').append(changesDescriptor.get(\"MD5\"));\n        files.append(' ').append(changesDescriptor.get(\"Size\"));\n        files.append(' ').append(changesDescriptor.get(\"Section\"));\n        files.append(' ').append(changesDescriptor.get(\"Priority\"));\n        files.append(' ').append(changesDescriptor.get(\"File\"));\n        changesDescriptor.set(\"Files\", files.toString());\n\n        if (!changesDescriptor.isValid()) {\n        \tthrow new PackagingException(\"Changes file descriptor keys are invalid \" + changesDescriptor.invalidKeys());\n        }\n\n        final String changes = changesDescriptor.toString();\n        //console.println(changes);\n\n        final byte[] changesBytes = changes.getBytes(\"UTF-8\");\n\n        if (pRing == null || pKey == null || pPassphrase == null) {\n            pOutput.write(changesBytes);\n            pOutput.close();\n            return changesDescriptor;\n        }\n\n        console.println(\"Signing changes with key \" + pKey);\n\n        final InputStream input = new ByteArrayInputStream(changesBytes);\n\n        try {\n            SigningUtils.clearSign(input, pRing, pKey, pPassphrase, pOutput);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        pOutput.close();\n\n        return changesDescriptor;\n    }\n\n    /**\n     * Build control archive of the deb\n     * @param pControlFiles\n     * @param pDataSize\n     * @param pChecksums\n     * @param pOutput\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     * @throws ParseException\n     */\n    private PackageDescriptor buildControl( final File[] pControlFiles, final BigInteger pDataSize, final StringBuffer pChecksums, final File pOutput ) throws IOException, ParseException {\n\n    \tif (!pOutput.canWrite()) {\n    \t\tthrow new IOException(\"Cannot write control file at '\" + pOutput + \"'\");\n    \t}\n\n        final TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(pOutput)));\n        outputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n        // create a descriptor out of the \"control\" file, copy all other files, ignore directories\n        PackageDescriptor packageDescriptor = null;\n        for (int i = 0; i < pControlFiles.length; i++) {\n            final File file = pControlFiles[i];\n\n            if (file.isDirectory()) {\n                console.println(\"Found directory '\" + file + \"' in the control directory. Maybe you are pointing to wrong dir?\");\n                continue;\n            }\n\n            final TarEntry entry = new TarEntry(file);\n            final String name = file.getName();\n\n            entry.setName(\"./\" + name);\n            entry.setNames(\"root\", \"root\");\n            entry.setMode(PermMapper.toMode(\"755\"));\n\n            if (\"control\".equals(name)) {\n\n            \tpackageDescriptor = new PackageDescriptor(new FileInputStream(file), resolver);\n\n                if (packageDescriptor.get(\"Date\") == null) {\n                    // Mon, 26 Mar 2007 11:44:04 +0200 (RFC 2822)\n                    SimpleDateFormat fmt = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss Z\", Locale.ENGLISH);\n                    packageDescriptor.set(\"Date\", fmt.format(new Date()));\n                }\n\n                if (packageDescriptor.get(\"Distribution\") == null) {\n                    packageDescriptor.set(\"Distribution\", \"unknown\");\n                }\n\n                if (packageDescriptor.get(\"Urgency\") == null) {\n                    packageDescriptor.set(\"Urgency\", \"low\");\n                }\n\n                packageDescriptor.set(\"Installed-Size\", pDataSize.divide(BigInteger.valueOf(1024)).toString());\n\n                final String debFullName = System.getenv(\"DEBFULLNAME\");\n                final String debEmail = System.getenv(\"DEBEMAIL\");\n\n                if (debFullName != null && debEmail != null) {\n                \tfinal String maintainer = debFullName + \" <\" + debEmail + \">\";\n                    packageDescriptor.set(\"Maintainer\", maintainer);\n                    console.println(\"Using maintainer '\" + maintainer + \"' from the environment variables.\");\n                }\n\n            } else {\n\n\t            final InputStream inputStream = new FileInputStream(file);\n\n\t            // copy file as new entry into the archive stream\n\t            outputStream.putNextEntry(entry);\n\t            Utils.copy(inputStream, outputStream);\n\t            outputStream.closeEntry();\n\n\t            inputStream.close();\n            }\n        }\n\n        if (packageDescriptor == null) {\n            throw new FileNotFoundException(\"No 'control' found in \" + Arrays.toString(pControlFiles));\n        }\n\n        addEntry(\"control\", packageDescriptor.toString(), outputStream);\n        addEntry(\"md5sums\", pChecksums.toString(), outputStream);\n\n        outputStream.close();\n\n        return packageDescriptor;\n    }\n\n    \n    // FIXME tempory - only until Commons Compress is fixed\n    private OutputStream compressedOutputStream( String pCompression, final OutputStream outputStream) throws CompressorException {\n    \tif (\"none\".equalsIgnoreCase(pCompression)) {\n    \t\treturn outputStream;\n    \t}\n        if (\"gzip\".equals(pCompression)) {\n        \tpCompression = \"gz\";\n        }\n        return new CompressorStreamFactory().createCompressorOutputStream(pCompression, outputStream);\n    }\n\n    /**\n     * Build the data archive of the deb from the provided DataProducers\n     * @param pData\n     * @param pOutput\n     * @param pChecksums\n     * @param pCompression the compression method used for the data file (gzip, bzip2 or anything else for no compression)\n     * @return\n     * @throws NoSuchAlgorithmException\n     * @throws IOException\n     * @throws CompressorException \n     */\n    BigInteger buildData( final DataProducer[] pData, final File pOutput, final StringBuffer pChecksums, String pCompression ) throws NoSuchAlgorithmException, IOException, CompressorException {\n\n    \tif (!pOutput.canWrite()) {\n    \t\tthrow new IOException(\"Cannot write data file at '\" + pOutput + \"'\");\n    \t}\n\n    \tfinal OutputStream fileOutputStream = new FileOutputStream(pOutput);\n    \tfinal OutputStream compressedOutputStream = compressedOutputStream(pCompression, fileOutputStream);\n        final TarOutputStream tarOutputStream = new TarOutputStream(compressedOutputStream);\n        tarOutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n        final MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\n        final Total dataSize = new Total();\n\n        final List addedDirectories = new ArrayList();\n        final DataConsumer receiver = new DataConsumer() {\n            public void onEachDir( String dirname, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                dirname = fixPath(dirname);\n\n                createParentDirectories((new File(dirname)).getParent(), user, uid, group, gid);\n\n                // The directory passed in explicitly by the caller also gets the passed-in mode.  (Unlike\n                // the parent directories for now.  See related comments at \"int mode =\" in\n                // createParentDirectories, including about a possible bug.)\n                createDirectory(dirname, user, uid, group, gid, mode, 0);\n\n                console.println(\"dir: \" + dirname);\n            }\n\n            public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n                filename = fixPath(filename);\n\n                createParentDirectories((new File(filename)).getParent(), user, uid, group, gid);\n\n                final TarEntry entry = new TarEntry(filename);\n\n                // FIXME: link is in the constructor\n                entry.setUserName(user);\n                entry.setUserId(uid);\n                entry.setGroupName(group);\n                entry.setGroupId(gid);\n                entry.setMode(mode);\n                entry.setSize(size);\n\n                tarOutputStream.putNextEntry(entry);\n\n                dataSize.add(size);\n                digest.reset();\n\n                Utils.copy(inputStream, new DigestOutputStream(tarOutputStream, digest));\n\n                final String md5 = Utils.toHex(digest.digest());\n\n                tarOutputStream.closeEntry();\n\n                console.println(\n                        \"file:\" + entry.getName() +\n                        \" size:\" + entry.getSize() +\n                        \" mode:\" + entry.getMode() +\n                        \" linkname:\" + entry.getLinkName() +\n                        \" username:\" + entry.getUserName() +\n                        \" userid:\" + entry.getUserId() +\n                        \" groupname:\" + entry.getGroupName() +\n                        \" groupid:\" + entry.getGroupId() +\n                        \" modtime:\" + entry.getModTime() +\n                        \" md5: \" + md5\n                );\n\n                // append to file md5 list\n                pChecksums.append(md5).append(\" \").append(entry.getName()).append('\\n');\n            }\n\n            private String fixPath(String path) {\n                // If we're receiving directory names from Windows, then we'll convert to use slash\n                // This does eliminate the ability to use of a backslash in a directory name on *NIX,\n            \t// but in practice, this is a non-issue\n                if (path.indexOf('\\\\') > -1) {\n                    path = path.replace('\\\\', '/');\n                }\n                // ensure the path is like : ./foo/bar\n                if (path.startsWith(\"/\")) {\n                    path = \".\" + path;\n                } else if (!path.startsWith(\"./\")) {\n                    path = \"./\" + path;\n                }\n                return path;\n            }\n\n            private void createDirectory(String directory, String user, int uid, String group, int gid, int mode, long size) throws IOException {\n                // All dirs should end with \"/\" when created, or the test DebAndTaskTestCase.testTarFileSet() thinks its a file\n                // and so thinks it has the wrong permission.\n                // This consistency also helps when checking if a directory already exists in addedDirectories.\n\n                if (!directory.endsWith(\"/\")) {\n                    directory += \"/\";\n                }\n\n                if (!addedDirectories.contains(directory)) {\n                    TarEntry entry = new TarEntry(directory);\n                    entry.setUserName(user);\n                    entry.setUserId(uid);\n                    entry.setGroupName(group);\n                    entry.setGroupId(gid);\n                    entry.setMode(mode);\n                    entry.setSize(size);\n\n                    tarOutputStream.putNextEntry(entry);\n                    tarOutputStream.closeEntry();\n                    addedDirectories.add(directory); // so addedDirectories consistently have \"/\" for finding duplicates.\n                }\n            }\n\n            private void createParentDirectories(String dirname, String user, int uid, String group, int gid) throws IOException {\n                // Debian packages must have parent directories created\n                // before sub-directories or files can be installed.\n                // For example, if an entry of ./usr/lib/foo/bar existed\n                // in a .deb package, but the ./usr/lib/foo directory didn't\n                // exist, the package installation would fail.  The .deb must\n                // then have an entry for ./usr/lib/foo and then ./usr/lib/foo/bar\n\n                if (dirname == null) {\n                  return;\n                }\n\n                // The loop below will create entries for all parent directories\n                // to ensure that .deb packages will install correctly.\n                String[] pathParts = dirname.split(\"\\\\/\");\n                String parentDir = \"./\";\n                for (int i = 1; i < pathParts.length; i++) {\n                    parentDir += pathParts[i] + \"/\";\n                    // Make it so the dirs can be traversed by users.\n                    // We could instead try something more granular, like setting the directory\n                    // permission to 'rx' for each of the 3 user/group/other read permissions\n                    // found on the file being added (ie, only if \"other\" has read\n                    // permission on the main node, then add o+rx permission on all the containing\n                    // directories, same w/ user & group), and then also we'd have to\n                    // check the parentDirs collection of those already added to\n                    // see if those permissions need to be similarly updated.  (Note, it hasn't\n                    // been demonstrated, but there might be a bug if a user specifically\n                    // requests a directory with certain permissions,\n                    // that has already been auto-created because it was a parent, and if so, go set\n                    // the user-requested mode on that directory instead of this automatic one.)\n                    // But for now, keeping it simple by making every dir a+rx.   Examples are:\n                    // drw-r----- fs/fs   # what you get with setMode(mode)\n                    // drwxr-xr-x fs/fs   # Usable. Too loose?\n                    int mode = TarEntry.DEFAULT_DIR_MODE;\n\n                    createDirectory(parentDir, user, uid, group, gid, mode, 0);\n                }\n            }\n        };\n\n        for (int i = 0; i < pData.length; i++) {\n            final DataProducer data = pData[i];\n            data.produce(receiver);\n        }\n\n        tarOutputStream.close();\n\n        console.println(\"Total size: \" + dataSize);\n\n        return dataSize.count;\n    }\n\n    private static void addEntry( final String pName, final String pContent, final TarOutputStream pOutput ) throws IOException {\n        final byte[] data = pContent.getBytes(\"UTF-8\");\n\n        final TarEntry entry = new TarEntry(\"./\" + pName);\n        entry.setSize(data.length);\n        entry.setNames(\"root\", \"root\");\n\n        pOutput.putNextEntry(entry);\n        pOutput.write(data);\n        pOutput.closeEntry();\n    }\n}\n","lineNo":337}
{"Smelly Sample":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.zip.GZIPInputStream;\n\nimport junit.framework.TestCase;\n\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.vafer.jdeb.ar.ArEntry;\nimport org.vafer.jdeb.ar.ArInputStream;\nimport org.vafer.jdeb.descriptors.PackageDescriptor;\nimport org.vafer.jdeb.producers.DataProducerArchive;\nimport org.vafer.jdeb.producers.DataProducerDirectory;\n\npublic final class DataProducerTestCase extends TestCase {\n\n\tpublic void testCreation() throws Exception {\n\n\t\tfinal Processor processor = new Processor(new Console() {\n\t\t\tpublic void println(String s) {\n\t\t\t}\n\t\t}, null);\n\t\t\n\t\tfinal File control = new File(getClass().getResource(\"deb/control/control\").toURI());\n\t\tfinal File archive1 = new File(getClass().getResource(\"deb/data.tgz\").toURI());\n\t\tfinal File archive2 = new File(getClass().getResource(\"deb/data.tar.bz2\").toURI());\n\t\tfinal File directory = new File(getClass().getResource(\"deb/data\").toURI());\n\t\t\n\t\tfinal DataProducer[] data = new DataProducer[] {\n\t\t\t\tnew DataProducerArchive(archive1, null, null, null),\n\t\t\t\tnew DataProducerArchive(archive2, null, null, null),\n\t\t\t\tnew DataProducerDirectory(directory, null, new String[] { \"**/.svn/**\" }, null)\n\t\t};\n\t\t\n\t\tfinal File deb = File.createTempFile(\"jdeb\", \".deb\");\n\t\t\n\t\tfinal PackageDescriptor packageDescriptor = processor.createDeb(new File[] { control }, data, deb, \"gzip\");\n\t\t\n\t\tassertTrue(packageDescriptor.isValid());\n\t\t\n\t\tfinal Set filesInDeb = new HashSet();\n\t\t\n\t\tfinal ArInputStream ar = new ArInputStream(new FileInputStream(deb));\n\t\twhile(true) {\n\t\t\tfinal ArEntry arEntry = ar.getNextEntry();\n\t\t\tif (arEntry == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (\"data.tar.gz\".equals(arEntry.getName())) {\n\t\t\t\t\n\t\t\t\tfinal TarInputStream tar = new TarInputStream(new GZIPInputStream(ar));\n\t\t\t\t\n\t\t\t\twhile(true) {\n\t\t\t\t\tfinal TarEntry tarEntry = tar.getNextEntry();\n\t\t\t\t\tif (tarEntry == null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfilesInDeb.add(tarEntry.getName());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttar.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < arEntry.getLength(); i++) {\n\t\t\t\tar.read();\n\t\t\t}\n\t\t}\n\t\t\n\t\tassertTrue(\"\" + filesInDeb, filesInDeb.contains(\"/test/testfile\"));\n\t\tassertTrue(\"\" + filesInDeb, filesInDeb.contains(\"/test/testfile2\"));\n\t\tassertTrue(\"\" + filesInDeb, filesInDeb.contains(\"/test/testfile3\"));\n\n\t\tassertTrue(deb.delete());\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.zip.GZIPInputStream;\n\nimport junit.framework.TestCase;\n\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.vafer.jdeb.ar.ArEntry;\nimport org.vafer.jdeb.ar.ArInputStream;\nimport org.vafer.jdeb.descriptors.PackageDescriptor;\nimport org.vafer.jdeb.producers.DataProducerArchive;\nimport org.vafer.jdeb.producers.DataProducerDirectory;\n\npublic final class DataProducerTestCase extends TestCase {\n\n\tpublic void testCreation() throws Exception {\n\n\t\tfinal Processor processor = new Processor(new Console() {\n\t\t\tpublic void println(String s) {\n\t\t\t}\n\t\t}, null);\n\t\t\n\t\tfinal File control = new File(getClass().getResource(\"deb/control/control\").toURI());\n\t\tfinal File archive1 = new File(getClass().getResource(\"deb/data.tgz\").toURI());\n\t\tfinal File archive2 = new File(getClass().getResource(\"deb/data.tar.bz2\").toURI());\n\t\tfinal File directory = new File(getClass().getResource(\"deb/data\").toURI());\n\t\t\n\t\tfinal DataProducer[] data = new DataProducer[] {\n\t\t\t\tnew DataProducerArchive(archive1, null, null, null),\n\t\t\t\tnew DataProducerArchive(archive2, null, null, null),\n\t\t\t\tnew DataProducerDirectory(directory, null, new String[] { \"**/.svn/**\" }, null)\n\t\t};\n\t\t\n\t\tfinal File deb = File.createTempFile(\"jdeb\", \".deb\");\n\t\t\n\t\tfinal PackageDescriptor packageDescriptor = processor.createDeb(new File[] { control }, data, deb, \"gzip\");\n\t\t\n\t\tassertTrue(packageDescriptor.isValid());\n\t\t\n\t\tfinal Set filesInDeb = new HashSet();\n\n\t\tFileInputStream in = new FileInputStream(deb);\n\t\tfinal ArInputStream ar = new ArInputStream(in);\n\t\twhile(true) {\n\t\t\tfinal ArEntry arEntry = ar.getNextEntry();\n\t\t\tif (arEntry == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (\"data.tar.gz\".equals(arEntry.getName())) {\n\t\t\t\t\n\t\t\t\tfinal TarInputStream tar = new TarInputStream(new GZIPInputStream(ar));\n\t\t\t\t\n\t\t\t\twhile(true) {\n\t\t\t\t\tfinal TarEntry tarEntry = tar.getNextEntry();\n\t\t\t\t\tif (tarEntry == null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfilesInDeb.add(tarEntry.getName());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttar.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < arEntry.getLength(); i++) {\n\t\t\t\tar.read();\n\t\t\t}\n\t\t}\n\n\t\tin.close();\n\t\t\n\t\tassertTrue(\"\" + filesInDeb, filesInDeb.contains(\"/test/testfile\"));\n\t\tassertTrue(\"\" + filesInDeb, filesInDeb.contains(\"/test/testfile2\"));\n\t\tassertTrue(\"\" + filesInDeb, filesInDeb.contains(\"/test/testfile3\"));\n\n\t\tassertTrue(\"Cannot delete the file \" + deb, deb.delete());\n\t}\n}\n","lineNo":62}
{"Smelly Sample":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.mapping.Mapper;\nimport org.vafer.jdeb.utils.Utils;\n\n/**\n * DataProducer iterating over a directory.\n * For cross-platform permissions and ownerships you probably want to use a Mapper, too. \n * \n * @author tcurdt\n */\npublic final class DataProducerDirectory extends AbstractDataProducer implements DataProducer {\n\n\tprivate final DirectoryScanner scanner = new DirectoryScanner();\n\t\n\tpublic DataProducerDirectory( final File pDir, final String[] pIncludes, final String[] pExcludes, final Mapper[] pMappers ) {\n\t\tsuper(pIncludes, pExcludes, pMappers);\n\t\tscanner.setBasedir(pDir);\n\t\tscanner.setIncludes(pIncludes);\n\t\tscanner.setExcludes(pExcludes);\n\t\tscanner.setCaseSensitive(true);\n\t\tscanner.setFollowSymlinks(true);\n\t}\n\t\n\tpublic void produce( final DataConsumer receiver ) throws IOException {\n\n\t\tscanner.scan();\n\n\t\tfinal File baseDir = scanner.getBasedir();\n\n\t\tfinal String[] dirs = scanner.getIncludedDirectories();\n\t\tfor (int i = 0; i < dirs.length; i++) {\n\t\t\tfinal File file = new File(baseDir, dirs[i]);\n\t\t\tString dirname = getFilename(baseDir, file);\n\n\t\t\tif (\"\".equals(dirname)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!isIncluded(dirname)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ('/' != File.separatorChar) {\n\t\t\t\tdirname = dirname.replace(File.separatorChar, '/');\n\t\t\t}\n\n\t\t\tTarEntry entry = new TarEntry(dirname);\n\t\t\tentry.setUserId(0);\n\t\t\tentry.setUserName(\"root\");\n\t\t\tentry.setGroupId(0);\n\t\t\tentry.setGroupName(\"root\");\n\t\t\tentry.setMode(TarEntry.DEFAULT_DIR_MODE);\n\n\t\t\tentry = map(entry);\n\n\t\t\tentry.setSize(0);\n\n\t\t\treceiver.onEachDir(entry.getName(), entry.getLinkName(), entry.getUserName(), entry.getUserId(), entry.getGroupName(), entry.getGroupId(), entry.getMode(), entry.getSize());\n\t\t}\n\n\n\t\tfinal String[] files = scanner.getIncludedFiles();\n\n\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\tfinal File file = new File(baseDir, files[i]);\n\t\t\tString filename = getFilename(baseDir, file);\n\n\t\t\tif (!isIncluded(filename)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ('/' != File.separatorChar) {\n\t\t\t\tfilename = filename.replace(File.separatorChar, '/');\n\t\t\t}\n\n\t\t\tTarEntry entry = new TarEntry(filename);\n\t\t\tentry.setUserId(0);\n\t\t\tentry.setUserName(\"root\");\n\t\t\tentry.setGroupId(0);\n\t\t\tentry.setGroupName(\"root\");\n\t\t\tentry.setMode(TarEntry.DEFAULT_FILE_MODE);\n\n\t\t\tentry = map(entry);\n\n\t\t\tentry.setSize(file.length());\n\n\t\t\treceiver.onEachFile(new FileInputStream(file), entry.getName(), entry.getLinkName(), entry.getUserName(), entry.getUserId(), entry.getGroupName(), entry.getGroupId(), entry.getMode(), entry.getSize());\n\t\t}\n\t}\n\n\tprivate String getFilename( File root, File file ) {\n\t\t\n\t\tfinal String relativeFilename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\t\t\n\t\t\n\t\treturn Utils.stripLeadingSlash(relativeFilename);\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.mapping.Mapper;\nimport org.vafer.jdeb.utils.Utils;\n\n/**\n * DataProducer iterating over a directory.\n * For cross-platform permissions and ownerships you probably want to use a Mapper, too. \n * \n * @author Torsten Curdt <tcurdt@vafer.org>\n */\npublic final class DataProducerDirectory extends AbstractDataProducer implements DataProducer {\n\n\tprivate final DirectoryScanner scanner = new DirectoryScanner();\n\t\n\tpublic DataProducerDirectory( final File pDir, final String[] pIncludes, final String[] pExcludes, final Mapper[] pMappers ) {\n\t\tsuper(pIncludes, pExcludes, pMappers);\n\t\tscanner.setBasedir(pDir);\n\t\tscanner.setIncludes(pIncludes);\n\t\tscanner.setExcludes(pExcludes);\n\t\tscanner.setCaseSensitive(true);\n\t\tscanner.setFollowSymlinks(true);\n\t}\n\t\n\tpublic void produce( final DataConsumer receiver ) throws IOException {\n\n\t\tscanner.scan();\n\n\t\tfinal File baseDir = scanner.getBasedir();\n\n\t\tfinal String[] dirs = scanner.getIncludedDirectories();\n\t\tfor (int i = 0; i < dirs.length; i++) {\n\t\t\tfinal File file = new File(baseDir, dirs[i]);\n\t\t\tString dirname = getFilename(baseDir, file);\n\n\t\t\tif (\"\".equals(dirname)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!isIncluded(dirname)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ('/' != File.separatorChar) {\n\t\t\t\tdirname = dirname.replace(File.separatorChar, '/');\n\t\t\t}\n\n\t\t\tTarEntry entry = new TarEntry(dirname);\n\t\t\tentry.setUserId(0);\n\t\t\tentry.setUserName(\"root\");\n\t\t\tentry.setGroupId(0);\n\t\t\tentry.setGroupName(\"root\");\n\t\t\tentry.setMode(TarEntry.DEFAULT_DIR_MODE);\n\n\t\t\tentry = map(entry);\n\n\t\t\tentry.setSize(0);\n\n\t\t\treceiver.onEachDir(entry.getName(), entry.getLinkName(), entry.getUserName(), entry.getUserId(), entry.getGroupName(), entry.getGroupId(), entry.getMode(), entry.getSize());\n\t\t}\n\n\n\t\tfinal String[] files = scanner.getIncludedFiles();\n\n\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\tfinal File file = new File(baseDir, files[i]);\n\t\t\tString filename = getFilename(baseDir, file);\n\n\t\t\tif (!isIncluded(filename)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ('/' != File.separatorChar) {\n\t\t\t\tfilename = filename.replace(File.separatorChar, '/');\n\t\t\t}\n\n\t\t\tTarEntry entry = new TarEntry(filename);\n\t\t\tentry.setUserId(0);\n\t\t\tentry.setUserName(\"root\");\n\t\t\tentry.setGroupId(0);\n\t\t\tentry.setGroupName(\"root\");\n\t\t\tentry.setMode(TarEntry.DEFAULT_FILE_MODE);\n\n\t\t\tentry = map(entry);\n\n\t\t\tentry.setSize(file.length());\n\n\t\t\tfinal InputStream inputStream = new FileInputStream(file);\n\t\t\ttry {\n\t\t\t\treceiver.onEachFile(inputStream, entry.getName(), entry.getLinkName(), entry.getUserName(), entry.getUserId(), entry.getGroupName(), entry.getGroupId(), entry.getMode(), entry.getSize());\n\t\t\t} finally {\n\t\t\t\tinputStream.close();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String getFilename( File root, File file ) {\n\t\t\n\t\tfinal String relativeFilename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\t\t\n\t\t\n\t\treturn Utils.stripLeadingSlash(relativeFilename);\n\t}\n\n}\n","lineNo":112}
{"Smelly Sample":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.signing;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\n\nimport junit.framework.TestCase;\n\npublic final class SigningTestCase extends TestCase {\n\n\tpublic void testClearSign() throws Exception {\n\t\t\n\t\tfinal InputStream ring = getClass().getClassLoader().getResourceAsStream(\"org/vafer/gpg/secring.gpg\");\n\t\t\n\t\tassertNotNull(ring);\n\t\t\n\t\tfinal byte[] input = \"TEST1\\nTEST2\\nTEST3\\n\".getBytes(\"UTF-8\");\n\t\tfinal byte[] expectedOutput = ( \n\t\t\t\"-----BEGIN PGP SIGNED MESSAGE-----\\n\" + \n\t\t\t\"Hash: SHA1\\n\" + \n\t\t\t\"\\n\" + \n\t\t\t\"TEST1\\r\\n\" + \n\t\t\t\"TEST2\\r\\n\" + \n\t\t\t\"TEST3\\r\\n\" + \n\t\t\t\"-----BEGIN PGP SIGNATURE-----\\n\" + \n\t\t\t\"Version: BCPG v1.29\\n\" + \n\t\t\t\"\\n\" + \n\t\t\t\"iEYEARECABAFAkax1rgJEHM9pIAuB02PAABIJgCghFmoCJCZ0CGiqgVLGGPd/Yh5\\n\" + \n\t\t\t\"FQQAnRVqvI2ij45JQSHYJBblZ0Vv2meN\\n\" + \n\t\t\t\"=aAAT\\n\" + \n\t\t\t\"-----END PGP SIGNATURE-----\\n\" + \n\t\t\t\"\" ).getBytes(\"UTF-8\");\n\t\t\n\t\tfinal ByteArrayOutputStream os = new ByteArrayOutputStream();\n\n\t\tSigningUtils.clearSign(\n\t\t\t\tnew ByteArrayInputStream(input),\n\t\t\t\tring,\n\t\t\t\t\"2E074D8F\", \"test\",\n\t\t\t\tos);\n\t\t\n\t\tfinal byte[] output = os.toByteArray(); \n\t\t\n\t\tassertEquals(new String(expectedOutput), new String(output));\t\t\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.signing;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.Arrays;\n\nimport junit.framework.TestCase;\n\npublic final class SigningTestCase extends TestCase {\n\n\tpublic void testClearSign() throws Exception {\n\t\t\n\t\tfinal InputStream ring = getClass().getClassLoader().getResourceAsStream(\"org/vafer/gpg/secring.gpg\");\n\t\t\n\t\tassertNotNull(ring);\n\t\t\n\t\tfinal String inputStr = \"TEST1\\nTEST2\\nTEST3\\n\"; \n\t\tfinal byte[] input = inputStr.getBytes(\"UTF-8\");\n\t\t\n\t\tfinal String expectedOutputStr = \n\t\t\t\"-----BEGIN PGP SIGNED MESSAGE-----\\n\" + \n\t\t\t\"Hash: SHA1\\n\" + \n\t\t\t\"\\n\" + \n\t\t\t\"TEST1\\r\\n\" + \n\t\t\t\"TEST2\\r\\n\" + \n\t\t\t\"TEST3\\r\\n\" + \n\t\t\t\"-----BEGIN PGP SIGNATURE-----\\n\" + \n\t\t\t\"Version: BCPG v1.29\\n\" + \n\t\t\t\"\\n\" + \n\t\t\t\"iEYEARECABAFAkax1rgJEHM9pIAuB02PAABIJgCghFmoCJCZ0CGiqgVLGGPd/Yh5\\n\" + \n\t\t\t\"FQQAnRVqvI2ij45JQSHYJBblZ0Vv2meN\\n\" + \n\t\t\t\"=aAAT\\n\" + \n\t\t\t\"-----END PGP SIGNATURE-----\\n\";\n\t\t\n\t\tfinal byte[] expectedOutput = expectedOutputStr.getBytes(\"UTF-8\"); \n\n\t\tfinal ByteArrayOutputStream os = new ByteArrayOutputStream();\n\n\t\tSigningUtils.clearSign(\n\t\t\t\tnew ByteArrayInputStream(input),\n\t\t\t\tring,\n\t\t\t\t\"2E074D8F\", \"test\",\n\t\t\t\tos);\n\t\t\n\t\tfinal byte[] output = os.toByteArray();\n\t\t\n\t\tfinal int from = expectedOutputStr.indexOf(\"iEYEAREC\");\n\t\tfinal int until = expectedOutputStr.indexOf(\"=aAAT\") + 5;\n\t\tArrays.fill(output, from, until, (byte)'?');\n\t\tArrays.fill(expectedOutput, from, until, (byte)'?');\n\n\t\tassertEquals(new String(expectedOutput), new String(output));\n\t}\n}\n","lineNo":33}
{"Smelly Sample":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.signing;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\n\nimport junit.framework.TestCase;\n\npublic final class SigningTestCase extends TestCase {\n\n\tpublic void testClearSign() throws Exception {\n\t\t\n\t\tfinal InputStream ring = getClass().getClassLoader().getResourceAsStream(\"org/vafer/gpg/secring.gpg\");\n\t\t\n\t\tassertNotNull(ring);\n\t\t\n\t\tfinal byte[] input = \"TEST1\\nTEST2\\nTEST3\\n\".getBytes(\"UTF-8\");\n\t\tfinal byte[] expectedOutput = ( \n\t\t\t\"-----BEGIN PGP SIGNED MESSAGE-----\\n\" + \n\t\t\t\"Hash: SHA1\\n\" + \n\t\t\t\"\\n\" + \n\t\t\t\"TEST1\\r\\n\" + \n\t\t\t\"TEST2\\r\\n\" + \n\t\t\t\"TEST3\\r\\n\" + \n\t\t\t\"-----BEGIN PGP SIGNATURE-----\\n\" + \n\t\t\t\"Version: BCPG v1.29\\n\" + \n\t\t\t\"\\n\" + \n\t\t\t\"iEYEARECABAFAkax1rgJEHM9pIAuB02PAABIJgCghFmoCJCZ0CGiqgVLGGPd/Yh5\\n\" + \n\t\t\t\"FQQAnRVqvI2ij45JQSHYJBblZ0Vv2meN\\n\" + \n\t\t\t\"=aAAT\\n\" + \n\t\t\t\"-----END PGP SIGNATURE-----\\n\" + \n\t\t\t\"\" ).getBytes(\"UTF-8\");\n\t\t\n\t\tfinal ByteArrayOutputStream os = new ByteArrayOutputStream();\n\n\t\tSigningUtils.clearSign(\n\t\t\t\tnew ByteArrayInputStream(input),\n\t\t\t\tring,\n\t\t\t\t\"2E074D8F\", \"test\",\n\t\t\t\tos);\n\t\t\n\t\tfinal byte[] output = os.toByteArray(); \n\t\t\n\t\tassertEquals(new String(expectedOutput), new String(output));\t\t\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.signing;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.Arrays;\n\nimport junit.framework.TestCase;\n\npublic final class SigningTestCase extends TestCase {\n\n\tpublic void testClearSign() throws Exception {\n\t\t\n\t\tfinal InputStream ring = getClass().getClassLoader().getResourceAsStream(\"org/vafer/gpg/secring.gpg\");\n\t\t\n\t\tassertNotNull(ring);\n\t\t\n\t\tfinal String inputStr = \"TEST1\\nTEST2\\nTEST3\\n\"; \n\t\tfinal byte[] input = inputStr.getBytes(\"UTF-8\");\n\t\t\n\t\tfinal String expectedOutputStr = \n\t\t\t\"-----BEGIN PGP SIGNED MESSAGE-----\\n\" + \n\t\t\t\"Hash: SHA1\\n\" + \n\t\t\t\"\\n\" + \n\t\t\t\"TEST1\\r\\n\" + \n\t\t\t\"TEST2\\r\\n\" + \n\t\t\t\"TEST3\\r\\n\" + \n\t\t\t\"-----BEGIN PGP SIGNATURE-----\\n\" + \n\t\t\t\"Version: BCPG v1.29\\n\" + \n\t\t\t\"\\n\" + \n\t\t\t\"iEYEARECABAFAkax1rgJEHM9pIAuB02PAABIJgCghFmoCJCZ0CGiqgVLGGPd/Yh5\\n\" + \n\t\t\t\"FQQAnRVqvI2ij45JQSHYJBblZ0Vv2meN\\n\" + \n\t\t\t\"=aAAT\\n\" + \n\t\t\t\"-----END PGP SIGNATURE-----\\n\";\n\t\t\n\t\tfinal byte[] expectedOutput = expectedOutputStr.getBytes(\"UTF-8\"); \n\n\t\tfinal ByteArrayOutputStream os = new ByteArrayOutputStream();\n\n\t\tSigningUtils.clearSign(\n\t\t\t\tnew ByteArrayInputStream(input),\n\t\t\t\tring,\n\t\t\t\t\"2E074D8F\", \"test\",\n\t\t\t\tos);\n\t\t\n\t\tfinal byte[] output = os.toByteArray();\n\t\t\n\t\tfinal int from = expectedOutputStr.indexOf(\"iEYEAREC\");\n\t\tfinal int until = expectedOutputStr.indexOf(\"=aAAT\") + 5;\n\t\tArrays.fill(output, from, until, (byte)'?');\n\t\tArrays.fill(expectedOutput, from, until, (byte)'?');\n\n\t\tassertEquals(new String(expectedOutput), new String(output));\n\t}\n}\n","lineNo":36}
{"Smelly Sample":"/*\n * Copyright 2008 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.ant;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.zip.GZIPInputStream;\n\nimport junit.framework.TestCase;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.ProjectHelper;\nimport org.apache.tools.bzip2.CBZip2InputStream;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.vafer.jdeb.ar.ArEntry;\nimport org.vafer.jdeb.ar.ArInputStream;\n\n/**\n * @author Emmanuel Bourg\n * @version $Revision$, $Date$\n */\npublic class DebAntTaskTestCase extends TestCase {\n\n\tprivate Project project;\n\n\tprotected void setUp() throws Exception {\n\t\tproject = new Project();\n\t\tproject.setCoreLoader(getClass().getClassLoader());\n\t\tproject.init();\n\n\t\tFile buildFile = new File(\"target/test-classes/testbuild.xml\");\n\t\tproject.setBaseDir(buildFile.getParentFile());\n\t\tProjectHelper.configureProject(project, buildFile);\n\n\t\t// remove the package previously build\n\t\tFile deb = new File(\"target/test.deb\");\n\t\tif (deb.exists()) {\n\t\t\tassertTrue(\"Unable to remove the test archive\", deb.delete());\n\t\t}\n\t}\n\n\tpublic void testMissingControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testInvalidControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"invalid-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testMissingDestFile() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-destfile\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testEmptyPackage() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"empty-package\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithArchive() {\n\t\tproject.executeTarget(\"with-archive\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingArchive() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-archive\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithDirectory() {\n\t\tproject.executeTarget(\"with-directory\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingDirectory() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-directory\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\t/**\n\t * Redirects the Ant output to the specified stream.\n\t */\n\tprivate void redirectOutput(OutputStream out) {\n\t\tDefaultLogger logger = new DefaultLogger();\n\t\tlogger.setOutputPrintStream(new PrintStream(out));\n\t\tlogger.setMessageOutputLevel(Project.MSG_INFO);\n\t\tproject.addBuildListener(logger);\n\t}\n\n\tpublic void testVerboseEnabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-enabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") != -1);\n\t}\n\n\tpublic void testVerboseDisabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-disabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") == -1);\n\t}\n\n\tpublic void testFileSet() {\n\t\tproject.executeTarget(\"fileset\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testTarFileSet() throws Exception {\n\t\tproject.executeTarget(\"tarfileset\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.gz\")) {\n\t\t\t\tTarInputStream tar = new TarInputStream(new GZIPInputStream(in));\n\t\t\t\tTarEntry tarentry;\n\t\t\t\twhile ((tarentry = tar.getNextEntry()) != null) {\n\t\t\t\t\tassertTrue(\"prefix\", tarentry.getName().startsWith(\"/foo/\"));\n\t\t\t\t\tif (tarentry.isDirectory()) {\n\t\t\t\t\t\tassertEquals(\"directory mode (\" + tarentry.getName() + \")\", 040700, tarentry.getMode());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassertEquals(\"file mode (\" + tarentry.getName() + \")\", 0100600, tarentry.getMode());\n\t\t\t\t\t}\n\t\t\t\t\tassertEquals(\"user\", \"ebourg\", tarentry.getUserName());\n\t\t\t\t\tassertEquals(\"group\", \"ebourg\", tarentry.getGroupName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tin.skip(entry.getLength());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testUnkownCompression() throws Exception {\n\t\ttry {\n\t\t\tproject.executeTarget(\"unknown-compression\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testBZip2Compression() throws Exception {\n\t\tproject.executeTarget(\"bzip2-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.bz2\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tassertEquals(\"header 0\", (byte) 'B', in.read());\n\t\t\t\tassertEquals(\"header 1\", (byte) 'Z', in.read());\n\n\t\t\t\tTarInputStream tar = new TarInputStream(new CBZip2InputStream(in));\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tin.skip(entry.getLength());\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"bz2 file not found\", found);\n\t}\n\n\tpublic void testNoCompression() throws Exception {\n\t\tproject.executeTarget(\"no-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tTarInputStream tar = new TarInputStream(in);\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tin.skip(entry.getLength());\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"tar file not found\", found);\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2008 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.ant;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.zip.GZIPInputStream;\n\nimport junit.framework.TestCase;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.ProjectHelper;\nimport org.apache.tools.bzip2.CBZip2InputStream;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.vafer.jdeb.ar.ArEntry;\nimport org.vafer.jdeb.ar.ArInputStream;\n\n/**\n * @author Emmanuel Bourg\n * @version $Revision$, $Date$\n */\npublic class DebAntTaskTestCase extends TestCase {\n\n\tprivate Project project;\n\n\tprotected void setUp() throws Exception {\n\t\tproject = new Project();\n\t\tproject.setCoreLoader(getClass().getClassLoader());\n\t\tproject.init();\n\n\t\tFile buildFile = new File(\"target/test-classes/testbuild.xml\");\n\t\tproject.setBaseDir(buildFile.getParentFile());\n\t\tProjectHelper.configureProject(project, buildFile);\n\n\t\t// remove the package previously build\n\t\tFile deb = new File(\"target/test.deb\");\n\t\tif (deb.exists()) {\n\t\t\tassertTrue(\"Unable to remove the test archive\", deb.delete());\n\t\t}\n\t}\n\n\tpublic void testMissingControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testInvalidControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"invalid-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testMissingDestFile() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-destfile\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testEmptyPackage() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"empty-package\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithArchive() {\n\t\tproject.executeTarget(\"with-archive\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingArchive() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-archive\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithDirectory() {\n\t\tproject.executeTarget(\"with-directory\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingDirectory() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-directory\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\t/**\n\t * Redirects the Ant output to the specified stream.\n\t */\n\tprivate void redirectOutput(OutputStream out) {\n\t\tDefaultLogger logger = new DefaultLogger();\n\t\tlogger.setOutputPrintStream(new PrintStream(out));\n\t\tlogger.setMessageOutputLevel(Project.MSG_INFO);\n\t\tproject.addBuildListener(logger);\n\t}\n\n\tpublic void testVerboseEnabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-enabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") != -1);\n\t}\n\n\tpublic void testVerboseDisabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-disabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") == -1);\n\t}\n\n\tpublic void testFileSet() {\n\t\tproject.executeTarget(\"fileset\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testTarFileSet() throws Exception {\n\t\tproject.executeTarget(\"tarfileset\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.gz\")) {\n\t\t\t\tTarInputStream tar = new TarInputStream(new GZIPInputStream(in));\n\t\t\t\tTarEntry tarentry;\n\t\t\t\twhile ((tarentry = tar.getNextEntry()) != null) {\n\t\t\t\t\tassertTrue(\"prefix\", tarentry.getName().startsWith(\"/foo/\"));\n\t\t\t\t\tif (tarentry.isDirectory()) {\n\t\t\t\t\t\tassertEquals(\"directory mode (\" + tarentry.getName() + \")\", 040700, tarentry.getMode());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassertEquals(\"file mode (\" + tarentry.getName() + \")\", 0100600, tarentry.getMode());\n\t\t\t\t\t}\n\t\t\t\t\tassertEquals(\"user\", \"ebourg\", tarentry.getUserName());\n\t\t\t\t\tassertEquals(\"group\", \"ebourg\", tarentry.getGroupName());\n\t\t\t\t}\n\t\t\t\ttar.close();\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tlong skip = entry.getLength(); \n\t\t\t\twhile(skip > 0) {\n\t\t\t\t\tlong skipped = in.skip(skip); \n\t\t\t\t\tif (skipped == -1) {\n\t\t\t\t\t\tthrow new IOException(\"Failed to skip\");\n\t\t\t\t\t}\n\t\t\t\t\tskip -= skipped;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testUnkownCompression() throws Exception {\n\t\ttry {\n\t\t\tproject.executeTarget(\"unknown-compression\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testBZip2Compression() throws Exception {\n\t\tproject.executeTarget(\"bzip2-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.bz2\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tassertEquals(\"header 0\", (byte) 'B', in.read());\n\t\t\t\tassertEquals(\"header 1\", (byte) 'Z', in.read());\n\n\t\t\t\tTarInputStream tar = new TarInputStream(new CBZip2InputStream(in));\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t\ttar.close();\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tlong skip = entry.getLength(); \n\t\t\t\twhile(skip > 0) {\n\t\t\t\t\tlong skipped = in.skip(skip); \n\t\t\t\t\tif (skipped == -1) {\n\t\t\t\t\t\tthrow new IOException(\"Failed to skip\");\n\t\t\t\t\t}\n\t\t\t\t\tskip -= skipped;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"bz2 file not found\", found);\n\t}\n\n\tpublic void testNoCompression() throws Exception {\n\t\tproject.executeTarget(\"no-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tTarInputStream tar = new TarInputStream(in);\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t\ttar.close();\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tlong skip = entry.getLength(); \n\t\t\t\twhile(skip > 0) {\n\t\t\t\t\tlong skipped = in.skip(skip); \n\t\t\t\t\tif (skipped == -1) {\n\t\t\t\t\t\tthrow new IOException(\"Failed to skip\");\n\t\t\t\t\t}\n\t\t\t\t\tskip -= skipped;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"tar file not found\", found);\n\t}\n}\n","lineNo":187}
{"Smelly Sample":"/*\n * Copyright 2008 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.ant;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.zip.GZIPInputStream;\n\nimport junit.framework.TestCase;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.ProjectHelper;\nimport org.apache.tools.bzip2.CBZip2InputStream;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.vafer.jdeb.ar.ArEntry;\nimport org.vafer.jdeb.ar.ArInputStream;\n\n/**\n * @author Emmanuel Bourg\n * @version $Revision$, $Date$\n */\npublic class DebAntTaskTestCase extends TestCase {\n\n\tprivate Project project;\n\n\tprotected void setUp() throws Exception {\n\t\tproject = new Project();\n\t\tproject.setCoreLoader(getClass().getClassLoader());\n\t\tproject.init();\n\n\t\tFile buildFile = new File(\"target/test-classes/testbuild.xml\");\n\t\tproject.setBaseDir(buildFile.getParentFile());\n\t\tProjectHelper.configureProject(project, buildFile);\n\n\t\t// remove the package previously build\n\t\tFile deb = new File(\"target/test.deb\");\n\t\tif (deb.exists()) {\n\t\t\tassertTrue(\"Unable to remove the test archive\", deb.delete());\n\t\t}\n\t}\n\n\tpublic void testMissingControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testInvalidControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"invalid-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testMissingDestFile() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-destfile\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testEmptyPackage() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"empty-package\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithArchive() {\n\t\tproject.executeTarget(\"with-archive\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingArchive() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-archive\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithDirectory() {\n\t\tproject.executeTarget(\"with-directory\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingDirectory() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-directory\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\t/**\n\t * Redirects the Ant output to the specified stream.\n\t */\n\tprivate void redirectOutput(OutputStream out) {\n\t\tDefaultLogger logger = new DefaultLogger();\n\t\tlogger.setOutputPrintStream(new PrintStream(out));\n\t\tlogger.setMessageOutputLevel(Project.MSG_INFO);\n\t\tproject.addBuildListener(logger);\n\t}\n\n\tpublic void testVerboseEnabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-enabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") != -1);\n\t}\n\n\tpublic void testVerboseDisabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-disabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") == -1);\n\t}\n\n\tpublic void testFileSet() {\n\t\tproject.executeTarget(\"fileset\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testTarFileSet() throws Exception {\n\t\tproject.executeTarget(\"tarfileset\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.gz\")) {\n\t\t\t\tTarInputStream tar = new TarInputStream(new GZIPInputStream(in));\n\t\t\t\tTarEntry tarentry;\n\t\t\t\twhile ((tarentry = tar.getNextEntry()) != null) {\n\t\t\t\t\tassertTrue(\"prefix\", tarentry.getName().startsWith(\"/foo/\"));\n\t\t\t\t\tif (tarentry.isDirectory()) {\n\t\t\t\t\t\tassertEquals(\"directory mode (\" + tarentry.getName() + \")\", 040700, tarentry.getMode());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassertEquals(\"file mode (\" + tarentry.getName() + \")\", 0100600, tarentry.getMode());\n\t\t\t\t\t}\n\t\t\t\t\tassertEquals(\"user\", \"ebourg\", tarentry.getUserName());\n\t\t\t\t\tassertEquals(\"group\", \"ebourg\", tarentry.getGroupName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tin.skip(entry.getLength());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testUnkownCompression() throws Exception {\n\t\ttry {\n\t\t\tproject.executeTarget(\"unknown-compression\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testBZip2Compression() throws Exception {\n\t\tproject.executeTarget(\"bzip2-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.bz2\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tassertEquals(\"header 0\", (byte) 'B', in.read());\n\t\t\t\tassertEquals(\"header 1\", (byte) 'Z', in.read());\n\n\t\t\t\tTarInputStream tar = new TarInputStream(new CBZip2InputStream(in));\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tin.skip(entry.getLength());\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"bz2 file not found\", found);\n\t}\n\n\tpublic void testNoCompression() throws Exception {\n\t\tproject.executeTarget(\"no-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tTarInputStream tar = new TarInputStream(in);\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tin.skip(entry.getLength());\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"tar file not found\", found);\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2008 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.ant;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.zip.GZIPInputStream;\n\nimport junit.framework.TestCase;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.ProjectHelper;\nimport org.apache.tools.bzip2.CBZip2InputStream;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.vafer.jdeb.ar.ArEntry;\nimport org.vafer.jdeb.ar.ArInputStream;\n\n/**\n * @author Emmanuel Bourg\n * @version $Revision$, $Date$\n */\npublic class DebAntTaskTestCase extends TestCase {\n\n\tprivate Project project;\n\n\tprotected void setUp() throws Exception {\n\t\tproject = new Project();\n\t\tproject.setCoreLoader(getClass().getClassLoader());\n\t\tproject.init();\n\n\t\tFile buildFile = new File(\"target/test-classes/testbuild.xml\");\n\t\tproject.setBaseDir(buildFile.getParentFile());\n\t\tProjectHelper.configureProject(project, buildFile);\n\n\t\t// remove the package previously build\n\t\tFile deb = new File(\"target/test.deb\");\n\t\tif (deb.exists()) {\n\t\t\tassertTrue(\"Unable to remove the test archive\", deb.delete());\n\t\t}\n\t}\n\n\tpublic void testMissingControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testInvalidControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"invalid-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testMissingDestFile() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-destfile\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testEmptyPackage() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"empty-package\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithArchive() {\n\t\tproject.executeTarget(\"with-archive\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingArchive() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-archive\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithDirectory() {\n\t\tproject.executeTarget(\"with-directory\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingDirectory() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-directory\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\t/**\n\t * Redirects the Ant output to the specified stream.\n\t */\n\tprivate void redirectOutput(OutputStream out) {\n\t\tDefaultLogger logger = new DefaultLogger();\n\t\tlogger.setOutputPrintStream(new PrintStream(out));\n\t\tlogger.setMessageOutputLevel(Project.MSG_INFO);\n\t\tproject.addBuildListener(logger);\n\t}\n\n\tpublic void testVerboseEnabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-enabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") != -1);\n\t}\n\n\tpublic void testVerboseDisabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-disabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") == -1);\n\t}\n\n\tpublic void testFileSet() {\n\t\tproject.executeTarget(\"fileset\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testTarFileSet() throws Exception {\n\t\tproject.executeTarget(\"tarfileset\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.gz\")) {\n\t\t\t\tTarInputStream tar = new TarInputStream(new GZIPInputStream(in));\n\t\t\t\tTarEntry tarentry;\n\t\t\t\twhile ((tarentry = tar.getNextEntry()) != null) {\n\t\t\t\t\tassertTrue(\"prefix\", tarentry.getName().startsWith(\"/foo/\"));\n\t\t\t\t\tif (tarentry.isDirectory()) {\n\t\t\t\t\t\tassertEquals(\"directory mode (\" + tarentry.getName() + \")\", 040700, tarentry.getMode());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassertEquals(\"file mode (\" + tarentry.getName() + \")\", 0100600, tarentry.getMode());\n\t\t\t\t\t}\n\t\t\t\t\tassertEquals(\"user\", \"ebourg\", tarentry.getUserName());\n\t\t\t\t\tassertEquals(\"group\", \"ebourg\", tarentry.getGroupName());\n\t\t\t\t}\n\t\t\t\ttar.close();\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tlong skip = entry.getLength(); \n\t\t\t\twhile(skip > 0) {\n\t\t\t\t\tlong skipped = in.skip(skip); \n\t\t\t\t\tif (skipped == -1) {\n\t\t\t\t\t\tthrow new IOException(\"Failed to skip\");\n\t\t\t\t\t}\n\t\t\t\t\tskip -= skipped;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testUnkownCompression() throws Exception {\n\t\ttry {\n\t\t\tproject.executeTarget(\"unknown-compression\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testBZip2Compression() throws Exception {\n\t\tproject.executeTarget(\"bzip2-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.bz2\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tassertEquals(\"header 0\", (byte) 'B', in.read());\n\t\t\t\tassertEquals(\"header 1\", (byte) 'Z', in.read());\n\n\t\t\t\tTarInputStream tar = new TarInputStream(new CBZip2InputStream(in));\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t\ttar.close();\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tlong skip = entry.getLength(); \n\t\t\t\twhile(skip > 0) {\n\t\t\t\t\tlong skipped = in.skip(skip); \n\t\t\t\t\tif (skipped == -1) {\n\t\t\t\t\t\tthrow new IOException(\"Failed to skip\");\n\t\t\t\t\t}\n\t\t\t\t\tskip -= skipped;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"bz2 file not found\", found);\n\t}\n\n\tpublic void testNoCompression() throws Exception {\n\t\tproject.executeTarget(\"no-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tTarInputStream tar = new TarInputStream(in);\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t\ttar.close();\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tlong skip = entry.getLength(); \n\t\t\t\twhile(skip > 0) {\n\t\t\t\t\tlong skipped = in.skip(skip); \n\t\t\t\t\tif (skipped == -1) {\n\t\t\t\t\t\tthrow new IOException(\"Failed to skip\");\n\t\t\t\t\t}\n\t\t\t\t\tskip -= skipped;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"tar file not found\", found);\n\t}\n}\n","lineNo":231}
{"Smelly Sample":"/*\n * Copyright 2008 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.ant;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.zip.GZIPInputStream;\n\nimport junit.framework.TestCase;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.ProjectHelper;\nimport org.apache.tools.bzip2.CBZip2InputStream;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.vafer.jdeb.ar.ArEntry;\nimport org.vafer.jdeb.ar.ArInputStream;\n\n/**\n * @author Emmanuel Bourg\n * @version $Revision$, $Date$\n */\npublic class DebAntTaskTestCase extends TestCase {\n\n\tprivate Project project;\n\n\tprotected void setUp() throws Exception {\n\t\tproject = new Project();\n\t\tproject.setCoreLoader(getClass().getClassLoader());\n\t\tproject.init();\n\n\t\tFile buildFile = new File(\"target/test-classes/testbuild.xml\");\n\t\tproject.setBaseDir(buildFile.getParentFile());\n\t\tProjectHelper.configureProject(project, buildFile);\n\n\t\t// remove the package previously build\n\t\tFile deb = new File(\"target/test.deb\");\n\t\tif (deb.exists()) {\n\t\t\tassertTrue(\"Unable to remove the test archive\", deb.delete());\n\t\t}\n\t}\n\n\tpublic void testMissingControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testInvalidControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"invalid-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testMissingDestFile() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-destfile\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testEmptyPackage() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"empty-package\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithArchive() {\n\t\tproject.executeTarget(\"with-archive\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingArchive() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-archive\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithDirectory() {\n\t\tproject.executeTarget(\"with-directory\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingDirectory() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-directory\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\t/**\n\t * Redirects the Ant output to the specified stream.\n\t */\n\tprivate void redirectOutput(OutputStream out) {\n\t\tDefaultLogger logger = new DefaultLogger();\n\t\tlogger.setOutputPrintStream(new PrintStream(out));\n\t\tlogger.setMessageOutputLevel(Project.MSG_INFO);\n\t\tproject.addBuildListener(logger);\n\t}\n\n\tpublic void testVerboseEnabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-enabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") != -1);\n\t}\n\n\tpublic void testVerboseDisabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-disabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") == -1);\n\t}\n\n\tpublic void testFileSet() {\n\t\tproject.executeTarget(\"fileset\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testTarFileSet() throws Exception {\n\t\tproject.executeTarget(\"tarfileset\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.gz\")) {\n\t\t\t\tTarInputStream tar = new TarInputStream(new GZIPInputStream(in));\n\t\t\t\tTarEntry tarentry;\n\t\t\t\twhile ((tarentry = tar.getNextEntry()) != null) {\n\t\t\t\t\tassertTrue(\"prefix\", tarentry.getName().startsWith(\"/foo/\"));\n\t\t\t\t\tif (tarentry.isDirectory()) {\n\t\t\t\t\t\tassertEquals(\"directory mode (\" + tarentry.getName() + \")\", 040700, tarentry.getMode());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassertEquals(\"file mode (\" + tarentry.getName() + \")\", 0100600, tarentry.getMode());\n\t\t\t\t\t}\n\t\t\t\t\tassertEquals(\"user\", \"ebourg\", tarentry.getUserName());\n\t\t\t\t\tassertEquals(\"group\", \"ebourg\", tarentry.getGroupName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tin.skip(entry.getLength());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testUnkownCompression() throws Exception {\n\t\ttry {\n\t\t\tproject.executeTarget(\"unknown-compression\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testBZip2Compression() throws Exception {\n\t\tproject.executeTarget(\"bzip2-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.bz2\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tassertEquals(\"header 0\", (byte) 'B', in.read());\n\t\t\t\tassertEquals(\"header 1\", (byte) 'Z', in.read());\n\n\t\t\t\tTarInputStream tar = new TarInputStream(new CBZip2InputStream(in));\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tin.skip(entry.getLength());\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"bz2 file not found\", found);\n\t}\n\n\tpublic void testNoCompression() throws Exception {\n\t\tproject.executeTarget(\"no-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tTarInputStream tar = new TarInputStream(in);\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tin.skip(entry.getLength());\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"tar file not found\", found);\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2008 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.ant;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.zip.GZIPInputStream;\n\nimport junit.framework.TestCase;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.ProjectHelper;\nimport org.apache.tools.bzip2.CBZip2InputStream;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.vafer.jdeb.ar.ArEntry;\nimport org.vafer.jdeb.ar.ArInputStream;\n\n/**\n * @author Emmanuel Bourg\n * @version $Revision$, $Date$\n */\npublic class DebAntTaskTestCase extends TestCase {\n\n\tprivate Project project;\n\n\tprotected void setUp() throws Exception {\n\t\tproject = new Project();\n\t\tproject.setCoreLoader(getClass().getClassLoader());\n\t\tproject.init();\n\n\t\tFile buildFile = new File(\"target/test-classes/testbuild.xml\");\n\t\tproject.setBaseDir(buildFile.getParentFile());\n\t\tProjectHelper.configureProject(project, buildFile);\n\n\t\t// remove the package previously build\n\t\tFile deb = new File(\"target/test.deb\");\n\t\tif (deb.exists()) {\n\t\t\tassertTrue(\"Unable to remove the test archive\", deb.delete());\n\t\t}\n\t}\n\n\tpublic void testMissingControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testInvalidControl() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"invalid-control\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testMissingDestFile() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"missing-destfile\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testEmptyPackage() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"empty-package\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithArchive() {\n\t\tproject.executeTarget(\"with-archive\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingArchive() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-archive\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testPackageWithDirectory() {\n\t\tproject.executeTarget(\"with-directory\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testPackageWithMissingDirectory() {\n\t\ttry {\n\t\t\tproject.executeTarget(\"with-missing-directory\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\t/**\n\t * Redirects the Ant output to the specified stream.\n\t */\n\tprivate void redirectOutput(OutputStream out) {\n\t\tDefaultLogger logger = new DefaultLogger();\n\t\tlogger.setOutputPrintStream(new PrintStream(out));\n\t\tlogger.setMessageOutputLevel(Project.MSG_INFO);\n\t\tproject.addBuildListener(logger);\n\t}\n\n\tpublic void testVerboseEnabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-enabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") != -1);\n\t}\n\n\tpublic void testVerboseDisabled() {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tredirectOutput(out);\n\n\t\tproject.executeTarget(\"verbose-disabled\");\n\n\t\tassertTrue(out.toString().indexOf(\"Total size\") == -1);\n\t}\n\n\tpublic void testFileSet() {\n\t\tproject.executeTarget(\"fileset\");\n\n\t\tassertTrue(\"package not build\", new File(\"target/test-classes/test.deb\").exists());\n\t}\n\n\tpublic void testTarFileSet() throws Exception {\n\t\tproject.executeTarget(\"tarfileset\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.gz\")) {\n\t\t\t\tTarInputStream tar = new TarInputStream(new GZIPInputStream(in));\n\t\t\t\tTarEntry tarentry;\n\t\t\t\twhile ((tarentry = tar.getNextEntry()) != null) {\n\t\t\t\t\tassertTrue(\"prefix\", tarentry.getName().startsWith(\"/foo/\"));\n\t\t\t\t\tif (tarentry.isDirectory()) {\n\t\t\t\t\t\tassertEquals(\"directory mode (\" + tarentry.getName() + \")\", 040700, tarentry.getMode());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassertEquals(\"file mode (\" + tarentry.getName() + \")\", 0100600, tarentry.getMode());\n\t\t\t\t\t}\n\t\t\t\t\tassertEquals(\"user\", \"ebourg\", tarentry.getUserName());\n\t\t\t\t\tassertEquals(\"group\", \"ebourg\", tarentry.getGroupName());\n\t\t\t\t}\n\t\t\t\ttar.close();\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tlong skip = entry.getLength(); \n\t\t\t\twhile(skip > 0) {\n\t\t\t\t\tlong skipped = in.skip(skip); \n\t\t\t\t\tif (skipped == -1) {\n\t\t\t\t\t\tthrow new IOException(\"Failed to skip\");\n\t\t\t\t\t}\n\t\t\t\t\tskip -= skipped;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testUnkownCompression() throws Exception {\n\t\ttry {\n\t\t\tproject.executeTarget(\"unknown-compression\");\n\t\t\tfail(\"No exception thrown\");\n\t\t} catch (BuildException e) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\tpublic void testBZip2Compression() throws Exception {\n\t\tproject.executeTarget(\"bzip2-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar.bz2\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tassertEquals(\"header 0\", (byte) 'B', in.read());\n\t\t\t\tassertEquals(\"header 1\", (byte) 'Z', in.read());\n\n\t\t\t\tTarInputStream tar = new TarInputStream(new CBZip2InputStream(in));\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t\ttar.close();\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tlong skip = entry.getLength(); \n\t\t\t\twhile(skip > 0) {\n\t\t\t\t\tlong skipped = in.skip(skip); \n\t\t\t\t\tif (skipped == -1) {\n\t\t\t\t\t\tthrow new IOException(\"Failed to skip\");\n\t\t\t\t\t}\n\t\t\t\t\tskip -= skipped;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"bz2 file not found\", found);\n\t}\n\n\tpublic void testNoCompression() throws Exception {\n\t\tproject.executeTarget(\"no-compression\");\n\n\t\tFile deb = new File(\"target/test-classes/test.deb\");\n\t\tassertTrue(\"package not build\", deb.exists());\n\n\t\tboolean found = false;\n\n\t\tArInputStream in = new ArInputStream(new FileInputStream(deb));\n\t\tArEntry entry;\n\t\twhile ((entry = in.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(\"data.tar\")) {\n\t\t\t\tfound = true;\n\n\t\t\t\tTarInputStream tar = new TarInputStream(in);\n\t\t\t\twhile ((tar.getNextEntry()) != null);\n\t\t\t\ttar.close();\n\t\t\t} else {\n\t\t\t\t// skip to the next entry\n\t\t\t\tlong skip = entry.getLength(); \n\t\t\t\twhile(skip > 0) {\n\t\t\t\t\tlong skipped = in.skip(skip); \n\t\t\t\t\tif (skipped == -1) {\n\t\t\t\t\t\tthrow new IOException(\"Failed to skip\");\n\t\t\t\t\t}\n\t\t\t\t\tskip -= skipped;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(\"tar file not found\", found);\n\t}\n}\n","lineNo":264}
{"Smelly Sample":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport org.apache.tools.ant.types.selectors.SelectorUtils;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.mapping.Mapper;\nimport org.vafer.jdeb.mapping.NullMapper;\n\n/**\n * Base Producer class providing including/excluding.\n * \n * @author tcurdt\n */\npublic abstract class AbstractDataProducer implements DataProducer {\n\n\tprivate final String[] includes;\n\tprivate final String[] excludes;\n\tprivate final Mapper mapper;\n\t\n\t\n\tpublic AbstractDataProducer( final String[] pIncludes, final String[] pExcludes, final Mapper pMapper ) {\n\t\texcludes = (pExcludes != null) ? pExcludes : new String[0];\n\t\tincludes = (pIncludes != null) ? pIncludes : new String[] { \"**\" };\n\t\tmapper = (pMapper != null) ? pMapper : new NullMapper();\n\t}\n\t\n\tpublic boolean isIncluded( final String pName ) {\n\t\tif (!isIncluded(pName, includes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isExcluded(pName, excludes)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n    private boolean isIncluded( String name, String[] includes ) {\n        for (int i = 0; i < includes.length; i++) {\n            if (SelectorUtils.matchPath(includes[i], name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    private boolean isExcluded( String name, String[] excludes ) {\n        for (int i = 0; i < excludes.length; i++) {\n            if (SelectorUtils.matchPath(excludes[i], name)) {            \n                return true;\n            }\n        }\n        return false;\n    }\n\t\n\tpublic TarEntry map( final TarEntry pEntry ) {\n\t\t\n\t\tfinal TarEntry entry = mapper.map(pEntry);\n\t\t\n\t\treturn entry;\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.producers;\n\nimport org.apache.tools.ant.types.selectors.SelectorUtils;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.mapping.Mapper;\n\n/**\n * Base Producer class providing including/excluding.\n * \n * @author tcurdt\n */\npublic abstract class AbstractDataProducer implements DataProducer {\n\n\tprivate final String[] includes;\n\tprivate final String[] excludes;\n\tprivate final Mapper[] mappers;\n\t\n\t\n\tpublic AbstractDataProducer( final String[] pIncludes, final String[] pExcludes, final Mapper[] pMapper ) {\n\t\texcludes = (pExcludes != null) ? pExcludes : new String[0];\n\t\tincludes = (pIncludes != null) ? pIncludes : new String[] { \"**\" };\n\t\tmappers = (pMapper != null) ? pMapper : new Mapper[0];\n\t}\n\t\n\tpublic boolean isIncluded( final String pName ) {\n\t\tif (!isIncluded(pName, includes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isExcluded(pName, excludes)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n    private boolean isIncluded( String name, String[] includes ) {\n        for (int i = 0; i < includes.length; i++) {\n            if (SelectorUtils.matchPath(includes[i], name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    private boolean isExcluded( String name, String[] excludes ) {\n        for (int i = 0; i < excludes.length; i++) {\n            if (SelectorUtils.matchPath(excludes[i], name)) {            \n                return true;\n            }\n        }\n        return false;\n    }\n\t\n\tpublic TarEntry map( final TarEntry pEntry ) {\n\t\t\n\t\tTarEntry entry = pEntry;\n\n\t\tfor (int i = 0; i < mappers.length; i++) {\n\t\t\tentry = mappers[i].map(entry);\n\t\t}\n\t\t\n\t\treturn entry;\n\t}\n}\n","lineNo":72}
{"Smelly Sample":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.text.ParseException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.Processor;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.descriptors.PackageDescriptor;\nimport org.vafer.jdeb.utils.Utils;\n\n/**\n * Creates deb archive\n *\n * @goal deb\n * @requiresDependencyResolution compile\n * @execute phase=\"package\"\n */\npublic final class DebMojo extends AbstractPluginMojo {\n\n\t/**\n     * @component\n     */\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the pattern of the name of final artifacts.\n     * Possible substitutions are [artifactId] [version] [extension] and [groupId].\n     * \n     * @parameter expression=\"${namePattern}\" default-value=\"[artifactId]_[version].[extension]\"\n     */\n    private String namePattern;\n\n    /**\n     * Explicitly defines the final artifact name (without using the pattern) \n     * \n     * @parameter expression=\"${deb}\"\n     */    \n    private File deb;\n    \n    /**\n     * Explicitly defines the path to the control directory. At least the control file is mandatory. \n     * \n     * @parameter expression=\"${controlDir}\"\n     */    \n    private File controlDir;\n    \n    /**\n     * Explicitly define the file to read the changes from. \n     * \n     * @parameter expression=\"${changesIn}\"\n     */    \n    private File changesIn = null;\n\n    /**\n     * Explicitly define the file where to write the changes to. \n     * \n     * @parameter expression=\"${changesIn}\"\n     */    \n    private File changesOut = null;\n    \n    /**\n     * The keyring file. Usually some/path/secring.gpg\n     * \n     * @parameter expression=\"${keyring}\"\n     */    \t\n    private File keyring = null;\n\n    /**\n     * The hex key id to use for signing. \n     * \n     * @parameter expression=\"${key}\"\n     */    \t\n\tprivate String key = null;\n\n    /**\n     * The passphrase for the key to sign the changes file. \n     * \n     * @parameter expression=\"${passhrase}\"\n     */    \t\n\tprivate String passphrase = null;\n    \n    /**\n     * If not defaultPath is specified this  \n     * \n     * @parameter expression=\"${defaultPath}\" default-value=\"/srv/jetty/www\"\n     */    \t\n\tprivate String defaultPath = \"/srv/jetty/www\";\n\n\t/**\n\t * TODO: make configurable\n\t */\n\tprivate DataProducer[] dataProducers = null;\n\t\n\t\n\t/**\n     * Main entry point\n     * @throws MojoExecutionException on error\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n    \t// expand name pattern\n    \tfinal String debName;\n    \tfinal String changesName;    \t\n    \tfinal Map variables = new HashMap();\n    \tvariables.put(\"artifactId\", getProject().getArtifactId());\n    \tvariables.put(\"groupId\", getProject().getGroupId());\n    \tvariables.put(\"version\", getProject().getVersion());\n    \tvariables.put(\"extension\", \"deb\");    \t\n    \ttry\n    \t{\n        \tdebName = Utils.replaceVariables(variables, namePattern, \"[\", \"]\"); \n\n        \tvariables.put(\"extension\", \"changes\");    \t\n        \tchangesName = Utils.replaceVariables(variables, namePattern, \"[\", \"]\"); \n\t\t}\n    \tcatch (ParseException e)\n    \t{\n\t\t\tthrow new MojoExecutionException(\"Failed parsing artifact name pattern\", e);\n\t\t}\n\n    \t// if not specified try to the default\n    \tif (deb == null)\n    \t{\n\t\t\tdeb = new File(buildDirectory, debName);\n    \t}\n\n    \t// if not specified try to the default\n    \tif (changesIn == null)\n    \t{\n    \t\tfinal File f = new File(getProject().getBasedir(), \"CHANGES.txt\");\n    \t\tif (f.exists() && f.isFile() && f.canRead())\n    \t\t{\n    \t\t\tchangesIn = f;\n    \t\t}\n    \t}\n    \t\n    \t// if not specified try to the default\n    \tif (changesOut == null)\n    \t{\n\t\t\tchangesOut = new File(buildDirectory, changesName);\n    \t}\n    \t\n    \t// if not specified try to the default\n    \tif (controlDir == null)\n    \t{\n    \t\tcontrolDir = new File(getProject().getBasedir(), \"src/deb/control\");\n    \t\tgetLog().info(\"Using default path to control directory \" + controlDir);\n    \t}\n    \t\n    \t// make sure we have at least the mandatory control directory\n    \tif (!controlDir.exists() || !controlDir.isDirectory())\n    \t{\n    \t\tthrow new MojoExecutionException(controlDir + \" needs to be a directory\");\n    \t}\n    \t\n    \t// make sure we have at least the mandatory control file\n    \tfinal File controlFile = new File(controlDir, \"control\");\n    \tif (!controlFile.exists() || !controlFile.isFile() || !controlFile.canRead())\n    \t{\n    \t\tthrow new MojoExecutionException(controlFile + \" is mandatory\");\n    \t}\n    \t\n    \tfinal File file = getProject().getArtifact().getFile();\n\t\tfinal File[] controlFiles = controlDir.listFiles();\n\t\t\n\t\t\n\t\tif (dataProducers == null)\n\t\t{\n\t\t\tdataProducers = new DataProducer[] { new DataProducer() {\n\t\t\tpublic void produce( final DataConsumer receiver ) {\n\t\t\t\ttry {\n\t\t\t\t\treceiver.onEachFile(new FileInputStream(file), new File(new File(defaultPath), file.getName()).getAbsolutePath(), \"\", \"root\", 0, \"root\", 0, TarEntry.DEFAULT_FILE_MODE, file.length());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tgetLog().error(e);\n\t\t\t\t}\n\t\t\t}}};\n\t\t}\n\n\t\t\n\t\tfinal Processor processor = new Processor(new Console()\n\t\t{\n\t\t\tpublic void println( final String s )\n\t\t\t{\n\t\t\t\tgetLog().info(s);\n\t\t\t}\t\t\t\n\t\t});\n\t\t\n\t\tfinal PackageDescriptor packageDescriptor;\n\t\ttry\n\t\t{\n\n\t\t\tpackageDescriptor = processor.createDeb(controlFiles, dataProducers, deb);\n\n\t\t\tgetLog().info(\"Attaching created debian archive \" + deb);\n\t\t\tprojectHelper.attachArtifact( getProject(), \"deb-archive\", deb.getName(), deb );\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tgetLog().error(\"Failed to create debian package \" + deb, e);\n\t\t\tthrow new MojoExecutionException(\"Failed to create debian package \" + deb, e);\n\t\t}    \t\n\n\t\tif (changesIn == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ttry\n\t\t{\n\n\t\t\t// for now only support reading the changes form a text file provider\n\t\t\tfinal TextfileChangesProvider changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageDescriptor);\n\t\t\t\n\t\t\tprocessor.createChanges(packageDescriptor, changesProvider, (keyring!=null)?new FileInputStream(keyring):null, key, passphrase, new FileOutputStream(changesOut));\n\n\t\t\t// write the release information to this file\n\t\t\tchangesProvider.save(new FileOutputStream(changesIn));\n\t\t\t\n\t\t\tgetLog().info(\"Attaching created debian changes file \" + changesOut);\n\t\t\tprojectHelper.attachArtifact( getProject(), \"deb-changes\", changesOut.getName(), changesOut );\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tgetLog().error(\"Failed to create debian changes file \" + changesOut, e);\n\t\t\tthrow new MojoExecutionException(\"Failed to create debian changes file \" + changesOut, e);\n\t\t}    \t\n    }    \n\n}\n","Method after Refactoring":"/*\n * Copyright 2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.vafer.jdeb.maven;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.text.ParseException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.tools.tar.TarEntry;\nimport org.vafer.jdeb.Console;\nimport org.vafer.jdeb.DataConsumer;\nimport org.vafer.jdeb.DataProducer;\nimport org.vafer.jdeb.Processor;\nimport org.vafer.jdeb.changes.TextfileChangesProvider;\nimport org.vafer.jdeb.descriptors.PackageDescriptor;\nimport org.vafer.jdeb.utils.MapVariableResolver;\nimport org.vafer.jdeb.utils.Utils;\nimport org.vafer.jdeb.utils.VariableResolver;\n\n/**\n * Creates deb archive\n *\n * @goal deb\n * @requiresDependencyResolution compile\n * @execute phase=\"package\"\n */\npublic final class DebMojo extends AbstractPluginMojo {\n\n\t/**\n     * @component\n     */\n    private MavenProjectHelper projectHelper;\n\n    /**\n     * Defines the pattern of the name of final artifacts.\n     * Possible substitutions are [[artifactId]] [[version]] [[extension]] and [[groupId]].\n     * \n     * @parameter expression=\"${namePattern}\" default-value=\"[[artifactId]]_[[version]].[[extension]]\"\n     */\n    private String namePattern;\n\n    /**\n     * Explicitly defines the final artifact name (without using the pattern) \n     * \n     * @parameter expression=\"${deb}\"\n     */    \n    private File deb;\n    \n    /**\n     * Explicitly defines the path to the control directory. At least the control file is mandatory. \n     * \n     * @parameter expression=\"${controlDir}\"\n     */    \n    private File controlDir;\n    \n    /**\n     * Explicitly define the file to read the changes from. \n     * \n     * @parameter expression=\"${changesIn}\"\n     */    \n    private File changesIn = null;\n\n    /**\n     * Explicitly define the file where to write the changes to. \n     * \n     * @parameter expression=\"${changesIn}\"\n     */    \n    private File changesOut = null;\n    \n    /**\n     * The keyring file. Usually some/path/secring.gpg\n     * \n     * @parameter expression=\"${keyring}\"\n     */    \t\n    private File keyring = null;\n\n    /**\n     * The hex key id to use for signing. \n     * \n     * @parameter expression=\"${key}\"\n     */    \t\n\tprivate String key = null;\n\n    /**\n     * The passphrase for the key to sign the changes file. \n     * \n     * @parameter expression=\"${passhrase}\"\n     */    \t\n\tprivate String passphrase = null;\n    \n    /**\n     * If not defaultPath is specified this  \n     * \n     * @parameter expression=\"${defaultPath}\" default-value=\"/srv/jetty/www\"\n     */    \t\n\tprivate String defaultPath = \"/srv/jetty/www\";\n\n\t/**\n\t * TODO: make configurable\n\t */\n\tprivate DataProducer[] dataProducers = null;\n\t\n\t\n\t/**\n     * Main entry point\n     * @throws MojoExecutionException on error\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n    \t// expand name pattern\n    \tfinal String debName;\n    \tfinal String changesName;    \t\n\n    \tfinal Map variables = new HashMap();\n    \tvariables.put(\"name\", getProject().getName());\n    \tvariables.put(\"artifactId\", getProject().getArtifactId());\n    \tvariables.put(\"groupId\", getProject().getGroupId());\n    \tvariables.put(\"version\", getProject().getVersion().replace('-', '+'));\n    \tvariables.put(\"description\", getProject().getDescription());\n    \tvariables.put(\"extension\", \"deb\");    \t\n    \tfinal VariableResolver resolver = new MapVariableResolver(variables);\n\n    \ttry\n    \t{\n        \tdebName = Utils.replaceVariables(resolver, namePattern, \"[[\", \"]]\"); \n        \t\n        \tvariables.put(\"extension\", \"changes\");    \t\n        \tchangesName = Utils.replaceVariables(resolver, namePattern, \"[[\", \"]]\"); \n\t\t}\n    \tcatch (ParseException e)\n    \t{\n\t\t\tthrow new MojoExecutionException(\"Failed parsing artifact name pattern\", e);\n\t\t}\n\n    \t// if not specified try to the default\n    \tif (deb == null)\n    \t{\n\t\t\tdeb = new File(buildDirectory, debName);\n    \t}\n\n    \t// if not specified try to the default\n    \tif (changesIn == null)\n    \t{\n    \t\tfinal File f = new File(getProject().getBasedir(), \"CHANGES.txt\");\n    \t\tif (f.exists() && f.isFile() && f.canRead())\n    \t\t{\n    \t\t\tchangesIn = f;\n    \t\t}\n    \t}\n    \t\n    \t// if not specified try to the default\n    \tif (changesOut == null)\n    \t{\n\t\t\tchangesOut = new File(buildDirectory, changesName);\n    \t}\n    \t\n    \t// if not specified try to the default\n    \tif (controlDir == null)\n    \t{\n    \t\tcontrolDir = new File(getProject().getBasedir(), \"src/deb/control\");\n    \t\tgetLog().info(\"Using default path to control directory \" + controlDir);\n    \t}\n    \t\n    \t// make sure we have at least the mandatory control directory\n    \tif (!controlDir.exists() || !controlDir.isDirectory())\n    \t{\n    \t\tthrow new MojoExecutionException(controlDir + \" needs to be a directory\");\n    \t}\n    \t\n    \t// make sure we have at least the mandatory control file\n    \tfinal File controlFile = new File(controlDir, \"control\");\n    \tif (!controlFile.exists() || !controlFile.isFile() || !controlFile.canRead())\n    \t{\n    \t\tthrow new MojoExecutionException(controlFile + \" is mandatory\");\n    \t}\n    \t\n    \tfinal File file = getProject().getArtifact().getFile();\n\t\tfinal File[] controlFiles = controlDir.listFiles();\n\t\t\n\t\t\n\t\tif (dataProducers == null)\n\t\t{\n\t\t\tdataProducers = new DataProducer[] { new DataProducer() {\n\t\t\tpublic void produce( final DataConsumer receiver ) {\n\t\t\t\ttry {\n\t\t\t\t\treceiver.onEachFile(new FileInputStream(file), new File(new File(defaultPath), file.getName()).getAbsolutePath(), \"\", \"root\", 0, \"root\", 0, TarEntry.DEFAULT_FILE_MODE, file.length());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tgetLog().error(e);\n\t\t\t\t}\n\t\t\t}}};\n\t\t}\n\n\t\t\n\t\tfinal Processor processor = new Processor(\n\t\t\t\tnew Console()\n\t\t\t\t{\n\t\t\t\t\tpublic void println( final String s )\n\t\t\t\t\t{\n\t\t\t\t\t\tgetLog().info(s);\n\t\t\t\t\t}\t\t\t\n\t\t\t\t},\n\t\t\t\tresolver\n\t\t);\n\t\t\n\t\tfinal PackageDescriptor packageDescriptor;\n\t\ttry\n\t\t{\n\n\t\t\tpackageDescriptor = processor.createDeb(controlFiles, dataProducers, deb);\n\n\t\t\tgetLog().info(\"Attaching created debian archive \" + deb);\n\t\t\tprojectHelper.attachArtifact( getProject(), \"deb-archive\", deb.getName(), deb );\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tgetLog().error(\"Failed to create debian package \" + deb, e);\n\t\t\tthrow new MojoExecutionException(\"Failed to create debian package \" + deb, e);\n\t\t}    \t\n\n\t\tif (changesIn == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ttry\n\t\t{\n\n\t\t\t// for now only support reading the changes form a text file provider\n\t\t\tfinal TextfileChangesProvider changesProvider = new TextfileChangesProvider(new FileInputStream(changesIn), packageDescriptor);\n\t\t\t\n\t\t\tprocessor.createChanges(packageDescriptor, changesProvider, (keyring!=null)?new FileInputStream(keyring):null, key, passphrase, new FileOutputStream(changesOut));\n\n\t\t\t// write the release information to this file\n\t\t\tchangesProvider.save(new FileOutputStream(changesIn));\n\t\t\t\n\t\t\tgetLog().info(\"Attaching created debian changes file \" + changesOut);\n\t\t\tprojectHelper.attachArtifact( getProject(), \"deb-changes\", changesOut.getName(), changesOut );\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tgetLog().error(\"Failed to create debian changes file \" + changesOut, e);\n\t\t\tthrow new MojoExecutionException(\"Failed to create debian changes file \" + changesOut, e);\n\t\t}    \t\n    }    \n\n}\n","lineNo":140}
{"Smelly Sample":"package org.vafer.jdeb.mapping;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.tools.tar.TarEntry;\n\n/**\n * ls -laR > mapping.txt \n * \n * @author tcurdt\n */\npublic final class LsMapper implements Mapper {\n\n\tprivate final Map mapping;\n\t\n\tpublic LsMapper( final InputStream pInput ) throws IOException {\n\t\tmapping = parse(pInput);\n\t}\n\t\n\t/*\n./trunk/target/test-classes/org/vafer/dependency:\ntotal 176\ndrwxr-xr-x   23 tcurdt  tcurdt   782 Jun 25 03:48 .\ndrwxr-xr-x    3 tcurdt  tcurdt   102 Jun 25 03:48 ..\n-rw-r--r--    1 tcurdt  tcurdt  2934 Jun 25 03:48 DependenciesTestCase.class\n-rw-r--r--    1 tcurdt  tcurdt   786 Jun 25 03:48 JarCombiningTestCase$1.class\n-rw-r--r--    1 tcurdt  tcurdt  2176 Jun 25 03:48 WarTestCase.class\ndrwxr-xr-x    4 tcurdt  tcurdt   136 Jun 25 03:48 classes\n\n./trunk/target/test-classes/org/vafer/dependency/classes:\n\t */\n\n\tprivate String readBase( final BufferedReader reader ) throws IOException {\n\t\tfinal String line = reader.readLine();\n\t\tif (line == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn line.substring(2, line.length() - 1);\n\t}\n\n\tprivate int readTotal( final BufferedReader reader ) throws IOException {\n\t\treader.readLine();\n\t\treturn 0;\n\t}\n\n\tprivate TarEntry readDir( final BufferedReader reader, final String base ) throws IOException {\n\t\treader.readLine();\n\t\treader.readLine();\n\t\treturn new TarEntry(base);\n\t}\n\n\tprivate TarEntry readFile( final BufferedReader reader, final String base ) throws IOException {\n\t\tfinal String line = reader.readLine();\n\n\t\tif (line.length() < 50) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new TarEntry(base + \"/\" + line.substring(50));\n\t}\n\t\n\tprivate Map parse( final InputStream pInput ) throws IOException {\n\t\tfinal Map mapping = new HashMap();\n\t\t\n\t\tfinal BufferedReader reader = new BufferedReader(new InputStreamReader(pInput));\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tfinal String base = readBase(reader);\n\n\t\t\tif (base == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treadTotal(reader);\n\t\t\tfinal TarEntry dir = readDir(reader, base);\n\t\t\tmapping.put(dir.getName(), dir);\n\t\t\tSystem.out.println(dir.getName());\n\n\t\t\twhile(true) {\n\t\t\t\tfinal TarEntry file = readFile(reader, base);\n\n\t\t\t\tif (file == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmapping.put(file.getName(), file);\n\n\t\t\t\tSystem.out.println(file.getName());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mapping;\n\t}\n\t\n\tpublic TarEntry map( final TarEntry pEntry ) {\n\t\t\n\t\tfinal TarEntry entry = (TarEntry) mapping.get(pEntry.getName());\n\t\t\n\t\tif (entry != null) {\n\t\t\treturn entry;\n\t\t}\n\t\t\n\t\treturn pEntry;\n\t}\n\n}\n","Method after Refactoring":"package org.vafer.jdeb.mapping;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.tools.tar.TarEntry;\n\n/**\n * ls -laR > mapping.txt \n * \n * @author tcurdt\n */\npublic final class LsMapper implements Mapper {\n\n\tprivate final Map mapping;\n\n\t\n\tpublic final static class ParseError extends Exception {\n\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tpublic ParseError() {\n\t\t\tsuper();\n\t\t}\n\n\t\tpublic ParseError(String message, Throwable cause) {\n\t\t\tsuper(message, cause);\n\t\t}\n\n\t\tpublic ParseError(String message) {\n\t\t\tsuper(message);\n\t\t}\n\n\t\tpublic ParseError(Throwable cause) {\n\t\t\tsuper(cause);\n\t\t}\n\t\t\n\t};\n\t\n\tpublic LsMapper( final InputStream pInput ) throws IOException, ParseError {\n\t\tmapping = parse(pInput);\n\t}\n\t\n\t/*\n./trunk/target/test-classes/org/vafer/dependency:\ntotal 176\ndrwxr-xr-x   23 tcurdt  tcurdt   782 Jun 25 03:48 .\ndrwxr-xr-x    3 tcurdt  tcurdt   102 Jun 25 03:48 ..\n-rw-r--r--    1 tcurdt  tcurdt  2934 Jun 25 03:48 DependenciesTestCase.class\n-rw-r--r--    1 tcurdt  tcurdt   786 Jun 25 03:48 JarCombiningTestCase$1.class\n-rw-r--r--    1 tcurdt  tcurdt  2176 Jun 25 03:48 WarTestCase.class\ndrwxr-xr-x    4 tcurdt  tcurdt   136 Jun 25 03:48 classes\n\n./trunk/target/test-classes/org/vafer/dependency/classes:\n\t */\n\t\n\tfinal private Pattern basePattern = Pattern.compile(\"^\\\\./(.*):$\");\n\tfinal private Pattern totalPattern = Pattern.compile(\"^total ([0-9]+)$\");\n\tfinal private Pattern dirPattern = Pattern.compile(\"^d([rwx-]{9})\\\\s+([0-9]+)\\\\s+(.*)\\\\s+(.*)\\\\s+([0-9]+)\\\\s+(.*)\\\\s+[\\\\.]{1,2}$\");\n\tfinal private Pattern filePattern = Pattern.compile(\"^([d-])([rwx-]{9})\\\\s+([0-9]+)\\\\s+(.*)\\\\s+(.*)\\\\s+([0-9]+)\\\\s+(.*)\\\\s+(.*)$\");\n\tfinal private Pattern newlinePattern = Pattern.compile(\"$\");\n\n\tprivate String readBase( final BufferedReader reader ) throws IOException, ParseError {\n\t\tfinal String line = reader.readLine();\n\t\tif (line == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal Matcher matcher = basePattern.matcher(line);\n\t\tif (!matcher.matches()) {\n\t\t\tthrow new ParseError(\"expected base line but got \\\"\" + line + \"\\\"\");\n\t\t}\n\t\treturn matcher.group(1);\n\t}\n\n\tprivate String readTotal( final BufferedReader reader ) throws IOException, ParseError {\n\t\tfinal String line = reader.readLine();\n\t\tfinal Matcher matcher = totalPattern.matcher(line);\n\t\tif (!matcher.matches()) {\n\t\t\tthrow new ParseError(\"expected total line but got \\\"\" + line + \"\\\"\");\n\t\t}\n\t\treturn matcher.group(1);\n\t}\n\n\tprivate TarEntry readDir( final BufferedReader reader, final String base ) throws IOException, ParseError {\n\t\tfinal String current = reader.readLine();\n\t\tfinal Matcher currentMatcher = dirPattern.matcher(current);\n\t\tif (!currentMatcher.matches()) {\n\t\t\tthrow new ParseError(\"expected dirline but got \\\"\" + current + \"\\\"\");\n\t\t}\n\n\t\tfinal String parent = reader.readLine();\n\t\tfinal Matcher parentMatcher = dirPattern.matcher(parent);\n\t\tif (!parentMatcher.matches()) {\n\t\t\tthrow new ParseError(\"expected dirline but got \\\"\" + parent + \"\\\"\");\n\t\t}\n\t\t\n\t\tfinal TarEntry entry = new TarEntry(base);\n\t\t//entry.setGroupName(currentMatcher.group(2));\n\t\t\n\t\treturn entry;\n\t}\n\n\tprivate TarEntry readFile( final BufferedReader reader, final String base ) throws IOException, ParseError {\n\t\t\n\t\twhile(true) {\n\t\t\tfinal String line = reader.readLine();\n\t\t\t\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tfinal Matcher matcher = filePattern.matcher(line);\n\t\t\tif (!matcher.matches()) {\n\t\t\t\tfinal Matcher newlineMatcher = newlinePattern.matcher(line);\n\t\t\t\tif (newlineMatcher.matches()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tthrow new ParseError(\"expected file line but got \\\"\" + line + \"\\\"\");\n\t\t\t}\n\t\t\t\n\t\t\tfinal String type = matcher.group(1);\n\t\t\tif (type.startsWith(\"-\")) {\n\t\t\t\tfinal TarEntry entry = new TarEntry(base + \"/\" + matcher.group(8));\n\n\t\t\t\t//entry.setGroupName(currentMatcher.group(2));\n\t\t\t\t\n\t\t\t\treturn entry;\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprivate Map parse( final InputStream pInput ) throws IOException, ParseError {\n\t\tfinal Map mapping = new HashMap();\n\t\t\n\t\tfinal BufferedReader reader = new BufferedReader(new InputStreamReader(pInput));\n\t\t\n\t\twhile(true) {\n\n\t\t\tfinal String base = readBase(reader);\n\n\t\t\tif (base == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treadTotal(reader);\n\t\t\tfinal TarEntry dir = readDir(reader, base);\n\t\t\tmapping.put(dir.getName(), dir);\n\n\t\t\twhile(true) {\n\t\t\t\tfinal TarEntry file = readFile(reader, base);\n\n\t\t\t\tif (file == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmapping.put(file.getName(), file);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mapping;\n\t}\n\t\n\tpublic TarEntry map( final TarEntry pEntry ) {\n\t\t\n\t\tfinal TarEntry entry = (TarEntry) mapping.get(pEntry.getName());\n\t\t\n\t\tif (entry != null) {\n\t\t\treturn entry;\n\t\t}\n\t\t\n\t\treturn pEntry;\n\t}\n\n}\n","lineNo":74}
{"Smelly Sample":"package org.vafer.jdeb.mapping;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.tools.tar.TarEntry;\n\n/**\n * ls -laR > mapping.txt \n * \n * @author tcurdt\n */\npublic final class LsMapper implements Mapper {\n\n\tprivate final Map mapping;\n\t\n\tpublic LsMapper( final InputStream pInput ) throws IOException {\n\t\tmapping = parse(pInput);\n\t}\n\t\n\t/*\n./trunk/target/test-classes/org/vafer/dependency:\ntotal 176\ndrwxr-xr-x   23 tcurdt  tcurdt   782 Jun 25 03:48 .\ndrwxr-xr-x    3 tcurdt  tcurdt   102 Jun 25 03:48 ..\n-rw-r--r--    1 tcurdt  tcurdt  2934 Jun 25 03:48 DependenciesTestCase.class\n-rw-r--r--    1 tcurdt  tcurdt   786 Jun 25 03:48 JarCombiningTestCase$1.class\n-rw-r--r--    1 tcurdt  tcurdt  2176 Jun 25 03:48 WarTestCase.class\ndrwxr-xr-x    4 tcurdt  tcurdt   136 Jun 25 03:48 classes\n\n./trunk/target/test-classes/org/vafer/dependency/classes:\n\t */\n\n\tprivate String readBase( final BufferedReader reader ) throws IOException {\n\t\tfinal String line = reader.readLine();\n\t\tif (line == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn line.substring(2, line.length() - 1);\n\t}\n\n\tprivate int readTotal( final BufferedReader reader ) throws IOException {\n\t\treader.readLine();\n\t\treturn 0;\n\t}\n\n\tprivate TarEntry readDir( final BufferedReader reader, final String base ) throws IOException {\n\t\treader.readLine();\n\t\treader.readLine();\n\t\treturn new TarEntry(base);\n\t}\n\n\tprivate TarEntry readFile( final BufferedReader reader, final String base ) throws IOException {\n\t\tfinal String line = reader.readLine();\n\n\t\tif (line.length() < 50) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new TarEntry(base + \"/\" + line.substring(50));\n\t}\n\t\n\tprivate Map parse( final InputStream pInput ) throws IOException {\n\t\tfinal Map mapping = new HashMap();\n\t\t\n\t\tfinal BufferedReader reader = new BufferedReader(new InputStreamReader(pInput));\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tfinal String base = readBase(reader);\n\n\t\t\tif (base == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treadTotal(reader);\n\t\t\tfinal TarEntry dir = readDir(reader, base);\n\t\t\tmapping.put(dir.getName(), dir);\n\t\t\tSystem.out.println(dir.getName());\n\n\t\t\twhile(true) {\n\t\t\t\tfinal TarEntry file = readFile(reader, base);\n\n\t\t\t\tif (file == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmapping.put(file.getName(), file);\n\n\t\t\t\tSystem.out.println(file.getName());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mapping;\n\t}\n\t\n\tpublic TarEntry map( final TarEntry pEntry ) {\n\t\t\n\t\tfinal TarEntry entry = (TarEntry) mapping.get(pEntry.getName());\n\t\t\n\t\tif (entry != null) {\n\t\t\treturn entry;\n\t\t}\n\t\t\n\t\treturn pEntry;\n\t}\n\n}\n","Method after Refactoring":"package org.vafer.jdeb.mapping;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.tools.tar.TarEntry;\n\n/**\n * ls -laR > mapping.txt \n * \n * @author tcurdt\n */\npublic final class LsMapper implements Mapper {\n\n\tprivate final Map mapping;\n\n\t\n\tpublic final static class ParseError extends Exception {\n\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tpublic ParseError() {\n\t\t\tsuper();\n\t\t}\n\n\t\tpublic ParseError(String message, Throwable cause) {\n\t\t\tsuper(message, cause);\n\t\t}\n\n\t\tpublic ParseError(String message) {\n\t\t\tsuper(message);\n\t\t}\n\n\t\tpublic ParseError(Throwable cause) {\n\t\t\tsuper(cause);\n\t\t}\n\t\t\n\t};\n\t\n\tpublic LsMapper( final InputStream pInput ) throws IOException, ParseError {\n\t\tmapping = parse(pInput);\n\t}\n\t\n\t/*\n./trunk/target/test-classes/org/vafer/dependency:\ntotal 176\ndrwxr-xr-x   23 tcurdt  tcurdt   782 Jun 25 03:48 .\ndrwxr-xr-x    3 tcurdt  tcurdt   102 Jun 25 03:48 ..\n-rw-r--r--    1 tcurdt  tcurdt  2934 Jun 25 03:48 DependenciesTestCase.class\n-rw-r--r--    1 tcurdt  tcurdt   786 Jun 25 03:48 JarCombiningTestCase$1.class\n-rw-r--r--    1 tcurdt  tcurdt  2176 Jun 25 03:48 WarTestCase.class\ndrwxr-xr-x    4 tcurdt  tcurdt   136 Jun 25 03:48 classes\n\n./trunk/target/test-classes/org/vafer/dependency/classes:\n\t */\n\t\n\tfinal private Pattern basePattern = Pattern.compile(\"^\\\\./(.*):$\");\n\tfinal private Pattern totalPattern = Pattern.compile(\"^total ([0-9]+)$\");\n\tfinal private Pattern dirPattern = Pattern.compile(\"^d([rwx-]{9})\\\\s+([0-9]+)\\\\s+(.*)\\\\s+(.*)\\\\s+([0-9]+)\\\\s+(.*)\\\\s+[\\\\.]{1,2}$\");\n\tfinal private Pattern filePattern = Pattern.compile(\"^([d-])([rwx-]{9})\\\\s+([0-9]+)\\\\s+(.*)\\\\s+(.*)\\\\s+([0-9]+)\\\\s+(.*)\\\\s+(.*)$\");\n\tfinal private Pattern newlinePattern = Pattern.compile(\"$\");\n\n\tprivate String readBase( final BufferedReader reader ) throws IOException, ParseError {\n\t\tfinal String line = reader.readLine();\n\t\tif (line == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal Matcher matcher = basePattern.matcher(line);\n\t\tif (!matcher.matches()) {\n\t\t\tthrow new ParseError(\"expected base line but got \\\"\" + line + \"\\\"\");\n\t\t}\n\t\treturn matcher.group(1);\n\t}\n\n\tprivate String readTotal( final BufferedReader reader ) throws IOException, ParseError {\n\t\tfinal String line = reader.readLine();\n\t\tfinal Matcher matcher = totalPattern.matcher(line);\n\t\tif (!matcher.matches()) {\n\t\t\tthrow new ParseError(\"expected total line but got \\\"\" + line + \"\\\"\");\n\t\t}\n\t\treturn matcher.group(1);\n\t}\n\n\tprivate TarEntry readDir( final BufferedReader reader, final String base ) throws IOException, ParseError {\n\t\tfinal String current = reader.readLine();\n\t\tfinal Matcher currentMatcher = dirPattern.matcher(current);\n\t\tif (!currentMatcher.matches()) {\n\t\t\tthrow new ParseError(\"expected dirline but got \\\"\" + current + \"\\\"\");\n\t\t}\n\n\t\tfinal String parent = reader.readLine();\n\t\tfinal Matcher parentMatcher = dirPattern.matcher(parent);\n\t\tif (!parentMatcher.matches()) {\n\t\t\tthrow new ParseError(\"expected dirline but got \\\"\" + parent + \"\\\"\");\n\t\t}\n\t\t\n\t\tfinal TarEntry entry = new TarEntry(base);\n\t\t//entry.setGroupName(currentMatcher.group(2));\n\t\t\n\t\treturn entry;\n\t}\n\n\tprivate TarEntry readFile( final BufferedReader reader, final String base ) throws IOException, ParseError {\n\t\t\n\t\twhile(true) {\n\t\t\tfinal String line = reader.readLine();\n\t\t\t\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tfinal Matcher matcher = filePattern.matcher(line);\n\t\t\tif (!matcher.matches()) {\n\t\t\t\tfinal Matcher newlineMatcher = newlinePattern.matcher(line);\n\t\t\t\tif (newlineMatcher.matches()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tthrow new ParseError(\"expected file line but got \\\"\" + line + \"\\\"\");\n\t\t\t}\n\t\t\t\n\t\t\tfinal String type = matcher.group(1);\n\t\t\tif (type.startsWith(\"-\")) {\n\t\t\t\tfinal TarEntry entry = new TarEntry(base + \"/\" + matcher.group(8));\n\n\t\t\t\t//entry.setGroupName(currentMatcher.group(2));\n\t\t\t\t\n\t\t\t\treturn entry;\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprivate Map parse( final InputStream pInput ) throws IOException, ParseError {\n\t\tfinal Map mapping = new HashMap();\n\t\t\n\t\tfinal BufferedReader reader = new BufferedReader(new InputStreamReader(pInput));\n\t\t\n\t\twhile(true) {\n\n\t\t\tfinal String base = readBase(reader);\n\n\t\t\tif (base == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treadTotal(reader);\n\t\t\tfinal TarEntry dir = readDir(reader, base);\n\t\t\tmapping.put(dir.getName(), dir);\n\n\t\t\twhile(true) {\n\t\t\t\tfinal TarEntry file = readFile(reader, base);\n\n\t\t\t\tif (file == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmapping.put(file.getName(), file);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mapping;\n\t}\n\t\n\tpublic TarEntry map( final TarEntry pEntry ) {\n\t\t\n\t\tfinal TarEntry entry = (TarEntry) mapping.get(pEntry.getName());\n\t\t\n\t\tif (entry != null) {\n\t\t\treturn entry;\n\t\t}\n\t\t\n\t\treturn pEntry;\n\t}\n\n}\n","lineNo":91}
{"Smelly Sample":"package org.vafer.jdeb;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarOutputStream;\nimport org.vafer.jdeb.ar.ArArchive;\nimport org.vafer.jdeb.ar.FileArEntry;\nimport org.vafer.jdeb.ar.StaticArEntry;\n\npublic class Processor {\n\n\tprivate final Console console;\n\t\n\tpublic Processor( Console pConsole ) {\n\t\tconsole = pConsole;\n\t}\n\t\n\tpublic void createDeb( File[] pControlFiles, DataProducer[] pData, OutputStream pDebOuput ) throws PackagingException {\n\n\t\tFile tempData = null;\n\t\tFile tempControl = null;\n\t\t\n\t\ttry {\n\t\t\ttempData = File.createTempFile(\"deb\", \"data\");\t\t\t\n\t\t\ttempControl = File.createTempFile(\"deb\", \"control\");\t\t\t\n\t\t\t\n\t\t\tconsole.println(\"building data\");\n\t\t\tfinal StringBuffer md5s = buildData(pData, tempData);\n\t\t\t\n\t\t\tconsole.println(\"building control\");\n\t\t\tbuildControl(pControlFiles, md5s, tempControl);\n\t\t\t\t\t\t\n\t\t\tfinal ArArchive ar = new ArArchive(pDebOuput);\n\t\t\tar.add(new StaticArEntry(\"debian-binary\", 0, 0, 33188, \"2.0\\n\"));\n\t\t\tar.add(new FileArEntry(tempControl,\"control.tar.gz\", 0, 0, 33188));\n\t\t\tar.add(new FileArEntry(tempData, \"data.tar.gz\", 0, 0, 33188));\n\t\t\tar.close();\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\tthrow new PackagingException(\"could not create deb package\", e);\n\t\t} finally {\n\t\t\tif (tempData != null) {\n\t\t\t\ttempData.delete();\n\t\t\t}\n\t\t\tif (tempControl != null) {\n\t\t\t\ttempControl.delete();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void buildControl( final File[] pControlFiles, final StringBuffer md5s, final File pOutput ) throws FileNotFoundException, IOException {\n\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(pOutput)));\n\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n\t\tfor (int i = 0; i < pControlFiles.length; i++) {\n\t\t\tfinal File file = pControlFiles[i];\n\n\t\t\tif (file.isDirectory()) {\n\t\t        return;\n\t\t    }\n\n\t\t\tfinal TarEntry entry = new TarEntry(file);\n\t\t\t\n\t\t\tentry.setName(file.getName());\n\t\t\t\n\t\t\tfinal InputStream inputStream = new FileInputStream(file);\n\n\t\t\toutputStream.putNextEntry(entry);\n\n\t\t\tUtils.copy(inputStream, outputStream);\t\t\t\t\t\t\t\t\n\t\t\t\n\t\t\toutputStream.closeEntry();\n\t\t\t\n\t\t\tinputStream.close();\n\t\t\t\n\t\t}\n\n\t\tfinal byte[] data = md5s.toString().getBytes(\"UTF-8\");\n\t\t\n\t\tfinal TarEntry entry = new TarEntry(\"md5sums\");\n\t\tentry.setSize(data.length);\n\n\t\toutputStream.putNextEntry(entry);\n\t\toutputStream.write(data);\n\t\toutputStream.closeEntry();\n\t\t\n\t\toutputStream.close();\n\t\t\n\t}\n\t\n\tprivate StringBuffer buildData( final DataProducer[] pData, final File pOutput ) throws NoSuchAlgorithmException, IOException {\n\t\tfinal StringBuffer md5s = new StringBuffer();\n\t\t\n\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(pOutput)));\n\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n\t\tfinal MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\n\t\tfinal DataConsumer receiver = new DataConsumer() {\n\t\t\tpublic void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n\n\t\t\t\tfinal TarEntry entry = new TarEntry(filename);\n\t\t\t\t\n\t\t\t\t// link?\n\t\t\t\tentry.setUserName(user);\n\t\t\t\tentry.setUserId(uid);\n\t\t\t\tentry.setUserName(group);\n\t\t\t\tentry.setUserId(gid);\n\t\t\t\tentry.setMode(mode);\n\t\t\t\tentry.setSize(inputStream == null?0:size);\n\n\t\t\t\toutputStream.putNextEntry(entry);\n\t\t\t\t\n\t\t\t    if (inputStream == null) {\n\t\t\t\t\tconsole.println(\"dir: \" + filename);\n\n\t\t\t\t    outputStream.closeEntry();\n\t\t\t\t    return;\n\t\t\t\t}\n\t\t\t    \n\t\t\t    digest.reset();\n\t\t\t    \n\t\t\t\tUtils.copy(inputStream, new DigestOutputStream(outputStream, digest));\n\t\t\t\t\n\t\t\t\tfinal String md5 = Utils.toHex(digest.digest());\n\t\t\t\t\n\t\t\t\toutputStream.closeEntry();\n\n\t\t\t\tconsole.println(\n\t\t\t\t\t\t\"file:\" + entry.getName() +\n\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\" modtime:\" + entry.getModTime() +\n\t\t\t\t\t\t\" md5: \" + md5\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tmd5s.append(md5).append(\" \").append(entry.getName()).append('\\n');\n\n\t\t\t}\t\t\t\t\t\n\t\t};\n\n\t\tfor (int i = 0; i < pData.length; i++) {\n\t\t\tfinal DataProducer data = pData[i];\n\t\t\tdata.produce(receiver);\n\t\t}\n\n\t\toutputStream.close();\n\n\t\treturn md5s;\n\t}\n\t\n\n\n}\n","Method after Refactoring":"package org.vafer.jdeb;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.ParseException;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarOutputStream;\nimport org.vafer.jdeb.ar.ArArchive;\nimport org.vafer.jdeb.ar.FileArEntry;\nimport org.vafer.jdeb.ar.StaticArEntry;\nimport org.vafer.jdeb.descriptors.ChangesDescriptor;\nimport org.vafer.jdeb.descriptors.PackageDescriptor;\n\npublic class Processor {\n\n\tprivate final Console console;\n\t\t\n\tpublic Processor( Console pConsole ) {\n\t\tconsole = pConsole;\n\t}\n\t\n\tpublic ChangesDescriptor createDeb( File[] pControlFiles, DataProducer[] pData, OutputStream pDebOuput ) throws PackagingException {\n\t\t\n\t\tFile tempData = null;\n\t\tFile tempControl = null;\n\t\t\n\t\ttry {\n\t\t\ttempData = File.createTempFile(\"deb\", \"data\");\t\t\t\n\t\t\ttempControl = File.createTempFile(\"deb\", \"control\");\t\t\t\n\t\t\t\n\t\t\tconsole.println(\"building data\");\n\t\t\tfinal StringBuffer md5s = buildData(pData, tempData);\n\t\t\t\n\t\t\tconsole.println(\"building control\");\n\t\t\tfinal PackageDescriptor packageDescriptor = buildControl(pControlFiles, md5s, tempControl);\n\t\t\t\t\t\t\n\t\t\tfinal ArArchive ar = new ArArchive(pDebOuput);\n\t\t\tar.add(new StaticArEntry(\"debian-binary\", 0, 0, 33188, \"2.0\\n\"));\n\t\t\tar.add(new FileArEntry(tempControl,\"control.tar.gz\", 0, 0, 33188));\n\t\t\tar.add(new FileArEntry(tempData, \"data.tar.gz\", 0, 0, 33188));\n\t\t\tar.close();\n\t\t\t\n\t\t\tfinal ChangesDescriptor changesDescriptor = new ChangesDescriptor(packageDescriptor); \n\t\t\t\n\t\t\t// add deb to changes descriptor\n\t\t\t\n\t\t\treturn changesDescriptor;\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\tthrow new PackagingException(\"could not create deb package\", e);\n\t\t} finally {\n\t\t\tif (tempData != null) {\n\t\t\t\ttempData.delete();\n\t\t\t}\n\t\t\tif (tempControl != null) {\n\t\t\t\ttempControl.delete();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void createChanges( ChangesDescriptor changesDescriptor, OutputStream pChangesOutput ) throws IOException {\n\t\t// sign changes\n\n\t\t// TODO:\n\t\t\n\t\t// write out\t\t\n\t\tpChangesOutput.write(changesDescriptor.toString().getBytes());\n\t}\n\t\n\tprivate PackageDescriptor buildControl( final File[] pControlFiles, final StringBuffer md5s, final File pOutput ) throws FileNotFoundException, IOException, ParseException {\n\t\t\n\t\tPackageDescriptor packageDescriptor = null;\n\t\t\n\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(pOutput)));\n\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n\t\tfor (int i = 0; i < pControlFiles.length; i++) {\n\t\t\tfinal File file = pControlFiles[i];\n\n\t\t\tif (file.isDirectory()) {\n\t\t        break;\n\t\t    }\n\n\t\t\tfinal TarEntry entry = new TarEntry(file);\n\t\t\t\n\t\t\tfinal String name = file.getName();\n\t\t\t\n\t\t\tentry.setName(name);\n\t\t\t\n\t\t\tif (\"control\".equals(name)) {\n\t\t\t\tpackageDescriptor = new PackageDescriptor(new FileInputStream(file));\n\t\t\t\tcontinue;\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tfinal InputStream inputStream = new FileInputStream(file);\n\n\t\t\toutputStream.putNextEntry(entry);\n\n\t\t\tUtils.copy(inputStream, outputStream);\t\t\t\t\t\t\t\t\n\t\t\t\n\t\t\toutputStream.closeEntry();\n\t\t\t\n\t\t\tinputStream.close();\n\t\t\t\n\t\t}\n\n\t\tif (packageDescriptor == null) {\n\t\t\tpackageDescriptor = new PackageDescriptor();\n\t\t}\n\t\t\n\t\taddEntry(\"control\", packageDescriptor.toString(), outputStream);\n\t\t\n\t\taddEntry(\"md5sums\", md5s.toString(), outputStream);\n\t\t\n\t\toutputStream.close();\n\t\t\n\t\treturn packageDescriptor;\n\t}\n\n\tprivate void addEntry( String name, String content, TarOutputStream outputStream ) throws IOException {\n\t\tfinal byte[] data = content.getBytes(\"UTF-8\");\n\t\t\n\t\tfinal TarEntry entry = new TarEntry(name);\n\t\tentry.setSize(data.length);\n\n\t\toutputStream.putNextEntry(entry);\n\t\toutputStream.write(data);\n\t\toutputStream.closeEntry();\t\t\n\t}\n\t\n\tprivate StringBuffer buildData( final DataProducer[] pData, final File pOutput ) throws NoSuchAlgorithmException, IOException {\n\t\tfinal StringBuffer md5s = new StringBuffer();\n\t\t\n\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(pOutput)));\n\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n\t\tfinal MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\n\t\tfinal BigInteger totalSize = BigInteger.ZERO;\n\t\t\n\t\tfinal DataConsumer receiver = new DataConsumer() {\n\t\t\tpublic void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException {\n\n\t\t\t\tfinal TarEntry entry = new TarEntry(filename);\n\t\t\t\t\n\t\t\t\t// link?\n\t\t\t\tentry.setUserName(user);\n\t\t\t\tentry.setUserId(uid);\n\t\t\t\tentry.setUserName(group);\n\t\t\t\tentry.setUserId(gid);\n\t\t\t\tentry.setMode(mode);\n\t\t\t\tentry.setSize(inputStream == null?0:size);\n\n\t\t\t\toutputStream.putNextEntry(entry);\n\t\t\t\t\n\t\t\t    if (inputStream == null) {\n\t\t\t\t\tconsole.println(\"dir: \" + filename);\n\n\t\t\t\t    outputStream.closeEntry();\n\t\t\t\t    return;\n\t\t\t\t}\n\t\t\t    \n\t\t\t    totalSize.add(BigInteger.valueOf(size));\n\t\t\t    \n\t\t\t    digest.reset();\n\t\t\t    \n\t\t\t\tUtils.copy(inputStream, new DigestOutputStream(outputStream, digest));\n\t\t\t\t\n\t\t\t\tfinal String md5 = Utils.toHex(digest.digest());\n\t\t\t\t\n\t\t\t\toutputStream.closeEntry();\n\n\t\t\t\tconsole.println(\n\t\t\t\t\t\t\"file:\" + entry.getName() +\n\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\" modtime:\" + entry.getModTime() +\n\t\t\t\t\t\t\" md5: \" + md5\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tmd5s.append(md5).append(\" \").append(entry.getName()).append('\\n');\n\n\t\t\t}\t\t\t\t\t\n\t\t};\n\n\t\tfor (int i = 0; i < pData.length; i++) {\n\t\t\tfinal DataProducer data = pData[i];\n\t\t\tdata.produce(receiver);\n\t\t}\n\n\t\toutputStream.close();\n\n\t\tconsole.println(\"total size: \" + totalSize);\n\t\t\n\t\treturn md5s;\n\t}\n\t\n\n\n}\n","lineNo":97}
{"Smelly Sample":"package org.vafer.jdeb;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.apache.tools.tar.TarOutputStream;\nimport org.vafer.jdeb.ar.ArArchive;\nimport org.vafer.jdeb.ar.FileArEntry;\nimport org.vafer.jdeb.ar.StaticArEntry;\n\npublic class DebAntTask extends Task {\n\n    private File deb;\n    private File control;\n\n    private Collection dataCollection = new ArrayList();\n    \n    \n    public void setDestfile(File deb) {\n    \tthis.deb = deb;\n    }\n    \n    public void setControl(File control) {\n    \tthis.control = control;\n    }\n    \n\t\n    public static class Data {\n    \t\n    \tprivate String prefix = \"\";\n    \tprivate int strip = 0;\n    \tprivate File data;\n    \t\n    \tpublic void setStrip(int strip) {\n    \t\tthis.strip = strip;\n    \t}\n    \t\n    \tpublic void setPrefix(String prefix) {\n    \t\tif (!prefix.endsWith(\"/\")) {\n        \t\tthis.prefix = prefix + \"/\";\n        \t\treturn;\n    \t\t}\n    \t\t\n    \t\tthis.prefix = prefix;\n    \t}\n    \t\n    \tpublic void setSrc(File data) {\n    \t\tthis.data = data;\n    \t}\n    \t\n    \tpublic File getFile() {\n    \t\treturn data;\n    \t}\n    \t\n    \tpublic int getStrip() {\n    \t\treturn strip;\n    \t}\n    \t\n    \tpublic String getPrefix() {\n    \t\treturn prefix;\n    \t}\n    \t\n    \tpublic String toString() {\n    \t\treturn data.toString();\n    \t}\n    }\n    \n    \n    public void addData(Data data) {\n    \tdataCollection.add(data);\n    }\n    \n    \n\tpublic void execute() {\n\t\t\n\t\tif (control == null || !control.isDirectory()) {\n\t\t\tthrow new BuildException(\"you need to point the 'control' attribute to the control directory\");\n\t\t}\n\t\t\t\t\n\t\tif (dataCollection.size() == 0) {\n\t\t\tthrow new BuildException(\"you need to provide at least one pointer to a tgz or directory with the data\");\n\t\t}\n\n\t\tif (deb == null) {\n\t\t\tthrow new BuildException(\"you need to point the 'destfile' attribute to where the deb is supposed to be created\");\n\t\t}\n\n\t\tFile tempData = null;\n\t\tFile tempControl = null;\n\t\t\n\t\ttry {\n\t\t\ttempData = File.createTempFile(\"deb\", \"data\");\n\t\t\ttempControl = File.createTempFile(\"deb\", \"control\");\n\n\t\t\t\n\t\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(tempData)));\n\t\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\t\t\t\n\t\t\tfinal StringBuffer md5sum = new StringBuffer();\n\n\n\t\t\tfor (Iterator it = dataCollection.iterator(); it.hasNext();) {\n\t\t\t\tfinal Data data = (Data) it.next();\n\n\t\t\t\tlog(\"*** adding data from \" + data);\n\t\t\t\t\n\t\t\t\tbuildData(data, outputStream, md5sum);\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\toutputStream.close();\n\t\t\t\n\t\t\tbuildControl(control, md5sum.toString(), tempControl);\n\t\t\t\t\t\t\n\t\t\tArArchive ar = new ArArchive(new FileOutputStream(deb));\n\t\t\tar.add(new StaticArEntry(\"debian-binary\",  0, 0, 33188, \"2.0\\n\"));\n\t\t\tar.add(new FileArEntry(tempControl, \"control.tar.gz\", 0, 0, 33188));\n\t\t\tar.add(new FileArEntry(tempData, \"data.tar.gz\", 0, 0, 33188));\n\t\t\tar.close();\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\t\n\t\t\tif (tempData != null) {\n\t\t\t\ttempData.delete();\n\t\t\t}\n\n\t\t\tif (tempControl != null) {\n\t\t\t\ttempControl.delete();\n\t\t\t}\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t\t\n\t\t\tthrow new BuildException(\"could not create deb package\", e);\n\t\t}\n\t}\n\t\n\tprivate static interface FileVisitor {\n\t\tvoid visit( File file );\n\t}\n\t\n\t\n\tprivate void iterate( File dir, FileVisitor visitor) {\n\n\t\t// FIXME: make configurable\n\t\tif (\".svn\".equals(dir.getName())) {\t\t\t\t\n\t\t\treturn;\n\t\t}\t\t\n\t\t\n\t    visitor.visit(dir);\n\n\t\tif (dir.isDirectory()) {\n\t\t\t\n\t\t\tFile[] childs = dir.listFiles();\n\t\t\tfor (int i = 0; i < childs.length; i++) {\n\t\t\t\titerate(childs[i], visitor);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate String stripPath( final int p, final String s ) {\n\t\t\n\t\tif (p<=0) {\n\t\t\treturn s;\n\t\t}\n\t\t\n\t\tint x = 0;\n\t\tfor (int i=0 ; i<p; i++) {\n\t\t\tx = s.indexOf('/', x);\n\t\t\tif (x < 0) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn s.substring(x+1);\n\t}\n\t\n\tprivate void buildData( final Data srcData, final TarOutputStream outputStream, final StringBuffer md5sum ) throws Exception {\n\t\tfinal File src = srcData.getFile();\n\t\t\n\t\tif (!src.exists()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// FIXME: merge both cases via visitor\n\t\tif (src.isFile()) {\n\t\t\tfinal TarInputStream inputStream = new TarInputStream(new GZIPInputStream(new FileInputStream(src)));\n\t\t\t\n\t\t\tfinal MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\n\t\t\twhile(true) {\n\t\t\t\tfinal TarEntry entry = inputStream.getNextEntry();\n\t\t\t\t\n\t\t\t\tif (entry == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tentry.setName(srcData.getPrefix() + stripPath(srcData.getStrip(), entry.getName()));\n\n\t\t\t\toutputStream.putNextEntry(entry);\n\t\n\t\t\t\tdigest.reset();\n\n\t\t\t\tcopy(inputStream, new DigestOutputStream(outputStream, digest));\n\t\t\t\t\t\t\t\t\n\t\t\t\tlog(\"adding data file name:\" + entry.getName() +\n\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\" modtime:\" + entry.getModTime() +\n\t\t\t\t\t\t\" md5: \" + toHex(digest.digest())\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\toutputStream.closeEntry();\n\t\t\t\t\n\t\t\t\tmd5sum.append(entry.getName()).append(\" \").append(toHex(digest.digest())).append('\\n');\n\t\t\t}\n\t\t\t\n\t\t\tinputStream.close();\n\t\t} else {\n\n\t\t\tfinal MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\n\t\t\titerate(src, new FileVisitor() {\n\t\t\t\tpublic void visit( File file ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTarEntry entry = new TarEntry(file);\n\t\t\t\t\t\t\n\t\t\t\t\t\tString localName = file.getAbsolutePath().substring(src.getAbsolutePath().length());\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (\"\".equals(localName)) {\n\t\t\t\t\t\t    return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tentry.setName(srcData.getPrefix() + stripPath(srcData.getStrip(), localName.substring(1)));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (file.isDirectory()) {\n\t\t\t\t\t\t    log(\"adding data directory name:\" + entry.getName() +\n\t\t\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\t\t\" modtime:\" + entry.getModTime()\n\t\t\t\t\t\t        );\n\t\t\t\t\t\t    outputStream.putNextEntry(entry);\n\t\t\t\t\t\t    outputStream.closeEntry();\n\t\t\t\t\t\t    return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tInputStream inputStream = new FileInputStream(file);\n\t\t\t\t\t\t\n\t\t\t\t\t\tlog(\"adding data file name:\" + entry.getName() +\n\t\t\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\t\t\" modtime:\" + entry.getModTime() +\n\t\t\t\t\t\t\t\t\" md5: \" + toHex(digest.digest())\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\toutputStream.putNextEntry(entry);\n\t\t\t\n\t\t\t\t\t\tdigest.reset();\n\n\t\t\t\t\t\tcopy(inputStream, new DigestOutputStream(outputStream, digest));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\toutputStream.closeEntry();\n\t\t\t\t\t\t\n\t\t\t\t\t\tmd5sum.append(entry.getName()).append(\" \").append(toHex(digest.digest())).append('\\n');\n\n\t\t\t\t\t\tinputStream.close();\n\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t});\t\t\t\t\t\t\n\t\t}\t\t\n\t}\n\t\n\t\n\tprivate void buildControl( final File src, final String digests, final File dst ) throws Exception {\n\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(dst)));\n\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n\t\titerate(src, new FileVisitor() {\n\t\t\tpublic void visit( File file ) {\n\t\t\t    \n\t\t\t    if (file.isDirectory()) {\n\t\t\t        return;\n\t\t\t    }\n\t\t\t    \n\t\t\t\ttry {\n\t\t\t\t\tTarEntry entry = new TarEntry(file);\n\t\t\t\t\t\n\t\t\t\t\tentry.setName(file.getName());\n\t\t\t\t\t\n\t\t\t\t\tInputStream inputStream = new FileInputStream(file);\n\n\t\t\t\t\tlog(\"adding control file \" + entry.getName());\n\n\t\t\t\t\toutputStream.putNextEntry(entry);\n\t\t\n\t\t\t\t\tcopy(inputStream, outputStream);\t\t\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\toutputStream.closeEntry();\n\t\t\t\t\t\n\t\t\t\t\tinputStream.close();\n\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\t\t});\n\n\t\tbyte[] data = digests.getBytes(\"UTF-8\");\n\t\t\n\t\tTarEntry entry = new TarEntry(\"md5sums\");\n\t\tentry.setSize(data.length);\n\n\t\tlog(\"adding control file \" + entry.getName());\n\n\t\toutputStream.putNextEntry(entry);\n\t\toutputStream.write(data);\n\t\toutputStream.closeEntry();\n\t\t\n\t\toutputStream.close();\n\t\t\n\t}\n\t\n    private static String toHex(byte[] b) {\n    \tfinal StringBuffer sb = new StringBuffer();\n\n    \tfor (int i = 0; i < b.length; ++i) {\n    \t\tsb.append(Integer.toHexString((b[i]>>4) & 0x0f));\n    \t\tsb.append(Integer.toHexString(b[i] & 0x0f));\n    \t}\n\n    \treturn sb.toString();\n    }\n    \n    private static int copy(InputStream input, OutputStream output) throws IOException {\n    \tbyte[] buffer = new byte[2048];\n    \tint count = 0;\n    \tint n = 0;\n    \twhile (-1 != (n = input.read(buffer))) {\n    \t\toutput.write(buffer, 0, n);\n    \t\tcount += n;\n    \t}\n    \treturn count;\n    }\n}\n","Method after Refactoring":"package org.vafer.jdeb;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.apache.tools.tar.TarOutputStream;\nimport org.vafer.jdeb.ar.ArArchive;\nimport org.vafer.jdeb.ar.FileArEntry;\nimport org.vafer.jdeb.ar.StaticArEntry;\n\npublic class DebAntTask extends Task {\n\n    private File deb;\n    private File control;\n\n    private Collection dataCollection = new ArrayList();\n    \n    \n    public void setDestfile(File deb) {\n    \tthis.deb = deb;\n    }\n    \n    public void setControl(File control) {\n    \tthis.control = control;\n    }\n    \n\t\n    public static class Data {\n    \t\n    \tprivate String prefix = \"\";\n    \tprivate int strip = 0;\n    \tprivate File data;\n    \t\n    \tpublic void setStrip(int strip) {\n    \t\tthis.strip = strip;\n    \t}\n    \t\n    \tpublic void setPrefix(String prefix) {\n    \t\tif (!prefix.endsWith(\"/\")) {\n        \t\tthis.prefix = prefix + \"/\";\n        \t\treturn;\n    \t\t}\n    \t\t\n    \t\tthis.prefix = prefix;\n    \t}\n    \t\n    \tpublic void setSrc(File data) {\n    \t\tthis.data = data;\n    \t}\n    \t\n    \tpublic File getFile() {\n    \t\treturn data;\n    \t}\n    \t\n    \tpublic int getStrip() {\n    \t\treturn strip;\n    \t}\n    \t\n    \tpublic String getPrefix() {\n    \t\treturn prefix;\n    \t}\n    \t\n    \tpublic String toString() {\n    \t\treturn data.toString();\n    \t}\n    }\n    \n    \n    public void addData(Data data) {\n    \tdataCollection.add(data);\n    }\n    \n    \n\tpublic void execute() {\n\t\t\n\t\tif (control == null || !control.isDirectory()) {\n\t\t\tthrow new BuildException(\"you need to point the 'control' attribute to the control directory\");\n\t\t}\n\t\t\t\t\n\t\tif (dataCollection.size() == 0) {\n\t\t\tthrow new BuildException(\"you need to provide at least one pointer to a tgz or directory with the data\");\n\t\t}\n\n\t\tif (deb == null) {\n\t\t\tthrow new BuildException(\"you need to point the 'destfile' attribute to where the deb is supposed to be created\");\n\t\t}\n\n\t\tFile tempData = null;\n\t\tFile tempControl = null;\n\t\t\n\t\ttry {\n\t\t\ttempData = File.createTempFile(\"deb\", \"data\");\n\t\t\ttempControl = File.createTempFile(\"deb\", \"control\");\n\t\t\t\n\t\t\ttempData.deleteOnExit();\n\t\t\ttempControl.deleteOnExit();\n\n\t\t\t\n\t\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(tempData)));\n\t\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\t\t\t\n\t\t\tfinal StringBuffer md5sum = new StringBuffer();\n\n\n\t\t\tfor (Iterator it = dataCollection.iterator(); it.hasNext();) {\n\t\t\t\tfinal Data data = (Data) it.next();\n\n\t\t\t\tlog(\"*** adding data from \" + data);\n\t\t\t\t\n\t\t\t\tbuildData(data, outputStream, md5sum);\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\toutputStream.close();\n\t\t\t\n\t\t\tbuildControl(control, md5sum.toString(), tempControl);\n\t\t\t\t\t\t\n\t\t\tArArchive ar = new ArArchive(new FileOutputStream(deb));\n\t\t\tar.add(new StaticArEntry(\"debian-binary\",  0, 0, 33188, \"2.0\\n\"));\n\t\t\tar.add(new FileArEntry(tempControl, \"control.tar.gz\", 0, 0, 33188));\n\t\t\tar.add(new FileArEntry(tempData, \"data.tar.gz\", 0, 0, 33188));\n\t\t\tar.close();\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t\t\n\t\t\tthrow new BuildException(\"could not create deb package\", e);\n\t\t}\n\t\t\n\t\tlog(\"created \" + deb);\n\t}\n\t\n\tprivate static interface FileVisitor {\n\t\tvoid visit( File file );\n\t}\n\t\n\t\n\tprivate void iterate( File dir, FileVisitor visitor) {\n\n\t\t// FIXME: make configurable\n\t\tif (\".svn\".equals(dir.getName())) {\t\t\t\t\n\t\t\treturn;\n\t\t}\t\t\n\t\t\n\t    visitor.visit(dir);\n\n\t\tif (dir.isDirectory()) {\n\t\t\t\n\t\t\tFile[] childs = dir.listFiles();\n\t\t\tfor (int i = 0; i < childs.length; i++) {\n\t\t\t\titerate(childs[i], visitor);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate String stripPath( final int p, final String s ) {\n\t\t\n\t\tif (p<=0) {\n\t\t\treturn s;\n\t\t}\n\t\t\n\t\tint x = 0;\n\t\tfor (int i=0 ; i<p; i++) {\n\t\t\tx = s.indexOf('/', x);\n\t\t\tif (x < 0) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn s.substring(x+1);\n\t}\n\t\n\tprivate String stripLeadingSlash( String s ) {\n\t\tif (s == null) {\n\t\t\treturn s;\n\t\t}\n\t\tif (s.length() == 0) {\n\t\t\treturn s;\n\t\t}\n\t\tif (s.charAt(0) == '/') {\n\t\t\treturn s.substring(1);\n\t\t}\n\t\treturn s;\n\t}\n\t\n\tprivate void buildData( final Data srcData, final TarOutputStream outputStream, final StringBuffer md5sum ) throws Exception {\n\t\tfinal File src = srcData.getFile();\n\t\t\n\t\tif (!src.exists()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// FIXME: merge both cases via visitor\n\t\tif (src.isFile()) {\n\t\t\tfinal TarInputStream inputStream = new TarInputStream(new GZIPInputStream(new FileInputStream(src)));\n\t\t\t\n\t\t\tfinal MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\n\t\t\twhile(true) {\n\t\t\t\tfinal TarEntry entry = inputStream.getNextEntry();\n\t\t\t\t\n\t\t\t\tif (entry == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tentry.setName(stripLeadingSlash(srcData.getPrefix() + stripPath(srcData.getStrip(), entry.getName())));\n\n\t\t\t\toutputStream.putNextEntry(entry);\n\t\t\t\t\t\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\t//copy(inputStream, outputStream);\n\t\t\t\t\toutputStream.closeEntry();\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\tdigest.reset();\n\t\n\t\t\t\t\tcopy(inputStream, new DigestOutputStream(outputStream, digest));\n\n\t\t\t\t\tString md5 = toHex(digest.digest());\n\t\t\t\t\t\n\t\t\t\t\tlog(\"adding data file name:\" + entry.getName() +\n\t\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\t\" modtime:\" + entry.getModTime() +\n\t\t\t\t\t\t\t\" md5: \" + md5 \n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\toutputStream.closeEntry();\n\t\t\t\t\t\n\t\t\t\t\tmd5sum.append(md5).append(\" \").append(entry.getName()).append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinputStream.close();\n\t\t} else {\n\n\t\t\tfinal MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\n\t\t\titerate(src, new FileVisitor() {\n\t\t\t\tpublic void visit( File file ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTarEntry entry = new TarEntry(file);\n\t\t\t\t\t\t\n\t\t\t\t\t\tString localName = file.getAbsolutePath().substring(src.getAbsolutePath().length());\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (\"\".equals(localName)) {\n\t\t\t\t\t\t    return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tentry.setName(stripLeadingSlash(srcData.getPrefix() + stripPath(srcData.getStrip(), localName.substring(1))));\n\t\t\t\t\t\t\n\t\t\t\t\t    outputStream.putNextEntry(entry);\n\n\t\t\t\t\t    if (file.isDirectory()) {\n\t\t\t\t\t\t    outputStream.closeEntry();\n\t\t\t\t\t\t    return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tInputStream inputStream = new FileInputStream(file);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdigest.reset();\n\n\t\t\t\t\t\tcopy(inputStream, new DigestOutputStream(outputStream, digest));\n\t\t\t\t\t\t\n\t\t\t\t\t\tString md5 = toHex(digest.digest());\n\t\t\t\t\t\t\n\t\t\t\t\t\toutputStream.closeEntry();\n\n\t\t\t\t\t\tlog(\"adding data file name:\" + entry.getName() +\n\t\t\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\t\t\" modtime:\" + entry.getModTime() +\n\t\t\t\t\t\t\t\t\" md5: \" + md5\n\t\t\t\t\t\t);\n\t\t\t\t\t\t\n\t\t\t\t\t\tmd5sum.append(md5).append(\" \").append(entry.getName()).append('\\n');\n\n\t\t\t\t\t\tinputStream.close();\n\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t});\t\t\t\t\t\t\n\t\t}\t\t\n\t}\n\t\n\t\n\tprivate void buildControl( final File src, final String digests, final File dst ) throws Exception {\n\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(dst)));\n\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n\t\titerate(src, new FileVisitor() {\n\t\t\tpublic void visit( File file ) {\n\t\t\t    \n\t\t\t    if (file.isDirectory()) {\n\t\t\t        return;\n\t\t\t    }\n\t\t\t    \n\t\t\t\ttry {\n\t\t\t\t\tTarEntry entry = new TarEntry(file);\n\t\t\t\t\t\n\t\t\t\t\tentry.setName(file.getName());\n\t\t\t\t\t\n\t\t\t\t\tInputStream inputStream = new FileInputStream(file);\n\n\t\t\t\t\tlog(\"adding control file \" + entry.getName());\n\n\t\t\t\t\toutputStream.putNextEntry(entry);\n\t\t\n\t\t\t\t\tcopy(inputStream, outputStream);\t\t\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\toutputStream.closeEntry();\n\t\t\t\t\t\n\t\t\t\t\tinputStream.close();\n\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\t\t});\n\n\t\tbyte[] data = digests.getBytes(\"UTF-8\");\n\t\t\n\t\tTarEntry entry = new TarEntry(\"md5sums\");\n\t\tentry.setSize(data.length);\n\n\t\tlog(\"adding control file \" + entry.getName());\n\n\t\toutputStream.putNextEntry(entry);\n\t\toutputStream.write(data);\n\t\toutputStream.closeEntry();\n\t\t\n\t\toutputStream.close();\n\t\t\n\t}\n\t\n    private static String toHex(byte[] b) {\n    \tfinal StringBuffer sb = new StringBuffer();\n\n    \tfor (int i = 0; i < b.length; ++i) {\n    \t\tsb.append(Integer.toHexString((b[i]>>4) & 0x0f));\n    \t\tsb.append(Integer.toHexString(b[i] & 0x0f));\n    \t}\n\n    \treturn sb.toString();\n    }\n    \n    private static int copy(InputStream input, OutputStream output) throws IOException {\n    \tbyte[] buffer = new byte[2048];\n    \tint count = 0;\n    \tint n = 0;\n    \twhile (-1 != (n = input.read(buffer))) {\n    \t\toutput.write(buffer, 0, n);\n    \t\tcount += n;\n    \t}\n    \treturn count;\n    }\n}\n","lineNo":234}
{"Smelly Sample":"package org.vafer.jdeb;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.apache.tools.tar.TarOutputStream;\nimport org.vafer.jdeb.ar.ArArchive;\nimport org.vafer.jdeb.ar.FileArEntry;\nimport org.vafer.jdeb.ar.StaticArEntry;\n\npublic class DebAntTask extends Task {\n\n    private File deb;\n    private File control;\n\n    private Collection dataCollection = new ArrayList();\n    \n    \n    public void setDestfile(File deb) {\n    \tthis.deb = deb;\n    }\n    \n    public void setControl(File control) {\n    \tthis.control = control;\n    }\n    \n\t\n    public static class Data {\n    \t\n    \tprivate String prefix = \"\";\n    \tprivate int strip = 0;\n    \tprivate File data;\n    \t\n    \tpublic void setStrip(int strip) {\n    \t\tthis.strip = strip;\n    \t}\n    \t\n    \tpublic void setPrefix(String prefix) {\n    \t\tif (!prefix.endsWith(\"/\")) {\n        \t\tthis.prefix = prefix + \"/\";\n        \t\treturn;\n    \t\t}\n    \t\t\n    \t\tthis.prefix = prefix;\n    \t}\n    \t\n    \tpublic void setSrc(File data) {\n    \t\tthis.data = data;\n    \t}\n    \t\n    \tpublic File getFile() {\n    \t\treturn data;\n    \t}\n    \t\n    \tpublic int getStrip() {\n    \t\treturn strip;\n    \t}\n    \t\n    \tpublic String getPrefix() {\n    \t\treturn prefix;\n    \t}\n    \t\n    \tpublic String toString() {\n    \t\treturn data.toString();\n    \t}\n    }\n    \n    \n    public void addData(Data data) {\n    \tdataCollection.add(data);\n    }\n    \n    \n\tpublic void execute() {\n\t\t\n\t\tif (control == null || !control.isDirectory()) {\n\t\t\tthrow new BuildException(\"you need to point the 'control' attribute to the control directory\");\n\t\t}\n\t\t\t\t\n\t\tif (dataCollection.size() == 0) {\n\t\t\tthrow new BuildException(\"you need to provide at least one pointer to a tgz or directory with the data\");\n\t\t}\n\n\t\tif (deb == null) {\n\t\t\tthrow new BuildException(\"you need to point the 'destfile' attribute to where the deb is supposed to be created\");\n\t\t}\n\n\t\tFile tempData = null;\n\t\tFile tempControl = null;\n\t\t\n\t\ttry {\n\t\t\ttempData = File.createTempFile(\"deb\", \"data\");\n\t\t\ttempControl = File.createTempFile(\"deb\", \"control\");\n\n\t\t\t\n\t\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(tempData)));\n\t\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\t\t\t\n\t\t\tfinal StringBuffer md5sum = new StringBuffer();\n\n\n\t\t\tfor (Iterator it = dataCollection.iterator(); it.hasNext();) {\n\t\t\t\tfinal Data data = (Data) it.next();\n\n\t\t\t\tlog(\"*** adding data from \" + data);\n\t\t\t\t\n\t\t\t\tbuildData(data, outputStream, md5sum);\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\toutputStream.close();\n\t\t\t\n\t\t\tbuildControl(control, md5sum.toString(), tempControl);\n\t\t\t\t\t\t\n\t\t\tArArchive ar = new ArArchive(new FileOutputStream(deb));\n\t\t\tar.add(new StaticArEntry(\"debian-binary\",  0, 0, 33188, \"2.0\\n\"));\n\t\t\tar.add(new FileArEntry(tempControl, \"control.tar.gz\", 0, 0, 33188));\n\t\t\tar.add(new FileArEntry(tempData, \"data.tar.gz\", 0, 0, 33188));\n\t\t\tar.close();\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\t\n\t\t\tif (tempData != null) {\n\t\t\t\ttempData.delete();\n\t\t\t}\n\n\t\t\tif (tempControl != null) {\n\t\t\t\ttempControl.delete();\n\t\t\t}\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t\t\n\t\t\tthrow new BuildException(\"could not create deb package\", e);\n\t\t}\n\t}\n\t\n\tprivate static interface FileVisitor {\n\t\tvoid visit( File file );\n\t}\n\t\n\t\n\tprivate void iterate( File dir, FileVisitor visitor) {\n\n\t\t// FIXME: make configurable\n\t\tif (\".svn\".equals(dir.getName())) {\t\t\t\t\n\t\t\treturn;\n\t\t}\t\t\n\t\t\n\t    visitor.visit(dir);\n\n\t\tif (dir.isDirectory()) {\n\t\t\t\n\t\t\tFile[] childs = dir.listFiles();\n\t\t\tfor (int i = 0; i < childs.length; i++) {\n\t\t\t\titerate(childs[i], visitor);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate String stripPath( final int p, final String s ) {\n\t\t\n\t\tif (p<=0) {\n\t\t\treturn s;\n\t\t}\n\t\t\n\t\tint x = 0;\n\t\tfor (int i=0 ; i<p; i++) {\n\t\t\tx = s.indexOf('/', x);\n\t\t\tif (x < 0) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn s.substring(x+1);\n\t}\n\t\n\tprivate void buildData( final Data srcData, final TarOutputStream outputStream, final StringBuffer md5sum ) throws Exception {\n\t\tfinal File src = srcData.getFile();\n\t\t\n\t\tif (!src.exists()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// FIXME: merge both cases via visitor\n\t\tif (src.isFile()) {\n\t\t\tfinal TarInputStream inputStream = new TarInputStream(new GZIPInputStream(new FileInputStream(src)));\n\t\t\t\n\t\t\tfinal MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\n\t\t\twhile(true) {\n\t\t\t\tfinal TarEntry entry = inputStream.getNextEntry();\n\t\t\t\t\n\t\t\t\tif (entry == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tentry.setName(srcData.getPrefix() + stripPath(srcData.getStrip(), entry.getName()));\n\n\t\t\t\toutputStream.putNextEntry(entry);\n\t\n\t\t\t\tdigest.reset();\n\n\t\t\t\tcopy(inputStream, new DigestOutputStream(outputStream, digest));\n\t\t\t\t\t\t\t\t\n\t\t\t\tlog(\"adding data file name:\" + entry.getName() +\n\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\" modtime:\" + entry.getModTime() +\n\t\t\t\t\t\t\" md5: \" + toHex(digest.digest())\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\toutputStream.closeEntry();\n\t\t\t\t\n\t\t\t\tmd5sum.append(entry.getName()).append(\" \").append(toHex(digest.digest())).append('\\n');\n\t\t\t}\n\t\t\t\n\t\t\tinputStream.close();\n\t\t} else {\n\n\t\t\tfinal MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\n\t\t\titerate(src, new FileVisitor() {\n\t\t\t\tpublic void visit( File file ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTarEntry entry = new TarEntry(file);\n\t\t\t\t\t\t\n\t\t\t\t\t\tString localName = file.getAbsolutePath().substring(src.getAbsolutePath().length());\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (\"\".equals(localName)) {\n\t\t\t\t\t\t    return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tentry.setName(srcData.getPrefix() + stripPath(srcData.getStrip(), localName.substring(1)));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (file.isDirectory()) {\n\t\t\t\t\t\t    log(\"adding data directory name:\" + entry.getName() +\n\t\t\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\t\t\" modtime:\" + entry.getModTime()\n\t\t\t\t\t\t        );\n\t\t\t\t\t\t    outputStream.putNextEntry(entry);\n\t\t\t\t\t\t    outputStream.closeEntry();\n\t\t\t\t\t\t    return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tInputStream inputStream = new FileInputStream(file);\n\t\t\t\t\t\t\n\t\t\t\t\t\tlog(\"adding data file name:\" + entry.getName() +\n\t\t\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\t\t\" modtime:\" + entry.getModTime() +\n\t\t\t\t\t\t\t\t\" md5: \" + toHex(digest.digest())\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\toutputStream.putNextEntry(entry);\n\t\t\t\n\t\t\t\t\t\tdigest.reset();\n\n\t\t\t\t\t\tcopy(inputStream, new DigestOutputStream(outputStream, digest));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\toutputStream.closeEntry();\n\t\t\t\t\t\t\n\t\t\t\t\t\tmd5sum.append(entry.getName()).append(\" \").append(toHex(digest.digest())).append('\\n');\n\n\t\t\t\t\t\tinputStream.close();\n\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t});\t\t\t\t\t\t\n\t\t}\t\t\n\t}\n\t\n\t\n\tprivate void buildControl( final File src, final String digests, final File dst ) throws Exception {\n\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(dst)));\n\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n\t\titerate(src, new FileVisitor() {\n\t\t\tpublic void visit( File file ) {\n\t\t\t    \n\t\t\t    if (file.isDirectory()) {\n\t\t\t        return;\n\t\t\t    }\n\t\t\t    \n\t\t\t\ttry {\n\t\t\t\t\tTarEntry entry = new TarEntry(file);\n\t\t\t\t\t\n\t\t\t\t\tentry.setName(file.getName());\n\t\t\t\t\t\n\t\t\t\t\tInputStream inputStream = new FileInputStream(file);\n\n\t\t\t\t\tlog(\"adding control file \" + entry.getName());\n\n\t\t\t\t\toutputStream.putNextEntry(entry);\n\t\t\n\t\t\t\t\tcopy(inputStream, outputStream);\t\t\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\toutputStream.closeEntry();\n\t\t\t\t\t\n\t\t\t\t\tinputStream.close();\n\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\t\t});\n\n\t\tbyte[] data = digests.getBytes(\"UTF-8\");\n\t\t\n\t\tTarEntry entry = new TarEntry(\"md5sums\");\n\t\tentry.setSize(data.length);\n\n\t\tlog(\"adding control file \" + entry.getName());\n\n\t\toutputStream.putNextEntry(entry);\n\t\toutputStream.write(data);\n\t\toutputStream.closeEntry();\n\t\t\n\t\toutputStream.close();\n\t\t\n\t}\n\t\n    private static String toHex(byte[] b) {\n    \tfinal StringBuffer sb = new StringBuffer();\n\n    \tfor (int i = 0; i < b.length; ++i) {\n    \t\tsb.append(Integer.toHexString((b[i]>>4) & 0x0f));\n    \t\tsb.append(Integer.toHexString(b[i] & 0x0f));\n    \t}\n\n    \treturn sb.toString();\n    }\n    \n    private static int copy(InputStream input, OutputStream output) throws IOException {\n    \tbyte[] buffer = new byte[2048];\n    \tint count = 0;\n    \tint n = 0;\n    \twhile (-1 != (n = input.read(buffer))) {\n    \t\toutput.write(buffer, 0, n);\n    \t\tcount += n;\n    \t}\n    \treturn count;\n    }\n}\n","Method after Refactoring":"package org.vafer.jdeb;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.apache.tools.tar.TarOutputStream;\nimport org.vafer.jdeb.ar.ArArchive;\nimport org.vafer.jdeb.ar.FileArEntry;\nimport org.vafer.jdeb.ar.StaticArEntry;\n\npublic class DebAntTask extends Task {\n\n    private File deb;\n    private File control;\n\n    private Collection dataCollection = new ArrayList();\n    \n    \n    public void setDestfile(File deb) {\n    \tthis.deb = deb;\n    }\n    \n    public void setControl(File control) {\n    \tthis.control = control;\n    }\n    \n\t\n    public static class Data {\n    \t\n    \tprivate String prefix = \"\";\n    \tprivate int strip = 0;\n    \tprivate File data;\n    \t\n    \tpublic void setStrip(int strip) {\n    \t\tthis.strip = strip;\n    \t}\n    \t\n    \tpublic void setPrefix(String prefix) {\n    \t\tif (!prefix.endsWith(\"/\")) {\n        \t\tthis.prefix = prefix + \"/\";\n        \t\treturn;\n    \t\t}\n    \t\t\n    \t\tthis.prefix = prefix;\n    \t}\n    \t\n    \tpublic void setSrc(File data) {\n    \t\tthis.data = data;\n    \t}\n    \t\n    \tpublic File getFile() {\n    \t\treturn data;\n    \t}\n    \t\n    \tpublic int getStrip() {\n    \t\treturn strip;\n    \t}\n    \t\n    \tpublic String getPrefix() {\n    \t\treturn prefix;\n    \t}\n    \t\n    \tpublic String toString() {\n    \t\treturn data.toString();\n    \t}\n    }\n    \n    \n    public void addData(Data data) {\n    \tdataCollection.add(data);\n    }\n    \n    \n\tpublic void execute() {\n\t\t\n\t\tif (control == null || !control.isDirectory()) {\n\t\t\tthrow new BuildException(\"you need to point the 'control' attribute to the control directory\");\n\t\t}\n\t\t\t\t\n\t\tif (dataCollection.size() == 0) {\n\t\t\tthrow new BuildException(\"you need to provide at least one pointer to a tgz or directory with the data\");\n\t\t}\n\n\t\tif (deb == null) {\n\t\t\tthrow new BuildException(\"you need to point the 'destfile' attribute to where the deb is supposed to be created\");\n\t\t}\n\n\t\tFile tempData = null;\n\t\tFile tempControl = null;\n\t\t\n\t\ttry {\n\t\t\ttempData = File.createTempFile(\"deb\", \"data\");\n\t\t\ttempControl = File.createTempFile(\"deb\", \"control\");\n\t\t\t\n\t\t\ttempData.deleteOnExit();\n\t\t\ttempControl.deleteOnExit();\n\n\t\t\t\n\t\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(tempData)));\n\t\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\t\t\t\n\t\t\tfinal StringBuffer md5sum = new StringBuffer();\n\n\n\t\t\tfor (Iterator it = dataCollection.iterator(); it.hasNext();) {\n\t\t\t\tfinal Data data = (Data) it.next();\n\n\t\t\t\tlog(\"*** adding data from \" + data);\n\t\t\t\t\n\t\t\t\tbuildData(data, outputStream, md5sum);\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\toutputStream.close();\n\t\t\t\n\t\t\tbuildControl(control, md5sum.toString(), tempControl);\n\t\t\t\t\t\t\n\t\t\tArArchive ar = new ArArchive(new FileOutputStream(deb));\n\t\t\tar.add(new StaticArEntry(\"debian-binary\",  0, 0, 33188, \"2.0\\n\"));\n\t\t\tar.add(new FileArEntry(tempControl, \"control.tar.gz\", 0, 0, 33188));\n\t\t\tar.add(new FileArEntry(tempData, \"data.tar.gz\", 0, 0, 33188));\n\t\t\tar.close();\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t\t\n\t\t\tthrow new BuildException(\"could not create deb package\", e);\n\t\t}\n\t\t\n\t\tlog(\"created \" + deb);\n\t}\n\t\n\tprivate static interface FileVisitor {\n\t\tvoid visit( File file );\n\t}\n\t\n\t\n\tprivate void iterate( File dir, FileVisitor visitor) {\n\n\t\t// FIXME: make configurable\n\t\tif (\".svn\".equals(dir.getName())) {\t\t\t\t\n\t\t\treturn;\n\t\t}\t\t\n\t\t\n\t    visitor.visit(dir);\n\n\t\tif (dir.isDirectory()) {\n\t\t\t\n\t\t\tFile[] childs = dir.listFiles();\n\t\t\tfor (int i = 0; i < childs.length; i++) {\n\t\t\t\titerate(childs[i], visitor);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate String stripPath( final int p, final String s ) {\n\t\t\n\t\tif (p<=0) {\n\t\t\treturn s;\n\t\t}\n\t\t\n\t\tint x = 0;\n\t\tfor (int i=0 ; i<p; i++) {\n\t\t\tx = s.indexOf('/', x);\n\t\t\tif (x < 0) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn s.substring(x+1);\n\t}\n\t\n\tprivate String stripLeadingSlash( String s ) {\n\t\tif (s == null) {\n\t\t\treturn s;\n\t\t}\n\t\tif (s.length() == 0) {\n\t\t\treturn s;\n\t\t}\n\t\tif (s.charAt(0) == '/') {\n\t\t\treturn s.substring(1);\n\t\t}\n\t\treturn s;\n\t}\n\t\n\tprivate void buildData( final Data srcData, final TarOutputStream outputStream, final StringBuffer md5sum ) throws Exception {\n\t\tfinal File src = srcData.getFile();\n\t\t\n\t\tif (!src.exists()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// FIXME: merge both cases via visitor\n\t\tif (src.isFile()) {\n\t\t\tfinal TarInputStream inputStream = new TarInputStream(new GZIPInputStream(new FileInputStream(src)));\n\t\t\t\n\t\t\tfinal MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\n\t\t\twhile(true) {\n\t\t\t\tfinal TarEntry entry = inputStream.getNextEntry();\n\t\t\t\t\n\t\t\t\tif (entry == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tentry.setName(stripLeadingSlash(srcData.getPrefix() + stripPath(srcData.getStrip(), entry.getName())));\n\n\t\t\t\toutputStream.putNextEntry(entry);\n\t\t\t\t\t\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\t//copy(inputStream, outputStream);\n\t\t\t\t\toutputStream.closeEntry();\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\tdigest.reset();\n\t\n\t\t\t\t\tcopy(inputStream, new DigestOutputStream(outputStream, digest));\n\n\t\t\t\t\tString md5 = toHex(digest.digest());\n\t\t\t\t\t\n\t\t\t\t\tlog(\"adding data file name:\" + entry.getName() +\n\t\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\t\" modtime:\" + entry.getModTime() +\n\t\t\t\t\t\t\t\" md5: \" + md5 \n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\toutputStream.closeEntry();\n\t\t\t\t\t\n\t\t\t\t\tmd5sum.append(md5).append(\" \").append(entry.getName()).append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinputStream.close();\n\t\t} else {\n\n\t\t\tfinal MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\n\t\t\titerate(src, new FileVisitor() {\n\t\t\t\tpublic void visit( File file ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTarEntry entry = new TarEntry(file);\n\t\t\t\t\t\t\n\t\t\t\t\t\tString localName = file.getAbsolutePath().substring(src.getAbsolutePath().length());\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (\"\".equals(localName)) {\n\t\t\t\t\t\t    return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tentry.setName(stripLeadingSlash(srcData.getPrefix() + stripPath(srcData.getStrip(), localName.substring(1))));\n\t\t\t\t\t\t\n\t\t\t\t\t    outputStream.putNextEntry(entry);\n\n\t\t\t\t\t    if (file.isDirectory()) {\n\t\t\t\t\t\t    outputStream.closeEntry();\n\t\t\t\t\t\t    return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tInputStream inputStream = new FileInputStream(file);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdigest.reset();\n\n\t\t\t\t\t\tcopy(inputStream, new DigestOutputStream(outputStream, digest));\n\t\t\t\t\t\t\n\t\t\t\t\t\tString md5 = toHex(digest.digest());\n\t\t\t\t\t\t\n\t\t\t\t\t\toutputStream.closeEntry();\n\n\t\t\t\t\t\tlog(\"adding data file name:\" + entry.getName() +\n\t\t\t\t\t\t\t\t\" size:\" + entry.getSize() +\n\t\t\t\t\t\t\t\t\" mode:\" + entry.getMode() +\n\t\t\t\t\t\t\t\t\" linkname:\" + entry.getLinkName() +\n\t\t\t\t\t\t\t\t\" username:\" + entry.getUserName() +\n\t\t\t\t\t\t\t\t\" userid:\" + entry.getUserId() +\n\t\t\t\t\t\t\t\t\" groupname:\" + entry.getGroupName() +\n\t\t\t\t\t\t\t\t\" groupid:\" + entry.getGroupId() +\n\t\t\t\t\t\t\t\t\" modtime:\" + entry.getModTime() +\n\t\t\t\t\t\t\t\t\" md5: \" + md5\n\t\t\t\t\t\t);\n\t\t\t\t\t\t\n\t\t\t\t\t\tmd5sum.append(md5).append(\" \").append(entry.getName()).append('\\n');\n\n\t\t\t\t\t\tinputStream.close();\n\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t});\t\t\t\t\t\t\n\t\t}\t\t\n\t}\n\t\n\t\n\tprivate void buildControl( final File src, final String digests, final File dst ) throws Exception {\n\t\tfinal TarOutputStream outputStream = new TarOutputStream(new GZIPOutputStream(new FileOutputStream(dst)));\n\t\toutputStream.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n\n\t\titerate(src, new FileVisitor() {\n\t\t\tpublic void visit( File file ) {\n\t\t\t    \n\t\t\t    if (file.isDirectory()) {\n\t\t\t        return;\n\t\t\t    }\n\t\t\t    \n\t\t\t\ttry {\n\t\t\t\t\tTarEntry entry = new TarEntry(file);\n\t\t\t\t\t\n\t\t\t\t\tentry.setName(file.getName());\n\t\t\t\t\t\n\t\t\t\t\tInputStream inputStream = new FileInputStream(file);\n\n\t\t\t\t\tlog(\"adding control file \" + entry.getName());\n\n\t\t\t\t\toutputStream.putNextEntry(entry);\n\t\t\n\t\t\t\t\tcopy(inputStream, outputStream);\t\t\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\toutputStream.closeEntry();\n\t\t\t\t\t\n\t\t\t\t\tinputStream.close();\n\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\t\t});\n\n\t\tbyte[] data = digests.getBytes(\"UTF-8\");\n\t\t\n\t\tTarEntry entry = new TarEntry(\"md5sums\");\n\t\tentry.setSize(data.length);\n\n\t\tlog(\"adding control file \" + entry.getName());\n\n\t\toutputStream.putNextEntry(entry);\n\t\toutputStream.write(data);\n\t\toutputStream.closeEntry();\n\t\t\n\t\toutputStream.close();\n\t\t\n\t}\n\t\n    private static String toHex(byte[] b) {\n    \tfinal StringBuffer sb = new StringBuffer();\n\n    \tfor (int i = 0; i < b.length; ++i) {\n    \t\tsb.append(Integer.toHexString((b[i]>>4) & 0x0f));\n    \t\tsb.append(Integer.toHexString(b[i] & 0x0f));\n    \t}\n\n    \treturn sb.toString();\n    }\n    \n    private static int copy(InputStream input, OutputStream output) throws IOException {\n    \tbyte[] buffer = new byte[2048];\n    \tint count = 0;\n    \tint n = 0;\n    \twhile (-1 != (n = input.read(buffer))) {\n    \t\toutput.write(buffer, 0, n);\n    \t\tcount += n;\n    \t}\n    \treturn count;\n    }\n}\n","lineNo":234}
