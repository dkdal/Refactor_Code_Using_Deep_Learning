{"Smelly Sample":"/*\n * YUI Compressor\n * http://developer.yahoo.com/yui/compressor/\n * Author: Julien Lecomte -  http://www.julienlecomte.net/\n * Author: Isaac Schlueter - http://foohack.com/\n * Author: Stoyan Stefanov - http://phpied.com/\n * Contributor: Dan Beam - http://danbeam.org/\n * Copyright (c) 2013 Yahoo! Inc.  All rights reserved.\n * The copyrights embodied in the content of this file are licensed\n * by Yahoo! Inc. under the BSD (revised) open source license.\n */\npackage com.yahoo.platform.yui.compressor;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.ArrayList;\n\npublic class CssCompressor {\n\n    private StringBuffer srcsb = new StringBuffer();\n\n    public CssCompressor(Reader in) throws IOException {\n        // Read the stream...\n        int c;\n        while ((c = in.read()) != -1) {\n            srcsb.append((char) c);\n        }\n    }\n\n    /**\n     * @param css - full css string\n     * @param preservedToken - token to preserve\n     * @param tokenRegex - regex to find token\n     * @param removeWhiteSpace - remove any white space in the token\n     * @param preservedTokens - array of token values\n     * @return\n     */\n    protected String preserveToken(String css, String preservedToken,\n            String tokenRegex, boolean removeWhiteSpace, ArrayList preservedTokens) {\n\n        int maxIndex = css.length() - 1;\n        int appendIndex = 0;\n\n        StringBuffer sb = new StringBuffer();\n\n        Pattern p = Pattern.compile(tokenRegex);\n        Matcher m = p.matcher(css);\n\n        while (m.find()) {\n            int startIndex = m.start() + (preservedToken.length() + 1);\n            String terminator = m.group(1);\n\n            // skip this, if CSS was already copied to \"sb\" upto this position\n            if (m.start() < appendIndex) {\n                continue;\n            }\n\n            if (terminator.length() == 0) {\n                terminator = \")\";\n            }\n\n            boolean foundTerminator = false;\n\n            int endIndex = m.end() - 1;\n            while(foundTerminator == false && endIndex+1 <= maxIndex) {\n                endIndex = css.indexOf(terminator, endIndex+1);\n\n                if (endIndex <= 0) {\n                    break;\n                } else if ((endIndex > 0) && (css.charAt(endIndex-1) != '\\\\')) {\n                    foundTerminator = true;\n                    if (!\")\".equals(terminator)) {\n                        endIndex = css.indexOf(\")\", endIndex);\n                    }\n                }\n            }\n\n            // Enough searching, start moving stuff over to the buffer\n            sb.append(css.substring(appendIndex, m.start()));\n\n            if (foundTerminator) {\n                String token = css.substring(startIndex, endIndex);\n                if(removeWhiteSpace)\n                    token = token.replaceAll(\"\\\\s+\", \"\");\n                preservedTokens.add(token);\n\n                String preserver = preservedToken + \"(___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___)\";\n                sb.append(preserver);\n\n                appendIndex = endIndex + 1;\n            } else {\n                // No end terminator found, re-add the whole match. Should we throw/warn here?\n                sb.append(css.substring(m.start(), m.end()));\n                appendIndex = m.end();\n            }\n        }\n\n        sb.append(css.substring(appendIndex));\n\n        return sb.toString();\n    }\n\n    public void compress(Writer out, int linebreakpos)\n            throws IOException {\n\n        Pattern p;\n        Matcher m;\n        String css = srcsb.toString();\n\n        int startIndex = 0;\n        int endIndex = 0;\n        int i = 0;\n        int max = 0;\n        ArrayList preservedTokens = new ArrayList(0);\n        ArrayList comments = new ArrayList(0);\n        String token;\n        int totallen = css.length();\n        String placeholder;\n\n\n        StringBuffer sb = new StringBuffer(css);\n\n        // collect all comment blocks...\n        while ((startIndex = sb.indexOf(\"/*\", startIndex)) >= 0) {\n            endIndex = sb.indexOf(\"*/\", startIndex + 2);\n            if (endIndex < 0) {\n                endIndex = totallen;\n            }\n\n            token = sb.substring(startIndex + 2, endIndex);\n            comments.add(token);\n            sb.replace(startIndex + 2, endIndex, \"___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_\" + (comments.size() - 1) + \"___\");\n            startIndex += 2;\n        }\n        css = sb.toString();\n\n\n        css = this.preserveToken(css, \"url\", \"(?i)url\\\\(\\\\s*([\\\"']?)data\\\\:\", true, preservedTokens);\n        css = this.preserveToken(css, \"calc\",  \"(?i)calc\\\\(\\\\s*([\\\"']?)\", false, preservedTokens);\n        css = this.preserveToken(css, \"progid:DXImageTransform.Microsoft.Matrix\",  \"(?i)progid:DXImageTransform.Microsoft.Matrix\\\\s*([\\\"']?)\", false, preservedTokens);\n\n\n        // preserve strings so their content doesn't get accidentally minified\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(\\\"([^\\\\\\\\\\\"]|\\\\\\\\.|\\\\\\\\)*\\\")|(\\'([^\\\\\\\\\\']|\\\\\\\\.|\\\\\\\\)*\\')\");\n        m = p.matcher(css);\n        while (m.find()) {\n            token = m.group();\n            char quote = token.charAt(0);\n            token = token.substring(1, token.length() - 1);\n\n            // maybe the string contains a comment-like substring?\n            // one, maybe more? put'em back then\n            if (token.indexOf(\"___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_\") >= 0) {\n                for (i = 0, max = comments.size(); i < max; i += 1) {\n                    token = token.replace(\"___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_\" + i + \"___\", comments.get(i).toString());\n                }\n            }\n\n            // minify alpha opacity in filter strings\n            token = token.replaceAll(\"(?i)progid:DXImageTransform.Microsoft.Alpha\\\\(Opacity=\", \"alpha(opacity=\");\n\n            preservedTokens.add(token);\n            String preserver = quote + \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\" + quote;\n            m.appendReplacement(sb, preserver);\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n\n        // strings are safe, now wrestle the comments\n        for (i = 0, max = comments.size(); i < max; i += 1) {\n\n            token = comments.get(i).toString();\n            placeholder = \"___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_\" + i + \"___\";\n\n            // ! in the first position of the comment means preserve\n            // so push to the preserved tokens while stripping the !\n            if (token.startsWith(\"!\")) {\n                preservedTokens.add(token);\n                css = css.replace(placeholder,  \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\");\n                continue;\n            }\n\n            // \\ in the last position looks like hack for Mac/IE5\n            // shorten that to /*\\*/ and the next one to /**/\n            if (token.endsWith(\"\\\\\")) {\n                preservedTokens.add(\"\\\\\");\n                css = css.replace(placeholder,  \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\");\n                i = i + 1; // attn: advancing the loop\n                preservedTokens.add(\"\");\n                css = css.replace(\"___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_\" + i + \"___\",  \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\");\n                continue;\n            }\n\n            // keep empty comments after child selectors (IE7 hack)\n            // e.g. html >/**/ body\n            if (token.length() == 0) {\n                startIndex = css.indexOf(placeholder);\n                if (startIndex > 2) {\n                    if (css.charAt(startIndex - 3) == '>') {\n                        preservedTokens.add(\"\");\n                        css = css.replace(placeholder,  \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\");\n                    }\n                }\n            }\n\n            // in all other cases kill the comment\n            css = css.replace(\"/*\" + placeholder + \"*/\", \"\");\n        }\n\n        // preserve \\9 IE hack\n        final String backslash9 = \"\\\\9\"; \n        while (css.indexOf(backslash9) > -1) {\n            preservedTokens.add(backslash9);\n            css = css.replace(backslash9,  \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\");\n     \t}\n        \n        // Normalize all whitespace strings to single spaces. Easier to work with that way.\n        css = css.replaceAll(\"\\\\s+\", \" \");\n\n        // Remove the spaces before the things that should not have spaces before them.\n        // But, be careful not to turn \"p :link {...}\" into \"p:link{...}\"\n        // Swap out any pseudo-class colons with the token, and then swap back.\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(^|\\\\})(([^\\\\{:])+:)+([^\\\\{]*\\\\{)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            String s = m.group();\n            s = s.replaceAll(\":\", \"___YUICSSMIN_PSEUDOCLASSCOLON___\");\n            s = s.replaceAll( \"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\" ).replaceAll( \"\\\\$\", \"\\\\\\\\\\\\$\" );\n            m.appendReplacement(sb, s);\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n        // Remove spaces before the things that should not have spaces before them.\n        css = css.replaceAll(\"\\\\s+([!{};:>+\\\\(\\\\)\\\\],])\", \"$1\");\n        // Restore spaces for !important\n        css = css.replaceAll(\"!important\", \" !important\");\n        // bring back the colon\n        css = css.replaceAll(\"___YUICSSMIN_PSEUDOCLASSCOLON___\", \":\");\n\n        // retain space for special IE6 cases\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i):first\\\\-(line|letter)(\\\\{|,)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, \":first-\" + m.group(1).toLowerCase() + \" \" + m.group(2));\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // no space after the end of a preserved comment\n        css = css.replaceAll(\"\\\\*/ \", \"*/\");\n\n        // If there are multiple @charset directives, push them to the top of the file.\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)^(.*)(@charset)( \\\"[^\\\"]*\\\";)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, m.group(2).toLowerCase() + m.group(3) + m.group(1));\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // When all @charset are at the top, remove the second and after (as they are completely ignored).\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)^((\\\\s*)(@charset)( [^;]+;\\\\s*))+\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, m.group(2) + m.group(3).toLowerCase() + m.group(4));\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // lowercase some popular @directives (@charset is done right above)\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)@(font-face|import|(?:-(?:atsc|khtml|moz|ms|o|wap|webkit)-)?keyframe|media|page|namespace)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, '@' + m.group(1).toLowerCase());\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // lowercase some more common pseudo-elements\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i):(active|after|before|checked|disabled|empty|enabled|first-(?:child|of-type)|focus|hover|last-(?:child|of-type)|link|only-(?:child|of-type)|root|:selection|target|visited)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, ':' + m.group(1).toLowerCase());\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // lowercase some more common functions\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i):(lang|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|(?:-(?:moz|webkit)-)?any)\\\\(\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, ':' + m.group(1).toLowerCase() + '(');\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // lower case some common function that can be values\n        // NOTE: rgb() isn't useful as we replace with #hex later, as well as and() is already done for us right after this\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)([:,\\\\( ]\\\\s*)(attr|color-stop|from|rgba|to|url|(?:-(?:atsc|khtml|moz|ms|o|wap|webkit)-)?(?:calc|max|min|(?:repeating-)?(?:linear|radial)-gradient)|-webkit-gradient)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, m.group(1) + m.group(2).toLowerCase());\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // Put the space back in some cases, to support stuff like\n        // @media screen and (-webkit-min-device-pixel-ratio:0){\n        css = css.replaceAll(\"(?i)\\\\band\\\\(\", \"and (\");\n\n        // Remove the spaces after the things that should not have spaces after them.\n        css = css.replaceAll(\"([!{}:;>+\\\\(\\\\[,])\\\\s+\", \"$1\");\n\n        // remove unnecessary semicolons\n        css = css.replaceAll(\";+}\", \"}\");\n\n        // Replace 0(px,em,%) with 0.\n        css = css.replaceAll(\"(?i)(^|[^.0-9])(?:0?\\\\.)?0(?:px|em|%|in|cm|mm|pc|pt|ex|deg|g?rad|m?s|k?hz)\", \"$10\");\n        // Replace x.0(px,em,%) with x(px,em,%).\n        css = css.replaceAll(\"([0-9])\\\\.0(px|em|%|in|cm|mm|pc|pt|ex|deg|g?rad|m?s|k?hz| |;)\", \"$1$2\");\n\n        // Replace 0 0 0 0; with 0.\n        css = css.replaceAll(\":0 0 0 0(;|})\", \":0$1\");\n        css = css.replaceAll(\":0 0 0(;|})\", \":0$1\");\n        css = css.replaceAll(\":0 0(;|})\", \":0$1\");\n\n\n        // Replace background-position:0; with background-position:0 0;\n        // same for transform-origin\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)(background-position|webkit-mask-position|transform-origin|webkit-transform-origin|moz-transform-origin|o-transform-origin|ms-transform-origin):0(;|})\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, m.group(1).toLowerCase() + \":0 0\" + m.group(2));\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // Replace 0.6 to .6, but only when preceded by : or a white-space\n        css = css.replaceAll(\"(:|\\\\s)0+\\\\.(\\\\d+)\", \"$1.$2\");\n\n        // Shorten colors from rgb(51,102,153) to #336699\n        // This makes it more likely that it'll get further compressed in the next step.\n        p = Pattern.compile(\"rgb\\\\s*\\\\(\\\\s*([0-9,\\\\s]+)\\\\s*\\\\)\");\n        m = p.matcher(css);\n        sb = new StringBuffer();\n        while (m.find()) {\n            String[] rgbcolors = m.group(1).split(\",\");\n            StringBuffer hexcolor = new StringBuffer(\"#\");\n            for (i = 0; i < rgbcolors.length; i++) {\n                int val = Integer.parseInt(rgbcolors[i]);\n                if (val < 16) {\n                    hexcolor.append(\"0\");\n                }\n\n                // If someone passes an RGB value that's too big to express in two characters, round down.\n                // Probably should throw out a warning here, but generating valid CSS is a bigger concern.\n                if (val > 255) {\n                    val = 255;\n                }\n                hexcolor.append(Integer.toHexString(val));\n            }\n            m.appendReplacement(sb, hexcolor.toString());\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // Shorten colors from #AABBCC to #ABC. Note that we want to make sure\n        // the color is not preceded by either \", \" or =. Indeed, the property\n        //     filter: chroma(color=\"#FFFFFF\");\n        // would become\n        //     filter: chroma(color=\"#FFF\");\n        // which makes the filter break in IE.\n        // We also want to make sure we're only compressing #AABBCC patterns inside { }, not id selectors ( #FAABAC {} )\n        // We also want to avoid compressing invalid values (e.g. #AABBCCD to #ABCD)\n        p = Pattern.compile(\"(\\\\=\\\\s*?[\\\"']?)?\" + \"#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\" + \"(:?\\\\}|[^0-9a-fA-F{][^{]*?\\\\})\");\n\n        m = p.matcher(css);\n        sb = new StringBuffer();\n        int index = 0;\n\n        while (m.find(index)) {\n\n            sb.append(css.substring(index, m.start()));\n\n            boolean isFilter = (m.group(1) != null && !\"\".equals(m.group(1)));\n\n            if (isFilter) {\n                // Restore, as is. Compression will break filters\n                sb.append(m.group(1) + \"#\" + m.group(2) + m.group(3) + m.group(4) + m.group(5) + m.group(6) + m.group(7));\n            } else {\n                if( m.group(2).equalsIgnoreCase(m.group(3)) &&\n                    m.group(4).equalsIgnoreCase(m.group(5)) &&\n                    m.group(6).equalsIgnoreCase(m.group(7))) {\n\n                    // #AABBCC pattern\n                    sb.append(\"#\" + (m.group(3) + m.group(5) + m.group(7)).toLowerCase());\n\n                } else {\n\n                    // Non-compressible color, restore, but lower case.\n                    sb.append(\"#\" + (m.group(2) + m.group(3) + m.group(4) + m.group(5) + m.group(6) + m.group(7)).toLowerCase());\n                }\n            }\n\n            index = m.end(7);\n        }\n\n        sb.append(css.substring(index));\n        css = sb.toString();\n\n        // Replace #f00 -> red\n        css = css.replaceAll(\"(:|\\\\s)(#f00)(;|})\", \"$1red$3\");\n        // Replace other short color keywords\n        css = css.replaceAll(\"(:|\\\\s)(#000080)(;|})\", \"$1navy$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#808080)(;|})\", \"$1gray$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#808000)(;|})\", \"$1olive$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#800080)(;|})\", \"$1purple$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#c0c0c0)(;|})\", \"$1silver$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#008080)(;|})\", \"$1teal$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#ffa500)(;|})\", \"$1orange$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#800000)(;|})\", \"$1maroon$3\");\n\n        // border: none -> border:0\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)(border|border-top|border-right|border-bottom|border-left|outline|background):none(;|})\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, m.group(1).toLowerCase() + \":0\" + m.group(2));\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // shorter opacity IE filter\n        css = css.replaceAll(\"(?i)progid:DXImageTransform.Microsoft.Alpha\\\\(Opacity=\", \"alpha(opacity=\");\n\n        // Find a fraction that is used for Opera's -o-device-pixel-ratio query\n        // Add token to add the \"\\\" back in later\n        css = css.replaceAll(\"\\\\(([\\\\-A-Za-z]+):([0-9]+)\\\\/([0-9]+)\\\\)\", \"($1:$2___YUI_QUERY_FRACTION___$3)\");\n\n        // Remove empty rules.\n        css = css.replaceAll(\"[^\\\\}\\\\{/;]+\\\\{\\\\}\", \"\");\n\n        // Add \"\\\" back to fix Opera -o-device-pixel-ratio query\n        css = css.replaceAll(\"___YUI_QUERY_FRACTION___\", \"/\");\n\n        // TODO: Should this be after we re-insert tokens. These could alter the break points. However then\n        // we'd need to make sure we don't break in the middle of a string etc.\n        if (linebreakpos >= 0) {\n            // Some source control tools don't like it when files containing lines longer\n            // than, say 8000 characters, are checked in. The linebreak option is used in\n            // that case to split long lines after a specific column.\n            i = 0;\n            int linestartpos = 0;\n            sb = new StringBuffer(css);\n            while (i < sb.length()) {\n                char c = sb.charAt(i++);\n                if (c == '}' && i - linestartpos > linebreakpos) {\n                    sb.insert(i, '\\n');\n                    linestartpos = i;\n                }\n            }\n\n            css = sb.toString();\n        }\n\n        // Replace multiple semi-colons in a row by a single one\n        // See SF bug #1980989\n        css = css.replaceAll(\";;+\", \";\");\n\n        // restore preserved comments and strings\n        for(i = 0, max = preservedTokens.size(); i < max; i++) {\n            css = css.replace(\"___YUICSSMIN_PRESERVED_TOKEN_\" + i + \"___\", preservedTokens.get(i).toString());\n        }\n\n        // Trim the final string (for any leading or trailing white spaces)\n        css = css.trim();\n\n        // Write the output...\n        out.write(css);\n    }\n}\n","Method after Refactoring":"/*\n * YUI Compressor\n * http://developer.yahoo.com/yui/compressor/\n * Author: Julien Lecomte -  http://www.julienlecomte.net/\n * Author: Isaac Schlueter - http://foohack.com/\n * Author: Stoyan Stefanov - http://phpied.com/\n * Contributor: Dan Beam - http://danbeam.org/\n * Copyright (c) 2013 Yahoo! Inc.  All rights reserved.\n * The copyrights embodied in the content of this file are licensed\n * by Yahoo! Inc. under the BSD (revised) open source license.\n */\npackage com.yahoo.platform.yui.compressor;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.ArrayList;\n\npublic class CssCompressor {\n\n    private StringBuffer srcsb = new StringBuffer();\n\n    public CssCompressor(Reader in) throws IOException {\n        // Read the stream...\n        int c;\n        while ((c = in.read()) != -1) {\n            srcsb.append((char) c);\n        }\n    }\n\n    /**\n     * @param css - full css string\n     * @param preservedToken - token to preserve\n     * @param tokenRegex - regex to find token\n     * @param removeWhiteSpace - remove any white space in the token\n     * @param preservedTokens - array of token values\n     * @return\n     */\n    protected String preserveToken(String css, String preservedToken,\n            String tokenRegex, boolean removeWhiteSpace, ArrayList preservedTokens) {\n\n        int maxIndex = css.length() - 1;\n        int appendIndex = 0;\n\n        StringBuffer sb = new StringBuffer();\n\n        Pattern p = Pattern.compile(tokenRegex);\n        Matcher m = p.matcher(css);\n\n        while (m.find()) {\n            int startIndex = m.start() + (preservedToken.length() + 1);\n            String terminator = m.group(1);\n\n            // skip this, if CSS was already copied to \"sb\" upto this position\n            if (m.start() < appendIndex) {\n                continue;\n            }\n\n            if (terminator.length() == 0) {\n                terminator = \")\";\n            }\n\n            boolean foundTerminator = false;\n\n            int endIndex = m.end() - 1;\n            while(foundTerminator == false && endIndex+1 <= maxIndex) {\n                endIndex = css.indexOf(terminator, endIndex+1);\n\n                if (endIndex <= 0) {\n                    break;\n                } else if ((endIndex > 0) && (css.charAt(endIndex-1) != '\\\\')) {\n                    foundTerminator = true;\n                    if (!\")\".equals(terminator)) {\n                        endIndex = css.indexOf(\")\", endIndex);\n                    }\n                }\n            }\n\n            // Enough searching, start moving stuff over to the buffer\n            sb.append(css.substring(appendIndex, m.start()));\n\n            if (foundTerminator) {\n                String token = css.substring(startIndex, endIndex);\n                if(removeWhiteSpace)\n                    token = token.replaceAll(\"\\\\s+\", \"\");\n                preservedTokens.add(token);\n\n                String preserver = preservedToken + \"(___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___)\";\n                sb.append(preserver);\n\n                appendIndex = endIndex + 1;\n            } else {\n                // No end terminator found, re-add the whole match. Should we throw/warn here?\n                sb.append(css.substring(m.start(), m.end()));\n                appendIndex = m.end();\n            }\n        }\n\n        sb.append(css.substring(appendIndex));\n\n        return sb.toString();\n    }\n\n    public void compress(Writer out, int linebreakpos)\n            throws IOException {\n\n        Pattern p;\n        Matcher m;\n        String css = srcsb.toString();\n\n        int startIndex = 0;\n        int endIndex = 0;\n        int i = 0;\n        int max = 0;\n        ArrayList preservedTokens = new ArrayList(0);\n        ArrayList comments = new ArrayList(0);\n        String token;\n        int totallen = css.length();\n        String placeholder;\n\n\n        StringBuffer sb = new StringBuffer(css);\n\n        // collect all comment blocks...\n        while ((startIndex = sb.indexOf(\"/*\", startIndex)) >= 0) {\n            endIndex = sb.indexOf(\"*/\", startIndex + 2);\n            if (endIndex < 0) {\n                endIndex = totallen;\n            }\n\n            token = sb.substring(startIndex + 2, endIndex);\n            comments.add(token);\n            sb.replace(startIndex + 2, endIndex, \"___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_\" + (comments.size() - 1) + \"___\");\n            startIndex += 2;\n        }\n        css = sb.toString();\n\n\n        css = this.preserveToken(css, \"url\", \"(?i)url\\\\(\\\\s*([\\\"']?)data\\\\:\", true, preservedTokens);\n        css = this.preserveToken(css, \"calc\",  \"(?i)calc\\\\(\\\\s*([\\\"']?)\", false, preservedTokens);\n        css = this.preserveToken(css, \"progid:DXImageTransform.Microsoft.Matrix\",  \"(?i)progid:DXImageTransform.Microsoft.Matrix\\\\s*([\\\"']?)\", false, preservedTokens);\n\n\n        // preserve strings so their content doesn't get accidentally minified\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(\\\"([^\\\\\\\\\\\"]|\\\\\\\\.|\\\\\\\\)*\\\")|(\\'([^\\\\\\\\\\']|\\\\\\\\.|\\\\\\\\)*\\')\");\n        m = p.matcher(css);\n        while (m.find()) {\n            token = m.group();\n            char quote = token.charAt(0);\n            token = token.substring(1, token.length() - 1);\n\n            // maybe the string contains a comment-like substring?\n            // one, maybe more? put'em back then\n            if (token.indexOf(\"___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_\") >= 0) {\n                for (i = 0, max = comments.size(); i < max; i += 1) {\n                    token = token.replace(\"___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_\" + i + \"___\", comments.get(i).toString());\n                }\n            }\n\n            // minify alpha opacity in filter strings\n            token = token.replaceAll(\"(?i)progid:DXImageTransform.Microsoft.Alpha\\\\(Opacity=\", \"alpha(opacity=\");\n\n            preservedTokens.add(token);\n            String preserver = quote + \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\" + quote;\n            m.appendReplacement(sb, preserver);\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n\n        // strings are safe, now wrestle the comments\n        for (i = 0, max = comments.size(); i < max; i += 1) {\n\n            token = comments.get(i).toString();\n            placeholder = \"___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_\" + i + \"___\";\n\n            // ! in the first position of the comment means preserve\n            // so push to the preserved tokens while stripping the !\n            if (token.startsWith(\"!\")) {\n                preservedTokens.add(token);\n                css = css.replace(placeholder,  \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\");\n                continue;\n            }\n\n            // \\ in the last position looks like hack for Mac/IE5\n            // shorten that to /*\\*/ and the next one to /**/\n            if (token.endsWith(\"\\\\\")) {\n                preservedTokens.add(\"\\\\\");\n                css = css.replace(placeholder,  \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\");\n                i = i + 1; // attn: advancing the loop\n                preservedTokens.add(\"\");\n                css = css.replace(\"___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_\" + i + \"___\",  \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\");\n                continue;\n            }\n\n            // keep empty comments after child selectors (IE7 hack)\n            // e.g. html >/**/ body\n            if (token.length() == 0) {\n                startIndex = css.indexOf(placeholder);\n                if (startIndex > 2) {\n                    if (css.charAt(startIndex - 3) == '>') {\n                        preservedTokens.add(\"\");\n                        css = css.replace(placeholder,  \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\");\n                    }\n                }\n            }\n\n            // in all other cases kill the comment\n            css = css.replace(\"/*\" + placeholder + \"*/\", \"\");\n        }\n\n        // preserve \\9 IE hack\n        final String backslash9 = \"\\\\9\"; \n        while (css.indexOf(backslash9) > -1) {\n            preservedTokens.add(backslash9);\n            css = css.replace(backslash9,  \"___YUICSSMIN_PRESERVED_TOKEN_\" + (preservedTokens.size() - 1) + \"___\");\n     \t}\n        \n        // Normalize all whitespace strings to single spaces. Easier to work with that way.\n        css = css.replaceAll(\"\\\\s+\", \" \");\n\n        // Remove the spaces before the things that should not have spaces before them.\n        // But, be careful not to turn \"p :link {...}\" into \"p:link{...}\"\n        // Swap out any pseudo-class colons with the token, and then swap back.\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(^|\\\\})(([^\\\\{:])+:)+([^\\\\{]*\\\\{)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            String s = m.group();\n            s = s.replaceAll(\":\", \"___YUICSSMIN_PSEUDOCLASSCOLON___\");\n            s = s.replaceAll( \"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\" ).replaceAll( \"\\\\$\", \"\\\\\\\\\\\\$\" );\n            m.appendReplacement(sb, s);\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n        // Remove spaces before the things that should not have spaces before them.\n        css = css.replaceAll(\"\\\\s+([!{};:>+\\\\(\\\\)\\\\],])\", \"$1\");\n        // Restore spaces for !important\n        css = css.replaceAll(\"!important\", \" !important\");\n        // bring back the colon\n        css = css.replaceAll(\"___YUICSSMIN_PSEUDOCLASSCOLON___\", \":\");\n\n        // retain space for special IE6 cases\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i):first\\\\-(line|letter)(\\\\{|,)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, \":first-\" + m.group(1).toLowerCase() + \" \" + m.group(2));\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // no space after the end of a preserved comment\n        css = css.replaceAll(\"\\\\*/ \", \"*/\");\n\n        // If there are multiple @charset directives, push them to the top of the file.\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)^(.*)(@charset)( \\\"[^\\\"]*\\\";)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            String s = m.group(1).replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\\$\", \"\\\\\\\\\\\\$\");\n            m.appendReplacement(sb, m.group(2).toLowerCase() + m.group(3) + s);\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // When all @charset are at the top, remove the second and after (as they are completely ignored).\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)^((\\\\s*)(@charset)( [^;]+;\\\\s*))+\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, m.group(2) + m.group(3).toLowerCase() + m.group(4));\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // lowercase some popular @directives (@charset is done right above)\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)@(font-face|import|(?:-(?:atsc|khtml|moz|ms|o|wap|webkit)-)?keyframe|media|page|namespace)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, '@' + m.group(1).toLowerCase());\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // lowercase some more common pseudo-elements\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i):(active|after|before|checked|disabled|empty|enabled|first-(?:child|of-type)|focus|hover|last-(?:child|of-type)|link|only-(?:child|of-type)|root|:selection|target|visited)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, ':' + m.group(1).toLowerCase());\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // lowercase some more common functions\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i):(lang|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|(?:-(?:moz|webkit)-)?any)\\\\(\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, ':' + m.group(1).toLowerCase() + '(');\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // lower case some common function that can be values\n        // NOTE: rgb() isn't useful as we replace with #hex later, as well as and() is already done for us right after this\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)([:,\\\\( ]\\\\s*)(attr|color-stop|from|rgba|to|url|(?:-(?:atsc|khtml|moz|ms|o|wap|webkit)-)?(?:calc|max|min|(?:repeating-)?(?:linear|radial)-gradient)|-webkit-gradient)\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, m.group(1) + m.group(2).toLowerCase());\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // Put the space back in some cases, to support stuff like\n        // @media screen and (-webkit-min-device-pixel-ratio:0){\n        css = css.replaceAll(\"(?i)\\\\band\\\\(\", \"and (\");\n\n        // Remove the spaces after the things that should not have spaces after them.\n        css = css.replaceAll(\"([!{}:;>+\\\\(\\\\[,])\\\\s+\", \"$1\");\n\n        // remove unnecessary semicolons\n        css = css.replaceAll(\";+}\", \"}\");\n\n        // Replace 0(px,em,%) with 0.\n        css = css.replaceAll(\"(?i)(^|[^.0-9])(?:0?\\\\.)?0(?:px|em|%|in|cm|mm|pc|pt|ex|deg|g?rad|m?s|k?hz)\", \"$10\");\n        // Replace x.0(px,em,%) with x(px,em,%).\n        css = css.replaceAll(\"([0-9])\\\\.0(px|em|%|in|cm|mm|pc|pt|ex|deg|g?rad|m?s|k?hz| |;)\", \"$1$2\");\n\n        // Replace 0 0 0 0; with 0.\n        css = css.replaceAll(\":0 0 0 0(;|})\", \":0$1\");\n        css = css.replaceAll(\":0 0 0(;|})\", \":0$1\");\n        css = css.replaceAll(\":0 0(;|})\", \":0$1\");\n\n\n        // Replace background-position:0; with background-position:0 0;\n        // same for transform-origin\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)(background-position|webkit-mask-position|transform-origin|webkit-transform-origin|moz-transform-origin|o-transform-origin|ms-transform-origin):0(;|})\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, m.group(1).toLowerCase() + \":0 0\" + m.group(2));\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // Replace 0.6 to .6, but only when preceded by : or a white-space\n        css = css.replaceAll(\"(:|\\\\s)0+\\\\.(\\\\d+)\", \"$1.$2\");\n\n        // Shorten colors from rgb(51,102,153) to #336699\n        // This makes it more likely that it'll get further compressed in the next step.\n        p = Pattern.compile(\"rgb\\\\s*\\\\(\\\\s*([0-9,\\\\s]+)\\\\s*\\\\)\");\n        m = p.matcher(css);\n        sb = new StringBuffer();\n        while (m.find()) {\n            String[] rgbcolors = m.group(1).split(\",\");\n            StringBuffer hexcolor = new StringBuffer(\"#\");\n            for (i = 0; i < rgbcolors.length; i++) {\n                int val = Integer.parseInt(rgbcolors[i]);\n                if (val < 16) {\n                    hexcolor.append(\"0\");\n                }\n\n                // If someone passes an RGB value that's too big to express in two characters, round down.\n                // Probably should throw out a warning here, but generating valid CSS is a bigger concern.\n                if (val > 255) {\n                    val = 255;\n                }\n                hexcolor.append(Integer.toHexString(val));\n            }\n            m.appendReplacement(sb, hexcolor.toString());\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // Shorten colors from #AABBCC to #ABC. Note that we want to make sure\n        // the color is not preceded by either \", \" or =. Indeed, the property\n        //     filter: chroma(color=\"#FFFFFF\");\n        // would become\n        //     filter: chroma(color=\"#FFF\");\n        // which makes the filter break in IE.\n        // We also want to make sure we're only compressing #AABBCC patterns inside { }, not id selectors ( #FAABAC {} )\n        // We also want to avoid compressing invalid values (e.g. #AABBCCD to #ABCD)\n        p = Pattern.compile(\"(\\\\=\\\\s*?[\\\"']?)?\" + \"#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\" + \"(:?\\\\}|[^0-9a-fA-F{][^{]*?\\\\})\");\n\n        m = p.matcher(css);\n        sb = new StringBuffer();\n        int index = 0;\n\n        while (m.find(index)) {\n\n            sb.append(css.substring(index, m.start()));\n\n            boolean isFilter = (m.group(1) != null && !\"\".equals(m.group(1)));\n\n            if (isFilter) {\n                // Restore, as is. Compression will break filters\n                sb.append(m.group(1) + \"#\" + m.group(2) + m.group(3) + m.group(4) + m.group(5) + m.group(6) + m.group(7));\n            } else {\n                if( m.group(2).equalsIgnoreCase(m.group(3)) &&\n                    m.group(4).equalsIgnoreCase(m.group(5)) &&\n                    m.group(6).equalsIgnoreCase(m.group(7))) {\n\n                    // #AABBCC pattern\n                    sb.append(\"#\" + (m.group(3) + m.group(5) + m.group(7)).toLowerCase());\n\n                } else {\n\n                    // Non-compressible color, restore, but lower case.\n                    sb.append(\"#\" + (m.group(2) + m.group(3) + m.group(4) + m.group(5) + m.group(6) + m.group(7)).toLowerCase());\n                }\n            }\n\n            index = m.end(7);\n        }\n\n        sb.append(css.substring(index));\n        css = sb.toString();\n\n        // Replace #f00 -> red\n        css = css.replaceAll(\"(:|\\\\s)(#f00)(;|})\", \"$1red$3\");\n        // Replace other short color keywords\n        css = css.replaceAll(\"(:|\\\\s)(#000080)(;|})\", \"$1navy$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#808080)(;|})\", \"$1gray$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#808000)(;|})\", \"$1olive$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#800080)(;|})\", \"$1purple$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#c0c0c0)(;|})\", \"$1silver$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#008080)(;|})\", \"$1teal$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#ffa500)(;|})\", \"$1orange$3\");\n        css = css.replaceAll(\"(:|\\\\s)(#800000)(;|})\", \"$1maroon$3\");\n\n        // border: none -> border:0\n        sb = new StringBuffer();\n        p = Pattern.compile(\"(?i)(border|border-top|border-right|border-bottom|border-left|outline|background):none(;|})\");\n        m = p.matcher(css);\n        while (m.find()) {\n            m.appendReplacement(sb, m.group(1).toLowerCase() + \":0\" + m.group(2));\n        }\n        m.appendTail(sb);\n        css = sb.toString();\n\n        // shorter opacity IE filter\n        css = css.replaceAll(\"(?i)progid:DXImageTransform.Microsoft.Alpha\\\\(Opacity=\", \"alpha(opacity=\");\n\n        // Find a fraction that is used for Opera's -o-device-pixel-ratio query\n        // Add token to add the \"\\\" back in later\n        css = css.replaceAll(\"\\\\(([\\\\-A-Za-z]+):([0-9]+)\\\\/([0-9]+)\\\\)\", \"($1:$2___YUI_QUERY_FRACTION___$3)\");\n\n        // Remove empty rules.\n        css = css.replaceAll(\"[^\\\\}\\\\{/;]+\\\\{\\\\}\", \"\");\n\n        // Add \"\\\" back to fix Opera -o-device-pixel-ratio query\n        css = css.replaceAll(\"___YUI_QUERY_FRACTION___\", \"/\");\n\n        // TODO: Should this be after we re-insert tokens. These could alter the break points. However then\n        // we'd need to make sure we don't break in the middle of a string etc.\n        if (linebreakpos >= 0) {\n            // Some source control tools don't like it when files containing lines longer\n            // than, say 8000 characters, are checked in. The linebreak option is used in\n            // that case to split long lines after a specific column.\n            i = 0;\n            int linestartpos = 0;\n            sb = new StringBuffer(css);\n            while (i < sb.length()) {\n                char c = sb.charAt(i++);\n                if (c == '}' && i - linestartpos > linebreakpos) {\n                    sb.insert(i, '\\n');\n                    linestartpos = i;\n                }\n            }\n\n            css = sb.toString();\n        }\n\n        // Replace multiple semi-colons in a row by a single one\n        // See SF bug #1980989\n        css = css.replaceAll(\";;+\", \";\");\n\n        // restore preserved comments and strings\n        for(i = 0, max = preservedTokens.size(); i < max; i++) {\n            css = css.replace(\"___YUICSSMIN_PRESERVED_TOKEN_\" + i + \"___\", preservedTokens.get(i).toString());\n        }\n\n        // Trim the final string (for any leading or trailing white spaces)\n        css = css.trim();\n\n        // Write the output...\n        out.write(css);\n    }\n}\n","lineNo":264}
