{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.social.sample.spi;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Future;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.AnonymousSecurityToken;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.protocol.DataCollection;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.RestfulCollection;\nimport org.apache.shindig.protocol.conversion.BeanConverter;\nimport org.apache.shindig.protocol.model.SortOrder;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.opensocial.model.Activity;\nimport org.apache.shindig.social.opensocial.model.ActivityEntry;\nimport org.apache.shindig.social.opensocial.model.Album;\nimport org.apache.shindig.social.opensocial.model.Group;\nimport org.apache.shindig.social.opensocial.model.MediaItem;\nimport org.apache.shindig.social.opensocial.model.Message;\nimport org.apache.shindig.social.opensocial.model.MessageCollection;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.spi.ActivityService;\nimport org.apache.shindig.social.opensocial.spi.ActivityStreamService;\nimport org.apache.shindig.social.opensocial.spi.AlbumService;\nimport org.apache.shindig.social.opensocial.spi.AppDataService;\nimport org.apache.shindig.social.opensocial.spi.CollectionOptions;\nimport org.apache.shindig.social.opensocial.spi.GroupId;\nimport org.apache.shindig.social.opensocial.spi.GroupService;\nimport org.apache.shindig.social.opensocial.spi.MediaItemService;\nimport org.apache.shindig.social.opensocial.spi.MessageService;\nimport org.apache.shindig.social.opensocial.spi.PersonService;\nimport org.apache.shindig.social.opensocial.spi.UserId;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\n\n/**\n * Implementation of supported services backed by a JSON DB.\n */\n@Singleton\npublic class JsonDbOpensocialService implements ActivityService, PersonService, AppDataService,\n    MessageService, AlbumService, MediaItemService, ActivityStreamService, GroupService {\n\n  private static final Comparator<Person> NAME_COMPARATOR = new Comparator<Person>() {\n    public int compare(Person person, Person person1) {\n      String name = person.getName().getFormatted();\n      String name1 = person1.getName().getFormatted();\n      return name.compareTo(name1);\n    }\n  };\n\n  /**\n   * The DB\n   */\n  private JSONObject db;\n\n  /**\n   * The JSON<->Bean converter\n   */\n  private BeanConverter converter;\n\n  /**\n   * db[\"people\"] -> Array<Person>\n   */\n  private static final String PEOPLE_TABLE = \"people\";\n\n  /**\n   * db[\"groups\"] -> Array<Group>\n   */\n  private static final String GROUPS_TABLE = \"groups\";\n\n  /**\n   * db[\"groupMembers\"] -> Array<Person>\n   */\n  private static final String GROUP_MEMBERS_TABLE = \"groupMembers\";\n\n  /**\n   * db[\"activities\"] -> Map<Person.Id, Array<Activity>>\n   */\n  private static final String ACTIVITIES_TABLE = \"activities\";\n\n  /**\n   * db[\"albums\"] -> Map<Person.Id, Array<Album>>\n   */\n  private static final String ALBUMS_TABLE = \"albums\";\n\n  /**\n   * db[\"mediaItems\"] -> Map<Person.Id, Array<MediaItem>>\n   */\n  private static final String MEDIAITEMS_TABLE = \"mediaItems\";\n\n  /**\n   * db[\"data\"] -> Map<Person.Id, Map<String, String>>\n   */\n  private static final String DATA_TABLE = \"data\";\n\n  /**\n   * db[\"friendLinks\"] -> Map<Person.Id, Array<Person.Id>>\n   */\n  private static final String FRIEND_LINK_TABLE = \"friendLinks\";\n\n  /**\n   * db[\"messages\"] -> Map<Person.Id, Array<Message>>\n   */\n  private static final String MESSAGE_TABLE = \"messages\";\n\n  /**\n   * db[\"passwords\"] -> Map<Person.Id, String>\n   */\n  private static final String PASSWORDS_TABLE = \"passwords\";\n\n  /**\n   * db[\"activityEntries\"] -> Map<Person.Id, Array<ActivityEntry>>\n   */\n  private static final String ACTIVITYSTREAMS_TABLE = \"activityEntries\";\n\n  /**\n   * Anonymous name.\n   */\n  private static final String ANONYMOUS_NAME = \"Anonymous\";\n\n  private Authority authority;\n\n  /**\n   * Initializes the JsonDbOpensocialService using Guice\n   *\n   * @param jsonLocation location of the json data provided by the shindig.canonical.json.db parameter\n   * @param converter an injected BeanConverter\n   * @throws java.lang.Exception if any\n   */\n  @Inject\n  public JsonDbOpensocialService(@Named(\"shindig.canonical.json.db\")\n  String jsonLocation, @Named(\"shindig.bean.converter.json\")\n  BeanConverter converter,\n  @Named(\"shindig.contextroot\") String contextroot) throws Exception {\n    String content = IOUtils.toString(ResourceLoader.openResource(jsonLocation), \"UTF-8\");\n    this.db = new JSONObject(content.replace(\"%contextroot%\", contextroot));\n    this.converter = converter;\n  }\n\n  /**\n   * Allows access to the underlying json db.\n   *\n   * @return a reference to the json db\n   */\n  public JSONObject getDb() {\n    return db;\n  }\n\n   /**\n   * override the json database\n   * @param db a {@link org.json.JSONObject}.\n   */\n  public void setDb(JSONObject db) {\n    this.db = db;\n  }\n\n  @Inject(optional = true)\n  public void setAuthority(Authority authority) {\n    this.authority = authority;\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(Set<UserId> userIds, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITIES_TABLE).has(id)) {\n          JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(id);\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (appId == null || !activity.has(Activity.Field.APP_ID.toString())) {\n              result.add(filterFields(activity, fields, Activity.class));\n            } else if (activity.get(Activity.Field.APP_ID.toString()).equals(appId)) {\n              result.add(filterFields(activity, fields, Activity.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, Set<String> activityIds,\n      SecurityToken token) throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n            result.add(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Activity> getActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activity.get(Activity.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivities(UserId userId, GroupId groupId, String appId,\n      Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        if (activities != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (!activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n              newList.put(activity);\n            }\n          }\n          db.getJSONObject(ACTIVITIES_TABLE).put(user, newList);\n          // TODO. This seems very odd that we return no useful response in this\n          // case\n          // There is no way to represent not-found\n          // if (found) { ??\n          // }\n        }\n      }\n      // What is the appropriate response here??\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> createActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Activity activity, SecurityToken token) throws ProtocolException {\n    // Are fields really needed here?\n    try {\n      JSONObject jsonObject = convertFromActivity(activity, fields);\n      if (!jsonObject.has(Activity.Field.ID.toString())) {\n        jsonObject.put(Activity.Field.ID.toString(), System.currentTimeMillis());\n      }\n      JSONArray jsonArray = db.getJSONObject(ACTIVITIES_TABLE)\n          .getJSONArray(userId.getUserId(token));\n      if (jsonArray == null) {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITIES_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      // TODO (woodser): if used with PUT, duplicate activity would be created?\n      jsonArray.put(jsonObject);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Person>> getPeople(Set<UserId> userIds, GroupId groupId,\n      CollectionOptions options, Set<String> fields, SecurityToken token) throws ProtocolException {\n    List<Person> result = Lists.newArrayList();\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (!idSet.contains(person.get(Person.Field.ID.toString()))) {\n          continue;\n        }\n\n        // Add group support later\n        Person personObj = filterFields(person, fields, Person.class);\n        Map<String, Object> appData = getPersonAppData(\n            person.getString(Person.Field.ID.toString()), fields);\n        personObj.setAppData(appData);\n\n        result.add(personObj);\n      }\n\n      if (GroupId.Type.self == groupId.getType() && result.isEmpty()) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"People '\" + idSet + \"' not found\");\n      }\n\n      // We can pretend that by default the people are in top friends order\n      if (options.getSortBy().equals(Person.Field.NAME.toString())) {\n        Collections.sort(result, NAME_COMPARATOR);\n\n        if (options.getSortOrder() == SortOrder.descending) {\n          Collections.reverse(result);\n        }\n      }\n\n      // TODO: The samplecontainer doesn't really have the concept of HAS_APP so\n      // we can't support any filters yet. We should fix this.\n\n      int totalSize = result.size();\n      int last = options.getFirst() + options.getMax();\n      result = result.subList(options.getFirst(), Math.min(last, totalSize));\n\n      return Futures.immediateFuture(new RestfulCollection<Person>(result, options.getFirst(), totalSize, options.getMax()));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)\n      throws ProtocolException {\n    if (id != null && AnonymousSecurityToken.ANONYMOUS_ID.equals(id.getUserId())) {\n      Person anonymous = new PersonImpl();\n      anonymous.setId(AnonymousSecurityToken.ANONYMOUS_ID);\n      anonymous.setName(new NameImpl(ANONYMOUS_NAME));\n      anonymous.setNickname(ANONYMOUS_NAME);\n      return Futures.immediateFuture(anonymous);\n    }\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (id != null && person.get(Person.Field.ID.toString()).equals(id.getUserId(token))) {\n          Person personObj = filterFields(person, fields, Person.class);\n          Map<String, Object> appData = getPersonAppData(person.getString(Person.Field.ID\n              .toString()), fields);\n          personObj.setAppData(appData);\n\n          return Futures.immediateFuture(personObj);\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Person '\" + id.getUserId(token) + \"' not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> updatePerson(UserId id, Person person, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String viewer = token.getViewerId(); // viewer\n      String user = id.getUserId(token); // person to update\n\n      if (!viewerCanUpdatePerson(viewer,user)) {\n        throw new ProtocolException(HttpServletResponse.SC_FORBIDDEN, \"User '\" + viewer + \"' does not have enough privileges to update person '\"+user+\"'\");\n      }\n\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject curPerson = people.getJSONObject(i);\n\n        if (user != null && curPerson.getString(Person.Field.ID.toString()).equals(user)) {\n          // Convert user to JSON and set ID\n          JSONObject jsonPerson = convertToJson(person);\n          // go through all properties to update in the submitted person object\n          // and change them in the current person object\n          for (String key : JSONObject.getNames(jsonPerson)) {\n            curPerson.put(key,jsonPerson.get(key));\n          }\n\n          people.put(i,curPerson);\n          return Futures.immediateFuture(converter.convertToObject(curPerson.toString(), Person.class));\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User ID \" + user + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n\n  }\n\n  /** Check if a viewer is allowed to update the given person record. **/\n  protected boolean viewerCanUpdatePerson(String viewer, String person) {\n    // A person can only update his own personal data (by default)\n    // if you wish to allow other people to update the personal data of the user\n    // you should change the current function\n    return viewer.equals(person) ? true : false;\n  }\n\n  private Map<String, Object> getPersonAppData(String id, Set<String> fields) {\n    try {\n      Map<String, Object> appData = null;\n      JSONObject personData = db.getJSONObject(DATA_TABLE).optJSONObject(id);\n      if (personData != null) {\n        if (fields.contains(Person.Field.APP_DATA.toString())) {\n          appData = Maps.newHashMap();\n          @SuppressWarnings(\"unchecked\")\n          Iterator<String> keys = personData.keys();\n          while (keys.hasNext()) {\n            String key = keys.next();\n            appData.put(key, personData.get(key));\n          }\n        } else {\n          String appDataPrefix = Person.Field.APP_DATA.toString() + '.';\n          for (String field : fields) {\n            if (field.startsWith(appDataPrefix)) {\n              if (appData == null) {\n                appData = Maps.newHashMap();\n              }\n\n              String appDataField = field.substring(appDataPrefix.length());\n              if (personData.has(appDataField)) {\n                appData.put(appDataField, personData.get(appDataField));\n              }\n            }\n          }\n        }\n      }\n\n      return appData;\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      Map<String, Map<String, Object>> idToData = Maps.newHashMap();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        JSONObject personData;\n        if (!db.getJSONObject(DATA_TABLE).has(id)) {\n          personData = new JSONObject();\n        } else {\n          if (!fields.isEmpty()) {\n            personData = new JSONObject(db.getJSONObject(DATA_TABLE).getJSONObject(id), fields\n                .toArray(new String[fields.size()]));\n          } else {\n            personData = db.getJSONObject(DATA_TABLE).getJSONObject(id);\n          }\n        }\n\n        // TODO: We can use the converter here to do this for us\n\n        // JSONObject keys are always strings\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = personData.keys();\n        Map<String, Object> data = Maps.newHashMap();\n        while (keys.hasNext()) {\n          String key = keys.next();\n          data.put(key, personData.getString(key));\n        }\n        idToData.put(id, data);\n      }\n      return Futures.immediateFuture(new DataCollection(idToData));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (!db.getJSONObject(DATA_TABLE).has(user)) {\n        return null;\n      }\n      JSONObject newPersonData = new JSONObject();\n      JSONObject oldPersonData = db.getJSONObject(DATA_TABLE).getJSONObject(user);\n\n      // JSONObject keys are always strings\n      @SuppressWarnings(\"unchecked\")\n      Iterator<String> keys = oldPersonData.keys();\n      while (keys.hasNext()) {\n        String key = keys.next();\n        if (!fields.contains(key)) {\n          newPersonData.put(key, oldPersonData.getString(key));\n        }\n      }\n      db.getJSONObject(DATA_TABLE).put(user, newPersonData);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Map<String, Object> values, SecurityToken token)\n      throws ProtocolException {\n    // TODO: this seems redundant. No need to pass both fields and a map of\n    // field->value\n    // TODO: According to rest, yes there is. If a field is in the param list\n    // but not in the map\n    // that means it is a delete\n\n    try {\n      JSONObject personData = db.getJSONObject(DATA_TABLE).getJSONObject(userId.getUserId(token));\n      if (personData == null) {\n        personData = new JSONObject();\n        db.getJSONObject(DATA_TABLE).put(userId.getUserId(token), personData);\n      }\n\n      for (Map.Entry<String, Object> entry : values.entrySet()) {\n        personData.put(entry.getKey(), entry.getValue());\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Group>> getGroups(UserId userId,\n\t\tCollectionOptions options, Set<String> fields, SecurityToken token)\n\t\tthrows ProtocolException {\n    List<Group> result = Lists.newArrayList();\n    String user = userId.getUserId(token);\n    try {\n      JSONArray groups = db.getJSONObject(GROUPS_TABLE).getJSONArray(user);\n\n      for (int i = 0; i < groups.length(); i++) {\n        JSONObject group = groups.getJSONObject(i);\n\n        Group groupObj = filterFields(group, fields, Group.class);\n        result.add(groupObj);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n\n    return Futures.immediateFuture(new RestfulCollection<Group>(result));\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Post a message for a set of users.\n   */\n  public Future<Void> createMessage(UserId userId, String appId, String msgCollId, Message message,\n      SecurityToken token) throws ProtocolException {\n    for (String recipient : message.getRecipients()) {\n      try {\n        JSONArray outbox = db.getJSONObject(MESSAGE_TABLE).getJSONArray(recipient);\n        if (outbox == null) {\n          outbox = new JSONArray();\n          db.getJSONObject(MESSAGE_TABLE).put(recipient, outbox);\n        }\n\n        outbox.put(message);\n      } catch (JSONException je) {\n        throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n            je);\n      }\n    }\n\n    return Futures.immediateFuture(null);\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MessageCollection>> getMessageCollections(UserId userId,\n      Set<String> fields, CollectionOptions options, SecurityToken token) throws ProtocolException {\n    try {\n      List<MessageCollection> result = Lists.newArrayList();\n      JSONObject messageCollections = db.getJSONObject(MESSAGE_TABLE).getJSONObject(\n          userId.getUserId(token));\n      for (String msgCollId : JSONObject.getNames(messageCollections)) {\n        JSONObject msgColl = messageCollections.getJSONObject(msgCollId);\n        msgColl.put(\"id\", msgCollId);\n        JSONArray messages = msgColl.getJSONArray(\"messages\");\n        int numMessages = (messages == null) ? 0 : messages.length();\n        msgColl.put(\"total\", String.valueOf(numMessages));\n        msgColl.put(\"unread\", String.valueOf(numMessages));\n\n        result.add(filterFields(msgColl, fields, MessageCollection.class));\n      }\n      return Futures.immediateFuture(new RestfulCollection<MessageCollection>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessages(UserId userId, String msgCollId, List<String> ids,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Gets the messsages in an user's queue.\n   */\n  public Future<RestfulCollection<Message>> getMessages(UserId userId, String msgCollId,\n      Set<String> fields, List<String> msgIds, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Message> result = Lists.newArrayList();\n      JSONArray messages = db.getJSONObject(MESSAGE_TABLE).getJSONObject(userId.getUserId(token))\n          .getJSONObject(msgCollId).getJSONArray(\"messages\");\n\n      // TODO: special case @all\n\n      if (messages == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"message collection\"\n            + msgCollId + \" not found\");\n      }\n\n      // TODO: filter and sort outbox.\n      for (int i = 0; i < messages.length(); i++) {\n        JSONObject msg = messages.getJSONObject(i);\n        Message message = filterFields(msg, fields, Message.class);\n        if (msgIds.isEmpty() || msgIds.contains(message.getId())) {\n          result.add(message);\n        }\n      }\n\n      return Futures.immediateFuture(new RestfulCollection<Message>(result));\n\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<MessageCollection> createMessageCollection(UserId userId,\n      MessageCollection msgCollection, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessage(UserId userId, String msgCollId, String messageId,\n      Message message, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessageCollection(UserId userId, MessageCollection msgCollection,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessageCollection(UserId userId, String msgCollId, SecurityToken token)\n      throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * Public methods for use with Authentication Classes\n   *\n   * @param username a {@link java.lang.String} object.\n   * @return a {@link java.lang.String} object.\n   */\n  public String getPassword(String username) {\n    try {\n      return db.getJSONObject(PASSWORDS_TABLE).getString(username);\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n\n  private Set<String> getIdSet(UserId user, GroupId group, SecurityToken token)\n      throws JSONException {\n    String userId = user.getUserId(token);\n\n    if (group == null) {\n      return ImmutableSortedSet.of(userId);\n    }\n\n    Set<String> returnVal = Sets.newLinkedHashSet();\n    switch (group.getType()) {\n    case all:\n    case friends:\n      if (db.getJSONObject(FRIEND_LINK_TABLE).has(userId)) {\n        JSONArray friends = db.getJSONObject(FRIEND_LINK_TABLE).getJSONArray(userId);\n        for (int i = 0; i < friends.length(); i++) {\n          returnVal.add(friends.getString(i));\n        }\n      }\n      break;\n    case objectId:\n      if (db.getJSONObject(GROUP_MEMBERS_TABLE).has(group.toString())) {\n        JSONArray groupMembers = db.getJSONObject(GROUP_MEMBERS_TABLE).getJSONArray(group.toString());\n        for (int i = 0; i < groupMembers.length(); i++) {\n          returnVal.add(groupMembers.getString(i));\n        }\n      }\n      break;\n    case self:\n      returnVal.add(userId);\n      break;\n    }\n    return returnVal;\n  }\n\n  /**\n   * Get the set of user id's for a set of users and a group\n   *\n   * @param users set of UserIds\n   * @param group the group\n   * @param token a token\n   * @return set of Id strings\n   * @throws org.json.JSONException if errors in Json\n   */\n  public Set<String> getIdSet(Set<UserId> users, GroupId group, SecurityToken token)\n      throws JSONException {\n    Set<String> ids = Sets.newLinkedHashSet();\n    for (UserId user : users) {\n      ids.addAll(getIdSet(user, group, token));\n    }\n    return ids;\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Album> getAlbum(UserId userId, String appId, Set<String> fields,\n                                String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Search albums for given ID and owner\n        JSONObject album;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          album = userAlbums.getJSONObject(i);\n          if (album.getString(Album.Field.ID.toString()).equals(albumId) &&\n              album.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n            return Futures.immediateFuture(filterFields(album, fields, Album.class));\n          }\n        }\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(UserId userId, String appId,\n                                                    Set<String> fields, CollectionOptions options, Set<String> albumIds,\n                                                    SecurityToken token) throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Stores target albums\n        List<Album> result = Lists.newArrayList();\n\n        // Search for every albumId\n        boolean found;\n        JSONObject curAlbum;\n        for (String albumId : albumIds) {\n          // Search albums for this albumId\n          found = false;\n          for (int i = 0; i < userAlbums.length(); i++) {\n            curAlbum = userAlbums.getJSONObject(i);\n            if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId) &&\n                curAlbum.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n              result.add(filterFields(curAlbum, fields, Album.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - albumId not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n          }\n        }\n\n        // Return found albums\n        return Futures.immediateFuture(new RestfulCollection<Album>(result));\n      }\n\n      // Album table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User '\" + user + \"' has no albums\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(Set<UserId> userIds,\n                                                    GroupId groupId, String appId, Set<String> fields,\n                                                    CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Album> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather albums for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(ALBUMS_TABLE).has(id)) {\n          JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userAlbums.length(); i++) {\n            JSONObject album = userAlbums.getJSONObject(i);\n            if (album.getString(Album.Field.OWNER_ID.toString()).equals(id)) {\n              result.add(filterFields(album, fields, Album.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Album>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteAlbum(UserId userId, String appId, String albumId,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      boolean targetFound = false;      // indicates if target album is found\n      JSONArray newAlbums = new JSONArray();  // list of albums minus target\n      String user = userId.getUserId(token);  // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Compose new list of albums excluding album to be deleted\n        JSONObject curAlbum;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newAlbums.put(curAlbum);\n          }\n        }\n      }\n\n      // Overwrite user's albums with updated list if album found\n      if (targetFound) {\n        db.getJSONObject(ALBUMS_TABLE).put(user, newAlbums);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: userId and album's ownerId don't have to match - potential problem\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createAlbum(UserId userId, String appId, Album album,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      // Get table of user's albums\n      String user = userId.getUserId(token);\n      JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n      if (userAlbums == null) {\n        userAlbums = new JSONArray();\n        db.getJSONObject(ALBUMS_TABLE).put(user, userAlbums);\n      }\n\n      // Convert album to JSON and set ID & owner\n      JSONObject jsonAlbum = convertToJson(album);\n      if (!jsonAlbum.has(Album.Field.ID.toString())) {\n        jsonAlbum.put(Album.Field.ID.toString(), System.currentTimeMillis());\n      }\n      if (!jsonAlbum.has(Album.Field.OWNER_ID.toString())) {\n        jsonAlbum.put(Album.Field.OWNER_ID.toString(), user);\n      }\n\n      // Insert new album into table\n      userAlbums.put(jsonAlbum);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateAlbum(UserId userId, String appId, Album album,\n                                  String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Convert album to JSON and set ID\n        JSONObject jsonAlbum = convertToJson(album);\n        jsonAlbum.put(Album.Field.ID.toString(), albumId);\n\n        // Iterate through albums to identify album to update\n        for (int i = 0; i < userAlbums.length(); i++) {\n          JSONObject curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            userAlbums.put(i, jsonAlbum);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<MediaItem> getMediaItem(UserId userId, String appId,\n                                        String albumId, String mediaItemId, Set<String> fields,\n                                        SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Search user's MediaItems for given ID and album\n        JSONObject mediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          mediaItem = userMediaItems.getJSONObject(i);\n          if (mediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              mediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            return Futures.immediateFuture(filterFields(mediaItem, fields, MediaItem.class));\n          }\n        }\n      }\n\n      // MediaItem wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID '\" + mediaItemId + \"' does not exist within Album '\" + albumId + '\\'');\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> mediaItemIds,\n                                                            Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores found MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search for every MediaItem ID target\n        boolean found;\n        JSONObject curMediaItem;\n        for (String mediaItemId : mediaItemIds) {\n          // Search existing MediaItems for this MediaItem ID\n          found = false;\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            curMediaItem = userMediaItems.getJSONObject(i);\n            if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(albumId) &&\n                curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n              result.add(filterFields(curMediaItem, fields, MediaItem.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - MediaItem ID not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist within Album \" + albumId);\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem table not found for user \" + user);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> fields,\n                                                            CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores target MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search user's MediaItems for given album\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            result.add(filterFields(curMediaItem, fields, MediaItem.class));\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(\n      Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<MediaItem> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather MediaItems for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(MEDIAITEMS_TABLE).has(id)) {\n          JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            result.add(filterFields(userMediaItems.getJSONObject(i), fields, MediaItem.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      boolean targetFound = false;        // indicates if target MediaItem is found\n      JSONArray newMediaItems = new JSONArray();  // list of MediaItems minus target\n      String user = userId.getUserId(token);    // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Compose new list of MediaItems excluding item to be deleted\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newMediaItems.put(curMediaItem);\n          }\n        }\n      }\n\n      // Overwrite user's MediaItems with updated list if target found\n      if (targetFound) {\n        db.getJSONObject(MEDIAITEMS_TABLE).put(user, newMediaItems);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createMediaItem(UserId userId, String appId,\n                                      String albumId, MediaItem mediaItem, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Get table of user's MediaItems\n      JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(userId.getUserId(token));\n      if (userMediaItems == null) {\n        userMediaItems = new JSONArray();\n        db.getJSONObject(MEDIAITEMS_TABLE).put(userId.getUserId(token), userMediaItems);\n      }\n\n      // Convert MediaItem to JSON and set ID & Album ID\n      JSONObject jsonMediaItem = convertToJson(mediaItem);\n      jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n      if (!jsonMediaItem.has(MediaItem.Field.ID.toString())) {\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), System.currentTimeMillis());\n      }\n\n      // Insert new MediaItem into table\n      userMediaItems.put(jsonMediaItem);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, MediaItem mediaItem,\n                                      SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Convert MediaItem to JSON and set ID & Album ID\n        JSONObject jsonMediaItem = convertToJson(mediaItem);\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), mediaItemId);\n        jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n\n        // Iterate through MediaItems to identify item to update\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          JSONObject curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            userMediaItems.put(i, jsonMediaItem);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no MediaItem found with given ID and Album ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> updateActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        if (activityId != null) {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), activityId);\n        } else {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n        }\n      }\n      activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Find & replace activity\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          jsonArray.put(i, jsonEntry);\n          return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> createActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n      }\n      String activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Ensure activity does not already exist\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity already exists: \" + activityId);\n        }\n      }\n      jsonArray.put(jsonEntry);\n      return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivityEntries(UserId userId, GroupId groupId,\n      String appId, Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n\n        if (activityEntries != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (!activityIds.contains(activityEntry.getString(ActivityEntry.Field.ID.toString()))) {\n              newList.put(activityEntry);\n            }\n          }\n          db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(user, newList);\n        }\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> getActivityEntry(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, String activityId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for (int i = 0; i < activityEntries.length(); i++) {\n          JSONObject activityEntry = activityEntries.getJSONObject(i);\n          if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activityEntry, fields, ActivityEntry.class));\n          }\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n\n/** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      Set<UserId> userIds, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n      List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(id)) {\n          JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n            // TODO: ActivityStreams don't have appIds\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      UserId userId, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, Set<String> activityIds, SecurityToken token)\n      throws ProtocolException {\n    List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for(String activityId : activityIds) {\n          boolean found = false;\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n              result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND, \"Activity not found: \" + activityId);\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // TODO Why specifically handle Activity instead of generic POJO (below)?\n\n  private JSONObject convertFromActivity(Activity activity, Set<String> fields)\n      throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activity));\n  }\n\n  private JSONObject convertFromActivityEntry(ActivityEntry activityEntry, Set<String> fields) throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activityEntry));\n  }\n\n  private JSONObject convertToJson(Object object) throws JSONException {\n    // TODO not using fields yet\n    return new JSONObject(converter.convertToString(object));\n  }\n\n  public <T> T filterFields(JSONObject object, Set<String> fields,\n                            Class<T> clz) throws JSONException {\n    if (!fields.isEmpty()) {\n      // Create a copy with just the specified fields\n      object = new JSONObject(object, fields.toArray(new String[fields\n          .size()]));\n    }\n    String objectVal = object.toString();\n    if (authority != null) {\n      objectVal = objectVal.replace(\"%origin%\", authority.getOrigin());\n    } else {\n      //provide default for junit tests\n      objectVal = objectVal.replace(\"%origin%\", \"http://localhost:8080\");\n    }\n    return converter.convertToObject(objectVal, clz);\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.social.sample.spi;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.Future;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.AnonymousSecurityToken;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.protocol.DataCollection;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.RestfulCollection;\nimport org.apache.shindig.protocol.conversion.BeanConverter;\nimport org.apache.shindig.protocol.model.SortOrder;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.opensocial.model.Activity;\nimport org.apache.shindig.social.opensocial.model.ActivityEntry;\nimport org.apache.shindig.social.opensocial.model.Album;\nimport org.apache.shindig.social.opensocial.model.Group;\nimport org.apache.shindig.social.opensocial.model.MediaItem;\nimport org.apache.shindig.social.opensocial.model.Message;\nimport org.apache.shindig.social.opensocial.model.MessageCollection;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.spi.ActivityService;\nimport org.apache.shindig.social.opensocial.spi.ActivityStreamService;\nimport org.apache.shindig.social.opensocial.spi.AlbumService;\nimport org.apache.shindig.social.opensocial.spi.AppDataService;\nimport org.apache.shindig.social.opensocial.spi.CollectionOptions;\nimport org.apache.shindig.social.opensocial.spi.GroupId;\nimport org.apache.shindig.social.opensocial.spi.GroupService;\nimport org.apache.shindig.social.opensocial.spi.MediaItemService;\nimport org.apache.shindig.social.opensocial.spi.MessageService;\nimport org.apache.shindig.social.opensocial.spi.PersonService;\nimport org.apache.shindig.social.opensocial.spi.UserId;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\n\n/**\n * Implementation of supported services backed by a JSON DB.\n */\n@Singleton\npublic class JsonDbOpensocialService implements ActivityService, PersonService, AppDataService,\n    MessageService, AlbumService, MediaItemService, ActivityStreamService, GroupService {\n\n  private static final Comparator<Person> NAME_COMPARATOR = new Comparator<Person>() {\n    public int compare(Person person, Person person1) {\n      String name = person.getName().getFormatted();\n      String name1 = person1.getName().getFormatted();\n      return name.compareTo(name1);\n    }\n  };\n\n  /**\n   * The DB\n   */\n  private JSONObject db;\n\n  /**\n   * The JSON<->Bean converter\n   */\n  private BeanConverter converter;\n\n  /**\n   * db[\"people\"] -> Array<Person>\n   */\n  private static final String PEOPLE_TABLE = \"people\";\n\n  /**\n   * db[\"groups\"] -> Array<Group>\n   */\n  private static final String GROUPS_TABLE = \"groups\";\n\n  /**\n   * db[\"groupMembers\"] -> Array<Person>\n   */\n  private static final String GROUP_MEMBERS_TABLE = \"groupMembers\";\n\n  /**\n   * db[\"activities\"] -> Map<Person.Id, Array<Activity>>\n   */\n  private static final String ACTIVITIES_TABLE = \"activities\";\n\n  /**\n   * db[\"albums\"] -> Map<Person.Id, Array<Album>>\n   */\n  private static final String ALBUMS_TABLE = \"albums\";\n\n  /**\n   * db[\"mediaItems\"] -> Map<Person.Id, Array<MediaItem>>\n   */\n  private static final String MEDIAITEMS_TABLE = \"mediaItems\";\n\n  /**\n   * db[\"data\"] -> Map<Person.Id, Map<String, String>>\n   */\n  private static final String DATA_TABLE = \"data\";\n\n  /**\n   * db[\"friendLinks\"] -> Map<Person.Id, Array<Person.Id>>\n   */\n  private static final String FRIEND_LINK_TABLE = \"friendLinks\";\n\n  /**\n   * db[\"messages\"] -> Map<Person.Id, Map<MessageCollection.Id, MessageCollection>>\n   */\n  private static final String MESSAGE_TABLE = \"messages\";\n\n  /**\n   * Attribute that contains the messages of a specific MessageCollection.\n   */\n  private static final String MESSAGES_ARRAY = \"messages\";\n\n  /**\n   * db[\"passwords\"] -> Map<Person.Id, String>\n   */\n  private static final String PASSWORDS_TABLE = \"passwords\";\n\n  /**\n   * db[\"activityEntries\"] -> Map<Person.Id, Array<ActivityEntry>>\n   */\n  private static final String ACTIVITYSTREAMS_TABLE = \"activityEntries\";\n\n  /**\n   * Anonymous name.\n   */\n  private static final String ANONYMOUS_NAME = \"Anonymous\";\n\n  private Authority authority;\n\n  /**\n   * Initializes the JsonDbOpensocialService using Guice\n   *\n   * @param jsonLocation location of the json data provided by the shindig.canonical.json.db parameter\n   * @param converter an injected BeanConverter\n   * @throws java.lang.Exception if any\n   */\n  @Inject\n  public JsonDbOpensocialService(@Named(\"shindig.canonical.json.db\")\n  String jsonLocation, @Named(\"shindig.bean.converter.json\")\n  BeanConverter converter,\n  @Named(\"shindig.contextroot\") String contextroot) throws Exception {\n    String content = IOUtils.toString(ResourceLoader.openResource(jsonLocation), \"UTF-8\");\n    this.db = new JSONObject(content.replace(\"%contextroot%\", contextroot));\n    this.converter = converter;\n  }\n\n  /**\n   * Allows access to the underlying json db.\n   *\n   * @return a reference to the json db\n   */\n  public JSONObject getDb() {\n    return db;\n  }\n\n   /**\n   * override the json database\n   * @param db a {@link org.json.JSONObject}.\n   */\n  public void setDb(JSONObject db) {\n    this.db = db;\n  }\n\n  @Inject(optional = true)\n  public void setAuthority(Authority authority) {\n    this.authority = authority;\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(Set<UserId> userIds, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITIES_TABLE).has(id)) {\n          JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(id);\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (appId == null || !activity.has(Activity.Field.APP_ID.toString())) {\n              result.add(filterFields(activity, fields, Activity.class));\n            } else if (activity.get(Activity.Field.APP_ID.toString()).equals(appId)) {\n              result.add(filterFields(activity, fields, Activity.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, Set<String> activityIds,\n      SecurityToken token) throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n            result.add(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Activity> getActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activity.get(Activity.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivities(UserId userId, GroupId groupId, String appId,\n      Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        if (activities != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (!activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n              newList.put(activity);\n            }\n          }\n          db.getJSONObject(ACTIVITIES_TABLE).put(user, newList);\n          // TODO. This seems very odd that we return no useful response in this\n          // case\n          // There is no way to represent not-found\n          // if (found) { ??\n          // }\n        }\n      }\n      // What is the appropriate response here??\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> createActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Activity activity, SecurityToken token) throws ProtocolException {\n    // Are fields really needed here?\n    try {\n      JSONObject jsonObject = convertFromActivity(activity, fields);\n      if (!jsonObject.has(Activity.Field.ID.toString())) {\n        jsonObject.put(Activity.Field.ID.toString(), System.currentTimeMillis());\n      }\n      JSONArray jsonArray = db.getJSONObject(ACTIVITIES_TABLE)\n          .getJSONArray(userId.getUserId(token));\n      if (jsonArray == null) {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITIES_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      // TODO (woodser): if used with PUT, duplicate activity would be created?\n      jsonArray.put(jsonObject);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Person>> getPeople(Set<UserId> userIds, GroupId groupId,\n      CollectionOptions options, Set<String> fields, SecurityToken token) throws ProtocolException {\n    List<Person> result = Lists.newArrayList();\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (!idSet.contains(person.get(Person.Field.ID.toString()))) {\n          continue;\n        }\n\n        // Add group support later\n        Person personObj = filterFields(person, fields, Person.class);\n        Map<String, Object> appData = getPersonAppData(\n            person.getString(Person.Field.ID.toString()), fields);\n        personObj.setAppData(appData);\n\n        result.add(personObj);\n      }\n\n      if (GroupId.Type.self == groupId.getType() && result.isEmpty()) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"People '\" + idSet + \"' not found\");\n      }\n\n      // We can pretend that by default the people are in top friends order\n      if (options.getSortBy().equals(Person.Field.NAME.toString())) {\n        Collections.sort(result, NAME_COMPARATOR);\n\n        if (options.getSortOrder() == SortOrder.descending) {\n          Collections.reverse(result);\n        }\n      }\n\n      // TODO: The samplecontainer doesn't really have the concept of HAS_APP so\n      // we can't support any filters yet. We should fix this.\n\n      int totalSize = result.size();\n      int last = options.getFirst() + options.getMax();\n      result = result.subList(options.getFirst(), Math.min(last, totalSize));\n\n      return Futures.immediateFuture(new RestfulCollection<Person>(result, options.getFirst(), totalSize, options.getMax()));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)\n      throws ProtocolException {\n    if (id != null && AnonymousSecurityToken.ANONYMOUS_ID.equals(id.getUserId())) {\n      Person anonymous = new PersonImpl();\n      anonymous.setId(AnonymousSecurityToken.ANONYMOUS_ID);\n      anonymous.setName(new NameImpl(ANONYMOUS_NAME));\n      anonymous.setNickname(ANONYMOUS_NAME);\n      return Futures.immediateFuture(anonymous);\n    }\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (id != null && person.get(Person.Field.ID.toString()).equals(id.getUserId(token))) {\n          Person personObj = filterFields(person, fields, Person.class);\n          Map<String, Object> appData = getPersonAppData(person.getString(Person.Field.ID\n              .toString()), fields);\n          personObj.setAppData(appData);\n\n          return Futures.immediateFuture(personObj);\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Person '\" + id.getUserId(token) + \"' not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> updatePerson(UserId id, Person person, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String viewer = token.getViewerId(); // viewer\n      String user = id.getUserId(token); // person to update\n\n      if (!viewerCanUpdatePerson(viewer,user)) {\n        throw new ProtocolException(HttpServletResponse.SC_FORBIDDEN, \"User '\" + viewer + \"' does not have enough privileges to update person '\"+user+\"'\");\n      }\n\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject curPerson = people.getJSONObject(i);\n\n        if (user != null && curPerson.getString(Person.Field.ID.toString()).equals(user)) {\n          // Convert user to JSON and set ID\n          JSONObject jsonPerson = convertToJson(person);\n          // go through all properties to update in the submitted person object\n          // and change them in the current person object\n          for (String key : JSONObject.getNames(jsonPerson)) {\n            curPerson.put(key,jsonPerson.get(key));\n          }\n\n          people.put(i,curPerson);\n          return Futures.immediateFuture(converter.convertToObject(curPerson.toString(), Person.class));\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User ID \" + user + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n\n  }\n\n  /** Check if a viewer is allowed to update the given person record. **/\n  protected boolean viewerCanUpdatePerson(String viewer, String person) {\n    // A person can only update his own personal data (by default)\n    // if you wish to allow other people to update the personal data of the user\n    // you should change the current function\n    return viewer.equals(person) ? true : false;\n  }\n\n  private Map<String, Object> getPersonAppData(String id, Set<String> fields) {\n    try {\n      Map<String, Object> appData = null;\n      JSONObject personData = db.getJSONObject(DATA_TABLE).optJSONObject(id);\n      if (personData != null) {\n        if (fields.contains(Person.Field.APP_DATA.toString())) {\n          appData = Maps.newHashMap();\n          @SuppressWarnings(\"unchecked\")\n          Iterator<String> keys = personData.keys();\n          while (keys.hasNext()) {\n            String key = keys.next();\n            appData.put(key, personData.get(key));\n          }\n        } else {\n          String appDataPrefix = Person.Field.APP_DATA.toString() + '.';\n          for (String field : fields) {\n            if (field.startsWith(appDataPrefix)) {\n              if (appData == null) {\n                appData = Maps.newHashMap();\n              }\n\n              String appDataField = field.substring(appDataPrefix.length());\n              if (personData.has(appDataField)) {\n                appData.put(appDataField, personData.get(appDataField));\n              }\n            }\n          }\n        }\n      }\n\n      return appData;\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      Map<String, Map<String, Object>> idToData = Maps.newHashMap();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        JSONObject personData;\n        if (!db.getJSONObject(DATA_TABLE).has(id)) {\n          personData = new JSONObject();\n        } else {\n          if (!fields.isEmpty()) {\n            personData = new JSONObject(db.getJSONObject(DATA_TABLE).getJSONObject(id), fields\n                .toArray(new String[fields.size()]));\n          } else {\n            personData = db.getJSONObject(DATA_TABLE).getJSONObject(id);\n          }\n        }\n\n        // TODO: We can use the converter here to do this for us\n\n        // JSONObject keys are always strings\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = personData.keys();\n        Map<String, Object> data = Maps.newHashMap();\n        while (keys.hasNext()) {\n          String key = keys.next();\n          data.put(key, personData.getString(key));\n        }\n        idToData.put(id, data);\n      }\n      return Futures.immediateFuture(new DataCollection(idToData));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (!db.getJSONObject(DATA_TABLE).has(user)) {\n        return null;\n      }\n      JSONObject newPersonData = new JSONObject();\n      JSONObject oldPersonData = db.getJSONObject(DATA_TABLE).getJSONObject(user);\n\n      // JSONObject keys are always strings\n      @SuppressWarnings(\"unchecked\")\n      Iterator<String> keys = oldPersonData.keys();\n      while (keys.hasNext()) {\n        String key = keys.next();\n        if (!fields.contains(key)) {\n          newPersonData.put(key, oldPersonData.getString(key));\n        }\n      }\n      db.getJSONObject(DATA_TABLE).put(user, newPersonData);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Map<String, Object> values, SecurityToken token)\n      throws ProtocolException {\n    // TODO: this seems redundant. No need to pass both fields and a map of\n    // field->value\n    // TODO: According to rest, yes there is. If a field is in the param list\n    // but not in the map\n    // that means it is a delete\n\n    try {\n      JSONObject personData = db.getJSONObject(DATA_TABLE).getJSONObject(userId.getUserId(token));\n      if (personData == null) {\n        personData = new JSONObject();\n        db.getJSONObject(DATA_TABLE).put(userId.getUserId(token), personData);\n      }\n\n      for (Map.Entry<String, Object> entry : values.entrySet()) {\n        personData.put(entry.getKey(), entry.getValue());\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Group>> getGroups(UserId userId,\n\t\tCollectionOptions options, Set<String> fields, SecurityToken token)\n\t\tthrows ProtocolException {\n    List<Group> result = Lists.newArrayList();\n    String user = userId.getUserId(token);\n    try {\n      JSONArray groups = db.getJSONObject(GROUPS_TABLE).getJSONArray(user);\n\n      for (int i = 0; i < groups.length(); i++) {\n        JSONObject group = groups.getJSONObject(i);\n\n        Group groupObj = filterFields(group, fields, Group.class);\n        result.add(groupObj);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n\n    return Futures.immediateFuture(new RestfulCollection<Group>(result));\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Post a message for a set of users.\n   */\n  public Future<Void> createMessage(UserId userId, String appId, String msgCollId, Message message,\n      SecurityToken token) throws ProtocolException {\n    if (message.getId() == null) {\n      // Assign a new ID to the message\n      message.setId(UUID.randomUUID().toString());\n    }\n    try {\n      JSONObject messagesTable = db.getJSONObject(MESSAGE_TABLE);\n      JSONObject messageObject = convertToJson(message);\n      for (String recipient : message.getRecipients()) {\n        JSONObject collection = messagesTable.getJSONObject(recipient).getJSONObject(msgCollId);\n        JSONArray outbox = collection.getJSONArray(MESSAGES_ARRAY);\n        if (outbox == null) {\n          outbox = new JSONArray();\n          collection.put(MESSAGES_ARRAY, outbox);\n        }\n\n        outbox.put(messageObject);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n\n    return Futures.immediateFuture(null);\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MessageCollection>> getMessageCollections(UserId userId,\n      Set<String> fields, CollectionOptions options, SecurityToken token) throws ProtocolException {\n    try {\n      List<MessageCollection> result = Lists.newArrayList();\n      JSONObject messageCollections = db.getJSONObject(MESSAGE_TABLE).getJSONObject(\n          userId.getUserId(token));\n      for (String msgCollId : JSONObject.getNames(messageCollections)) {\n        JSONObject msgColl = messageCollections.getJSONObject(msgCollId);\n        msgColl.put(\"id\", msgCollId);\n        JSONArray messages = msgColl.getJSONArray(MESSAGES_ARRAY);\n        int numMessages = (messages == null) ? 0 : messages.length();\n        msgColl.put(\"total\", String.valueOf(numMessages));\n        msgColl.put(\"unread\", String.valueOf(numMessages));\n\n        result.add(filterFields(msgColl, fields, MessageCollection.class));\n      }\n      return Futures.immediateFuture(new RestfulCollection<MessageCollection>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessages(UserId userId, String msgCollId, List<String> ids,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Gets the messsages in an user's queue.\n   */\n  public Future<RestfulCollection<Message>> getMessages(UserId userId, String msgCollId,\n      Set<String> fields, List<String> msgIds, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Message> result = Lists.newArrayList();\n      JSONArray messages = db.getJSONObject(MESSAGE_TABLE).getJSONObject(userId.getUserId(token))\n          .getJSONObject(msgCollId).getJSONArray(MESSAGES_ARRAY);\n\n      // TODO: special case @all\n\n      if (messages == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"message collection\"\n            + msgCollId + \" not found\");\n      }\n\n      // TODO: filter and sort outbox.\n      for (int i = 0; i < messages.length(); i++) {\n        JSONObject msg = messages.getJSONObject(i);\n        Message message = filterFields(msg, fields, Message.class);\n        if (msgIds.isEmpty() || msgIds.contains(message.getId())) {\n          result.add(message);\n        }\n      }\n\n      return Futures.immediateFuture(new RestfulCollection<Message>(result));\n\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<MessageCollection> createMessageCollection(UserId userId,\n      MessageCollection msgCollection, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessage(UserId userId, String msgCollId, String messageId,\n      Message message, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessageCollection(UserId userId, MessageCollection msgCollection,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessageCollection(UserId userId, String msgCollId, SecurityToken token)\n      throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * Public methods for use with Authentication Classes\n   *\n   * @param username a {@link java.lang.String} object.\n   * @return a {@link java.lang.String} object.\n   */\n  public String getPassword(String username) {\n    try {\n      return db.getJSONObject(PASSWORDS_TABLE).getString(username);\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n\n  private Set<String> getIdSet(UserId user, GroupId group, SecurityToken token)\n      throws JSONException {\n    String userId = user.getUserId(token);\n\n    if (group == null) {\n      return ImmutableSortedSet.of(userId);\n    }\n\n    Set<String> returnVal = Sets.newLinkedHashSet();\n    switch (group.getType()) {\n    case all:\n    case friends:\n      if (db.getJSONObject(FRIEND_LINK_TABLE).has(userId)) {\n        JSONArray friends = db.getJSONObject(FRIEND_LINK_TABLE).getJSONArray(userId);\n        for (int i = 0; i < friends.length(); i++) {\n          returnVal.add(friends.getString(i));\n        }\n      }\n      break;\n    case objectId:\n      if (db.getJSONObject(GROUP_MEMBERS_TABLE).has(group.toString())) {\n        JSONArray groupMembers = db.getJSONObject(GROUP_MEMBERS_TABLE).getJSONArray(group.toString());\n        for (int i = 0; i < groupMembers.length(); i++) {\n          returnVal.add(groupMembers.getString(i));\n        }\n      }\n      break;\n    case self:\n      returnVal.add(userId);\n      break;\n    }\n    return returnVal;\n  }\n\n  /**\n   * Get the set of user id's for a set of users and a group\n   *\n   * @param users set of UserIds\n   * @param group the group\n   * @param token a token\n   * @return set of Id strings\n   * @throws org.json.JSONException if errors in Json\n   */\n  public Set<String> getIdSet(Set<UserId> users, GroupId group, SecurityToken token)\n      throws JSONException {\n    Set<String> ids = Sets.newLinkedHashSet();\n    for (UserId user : users) {\n      ids.addAll(getIdSet(user, group, token));\n    }\n    return ids;\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Album> getAlbum(UserId userId, String appId, Set<String> fields,\n                                String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Search albums for given ID and owner\n        JSONObject album;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          album = userAlbums.getJSONObject(i);\n          if (album.getString(Album.Field.ID.toString()).equals(albumId) &&\n              album.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n            return Futures.immediateFuture(filterFields(album, fields, Album.class));\n          }\n        }\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(UserId userId, String appId,\n                                                    Set<String> fields, CollectionOptions options, Set<String> albumIds,\n                                                    SecurityToken token) throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Stores target albums\n        List<Album> result = Lists.newArrayList();\n\n        // Search for every albumId\n        boolean found;\n        JSONObject curAlbum;\n        for (String albumId : albumIds) {\n          // Search albums for this albumId\n          found = false;\n          for (int i = 0; i < userAlbums.length(); i++) {\n            curAlbum = userAlbums.getJSONObject(i);\n            if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId) &&\n                curAlbum.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n              result.add(filterFields(curAlbum, fields, Album.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - albumId not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n          }\n        }\n\n        // Return found albums\n        return Futures.immediateFuture(new RestfulCollection<Album>(result));\n      }\n\n      // Album table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User '\" + user + \"' has no albums\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(Set<UserId> userIds,\n                                                    GroupId groupId, String appId, Set<String> fields,\n                                                    CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Album> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather albums for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(ALBUMS_TABLE).has(id)) {\n          JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userAlbums.length(); i++) {\n            JSONObject album = userAlbums.getJSONObject(i);\n            if (album.getString(Album.Field.OWNER_ID.toString()).equals(id)) {\n              result.add(filterFields(album, fields, Album.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Album>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteAlbum(UserId userId, String appId, String albumId,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      boolean targetFound = false;      // indicates if target album is found\n      JSONArray newAlbums = new JSONArray();  // list of albums minus target\n      String user = userId.getUserId(token);  // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Compose new list of albums excluding album to be deleted\n        JSONObject curAlbum;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newAlbums.put(curAlbum);\n          }\n        }\n      }\n\n      // Overwrite user's albums with updated list if album found\n      if (targetFound) {\n        db.getJSONObject(ALBUMS_TABLE).put(user, newAlbums);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: userId and album's ownerId don't have to match - potential problem\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createAlbum(UserId userId, String appId, Album album,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      // Get table of user's albums\n      String user = userId.getUserId(token);\n      JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n      if (userAlbums == null) {\n        userAlbums = new JSONArray();\n        db.getJSONObject(ALBUMS_TABLE).put(user, userAlbums);\n      }\n\n      // Convert album to JSON and set ID & owner\n      JSONObject jsonAlbum = convertToJson(album);\n      if (!jsonAlbum.has(Album.Field.ID.toString())) {\n        jsonAlbum.put(Album.Field.ID.toString(), System.currentTimeMillis());\n      }\n      if (!jsonAlbum.has(Album.Field.OWNER_ID.toString())) {\n        jsonAlbum.put(Album.Field.OWNER_ID.toString(), user);\n      }\n\n      // Insert new album into table\n      userAlbums.put(jsonAlbum);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateAlbum(UserId userId, String appId, Album album,\n                                  String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Convert album to JSON and set ID\n        JSONObject jsonAlbum = convertToJson(album);\n        jsonAlbum.put(Album.Field.ID.toString(), albumId);\n\n        // Iterate through albums to identify album to update\n        for (int i = 0; i < userAlbums.length(); i++) {\n          JSONObject curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            userAlbums.put(i, jsonAlbum);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<MediaItem> getMediaItem(UserId userId, String appId,\n                                        String albumId, String mediaItemId, Set<String> fields,\n                                        SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Search user's MediaItems for given ID and album\n        JSONObject mediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          mediaItem = userMediaItems.getJSONObject(i);\n          if (mediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              mediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            return Futures.immediateFuture(filterFields(mediaItem, fields, MediaItem.class));\n          }\n        }\n      }\n\n      // MediaItem wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID '\" + mediaItemId + \"' does not exist within Album '\" + albumId + '\\'');\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> mediaItemIds,\n                                                            Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores found MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search for every MediaItem ID target\n        boolean found;\n        JSONObject curMediaItem;\n        for (String mediaItemId : mediaItemIds) {\n          // Search existing MediaItems for this MediaItem ID\n          found = false;\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            curMediaItem = userMediaItems.getJSONObject(i);\n            if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(albumId) &&\n                curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n              result.add(filterFields(curMediaItem, fields, MediaItem.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - MediaItem ID not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist within Album \" + albumId);\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem table not found for user \" + user);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> fields,\n                                                            CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores target MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search user's MediaItems for given album\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            result.add(filterFields(curMediaItem, fields, MediaItem.class));\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(\n      Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<MediaItem> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather MediaItems for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(MEDIAITEMS_TABLE).has(id)) {\n          JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            result.add(filterFields(userMediaItems.getJSONObject(i), fields, MediaItem.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      boolean targetFound = false;        // indicates if target MediaItem is found\n      JSONArray newMediaItems = new JSONArray();  // list of MediaItems minus target\n      String user = userId.getUserId(token);    // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Compose new list of MediaItems excluding item to be deleted\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newMediaItems.put(curMediaItem);\n          }\n        }\n      }\n\n      // Overwrite user's MediaItems with updated list if target found\n      if (targetFound) {\n        db.getJSONObject(MEDIAITEMS_TABLE).put(user, newMediaItems);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createMediaItem(UserId userId, String appId,\n                                      String albumId, MediaItem mediaItem, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Get table of user's MediaItems\n      JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(userId.getUserId(token));\n      if (userMediaItems == null) {\n        userMediaItems = new JSONArray();\n        db.getJSONObject(MEDIAITEMS_TABLE).put(userId.getUserId(token), userMediaItems);\n      }\n\n      // Convert MediaItem to JSON and set ID & Album ID\n      JSONObject jsonMediaItem = convertToJson(mediaItem);\n      jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n      if (!jsonMediaItem.has(MediaItem.Field.ID.toString())) {\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), System.currentTimeMillis());\n      }\n\n      // Insert new MediaItem into table\n      userMediaItems.put(jsonMediaItem);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, MediaItem mediaItem,\n                                      SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Convert MediaItem to JSON and set ID & Album ID\n        JSONObject jsonMediaItem = convertToJson(mediaItem);\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), mediaItemId);\n        jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n\n        // Iterate through MediaItems to identify item to update\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          JSONObject curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            userMediaItems.put(i, jsonMediaItem);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no MediaItem found with given ID and Album ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> updateActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        if (activityId != null) {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), activityId);\n        } else {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n        }\n      }\n      activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Find & replace activity\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          jsonArray.put(i, jsonEntry);\n          return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> createActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n      }\n      String activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Ensure activity does not already exist\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity already exists: \" + activityId);\n        }\n      }\n      jsonArray.put(jsonEntry);\n      return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivityEntries(UserId userId, GroupId groupId,\n      String appId, Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n\n        if (activityEntries != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (!activityIds.contains(activityEntry.getString(ActivityEntry.Field.ID.toString()))) {\n              newList.put(activityEntry);\n            }\n          }\n          db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(user, newList);\n        }\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> getActivityEntry(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, String activityId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for (int i = 0; i < activityEntries.length(); i++) {\n          JSONObject activityEntry = activityEntries.getJSONObject(i);\n          if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activityEntry, fields, ActivityEntry.class));\n          }\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n\n/** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      Set<UserId> userIds, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n      List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(id)) {\n          JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n            // TODO: ActivityStreams don't have appIds\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      UserId userId, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, Set<String> activityIds, SecurityToken token)\n      throws ProtocolException {\n    List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for(String activityId : activityIds) {\n          boolean found = false;\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n              result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND, \"Activity not found: \" + activityId);\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // TODO Why specifically handle Activity instead of generic POJO (below)?\n\n  private JSONObject convertFromActivity(Activity activity, Set<String> fields)\n      throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activity));\n  }\n\n  private JSONObject convertFromActivityEntry(ActivityEntry activityEntry, Set<String> fields) throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activityEntry));\n  }\n\n  private JSONObject convertToJson(Object object) throws JSONException {\n    // TODO not using fields yet\n    return new JSONObject(converter.convertToString(object));\n  }\n\n  public <T> T filterFields(JSONObject object, Set<String> fields,\n                            Class<T> clz) throws JSONException {\n    if (!fields.isEmpty()) {\n      // Create a copy with just the specified fields\n      object = new JSONObject(object, fields.toArray(new String[fields\n          .size()]));\n    }\n    String objectVal = object.toString();\n    if (authority != null) {\n      objectVal = objectVal.replace(\"%origin%\", authority.getOrigin());\n    } else {\n      //provide default for junit tests\n      objectVal = objectVal.replace(\"%origin%\", \"http://localhost:8080\");\n    }\n    return converter.convertToObject(objectVal, clz);\n  }\n}\n","lineNo":630}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.social.sample.spi;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Future;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.AnonymousSecurityToken;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.protocol.DataCollection;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.RestfulCollection;\nimport org.apache.shindig.protocol.conversion.BeanConverter;\nimport org.apache.shindig.protocol.model.SortOrder;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.opensocial.model.Activity;\nimport org.apache.shindig.social.opensocial.model.ActivityEntry;\nimport org.apache.shindig.social.opensocial.model.Album;\nimport org.apache.shindig.social.opensocial.model.Group;\nimport org.apache.shindig.social.opensocial.model.MediaItem;\nimport org.apache.shindig.social.opensocial.model.Message;\nimport org.apache.shindig.social.opensocial.model.MessageCollection;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.spi.ActivityService;\nimport org.apache.shindig.social.opensocial.spi.ActivityStreamService;\nimport org.apache.shindig.social.opensocial.spi.AlbumService;\nimport org.apache.shindig.social.opensocial.spi.AppDataService;\nimport org.apache.shindig.social.opensocial.spi.CollectionOptions;\nimport org.apache.shindig.social.opensocial.spi.GroupId;\nimport org.apache.shindig.social.opensocial.spi.GroupService;\nimport org.apache.shindig.social.opensocial.spi.MediaItemService;\nimport org.apache.shindig.social.opensocial.spi.MessageService;\nimport org.apache.shindig.social.opensocial.spi.PersonService;\nimport org.apache.shindig.social.opensocial.spi.UserId;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\n\n/**\n * Implementation of supported services backed by a JSON DB.\n */\n@Singleton\npublic class JsonDbOpensocialService implements ActivityService, PersonService, AppDataService,\n    MessageService, AlbumService, MediaItemService, ActivityStreamService, GroupService {\n\n  private static final Comparator<Person> NAME_COMPARATOR = new Comparator<Person>() {\n    public int compare(Person person, Person person1) {\n      String name = person.getName().getFormatted();\n      String name1 = person1.getName().getFormatted();\n      return name.compareTo(name1);\n    }\n  };\n\n  /**\n   * The DB\n   */\n  private JSONObject db;\n\n  /**\n   * The JSON<->Bean converter\n   */\n  private BeanConverter converter;\n\n  /**\n   * db[\"people\"] -> Array<Person>\n   */\n  private static final String PEOPLE_TABLE = \"people\";\n\n  /**\n   * db[\"groups\"] -> Array<Group>\n   */\n  private static final String GROUPS_TABLE = \"groups\";\n\n  /**\n   * db[\"groupMembers\"] -> Array<Person>\n   */\n  private static final String GROUP_MEMBERS_TABLE = \"groupMembers\";\n\n  /**\n   * db[\"activities\"] -> Map<Person.Id, Array<Activity>>\n   */\n  private static final String ACTIVITIES_TABLE = \"activities\";\n\n  /**\n   * db[\"albums\"] -> Map<Person.Id, Array<Album>>\n   */\n  private static final String ALBUMS_TABLE = \"albums\";\n\n  /**\n   * db[\"mediaItems\"] -> Map<Person.Id, Array<MediaItem>>\n   */\n  private static final String MEDIAITEMS_TABLE = \"mediaItems\";\n\n  /**\n   * db[\"data\"] -> Map<Person.Id, Map<String, String>>\n   */\n  private static final String DATA_TABLE = \"data\";\n\n  /**\n   * db[\"friendLinks\"] -> Map<Person.Id, Array<Person.Id>>\n   */\n  private static final String FRIEND_LINK_TABLE = \"friendLinks\";\n\n  /**\n   * db[\"messages\"] -> Map<Person.Id, Array<Message>>\n   */\n  private static final String MESSAGE_TABLE = \"messages\";\n\n  /**\n   * db[\"passwords\"] -> Map<Person.Id, String>\n   */\n  private static final String PASSWORDS_TABLE = \"passwords\";\n\n  /**\n   * db[\"activityEntries\"] -> Map<Person.Id, Array<ActivityEntry>>\n   */\n  private static final String ACTIVITYSTREAMS_TABLE = \"activityEntries\";\n\n  /**\n   * Anonymous name.\n   */\n  private static final String ANONYMOUS_NAME = \"Anonymous\";\n\n  private Authority authority;\n\n  /**\n   * Initializes the JsonDbOpensocialService using Guice\n   *\n   * @param jsonLocation location of the json data provided by the shindig.canonical.json.db parameter\n   * @param converter an injected BeanConverter\n   * @throws java.lang.Exception if any\n   */\n  @Inject\n  public JsonDbOpensocialService(@Named(\"shindig.canonical.json.db\")\n  String jsonLocation, @Named(\"shindig.bean.converter.json\")\n  BeanConverter converter,\n  @Named(\"shindig.contextroot\") String contextroot) throws Exception {\n    String content = IOUtils.toString(ResourceLoader.openResource(jsonLocation), \"UTF-8\");\n    this.db = new JSONObject(content.replace(\"%contextroot%\", contextroot));\n    this.converter = converter;\n  }\n\n  /**\n   * Allows access to the underlying json db.\n   *\n   * @return a reference to the json db\n   */\n  public JSONObject getDb() {\n    return db;\n  }\n\n   /**\n   * override the json database\n   * @param db a {@link org.json.JSONObject}.\n   */\n  public void setDb(JSONObject db) {\n    this.db = db;\n  }\n\n  @Inject(optional = true)\n  public void setAuthority(Authority authority) {\n    this.authority = authority;\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(Set<UserId> userIds, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITIES_TABLE).has(id)) {\n          JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(id);\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (appId == null || !activity.has(Activity.Field.APP_ID.toString())) {\n              result.add(filterFields(activity, fields, Activity.class));\n            } else if (activity.get(Activity.Field.APP_ID.toString()).equals(appId)) {\n              result.add(filterFields(activity, fields, Activity.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, Set<String> activityIds,\n      SecurityToken token) throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n            result.add(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Activity> getActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activity.get(Activity.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivities(UserId userId, GroupId groupId, String appId,\n      Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        if (activities != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (!activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n              newList.put(activity);\n            }\n          }\n          db.getJSONObject(ACTIVITIES_TABLE).put(user, newList);\n          // TODO. This seems very odd that we return no useful response in this\n          // case\n          // There is no way to represent not-found\n          // if (found) { ??\n          // }\n        }\n      }\n      // What is the appropriate response here??\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> createActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Activity activity, SecurityToken token) throws ProtocolException {\n    // Are fields really needed here?\n    try {\n      JSONObject jsonObject = convertFromActivity(activity, fields);\n      if (!jsonObject.has(Activity.Field.ID.toString())) {\n        jsonObject.put(Activity.Field.ID.toString(), System.currentTimeMillis());\n      }\n      JSONArray jsonArray = db.getJSONObject(ACTIVITIES_TABLE)\n          .getJSONArray(userId.getUserId(token));\n      if (jsonArray == null) {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITIES_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      // TODO (woodser): if used with PUT, duplicate activity would be created?\n      jsonArray.put(jsonObject);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Person>> getPeople(Set<UserId> userIds, GroupId groupId,\n      CollectionOptions options, Set<String> fields, SecurityToken token) throws ProtocolException {\n    List<Person> result = Lists.newArrayList();\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (!idSet.contains(person.get(Person.Field.ID.toString()))) {\n          continue;\n        }\n\n        // Add group support later\n        Person personObj = filterFields(person, fields, Person.class);\n        Map<String, Object> appData = getPersonAppData(\n            person.getString(Person.Field.ID.toString()), fields);\n        personObj.setAppData(appData);\n\n        result.add(personObj);\n      }\n\n      if (GroupId.Type.self == groupId.getType() && result.isEmpty()) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"People '\" + idSet + \"' not found\");\n      }\n\n      // We can pretend that by default the people are in top friends order\n      if (options.getSortBy().equals(Person.Field.NAME.toString())) {\n        Collections.sort(result, NAME_COMPARATOR);\n\n        if (options.getSortOrder() == SortOrder.descending) {\n          Collections.reverse(result);\n        }\n      }\n\n      // TODO: The samplecontainer doesn't really have the concept of HAS_APP so\n      // we can't support any filters yet. We should fix this.\n\n      int totalSize = result.size();\n      int last = options.getFirst() + options.getMax();\n      result = result.subList(options.getFirst(), Math.min(last, totalSize));\n\n      return Futures.immediateFuture(new RestfulCollection<Person>(result, options.getFirst(), totalSize, options.getMax()));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)\n      throws ProtocolException {\n    if (id != null && AnonymousSecurityToken.ANONYMOUS_ID.equals(id.getUserId())) {\n      Person anonymous = new PersonImpl();\n      anonymous.setId(AnonymousSecurityToken.ANONYMOUS_ID);\n      anonymous.setName(new NameImpl(ANONYMOUS_NAME));\n      anonymous.setNickname(ANONYMOUS_NAME);\n      return Futures.immediateFuture(anonymous);\n    }\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (id != null && person.get(Person.Field.ID.toString()).equals(id.getUserId(token))) {\n          Person personObj = filterFields(person, fields, Person.class);\n          Map<String, Object> appData = getPersonAppData(person.getString(Person.Field.ID\n              .toString()), fields);\n          personObj.setAppData(appData);\n\n          return Futures.immediateFuture(personObj);\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Person '\" + id.getUserId(token) + \"' not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> updatePerson(UserId id, Person person, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String viewer = token.getViewerId(); // viewer\n      String user = id.getUserId(token); // person to update\n\n      if (!viewerCanUpdatePerson(viewer,user)) {\n        throw new ProtocolException(HttpServletResponse.SC_FORBIDDEN, \"User '\" + viewer + \"' does not have enough privileges to update person '\"+user+\"'\");\n      }\n\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject curPerson = people.getJSONObject(i);\n\n        if (user != null && curPerson.getString(Person.Field.ID.toString()).equals(user)) {\n          // Convert user to JSON and set ID\n          JSONObject jsonPerson = convertToJson(person);\n          // go through all properties to update in the submitted person object\n          // and change them in the current person object\n          for (String key : JSONObject.getNames(jsonPerson)) {\n            curPerson.put(key,jsonPerson.get(key));\n          }\n\n          people.put(i,curPerson);\n          return Futures.immediateFuture(converter.convertToObject(curPerson.toString(), Person.class));\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User ID \" + user + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n\n  }\n\n  /** Check if a viewer is allowed to update the given person record. **/\n  protected boolean viewerCanUpdatePerson(String viewer, String person) {\n    // A person can only update his own personal data (by default)\n    // if you wish to allow other people to update the personal data of the user\n    // you should change the current function\n    return viewer.equals(person) ? true : false;\n  }\n\n  private Map<String, Object> getPersonAppData(String id, Set<String> fields) {\n    try {\n      Map<String, Object> appData = null;\n      JSONObject personData = db.getJSONObject(DATA_TABLE).optJSONObject(id);\n      if (personData != null) {\n        if (fields.contains(Person.Field.APP_DATA.toString())) {\n          appData = Maps.newHashMap();\n          @SuppressWarnings(\"unchecked\")\n          Iterator<String> keys = personData.keys();\n          while (keys.hasNext()) {\n            String key = keys.next();\n            appData.put(key, personData.get(key));\n          }\n        } else {\n          String appDataPrefix = Person.Field.APP_DATA.toString() + '.';\n          for (String field : fields) {\n            if (field.startsWith(appDataPrefix)) {\n              if (appData == null) {\n                appData = Maps.newHashMap();\n              }\n\n              String appDataField = field.substring(appDataPrefix.length());\n              if (personData.has(appDataField)) {\n                appData.put(appDataField, personData.get(appDataField));\n              }\n            }\n          }\n        }\n      }\n\n      return appData;\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      Map<String, Map<String, Object>> idToData = Maps.newHashMap();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        JSONObject personData;\n        if (!db.getJSONObject(DATA_TABLE).has(id)) {\n          personData = new JSONObject();\n        } else {\n          if (!fields.isEmpty()) {\n            personData = new JSONObject(db.getJSONObject(DATA_TABLE).getJSONObject(id), fields\n                .toArray(new String[fields.size()]));\n          } else {\n            personData = db.getJSONObject(DATA_TABLE).getJSONObject(id);\n          }\n        }\n\n        // TODO: We can use the converter here to do this for us\n\n        // JSONObject keys are always strings\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = personData.keys();\n        Map<String, Object> data = Maps.newHashMap();\n        while (keys.hasNext()) {\n          String key = keys.next();\n          data.put(key, personData.getString(key));\n        }\n        idToData.put(id, data);\n      }\n      return Futures.immediateFuture(new DataCollection(idToData));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (!db.getJSONObject(DATA_TABLE).has(user)) {\n        return null;\n      }\n      JSONObject newPersonData = new JSONObject();\n      JSONObject oldPersonData = db.getJSONObject(DATA_TABLE).getJSONObject(user);\n\n      // JSONObject keys are always strings\n      @SuppressWarnings(\"unchecked\")\n      Iterator<String> keys = oldPersonData.keys();\n      while (keys.hasNext()) {\n        String key = keys.next();\n        if (!fields.contains(key)) {\n          newPersonData.put(key, oldPersonData.getString(key));\n        }\n      }\n      db.getJSONObject(DATA_TABLE).put(user, newPersonData);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Map<String, Object> values, SecurityToken token)\n      throws ProtocolException {\n    // TODO: this seems redundant. No need to pass both fields and a map of\n    // field->value\n    // TODO: According to rest, yes there is. If a field is in the param list\n    // but not in the map\n    // that means it is a delete\n\n    try {\n      JSONObject personData = db.getJSONObject(DATA_TABLE).getJSONObject(userId.getUserId(token));\n      if (personData == null) {\n        personData = new JSONObject();\n        db.getJSONObject(DATA_TABLE).put(userId.getUserId(token), personData);\n      }\n\n      for (Map.Entry<String, Object> entry : values.entrySet()) {\n        personData.put(entry.getKey(), entry.getValue());\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Group>> getGroups(UserId userId,\n\t\tCollectionOptions options, Set<String> fields, SecurityToken token)\n\t\tthrows ProtocolException {\n    List<Group> result = Lists.newArrayList();\n    String user = userId.getUserId(token);\n    try {\n      JSONArray groups = db.getJSONObject(GROUPS_TABLE).getJSONArray(user);\n\n      for (int i = 0; i < groups.length(); i++) {\n        JSONObject group = groups.getJSONObject(i);\n\n        Group groupObj = filterFields(group, fields, Group.class);\n        result.add(groupObj);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n\n    return Futures.immediateFuture(new RestfulCollection<Group>(result));\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Post a message for a set of users.\n   */\n  public Future<Void> createMessage(UserId userId, String appId, String msgCollId, Message message,\n      SecurityToken token) throws ProtocolException {\n    for (String recipient : message.getRecipients()) {\n      try {\n        JSONArray outbox = db.getJSONObject(MESSAGE_TABLE).getJSONArray(recipient);\n        if (outbox == null) {\n          outbox = new JSONArray();\n          db.getJSONObject(MESSAGE_TABLE).put(recipient, outbox);\n        }\n\n        outbox.put(message);\n      } catch (JSONException je) {\n        throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n            je);\n      }\n    }\n\n    return Futures.immediateFuture(null);\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MessageCollection>> getMessageCollections(UserId userId,\n      Set<String> fields, CollectionOptions options, SecurityToken token) throws ProtocolException {\n    try {\n      List<MessageCollection> result = Lists.newArrayList();\n      JSONObject messageCollections = db.getJSONObject(MESSAGE_TABLE).getJSONObject(\n          userId.getUserId(token));\n      for (String msgCollId : JSONObject.getNames(messageCollections)) {\n        JSONObject msgColl = messageCollections.getJSONObject(msgCollId);\n        msgColl.put(\"id\", msgCollId);\n        JSONArray messages = msgColl.getJSONArray(\"messages\");\n        int numMessages = (messages == null) ? 0 : messages.length();\n        msgColl.put(\"total\", String.valueOf(numMessages));\n        msgColl.put(\"unread\", String.valueOf(numMessages));\n\n        result.add(filterFields(msgColl, fields, MessageCollection.class));\n      }\n      return Futures.immediateFuture(new RestfulCollection<MessageCollection>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessages(UserId userId, String msgCollId, List<String> ids,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Gets the messsages in an user's queue.\n   */\n  public Future<RestfulCollection<Message>> getMessages(UserId userId, String msgCollId,\n      Set<String> fields, List<String> msgIds, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Message> result = Lists.newArrayList();\n      JSONArray messages = db.getJSONObject(MESSAGE_TABLE).getJSONObject(userId.getUserId(token))\n          .getJSONObject(msgCollId).getJSONArray(\"messages\");\n\n      // TODO: special case @all\n\n      if (messages == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"message collection\"\n            + msgCollId + \" not found\");\n      }\n\n      // TODO: filter and sort outbox.\n      for (int i = 0; i < messages.length(); i++) {\n        JSONObject msg = messages.getJSONObject(i);\n        Message message = filterFields(msg, fields, Message.class);\n        if (msgIds.isEmpty() || msgIds.contains(message.getId())) {\n          result.add(message);\n        }\n      }\n\n      return Futures.immediateFuture(new RestfulCollection<Message>(result));\n\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<MessageCollection> createMessageCollection(UserId userId,\n      MessageCollection msgCollection, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessage(UserId userId, String msgCollId, String messageId,\n      Message message, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessageCollection(UserId userId, MessageCollection msgCollection,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessageCollection(UserId userId, String msgCollId, SecurityToken token)\n      throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * Public methods for use with Authentication Classes\n   *\n   * @param username a {@link java.lang.String} object.\n   * @return a {@link java.lang.String} object.\n   */\n  public String getPassword(String username) {\n    try {\n      return db.getJSONObject(PASSWORDS_TABLE).getString(username);\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n\n  private Set<String> getIdSet(UserId user, GroupId group, SecurityToken token)\n      throws JSONException {\n    String userId = user.getUserId(token);\n\n    if (group == null) {\n      return ImmutableSortedSet.of(userId);\n    }\n\n    Set<String> returnVal = Sets.newLinkedHashSet();\n    switch (group.getType()) {\n    case all:\n    case friends:\n      if (db.getJSONObject(FRIEND_LINK_TABLE).has(userId)) {\n        JSONArray friends = db.getJSONObject(FRIEND_LINK_TABLE).getJSONArray(userId);\n        for (int i = 0; i < friends.length(); i++) {\n          returnVal.add(friends.getString(i));\n        }\n      }\n      break;\n    case objectId:\n      if (db.getJSONObject(GROUP_MEMBERS_TABLE).has(group.toString())) {\n        JSONArray groupMembers = db.getJSONObject(GROUP_MEMBERS_TABLE).getJSONArray(group.toString());\n        for (int i = 0; i < groupMembers.length(); i++) {\n          returnVal.add(groupMembers.getString(i));\n        }\n      }\n      break;\n    case self:\n      returnVal.add(userId);\n      break;\n    }\n    return returnVal;\n  }\n\n  /**\n   * Get the set of user id's for a set of users and a group\n   *\n   * @param users set of UserIds\n   * @param group the group\n   * @param token a token\n   * @return set of Id strings\n   * @throws org.json.JSONException if errors in Json\n   */\n  public Set<String> getIdSet(Set<UserId> users, GroupId group, SecurityToken token)\n      throws JSONException {\n    Set<String> ids = Sets.newLinkedHashSet();\n    for (UserId user : users) {\n      ids.addAll(getIdSet(user, group, token));\n    }\n    return ids;\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Album> getAlbum(UserId userId, String appId, Set<String> fields,\n                                String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Search albums for given ID and owner\n        JSONObject album;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          album = userAlbums.getJSONObject(i);\n          if (album.getString(Album.Field.ID.toString()).equals(albumId) &&\n              album.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n            return Futures.immediateFuture(filterFields(album, fields, Album.class));\n          }\n        }\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(UserId userId, String appId,\n                                                    Set<String> fields, CollectionOptions options, Set<String> albumIds,\n                                                    SecurityToken token) throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Stores target albums\n        List<Album> result = Lists.newArrayList();\n\n        // Search for every albumId\n        boolean found;\n        JSONObject curAlbum;\n        for (String albumId : albumIds) {\n          // Search albums for this albumId\n          found = false;\n          for (int i = 0; i < userAlbums.length(); i++) {\n            curAlbum = userAlbums.getJSONObject(i);\n            if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId) &&\n                curAlbum.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n              result.add(filterFields(curAlbum, fields, Album.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - albumId not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n          }\n        }\n\n        // Return found albums\n        return Futures.immediateFuture(new RestfulCollection<Album>(result));\n      }\n\n      // Album table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User '\" + user + \"' has no albums\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(Set<UserId> userIds,\n                                                    GroupId groupId, String appId, Set<String> fields,\n                                                    CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Album> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather albums for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(ALBUMS_TABLE).has(id)) {\n          JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userAlbums.length(); i++) {\n            JSONObject album = userAlbums.getJSONObject(i);\n            if (album.getString(Album.Field.OWNER_ID.toString()).equals(id)) {\n              result.add(filterFields(album, fields, Album.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Album>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteAlbum(UserId userId, String appId, String albumId,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      boolean targetFound = false;      // indicates if target album is found\n      JSONArray newAlbums = new JSONArray();  // list of albums minus target\n      String user = userId.getUserId(token);  // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Compose new list of albums excluding album to be deleted\n        JSONObject curAlbum;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newAlbums.put(curAlbum);\n          }\n        }\n      }\n\n      // Overwrite user's albums with updated list if album found\n      if (targetFound) {\n        db.getJSONObject(ALBUMS_TABLE).put(user, newAlbums);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: userId and album's ownerId don't have to match - potential problem\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createAlbum(UserId userId, String appId, Album album,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      // Get table of user's albums\n      String user = userId.getUserId(token);\n      JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n      if (userAlbums == null) {\n        userAlbums = new JSONArray();\n        db.getJSONObject(ALBUMS_TABLE).put(user, userAlbums);\n      }\n\n      // Convert album to JSON and set ID & owner\n      JSONObject jsonAlbum = convertToJson(album);\n      if (!jsonAlbum.has(Album.Field.ID.toString())) {\n        jsonAlbum.put(Album.Field.ID.toString(), System.currentTimeMillis());\n      }\n      if (!jsonAlbum.has(Album.Field.OWNER_ID.toString())) {\n        jsonAlbum.put(Album.Field.OWNER_ID.toString(), user);\n      }\n\n      // Insert new album into table\n      userAlbums.put(jsonAlbum);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateAlbum(UserId userId, String appId, Album album,\n                                  String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Convert album to JSON and set ID\n        JSONObject jsonAlbum = convertToJson(album);\n        jsonAlbum.put(Album.Field.ID.toString(), albumId);\n\n        // Iterate through albums to identify album to update\n        for (int i = 0; i < userAlbums.length(); i++) {\n          JSONObject curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            userAlbums.put(i, jsonAlbum);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<MediaItem> getMediaItem(UserId userId, String appId,\n                                        String albumId, String mediaItemId, Set<String> fields,\n                                        SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Search user's MediaItems for given ID and album\n        JSONObject mediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          mediaItem = userMediaItems.getJSONObject(i);\n          if (mediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              mediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            return Futures.immediateFuture(filterFields(mediaItem, fields, MediaItem.class));\n          }\n        }\n      }\n\n      // MediaItem wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID '\" + mediaItemId + \"' does not exist within Album '\" + albumId + '\\'');\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> mediaItemIds,\n                                                            Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores found MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search for every MediaItem ID target\n        boolean found;\n        JSONObject curMediaItem;\n        for (String mediaItemId : mediaItemIds) {\n          // Search existing MediaItems for this MediaItem ID\n          found = false;\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            curMediaItem = userMediaItems.getJSONObject(i);\n            if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(albumId) &&\n                curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n              result.add(filterFields(curMediaItem, fields, MediaItem.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - MediaItem ID not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist within Album \" + albumId);\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem table not found for user \" + user);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> fields,\n                                                            CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores target MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search user's MediaItems for given album\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            result.add(filterFields(curMediaItem, fields, MediaItem.class));\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(\n      Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<MediaItem> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather MediaItems for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(MEDIAITEMS_TABLE).has(id)) {\n          JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            result.add(filterFields(userMediaItems.getJSONObject(i), fields, MediaItem.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      boolean targetFound = false;        // indicates if target MediaItem is found\n      JSONArray newMediaItems = new JSONArray();  // list of MediaItems minus target\n      String user = userId.getUserId(token);    // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Compose new list of MediaItems excluding item to be deleted\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newMediaItems.put(curMediaItem);\n          }\n        }\n      }\n\n      // Overwrite user's MediaItems with updated list if target found\n      if (targetFound) {\n        db.getJSONObject(MEDIAITEMS_TABLE).put(user, newMediaItems);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createMediaItem(UserId userId, String appId,\n                                      String albumId, MediaItem mediaItem, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Get table of user's MediaItems\n      JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(userId.getUserId(token));\n      if (userMediaItems == null) {\n        userMediaItems = new JSONArray();\n        db.getJSONObject(MEDIAITEMS_TABLE).put(userId.getUserId(token), userMediaItems);\n      }\n\n      // Convert MediaItem to JSON and set ID & Album ID\n      JSONObject jsonMediaItem = convertToJson(mediaItem);\n      jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n      if (!jsonMediaItem.has(MediaItem.Field.ID.toString())) {\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), System.currentTimeMillis());\n      }\n\n      // Insert new MediaItem into table\n      userMediaItems.put(jsonMediaItem);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, MediaItem mediaItem,\n                                      SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Convert MediaItem to JSON and set ID & Album ID\n        JSONObject jsonMediaItem = convertToJson(mediaItem);\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), mediaItemId);\n        jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n\n        // Iterate through MediaItems to identify item to update\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          JSONObject curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            userMediaItems.put(i, jsonMediaItem);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no MediaItem found with given ID and Album ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> updateActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        if (activityId != null) {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), activityId);\n        } else {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n        }\n      }\n      activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Find & replace activity\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          jsonArray.put(i, jsonEntry);\n          return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> createActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n      }\n      String activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Ensure activity does not already exist\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity already exists: \" + activityId);\n        }\n      }\n      jsonArray.put(jsonEntry);\n      return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivityEntries(UserId userId, GroupId groupId,\n      String appId, Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n\n        if (activityEntries != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (!activityIds.contains(activityEntry.getString(ActivityEntry.Field.ID.toString()))) {\n              newList.put(activityEntry);\n            }\n          }\n          db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(user, newList);\n        }\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> getActivityEntry(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, String activityId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for (int i = 0; i < activityEntries.length(); i++) {\n          JSONObject activityEntry = activityEntries.getJSONObject(i);\n          if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activityEntry, fields, ActivityEntry.class));\n          }\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n\n/** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      Set<UserId> userIds, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n      List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(id)) {\n          JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n            // TODO: ActivityStreams don't have appIds\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      UserId userId, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, Set<String> activityIds, SecurityToken token)\n      throws ProtocolException {\n    List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for(String activityId : activityIds) {\n          boolean found = false;\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n              result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND, \"Activity not found: \" + activityId);\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // TODO Why specifically handle Activity instead of generic POJO (below)?\n\n  private JSONObject convertFromActivity(Activity activity, Set<String> fields)\n      throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activity));\n  }\n\n  private JSONObject convertFromActivityEntry(ActivityEntry activityEntry, Set<String> fields) throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activityEntry));\n  }\n\n  private JSONObject convertToJson(Object object) throws JSONException {\n    // TODO not using fields yet\n    return new JSONObject(converter.convertToString(object));\n  }\n\n  public <T> T filterFields(JSONObject object, Set<String> fields,\n                            Class<T> clz) throws JSONException {\n    if (!fields.isEmpty()) {\n      // Create a copy with just the specified fields\n      object = new JSONObject(object, fields.toArray(new String[fields\n          .size()]));\n    }\n    String objectVal = object.toString();\n    if (authority != null) {\n      objectVal = objectVal.replace(\"%origin%\", authority.getOrigin());\n    } else {\n      //provide default for junit tests\n      objectVal = objectVal.replace(\"%origin%\", \"http://localhost:8080\");\n    }\n    return converter.convertToObject(objectVal, clz);\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.social.sample.spi;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.Future;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.AnonymousSecurityToken;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.protocol.DataCollection;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.RestfulCollection;\nimport org.apache.shindig.protocol.conversion.BeanConverter;\nimport org.apache.shindig.protocol.model.SortOrder;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.opensocial.model.Activity;\nimport org.apache.shindig.social.opensocial.model.ActivityEntry;\nimport org.apache.shindig.social.opensocial.model.Album;\nimport org.apache.shindig.social.opensocial.model.Group;\nimport org.apache.shindig.social.opensocial.model.MediaItem;\nimport org.apache.shindig.social.opensocial.model.Message;\nimport org.apache.shindig.social.opensocial.model.MessageCollection;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.spi.ActivityService;\nimport org.apache.shindig.social.opensocial.spi.ActivityStreamService;\nimport org.apache.shindig.social.opensocial.spi.AlbumService;\nimport org.apache.shindig.social.opensocial.spi.AppDataService;\nimport org.apache.shindig.social.opensocial.spi.CollectionOptions;\nimport org.apache.shindig.social.opensocial.spi.GroupId;\nimport org.apache.shindig.social.opensocial.spi.GroupService;\nimport org.apache.shindig.social.opensocial.spi.MediaItemService;\nimport org.apache.shindig.social.opensocial.spi.MessageService;\nimport org.apache.shindig.social.opensocial.spi.PersonService;\nimport org.apache.shindig.social.opensocial.spi.UserId;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\n\n/**\n * Implementation of supported services backed by a JSON DB.\n */\n@Singleton\npublic class JsonDbOpensocialService implements ActivityService, PersonService, AppDataService,\n    MessageService, AlbumService, MediaItemService, ActivityStreamService, GroupService {\n\n  private static final Comparator<Person> NAME_COMPARATOR = new Comparator<Person>() {\n    public int compare(Person person, Person person1) {\n      String name = person.getName().getFormatted();\n      String name1 = person1.getName().getFormatted();\n      return name.compareTo(name1);\n    }\n  };\n\n  /**\n   * The DB\n   */\n  private JSONObject db;\n\n  /**\n   * The JSON<->Bean converter\n   */\n  private BeanConverter converter;\n\n  /**\n   * db[\"people\"] -> Array<Person>\n   */\n  private static final String PEOPLE_TABLE = \"people\";\n\n  /**\n   * db[\"groups\"] -> Array<Group>\n   */\n  private static final String GROUPS_TABLE = \"groups\";\n\n  /**\n   * db[\"groupMembers\"] -> Array<Person>\n   */\n  private static final String GROUP_MEMBERS_TABLE = \"groupMembers\";\n\n  /**\n   * db[\"activities\"] -> Map<Person.Id, Array<Activity>>\n   */\n  private static final String ACTIVITIES_TABLE = \"activities\";\n\n  /**\n   * db[\"albums\"] -> Map<Person.Id, Array<Album>>\n   */\n  private static final String ALBUMS_TABLE = \"albums\";\n\n  /**\n   * db[\"mediaItems\"] -> Map<Person.Id, Array<MediaItem>>\n   */\n  private static final String MEDIAITEMS_TABLE = \"mediaItems\";\n\n  /**\n   * db[\"data\"] -> Map<Person.Id, Map<String, String>>\n   */\n  private static final String DATA_TABLE = \"data\";\n\n  /**\n   * db[\"friendLinks\"] -> Map<Person.Id, Array<Person.Id>>\n   */\n  private static final String FRIEND_LINK_TABLE = \"friendLinks\";\n\n  /**\n   * db[\"messages\"] -> Map<Person.Id, Map<MessageCollection.Id, MessageCollection>>\n   */\n  private static final String MESSAGE_TABLE = \"messages\";\n\n  /**\n   * Attribute that contains the messages of a specific MessageCollection.\n   */\n  private static final String MESSAGES_ARRAY = \"messages\";\n\n  /**\n   * db[\"passwords\"] -> Map<Person.Id, String>\n   */\n  private static final String PASSWORDS_TABLE = \"passwords\";\n\n  /**\n   * db[\"activityEntries\"] -> Map<Person.Id, Array<ActivityEntry>>\n   */\n  private static final String ACTIVITYSTREAMS_TABLE = \"activityEntries\";\n\n  /**\n   * Anonymous name.\n   */\n  private static final String ANONYMOUS_NAME = \"Anonymous\";\n\n  private Authority authority;\n\n  /**\n   * Initializes the JsonDbOpensocialService using Guice\n   *\n   * @param jsonLocation location of the json data provided by the shindig.canonical.json.db parameter\n   * @param converter an injected BeanConverter\n   * @throws java.lang.Exception if any\n   */\n  @Inject\n  public JsonDbOpensocialService(@Named(\"shindig.canonical.json.db\")\n  String jsonLocation, @Named(\"shindig.bean.converter.json\")\n  BeanConverter converter,\n  @Named(\"shindig.contextroot\") String contextroot) throws Exception {\n    String content = IOUtils.toString(ResourceLoader.openResource(jsonLocation), \"UTF-8\");\n    this.db = new JSONObject(content.replace(\"%contextroot%\", contextroot));\n    this.converter = converter;\n  }\n\n  /**\n   * Allows access to the underlying json db.\n   *\n   * @return a reference to the json db\n   */\n  public JSONObject getDb() {\n    return db;\n  }\n\n   /**\n   * override the json database\n   * @param db a {@link org.json.JSONObject}.\n   */\n  public void setDb(JSONObject db) {\n    this.db = db;\n  }\n\n  @Inject(optional = true)\n  public void setAuthority(Authority authority) {\n    this.authority = authority;\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(Set<UserId> userIds, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITIES_TABLE).has(id)) {\n          JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(id);\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (appId == null || !activity.has(Activity.Field.APP_ID.toString())) {\n              result.add(filterFields(activity, fields, Activity.class));\n            } else if (activity.get(Activity.Field.APP_ID.toString()).equals(appId)) {\n              result.add(filterFields(activity, fields, Activity.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, Set<String> activityIds,\n      SecurityToken token) throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n            result.add(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Activity> getActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activity.get(Activity.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivities(UserId userId, GroupId groupId, String appId,\n      Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        if (activities != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (!activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n              newList.put(activity);\n            }\n          }\n          db.getJSONObject(ACTIVITIES_TABLE).put(user, newList);\n          // TODO. This seems very odd that we return no useful response in this\n          // case\n          // There is no way to represent not-found\n          // if (found) { ??\n          // }\n        }\n      }\n      // What is the appropriate response here??\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> createActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Activity activity, SecurityToken token) throws ProtocolException {\n    // Are fields really needed here?\n    try {\n      JSONObject jsonObject = convertFromActivity(activity, fields);\n      if (!jsonObject.has(Activity.Field.ID.toString())) {\n        jsonObject.put(Activity.Field.ID.toString(), System.currentTimeMillis());\n      }\n      JSONArray jsonArray = db.getJSONObject(ACTIVITIES_TABLE)\n          .getJSONArray(userId.getUserId(token));\n      if (jsonArray == null) {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITIES_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      // TODO (woodser): if used with PUT, duplicate activity would be created?\n      jsonArray.put(jsonObject);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Person>> getPeople(Set<UserId> userIds, GroupId groupId,\n      CollectionOptions options, Set<String> fields, SecurityToken token) throws ProtocolException {\n    List<Person> result = Lists.newArrayList();\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (!idSet.contains(person.get(Person.Field.ID.toString()))) {\n          continue;\n        }\n\n        // Add group support later\n        Person personObj = filterFields(person, fields, Person.class);\n        Map<String, Object> appData = getPersonAppData(\n            person.getString(Person.Field.ID.toString()), fields);\n        personObj.setAppData(appData);\n\n        result.add(personObj);\n      }\n\n      if (GroupId.Type.self == groupId.getType() && result.isEmpty()) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"People '\" + idSet + \"' not found\");\n      }\n\n      // We can pretend that by default the people are in top friends order\n      if (options.getSortBy().equals(Person.Field.NAME.toString())) {\n        Collections.sort(result, NAME_COMPARATOR);\n\n        if (options.getSortOrder() == SortOrder.descending) {\n          Collections.reverse(result);\n        }\n      }\n\n      // TODO: The samplecontainer doesn't really have the concept of HAS_APP so\n      // we can't support any filters yet. We should fix this.\n\n      int totalSize = result.size();\n      int last = options.getFirst() + options.getMax();\n      result = result.subList(options.getFirst(), Math.min(last, totalSize));\n\n      return Futures.immediateFuture(new RestfulCollection<Person>(result, options.getFirst(), totalSize, options.getMax()));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)\n      throws ProtocolException {\n    if (id != null && AnonymousSecurityToken.ANONYMOUS_ID.equals(id.getUserId())) {\n      Person anonymous = new PersonImpl();\n      anonymous.setId(AnonymousSecurityToken.ANONYMOUS_ID);\n      anonymous.setName(new NameImpl(ANONYMOUS_NAME));\n      anonymous.setNickname(ANONYMOUS_NAME);\n      return Futures.immediateFuture(anonymous);\n    }\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (id != null && person.get(Person.Field.ID.toString()).equals(id.getUserId(token))) {\n          Person personObj = filterFields(person, fields, Person.class);\n          Map<String, Object> appData = getPersonAppData(person.getString(Person.Field.ID\n              .toString()), fields);\n          personObj.setAppData(appData);\n\n          return Futures.immediateFuture(personObj);\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Person '\" + id.getUserId(token) + \"' not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> updatePerson(UserId id, Person person, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String viewer = token.getViewerId(); // viewer\n      String user = id.getUserId(token); // person to update\n\n      if (!viewerCanUpdatePerson(viewer,user)) {\n        throw new ProtocolException(HttpServletResponse.SC_FORBIDDEN, \"User '\" + viewer + \"' does not have enough privileges to update person '\"+user+\"'\");\n      }\n\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject curPerson = people.getJSONObject(i);\n\n        if (user != null && curPerson.getString(Person.Field.ID.toString()).equals(user)) {\n          // Convert user to JSON and set ID\n          JSONObject jsonPerson = convertToJson(person);\n          // go through all properties to update in the submitted person object\n          // and change them in the current person object\n          for (String key : JSONObject.getNames(jsonPerson)) {\n            curPerson.put(key,jsonPerson.get(key));\n          }\n\n          people.put(i,curPerson);\n          return Futures.immediateFuture(converter.convertToObject(curPerson.toString(), Person.class));\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User ID \" + user + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n\n  }\n\n  /** Check if a viewer is allowed to update the given person record. **/\n  protected boolean viewerCanUpdatePerson(String viewer, String person) {\n    // A person can only update his own personal data (by default)\n    // if you wish to allow other people to update the personal data of the user\n    // you should change the current function\n    return viewer.equals(person) ? true : false;\n  }\n\n  private Map<String, Object> getPersonAppData(String id, Set<String> fields) {\n    try {\n      Map<String, Object> appData = null;\n      JSONObject personData = db.getJSONObject(DATA_TABLE).optJSONObject(id);\n      if (personData != null) {\n        if (fields.contains(Person.Field.APP_DATA.toString())) {\n          appData = Maps.newHashMap();\n          @SuppressWarnings(\"unchecked\")\n          Iterator<String> keys = personData.keys();\n          while (keys.hasNext()) {\n            String key = keys.next();\n            appData.put(key, personData.get(key));\n          }\n        } else {\n          String appDataPrefix = Person.Field.APP_DATA.toString() + '.';\n          for (String field : fields) {\n            if (field.startsWith(appDataPrefix)) {\n              if (appData == null) {\n                appData = Maps.newHashMap();\n              }\n\n              String appDataField = field.substring(appDataPrefix.length());\n              if (personData.has(appDataField)) {\n                appData.put(appDataField, personData.get(appDataField));\n              }\n            }\n          }\n        }\n      }\n\n      return appData;\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      Map<String, Map<String, Object>> idToData = Maps.newHashMap();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        JSONObject personData;\n        if (!db.getJSONObject(DATA_TABLE).has(id)) {\n          personData = new JSONObject();\n        } else {\n          if (!fields.isEmpty()) {\n            personData = new JSONObject(db.getJSONObject(DATA_TABLE).getJSONObject(id), fields\n                .toArray(new String[fields.size()]));\n          } else {\n            personData = db.getJSONObject(DATA_TABLE).getJSONObject(id);\n          }\n        }\n\n        // TODO: We can use the converter here to do this for us\n\n        // JSONObject keys are always strings\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = personData.keys();\n        Map<String, Object> data = Maps.newHashMap();\n        while (keys.hasNext()) {\n          String key = keys.next();\n          data.put(key, personData.getString(key));\n        }\n        idToData.put(id, data);\n      }\n      return Futures.immediateFuture(new DataCollection(idToData));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (!db.getJSONObject(DATA_TABLE).has(user)) {\n        return null;\n      }\n      JSONObject newPersonData = new JSONObject();\n      JSONObject oldPersonData = db.getJSONObject(DATA_TABLE).getJSONObject(user);\n\n      // JSONObject keys are always strings\n      @SuppressWarnings(\"unchecked\")\n      Iterator<String> keys = oldPersonData.keys();\n      while (keys.hasNext()) {\n        String key = keys.next();\n        if (!fields.contains(key)) {\n          newPersonData.put(key, oldPersonData.getString(key));\n        }\n      }\n      db.getJSONObject(DATA_TABLE).put(user, newPersonData);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Map<String, Object> values, SecurityToken token)\n      throws ProtocolException {\n    // TODO: this seems redundant. No need to pass both fields and a map of\n    // field->value\n    // TODO: According to rest, yes there is. If a field is in the param list\n    // but not in the map\n    // that means it is a delete\n\n    try {\n      JSONObject personData = db.getJSONObject(DATA_TABLE).getJSONObject(userId.getUserId(token));\n      if (personData == null) {\n        personData = new JSONObject();\n        db.getJSONObject(DATA_TABLE).put(userId.getUserId(token), personData);\n      }\n\n      for (Map.Entry<String, Object> entry : values.entrySet()) {\n        personData.put(entry.getKey(), entry.getValue());\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Group>> getGroups(UserId userId,\n\t\tCollectionOptions options, Set<String> fields, SecurityToken token)\n\t\tthrows ProtocolException {\n    List<Group> result = Lists.newArrayList();\n    String user = userId.getUserId(token);\n    try {\n      JSONArray groups = db.getJSONObject(GROUPS_TABLE).getJSONArray(user);\n\n      for (int i = 0; i < groups.length(); i++) {\n        JSONObject group = groups.getJSONObject(i);\n\n        Group groupObj = filterFields(group, fields, Group.class);\n        result.add(groupObj);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n\n    return Futures.immediateFuture(new RestfulCollection<Group>(result));\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Post a message for a set of users.\n   */\n  public Future<Void> createMessage(UserId userId, String appId, String msgCollId, Message message,\n      SecurityToken token) throws ProtocolException {\n    if (message.getId() == null) {\n      // Assign a new ID to the message\n      message.setId(UUID.randomUUID().toString());\n    }\n    try {\n      JSONObject messagesTable = db.getJSONObject(MESSAGE_TABLE);\n      JSONObject messageObject = convertToJson(message);\n      for (String recipient : message.getRecipients()) {\n        JSONObject collection = messagesTable.getJSONObject(recipient).getJSONObject(msgCollId);\n        JSONArray outbox = collection.getJSONArray(MESSAGES_ARRAY);\n        if (outbox == null) {\n          outbox = new JSONArray();\n          collection.put(MESSAGES_ARRAY, outbox);\n        }\n\n        outbox.put(messageObject);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n\n    return Futures.immediateFuture(null);\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MessageCollection>> getMessageCollections(UserId userId,\n      Set<String> fields, CollectionOptions options, SecurityToken token) throws ProtocolException {\n    try {\n      List<MessageCollection> result = Lists.newArrayList();\n      JSONObject messageCollections = db.getJSONObject(MESSAGE_TABLE).getJSONObject(\n          userId.getUserId(token));\n      for (String msgCollId : JSONObject.getNames(messageCollections)) {\n        JSONObject msgColl = messageCollections.getJSONObject(msgCollId);\n        msgColl.put(\"id\", msgCollId);\n        JSONArray messages = msgColl.getJSONArray(MESSAGES_ARRAY);\n        int numMessages = (messages == null) ? 0 : messages.length();\n        msgColl.put(\"total\", String.valueOf(numMessages));\n        msgColl.put(\"unread\", String.valueOf(numMessages));\n\n        result.add(filterFields(msgColl, fields, MessageCollection.class));\n      }\n      return Futures.immediateFuture(new RestfulCollection<MessageCollection>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessages(UserId userId, String msgCollId, List<String> ids,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Gets the messsages in an user's queue.\n   */\n  public Future<RestfulCollection<Message>> getMessages(UserId userId, String msgCollId,\n      Set<String> fields, List<String> msgIds, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Message> result = Lists.newArrayList();\n      JSONArray messages = db.getJSONObject(MESSAGE_TABLE).getJSONObject(userId.getUserId(token))\n          .getJSONObject(msgCollId).getJSONArray(MESSAGES_ARRAY);\n\n      // TODO: special case @all\n\n      if (messages == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"message collection\"\n            + msgCollId + \" not found\");\n      }\n\n      // TODO: filter and sort outbox.\n      for (int i = 0; i < messages.length(); i++) {\n        JSONObject msg = messages.getJSONObject(i);\n        Message message = filterFields(msg, fields, Message.class);\n        if (msgIds.isEmpty() || msgIds.contains(message.getId())) {\n          result.add(message);\n        }\n      }\n\n      return Futures.immediateFuture(new RestfulCollection<Message>(result));\n\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<MessageCollection> createMessageCollection(UserId userId,\n      MessageCollection msgCollection, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessage(UserId userId, String msgCollId, String messageId,\n      Message message, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessageCollection(UserId userId, MessageCollection msgCollection,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessageCollection(UserId userId, String msgCollId, SecurityToken token)\n      throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * Public methods for use with Authentication Classes\n   *\n   * @param username a {@link java.lang.String} object.\n   * @return a {@link java.lang.String} object.\n   */\n  public String getPassword(String username) {\n    try {\n      return db.getJSONObject(PASSWORDS_TABLE).getString(username);\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n\n  private Set<String> getIdSet(UserId user, GroupId group, SecurityToken token)\n      throws JSONException {\n    String userId = user.getUserId(token);\n\n    if (group == null) {\n      return ImmutableSortedSet.of(userId);\n    }\n\n    Set<String> returnVal = Sets.newLinkedHashSet();\n    switch (group.getType()) {\n    case all:\n    case friends:\n      if (db.getJSONObject(FRIEND_LINK_TABLE).has(userId)) {\n        JSONArray friends = db.getJSONObject(FRIEND_LINK_TABLE).getJSONArray(userId);\n        for (int i = 0; i < friends.length(); i++) {\n          returnVal.add(friends.getString(i));\n        }\n      }\n      break;\n    case objectId:\n      if (db.getJSONObject(GROUP_MEMBERS_TABLE).has(group.toString())) {\n        JSONArray groupMembers = db.getJSONObject(GROUP_MEMBERS_TABLE).getJSONArray(group.toString());\n        for (int i = 0; i < groupMembers.length(); i++) {\n          returnVal.add(groupMembers.getString(i));\n        }\n      }\n      break;\n    case self:\n      returnVal.add(userId);\n      break;\n    }\n    return returnVal;\n  }\n\n  /**\n   * Get the set of user id's for a set of users and a group\n   *\n   * @param users set of UserIds\n   * @param group the group\n   * @param token a token\n   * @return set of Id strings\n   * @throws org.json.JSONException if errors in Json\n   */\n  public Set<String> getIdSet(Set<UserId> users, GroupId group, SecurityToken token)\n      throws JSONException {\n    Set<String> ids = Sets.newLinkedHashSet();\n    for (UserId user : users) {\n      ids.addAll(getIdSet(user, group, token));\n    }\n    return ids;\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Album> getAlbum(UserId userId, String appId, Set<String> fields,\n                                String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Search albums for given ID and owner\n        JSONObject album;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          album = userAlbums.getJSONObject(i);\n          if (album.getString(Album.Field.ID.toString()).equals(albumId) &&\n              album.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n            return Futures.immediateFuture(filterFields(album, fields, Album.class));\n          }\n        }\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(UserId userId, String appId,\n                                                    Set<String> fields, CollectionOptions options, Set<String> albumIds,\n                                                    SecurityToken token) throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Stores target albums\n        List<Album> result = Lists.newArrayList();\n\n        // Search for every albumId\n        boolean found;\n        JSONObject curAlbum;\n        for (String albumId : albumIds) {\n          // Search albums for this albumId\n          found = false;\n          for (int i = 0; i < userAlbums.length(); i++) {\n            curAlbum = userAlbums.getJSONObject(i);\n            if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId) &&\n                curAlbum.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n              result.add(filterFields(curAlbum, fields, Album.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - albumId not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n          }\n        }\n\n        // Return found albums\n        return Futures.immediateFuture(new RestfulCollection<Album>(result));\n      }\n\n      // Album table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User '\" + user + \"' has no albums\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(Set<UserId> userIds,\n                                                    GroupId groupId, String appId, Set<String> fields,\n                                                    CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Album> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather albums for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(ALBUMS_TABLE).has(id)) {\n          JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userAlbums.length(); i++) {\n            JSONObject album = userAlbums.getJSONObject(i);\n            if (album.getString(Album.Field.OWNER_ID.toString()).equals(id)) {\n              result.add(filterFields(album, fields, Album.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Album>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteAlbum(UserId userId, String appId, String albumId,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      boolean targetFound = false;      // indicates if target album is found\n      JSONArray newAlbums = new JSONArray();  // list of albums minus target\n      String user = userId.getUserId(token);  // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Compose new list of albums excluding album to be deleted\n        JSONObject curAlbum;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newAlbums.put(curAlbum);\n          }\n        }\n      }\n\n      // Overwrite user's albums with updated list if album found\n      if (targetFound) {\n        db.getJSONObject(ALBUMS_TABLE).put(user, newAlbums);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: userId and album's ownerId don't have to match - potential problem\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createAlbum(UserId userId, String appId, Album album,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      // Get table of user's albums\n      String user = userId.getUserId(token);\n      JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n      if (userAlbums == null) {\n        userAlbums = new JSONArray();\n        db.getJSONObject(ALBUMS_TABLE).put(user, userAlbums);\n      }\n\n      // Convert album to JSON and set ID & owner\n      JSONObject jsonAlbum = convertToJson(album);\n      if (!jsonAlbum.has(Album.Field.ID.toString())) {\n        jsonAlbum.put(Album.Field.ID.toString(), System.currentTimeMillis());\n      }\n      if (!jsonAlbum.has(Album.Field.OWNER_ID.toString())) {\n        jsonAlbum.put(Album.Field.OWNER_ID.toString(), user);\n      }\n\n      // Insert new album into table\n      userAlbums.put(jsonAlbum);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateAlbum(UserId userId, String appId, Album album,\n                                  String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Convert album to JSON and set ID\n        JSONObject jsonAlbum = convertToJson(album);\n        jsonAlbum.put(Album.Field.ID.toString(), albumId);\n\n        // Iterate through albums to identify album to update\n        for (int i = 0; i < userAlbums.length(); i++) {\n          JSONObject curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            userAlbums.put(i, jsonAlbum);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<MediaItem> getMediaItem(UserId userId, String appId,\n                                        String albumId, String mediaItemId, Set<String> fields,\n                                        SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Search user's MediaItems for given ID and album\n        JSONObject mediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          mediaItem = userMediaItems.getJSONObject(i);\n          if (mediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              mediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            return Futures.immediateFuture(filterFields(mediaItem, fields, MediaItem.class));\n          }\n        }\n      }\n\n      // MediaItem wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID '\" + mediaItemId + \"' does not exist within Album '\" + albumId + '\\'');\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> mediaItemIds,\n                                                            Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores found MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search for every MediaItem ID target\n        boolean found;\n        JSONObject curMediaItem;\n        for (String mediaItemId : mediaItemIds) {\n          // Search existing MediaItems for this MediaItem ID\n          found = false;\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            curMediaItem = userMediaItems.getJSONObject(i);\n            if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(albumId) &&\n                curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n              result.add(filterFields(curMediaItem, fields, MediaItem.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - MediaItem ID not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist within Album \" + albumId);\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem table not found for user \" + user);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> fields,\n                                                            CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores target MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search user's MediaItems for given album\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            result.add(filterFields(curMediaItem, fields, MediaItem.class));\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(\n      Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<MediaItem> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather MediaItems for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(MEDIAITEMS_TABLE).has(id)) {\n          JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            result.add(filterFields(userMediaItems.getJSONObject(i), fields, MediaItem.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      boolean targetFound = false;        // indicates if target MediaItem is found\n      JSONArray newMediaItems = new JSONArray();  // list of MediaItems minus target\n      String user = userId.getUserId(token);    // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Compose new list of MediaItems excluding item to be deleted\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newMediaItems.put(curMediaItem);\n          }\n        }\n      }\n\n      // Overwrite user's MediaItems with updated list if target found\n      if (targetFound) {\n        db.getJSONObject(MEDIAITEMS_TABLE).put(user, newMediaItems);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createMediaItem(UserId userId, String appId,\n                                      String albumId, MediaItem mediaItem, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Get table of user's MediaItems\n      JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(userId.getUserId(token));\n      if (userMediaItems == null) {\n        userMediaItems = new JSONArray();\n        db.getJSONObject(MEDIAITEMS_TABLE).put(userId.getUserId(token), userMediaItems);\n      }\n\n      // Convert MediaItem to JSON and set ID & Album ID\n      JSONObject jsonMediaItem = convertToJson(mediaItem);\n      jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n      if (!jsonMediaItem.has(MediaItem.Field.ID.toString())) {\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), System.currentTimeMillis());\n      }\n\n      // Insert new MediaItem into table\n      userMediaItems.put(jsonMediaItem);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, MediaItem mediaItem,\n                                      SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Convert MediaItem to JSON and set ID & Album ID\n        JSONObject jsonMediaItem = convertToJson(mediaItem);\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), mediaItemId);\n        jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n\n        // Iterate through MediaItems to identify item to update\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          JSONObject curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            userMediaItems.put(i, jsonMediaItem);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no MediaItem found with given ID and Album ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> updateActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        if (activityId != null) {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), activityId);\n        } else {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n        }\n      }\n      activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Find & replace activity\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          jsonArray.put(i, jsonEntry);\n          return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> createActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n      }\n      String activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Ensure activity does not already exist\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity already exists: \" + activityId);\n        }\n      }\n      jsonArray.put(jsonEntry);\n      return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivityEntries(UserId userId, GroupId groupId,\n      String appId, Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n\n        if (activityEntries != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (!activityIds.contains(activityEntry.getString(ActivityEntry.Field.ID.toString()))) {\n              newList.put(activityEntry);\n            }\n          }\n          db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(user, newList);\n        }\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> getActivityEntry(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, String activityId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for (int i = 0; i < activityEntries.length(); i++) {\n          JSONObject activityEntry = activityEntries.getJSONObject(i);\n          if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activityEntry, fields, ActivityEntry.class));\n          }\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n\n/** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      Set<UserId> userIds, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n      List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(id)) {\n          JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n            // TODO: ActivityStreams don't have appIds\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      UserId userId, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, Set<String> activityIds, SecurityToken token)\n      throws ProtocolException {\n    List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for(String activityId : activityIds) {\n          boolean found = false;\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n              result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND, \"Activity not found: \" + activityId);\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // TODO Why specifically handle Activity instead of generic POJO (below)?\n\n  private JSONObject convertFromActivity(Activity activity, Set<String> fields)\n      throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activity));\n  }\n\n  private JSONObject convertFromActivityEntry(ActivityEntry activityEntry, Set<String> fields) throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activityEntry));\n  }\n\n  private JSONObject convertToJson(Object object) throws JSONException {\n    // TODO not using fields yet\n    return new JSONObject(converter.convertToString(object));\n  }\n\n  public <T> T filterFields(JSONObject object, Set<String> fields,\n                            Class<T> clz) throws JSONException {\n    if (!fields.isEmpty()) {\n      // Create a copy with just the specified fields\n      object = new JSONObject(object, fields.toArray(new String[fields\n          .size()]));\n    }\n    String objectVal = object.toString();\n    if (authority != null) {\n      objectVal = objectVal.replace(\"%origin%\", authority.getOrigin());\n    } else {\n      //provide default for junit tests\n      objectVal = objectVal.replace(\"%origin%\", \"http://localhost:8080\");\n    }\n    return converter.convertToObject(objectVal, clz);\n  }\n}\n","lineNo":633}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.social.sample.spi;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Future;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.AnonymousSecurityToken;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.protocol.DataCollection;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.RestfulCollection;\nimport org.apache.shindig.protocol.conversion.BeanConverter;\nimport org.apache.shindig.protocol.model.SortOrder;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.opensocial.model.Activity;\nimport org.apache.shindig.social.opensocial.model.ActivityEntry;\nimport org.apache.shindig.social.opensocial.model.Album;\nimport org.apache.shindig.social.opensocial.model.Group;\nimport org.apache.shindig.social.opensocial.model.MediaItem;\nimport org.apache.shindig.social.opensocial.model.Message;\nimport org.apache.shindig.social.opensocial.model.MessageCollection;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.spi.ActivityService;\nimport org.apache.shindig.social.opensocial.spi.ActivityStreamService;\nimport org.apache.shindig.social.opensocial.spi.AlbumService;\nimport org.apache.shindig.social.opensocial.spi.AppDataService;\nimport org.apache.shindig.social.opensocial.spi.CollectionOptions;\nimport org.apache.shindig.social.opensocial.spi.GroupId;\nimport org.apache.shindig.social.opensocial.spi.GroupService;\nimport org.apache.shindig.social.opensocial.spi.MediaItemService;\nimport org.apache.shindig.social.opensocial.spi.MessageService;\nimport org.apache.shindig.social.opensocial.spi.PersonService;\nimport org.apache.shindig.social.opensocial.spi.UserId;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\n\n/**\n * Implementation of supported services backed by a JSON DB.\n */\n@Singleton\npublic class JsonDbOpensocialService implements ActivityService, PersonService, AppDataService,\n    MessageService, AlbumService, MediaItemService, ActivityStreamService, GroupService {\n\n  private static final Comparator<Person> NAME_COMPARATOR = new Comparator<Person>() {\n    public int compare(Person person, Person person1) {\n      String name = person.getName().getFormatted();\n      String name1 = person1.getName().getFormatted();\n      return name.compareTo(name1);\n    }\n  };\n\n  /**\n   * The DB\n   */\n  private JSONObject db;\n\n  /**\n   * The JSON<->Bean converter\n   */\n  private BeanConverter converter;\n\n  /**\n   * db[\"people\"] -> Array<Person>\n   */\n  private static final String PEOPLE_TABLE = \"people\";\n\n  /**\n   * db[\"groups\"] -> Array<Group>\n   */\n  private static final String GROUPS_TABLE = \"groups\";\n\n  /**\n   * db[\"groupMembers\"] -> Array<Person>\n   */\n  private static final String GROUP_MEMBERS_TABLE = \"groupMembers\";\n\n  /**\n   * db[\"activities\"] -> Map<Person.Id, Array<Activity>>\n   */\n  private static final String ACTIVITIES_TABLE = \"activities\";\n\n  /**\n   * db[\"albums\"] -> Map<Person.Id, Array<Album>>\n   */\n  private static final String ALBUMS_TABLE = \"albums\";\n\n  /**\n   * db[\"mediaItems\"] -> Map<Person.Id, Array<MediaItem>>\n   */\n  private static final String MEDIAITEMS_TABLE = \"mediaItems\";\n\n  /**\n   * db[\"data\"] -> Map<Person.Id, Map<String, String>>\n   */\n  private static final String DATA_TABLE = \"data\";\n\n  /**\n   * db[\"friendLinks\"] -> Map<Person.Id, Array<Person.Id>>\n   */\n  private static final String FRIEND_LINK_TABLE = \"friendLinks\";\n\n  /**\n   * db[\"messages\"] -> Map<Person.Id, Array<Message>>\n   */\n  private static final String MESSAGE_TABLE = \"messages\";\n\n  /**\n   * db[\"passwords\"] -> Map<Person.Id, String>\n   */\n  private static final String PASSWORDS_TABLE = \"passwords\";\n\n  /**\n   * db[\"activityEntries\"] -> Map<Person.Id, Array<ActivityEntry>>\n   */\n  private static final String ACTIVITYSTREAMS_TABLE = \"activityEntries\";\n\n  /**\n   * Anonymous name.\n   */\n  private static final String ANONYMOUS_NAME = \"Anonymous\";\n\n  private Authority authority;\n\n  /**\n   * Initializes the JsonDbOpensocialService using Guice\n   *\n   * @param jsonLocation location of the json data provided by the shindig.canonical.json.db parameter\n   * @param converter an injected BeanConverter\n   * @throws java.lang.Exception if any\n   */\n  @Inject\n  public JsonDbOpensocialService(@Named(\"shindig.canonical.json.db\")\n  String jsonLocation, @Named(\"shindig.bean.converter.json\")\n  BeanConverter converter,\n  @Named(\"shindig.contextroot\") String contextroot) throws Exception {\n    String content = IOUtils.toString(ResourceLoader.openResource(jsonLocation), \"UTF-8\");\n    this.db = new JSONObject(content.replace(\"%contextroot%\", contextroot));\n    this.converter = converter;\n  }\n\n  /**\n   * Allows access to the underlying json db.\n   *\n   * @return a reference to the json db\n   */\n  public JSONObject getDb() {\n    return db;\n  }\n\n   /**\n   * override the json database\n   * @param db a {@link org.json.JSONObject}.\n   */\n  public void setDb(JSONObject db) {\n    this.db = db;\n  }\n\n  @Inject(optional = true)\n  public void setAuthority(Authority authority) {\n    this.authority = authority;\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(Set<UserId> userIds, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITIES_TABLE).has(id)) {\n          JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(id);\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (appId == null || !activity.has(Activity.Field.APP_ID.toString())) {\n              result.add(filterFields(activity, fields, Activity.class));\n            } else if (activity.get(Activity.Field.APP_ID.toString()).equals(appId)) {\n              result.add(filterFields(activity, fields, Activity.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, Set<String> activityIds,\n      SecurityToken token) throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n            result.add(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Activity> getActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activity.get(Activity.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivities(UserId userId, GroupId groupId, String appId,\n      Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        if (activities != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (!activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n              newList.put(activity);\n            }\n          }\n          db.getJSONObject(ACTIVITIES_TABLE).put(user, newList);\n          // TODO. This seems very odd that we return no useful response in this\n          // case\n          // There is no way to represent not-found\n          // if (found) { ??\n          // }\n        }\n      }\n      // What is the appropriate response here??\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> createActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Activity activity, SecurityToken token) throws ProtocolException {\n    // Are fields really needed here?\n    try {\n      JSONObject jsonObject = convertFromActivity(activity, fields);\n      if (!jsonObject.has(Activity.Field.ID.toString())) {\n        jsonObject.put(Activity.Field.ID.toString(), System.currentTimeMillis());\n      }\n      JSONArray jsonArray = db.getJSONObject(ACTIVITIES_TABLE)\n          .getJSONArray(userId.getUserId(token));\n      if (jsonArray == null) {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITIES_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      // TODO (woodser): if used with PUT, duplicate activity would be created?\n      jsonArray.put(jsonObject);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Person>> getPeople(Set<UserId> userIds, GroupId groupId,\n      CollectionOptions options, Set<String> fields, SecurityToken token) throws ProtocolException {\n    List<Person> result = Lists.newArrayList();\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (!idSet.contains(person.get(Person.Field.ID.toString()))) {\n          continue;\n        }\n\n        // Add group support later\n        Person personObj = filterFields(person, fields, Person.class);\n        Map<String, Object> appData = getPersonAppData(\n            person.getString(Person.Field.ID.toString()), fields);\n        personObj.setAppData(appData);\n\n        result.add(personObj);\n      }\n\n      if (GroupId.Type.self == groupId.getType() && result.isEmpty()) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"People '\" + idSet + \"' not found\");\n      }\n\n      // We can pretend that by default the people are in top friends order\n      if (options.getSortBy().equals(Person.Field.NAME.toString())) {\n        Collections.sort(result, NAME_COMPARATOR);\n\n        if (options.getSortOrder() == SortOrder.descending) {\n          Collections.reverse(result);\n        }\n      }\n\n      // TODO: The samplecontainer doesn't really have the concept of HAS_APP so\n      // we can't support any filters yet. We should fix this.\n\n      int totalSize = result.size();\n      int last = options.getFirst() + options.getMax();\n      result = result.subList(options.getFirst(), Math.min(last, totalSize));\n\n      return Futures.immediateFuture(new RestfulCollection<Person>(result, options.getFirst(), totalSize, options.getMax()));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)\n      throws ProtocolException {\n    if (id != null && AnonymousSecurityToken.ANONYMOUS_ID.equals(id.getUserId())) {\n      Person anonymous = new PersonImpl();\n      anonymous.setId(AnonymousSecurityToken.ANONYMOUS_ID);\n      anonymous.setName(new NameImpl(ANONYMOUS_NAME));\n      anonymous.setNickname(ANONYMOUS_NAME);\n      return Futures.immediateFuture(anonymous);\n    }\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (id != null && person.get(Person.Field.ID.toString()).equals(id.getUserId(token))) {\n          Person personObj = filterFields(person, fields, Person.class);\n          Map<String, Object> appData = getPersonAppData(person.getString(Person.Field.ID\n              .toString()), fields);\n          personObj.setAppData(appData);\n\n          return Futures.immediateFuture(personObj);\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Person '\" + id.getUserId(token) + \"' not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> updatePerson(UserId id, Person person, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String viewer = token.getViewerId(); // viewer\n      String user = id.getUserId(token); // person to update\n\n      if (!viewerCanUpdatePerson(viewer,user)) {\n        throw new ProtocolException(HttpServletResponse.SC_FORBIDDEN, \"User '\" + viewer + \"' does not have enough privileges to update person '\"+user+\"'\");\n      }\n\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject curPerson = people.getJSONObject(i);\n\n        if (user != null && curPerson.getString(Person.Field.ID.toString()).equals(user)) {\n          // Convert user to JSON and set ID\n          JSONObject jsonPerson = convertToJson(person);\n          // go through all properties to update in the submitted person object\n          // and change them in the current person object\n          for (String key : JSONObject.getNames(jsonPerson)) {\n            curPerson.put(key,jsonPerson.get(key));\n          }\n\n          people.put(i,curPerson);\n          return Futures.immediateFuture(converter.convertToObject(curPerson.toString(), Person.class));\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User ID \" + user + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n\n  }\n\n  /** Check if a viewer is allowed to update the given person record. **/\n  protected boolean viewerCanUpdatePerson(String viewer, String person) {\n    // A person can only update his own personal data (by default)\n    // if you wish to allow other people to update the personal data of the user\n    // you should change the current function\n    return viewer.equals(person) ? true : false;\n  }\n\n  private Map<String, Object> getPersonAppData(String id, Set<String> fields) {\n    try {\n      Map<String, Object> appData = null;\n      JSONObject personData = db.getJSONObject(DATA_TABLE).optJSONObject(id);\n      if (personData != null) {\n        if (fields.contains(Person.Field.APP_DATA.toString())) {\n          appData = Maps.newHashMap();\n          @SuppressWarnings(\"unchecked\")\n          Iterator<String> keys = personData.keys();\n          while (keys.hasNext()) {\n            String key = keys.next();\n            appData.put(key, personData.get(key));\n          }\n        } else {\n          String appDataPrefix = Person.Field.APP_DATA.toString() + '.';\n          for (String field : fields) {\n            if (field.startsWith(appDataPrefix)) {\n              if (appData == null) {\n                appData = Maps.newHashMap();\n              }\n\n              String appDataField = field.substring(appDataPrefix.length());\n              if (personData.has(appDataField)) {\n                appData.put(appDataField, personData.get(appDataField));\n              }\n            }\n          }\n        }\n      }\n\n      return appData;\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      Map<String, Map<String, Object>> idToData = Maps.newHashMap();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        JSONObject personData;\n        if (!db.getJSONObject(DATA_TABLE).has(id)) {\n          personData = new JSONObject();\n        } else {\n          if (!fields.isEmpty()) {\n            personData = new JSONObject(db.getJSONObject(DATA_TABLE).getJSONObject(id), fields\n                .toArray(new String[fields.size()]));\n          } else {\n            personData = db.getJSONObject(DATA_TABLE).getJSONObject(id);\n          }\n        }\n\n        // TODO: We can use the converter here to do this for us\n\n        // JSONObject keys are always strings\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = personData.keys();\n        Map<String, Object> data = Maps.newHashMap();\n        while (keys.hasNext()) {\n          String key = keys.next();\n          data.put(key, personData.getString(key));\n        }\n        idToData.put(id, data);\n      }\n      return Futures.immediateFuture(new DataCollection(idToData));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (!db.getJSONObject(DATA_TABLE).has(user)) {\n        return null;\n      }\n      JSONObject newPersonData = new JSONObject();\n      JSONObject oldPersonData = db.getJSONObject(DATA_TABLE).getJSONObject(user);\n\n      // JSONObject keys are always strings\n      @SuppressWarnings(\"unchecked\")\n      Iterator<String> keys = oldPersonData.keys();\n      while (keys.hasNext()) {\n        String key = keys.next();\n        if (!fields.contains(key)) {\n          newPersonData.put(key, oldPersonData.getString(key));\n        }\n      }\n      db.getJSONObject(DATA_TABLE).put(user, newPersonData);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Map<String, Object> values, SecurityToken token)\n      throws ProtocolException {\n    // TODO: this seems redundant. No need to pass both fields and a map of\n    // field->value\n    // TODO: According to rest, yes there is. If a field is in the param list\n    // but not in the map\n    // that means it is a delete\n\n    try {\n      JSONObject personData = db.getJSONObject(DATA_TABLE).getJSONObject(userId.getUserId(token));\n      if (personData == null) {\n        personData = new JSONObject();\n        db.getJSONObject(DATA_TABLE).put(userId.getUserId(token), personData);\n      }\n\n      for (Map.Entry<String, Object> entry : values.entrySet()) {\n        personData.put(entry.getKey(), entry.getValue());\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Group>> getGroups(UserId userId,\n\t\tCollectionOptions options, Set<String> fields, SecurityToken token)\n\t\tthrows ProtocolException {\n    List<Group> result = Lists.newArrayList();\n    String user = userId.getUserId(token);\n    try {\n      JSONArray groups = db.getJSONObject(GROUPS_TABLE).getJSONArray(user);\n\n      for (int i = 0; i < groups.length(); i++) {\n        JSONObject group = groups.getJSONObject(i);\n\n        Group groupObj = filterFields(group, fields, Group.class);\n        result.add(groupObj);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n\n    return Futures.immediateFuture(new RestfulCollection<Group>(result));\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Post a message for a set of users.\n   */\n  public Future<Void> createMessage(UserId userId, String appId, String msgCollId, Message message,\n      SecurityToken token) throws ProtocolException {\n    for (String recipient : message.getRecipients()) {\n      try {\n        JSONArray outbox = db.getJSONObject(MESSAGE_TABLE).getJSONArray(recipient);\n        if (outbox == null) {\n          outbox = new JSONArray();\n          db.getJSONObject(MESSAGE_TABLE).put(recipient, outbox);\n        }\n\n        outbox.put(message);\n      } catch (JSONException je) {\n        throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n            je);\n      }\n    }\n\n    return Futures.immediateFuture(null);\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MessageCollection>> getMessageCollections(UserId userId,\n      Set<String> fields, CollectionOptions options, SecurityToken token) throws ProtocolException {\n    try {\n      List<MessageCollection> result = Lists.newArrayList();\n      JSONObject messageCollections = db.getJSONObject(MESSAGE_TABLE).getJSONObject(\n          userId.getUserId(token));\n      for (String msgCollId : JSONObject.getNames(messageCollections)) {\n        JSONObject msgColl = messageCollections.getJSONObject(msgCollId);\n        msgColl.put(\"id\", msgCollId);\n        JSONArray messages = msgColl.getJSONArray(\"messages\");\n        int numMessages = (messages == null) ? 0 : messages.length();\n        msgColl.put(\"total\", String.valueOf(numMessages));\n        msgColl.put(\"unread\", String.valueOf(numMessages));\n\n        result.add(filterFields(msgColl, fields, MessageCollection.class));\n      }\n      return Futures.immediateFuture(new RestfulCollection<MessageCollection>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessages(UserId userId, String msgCollId, List<String> ids,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Gets the messsages in an user's queue.\n   */\n  public Future<RestfulCollection<Message>> getMessages(UserId userId, String msgCollId,\n      Set<String> fields, List<String> msgIds, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Message> result = Lists.newArrayList();\n      JSONArray messages = db.getJSONObject(MESSAGE_TABLE).getJSONObject(userId.getUserId(token))\n          .getJSONObject(msgCollId).getJSONArray(\"messages\");\n\n      // TODO: special case @all\n\n      if (messages == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"message collection\"\n            + msgCollId + \" not found\");\n      }\n\n      // TODO: filter and sort outbox.\n      for (int i = 0; i < messages.length(); i++) {\n        JSONObject msg = messages.getJSONObject(i);\n        Message message = filterFields(msg, fields, Message.class);\n        if (msgIds.isEmpty() || msgIds.contains(message.getId())) {\n          result.add(message);\n        }\n      }\n\n      return Futures.immediateFuture(new RestfulCollection<Message>(result));\n\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<MessageCollection> createMessageCollection(UserId userId,\n      MessageCollection msgCollection, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessage(UserId userId, String msgCollId, String messageId,\n      Message message, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessageCollection(UserId userId, MessageCollection msgCollection,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessageCollection(UserId userId, String msgCollId, SecurityToken token)\n      throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * Public methods for use with Authentication Classes\n   *\n   * @param username a {@link java.lang.String} object.\n   * @return a {@link java.lang.String} object.\n   */\n  public String getPassword(String username) {\n    try {\n      return db.getJSONObject(PASSWORDS_TABLE).getString(username);\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n\n  private Set<String> getIdSet(UserId user, GroupId group, SecurityToken token)\n      throws JSONException {\n    String userId = user.getUserId(token);\n\n    if (group == null) {\n      return ImmutableSortedSet.of(userId);\n    }\n\n    Set<String> returnVal = Sets.newLinkedHashSet();\n    switch (group.getType()) {\n    case all:\n    case friends:\n      if (db.getJSONObject(FRIEND_LINK_TABLE).has(userId)) {\n        JSONArray friends = db.getJSONObject(FRIEND_LINK_TABLE).getJSONArray(userId);\n        for (int i = 0; i < friends.length(); i++) {\n          returnVal.add(friends.getString(i));\n        }\n      }\n      break;\n    case objectId:\n      if (db.getJSONObject(GROUP_MEMBERS_TABLE).has(group.toString())) {\n        JSONArray groupMembers = db.getJSONObject(GROUP_MEMBERS_TABLE).getJSONArray(group.toString());\n        for (int i = 0; i < groupMembers.length(); i++) {\n          returnVal.add(groupMembers.getString(i));\n        }\n      }\n      break;\n    case self:\n      returnVal.add(userId);\n      break;\n    }\n    return returnVal;\n  }\n\n  /**\n   * Get the set of user id's for a set of users and a group\n   *\n   * @param users set of UserIds\n   * @param group the group\n   * @param token a token\n   * @return set of Id strings\n   * @throws org.json.JSONException if errors in Json\n   */\n  public Set<String> getIdSet(Set<UserId> users, GroupId group, SecurityToken token)\n      throws JSONException {\n    Set<String> ids = Sets.newLinkedHashSet();\n    for (UserId user : users) {\n      ids.addAll(getIdSet(user, group, token));\n    }\n    return ids;\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Album> getAlbum(UserId userId, String appId, Set<String> fields,\n                                String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Search albums for given ID and owner\n        JSONObject album;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          album = userAlbums.getJSONObject(i);\n          if (album.getString(Album.Field.ID.toString()).equals(albumId) &&\n              album.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n            return Futures.immediateFuture(filterFields(album, fields, Album.class));\n          }\n        }\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(UserId userId, String appId,\n                                                    Set<String> fields, CollectionOptions options, Set<String> albumIds,\n                                                    SecurityToken token) throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Stores target albums\n        List<Album> result = Lists.newArrayList();\n\n        // Search for every albumId\n        boolean found;\n        JSONObject curAlbum;\n        for (String albumId : albumIds) {\n          // Search albums for this albumId\n          found = false;\n          for (int i = 0; i < userAlbums.length(); i++) {\n            curAlbum = userAlbums.getJSONObject(i);\n            if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId) &&\n                curAlbum.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n              result.add(filterFields(curAlbum, fields, Album.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - albumId not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n          }\n        }\n\n        // Return found albums\n        return Futures.immediateFuture(new RestfulCollection<Album>(result));\n      }\n\n      // Album table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User '\" + user + \"' has no albums\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(Set<UserId> userIds,\n                                                    GroupId groupId, String appId, Set<String> fields,\n                                                    CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Album> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather albums for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(ALBUMS_TABLE).has(id)) {\n          JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userAlbums.length(); i++) {\n            JSONObject album = userAlbums.getJSONObject(i);\n            if (album.getString(Album.Field.OWNER_ID.toString()).equals(id)) {\n              result.add(filterFields(album, fields, Album.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Album>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteAlbum(UserId userId, String appId, String albumId,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      boolean targetFound = false;      // indicates if target album is found\n      JSONArray newAlbums = new JSONArray();  // list of albums minus target\n      String user = userId.getUserId(token);  // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Compose new list of albums excluding album to be deleted\n        JSONObject curAlbum;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newAlbums.put(curAlbum);\n          }\n        }\n      }\n\n      // Overwrite user's albums with updated list if album found\n      if (targetFound) {\n        db.getJSONObject(ALBUMS_TABLE).put(user, newAlbums);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: userId and album's ownerId don't have to match - potential problem\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createAlbum(UserId userId, String appId, Album album,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      // Get table of user's albums\n      String user = userId.getUserId(token);\n      JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n      if (userAlbums == null) {\n        userAlbums = new JSONArray();\n        db.getJSONObject(ALBUMS_TABLE).put(user, userAlbums);\n      }\n\n      // Convert album to JSON and set ID & owner\n      JSONObject jsonAlbum = convertToJson(album);\n      if (!jsonAlbum.has(Album.Field.ID.toString())) {\n        jsonAlbum.put(Album.Field.ID.toString(), System.currentTimeMillis());\n      }\n      if (!jsonAlbum.has(Album.Field.OWNER_ID.toString())) {\n        jsonAlbum.put(Album.Field.OWNER_ID.toString(), user);\n      }\n\n      // Insert new album into table\n      userAlbums.put(jsonAlbum);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateAlbum(UserId userId, String appId, Album album,\n                                  String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Convert album to JSON and set ID\n        JSONObject jsonAlbum = convertToJson(album);\n        jsonAlbum.put(Album.Field.ID.toString(), albumId);\n\n        // Iterate through albums to identify album to update\n        for (int i = 0; i < userAlbums.length(); i++) {\n          JSONObject curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            userAlbums.put(i, jsonAlbum);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<MediaItem> getMediaItem(UserId userId, String appId,\n                                        String albumId, String mediaItemId, Set<String> fields,\n                                        SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Search user's MediaItems for given ID and album\n        JSONObject mediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          mediaItem = userMediaItems.getJSONObject(i);\n          if (mediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              mediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            return Futures.immediateFuture(filterFields(mediaItem, fields, MediaItem.class));\n          }\n        }\n      }\n\n      // MediaItem wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID '\" + mediaItemId + \"' does not exist within Album '\" + albumId + '\\'');\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> mediaItemIds,\n                                                            Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores found MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search for every MediaItem ID target\n        boolean found;\n        JSONObject curMediaItem;\n        for (String mediaItemId : mediaItemIds) {\n          // Search existing MediaItems for this MediaItem ID\n          found = false;\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            curMediaItem = userMediaItems.getJSONObject(i);\n            if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(albumId) &&\n                curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n              result.add(filterFields(curMediaItem, fields, MediaItem.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - MediaItem ID not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist within Album \" + albumId);\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem table not found for user \" + user);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> fields,\n                                                            CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores target MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search user's MediaItems for given album\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            result.add(filterFields(curMediaItem, fields, MediaItem.class));\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(\n      Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<MediaItem> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather MediaItems for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(MEDIAITEMS_TABLE).has(id)) {\n          JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            result.add(filterFields(userMediaItems.getJSONObject(i), fields, MediaItem.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      boolean targetFound = false;        // indicates if target MediaItem is found\n      JSONArray newMediaItems = new JSONArray();  // list of MediaItems minus target\n      String user = userId.getUserId(token);    // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Compose new list of MediaItems excluding item to be deleted\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newMediaItems.put(curMediaItem);\n          }\n        }\n      }\n\n      // Overwrite user's MediaItems with updated list if target found\n      if (targetFound) {\n        db.getJSONObject(MEDIAITEMS_TABLE).put(user, newMediaItems);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createMediaItem(UserId userId, String appId,\n                                      String albumId, MediaItem mediaItem, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Get table of user's MediaItems\n      JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(userId.getUserId(token));\n      if (userMediaItems == null) {\n        userMediaItems = new JSONArray();\n        db.getJSONObject(MEDIAITEMS_TABLE).put(userId.getUserId(token), userMediaItems);\n      }\n\n      // Convert MediaItem to JSON and set ID & Album ID\n      JSONObject jsonMediaItem = convertToJson(mediaItem);\n      jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n      if (!jsonMediaItem.has(MediaItem.Field.ID.toString())) {\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), System.currentTimeMillis());\n      }\n\n      // Insert new MediaItem into table\n      userMediaItems.put(jsonMediaItem);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, MediaItem mediaItem,\n                                      SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Convert MediaItem to JSON and set ID & Album ID\n        JSONObject jsonMediaItem = convertToJson(mediaItem);\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), mediaItemId);\n        jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n\n        // Iterate through MediaItems to identify item to update\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          JSONObject curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            userMediaItems.put(i, jsonMediaItem);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no MediaItem found with given ID and Album ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> updateActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        if (activityId != null) {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), activityId);\n        } else {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n        }\n      }\n      activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Find & replace activity\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          jsonArray.put(i, jsonEntry);\n          return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> createActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n      }\n      String activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Ensure activity does not already exist\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity already exists: \" + activityId);\n        }\n      }\n      jsonArray.put(jsonEntry);\n      return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivityEntries(UserId userId, GroupId groupId,\n      String appId, Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n\n        if (activityEntries != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (!activityIds.contains(activityEntry.getString(ActivityEntry.Field.ID.toString()))) {\n              newList.put(activityEntry);\n            }\n          }\n          db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(user, newList);\n        }\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> getActivityEntry(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, String activityId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for (int i = 0; i < activityEntries.length(); i++) {\n          JSONObject activityEntry = activityEntries.getJSONObject(i);\n          if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activityEntry, fields, ActivityEntry.class));\n          }\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n\n/** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      Set<UserId> userIds, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n      List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(id)) {\n          JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n            // TODO: ActivityStreams don't have appIds\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      UserId userId, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, Set<String> activityIds, SecurityToken token)\n      throws ProtocolException {\n    List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for(String activityId : activityIds) {\n          boolean found = false;\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n              result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND, \"Activity not found: \" + activityId);\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // TODO Why specifically handle Activity instead of generic POJO (below)?\n\n  private JSONObject convertFromActivity(Activity activity, Set<String> fields)\n      throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activity));\n  }\n\n  private JSONObject convertFromActivityEntry(ActivityEntry activityEntry, Set<String> fields) throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activityEntry));\n  }\n\n  private JSONObject convertToJson(Object object) throws JSONException {\n    // TODO not using fields yet\n    return new JSONObject(converter.convertToString(object));\n  }\n\n  public <T> T filterFields(JSONObject object, Set<String> fields,\n                            Class<T> clz) throws JSONException {\n    if (!fields.isEmpty()) {\n      // Create a copy with just the specified fields\n      object = new JSONObject(object, fields.toArray(new String[fields\n          .size()]));\n    }\n    String objectVal = object.toString();\n    if (authority != null) {\n      objectVal = objectVal.replace(\"%origin%\", authority.getOrigin());\n    } else {\n      //provide default for junit tests\n      objectVal = objectVal.replace(\"%origin%\", \"http://localhost:8080\");\n    }\n    return converter.convertToObject(objectVal, clz);\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.social.sample.spi;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.Future;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.AnonymousSecurityToken;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.protocol.DataCollection;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.RestfulCollection;\nimport org.apache.shindig.protocol.conversion.BeanConverter;\nimport org.apache.shindig.protocol.model.SortOrder;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.opensocial.model.Activity;\nimport org.apache.shindig.social.opensocial.model.ActivityEntry;\nimport org.apache.shindig.social.opensocial.model.Album;\nimport org.apache.shindig.social.opensocial.model.Group;\nimport org.apache.shindig.social.opensocial.model.MediaItem;\nimport org.apache.shindig.social.opensocial.model.Message;\nimport org.apache.shindig.social.opensocial.model.MessageCollection;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.spi.ActivityService;\nimport org.apache.shindig.social.opensocial.spi.ActivityStreamService;\nimport org.apache.shindig.social.opensocial.spi.AlbumService;\nimport org.apache.shindig.social.opensocial.spi.AppDataService;\nimport org.apache.shindig.social.opensocial.spi.CollectionOptions;\nimport org.apache.shindig.social.opensocial.spi.GroupId;\nimport org.apache.shindig.social.opensocial.spi.GroupService;\nimport org.apache.shindig.social.opensocial.spi.MediaItemService;\nimport org.apache.shindig.social.opensocial.spi.MessageService;\nimport org.apache.shindig.social.opensocial.spi.PersonService;\nimport org.apache.shindig.social.opensocial.spi.UserId;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\n\n/**\n * Implementation of supported services backed by a JSON DB.\n */\n@Singleton\npublic class JsonDbOpensocialService implements ActivityService, PersonService, AppDataService,\n    MessageService, AlbumService, MediaItemService, ActivityStreamService, GroupService {\n\n  private static final Comparator<Person> NAME_COMPARATOR = new Comparator<Person>() {\n    public int compare(Person person, Person person1) {\n      String name = person.getName().getFormatted();\n      String name1 = person1.getName().getFormatted();\n      return name.compareTo(name1);\n    }\n  };\n\n  /**\n   * The DB\n   */\n  private JSONObject db;\n\n  /**\n   * The JSON<->Bean converter\n   */\n  private BeanConverter converter;\n\n  /**\n   * db[\"people\"] -> Array<Person>\n   */\n  private static final String PEOPLE_TABLE = \"people\";\n\n  /**\n   * db[\"groups\"] -> Array<Group>\n   */\n  private static final String GROUPS_TABLE = \"groups\";\n\n  /**\n   * db[\"groupMembers\"] -> Array<Person>\n   */\n  private static final String GROUP_MEMBERS_TABLE = \"groupMembers\";\n\n  /**\n   * db[\"activities\"] -> Map<Person.Id, Array<Activity>>\n   */\n  private static final String ACTIVITIES_TABLE = \"activities\";\n\n  /**\n   * db[\"albums\"] -> Map<Person.Id, Array<Album>>\n   */\n  private static final String ALBUMS_TABLE = \"albums\";\n\n  /**\n   * db[\"mediaItems\"] -> Map<Person.Id, Array<MediaItem>>\n   */\n  private static final String MEDIAITEMS_TABLE = \"mediaItems\";\n\n  /**\n   * db[\"data\"] -> Map<Person.Id, Map<String, String>>\n   */\n  private static final String DATA_TABLE = \"data\";\n\n  /**\n   * db[\"friendLinks\"] -> Map<Person.Id, Array<Person.Id>>\n   */\n  private static final String FRIEND_LINK_TABLE = \"friendLinks\";\n\n  /**\n   * db[\"messages\"] -> Map<Person.Id, Map<MessageCollection.Id, MessageCollection>>\n   */\n  private static final String MESSAGE_TABLE = \"messages\";\n\n  /**\n   * Attribute that contains the messages of a specific MessageCollection.\n   */\n  private static final String MESSAGES_ARRAY = \"messages\";\n\n  /**\n   * db[\"passwords\"] -> Map<Person.Id, String>\n   */\n  private static final String PASSWORDS_TABLE = \"passwords\";\n\n  /**\n   * db[\"activityEntries\"] -> Map<Person.Id, Array<ActivityEntry>>\n   */\n  private static final String ACTIVITYSTREAMS_TABLE = \"activityEntries\";\n\n  /**\n   * Anonymous name.\n   */\n  private static final String ANONYMOUS_NAME = \"Anonymous\";\n\n  private Authority authority;\n\n  /**\n   * Initializes the JsonDbOpensocialService using Guice\n   *\n   * @param jsonLocation location of the json data provided by the shindig.canonical.json.db parameter\n   * @param converter an injected BeanConverter\n   * @throws java.lang.Exception if any\n   */\n  @Inject\n  public JsonDbOpensocialService(@Named(\"shindig.canonical.json.db\")\n  String jsonLocation, @Named(\"shindig.bean.converter.json\")\n  BeanConverter converter,\n  @Named(\"shindig.contextroot\") String contextroot) throws Exception {\n    String content = IOUtils.toString(ResourceLoader.openResource(jsonLocation), \"UTF-8\");\n    this.db = new JSONObject(content.replace(\"%contextroot%\", contextroot));\n    this.converter = converter;\n  }\n\n  /**\n   * Allows access to the underlying json db.\n   *\n   * @return a reference to the json db\n   */\n  public JSONObject getDb() {\n    return db;\n  }\n\n   /**\n   * override the json database\n   * @param db a {@link org.json.JSONObject}.\n   */\n  public void setDb(JSONObject db) {\n    this.db = db;\n  }\n\n  @Inject(optional = true)\n  public void setAuthority(Authority authority) {\n    this.authority = authority;\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(Set<UserId> userIds, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITIES_TABLE).has(id)) {\n          JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(id);\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (appId == null || !activity.has(Activity.Field.APP_ID.toString())) {\n              result.add(filterFields(activity, fields, Activity.class));\n            } else if (activity.get(Activity.Field.APP_ID.toString()).equals(appId)) {\n              result.add(filterFields(activity, fields, Activity.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, Set<String> activityIds,\n      SecurityToken token) throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n            result.add(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Activity> getActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activity.get(Activity.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivities(UserId userId, GroupId groupId, String appId,\n      Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        if (activities != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (!activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n              newList.put(activity);\n            }\n          }\n          db.getJSONObject(ACTIVITIES_TABLE).put(user, newList);\n          // TODO. This seems very odd that we return no useful response in this\n          // case\n          // There is no way to represent not-found\n          // if (found) { ??\n          // }\n        }\n      }\n      // What is the appropriate response here??\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> createActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Activity activity, SecurityToken token) throws ProtocolException {\n    // Are fields really needed here?\n    try {\n      JSONObject jsonObject = convertFromActivity(activity, fields);\n      if (!jsonObject.has(Activity.Field.ID.toString())) {\n        jsonObject.put(Activity.Field.ID.toString(), System.currentTimeMillis());\n      }\n      JSONArray jsonArray = db.getJSONObject(ACTIVITIES_TABLE)\n          .getJSONArray(userId.getUserId(token));\n      if (jsonArray == null) {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITIES_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      // TODO (woodser): if used with PUT, duplicate activity would be created?\n      jsonArray.put(jsonObject);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Person>> getPeople(Set<UserId> userIds, GroupId groupId,\n      CollectionOptions options, Set<String> fields, SecurityToken token) throws ProtocolException {\n    List<Person> result = Lists.newArrayList();\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (!idSet.contains(person.get(Person.Field.ID.toString()))) {\n          continue;\n        }\n\n        // Add group support later\n        Person personObj = filterFields(person, fields, Person.class);\n        Map<String, Object> appData = getPersonAppData(\n            person.getString(Person.Field.ID.toString()), fields);\n        personObj.setAppData(appData);\n\n        result.add(personObj);\n      }\n\n      if (GroupId.Type.self == groupId.getType() && result.isEmpty()) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"People '\" + idSet + \"' not found\");\n      }\n\n      // We can pretend that by default the people are in top friends order\n      if (options.getSortBy().equals(Person.Field.NAME.toString())) {\n        Collections.sort(result, NAME_COMPARATOR);\n\n        if (options.getSortOrder() == SortOrder.descending) {\n          Collections.reverse(result);\n        }\n      }\n\n      // TODO: The samplecontainer doesn't really have the concept of HAS_APP so\n      // we can't support any filters yet. We should fix this.\n\n      int totalSize = result.size();\n      int last = options.getFirst() + options.getMax();\n      result = result.subList(options.getFirst(), Math.min(last, totalSize));\n\n      return Futures.immediateFuture(new RestfulCollection<Person>(result, options.getFirst(), totalSize, options.getMax()));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)\n      throws ProtocolException {\n    if (id != null && AnonymousSecurityToken.ANONYMOUS_ID.equals(id.getUserId())) {\n      Person anonymous = new PersonImpl();\n      anonymous.setId(AnonymousSecurityToken.ANONYMOUS_ID);\n      anonymous.setName(new NameImpl(ANONYMOUS_NAME));\n      anonymous.setNickname(ANONYMOUS_NAME);\n      return Futures.immediateFuture(anonymous);\n    }\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (id != null && person.get(Person.Field.ID.toString()).equals(id.getUserId(token))) {\n          Person personObj = filterFields(person, fields, Person.class);\n          Map<String, Object> appData = getPersonAppData(person.getString(Person.Field.ID\n              .toString()), fields);\n          personObj.setAppData(appData);\n\n          return Futures.immediateFuture(personObj);\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Person '\" + id.getUserId(token) + \"' not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> updatePerson(UserId id, Person person, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String viewer = token.getViewerId(); // viewer\n      String user = id.getUserId(token); // person to update\n\n      if (!viewerCanUpdatePerson(viewer,user)) {\n        throw new ProtocolException(HttpServletResponse.SC_FORBIDDEN, \"User '\" + viewer + \"' does not have enough privileges to update person '\"+user+\"'\");\n      }\n\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject curPerson = people.getJSONObject(i);\n\n        if (user != null && curPerson.getString(Person.Field.ID.toString()).equals(user)) {\n          // Convert user to JSON and set ID\n          JSONObject jsonPerson = convertToJson(person);\n          // go through all properties to update in the submitted person object\n          // and change them in the current person object\n          for (String key : JSONObject.getNames(jsonPerson)) {\n            curPerson.put(key,jsonPerson.get(key));\n          }\n\n          people.put(i,curPerson);\n          return Futures.immediateFuture(converter.convertToObject(curPerson.toString(), Person.class));\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User ID \" + user + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n\n  }\n\n  /** Check if a viewer is allowed to update the given person record. **/\n  protected boolean viewerCanUpdatePerson(String viewer, String person) {\n    // A person can only update his own personal data (by default)\n    // if you wish to allow other people to update the personal data of the user\n    // you should change the current function\n    return viewer.equals(person) ? true : false;\n  }\n\n  private Map<String, Object> getPersonAppData(String id, Set<String> fields) {\n    try {\n      Map<String, Object> appData = null;\n      JSONObject personData = db.getJSONObject(DATA_TABLE).optJSONObject(id);\n      if (personData != null) {\n        if (fields.contains(Person.Field.APP_DATA.toString())) {\n          appData = Maps.newHashMap();\n          @SuppressWarnings(\"unchecked\")\n          Iterator<String> keys = personData.keys();\n          while (keys.hasNext()) {\n            String key = keys.next();\n            appData.put(key, personData.get(key));\n          }\n        } else {\n          String appDataPrefix = Person.Field.APP_DATA.toString() + '.';\n          for (String field : fields) {\n            if (field.startsWith(appDataPrefix)) {\n              if (appData == null) {\n                appData = Maps.newHashMap();\n              }\n\n              String appDataField = field.substring(appDataPrefix.length());\n              if (personData.has(appDataField)) {\n                appData.put(appDataField, personData.get(appDataField));\n              }\n            }\n          }\n        }\n      }\n\n      return appData;\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      Map<String, Map<String, Object>> idToData = Maps.newHashMap();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        JSONObject personData;\n        if (!db.getJSONObject(DATA_TABLE).has(id)) {\n          personData = new JSONObject();\n        } else {\n          if (!fields.isEmpty()) {\n            personData = new JSONObject(db.getJSONObject(DATA_TABLE).getJSONObject(id), fields\n                .toArray(new String[fields.size()]));\n          } else {\n            personData = db.getJSONObject(DATA_TABLE).getJSONObject(id);\n          }\n        }\n\n        // TODO: We can use the converter here to do this for us\n\n        // JSONObject keys are always strings\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = personData.keys();\n        Map<String, Object> data = Maps.newHashMap();\n        while (keys.hasNext()) {\n          String key = keys.next();\n          data.put(key, personData.getString(key));\n        }\n        idToData.put(id, data);\n      }\n      return Futures.immediateFuture(new DataCollection(idToData));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (!db.getJSONObject(DATA_TABLE).has(user)) {\n        return null;\n      }\n      JSONObject newPersonData = new JSONObject();\n      JSONObject oldPersonData = db.getJSONObject(DATA_TABLE).getJSONObject(user);\n\n      // JSONObject keys are always strings\n      @SuppressWarnings(\"unchecked\")\n      Iterator<String> keys = oldPersonData.keys();\n      while (keys.hasNext()) {\n        String key = keys.next();\n        if (!fields.contains(key)) {\n          newPersonData.put(key, oldPersonData.getString(key));\n        }\n      }\n      db.getJSONObject(DATA_TABLE).put(user, newPersonData);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Map<String, Object> values, SecurityToken token)\n      throws ProtocolException {\n    // TODO: this seems redundant. No need to pass both fields and a map of\n    // field->value\n    // TODO: According to rest, yes there is. If a field is in the param list\n    // but not in the map\n    // that means it is a delete\n\n    try {\n      JSONObject personData = db.getJSONObject(DATA_TABLE).getJSONObject(userId.getUserId(token));\n      if (personData == null) {\n        personData = new JSONObject();\n        db.getJSONObject(DATA_TABLE).put(userId.getUserId(token), personData);\n      }\n\n      for (Map.Entry<String, Object> entry : values.entrySet()) {\n        personData.put(entry.getKey(), entry.getValue());\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Group>> getGroups(UserId userId,\n\t\tCollectionOptions options, Set<String> fields, SecurityToken token)\n\t\tthrows ProtocolException {\n    List<Group> result = Lists.newArrayList();\n    String user = userId.getUserId(token);\n    try {\n      JSONArray groups = db.getJSONObject(GROUPS_TABLE).getJSONArray(user);\n\n      for (int i = 0; i < groups.length(); i++) {\n        JSONObject group = groups.getJSONObject(i);\n\n        Group groupObj = filterFields(group, fields, Group.class);\n        result.add(groupObj);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n\n    return Futures.immediateFuture(new RestfulCollection<Group>(result));\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Post a message for a set of users.\n   */\n  public Future<Void> createMessage(UserId userId, String appId, String msgCollId, Message message,\n      SecurityToken token) throws ProtocolException {\n    if (message.getId() == null) {\n      // Assign a new ID to the message\n      message.setId(UUID.randomUUID().toString());\n    }\n    try {\n      JSONObject messagesTable = db.getJSONObject(MESSAGE_TABLE);\n      JSONObject messageObject = convertToJson(message);\n      for (String recipient : message.getRecipients()) {\n        JSONObject collection = messagesTable.getJSONObject(recipient).getJSONObject(msgCollId);\n        JSONArray outbox = collection.getJSONArray(MESSAGES_ARRAY);\n        if (outbox == null) {\n          outbox = new JSONArray();\n          collection.put(MESSAGES_ARRAY, outbox);\n        }\n\n        outbox.put(messageObject);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n\n    return Futures.immediateFuture(null);\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MessageCollection>> getMessageCollections(UserId userId,\n      Set<String> fields, CollectionOptions options, SecurityToken token) throws ProtocolException {\n    try {\n      List<MessageCollection> result = Lists.newArrayList();\n      JSONObject messageCollections = db.getJSONObject(MESSAGE_TABLE).getJSONObject(\n          userId.getUserId(token));\n      for (String msgCollId : JSONObject.getNames(messageCollections)) {\n        JSONObject msgColl = messageCollections.getJSONObject(msgCollId);\n        msgColl.put(\"id\", msgCollId);\n        JSONArray messages = msgColl.getJSONArray(MESSAGES_ARRAY);\n        int numMessages = (messages == null) ? 0 : messages.length();\n        msgColl.put(\"total\", String.valueOf(numMessages));\n        msgColl.put(\"unread\", String.valueOf(numMessages));\n\n        result.add(filterFields(msgColl, fields, MessageCollection.class));\n      }\n      return Futures.immediateFuture(new RestfulCollection<MessageCollection>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessages(UserId userId, String msgCollId, List<String> ids,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Gets the messsages in an user's queue.\n   */\n  public Future<RestfulCollection<Message>> getMessages(UserId userId, String msgCollId,\n      Set<String> fields, List<String> msgIds, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Message> result = Lists.newArrayList();\n      JSONArray messages = db.getJSONObject(MESSAGE_TABLE).getJSONObject(userId.getUserId(token))\n          .getJSONObject(msgCollId).getJSONArray(MESSAGES_ARRAY);\n\n      // TODO: special case @all\n\n      if (messages == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"message collection\"\n            + msgCollId + \" not found\");\n      }\n\n      // TODO: filter and sort outbox.\n      for (int i = 0; i < messages.length(); i++) {\n        JSONObject msg = messages.getJSONObject(i);\n        Message message = filterFields(msg, fields, Message.class);\n        if (msgIds.isEmpty() || msgIds.contains(message.getId())) {\n          result.add(message);\n        }\n      }\n\n      return Futures.immediateFuture(new RestfulCollection<Message>(result));\n\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<MessageCollection> createMessageCollection(UserId userId,\n      MessageCollection msgCollection, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessage(UserId userId, String msgCollId, String messageId,\n      Message message, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessageCollection(UserId userId, MessageCollection msgCollection,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessageCollection(UserId userId, String msgCollId, SecurityToken token)\n      throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * Public methods for use with Authentication Classes\n   *\n   * @param username a {@link java.lang.String} object.\n   * @return a {@link java.lang.String} object.\n   */\n  public String getPassword(String username) {\n    try {\n      return db.getJSONObject(PASSWORDS_TABLE).getString(username);\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n\n  private Set<String> getIdSet(UserId user, GroupId group, SecurityToken token)\n      throws JSONException {\n    String userId = user.getUserId(token);\n\n    if (group == null) {\n      return ImmutableSortedSet.of(userId);\n    }\n\n    Set<String> returnVal = Sets.newLinkedHashSet();\n    switch (group.getType()) {\n    case all:\n    case friends:\n      if (db.getJSONObject(FRIEND_LINK_TABLE).has(userId)) {\n        JSONArray friends = db.getJSONObject(FRIEND_LINK_TABLE).getJSONArray(userId);\n        for (int i = 0; i < friends.length(); i++) {\n          returnVal.add(friends.getString(i));\n        }\n      }\n      break;\n    case objectId:\n      if (db.getJSONObject(GROUP_MEMBERS_TABLE).has(group.toString())) {\n        JSONArray groupMembers = db.getJSONObject(GROUP_MEMBERS_TABLE).getJSONArray(group.toString());\n        for (int i = 0; i < groupMembers.length(); i++) {\n          returnVal.add(groupMembers.getString(i));\n        }\n      }\n      break;\n    case self:\n      returnVal.add(userId);\n      break;\n    }\n    return returnVal;\n  }\n\n  /**\n   * Get the set of user id's for a set of users and a group\n   *\n   * @param users set of UserIds\n   * @param group the group\n   * @param token a token\n   * @return set of Id strings\n   * @throws org.json.JSONException if errors in Json\n   */\n  public Set<String> getIdSet(Set<UserId> users, GroupId group, SecurityToken token)\n      throws JSONException {\n    Set<String> ids = Sets.newLinkedHashSet();\n    for (UserId user : users) {\n      ids.addAll(getIdSet(user, group, token));\n    }\n    return ids;\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Album> getAlbum(UserId userId, String appId, Set<String> fields,\n                                String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Search albums for given ID and owner\n        JSONObject album;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          album = userAlbums.getJSONObject(i);\n          if (album.getString(Album.Field.ID.toString()).equals(albumId) &&\n              album.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n            return Futures.immediateFuture(filterFields(album, fields, Album.class));\n          }\n        }\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(UserId userId, String appId,\n                                                    Set<String> fields, CollectionOptions options, Set<String> albumIds,\n                                                    SecurityToken token) throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Stores target albums\n        List<Album> result = Lists.newArrayList();\n\n        // Search for every albumId\n        boolean found;\n        JSONObject curAlbum;\n        for (String albumId : albumIds) {\n          // Search albums for this albumId\n          found = false;\n          for (int i = 0; i < userAlbums.length(); i++) {\n            curAlbum = userAlbums.getJSONObject(i);\n            if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId) &&\n                curAlbum.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n              result.add(filterFields(curAlbum, fields, Album.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - albumId not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n          }\n        }\n\n        // Return found albums\n        return Futures.immediateFuture(new RestfulCollection<Album>(result));\n      }\n\n      // Album table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User '\" + user + \"' has no albums\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(Set<UserId> userIds,\n                                                    GroupId groupId, String appId, Set<String> fields,\n                                                    CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Album> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather albums for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(ALBUMS_TABLE).has(id)) {\n          JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userAlbums.length(); i++) {\n            JSONObject album = userAlbums.getJSONObject(i);\n            if (album.getString(Album.Field.OWNER_ID.toString()).equals(id)) {\n              result.add(filterFields(album, fields, Album.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Album>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteAlbum(UserId userId, String appId, String albumId,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      boolean targetFound = false;      // indicates if target album is found\n      JSONArray newAlbums = new JSONArray();  // list of albums minus target\n      String user = userId.getUserId(token);  // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Compose new list of albums excluding album to be deleted\n        JSONObject curAlbum;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newAlbums.put(curAlbum);\n          }\n        }\n      }\n\n      // Overwrite user's albums with updated list if album found\n      if (targetFound) {\n        db.getJSONObject(ALBUMS_TABLE).put(user, newAlbums);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: userId and album's ownerId don't have to match - potential problem\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createAlbum(UserId userId, String appId, Album album,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      // Get table of user's albums\n      String user = userId.getUserId(token);\n      JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n      if (userAlbums == null) {\n        userAlbums = new JSONArray();\n        db.getJSONObject(ALBUMS_TABLE).put(user, userAlbums);\n      }\n\n      // Convert album to JSON and set ID & owner\n      JSONObject jsonAlbum = convertToJson(album);\n      if (!jsonAlbum.has(Album.Field.ID.toString())) {\n        jsonAlbum.put(Album.Field.ID.toString(), System.currentTimeMillis());\n      }\n      if (!jsonAlbum.has(Album.Field.OWNER_ID.toString())) {\n        jsonAlbum.put(Album.Field.OWNER_ID.toString(), user);\n      }\n\n      // Insert new album into table\n      userAlbums.put(jsonAlbum);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateAlbum(UserId userId, String appId, Album album,\n                                  String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Convert album to JSON and set ID\n        JSONObject jsonAlbum = convertToJson(album);\n        jsonAlbum.put(Album.Field.ID.toString(), albumId);\n\n        // Iterate through albums to identify album to update\n        for (int i = 0; i < userAlbums.length(); i++) {\n          JSONObject curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            userAlbums.put(i, jsonAlbum);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<MediaItem> getMediaItem(UserId userId, String appId,\n                                        String albumId, String mediaItemId, Set<String> fields,\n                                        SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Search user's MediaItems for given ID and album\n        JSONObject mediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          mediaItem = userMediaItems.getJSONObject(i);\n          if (mediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              mediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            return Futures.immediateFuture(filterFields(mediaItem, fields, MediaItem.class));\n          }\n        }\n      }\n\n      // MediaItem wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID '\" + mediaItemId + \"' does not exist within Album '\" + albumId + '\\'');\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> mediaItemIds,\n                                                            Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores found MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search for every MediaItem ID target\n        boolean found;\n        JSONObject curMediaItem;\n        for (String mediaItemId : mediaItemIds) {\n          // Search existing MediaItems for this MediaItem ID\n          found = false;\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            curMediaItem = userMediaItems.getJSONObject(i);\n            if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(albumId) &&\n                curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n              result.add(filterFields(curMediaItem, fields, MediaItem.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - MediaItem ID not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist within Album \" + albumId);\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem table not found for user \" + user);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> fields,\n                                                            CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores target MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search user's MediaItems for given album\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            result.add(filterFields(curMediaItem, fields, MediaItem.class));\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(\n      Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<MediaItem> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather MediaItems for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(MEDIAITEMS_TABLE).has(id)) {\n          JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            result.add(filterFields(userMediaItems.getJSONObject(i), fields, MediaItem.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      boolean targetFound = false;        // indicates if target MediaItem is found\n      JSONArray newMediaItems = new JSONArray();  // list of MediaItems minus target\n      String user = userId.getUserId(token);    // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Compose new list of MediaItems excluding item to be deleted\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newMediaItems.put(curMediaItem);\n          }\n        }\n      }\n\n      // Overwrite user's MediaItems with updated list if target found\n      if (targetFound) {\n        db.getJSONObject(MEDIAITEMS_TABLE).put(user, newMediaItems);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createMediaItem(UserId userId, String appId,\n                                      String albumId, MediaItem mediaItem, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Get table of user's MediaItems\n      JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(userId.getUserId(token));\n      if (userMediaItems == null) {\n        userMediaItems = new JSONArray();\n        db.getJSONObject(MEDIAITEMS_TABLE).put(userId.getUserId(token), userMediaItems);\n      }\n\n      // Convert MediaItem to JSON and set ID & Album ID\n      JSONObject jsonMediaItem = convertToJson(mediaItem);\n      jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n      if (!jsonMediaItem.has(MediaItem.Field.ID.toString())) {\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), System.currentTimeMillis());\n      }\n\n      // Insert new MediaItem into table\n      userMediaItems.put(jsonMediaItem);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, MediaItem mediaItem,\n                                      SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Convert MediaItem to JSON and set ID & Album ID\n        JSONObject jsonMediaItem = convertToJson(mediaItem);\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), mediaItemId);\n        jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n\n        // Iterate through MediaItems to identify item to update\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          JSONObject curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            userMediaItems.put(i, jsonMediaItem);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no MediaItem found with given ID and Album ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> updateActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        if (activityId != null) {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), activityId);\n        } else {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n        }\n      }\n      activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Find & replace activity\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          jsonArray.put(i, jsonEntry);\n          return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> createActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n      }\n      String activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Ensure activity does not already exist\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity already exists: \" + activityId);\n        }\n      }\n      jsonArray.put(jsonEntry);\n      return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivityEntries(UserId userId, GroupId groupId,\n      String appId, Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n\n        if (activityEntries != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (!activityIds.contains(activityEntry.getString(ActivityEntry.Field.ID.toString()))) {\n              newList.put(activityEntry);\n            }\n          }\n          db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(user, newList);\n        }\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> getActivityEntry(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, String activityId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for (int i = 0; i < activityEntries.length(); i++) {\n          JSONObject activityEntry = activityEntries.getJSONObject(i);\n          if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activityEntry, fields, ActivityEntry.class));\n          }\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n\n/** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      Set<UserId> userIds, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n      List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(id)) {\n          JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n            // TODO: ActivityStreams don't have appIds\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      UserId userId, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, Set<String> activityIds, SecurityToken token)\n      throws ProtocolException {\n    List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for(String activityId : activityIds) {\n          boolean found = false;\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n              result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND, \"Activity not found: \" + activityId);\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // TODO Why specifically handle Activity instead of generic POJO (below)?\n\n  private JSONObject convertFromActivity(Activity activity, Set<String> fields)\n      throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activity));\n  }\n\n  private JSONObject convertFromActivityEntry(ActivityEntry activityEntry, Set<String> fields) throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activityEntry));\n  }\n\n  private JSONObject convertToJson(Object object) throws JSONException {\n    // TODO not using fields yet\n    return new JSONObject(converter.convertToString(object));\n  }\n\n  public <T> T filterFields(JSONObject object, Set<String> fields,\n                            Class<T> clz) throws JSONException {\n    if (!fields.isEmpty()) {\n      // Create a copy with just the specified fields\n      object = new JSONObject(object, fields.toArray(new String[fields\n          .size()]));\n    }\n    String objectVal = object.toString();\n    if (authority != null) {\n      objectVal = objectVal.replace(\"%origin%\", authority.getOrigin());\n    } else {\n      //provide default for junit tests\n      objectVal = objectVal.replace(\"%origin%\", \"http://localhost:8080\");\n    }\n    return converter.convertToObject(objectVal, clz);\n  }\n}\n","lineNo":631}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.templates.tags;\n\nimport org.apache.shindig.gadgets.templates.TemplateProcessor;\nimport org.apache.shindig.gadgets.templates.ElementELResolver.ElementWrapper;\nimport org.w3c.dom.DocumentFragment;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\n\n/**\n * TagHandler implemented by an declarative XML definition.\n */\npublic class TemplateBasedTagHandler extends AbstractTagHandler {\n\n  private final Element templateDefinition;\n\n  public TemplateBasedTagHandler(Element templateDefinition, String namespaceUri, String tagName) {\n    super(namespaceUri, tagName);\n    this.templateDefinition = templateDefinition;\n  }\n\n  public void process(Node result, Element tagInstance, TemplateProcessor processor) {\n    // Process the children of the tag\n    DocumentFragment processedContent = processChildren(tagInstance, processor);\n\n    // Save the old values of \"My\", \"Cur\", and the template root element,\n    // and update each\n    Map<String, Object> oldMy = processor.getTemplateContext().setMy(\n        computeMy(tagInstance, processedContent, processor));\n    Object oldCur = processor.getTemplateContext().setCur(null);\n    Node oldTemplateRoot = processor.getTemplateContext().setTemplateRoot(processedContent);\n\n    processTemplate(result, tagInstance, processor);\n\n    // And restore the template context\n    processor.getTemplateContext().setMy(oldMy);\n    processor.getTemplateContext().setCur(oldCur);\n    processor.getTemplateContext().setTemplateRoot(oldTemplateRoot);\n  }\n\n  /** Process the template content in the new EL state */\n  protected void processTemplate(Node result, Element tagInstance, TemplateProcessor processor) {\n    processor.processChildNodes(result, templateDefinition);\n  }\n\n  /**\n   * Compute the value of ${My} for this tag execution.\n   */\n  protected Map<String, Object> computeMy(Element tagInstance, Node processedContent,\n      TemplateProcessor processor) {\n    Map<String, Object> myMap = Maps.newHashMap();\n\n    NodeList children = processedContent.getChildNodes();\n\n    for (int i = 0;  i < children.getLength(); i++) {\n      Node child = children.item(i);\n      if (child instanceof Element) {\n        Element el = (Element) child;\n        String name = el.getLocalName();\n        // TODO: why???  There should always be a local name.\n        if (name == null) {\n          name = el.getNodeName();\n        }\n\n        ElementWrapper wrapper = new ElementWrapper(el);\n        Object previous = myMap.get(name);\n        if (previous == null) {\n          myMap.put(name, wrapper);\n        } else if (previous instanceof ElementWrapper) {\n          List<ElementWrapper> bucket = Lists.newArrayListWithCapacity(children.getLength());\n          bucket.add((ElementWrapper) previous);\n          bucket.add(wrapper);\n          myMap.put(name, bucket);\n         } else {\n           // Must be a List<ElementWrapper>\n           @SuppressWarnings(\"unchecked\")\n           List<ElementWrapper> bucket = (List<ElementWrapper>) previous;\n           bucket.add(wrapper);\n        }\n      }\n    }\n\n    NamedNodeMap atts = tagInstance.getAttributes();\n    for (int i = 0; i < atts.getLength(); i++) {\n      String name = atts.item(i).getNodeName();\n      // Overwrite any pre-existing values, as attributes take\n      // precedence over elements.  This is wasteful if there are attributes\n      // and elements with the same name, but that should be very rare\n      myMap.put(name, getValueFromTag(tagInstance, name, processor, Object.class));\n    }\n\n    return myMap;\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.templates.tags;\n\nimport org.apache.shindig.gadgets.templates.TemplateProcessor;\nimport org.apache.shindig.gadgets.templates.ElementELResolver.ElementWrapper;\nimport org.w3c.dom.DocumentFragment;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\n\n/**\n * TagHandler implemented by an declarative XML definition.\n */\npublic class TemplateBasedTagHandler extends AbstractTagHandler {\n\n  private final Element templateDefinition;\n\n  public TemplateBasedTagHandler(Element templateDefinition, String namespaceUri, String tagName) {\n    super(namespaceUri, tagName);\n    this.templateDefinition = templateDefinition;\n  }\n\n  public void process(Node result, Element tagInstance, TemplateProcessor processor) {\n    // Process the children of the tag\n    DocumentFragment processedContent = processChildren(tagInstance, processor);\n\n    // Save the old values of \"My\", \"Cur\", and the template root element,\n    // and update each\n    Map<String, Object> oldMy = processor.getTemplateContext().setMy(\n        computeMy(tagInstance, processedContent, processor));\n    Object oldCur = processor.getTemplateContext().setCur(null);\n    Node oldTemplateRoot = processor.getTemplateContext().setTemplateRoot(processedContent);\n\n    processTemplate(result, tagInstance, processor);\n\n    // And restore the template context\n    processor.getTemplateContext().setMy(oldMy);\n    processor.getTemplateContext().setCur(oldCur);\n    processor.getTemplateContext().setTemplateRoot(oldTemplateRoot);\n  }\n\n  /** Process the template content in the new EL state */\n  protected void processTemplate(Node result, Element tagInstance, TemplateProcessor processor) {\n    synchronized (result) {\n      processor.processChildNodes(result, templateDefinition);\n    }\n  }\n\n  /**\n   * Compute the value of ${My} for this tag execution.\n   */\n  protected Map<String, Object> computeMy(Element tagInstance, Node processedContent,\n      TemplateProcessor processor) {\n    Map<String, Object> myMap = Maps.newHashMap();\n    Node clonedSource;\n    synchronized (processedContent) {\n      clonedSource = processedContent.cloneNode(true);\n    }\n    int children = clonedSource.getChildNodes().getLength();\n    Node childNode = clonedSource.getFirstChild();\n    while(childNode != null) {\n      if (childNode instanceof Element) {\n        Element el = (Element) childNode;\n        String name = el.getLocalName();\n        // TODO: why???  There should always be a local name.\n        if (name == null) {\n          name = el.getNodeName();\n        }\n        ElementWrapper wrapper = new ElementWrapper(el);\n        Object previous = myMap.get(name);\n        if (previous == null) {\n          myMap.put(name, wrapper);\n        } else if (previous instanceof ElementWrapper) {\n          List<ElementWrapper> bucket = Lists.newArrayListWithCapacity(children);\n          bucket.add((ElementWrapper) previous);\n          bucket.add(wrapper);\n          myMap.put(name, bucket);\n         } else {\n           // Must be a List<ElementWrapper>\n           @SuppressWarnings(\"unchecked\")\n           List<ElementWrapper> bucket = (List<ElementWrapper>) previous;\n           bucket.add(wrapper);\n        }\n      }\n      childNode = childNode.getNextSibling();\n    }\n\n    NamedNodeMap atts = tagInstance.getAttributes();\n    for (int i = 0; i < atts.getLength(); i++) {\n      String name = atts.item(i).getNodeName();\n      // Overwrite any pre-existing values, as attributes take\n      // precedence over elements.  This is wasteful if there are attributes\n      // and elements with the same name, but that should be very rare\n      myMap.put(name, getValueFromTag(tagInstance, name, processor, Object.class));\n    }\n\n    return myMap;\n  }\n}\n","lineNo":83}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.protocol.conversion;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport org.apache.shindig.common.JsonProperty;\nimport org.apache.shindig.common.JsonSerializer;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.protocol.ContentTypes;\nimport org.apache.shindig.protocol.model.Enum;\nimport org.apache.shindig.protocol.model.EnumImpl;\nimport org.apache.shindig.protocol.model.ExtendableBean;\nimport org.joda.time.DateTime;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.inject.Inject;\nimport com.google.inject.Injector;\n\n/**\n * Converts between JSON and java objects.\n *\n * TODO: Eliminate BeanConverter interface.\n */\npublic class BeanJsonConverter implements BeanConverter {\n\n  // Only compute the filtered SETTERS once per-class\n  private static final LoadingCache<Class<?>, Map<String, Method>> SETTERS = CacheBuilder\n      .newBuilder()\n      .build(new CacheLoader<Class<?>, Map<String, Method>>() {\n        public Map<String, Method> load(Class<?> type) {\n          ImmutableMap.Builder<String, Method> builder = ImmutableMap.builder();\n          for (Method method : type.getMethods()) {\n            if (method.getParameterTypes().length == 1) {\n              String name = getPropertyName(method);\n              if (name != null) {\n                builder.put(name, method);\n              }\n            }\n          }\n          return builder.build();\n        }\n      });\n\n  private final Injector injector;\n\n  @Inject\n  public BeanJsonConverter(Injector injector) {\n    this.injector = injector;\n  }\n\n  public String getContentType() {\n    return ContentTypes.OUTPUT_JSON_CONTENT_TYPE;\n  }\n\n  /**\n   * Convert the passed in object to a string.\n   *\n   * @param pojo The object to convert\n   * @return An object whose toString method will return json\n   */\n  public String convertToString(final Object pojo) {\n    return JsonSerializer.serialize(pojo);\n  }\n\n  public void append(Appendable buf, Object pojo) throws IOException {\n    JsonSerializer.append(buf, pojo);\n  }\n\n  private static String getPropertyName(Method setter) {\n    JsonProperty property = setter.getAnnotation(JsonProperty.class);\n    if (property == null) {\n      String name = setter.getName();\n      if (name.startsWith(\"set\") && !Modifier.isStatic(setter.getModifiers())) {\n        return name.substring(3, 4).toLowerCase() + name.substring(4);\n      }\n      return null;\n    } else {\n      return property.value();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  // Class.cast() would be better - but the Class object may be null\n  public <T> T convertToObject(String string, Class<T> clazz) {\n    return (T)convertToObject(string, (Type) clazz);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T convertToObject(String json, Type type) {\n    try {\n      return (T) convertToObject(new JSONObject(json), type);\n    } catch (JSONException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public Object convertToObject(Object value, Type type) {\n    if (type == null || type.equals(Object.class)) {\n      // Use the source type instead.\n      if (value instanceof JSONObject) {\n        return convertToMap((JSONObject) value, null);\n      } else if (value instanceof JSONArray) {\n        return convertToList((JSONArray) value, null);\n      }\n      return value;\n    } else if (type instanceof ParameterizedType) {\n      return convertGeneric(value, (ParameterizedType) type);\n    } else if (type.equals(String.class)) {\n      return String.valueOf(value);\n    } else if (type.equals(Boolean.class) || type.equals(Boolean.TYPE)) {\n      return value instanceof String ? Boolean.valueOf((String) value) : Boolean.TRUE.equals(value);\n    } else if (type.equals(Integer.class) || type.equals(Integer.TYPE)) {\n      return value instanceof String ? Integer.valueOf((String) value) : ((Number) value).intValue();\n    } else if (type.equals(Long.class) || type.equals(Long.TYPE)) {\n      return value instanceof String ? Long.valueOf((String) value) : ((Number) value).longValue();\n    } else if (type.equals(Double.class) || type.equals(Double.TYPE)) {\n      return value instanceof String ? Double.valueOf((String) value) : ((Number) value).doubleValue();\n    } else if (type.equals(Float.class) || type.equals(Float.TYPE)) {\n      return value instanceof String ? Float.valueOf((String) value) : ((Number) value).floatValue();\n    } else if (type.equals(Date.class)) {\n      return new DateTime(String.valueOf(value)).toDate();\n    } else if (type.equals(Uri.class)) {\n      return Uri.parse(String.valueOf(value));\n    } else if (type.equals(Map.class)) {\n      return convertToMap((JSONObject) value, null);\n    } else if (type.equals(List.class) || type.equals(Collection.class)) {\n      return convertToList((JSONArray) value, null);\n    } else if (type.equals(Set.class)) {\n      return convertToSet((JSONArray) value, null);\n    }\n\n    Class<?> clazz = (Class<?>) type;\n\n    if (clazz.isEnum()) {\n      return convertToEnum((String) value, clazz);\n    }\n\n    return convertToClass((JSONObject) value, clazz);\n  }\n\n  private Object convertGeneric(Object value, ParameterizedType type) {\n    Type[] typeArgs = type.getActualTypeArguments();\n    Class<?> clazz = (Class<?>) type.getRawType();\n\n    if (Set.class.isAssignableFrom(clazz)) {\n      return convertToSet((JSONArray) value, typeArgs[0]);\n    } else if (Collection.class.isAssignableFrom(clazz)) {\n      return convertToList((JSONArray) value, typeArgs[0]);\n    } else if (Map.class.isAssignableFrom(clazz)) {\n      return convertToMap((JSONObject) value, typeArgs[1]);\n    } else if (org.apache.shindig.protocol.model.Enum.class.isAssignableFrom(clazz)) {\n      // Special case for opensocial Enum objects. These really need to be refactored to not require\n      // this handling.\n      return convertToOsEnum((JSONObject) value, (Class<?>) typeArgs[0]);\n    }\n    return convertToClass((JSONObject) value, clazz);\n  }\n\n  private Enum<Enum.EnumKey> convertToOsEnum(JSONObject json, Class<?> enumKeyType) {\n    Enum<Enum.EnumKey> value;\n    String val = Enum.Field.VALUE.toString();\n    String display = Enum.Field.DISPLAY_VALUE.toString();\n    if (json.has(val)) {\n      Enum.EnumKey enumKey;\n      try {\n        enumKey = (Enum.EnumKey) enumKeyType.getField(json.optString(val)).get(null);\n      } catch (IllegalArgumentException e) {\n        throw new RuntimeException(e);\n      } catch (SecurityException e) {\n        throw new RuntimeException(e);\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      } catch (NoSuchFieldException e) {\n        throw new RuntimeException(e);\n      }\n      String displayValue = null;\n      if (json.has(display)) {\n        displayValue = json.optString(display);\n      }\n      value = new EnumImpl<Enum.EnumKey>(enumKey,displayValue);\n    } else {\n      value = new EnumImpl<Enum.EnumKey>(null, json.optString(display));\n    }\n    return value;\n  }\n\n  private Object convertToEnum(String value, Class<?> type) {\n    for (Object o : type.getEnumConstants()) {\n      if (o.toString().equals(value)) {\n        return o;\n      }\n    }\n    throw new IllegalArgumentException(\"No enum value \" + value + \" in \" + type.getName());\n  }\n\n  private Map<String, Object> convertToMap(JSONObject in, Type type) {\n    Map<String, Object> out = new HashMap<String, Object>(in.length(), 1);\n    if(in.length() == 0)\n      return Collections.emptyMap();\n\n    for (String name : JSONObject.getNames(in)) {\n      out.put(name, convertToObject(in.opt(name), type));\n    }\n    return out;\n  }\n\n  private List<Object> convertToList(JSONArray in, Type type) {\n    ArrayList<Object> out = Lists.newArrayListWithCapacity(in.length());\n\n    for (int i = 0, j = in.length(); i < j; ++i) {\n      out.add(convertToObject(in.opt(i), type));\n    }\n    return out;\n  }\n\n  private Set<Object> convertToSet(JSONArray in, Type type) {\n    return ImmutableSet.copyOf(convertToList(in, type));\n  }\n\n  private Object convertToClass(JSONObject in, Class<?> type) {\n    Object out = injector.getInstance(type);\n\n    /*\n     * Simple hack to add support for arbitrary extensions to Shindig's data\n     * model.  It initializes keys/values of an ExtendableBean class, which is\n     * a Map under the covers.  If a class implements ExtendableBean.java, it\n     * will support arbitrary mappings to JSON & XML.\n     */\n    if (ExtendableBean.class.isAssignableFrom(type)) {\n      for (String name : JSONObject.getNames(in)) {\n        ((ExtendableBean) out).put(name, convertToObject(in.opt(name), null));\n      }\n    }\n\n    for (Map.Entry<String, Method> entry : SETTERS.getUnchecked(out.getClass()).entrySet()) {\n      Object value = in.opt(entry.getKey());\n      if (value != null) {\n        Method method = entry.getValue();\n        try {\n          method.invoke(out, convertToObject(value, method.getGenericParameterTypes()[0]));\n        } catch (IllegalArgumentException e) {\n          throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        } catch (InvocationTargetException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n    return out;\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.protocol.conversion;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport org.apache.shindig.common.JsonProperty;\nimport org.apache.shindig.common.JsonSerializer;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.protocol.ContentTypes;\nimport org.apache.shindig.protocol.model.Enum;\nimport org.apache.shindig.protocol.model.EnumImpl;\nimport org.apache.shindig.protocol.model.ExtendableBean;\nimport org.joda.time.DateTime;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.inject.Inject;\nimport com.google.inject.Injector;\n\n/**\n * Converts between JSON and java objects.\n *\n * TODO: Eliminate BeanConverter interface.\n */\npublic class BeanJsonConverter implements BeanConverter {\n\n  // Only compute the filtered SETTERS once per-class\n  private static final LoadingCache<Class<?>, Map<String, Method>> SETTERS = CacheBuilder\n      .newBuilder()\n      .build(new CacheLoader<Class<?>, Map<String, Method>>() {\n        public Map<String, Method> load(Class<?> type) {\n          ImmutableMap.Builder<String, Method> builder = ImmutableMap.builder();\n          for (Method method : type.getMethods()) {\n            if (method.getParameterTypes().length == 1) {\n              String name = getPropertyName(method);\n              if (name != null) {\n                builder.put(name, method);\n              }\n            }\n          }\n          return builder.build();\n        }\n      });\n\n  private final Injector injector;\n\n  @Inject\n  public BeanJsonConverter(Injector injector) {\n    this.injector = injector;\n  }\n\n  public String getContentType() {\n    return ContentTypes.OUTPUT_JSON_CONTENT_TYPE;\n  }\n\n  /**\n   * Convert the passed in object to a string.\n   *\n   * @param pojo The object to convert\n   * @return An object whose toString method will return json\n   */\n  public String convertToString(final Object pojo) {\n    return JsonSerializer.serialize(pojo);\n  }\n\n  public void append(Appendable buf, Object pojo) throws IOException {\n    JsonSerializer.append(buf, pojo);\n  }\n\n  private static String getPropertyName(Method setter) {\n    JsonProperty property = setter.getAnnotation(JsonProperty.class);\n    if (property == null) {\n      String name = setter.getName();\n      if (name.startsWith(\"set\") && !Modifier.isStatic(setter.getModifiers())) {\n        return name.substring(3, 4).toLowerCase() + name.substring(4);\n      }\n      return null;\n    } else {\n      return property.value();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  // Class.cast() would be better - but the Class object may be null\n  public <T> T convertToObject(String string, Class<T> clazz) {\n    return (T)convertToObject(string, (Type) clazz);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T convertToObject(String json, Type type) {\n    try {\n      return (T) convertToObject(new JSONObject(json), type);\n    } catch (JSONException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public Object convertToObject(Object value, Type type) {\n    if (type == null || type.equals(Object.class)) {\n      // Use the source type instead.\n      if (value instanceof JSONObject) {\n        return convertToMap((JSONObject) value, null);\n      } else if (value instanceof JSONArray) {\n        return convertToList((JSONArray) value, null);\n      }\n      return value;\n    } else if (type instanceof ParameterizedType) {\n      return convertGeneric(value, (ParameterizedType) type);\n    } else if (type.equals(String.class)) {\n      return String.valueOf(value);\n    } else if (type.equals(Boolean.class) || type.equals(Boolean.TYPE)) {\n      return value instanceof String ? Boolean.valueOf((String) value) : Boolean.TRUE.equals(value);\n    } else if (type.equals(Integer.class) || type.equals(Integer.TYPE)) {\n      return value instanceof String ? Integer.valueOf((String) value) : ((Number) value).intValue();\n    } else if (type.equals(Long.class) || type.equals(Long.TYPE)) {\n      return value instanceof String ? Long.valueOf((String) value) : ((Number) value).longValue();\n    } else if (type.equals(Double.class) || type.equals(Double.TYPE)) {\n      return value instanceof String ? Double.valueOf((String) value) : ((Number) value).doubleValue();\n    } else if (type.equals(Float.class) || type.equals(Float.TYPE)) {\n      return value instanceof String ? Float.valueOf((String) value) : ((Number) value).floatValue();\n    } else if (type.equals(Date.class)) {\n      return new DateTime(String.valueOf(value)).toDate();\n    } else if (type.equals(Uri.class)) {\n      return Uri.parse(String.valueOf(value));\n    } else if (type.equals(Map.class)) {\n      return convertToMap((JSONObject) value, null);\n    } else if (type.equals(List.class) || type.equals(Collection.class)) {\n      return convertToList((JSONArray) value, null);\n    } else if (type.equals(Set.class)) {\n      return convertToSet((JSONArray) value, null);\n    }\n\n    Class<?> clazz = (Class<?>) type;\n\n    if (clazz.isEnum()) {\n      return convertToEnum((String) value, clazz);\n    }\n\n    return convertToClass((JSONObject) value, clazz);\n  }\n\n  private Object convertGeneric(Object value, ParameterizedType type) {\n    Type[] typeArgs = type.getActualTypeArguments();\n    Class<?> clazz = (Class<?>) type.getRawType();\n\n    if (Set.class.isAssignableFrom(clazz)) {\n      return convertToSet((JSONArray) value, typeArgs[0]);\n    } else if (Collection.class.isAssignableFrom(clazz)) {\n      return convertToList((JSONArray) value, typeArgs[0]);\n    } else if (Map.class.isAssignableFrom(clazz)) {\n      return convertToMap((JSONObject) value, typeArgs[1]);\n    } else if (org.apache.shindig.protocol.model.Enum.class.isAssignableFrom(clazz)) {\n      // Special case for opensocial Enum objects. These really need to be refactored to not require\n      // this handling.\n      return convertToOsEnum((JSONObject) value, (Class<?>) typeArgs[0]);\n    }\n    return convertToClass((JSONObject) value, clazz);\n  }\n\n  private Enum<Enum.EnumKey> convertToOsEnum(JSONObject json, Class<?> enumKeyType) {\n    Enum<Enum.EnumKey> value;\n    String val = Enum.Field.VALUE.toString();\n    String display = Enum.Field.DISPLAY_VALUE.toString();\n    if (json.has(val)) {\n      Enum.EnumKey enumKey;\n      try {\n        enumKey = (Enum.EnumKey) enumKeyType.getField(json.optString(val)).get(null);\n      } catch (IllegalArgumentException e) {\n        throw new RuntimeException(e);\n      } catch (SecurityException e) {\n        throw new RuntimeException(e);\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      } catch (NoSuchFieldException e) {\n        throw new RuntimeException(e);\n      }\n      String displayValue = null;\n      if (json.has(display)) {\n        displayValue = json.optString(display);\n      }\n      value = new EnumImpl<Enum.EnumKey>(enumKey,displayValue);\n    } else {\n      value = new EnumImpl<Enum.EnumKey>(null, json.optString(display));\n    }\n    return value;\n  }\n\n  private Object convertToEnum(String value, Class<?> type) {\n    for (Object o : type.getEnumConstants()) {\n      if (o.toString().equals(value)) {\n        return o;\n      }\n    }\n    throw new IllegalArgumentException(\"No enum value \" + value + \" in \" + type.getName());\n  }\n\n  private Map<String, Object> convertToMap(JSONObject in, Type type) {\n    Map<String, Object> out = new HashMap<String, Object>(in.length(), 1);\n    if(in.length() == 0)\n      return Collections.emptyMap();\n\n    for (String name : JSONObject.getNames(in)) {\n      out.put(name, convertToObject(in.opt(name), type));\n    }\n    return out;\n  }\n\n  private List<Object> convertToList(JSONArray in, Type type) {\n    ArrayList<Object> out = Lists.newArrayListWithCapacity(in.length());\n\n    for (int i = 0, j = in.length(); i < j; ++i) {\n      out.add(convertToObject(in.opt(i), type));\n    }\n    return out;\n  }\n\n  private Set<Object> convertToSet(JSONArray in, Type type) {\n    return ImmutableSet.copyOf(convertToList(in, type));\n  }\n\n  private Object convertToClass(JSONObject in, Class<?> type) {\n    Object out = injector.getInstance(type);\n\n    /*\n     * Simple hack to add support for arbitrary extensions to Shindig's data\n     * model.  It initializes keys/values of an ExtendableBean class, which is\n     * a Map under the covers.  If a class implements ExtendableBean.java, it\n     * will support arbitrary mappings to JSON & XML.\n     */\n    if (ExtendableBean.class.isAssignableFrom(type)) {\n      String[] names = JSONObject.getNames(in);\n      if (names != null) {\n        for (String name : names) {\n          ((ExtendableBean) out).put(name, convertToObject(in.opt(name), null));\n        }\n      }\n    }\n\n    for (Map.Entry<String, Method> entry : SETTERS.getUnchecked(out.getClass()).entrySet()) {\n      Object value = in.opt(entry.getKey());\n      if (value != null) {\n        Method method = entry.getValue();\n        try {\n          method.invoke(out, convertToObject(value, method.getGenericParameterTypes()[0]));\n        } catch (IllegalArgumentException e) {\n          throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        } catch (InvocationTargetException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n    return out;\n  }\n}\n","lineNo":268}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.social.sample.spi;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Future;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.AnonymousSecurityToken;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.protocol.DataCollection;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.RestfulCollection;\nimport org.apache.shindig.protocol.conversion.BeanConverter;\nimport org.apache.shindig.protocol.model.SortOrder;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.opensocial.model.Activity;\nimport org.apache.shindig.social.opensocial.model.ActivityEntry;\nimport org.apache.shindig.social.opensocial.model.Album;\nimport org.apache.shindig.social.opensocial.model.Group;\nimport org.apache.shindig.social.opensocial.model.MediaItem;\nimport org.apache.shindig.social.opensocial.model.Message;\nimport org.apache.shindig.social.opensocial.model.MessageCollection;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.spi.ActivityService;\nimport org.apache.shindig.social.opensocial.spi.ActivityStreamService;\nimport org.apache.shindig.social.opensocial.spi.AlbumService;\nimport org.apache.shindig.social.opensocial.spi.AppDataService;\nimport org.apache.shindig.social.opensocial.spi.CollectionOptions;\nimport org.apache.shindig.social.opensocial.spi.GroupId;\nimport org.apache.shindig.social.opensocial.spi.GroupService;\nimport org.apache.shindig.social.opensocial.spi.MediaItemService;\nimport org.apache.shindig.social.opensocial.spi.MessageService;\nimport org.apache.shindig.social.opensocial.spi.PersonService;\nimport org.apache.shindig.social.opensocial.spi.UserId;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\n\n/**\n * Implementation of supported services backed by a JSON DB.\n */\n@Singleton\npublic class JsonDbOpensocialService implements ActivityService, PersonService, AppDataService,\n    MessageService, AlbumService, MediaItemService, ActivityStreamService, GroupService {\n\n  private static final Comparator<Person> NAME_COMPARATOR = new Comparator<Person>() {\n    public int compare(Person person, Person person1) {\n      String name = person.getName().getFormatted();\n      String name1 = person1.getName().getFormatted();\n      return name.compareTo(name1);\n    }\n  };\n\n  /**\n   * The DB\n   */\n  private JSONObject db;\n\n  /**\n   * The JSON<->Bean converter\n   */\n  private BeanConverter converter;\n\n  /**\n   * db[\"people\"] -> Array<Person>\n   */\n  private static final String PEOPLE_TABLE = \"people\";\n\n  /**\n   * db[\"groups\"] -> Array<Group>\n   */\n  private static final String GROUPS_TABLE = \"groups\";\n\n  /**\n   * db[\"groupMembers\"] -> Array<Person>\n   */\n  private static final String GROUP_MEMBERS_TABLE = \"groupMembers\";\n\n  /**\n   * db[\"activities\"] -> Map<Person.Id, Array<Activity>>\n   */\n  private static final String ACTIVITIES_TABLE = \"activities\";\n\n  /**\n   * db[\"albums\"] -> Map<Person.Id, Array<Album>>\n   */\n  private static final String ALBUMS_TABLE = \"albums\";\n\n  /**\n   * db[\"mediaItems\"] -> Map<Person.Id, Array<MediaItem>>\n   */\n  private static final String MEDIAITEMS_TABLE = \"mediaItems\";\n\n  /**\n   * db[\"data\"] -> Map<Person.Id, Map<String, String>>\n   */\n  private static final String DATA_TABLE = \"data\";\n\n  /**\n   * db[\"friendLinks\"] -> Map<Person.Id, Array<Person.Id>>\n   */\n  private static final String FRIEND_LINK_TABLE = \"friendLinks\";\n\n  /**\n   * db[\"messages\"] -> Map<Person.Id, Array<Message>>\n   */\n  private static final String MESSAGE_TABLE = \"messages\";\n\n  /**\n   * db[\"passwords\"] -> Map<Person.Id, String>\n   */\n  private static final String PASSWORDS_TABLE = \"passwords\";\n\n  /**\n   * db[\"activityEntries\"] -> Map<Person.Id, Array<ActivityEntry>>\n   */\n  private static final String ACTIVITYSTREAMS_TABLE = \"activityEntries\";\n\n  /**\n   * Anonymous name.\n   */\n  private static final String ANONYMOUS_NAME = \"Anonymous\";\n\n  private Authority authority;\n\n  /**\n   * Initializes the JsonDbOpensocialService using Guice\n   *\n   * @param jsonLocation location of the json data provided by the shindig.canonical.json.db parameter\n   * @param converter an injected BeanConverter\n   * @throws java.lang.Exception if any\n   */\n  @Inject\n  public JsonDbOpensocialService(@Named(\"shindig.canonical.json.db\")\n  String jsonLocation, @Named(\"shindig.bean.converter.json\")\n  BeanConverter converter,\n  @Named(\"shindig.contextroot\") String contextroot) throws Exception {\n    String content = IOUtils.toString(ResourceLoader.openResource(jsonLocation), \"UTF-8\");\n    this.db = new JSONObject(content.replace(\"%contextroot%\", contextroot));\n    this.converter = converter;\n  }\n\n  /**\n   * Allows access to the underlying json db.\n   *\n   * @return a reference to the json db\n   */\n  public JSONObject getDb() {\n    return db;\n  }\n\n   /**\n   * override the json database\n   * @param db a {@link org.json.JSONObject}.\n   */\n  public void setDb(JSONObject db) {\n    this.db = db;\n  }\n\n  @Inject(optional = true)\n  public void setAuthority(Authority authority) {\n    this.authority = authority;\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(Set<UserId> userIds, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITIES_TABLE).has(id)) {\n          JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(id);\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (appId == null || !activity.has(Activity.Field.APP_ID.toString())) {\n              result.add(filterFields(activity, fields, Activity.class));\n            } else if (activity.get(Activity.Field.APP_ID.toString()).equals(appId)) {\n              result.add(filterFields(activity, fields, Activity.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, Set<String> activityIds,\n      SecurityToken token) throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n            result.add(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Activity> getActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activity.get(Activity.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivities(UserId userId, GroupId groupId, String appId,\n      Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        if (activities != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (!activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n              newList.put(activity);\n            }\n          }\n          db.getJSONObject(ACTIVITIES_TABLE).put(user, newList);\n          // TODO. This seems very odd that we return no useful response in this\n          // case\n          // There is no way to represent not-found\n          // if (found) { ??\n          // }\n        }\n      }\n      // What is the appropriate response here??\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> createActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Activity activity, SecurityToken token) throws ProtocolException {\n    // Are fields really needed here?\n    try {\n      JSONObject jsonObject = convertFromActivity(activity, fields);\n      if (!jsonObject.has(Activity.Field.ID.toString())) {\n        jsonObject.put(Activity.Field.ID.toString(), System.currentTimeMillis());\n      }\n      JSONArray jsonArray = db.getJSONObject(ACTIVITIES_TABLE)\n          .getJSONArray(userId.getUserId(token));\n      if (jsonArray == null) {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITIES_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      // TODO (woodser): if used with PUT, duplicate activity would be created?\n      jsonArray.put(jsonObject);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Person>> getPeople(Set<UserId> userIds, GroupId groupId,\n      CollectionOptions options, Set<String> fields, SecurityToken token) throws ProtocolException {\n    List<Person> result = Lists.newArrayList();\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (!idSet.contains(person.get(Person.Field.ID.toString()))) {\n          continue;\n        }\n\n        // Add group support later\n        Person personObj = filterFields(person, fields, Person.class);\n        Map<String, Object> appData = getPersonAppData(\n            person.getString(Person.Field.ID.toString()), fields);\n        personObj.setAppData(appData);\n\n        result.add(personObj);\n      }\n\n      if (GroupId.Type.self == groupId.getType() && result.isEmpty()) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"People '\" + idSet + \"' not found\");\n      }\n\n      // We can pretend that by default the people are in top friends order\n      if (options.getSortBy().equals(Person.Field.NAME.toString())) {\n        Collections.sort(result, NAME_COMPARATOR);\n\n        if (options.getSortOrder() == SortOrder.descending) {\n          Collections.reverse(result);\n        }\n      }\n\n      // TODO: The samplecontainer doesn't really have the concept of HAS_APP so\n      // we can't support any filters yet. We should fix this.\n\n      int totalSize = result.size();\n      int last = options.getFirst() + options.getMax();\n      result = result.subList(options.getFirst(), Math.min(last, totalSize));\n\n      return Futures.immediateFuture(new RestfulCollection<Person>(result, options.getFirst(), totalSize, options.getMax()));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)\n      throws ProtocolException {\n    if (id != null && AnonymousSecurityToken.ANONYMOUS_ID.equals(id.getUserId())) {\n      Person anonymous = new PersonImpl();\n      anonymous.setId(AnonymousSecurityToken.ANONYMOUS_ID);\n      anonymous.setName(new NameImpl(ANONYMOUS_NAME));\n      anonymous.setNickname(ANONYMOUS_NAME);\n      return Futures.immediateFuture(anonymous);\n    }\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (id != null && person.get(Person.Field.ID.toString()).equals(id.getUserId(token))) {\n          Person personObj = filterFields(person, fields, Person.class);\n          Map<String, Object> appData = getPersonAppData(person.getString(Person.Field.ID\n              .toString()), fields);\n          personObj.setAppData(appData);\n\n          return Futures.immediateFuture(personObj);\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Person '\" + id.getUserId(token) + \"' not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> updatePerson(UserId id, Person person, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String viewer = token.getViewerId(); // viewer\n      String user = id.getUserId(token); // person to update\n\n      if (!viewerCanUpdatePerson(viewer,user)) {\n        throw new ProtocolException(HttpServletResponse.SC_FORBIDDEN, \"User '\" + viewer + \"' does not have enough privileges to update person '\"+user+\"'\");\n      }\n\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject curPerson = people.getJSONObject(i);\n\n        if (user != null && curPerson.getString(Person.Field.ID.toString()).equals(user)) {\n          // Convert user to JSON and set ID\n          JSONObject jsonPerson = convertToJson(person);\n          // go through all properties to update in the submitted person object\n          // and change them in the current person object\n          for (String key : JSONObject.getNames(jsonPerson)) {\n            curPerson.put(key,jsonPerson.get(key));\n          }\n\n          people.put(i,curPerson);\n          return Futures.immediateFuture(converter.convertToObject(curPerson.toString(), Person.class));\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User ID \" + user + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n\n  }\n\n  /** Check if a viewer is allowed to update the given person record. **/\n  protected boolean viewerCanUpdatePerson(String viewer, String person) {\n    // A person can only update his own personal data (by default)\n    // if you wish to allow other people to update the personal data of the user\n    // you should change the current function\n    return viewer.equals(person) ? true : false;\n  }\n\n  private Map<String, Object> getPersonAppData(String id, Set<String> fields) {\n    try {\n      Map<String, Object> appData = null;\n      JSONObject personData = db.getJSONObject(DATA_TABLE).optJSONObject(id);\n      if (personData != null) {\n        if (fields.contains(Person.Field.APP_DATA.toString())) {\n          appData = Maps.newHashMap();\n          @SuppressWarnings(\"unchecked\")\n          Iterator<String> keys = personData.keys();\n          while (keys.hasNext()) {\n            String key = keys.next();\n            appData.put(key, personData.get(key));\n          }\n        } else {\n          String appDataPrefix = Person.Field.APP_DATA.toString() + '.';\n          for (String field : fields) {\n            if (field.startsWith(appDataPrefix)) {\n              if (appData == null) {\n                appData = Maps.newHashMap();\n              }\n\n              String appDataField = field.substring(appDataPrefix.length());\n              if (personData.has(appDataField)) {\n                appData.put(appDataField, personData.get(appDataField));\n              }\n            }\n          }\n        }\n      }\n\n      return appData;\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      Map<String, Map<String, Object>> idToData = Maps.newHashMap();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        JSONObject personData;\n        if (!db.getJSONObject(DATA_TABLE).has(id)) {\n          personData = new JSONObject();\n        } else {\n          if (!fields.isEmpty()) {\n            personData = new JSONObject(db.getJSONObject(DATA_TABLE).getJSONObject(id), fields\n                .toArray(new String[fields.size()]));\n          } else {\n            personData = db.getJSONObject(DATA_TABLE).getJSONObject(id);\n          }\n        }\n\n        // TODO: We can use the converter here to do this for us\n\n        // JSONObject keys are always strings\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = personData.keys();\n        Map<String, Object> data = Maps.newHashMap();\n        while (keys.hasNext()) {\n          String key = keys.next();\n          data.put(key, personData.getString(key));\n        }\n        idToData.put(id, data);\n      }\n      return Futures.immediateFuture(new DataCollection(idToData));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (!db.getJSONObject(DATA_TABLE).has(user)) {\n        return null;\n      }\n      JSONObject newPersonData = new JSONObject();\n      JSONObject oldPersonData = db.getJSONObject(DATA_TABLE).getJSONObject(user);\n\n      // JSONObject keys are always strings\n      @SuppressWarnings(\"unchecked\")\n      Iterator<String> keys = oldPersonData.keys();\n      while (keys.hasNext()) {\n        String key = keys.next();\n        if (!fields.contains(key)) {\n          newPersonData.put(key, oldPersonData.getString(key));\n        }\n      }\n      db.getJSONObject(DATA_TABLE).put(user, newPersonData);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Map<String, Object> values, SecurityToken token)\n      throws ProtocolException {\n    // TODO: this seems redundant. No need to pass both fields and a map of\n    // field->value\n    // TODO: According to rest, yes there is. If a field is in the param list\n    // but not in the map\n    // that means it is a delete\n\n    try {\n      JSONObject personData = db.getJSONObject(DATA_TABLE).getJSONObject(userId.getUserId(token));\n      if (personData == null) {\n        personData = new JSONObject();\n        db.getJSONObject(DATA_TABLE).put(userId.getUserId(token), personData);\n      }\n\n      for (Map.Entry<String, Object> entry : values.entrySet()) {\n        personData.put(entry.getKey(), entry.getValue());\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Group>> getGroups(UserId userId,\n\t\tCollectionOptions options, Set<String> fields, SecurityToken token)\n\t\tthrows ProtocolException {\n    List<Group> result = Lists.newArrayList();\n    String user = userId.getUserId(token);\n    try {\n      JSONArray groups = db.getJSONObject(GROUPS_TABLE).getJSONArray(user);\n\n      for (int i = 0; i < groups.length(); i++) {\n        JSONObject group = groups.getJSONObject(i);\n\n        Group groupObj = filterFields(group, fields, Group.class);\n        result.add(groupObj);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n\n    return Futures.immediateFuture(new RestfulCollection<Group>(result));\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Post a message for a set of users.\n   */\n  public Future<Void> createMessage(UserId userId, String appId, String msgCollId, Message message,\n      SecurityToken token) throws ProtocolException {\n    for (String recipient : message.getRecipients()) {\n      try {\n        JSONArray outbox = db.getJSONObject(MESSAGE_TABLE).getJSONArray(recipient);\n        if (outbox == null) {\n          outbox = new JSONArray();\n          db.getJSONObject(MESSAGE_TABLE).put(recipient, outbox);\n        }\n\n        outbox.put(message);\n      } catch (JSONException je) {\n        throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n            je);\n      }\n    }\n\n    return Futures.immediateFuture(null);\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MessageCollection>> getMessageCollections(UserId userId,\n      Set<String> fields, CollectionOptions options, SecurityToken token) throws ProtocolException {\n    try {\n      List<MessageCollection> result = Lists.newArrayList();\n      JSONObject messageCollections = db.getJSONObject(MESSAGE_TABLE).getJSONObject(\n          userId.getUserId(token));\n      for (String msgCollId : JSONObject.getNames(messageCollections)) {\n        JSONObject msgColl = messageCollections.getJSONObject(msgCollId);\n        msgColl.put(\"id\", msgCollId);\n        JSONArray messages = msgColl.getJSONArray(\"messages\");\n        int numMessages = (messages == null) ? 0 : messages.length();\n        msgColl.put(\"total\", String.valueOf(numMessages));\n        msgColl.put(\"unread\", String.valueOf(numMessages));\n\n        result.add(filterFields(msgColl, fields, MessageCollection.class));\n      }\n      return Futures.immediateFuture(new RestfulCollection<MessageCollection>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessages(UserId userId, String msgCollId, List<String> ids,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Gets the messsages in an user's queue.\n   */\n  public Future<RestfulCollection<Message>> getMessages(UserId userId, String msgCollId,\n      Set<String> fields, List<String> msgIds, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Message> result = Lists.newArrayList();\n      JSONArray messages = db.getJSONObject(MESSAGE_TABLE).getJSONObject(userId.getUserId(token))\n          .getJSONObject(msgCollId).getJSONArray(\"messages\");\n\n      // TODO: special case @all\n\n      if (messages == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"message collection\"\n            + msgCollId + \" not found\");\n      }\n\n      // TODO: filter and sort outbox.\n      for (int i = 0; i < messages.length(); i++) {\n        JSONObject msg = messages.getJSONObject(i);\n        result.add(filterFields(msg, fields, Message.class));\n      }\n\n      return Futures.immediateFuture(new RestfulCollection<Message>(result));\n\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<MessageCollection> createMessageCollection(UserId userId,\n      MessageCollection msgCollection, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessage(UserId userId, String msgCollId, String messageId,\n      Message message, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessageCollection(UserId userId, MessageCollection msgCollection,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessageCollection(UserId userId, String msgCollId, SecurityToken token)\n      throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * Public methods for use with Authentication Classes\n   *\n   * @param username a {@link java.lang.String} object.\n   * @return a {@link java.lang.String} object.\n   */\n  public String getPassword(String username) {\n    try {\n      return db.getJSONObject(PASSWORDS_TABLE).getString(username);\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n\n  private Set<String> getIdSet(UserId user, GroupId group, SecurityToken token)\n      throws JSONException {\n    String userId = user.getUserId(token);\n\n    if (group == null) {\n      return ImmutableSortedSet.of(userId);\n    }\n\n    Set<String> returnVal = Sets.newLinkedHashSet();\n    switch (group.getType()) {\n    case all:\n    case friends:\n      if (db.getJSONObject(FRIEND_LINK_TABLE).has(userId)) {\n        JSONArray friends = db.getJSONObject(FRIEND_LINK_TABLE).getJSONArray(userId);\n        for (int i = 0; i < friends.length(); i++) {\n          returnVal.add(friends.getString(i));\n        }\n      }\n      break;\n    case objectId:\n      if (db.getJSONObject(GROUP_MEMBERS_TABLE).has(group.toString())) {\n        JSONArray groupMembers = db.getJSONObject(GROUP_MEMBERS_TABLE).getJSONArray(group.toString());\n        for (int i = 0; i < groupMembers.length(); i++) {\n          returnVal.add(groupMembers.getString(i));\n        }\n      }\n      break;\n    case self:\n      returnVal.add(userId);\n      break;\n    }\n    return returnVal;\n  }\n\n  /**\n   * Get the set of user id's for a set of users and a group\n   *\n   * @param users set of UserIds\n   * @param group the group\n   * @param token a token\n   * @return set of Id strings\n   * @throws org.json.JSONException if errors in Json\n   */\n  public Set<String> getIdSet(Set<UserId> users, GroupId group, SecurityToken token)\n      throws JSONException {\n    Set<String> ids = Sets.newLinkedHashSet();\n    for (UserId user : users) {\n      ids.addAll(getIdSet(user, group, token));\n    }\n    return ids;\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Album> getAlbum(UserId userId, String appId, Set<String> fields,\n                                String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Search albums for given ID and owner\n        JSONObject album;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          album = userAlbums.getJSONObject(i);\n          if (album.getString(Album.Field.ID.toString()).equals(albumId) &&\n              album.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n            return Futures.immediateFuture(filterFields(album, fields, Album.class));\n          }\n        }\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(UserId userId, String appId,\n                                                    Set<String> fields, CollectionOptions options, Set<String> albumIds,\n                                                    SecurityToken token) throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Stores target albums\n        List<Album> result = Lists.newArrayList();\n\n        // Search for every albumId\n        boolean found;\n        JSONObject curAlbum;\n        for (String albumId : albumIds) {\n          // Search albums for this albumId\n          found = false;\n          for (int i = 0; i < userAlbums.length(); i++) {\n            curAlbum = userAlbums.getJSONObject(i);\n            if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId) &&\n                curAlbum.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n              result.add(filterFields(curAlbum, fields, Album.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - albumId not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n          }\n        }\n\n        // Return found albums\n        return Futures.immediateFuture(new RestfulCollection<Album>(result));\n      }\n\n      // Album table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User '\" + user + \"' has no albums\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(Set<UserId> userIds,\n                                                    GroupId groupId, String appId, Set<String> fields,\n                                                    CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Album> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather albums for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(ALBUMS_TABLE).has(id)) {\n          JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userAlbums.length(); i++) {\n            JSONObject album = userAlbums.getJSONObject(i);\n            if (album.getString(Album.Field.OWNER_ID.toString()).equals(id)) {\n              result.add(filterFields(album, fields, Album.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Album>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteAlbum(UserId userId, String appId, String albumId,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      boolean targetFound = false;      // indicates if target album is found\n      JSONArray newAlbums = new JSONArray();  // list of albums minus target\n      String user = userId.getUserId(token);  // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Compose new list of albums excluding album to be deleted\n        JSONObject curAlbum;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newAlbums.put(curAlbum);\n          }\n        }\n      }\n\n      // Overwrite user's albums with updated list if album found\n      if (targetFound) {\n        db.getJSONObject(ALBUMS_TABLE).put(user, newAlbums);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: userId and album's ownerId don't have to match - potential problem\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createAlbum(UserId userId, String appId, Album album,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      // Get table of user's albums\n      String user = userId.getUserId(token);\n      JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n      if (userAlbums == null) {\n        userAlbums = new JSONArray();\n        db.getJSONObject(ALBUMS_TABLE).put(user, userAlbums);\n      }\n\n      // Convert album to JSON and set ID & owner\n      JSONObject jsonAlbum = convertToJson(album);\n      if (!jsonAlbum.has(Album.Field.ID.toString())) {\n        jsonAlbum.put(Album.Field.ID.toString(), System.currentTimeMillis());\n      }\n      if (!jsonAlbum.has(Album.Field.OWNER_ID.toString())) {\n        jsonAlbum.put(Album.Field.OWNER_ID.toString(), user);\n      }\n\n      // Insert new album into table\n      userAlbums.put(jsonAlbum);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateAlbum(UserId userId, String appId, Album album,\n                                  String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Convert album to JSON and set ID\n        JSONObject jsonAlbum = convertToJson(album);\n        jsonAlbum.put(Album.Field.ID.toString(), albumId);\n\n        // Iterate through albums to identify album to update\n        for (int i = 0; i < userAlbums.length(); i++) {\n          JSONObject curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            userAlbums.put(i, jsonAlbum);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<MediaItem> getMediaItem(UserId userId, String appId,\n                                        String albumId, String mediaItemId, Set<String> fields,\n                                        SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Search user's MediaItems for given ID and album\n        JSONObject mediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          mediaItem = userMediaItems.getJSONObject(i);\n          if (mediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              mediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            return Futures.immediateFuture(filterFields(mediaItem, fields, MediaItem.class));\n          }\n        }\n      }\n\n      // MediaItem wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID '\" + mediaItemId + \"' does not exist within Album '\" + albumId + '\\'');\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> mediaItemIds,\n                                                            Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores found MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search for every MediaItem ID target\n        boolean found;\n        JSONObject curMediaItem;\n        for (String mediaItemId : mediaItemIds) {\n          // Search existing MediaItems for this MediaItem ID\n          found = false;\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            curMediaItem = userMediaItems.getJSONObject(i);\n            if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(albumId) &&\n                curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n              result.add(filterFields(curMediaItem, fields, MediaItem.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - MediaItem ID not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist within Album \" + albumId);\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem table not found for user \" + user);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> fields,\n                                                            CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores target MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search user's MediaItems for given album\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            result.add(filterFields(curMediaItem, fields, MediaItem.class));\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(\n      Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<MediaItem> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather MediaItems for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(MEDIAITEMS_TABLE).has(id)) {\n          JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            result.add(filterFields(userMediaItems.getJSONObject(i), fields, MediaItem.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      boolean targetFound = false;        // indicates if target MediaItem is found\n      JSONArray newMediaItems = new JSONArray();  // list of MediaItems minus target\n      String user = userId.getUserId(token);    // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Compose new list of MediaItems excluding item to be deleted\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newMediaItems.put(curMediaItem);\n          }\n        }\n      }\n\n      // Overwrite user's MediaItems with updated list if target found\n      if (targetFound) {\n        db.getJSONObject(MEDIAITEMS_TABLE).put(user, newMediaItems);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createMediaItem(UserId userId, String appId,\n                                      String albumId, MediaItem mediaItem, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Get table of user's MediaItems\n      JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(userId.getUserId(token));\n      if (userMediaItems == null) {\n        userMediaItems = new JSONArray();\n        db.getJSONObject(MEDIAITEMS_TABLE).put(userId.getUserId(token), userMediaItems);\n      }\n\n      // Convert MediaItem to JSON and set ID & Album ID\n      JSONObject jsonMediaItem = convertToJson(mediaItem);\n      jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n      if (!jsonMediaItem.has(MediaItem.Field.ID.toString())) {\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), System.currentTimeMillis());\n      }\n\n      // Insert new MediaItem into table\n      userMediaItems.put(jsonMediaItem);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, MediaItem mediaItem,\n                                      SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Convert MediaItem to JSON and set ID & Album ID\n        JSONObject jsonMediaItem = convertToJson(mediaItem);\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), mediaItemId);\n        jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n\n        // Iterate through MediaItems to identify item to update\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          JSONObject curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            userMediaItems.put(i, jsonMediaItem);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no MediaItem found with given ID and Album ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> updateActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        if (activityId != null) {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), activityId);\n        } else {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n        }\n      }\n      activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Find & replace activity\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          jsonArray.put(i, jsonEntry);\n          return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> createActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n      }\n      String activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Ensure activity does not already exist\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity already exists: \" + activityId);\n        }\n      }\n      jsonArray.put(jsonEntry);\n      return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivityEntries(UserId userId, GroupId groupId,\n      String appId, Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n\n        if (activityEntries != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (!activityIds.contains(activityEntry.getString(ActivityEntry.Field.ID.toString()))) {\n              newList.put(activityEntry);\n            }\n          }\n          db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(user, newList);\n        }\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> getActivityEntry(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, String activityId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for (int i = 0; i < activityEntries.length(); i++) {\n          JSONObject activityEntry = activityEntries.getJSONObject(i);\n          if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activityEntry, fields, ActivityEntry.class));\n          }\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n\n/** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      Set<UserId> userIds, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n      List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(id)) {\n          JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n            // TODO: ActivityStreams don't have appIds\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      UserId userId, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, Set<String> activityIds, SecurityToken token)\n      throws ProtocolException {\n    List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for(String activityId : activityIds) {\n          boolean found = false;\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n              result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND, \"Activity not found: \" + activityId);\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // TODO Why specifically handle Activity instead of generic POJO (below)?\n\n  private JSONObject convertFromActivity(Activity activity, Set<String> fields)\n      throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activity));\n  }\n\n  private JSONObject convertFromActivityEntry(ActivityEntry activityEntry, Set<String> fields) throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activityEntry));\n  }\n\n  private JSONObject convertToJson(Object object) throws JSONException {\n    // TODO not using fields yet\n    return new JSONObject(converter.convertToString(object));\n  }\n\n  public <T> T filterFields(JSONObject object, Set<String> fields,\n                            Class<T> clz) throws JSONException {\n    if (!fields.isEmpty()) {\n      // Create a copy with just the specified fields\n      object = new JSONObject(object, fields.toArray(new String[fields\n          .size()]));\n    }\n    String objectVal = object.toString();\n    if (authority != null) {\n      objectVal = objectVal.replace(\"%origin%\", authority.getOrigin());\n    } else {\n      //provide default for junit tests\n      objectVal = objectVal.replace(\"%origin%\", \"http://localhost:8080\");\n    }\n    return converter.convertToObject(objectVal, clz);\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.social.sample.spi;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Future;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.AnonymousSecurityToken;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.protocol.DataCollection;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.RestfulCollection;\nimport org.apache.shindig.protocol.conversion.BeanConverter;\nimport org.apache.shindig.protocol.model.SortOrder;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.opensocial.model.Activity;\nimport org.apache.shindig.social.opensocial.model.ActivityEntry;\nimport org.apache.shindig.social.opensocial.model.Album;\nimport org.apache.shindig.social.opensocial.model.Group;\nimport org.apache.shindig.social.opensocial.model.MediaItem;\nimport org.apache.shindig.social.opensocial.model.Message;\nimport org.apache.shindig.social.opensocial.model.MessageCollection;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.spi.ActivityService;\nimport org.apache.shindig.social.opensocial.spi.ActivityStreamService;\nimport org.apache.shindig.social.opensocial.spi.AlbumService;\nimport org.apache.shindig.social.opensocial.spi.AppDataService;\nimport org.apache.shindig.social.opensocial.spi.CollectionOptions;\nimport org.apache.shindig.social.opensocial.spi.GroupId;\nimport org.apache.shindig.social.opensocial.spi.GroupService;\nimport org.apache.shindig.social.opensocial.spi.MediaItemService;\nimport org.apache.shindig.social.opensocial.spi.MessageService;\nimport org.apache.shindig.social.opensocial.spi.PersonService;\nimport org.apache.shindig.social.opensocial.spi.UserId;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\n\n/**\n * Implementation of supported services backed by a JSON DB.\n */\n@Singleton\npublic class JsonDbOpensocialService implements ActivityService, PersonService, AppDataService,\n    MessageService, AlbumService, MediaItemService, ActivityStreamService, GroupService {\n\n  private static final Comparator<Person> NAME_COMPARATOR = new Comparator<Person>() {\n    public int compare(Person person, Person person1) {\n      String name = person.getName().getFormatted();\n      String name1 = person1.getName().getFormatted();\n      return name.compareTo(name1);\n    }\n  };\n\n  /**\n   * The DB\n   */\n  private JSONObject db;\n\n  /**\n   * The JSON<->Bean converter\n   */\n  private BeanConverter converter;\n\n  /**\n   * db[\"people\"] -> Array<Person>\n   */\n  private static final String PEOPLE_TABLE = \"people\";\n\n  /**\n   * db[\"groups\"] -> Array<Group>\n   */\n  private static final String GROUPS_TABLE = \"groups\";\n\n  /**\n   * db[\"groupMembers\"] -> Array<Person>\n   */\n  private static final String GROUP_MEMBERS_TABLE = \"groupMembers\";\n\n  /**\n   * db[\"activities\"] -> Map<Person.Id, Array<Activity>>\n   */\n  private static final String ACTIVITIES_TABLE = \"activities\";\n\n  /**\n   * db[\"albums\"] -> Map<Person.Id, Array<Album>>\n   */\n  private static final String ALBUMS_TABLE = \"albums\";\n\n  /**\n   * db[\"mediaItems\"] -> Map<Person.Id, Array<MediaItem>>\n   */\n  private static final String MEDIAITEMS_TABLE = \"mediaItems\";\n\n  /**\n   * db[\"data\"] -> Map<Person.Id, Map<String, String>>\n   */\n  private static final String DATA_TABLE = \"data\";\n\n  /**\n   * db[\"friendLinks\"] -> Map<Person.Id, Array<Person.Id>>\n   */\n  private static final String FRIEND_LINK_TABLE = \"friendLinks\";\n\n  /**\n   * db[\"messages\"] -> Map<Person.Id, Array<Message>>\n   */\n  private static final String MESSAGE_TABLE = \"messages\";\n\n  /**\n   * db[\"passwords\"] -> Map<Person.Id, String>\n   */\n  private static final String PASSWORDS_TABLE = \"passwords\";\n\n  /**\n   * db[\"activityEntries\"] -> Map<Person.Id, Array<ActivityEntry>>\n   */\n  private static final String ACTIVITYSTREAMS_TABLE = \"activityEntries\";\n\n  /**\n   * Anonymous name.\n   */\n  private static final String ANONYMOUS_NAME = \"Anonymous\";\n\n  private Authority authority;\n\n  /**\n   * Initializes the JsonDbOpensocialService using Guice\n   *\n   * @param jsonLocation location of the json data provided by the shindig.canonical.json.db parameter\n   * @param converter an injected BeanConverter\n   * @throws java.lang.Exception if any\n   */\n  @Inject\n  public JsonDbOpensocialService(@Named(\"shindig.canonical.json.db\")\n  String jsonLocation, @Named(\"shindig.bean.converter.json\")\n  BeanConverter converter,\n  @Named(\"shindig.contextroot\") String contextroot) throws Exception {\n    String content = IOUtils.toString(ResourceLoader.openResource(jsonLocation), \"UTF-8\");\n    this.db = new JSONObject(content.replace(\"%contextroot%\", contextroot));\n    this.converter = converter;\n  }\n\n  /**\n   * Allows access to the underlying json db.\n   *\n   * @return a reference to the json db\n   */\n  public JSONObject getDb() {\n    return db;\n  }\n\n   /**\n   * override the json database\n   * @param db a {@link org.json.JSONObject}.\n   */\n  public void setDb(JSONObject db) {\n    this.db = db;\n  }\n\n  @Inject(optional = true)\n  public void setAuthority(Authority authority) {\n    this.authority = authority;\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(Set<UserId> userIds, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITIES_TABLE).has(id)) {\n          JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(id);\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (appId == null || !activity.has(Activity.Field.APP_ID.toString())) {\n              result.add(filterFields(activity, fields, Activity.class));\n            } else if (activity.get(Activity.Field.APP_ID.toString()).equals(appId)) {\n              result.add(filterFields(activity, fields, Activity.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, Set<String> activityIds,\n      SecurityToken token) throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n            result.add(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Activity> getActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activity.get(Activity.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivities(UserId userId, GroupId groupId, String appId,\n      Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        if (activities != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (!activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n              newList.put(activity);\n            }\n          }\n          db.getJSONObject(ACTIVITIES_TABLE).put(user, newList);\n          // TODO. This seems very odd that we return no useful response in this\n          // case\n          // There is no way to represent not-found\n          // if (found) { ??\n          // }\n        }\n      }\n      // What is the appropriate response here??\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> createActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Activity activity, SecurityToken token) throws ProtocolException {\n    // Are fields really needed here?\n    try {\n      JSONObject jsonObject = convertFromActivity(activity, fields);\n      if (!jsonObject.has(Activity.Field.ID.toString())) {\n        jsonObject.put(Activity.Field.ID.toString(), System.currentTimeMillis());\n      }\n      JSONArray jsonArray = db.getJSONObject(ACTIVITIES_TABLE)\n          .getJSONArray(userId.getUserId(token));\n      if (jsonArray == null) {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITIES_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      // TODO (woodser): if used with PUT, duplicate activity would be created?\n      jsonArray.put(jsonObject);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Person>> getPeople(Set<UserId> userIds, GroupId groupId,\n      CollectionOptions options, Set<String> fields, SecurityToken token) throws ProtocolException {\n    List<Person> result = Lists.newArrayList();\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (!idSet.contains(person.get(Person.Field.ID.toString()))) {\n          continue;\n        }\n\n        // Add group support later\n        Person personObj = filterFields(person, fields, Person.class);\n        Map<String, Object> appData = getPersonAppData(\n            person.getString(Person.Field.ID.toString()), fields);\n        personObj.setAppData(appData);\n\n        result.add(personObj);\n      }\n\n      if (GroupId.Type.self == groupId.getType() && result.isEmpty()) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"People '\" + idSet + \"' not found\");\n      }\n\n      // We can pretend that by default the people are in top friends order\n      if (options.getSortBy().equals(Person.Field.NAME.toString())) {\n        Collections.sort(result, NAME_COMPARATOR);\n\n        if (options.getSortOrder() == SortOrder.descending) {\n          Collections.reverse(result);\n        }\n      }\n\n      // TODO: The samplecontainer doesn't really have the concept of HAS_APP so\n      // we can't support any filters yet. We should fix this.\n\n      int totalSize = result.size();\n      int last = options.getFirst() + options.getMax();\n      result = result.subList(options.getFirst(), Math.min(last, totalSize));\n\n      return Futures.immediateFuture(new RestfulCollection<Person>(result, options.getFirst(), totalSize, options.getMax()));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)\n      throws ProtocolException {\n    if (id != null && AnonymousSecurityToken.ANONYMOUS_ID.equals(id.getUserId())) {\n      Person anonymous = new PersonImpl();\n      anonymous.setId(AnonymousSecurityToken.ANONYMOUS_ID);\n      anonymous.setName(new NameImpl(ANONYMOUS_NAME));\n      anonymous.setNickname(ANONYMOUS_NAME);\n      return Futures.immediateFuture(anonymous);\n    }\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (id != null && person.get(Person.Field.ID.toString()).equals(id.getUserId(token))) {\n          Person personObj = filterFields(person, fields, Person.class);\n          Map<String, Object> appData = getPersonAppData(person.getString(Person.Field.ID\n              .toString()), fields);\n          personObj.setAppData(appData);\n\n          return Futures.immediateFuture(personObj);\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Person '\" + id.getUserId(token) + \"' not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> updatePerson(UserId id, Person person, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String viewer = token.getViewerId(); // viewer\n      String user = id.getUserId(token); // person to update\n\n      if (!viewerCanUpdatePerson(viewer,user)) {\n        throw new ProtocolException(HttpServletResponse.SC_FORBIDDEN, \"User '\" + viewer + \"' does not have enough privileges to update person '\"+user+\"'\");\n      }\n\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject curPerson = people.getJSONObject(i);\n\n        if (user != null && curPerson.getString(Person.Field.ID.toString()).equals(user)) {\n          // Convert user to JSON and set ID\n          JSONObject jsonPerson = convertToJson(person);\n          // go through all properties to update in the submitted person object\n          // and change them in the current person object\n          for (String key : JSONObject.getNames(jsonPerson)) {\n            curPerson.put(key,jsonPerson.get(key));\n          }\n\n          people.put(i,curPerson);\n          return Futures.immediateFuture(converter.convertToObject(curPerson.toString(), Person.class));\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User ID \" + user + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n\n  }\n\n  /** Check if a viewer is allowed to update the given person record. **/\n  protected boolean viewerCanUpdatePerson(String viewer, String person) {\n    // A person can only update his own personal data (by default)\n    // if you wish to allow other people to update the personal data of the user\n    // you should change the current function\n    return viewer.equals(person) ? true : false;\n  }\n\n  private Map<String, Object> getPersonAppData(String id, Set<String> fields) {\n    try {\n      Map<String, Object> appData = null;\n      JSONObject personData = db.getJSONObject(DATA_TABLE).optJSONObject(id);\n      if (personData != null) {\n        if (fields.contains(Person.Field.APP_DATA.toString())) {\n          appData = Maps.newHashMap();\n          @SuppressWarnings(\"unchecked\")\n          Iterator<String> keys = personData.keys();\n          while (keys.hasNext()) {\n            String key = keys.next();\n            appData.put(key, personData.get(key));\n          }\n        } else {\n          String appDataPrefix = Person.Field.APP_DATA.toString() + '.';\n          for (String field : fields) {\n            if (field.startsWith(appDataPrefix)) {\n              if (appData == null) {\n                appData = Maps.newHashMap();\n              }\n\n              String appDataField = field.substring(appDataPrefix.length());\n              if (personData.has(appDataField)) {\n                appData.put(appDataField, personData.get(appDataField));\n              }\n            }\n          }\n        }\n      }\n\n      return appData;\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      Map<String, Map<String, Object>> idToData = Maps.newHashMap();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        JSONObject personData;\n        if (!db.getJSONObject(DATA_TABLE).has(id)) {\n          personData = new JSONObject();\n        } else {\n          if (!fields.isEmpty()) {\n            personData = new JSONObject(db.getJSONObject(DATA_TABLE).getJSONObject(id), fields\n                .toArray(new String[fields.size()]));\n          } else {\n            personData = db.getJSONObject(DATA_TABLE).getJSONObject(id);\n          }\n        }\n\n        // TODO: We can use the converter here to do this for us\n\n        // JSONObject keys are always strings\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = personData.keys();\n        Map<String, Object> data = Maps.newHashMap();\n        while (keys.hasNext()) {\n          String key = keys.next();\n          data.put(key, personData.getString(key));\n        }\n        idToData.put(id, data);\n      }\n      return Futures.immediateFuture(new DataCollection(idToData));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (!db.getJSONObject(DATA_TABLE).has(user)) {\n        return null;\n      }\n      JSONObject newPersonData = new JSONObject();\n      JSONObject oldPersonData = db.getJSONObject(DATA_TABLE).getJSONObject(user);\n\n      // JSONObject keys are always strings\n      @SuppressWarnings(\"unchecked\")\n      Iterator<String> keys = oldPersonData.keys();\n      while (keys.hasNext()) {\n        String key = keys.next();\n        if (!fields.contains(key)) {\n          newPersonData.put(key, oldPersonData.getString(key));\n        }\n      }\n      db.getJSONObject(DATA_TABLE).put(user, newPersonData);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Map<String, Object> values, SecurityToken token)\n      throws ProtocolException {\n    // TODO: this seems redundant. No need to pass both fields and a map of\n    // field->value\n    // TODO: According to rest, yes there is. If a field is in the param list\n    // but not in the map\n    // that means it is a delete\n\n    try {\n      JSONObject personData = db.getJSONObject(DATA_TABLE).getJSONObject(userId.getUserId(token));\n      if (personData == null) {\n        personData = new JSONObject();\n        db.getJSONObject(DATA_TABLE).put(userId.getUserId(token), personData);\n      }\n\n      for (Map.Entry<String, Object> entry : values.entrySet()) {\n        personData.put(entry.getKey(), entry.getValue());\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Group>> getGroups(UserId userId,\n\t\tCollectionOptions options, Set<String> fields, SecurityToken token)\n\t\tthrows ProtocolException {\n    List<Group> result = Lists.newArrayList();\n    String user = userId.getUserId(token);\n    try {\n      JSONArray groups = db.getJSONObject(GROUPS_TABLE).getJSONArray(user);\n\n      for (int i = 0; i < groups.length(); i++) {\n        JSONObject group = groups.getJSONObject(i);\n\n        Group groupObj = filterFields(group, fields, Group.class);\n        result.add(groupObj);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n\n    return Futures.immediateFuture(new RestfulCollection<Group>(result));\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Post a message for a set of users.\n   */\n  public Future<Void> createMessage(UserId userId, String appId, String msgCollId, Message message,\n      SecurityToken token) throws ProtocolException {\n    for (String recipient : message.getRecipients()) {\n      try {\n        JSONArray outbox = db.getJSONObject(MESSAGE_TABLE).getJSONArray(recipient);\n        if (outbox == null) {\n          outbox = new JSONArray();\n          db.getJSONObject(MESSAGE_TABLE).put(recipient, outbox);\n        }\n\n        outbox.put(message);\n      } catch (JSONException je) {\n        throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n            je);\n      }\n    }\n\n    return Futures.immediateFuture(null);\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MessageCollection>> getMessageCollections(UserId userId,\n      Set<String> fields, CollectionOptions options, SecurityToken token) throws ProtocolException {\n    try {\n      List<MessageCollection> result = Lists.newArrayList();\n      JSONObject messageCollections = db.getJSONObject(MESSAGE_TABLE).getJSONObject(\n          userId.getUserId(token));\n      for (String msgCollId : JSONObject.getNames(messageCollections)) {\n        JSONObject msgColl = messageCollections.getJSONObject(msgCollId);\n        msgColl.put(\"id\", msgCollId);\n        JSONArray messages = msgColl.getJSONArray(\"messages\");\n        int numMessages = (messages == null) ? 0 : messages.length();\n        msgColl.put(\"total\", String.valueOf(numMessages));\n        msgColl.put(\"unread\", String.valueOf(numMessages));\n\n        result.add(filterFields(msgColl, fields, MessageCollection.class));\n      }\n      return Futures.immediateFuture(new RestfulCollection<MessageCollection>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessages(UserId userId, String msgCollId, List<String> ids,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Gets the messsages in an user's queue.\n   */\n  public Future<RestfulCollection<Message>> getMessages(UserId userId, String msgCollId,\n      Set<String> fields, List<String> msgIds, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Message> result = Lists.newArrayList();\n      JSONArray messages = db.getJSONObject(MESSAGE_TABLE).getJSONObject(userId.getUserId(token))\n          .getJSONObject(msgCollId).getJSONArray(\"messages\");\n\n      // TODO: special case @all\n\n      if (messages == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"message collection\"\n            + msgCollId + \" not found\");\n      }\n\n      // TODO: filter and sort outbox.\n      for (int i = 0; i < messages.length(); i++) {\n        JSONObject msg = messages.getJSONObject(i);\n        Message message = filterFields(msg, fields, Message.class);\n        if (msgIds.isEmpty() || msgIds.contains(message.getId())) {\n          result.add(message);\n        }\n      }\n\n      return Futures.immediateFuture(new RestfulCollection<Message>(result));\n\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<MessageCollection> createMessageCollection(UserId userId,\n      MessageCollection msgCollection, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessage(UserId userId, String msgCollId, String messageId,\n      Message message, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessageCollection(UserId userId, MessageCollection msgCollection,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessageCollection(UserId userId, String msgCollId, SecurityToken token)\n      throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * Public methods for use with Authentication Classes\n   *\n   * @param username a {@link java.lang.String} object.\n   * @return a {@link java.lang.String} object.\n   */\n  public String getPassword(String username) {\n    try {\n      return db.getJSONObject(PASSWORDS_TABLE).getString(username);\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n\n  private Set<String> getIdSet(UserId user, GroupId group, SecurityToken token)\n      throws JSONException {\n    String userId = user.getUserId(token);\n\n    if (group == null) {\n      return ImmutableSortedSet.of(userId);\n    }\n\n    Set<String> returnVal = Sets.newLinkedHashSet();\n    switch (group.getType()) {\n    case all:\n    case friends:\n      if (db.getJSONObject(FRIEND_LINK_TABLE).has(userId)) {\n        JSONArray friends = db.getJSONObject(FRIEND_LINK_TABLE).getJSONArray(userId);\n        for (int i = 0; i < friends.length(); i++) {\n          returnVal.add(friends.getString(i));\n        }\n      }\n      break;\n    case objectId:\n      if (db.getJSONObject(GROUP_MEMBERS_TABLE).has(group.toString())) {\n        JSONArray groupMembers = db.getJSONObject(GROUP_MEMBERS_TABLE).getJSONArray(group.toString());\n        for (int i = 0; i < groupMembers.length(); i++) {\n          returnVal.add(groupMembers.getString(i));\n        }\n      }\n      break;\n    case self:\n      returnVal.add(userId);\n      break;\n    }\n    return returnVal;\n  }\n\n  /**\n   * Get the set of user id's for a set of users and a group\n   *\n   * @param users set of UserIds\n   * @param group the group\n   * @param token a token\n   * @return set of Id strings\n   * @throws org.json.JSONException if errors in Json\n   */\n  public Set<String> getIdSet(Set<UserId> users, GroupId group, SecurityToken token)\n      throws JSONException {\n    Set<String> ids = Sets.newLinkedHashSet();\n    for (UserId user : users) {\n      ids.addAll(getIdSet(user, group, token));\n    }\n    return ids;\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Album> getAlbum(UserId userId, String appId, Set<String> fields,\n                                String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Search albums for given ID and owner\n        JSONObject album;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          album = userAlbums.getJSONObject(i);\n          if (album.getString(Album.Field.ID.toString()).equals(albumId) &&\n              album.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n            return Futures.immediateFuture(filterFields(album, fields, Album.class));\n          }\n        }\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(UserId userId, String appId,\n                                                    Set<String> fields, CollectionOptions options, Set<String> albumIds,\n                                                    SecurityToken token) throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Stores target albums\n        List<Album> result = Lists.newArrayList();\n\n        // Search for every albumId\n        boolean found;\n        JSONObject curAlbum;\n        for (String albumId : albumIds) {\n          // Search albums for this albumId\n          found = false;\n          for (int i = 0; i < userAlbums.length(); i++) {\n            curAlbum = userAlbums.getJSONObject(i);\n            if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId) &&\n                curAlbum.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n              result.add(filterFields(curAlbum, fields, Album.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - albumId not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n          }\n        }\n\n        // Return found albums\n        return Futures.immediateFuture(new RestfulCollection<Album>(result));\n      }\n\n      // Album table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User '\" + user + \"' has no albums\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(Set<UserId> userIds,\n                                                    GroupId groupId, String appId, Set<String> fields,\n                                                    CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Album> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather albums for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(ALBUMS_TABLE).has(id)) {\n          JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userAlbums.length(); i++) {\n            JSONObject album = userAlbums.getJSONObject(i);\n            if (album.getString(Album.Field.OWNER_ID.toString()).equals(id)) {\n              result.add(filterFields(album, fields, Album.class));\n            }\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<Album>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteAlbum(UserId userId, String appId, String albumId,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      boolean targetFound = false;      // indicates if target album is found\n      JSONArray newAlbums = new JSONArray();  // list of albums minus target\n      String user = userId.getUserId(token);  // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Compose new list of albums excluding album to be deleted\n        JSONObject curAlbum;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newAlbums.put(curAlbum);\n          }\n        }\n      }\n\n      // Overwrite user's albums with updated list if album found\n      if (targetFound) {\n        db.getJSONObject(ALBUMS_TABLE).put(user, newAlbums);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: userId and album's ownerId don't have to match - potential problem\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createAlbum(UserId userId, String appId, Album album,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      // Get table of user's albums\n      String user = userId.getUserId(token);\n      JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n      if (userAlbums == null) {\n        userAlbums = new JSONArray();\n        db.getJSONObject(ALBUMS_TABLE).put(user, userAlbums);\n      }\n\n      // Convert album to JSON and set ID & owner\n      JSONObject jsonAlbum = convertToJson(album);\n      if (!jsonAlbum.has(Album.Field.ID.toString())) {\n        jsonAlbum.put(Album.Field.ID.toString(), System.currentTimeMillis());\n      }\n      if (!jsonAlbum.has(Album.Field.OWNER_ID.toString())) {\n        jsonAlbum.put(Album.Field.OWNER_ID.toString(), user);\n      }\n\n      // Insert new album into table\n      userAlbums.put(jsonAlbum);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateAlbum(UserId userId, String appId, Album album,\n                                  String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Convert album to JSON and set ID\n        JSONObject jsonAlbum = convertToJson(album);\n        jsonAlbum.put(Album.Field.ID.toString(), albumId);\n\n        // Iterate through albums to identify album to update\n        for (int i = 0; i < userAlbums.length(); i++) {\n          JSONObject curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            userAlbums.put(i, jsonAlbum);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<MediaItem> getMediaItem(UserId userId, String appId,\n                                        String albumId, String mediaItemId, Set<String> fields,\n                                        SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Search user's MediaItems for given ID and album\n        JSONObject mediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          mediaItem = userMediaItems.getJSONObject(i);\n          if (mediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              mediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            return Futures.immediateFuture(filterFields(mediaItem, fields, MediaItem.class));\n          }\n        }\n      }\n\n      // MediaItem wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID '\" + mediaItemId + \"' does not exist within Album '\" + albumId + '\\'');\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> mediaItemIds,\n                                                            Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores found MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search for every MediaItem ID target\n        boolean found;\n        JSONObject curMediaItem;\n        for (String mediaItemId : mediaItemIds) {\n          // Search existing MediaItems for this MediaItem ID\n          found = false;\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            curMediaItem = userMediaItems.getJSONObject(i);\n            if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(albumId) &&\n                curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n              result.add(filterFields(curMediaItem, fields, MediaItem.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - MediaItem ID not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist within Album \" + albumId);\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem table not found for user \" + user);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> fields,\n                                                            CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores target MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search user's MediaItems for given album\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            result.add(filterFields(curMediaItem, fields, MediaItem.class));\n          }\n        }\n\n        // Return found MediaItems\n        return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(\n      Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<MediaItem> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather MediaItems for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(MEDIAITEMS_TABLE).has(id)) {\n          JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            result.add(filterFields(userMediaItems.getJSONObject(i), fields, MediaItem.class));\n          }\n        }\n      }\n      return Futures.immediateFuture(new RestfulCollection<MediaItem>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      boolean targetFound = false;        // indicates if target MediaItem is found\n      JSONArray newMediaItems = new JSONArray();  // list of MediaItems minus target\n      String user = userId.getUserId(token);    // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Compose new list of MediaItems excluding item to be deleted\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newMediaItems.put(curMediaItem);\n          }\n        }\n      }\n\n      // Overwrite user's MediaItems with updated list if target found\n      if (targetFound) {\n        db.getJSONObject(MEDIAITEMS_TABLE).put(user, newMediaItems);\n        return Futures.immediateFuture(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createMediaItem(UserId userId, String appId,\n                                      String albumId, MediaItem mediaItem, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Get table of user's MediaItems\n      JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(userId.getUserId(token));\n      if (userMediaItems == null) {\n        userMediaItems = new JSONArray();\n        db.getJSONObject(MEDIAITEMS_TABLE).put(userId.getUserId(token), userMediaItems);\n      }\n\n      // Convert MediaItem to JSON and set ID & Album ID\n      JSONObject jsonMediaItem = convertToJson(mediaItem);\n      jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n      if (!jsonMediaItem.has(MediaItem.Field.ID.toString())) {\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), System.currentTimeMillis());\n      }\n\n      // Insert new MediaItem into table\n      userMediaItems.put(jsonMediaItem);\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, MediaItem mediaItem,\n                                      SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Convert MediaItem to JSON and set ID & Album ID\n        JSONObject jsonMediaItem = convertToJson(mediaItem);\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), mediaItemId);\n        jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n\n        // Iterate through MediaItems to identify item to update\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          JSONObject curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            userMediaItems.put(i, jsonMediaItem);\n            return Futures.immediateFuture(null);\n          }\n        }\n      }\n\n      // Error - no MediaItem found with given ID and Album ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> updateActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        if (activityId != null) {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), activityId);\n        } else {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n        }\n      }\n      activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Find & replace activity\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          jsonArray.put(i, jsonEntry);\n          return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> createActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n      }\n      String activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n\n      // Ensure activity does not already exist\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity already exists: \" + activityId);\n        }\n      }\n      jsonArray.put(jsonEntry);\n      return Futures.immediateFuture(filterFields(jsonEntry, fields, ActivityEntry.class));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivityEntries(UserId userId, GroupId groupId,\n      String appId, Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n\n        if (activityEntries != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (!activityIds.contains(activityEntry.getString(ActivityEntry.Field.ID.toString()))) {\n              newList.put(activityEntry);\n            }\n          }\n          db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(user, newList);\n        }\n      }\n      return Futures.immediateFuture(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> getActivityEntry(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, String activityId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for (int i = 0; i < activityEntries.length(); i++) {\n          JSONObject activityEntry = activityEntries.getJSONObject(i);\n          if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n            return Futures.immediateFuture(filterFields(activityEntry, fields, ActivityEntry.class));\n          }\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n\n/** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      Set<UserId> userIds, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n      List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(id)) {\n          JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n            // TODO: ActivityStreams don't have appIds\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      UserId userId, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, Set<String> activityIds, SecurityToken token)\n      throws ProtocolException {\n    List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for(String activityId : activityIds) {\n          boolean found = false;\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n              result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND, \"Activity not found: \" + activityId);\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return Futures.immediateFuture(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // TODO Why specifically handle Activity instead of generic POJO (below)?\n\n  private JSONObject convertFromActivity(Activity activity, Set<String> fields)\n      throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activity));\n  }\n\n  private JSONObject convertFromActivityEntry(ActivityEntry activityEntry, Set<String> fields) throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activityEntry));\n  }\n\n  private JSONObject convertToJson(Object object) throws JSONException {\n    // TODO not using fields yet\n    return new JSONObject(converter.convertToString(object));\n  }\n\n  public <T> T filterFields(JSONObject object, Set<String> fields,\n                            Class<T> clz) throws JSONException {\n    if (!fields.isEmpty()) {\n      // Create a copy with just the specified fields\n      object = new JSONObject(object, fields.toArray(new String[fields\n          .size()]));\n    }\n    String objectVal = object.toString();\n    if (authority != null) {\n      objectVal = objectVal.replace(\"%origin%\", authority.getOrigin());\n    } else {\n      //provide default for junit tests\n      objectVal = objectVal.replace(\"%origin%\", \"http://localhost:8080\");\n    }\n    return converter.convertToObject(objectVal, clz);\n  }\n}\n","lineNo":691}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.render;\n\nimport org.apache.shindig.common.logging.i18n.MessageKeys;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.config.ContainerConfig;\nimport org.apache.shindig.gadgets.Gadget;\nimport org.apache.shindig.gadgets.GadgetContext;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.LockedDomainService;\nimport org.apache.shindig.gadgets.process.ProcessingException;\nimport org.apache.shindig.gadgets.process.Processor;\nimport org.apache.shindig.gadgets.spec.View;\n\nimport com.google.inject.Inject;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\n/**\n * Validates a rendering request parameters before calling an appropriate renderer.\n */\npublic class Renderer {\n  //class name for logging purpose\n  private static final String classname = Renderer.class.getName();\n  private static final Logger LOG = Logger.getLogger(classname,MessageKeys.MESSAGES);\n\n  private final Processor processor;\n  private final HtmlRenderer renderer;\n  private final ContainerConfig containerConfig;\n  private final LockedDomainService lockedDomainService;\n\n  @Inject\n  public Renderer(Processor processor,\n                  HtmlRenderer renderer,\n                  ContainerConfig containerConfig,\n                  LockedDomainService lockedDomainService) {\n    this.processor = processor;\n    this.renderer = renderer;\n    this.containerConfig = containerConfig;\n    this.lockedDomainService = lockedDomainService;\n  }\n\n  /**\n   * Attempts to render the requested gadget.\n   *\n   * @return The results of the rendering attempt.\n   *\n   * TODO: Localize error messages.\n   */\n  public RenderingResults render(GadgetContext context) {\n    if (!validateParent(context)) {\n      return RenderingResults.error(\"Unsupported parent parameter. Check your container code.\",\n          HttpServletResponse.SC_BAD_REQUEST);\n    }\n\n    try {\n      Gadget gadget = processor.process(context);\n\n      if (gadget.getCurrentView() == null) {\n        return RenderingResults.error(\"Unable to locate an appropriate view in this gadget. \" +\n            \"Requested: '\" + gadget.getContext().getView() +\n            \"' Available: \" + gadget.getSpec().getViews().keySet(), HttpServletResponse.SC_NOT_FOUND);\n      }\n\n      if (gadget.getCurrentView().getType() == View.ContentType.URL) {\n        if (gadget.requiresCaja()) {\n          return RenderingResults.error(\"Caja does not support url type gadgets.\",\n            HttpServletResponse.SC_BAD_REQUEST);\n        } else if (gadget.sanitizeOutput()) {\n          return RenderingResults.error(\"Type=url gadgets cannot be sanitized.\",\n            HttpServletResponse.SC_BAD_REQUEST);\n        }\n        return RenderingResults.mustRedirect(gadget.getCurrentView().getHref());\n      }\n\n      if (!lockedDomainService.isGadgetValidForHost(context.getHost(), gadget, context.getContainer())) {\n        return RenderingResults.error(\"Invalid domain\", HttpServletResponse.SC_BAD_REQUEST);\n      }\n\n      return RenderingResults.ok(renderer.render(gadget));\n    } catch (RenderingException e) {\n      return logError(\"render\", context.getUrl(), e.getHttpStatusCode(), e);\n    } catch (ProcessingException e) {\n      return logError(\"render\", context.getUrl(), e.getHttpStatusCode(), e);\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof GadgetException) {\n        return logError(\"render\", context.getUrl(), ((GadgetException)e.getCause()).getHttpStatusCode(),\n            e.getCause());\n      }\n      throw e;\n    }\n  }\n\n  private RenderingResults logError(String methodname, Uri gadgetUrl, int statusCode, Throwable t) {\n    if (LOG.isLoggable(Level.INFO)) {\n      LOG.logp(Level.INFO, classname, methodname, MessageKeys.FAILED_TO_RENDER, new Object[] {gadgetUrl,t.getMessage()});\n    }\n    return RenderingResults.error(t.getMessage(), statusCode);\n  }\n\n  /**\n   * Validates that the parent parameter was acceptable.\n   *\n   * @return True if the parent parameter is valid for the current container.\n   */\n  private boolean validateParent(GadgetContext context) {\n    String container = context.getContainer();\n    String parent = context.getParameter(\"parent\");\n\n    if (parent == null) {\n      // If there is no parent parameter, we are still safe because no\n      // dependent code ever has to trust it anyway.\n      return true;\n    }\n\n    List<Object> parents = containerConfig.getList(container, \"gadgets.parent\");\n    if (parents.isEmpty()) {\n      // Allow all.\n      return true;\n    }\n\n    // We need to check each possible parent parameter against this regex.\n    for (Object pattern : parents) {\n      if (Pattern.matches(pattern.toString(), parent)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.render;\n\nimport org.apache.shindig.common.logging.i18n.MessageKeys;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.config.ContainerConfig;\nimport org.apache.shindig.gadgets.Gadget;\nimport org.apache.shindig.gadgets.GadgetContext;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.LockedDomainService;\nimport org.apache.shindig.gadgets.process.ProcessingException;\nimport org.apache.shindig.gadgets.process.Processor;\nimport org.apache.shindig.gadgets.spec.GadgetSpec;\nimport org.apache.shindig.gadgets.spec.View;\n\nimport com.google.inject.Inject;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\n/**\n * Validates a rendering request parameters before calling an appropriate renderer.\n */\npublic class Renderer {\n  //class name for logging purpose\n  private static final String classname = Renderer.class.getName();\n  private static final Logger LOG = Logger.getLogger(classname,MessageKeys.MESSAGES);\n\n  private final Processor processor;\n  private final HtmlRenderer renderer;\n  private final ContainerConfig containerConfig;\n  private final LockedDomainService lockedDomainService;\n\n  @Inject\n  public Renderer(Processor processor,\n                  HtmlRenderer renderer,\n                  ContainerConfig containerConfig,\n                  LockedDomainService lockedDomainService) {\n    this.processor = processor;\n    this.renderer = renderer;\n    this.containerConfig = containerConfig;\n    this.lockedDomainService = lockedDomainService;\n  }\n\n  /**\n   * Attempts to render the requested gadget.\n   *\n   * @return The results of the rendering attempt.\n   *\n   * TODO: Localize error messages.\n   */\n  public RenderingResults render(GadgetContext context) {\n    if (!validateParent(context)) {\n      return RenderingResults.error(\"Unsupported parent parameter. Check your container code.\",\n          HttpServletResponse.SC_BAD_REQUEST);\n    }\n\n    try {\n      Gadget gadget = processor.process(context);\n\n      GadgetSpec gadgetSpec = gadget.getSpec();\n      if (gadget.getCurrentView() == null) {\n        return RenderingResults.error(\"Unable to locate an appropriate view in this gadget. \" +\n            \"Requested: '\" + gadget.getContext().getView() +\n            \"' Available: \" + gadgetSpec.getViews().keySet(), HttpServletResponse.SC_NOT_FOUND);\n      }\n\n      if (gadget.getCurrentView().getType() == View.ContentType.URL) {\n        if (gadget.requiresCaja()) {\n          return RenderingResults.error(\"Caja does not support url type gadgets.\",\n            HttpServletResponse.SC_BAD_REQUEST);\n        } else if (gadget.sanitizeOutput()) {\n          return RenderingResults.error(\"Type=url gadgets cannot be sanitized.\",\n            HttpServletResponse.SC_BAD_REQUEST);\n        }\n        return RenderingResults.mustRedirect(gadget.getCurrentView().getHref());\n      }\n\n      if (!lockedDomainService.isGadgetValidForHost(context.getHost(), gadget, context.getContainer())) {\n        return RenderingResults.error(\"Invalid domain for host (\" + context.getHost()\n                + \") and gadget (\" + gadgetSpec.getUrl() + \")\",\n                HttpServletResponse.SC_BAD_REQUEST);\n      }\n\n      return RenderingResults.ok(renderer.render(gadget));\n    } catch (RenderingException e) {\n      return logError(\"render\", context.getUrl(), e.getHttpStatusCode(), e);\n    } catch (ProcessingException e) {\n      return logError(\"render\", context.getUrl(), e.getHttpStatusCode(), e);\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof GadgetException) {\n        return logError(\"render\", context.getUrl(), ((GadgetException)e.getCause()).getHttpStatusCode(),\n            e.getCause());\n      }\n      throw e;\n    }\n  }\n\n  private RenderingResults logError(String methodname, Uri gadgetUrl, int statusCode, Throwable t) {\n    if (LOG.isLoggable(Level.INFO)) {\n      LOG.logp(Level.INFO, classname, methodname, MessageKeys.FAILED_TO_RENDER, new Object[] {gadgetUrl,t.getMessage()});\n    }\n    return RenderingResults.error(t.getMessage(), statusCode);\n  }\n\n  /**\n   * Validates that the parent parameter was acceptable.\n   *\n   * @return True if the parent parameter is valid for the current container.\n   */\n  private boolean validateParent(GadgetContext context) {\n    String container = context.getContainer();\n    String parent = context.getParameter(\"parent\");\n\n    if (parent == null) {\n      // If there is no parent parameter, we are still safe because no\n      // dependent code ever has to trust it anyway.\n      return true;\n    }\n\n    List<Object> parents = containerConfig.getList(container, \"gadgets.parent\");\n    if (parents.isEmpty()) {\n      // Allow all.\n      return true;\n    }\n\n    // We need to check each possible parent parameter against this regex.\n    for (Object pattern : parents) {\n      if (Pattern.matches(pattern.toString(), parent)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n","lineNo":81}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.uri;\n\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.common.util.HashUtil;\nimport org.apache.shindig.gadgets.features.FeatureRegistry;\nimport org.apache.shindig.gadgets.features.FeatureResource;\nimport org.apache.shindig.gadgets.uri.IframeUriManager.Versioner;\n\nimport com.google.inject.Inject;\n\n/**\n * Simple, but naive, implementation of an IFRAME version generator that\n * returns the same version value for all renders: the hash of all JS in the\n * feature system. This serves as an implicit version of the whole build.\n *\n * While often a reasonable heuristic, use of this versioner completely\n * ignores code changes. For instance, a rewriter may be deployed, yet\n * if no JS changed, it would never run since a generated/versioned URL\n * would cache the previously-generated render.\n *\n * More sophisticated Versioner implementations may take these sorts of\n * scenarios into consideration, and even go further, retrieving the\n * referenced gadget from the GadgetSpecFactory. Such an implementation's\n * performance is highly installation-specific, however, so is left as\n * an exercise to integrators to achieve effectively.\n */\npublic class AllJsIframeVersioner implements Versioner {\n  private final String allJsChecksum;\n\n  @Inject\n  public AllJsIframeVersioner(FeatureRegistry registry) {\n    StringBuilder jsBuf = new StringBuilder();\n    for (FeatureResource resource : registry.getAllFeatures().getResources()) {\n      jsBuf.append(resource.getContent()).append(resource.getDebugContent());\n    }\n    allJsChecksum = HashUtil.checksum(jsBuf.toString().getBytes());\n  }\n\n  public String version(Uri gadgetUri, String container) {\n    return allJsChecksum;\n  }\n\n  public UriStatus validate(Uri gadgetUri, String container, String value) {\n    if (value == null || value.length() == 0) {\n      return UriStatus.VALID_UNVERSIONED;\n    }\n\n    if (value.equals(allJsChecksum)) {\n      return UriStatus.VALID_VERSIONED;\n    }\n\n    return UriStatus.INVALID_VERSION;\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.uri;\n\nimport java.nio.charset.Charset;\nimport java.security.MessageDigest;\n\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.common.util.HashUtil;\nimport org.apache.shindig.gadgets.features.FeatureRegistry;\nimport org.apache.shindig.gadgets.features.FeatureResource;\nimport org.apache.shindig.gadgets.uri.IframeUriManager.Versioner;\n\nimport com.google.inject.Inject;\n\n/**\n * Simple, but naive, implementation of an IFRAME version generator that\n * returns the same version value for all renders: the hash of all JS in the\n * feature system. This serves as an implicit version of the whole build.\n *\n * While often a reasonable heuristic, use of this versioner completely\n * ignores code changes. For instance, a rewriter may be deployed, yet\n * if no JS changed, it would never run since a generated/versioned URL\n * would cache the previously-generated render.\n *\n * More sophisticated Versioner implementations may take these sorts of\n * scenarios into consideration, and even go further, retrieving the\n * referenced gadget from the GadgetSpecFactory. Such an implementation's\n * performance is highly installation-specific, however, so is left as\n * an exercise to integrators to achieve effectively.\n */\npublic class AllJsIframeVersioner implements Versioner {\n  private final String allJsChecksum;\n\n  @Inject\n  public AllJsIframeVersioner(FeatureRegistry registry) {\n    Charset charset = Charset.defaultCharset();\n    MessageDigest digest = HashUtil.getMessageDigest();\n    digest.reset();\n    for (FeatureResource resource : registry.getAllFeatures().getResources()) {\n      // Emulate StringBuilder append of content\n      String content = resource.getContent();\n      digest.update((content == null ? \"null\" : content).getBytes(charset));\n      content = resource.getDebugContent();\n      digest.update((content == null ? \"null\" : content).getBytes(charset));\n    }\n    allJsChecksum = HashUtil.bytesToHex(digest.digest());\n  }\n\n  public String version(Uri gadgetUri, String container) {\n    return allJsChecksum;\n  }\n\n  public UriStatus validate(Uri gadgetUri, String container, String value) {\n    if (value == null || value.length() == 0) {\n      return UriStatus.VALID_UNVERSIONED;\n    }\n\n    if (value.equals(allJsChecksum)) {\n      return UriStatus.VALID_VERSIONED;\n    }\n\n    return UriStatus.INVALID_VERSION;\n  }\n}\n","lineNo":58}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.auth;\n\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.shindig.common.crypto.BlobCrypterException;\nimport org.apache.shindig.common.util.Utf8UrlCoder;\n\nimport com.google.common.base.Joiner;\nimport com.google.inject.Singleton;\n\n/**\n * A SecurityTokenCodec implementation that just provides dummy data to satisfy\n * tests and API calls. Do not use this for any security applications.\n *\n * @since 2.0.0\n */\n@Singleton\npublic class BasicSecurityTokenCodec implements SecurityTokenCodec {\n\n  private static final int OWNER_INDEX = 0;\n  private static final int VIEWER_INDEX = 1;\n  private static final int APP_ID_INDEX = 2;\n  private static final int DOMAIN_INDEX = 3;\n  private static final int APP_URL_INDEX = 4;\n  private static final int MODULE_ID_INDEX = 5;\n  private static final int CONTAINER_ID_INDEX = 6;\n  private static final int EXPIRY_INDEX = 7; // for back compat, conditionally check later\n  private static final int TOKEN_COUNT = CONTAINER_ID_INDEX + 1;\n\n  /**\n   * Encodes a token using the a plaintext dummy format.\n   * @param token token to encode\n   * @return token with values separated by colons\n   */\n  public String encodeToken(SecurityToken token) {\n    Long expires = null;\n    if (token instanceof AbstractSecurityToken) {\n      ((AbstractSecurityToken) token).setExpires();\n      expires = token.getExpiresAt();\n    } else {\n      // Quick and dirty token expire calculation.\n      expires = new BasicSecurityToken().setExpires().getExpiresAt();\n    }\n\n    String encoded = Joiner.on(\":\").join(\n        Utf8UrlCoder.encode(token.getOwnerId()),\n        Utf8UrlCoder.encode(token.getViewerId()),\n        Utf8UrlCoder.encode(token.getAppId()),\n        Utf8UrlCoder.encode(token.getDomain()),\n        Utf8UrlCoder.encode(token.getAppUrl()),\n        Long.toString(token.getModuleId(), 10),\n        Utf8UrlCoder.encode(token.getContainer()));\n\n    if (expires != null) {\n      encoded = Joiner.on(':').join(encoded, Long.toString(expires, 10));\n    }\n\n    return encoded;\n  }\n\n\n  /**\n   * {@inheritDoc}\n   *\n   * Returns a token with some faked out values.\n   */\n  public SecurityToken createToken(Map<String, String> parameters)\n      throws SecurityTokenException {\n\n    final String token = parameters.get(SecurityTokenCodec.SECURITY_TOKEN_NAME);\n    if (token == null || token.trim().length() == 0) {\n      // No token is present, assume anonymous access\n      return new AnonymousSecurityToken();\n    }\n\n    try {\n      String[] tokens = StringUtils.split(token, ':');\n      if (tokens.length < TOKEN_COUNT) {\n        throw new SecurityTokenException(\"Malformed security token\");\n      }\n\n      Long expires = null;\n      if (tokens.length > TOKEN_COUNT && !tokens[EXPIRY_INDEX].equals(\"\")) {\n        expires = Long.parseLong(Utf8UrlCoder.decode(tokens[EXPIRY_INDEX]), 10);\n      }\n\n      BasicSecurityToken basicToken = new BasicSecurityToken(\n          Utf8UrlCoder.decode(tokens[OWNER_INDEX]),\n          Utf8UrlCoder.decode(tokens[VIEWER_INDEX]),\n          Utf8UrlCoder.decode(tokens[APP_ID_INDEX]),\n          Utf8UrlCoder.decode(tokens[DOMAIN_INDEX]),\n          Utf8UrlCoder.decode(tokens[APP_URL_INDEX]),\n          Utf8UrlCoder.decode(tokens[MODULE_ID_INDEX]),\n          Utf8UrlCoder.decode(tokens[CONTAINER_ID_INDEX]),\n          parameters.get(SecurityTokenCodec.ACTIVE_URL_NAME),\n          expires);\n      return basicToken.enforceNotExpired();\n    } catch (BlobCrypterException e) {\n      throw new SecurityTokenException(e);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      throw new SecurityTokenException(e);\n    }\n  }\n\n  public int getTokenTimeToLive() {\n    return AbstractSecurityToken.MAX_TOKEN_TTL;\n  }\n\n  /**\n   * Creates a basic signer\n   */\n  public BasicSecurityTokenCodec() {}\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.auth;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.shindig.common.crypto.BlobCrypterException;\nimport org.apache.shindig.common.util.Utf8UrlCoder;\nimport org.apache.shindig.config.ContainerConfig;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.Maps;\nimport com.google.inject.Singleton;\n\n/**\n * A SecurityTokenCodec implementation that just provides dummy data to satisfy\n * tests and API calls. Do not use this for any security applications.\n *\n * @since 2.0.0\n */\n@Singleton\npublic class BasicSecurityTokenCodec implements SecurityTokenCodec, ContainerConfig.ConfigObserver {\n\n  // Logging\n  private static final String CLASSNAME = BasicSecurityTokenCodec.class.getName();\n  private static final Logger LOG = Logger.getLogger(CLASSNAME);\n\n  private static final int OWNER_INDEX = 0;\n  private static final int VIEWER_INDEX = 1;\n  private static final int APP_ID_INDEX = 2;\n  private static final int DOMAIN_INDEX = 3;\n  private static final int APP_URL_INDEX = 4;\n  private static final int MODULE_ID_INDEX = 5;\n  private static final int CONTAINER_ID_INDEX = 6;\n  private static final int EXPIRY_INDEX = 7; // for back compat, conditionally check later\n  private static final int TOKEN_COUNT = CONTAINER_ID_INDEX + 1;\n  private Map<String, Integer> tokenTTLs = Maps.newHashMap();\n\n  /**\n   * Encodes a token using the a plaintext dummy format.\n   * @param token token to encode\n   * @return token with values separated by colons\n   */\n  public String encodeToken(SecurityToken token) {\n    Long expires = null;\n    Integer tokenTTL = this.tokenTTLs.get(token.getContainer());\n    if (token instanceof AbstractSecurityToken) {\n      if (tokenTTL != null) {\n        ((AbstractSecurityToken) token).setExpires(tokenTTL);\n      } else {\n        ((AbstractSecurityToken) token).setExpires();\n      }\n      expires = token.getExpiresAt();\n    } else {\n      // Quick and dirty token expire calculation.\n      AbstractSecurityToken localToken = new BasicSecurityToken();\n      if (tokenTTL != null) {\n        localToken.setExpires(tokenTTL);\n      } else {\n        localToken.setExpires();\n      }\n      expires = localToken.getExpiresAt();\n    }\n\n    String encoded = Joiner.on(\":\").join(\n        Utf8UrlCoder.encode(token.getOwnerId()),\n        Utf8UrlCoder.encode(token.getViewerId()),\n        Utf8UrlCoder.encode(token.getAppId()),\n        Utf8UrlCoder.encode(token.getDomain()),\n        Utf8UrlCoder.encode(token.getAppUrl()),\n        Long.toString(token.getModuleId(), 10),\n        Utf8UrlCoder.encode(token.getContainer()));\n\n    if (expires != null) {\n      encoded = Joiner.on(':').join(encoded, Long.toString(expires, 10));\n    }\n\n    return encoded;\n  }\n\n\n  /**\n   * {@inheritDoc}\n   *\n   * Returns a token with some faked out values.\n   */\n  public SecurityToken createToken(Map<String, String> parameters)\n      throws SecurityTokenException {\n\n    final String token = parameters.get(SecurityTokenCodec.SECURITY_TOKEN_NAME);\n    if (token == null || token.trim().length() == 0) {\n      // No token is present, assume anonymous access\n      return new AnonymousSecurityToken();\n    }\n\n    try {\n      String[] tokens = StringUtils.split(token, ':');\n      if (tokens.length < TOKEN_COUNT) {\n        throw new SecurityTokenException(\"Malformed security token\");\n      }\n\n      Long expires = null;\n      if (tokens.length > TOKEN_COUNT && !tokens[EXPIRY_INDEX].equals(\"\")) {\n        expires = Long.parseLong(Utf8UrlCoder.decode(tokens[EXPIRY_INDEX]), 10);\n      }\n\n      BasicSecurityToken basicToken = new BasicSecurityToken(\n          Utf8UrlCoder.decode(tokens[OWNER_INDEX]),\n          Utf8UrlCoder.decode(tokens[VIEWER_INDEX]),\n          Utf8UrlCoder.decode(tokens[APP_ID_INDEX]),\n          Utf8UrlCoder.decode(tokens[DOMAIN_INDEX]),\n          Utf8UrlCoder.decode(tokens[APP_URL_INDEX]),\n          Utf8UrlCoder.decode(tokens[MODULE_ID_INDEX]),\n          Utf8UrlCoder.decode(tokens[CONTAINER_ID_INDEX]),\n          parameters.get(SecurityTokenCodec.ACTIVE_URL_NAME),\n          expires);\n      return basicToken.enforceNotExpired();\n    } catch (BlobCrypterException e) {\n      throw new SecurityTokenException(e);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      throw new SecurityTokenException(e);\n    }\n  }\n\n  public int getTokenTimeToLive() {\n    return AbstractSecurityToken.DEFAULT_MAX_TOKEN_TTL;\n  }\n\n  public int getTokenTimeToLive(String container) {\n    Integer tokenTTL = this.tokenTTLs.get(container);\n    if (tokenTTL == null) {\n      return getTokenTimeToLive();\n    }\n    return tokenTTL;\n  }\n\n  /**\n   * Creates a basic signer\n   */\n  public BasicSecurityTokenCodec() {}\n\n  /**\n   * Creates a basic signer that can observe container configuration changes\n   * @param config the container config to observe\n   */\n  public BasicSecurityTokenCodec(ContainerConfig config) {\n    config.addConfigObserver(this, true);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  public void containersChanged(ContainerConfig config, Collection<String> changed,\n          Collection<String> removed) {\n    for (String container : removed) {\n      this.tokenTTLs.remove(container);\n    }\n\n    for (String container : changed) {\n      int tokenTTL = config.getInt(container, SECURITY_TOKEN_TTL_CONFIG);\n      // 0 means the value was not defined or NaN.  0 shouldn't be a valid TTL anyway.\n      if (tokenTTL > 0) {\n        this.tokenTTLs.put(container, tokenTTL);\n      } else {\n        LOG.logp(Level.WARNING, CLASSNAME, \"containersChanged\",\n                \"Token TTL for container \\\"{0}\\\" was {1} and will be ignored.\",\n                new Object[] { container, tokenTTL });\n      }\n    }\n  }\n}\n","lineNo":76}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth;\n\nimport com.google.common.collect.Maps;\n\nimport com.google.inject.Singleton;\n\nimport net.oauth.OAuth;\nimport net.oauth.OAuthConsumer;\nimport net.oauth.OAuthServiceProvider;\nimport net.oauth.signature.RSA_SHA1;\n\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.oauth.BasicOAuthStoreConsumerKeyAndSecret.KeyType;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * Simple implementation of the {@link OAuthStore} interface. We use a\n * in-memory hash map. If initialized with a private key, then the store will\n * return an OAuthAccessor in {@code getOAuthAccessor} that uses that private\n * key if no consumer key and secret could be found.\n */\n@Singleton\npublic class BasicOAuthStore implements OAuthStore {\n\n  private static final String CONSUMER_SECRET_KEY = \"consumer_secret\";\n  private static final String CONSUMER_KEY_KEY = \"consumer_key\";\n  private static final String KEY_TYPE_KEY = \"key_type\";\n  private static final String CALLBACK_URL = \"callback_url\";\n\n  /**\n   * HashMap of provider and consumer information. Maps BasicOAuthStoreConsumerIndexs (i.e.\n   * nickname of a service provider and the gadget that uses that nickname) to\n   * {@link BasicOAuthStoreConsumerKeyAndSecret}s.\n   */\n  private final Map<BasicOAuthStoreConsumerIndex, BasicOAuthStoreConsumerKeyAndSecret> consumerInfos;\n\n  /**\n   * HashMap of token information. Maps BasicOAuthStoreTokenIndexs (i.e. gadget id, token\n   * nickname, module id, etc.) to TokenInfos (i.e. access token and token\n   * secrets).\n   */\n  private final Map<BasicOAuthStoreTokenIndex, TokenInfo> tokens;\n\n  /**\n   * Key to use when no other key is found.\n   */\n  private BasicOAuthStoreConsumerKeyAndSecret defaultKey;\n\n  /**\n   * Callback to use when no per-key callback URL is found.\n   */\n  private String defaultCallbackUrl;\n\n  /** Number of times we looked up a consumer key */\n  private int consumerKeyLookupCount = 0;\n\n  /** Number of times we looked up an access token */\n  private int accessTokenLookupCount = 0;\n\n  /** Number of times we added an access token */\n  private int accessTokenAddCount = 0;\n\n  /** Number of times we removed an access token */\n  private int accessTokenRemoveCount = 0;\n\n  private Authority authority;\n\n  public BasicOAuthStore() {\n    consumerInfos = Maps.newHashMap();\n    tokens = Maps.newHashMap();\n  }\n\n  public void initFromConfigString(String oauthConfigStr) throws GadgetException {\n    try {\n      JSONObject oauthConfigs = new JSONObject(oauthConfigStr);\n      for (Iterator<?> i = oauthConfigs.keys(); i.hasNext();) {\n        String url = (String) i.next();\n        URI gadgetUri = new URI(url);\n        JSONObject oauthConfig = oauthConfigs.getJSONObject(url);\n        storeConsumerInfos(gadgetUri, oauthConfig);\n      }\n    } catch (JSONException e) {\n      throw new GadgetException(GadgetException.Code.OAUTH_STORAGE_ERROR, e);\n    } catch (URISyntaxException e) {\n      throw new GadgetException(GadgetException.Code.OAUTH_STORAGE_ERROR, e);\n    }\n  }\n\n  private void storeConsumerInfos(URI gadgetUri, JSONObject oauthConfig)\n      throws JSONException, GadgetException {\n    for (String serviceName : JSONObject.getNames(oauthConfig)) {\n      JSONObject consumerInfo = oauthConfig.getJSONObject(serviceName);\n      storeConsumerInfo(gadgetUri, serviceName, consumerInfo);\n    }\n  }\n\n  private void storeConsumerInfo(URI gadgetUri, String serviceName, JSONObject consumerInfo)\n      throws JSONException, GadgetException {\n    realStoreConsumerInfo(gadgetUri, serviceName, consumerInfo);\n  }\n\n  private void realStoreConsumerInfo(URI gadgetUri, String serviceName, JSONObject consumerInfo)\n      throws JSONException {\n    String callbackUrl = consumerInfo.optString(CALLBACK_URL, null);\n    String consumerSecret = consumerInfo.getString(CONSUMER_SECRET_KEY);\n    String consumerKey = consumerInfo.getString(CONSUMER_KEY_KEY);\n    String keyTypeStr = consumerInfo.getString(KEY_TYPE_KEY);\n    KeyType keyType = KeyType.HMAC_SYMMETRIC;\n\n    if (\"RSA_PRIVATE\".equals(keyTypeStr)) {\n      keyType = KeyType.RSA_PRIVATE;\n      consumerSecret = convertFromOpenSsl(consumerSecret);\n    }\n\n    BasicOAuthStoreConsumerKeyAndSecret kas = new BasicOAuthStoreConsumerKeyAndSecret(\n        consumerKey, consumerSecret, keyType, null, callbackUrl);\n\n    BasicOAuthStoreConsumerIndex index = new BasicOAuthStoreConsumerIndex();\n    index.setGadgetUri(gadgetUri.toASCIIString());\n    index.setServiceName(serviceName);\n    setConsumerKeyAndSecret(index, kas);\n  }\n\n  // Support standard openssl keys by stripping out the headers and blank lines\n  public static String convertFromOpenSsl(String privateKey) {\n    return privateKey.replaceAll(\"-----[A-Z ]*-----\", \"\").replace(\"\\n\", \"\");\n  }\n\n  public void setDefaultKey(BasicOAuthStoreConsumerKeyAndSecret defaultKey) {\n    this.defaultKey = defaultKey;\n  }\n\n  public void setDefaultCallbackUrl(String defaultCallbackUrl) {\n    this.defaultCallbackUrl = defaultCallbackUrl;\n  }\n\n  public void setConsumerKeyAndSecret(\n      BasicOAuthStoreConsumerIndex providerKey, BasicOAuthStoreConsumerKeyAndSecret keyAndSecret) {\n    consumerInfos.put(providerKey, keyAndSecret);\n  }\n\n  public void setAuthority(Authority authority) {\n    this.authority = authority;\n  }\n\n  public ConsumerInfo getConsumerKeyAndSecret(\n      SecurityToken securityToken, String serviceName, OAuthServiceProvider provider)\n      throws GadgetException {\n    ++consumerKeyLookupCount;\n    BasicOAuthStoreConsumerIndex pk = new BasicOAuthStoreConsumerIndex();\n    pk.setGadgetUri(securityToken.getAppUrl());\n    pk.setServiceName(serviceName);\n    BasicOAuthStoreConsumerKeyAndSecret cks = consumerInfos.get(pk);\n    if (cks == null) {\n      cks = defaultKey;\n    }\n    if (cks == null) {\n      throw new GadgetException(GadgetException.Code.INTERNAL_SERVER_ERROR,\n          \"No key for gadget \" + securityToken.getAppUrl() + \" and service \" + serviceName);\n    }\n    OAuthConsumer consumer;\n    if (cks.getKeyType() == KeyType.RSA_PRIVATE) {\n      consumer = new OAuthConsumer(null, cks.getConsumerKey(), null, provider);\n      // The oauth.net java code has lots of magic.  By setting this property here, code thousands\n      // of lines away knows that the consumerSecret value in the consumer should be treated as\n      // an RSA private key and not an HMAC key.\n      consumer.setProperty(OAuth.OAUTH_SIGNATURE_METHOD, OAuth.RSA_SHA1);\n      consumer.setProperty(RSA_SHA1.PRIVATE_KEY, cks.getConsumerSecret());\n    } else {\n      consumer = new OAuthConsumer(null, cks.getConsumerKey(), cks.getConsumerSecret(), provider);\n      consumer.setProperty(OAuth.OAUTH_SIGNATURE_METHOD, OAuth.HMAC_SHA1);\n    }\n    String callback = (cks.getCallbackUrl() != null ? cks.getCallbackUrl() : defaultCallbackUrl);\n\n    if (authority != null) {\n      callback = callback.replace(\"%authority%\", authority.getAuthority());\n    }\n\n    return new ConsumerInfo(consumer, cks.getKeyName(), callback);\n  }\n\n  private BasicOAuthStoreTokenIndex makeBasicOAuthStoreTokenIndex(\n      SecurityToken securityToken, String serviceName, String tokenName) {\n    BasicOAuthStoreTokenIndex tokenKey = new BasicOAuthStoreTokenIndex();\n    tokenKey.setGadgetUri(securityToken.getAppUrl());\n    tokenKey.setModuleId(securityToken.getModuleId());\n    tokenKey.setServiceName(serviceName);\n    tokenKey.setTokenName(tokenName);\n    tokenKey.setUserId(securityToken.getViewerId());\n    return tokenKey;\n  }\n\n  public TokenInfo getTokenInfo(SecurityToken securityToken, ConsumerInfo consumerInfo,\n      String serviceName, String tokenName) {\n    ++accessTokenLookupCount;\n    BasicOAuthStoreTokenIndex tokenKey =\n        makeBasicOAuthStoreTokenIndex(securityToken, serviceName, tokenName);\n    return tokens.get(tokenKey);\n  }\n\n  public void setTokenInfo(SecurityToken securityToken, ConsumerInfo consumerInfo,\n      String serviceName, String tokenName, TokenInfo tokenInfo) {\n    ++accessTokenAddCount;\n    BasicOAuthStoreTokenIndex tokenKey =\n        makeBasicOAuthStoreTokenIndex(securityToken, serviceName, tokenName);\n    tokens.put(tokenKey, tokenInfo);\n  }\n\n  public void removeToken(SecurityToken securityToken, ConsumerInfo consumerInfo,\n      String serviceName, String tokenName) {\n    ++accessTokenRemoveCount;\n    BasicOAuthStoreTokenIndex tokenKey =\n        makeBasicOAuthStoreTokenIndex(securityToken, serviceName, tokenName);\n    tokens.remove(tokenKey);\n  }\n\n  public int getConsumerKeyLookupCount() {\n    return consumerKeyLookupCount;\n  }\n\n  public int getAccessTokenLookupCount() {\n    return accessTokenLookupCount;\n  }\n\n  public int getAccessTokenAddCount() {\n    return accessTokenAddCount;\n  }\n\n  public int getAccessTokenRemoveCount() {\n    return accessTokenRemoveCount;\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth;\n\nimport com.google.common.collect.Maps;\n\nimport com.google.inject.Singleton;\n\nimport net.oauth.OAuth;\nimport net.oauth.OAuthConsumer;\nimport net.oauth.OAuthServiceProvider;\nimport net.oauth.signature.RSA_SHA1;\n\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.oauth.BasicOAuthStoreConsumerKeyAndSecret.KeyType;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * Simple implementation of the {@link OAuthStore} interface. We use a\n * in-memory hash map. If initialized with a private key, then the store will\n * return an OAuthAccessor in {@code getOAuthAccessor} that uses that private\n * key if no consumer key and secret could be found.\n */\n@Singleton\npublic class BasicOAuthStore implements OAuthStore {\n\n  private static final String CONSUMER_SECRET_KEY = \"consumer_secret\";\n  private static final String CONSUMER_KEY_KEY = \"consumer_key\";\n  private static final String KEY_TYPE_KEY = \"key_type\";\n  private static final String CALLBACK_URL = \"callback_url\";\n  private static final String OAUTH_BODY_HASH_KEY = \"bodyHash\";\n\n  /**\n   * HashMap of provider and consumer information. Maps BasicOAuthStoreConsumerIndexs (i.e.\n   * nickname of a service provider and the gadget that uses that nickname) to\n   * {@link BasicOAuthStoreConsumerKeyAndSecret}s.\n   */\n  private final Map<BasicOAuthStoreConsumerIndex, BasicOAuthStoreConsumerKeyAndSecret> consumerInfos;\n\n  /**\n   * HashMap of token information. Maps BasicOAuthStoreTokenIndexs (i.e. gadget id, token\n   * nickname, module id, etc.) to TokenInfos (i.e. access token and token\n   * secrets).\n   */\n  private final Map<BasicOAuthStoreTokenIndex, TokenInfo> tokens;\n\n  /**\n   * Key to use when no other key is found.\n   */\n  private BasicOAuthStoreConsumerKeyAndSecret defaultKey;\n\n  /**\n   * Callback to use when no per-key callback URL is found.\n   */\n  private String defaultCallbackUrl;\n\n  /** Number of times we looked up a consumer key */\n  private int consumerKeyLookupCount = 0;\n\n  /** Number of times we looked up an access token */\n  private int accessTokenLookupCount = 0;\n\n  /** Number of times we added an access token */\n  private int accessTokenAddCount = 0;\n\n  /** Number of times we removed an access token */\n  private int accessTokenRemoveCount = 0;\n\n  private Authority authority;\n\n  public BasicOAuthStore() {\n    consumerInfos = Maps.newHashMap();\n    tokens = Maps.newHashMap();\n  }\n\n  public void initFromConfigString(String oauthConfigStr) throws GadgetException {\n    try {\n      JSONObject oauthConfigs = new JSONObject(oauthConfigStr);\n      for (Iterator<?> i = oauthConfigs.keys(); i.hasNext();) {\n        String url = (String) i.next();\n        URI gadgetUri = new URI(url);\n        JSONObject oauthConfig = oauthConfigs.getJSONObject(url);\n        storeConsumerInfos(gadgetUri, oauthConfig);\n      }\n    } catch (JSONException e) {\n      throw new GadgetException(GadgetException.Code.OAUTH_STORAGE_ERROR, e);\n    } catch (URISyntaxException e) {\n      throw new GadgetException(GadgetException.Code.OAUTH_STORAGE_ERROR, e);\n    }\n  }\n\n  private void storeConsumerInfos(URI gadgetUri, JSONObject oauthConfig)\n      throws JSONException, GadgetException {\n    for (String serviceName : JSONObject.getNames(oauthConfig)) {\n      JSONObject consumerInfo = oauthConfig.getJSONObject(serviceName);\n      storeConsumerInfo(gadgetUri, serviceName, consumerInfo);\n    }\n  }\n\n  private void storeConsumerInfo(URI gadgetUri, String serviceName, JSONObject consumerInfo)\n      throws JSONException, GadgetException {\n    realStoreConsumerInfo(gadgetUri, serviceName, consumerInfo);\n  }\n\n  private void realStoreConsumerInfo(URI gadgetUri, String serviceName, JSONObject consumerInfo)\n      throws JSONException {\n    String callbackUrl = consumerInfo.optString(CALLBACK_URL, null);\n    String consumerSecret = consumerInfo.getString(CONSUMER_SECRET_KEY);\n    String consumerKey = consumerInfo.getString(CONSUMER_KEY_KEY);\n    String keyTypeStr = consumerInfo.getString(KEY_TYPE_KEY);\n    boolean oauthBodyHash = true;\n    String oauthBodyHashString = consumerInfo.optString(OAUTH_BODY_HASH_KEY);\n    if (\"false\".equalsIgnoreCase(oauthBodyHashString)) {\n      oauthBodyHash = false;\n    }\n    KeyType keyType = KeyType.HMAC_SYMMETRIC;\n\n    if (\"RSA_PRIVATE\".equals(keyTypeStr)) {\n      keyType = KeyType.RSA_PRIVATE;\n      consumerSecret = convertFromOpenSsl(consumerSecret);\n    } else if (\"PLAINTEXT\".equals(keyTypeStr)) {\n      keyType = KeyType.PLAINTEXT;\n    }\n\n    BasicOAuthStoreConsumerKeyAndSecret kas = new BasicOAuthStoreConsumerKeyAndSecret(\n        consumerKey, consumerSecret, keyType, null, callbackUrl, oauthBodyHash);\n\n    BasicOAuthStoreConsumerIndex index = new BasicOAuthStoreConsumerIndex();\n    index.setGadgetUri(gadgetUri.toASCIIString());\n    index.setServiceName(serviceName);\n    setConsumerKeyAndSecret(index, kas);\n  }\n\n  // Support standard openssl keys by stripping out the headers and blank lines\n  public static String convertFromOpenSsl(String privateKey) {\n    return privateKey.replaceAll(\"-----[A-Z ]*-----\", \"\").replace(\"\\n\", \"\");\n  }\n\n  public void setDefaultKey(BasicOAuthStoreConsumerKeyAndSecret defaultKey) {\n    this.defaultKey = defaultKey;\n  }\n\n  public void setDefaultCallbackUrl(String defaultCallbackUrl) {\n    this.defaultCallbackUrl = defaultCallbackUrl;\n  }\n\n  public void setConsumerKeyAndSecret(\n      BasicOAuthStoreConsumerIndex providerKey, BasicOAuthStoreConsumerKeyAndSecret keyAndSecret) {\n    consumerInfos.put(providerKey, keyAndSecret);\n  }\n\n  public void setAuthority(Authority authority) {\n    this.authority = authority;\n  }\n\n  public ConsumerInfo getConsumerKeyAndSecret(\n      SecurityToken securityToken, String serviceName, OAuthServiceProvider provider)\n      throws GadgetException {\n    ++consumerKeyLookupCount;\n    BasicOAuthStoreConsumerIndex pk = new BasicOAuthStoreConsumerIndex();\n    pk.setGadgetUri(securityToken.getAppUrl());\n    pk.setServiceName(serviceName);\n    BasicOAuthStoreConsumerKeyAndSecret cks = consumerInfos.get(pk);\n    if (cks == null) {\n      cks = defaultKey;\n    }\n    if (cks == null) {\n      throw new GadgetException(GadgetException.Code.INTERNAL_SERVER_ERROR,\n          \"No key for gadget \" + securityToken.getAppUrl() + \" and service \" + serviceName);\n    }\n    OAuthConsumer consumer;\n    final KeyType keyType = cks.getKeyType();\n    if (keyType == KeyType.RSA_PRIVATE) {\n      consumer = new OAuthConsumer(null, cks.getConsumerKey(), null, provider);\n      // The oauth.net java code has lots of magic.  By setting this property here, code thousands\n      // of lines away knows that the consumerSecret value in the consumer should be treated as\n      // an RSA private key and not an HMAC key.\n      consumer.setProperty(OAuth.OAUTH_SIGNATURE_METHOD, OAuth.RSA_SHA1);\n      consumer.setProperty(RSA_SHA1.PRIVATE_KEY, cks.getConsumerSecret());\n    } else if  (keyType == KeyType.PLAINTEXT) {\n      consumer = new OAuthConsumer(null, cks.getConsumerKey(), cks.getConsumerSecret(), provider);\n      consumer.setProperty(OAuth.OAUTH_SIGNATURE_METHOD, \"PLAINTEXT\");\n    } else {\n      consumer = new OAuthConsumer(null, cks.getConsumerKey(), cks.getConsumerSecret(), provider);\n      consumer.setProperty(OAuth.OAUTH_SIGNATURE_METHOD, OAuth.HMAC_SHA1);\n    }\n    String callback = (cks.getCallbackUrl() != null ? cks.getCallbackUrl() : defaultCallbackUrl);\n\n    if (authority != null) {\n      callback = callback.replace(\"%authority%\", authority.getAuthority());\n    }\n\n    return new ConsumerInfo(consumer, cks.getKeyName(), callback, cks.isOauthBodyHash());\n  }\n\n  private BasicOAuthStoreTokenIndex makeBasicOAuthStoreTokenIndex(\n      SecurityToken securityToken, String serviceName, String tokenName) {\n    BasicOAuthStoreTokenIndex tokenKey = new BasicOAuthStoreTokenIndex();\n    tokenKey.setGadgetUri(securityToken.getAppUrl());\n    tokenKey.setModuleId(securityToken.getModuleId());\n    tokenKey.setServiceName(serviceName);\n    tokenKey.setTokenName(tokenName);\n    tokenKey.setUserId(securityToken.getViewerId());\n    return tokenKey;\n  }\n\n  public TokenInfo getTokenInfo(SecurityToken securityToken, ConsumerInfo consumerInfo,\n      String serviceName, String tokenName) {\n    ++accessTokenLookupCount;\n    BasicOAuthStoreTokenIndex tokenKey =\n        makeBasicOAuthStoreTokenIndex(securityToken, serviceName, tokenName);\n    return tokens.get(tokenKey);\n  }\n\n  public void setTokenInfo(SecurityToken securityToken, ConsumerInfo consumerInfo,\n      String serviceName, String tokenName, TokenInfo tokenInfo) {\n    ++accessTokenAddCount;\n    BasicOAuthStoreTokenIndex tokenKey =\n        makeBasicOAuthStoreTokenIndex(securityToken, serviceName, tokenName);\n    tokens.put(tokenKey, tokenInfo);\n  }\n\n  public void removeToken(SecurityToken securityToken, ConsumerInfo consumerInfo,\n      String serviceName, String tokenName) {\n    ++accessTokenRemoveCount;\n    BasicOAuthStoreTokenIndex tokenKey =\n        makeBasicOAuthStoreTokenIndex(securityToken, serviceName, tokenName);\n    tokens.remove(tokenKey);\n  }\n\n  public int getConsumerKeyLookupCount() {\n    return consumerKeyLookupCount;\n  }\n\n  public int getAccessTokenLookupCount() {\n    return accessTokenLookupCount;\n  }\n\n  public int getAccessTokenAddCount() {\n    return accessTokenAddCount;\n  }\n\n  public int getAccessTokenRemoveCount() {\n    return accessTokenRemoveCount;\n  }\n}\n","lineNo":196}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\npackage org.apache.shindig.gadgets.rewrite.js;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang3.StringEscapeUtils;\nimport org.apache.shindig.common.cache.Cache;\nimport org.apache.shindig.common.cache.CacheProvider;\nimport org.apache.shindig.common.logging.i18n.MessageKeys;\nimport org.apache.shindig.common.util.HashUtil;\nimport org.apache.shindig.gadgets.features.ApiDirective;\nimport org.apache.shindig.gadgets.features.FeatureRegistry.FeatureBundle;\nimport org.apache.shindig.gadgets.http.HttpResponse;\nimport org.apache.shindig.gadgets.js.JsContent;\nimport org.apache.shindig.gadgets.js.JsResponse;\nimport org.apache.shindig.gadgets.js.JsResponseBuilder;\nimport org.apache.shindig.gadgets.uri.JsUriManager.JsUri;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.debugging.sourcemap.SourceMapConsumerFactory;\nimport com.google.debugging.sourcemap.SourceMapParseException;\nimport com.google.debugging.sourcemap.SourceMapping;\nimport com.google.debugging.sourcemap.proto.Mapping.OriginalMapping;\nimport com.google.inject.Inject;\nimport com.google.inject.name.Named;\nimport com.google.javascript.jscomp.BasicErrorManager;\nimport com.google.javascript.jscomp.CheckLevel;\nimport com.google.javascript.jscomp.CommandLineRunner;\nimport com.google.javascript.jscomp.CompilationLevel;\nimport com.google.javascript.jscomp.Compiler;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport com.google.javascript.jscomp.JSError;\nimport com.google.javascript.jscomp.SourceFile;\nimport com.google.javascript.jscomp.Result;\nimport com.google.javascript.jscomp.SourceMap;\n\npublic class ClosureJsCompiler implements JsCompiler {\n  // Based on Closure Library's goog.exportSymbol implementation.\n  private static final JsContent EXPORTSYMBOL_CODE =\n      JsContent.fromText(\"var goog=goog||{};goog.exportSymbol=function(name,obj){\"\n              + \"var parts=name.split('.'),cur=window,part;\"\n              + \"for(;parts.length&&(part=parts.shift());){if(!parts.length){\"\n              + \"cur[part]=obj;}else{cur=cur[part]||(cur[part]={})}}};\", \"[goog.exportSymbol]\");\n\n  //class name for logging purpose\n  private static final String classname = ClosureJsCompiler.class.getName();\n  private static final Logger LOG = Logger.getLogger(classname, MessageKeys.MESSAGES);\n\n  @VisibleForTesting\n  static final String CACHE_NAME = \"CompiledJs\";\n\n  private final DefaultJsCompiler defaultCompiler;\n  private final Cache<String, JsResponse> cache;\n  private final List<SourceFile> defaultExterns;\n  private final String compileLevel;\n  private final CompilerOptions compilerOptions;\n\n  @Inject\n  public ClosureJsCompiler(DefaultJsCompiler defaultCompiler, CacheProvider cacheProvider,\n      @Named(\"shindig.closure.compile.level\") String level) {\n    this.cache = cacheProvider.createCache(CACHE_NAME);\n    this.defaultCompiler = defaultCompiler;\n    List<SourceFile> externs = null;\n    try {\n      externs = Collections.unmodifiableList(CommandLineRunner.getDefaultExterns());\n    } catch(IOException e) {\n      if (LOG.isLoggable(Level.WARNING)) {\n        LOG.log(Level.WARNING, \"Unable to load default closure externs: \" + e.getMessage(), e);\n      }\n    }\n    defaultExterns = externs;\n\n    compileLevel = level.toLowerCase().trim();\n    compilerOptions = defaultCompilerOptions();\n  }\n\n  public CompilerOptions defaultCompilerOptions() {\n    CompilerOptions result = new CompilerOptions();\n    if (compileLevel.equals(\"advanced\")) {\n      CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(result);\n    }\n    else if (compileLevel.equals(\"whitespace_only\")) {\n      CompilationLevel.WHITESPACE_ONLY.setOptionsForCompilationLevel(result);\n    }\n    else {\n      // If 'none', this complier will not run, @see compile\n      CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(result);\n    }\n    return result;\n  }\n\n  @VisibleForTesting\n  protected CompilerOptions getCompilerOptions(JsUri uri) {\n    /*\n     * This method gets called many times over the course of a single compilation.\n     * Keep the instantiated compiler options unless we need to set SourceMap options\n     */\n    if (!outputCorrelatedJs()) {\n      return compilerOptions;\n    }\n\n    CompilerOptions options = defaultCompilerOptions();\n    setSourceMapCompilerOptions(options);\n    return options;\n  }\n\n  protected void setSourceMapCompilerOptions(CompilerOptions options) {\n    options.sourceMapOutputPath = \"create.out\";\n    options.sourceMapFormat = SourceMap.Format.DEFAULT;\n    options.sourceMapDetailLevel = SourceMap.DetailLevel.ALL;\n  }\n\n  @VisibleForTesting\n  Compiler newCompiler() {\n    BasicErrorManager errorManager = new BasicErrorManager() {\n      @Override\n      protected void printSummary() { /* Do nothing */ }\n\n      @Override\n      public void println(CheckLevel arg0, JSError arg1) { /* Do nothing */ }\n    };\n    return new Compiler(errorManager);\n  }\n\n  public JsResponse compile(JsUri jsUri, Iterable<JsContent> content, String externs) {\n    JsResponse exportResponse = defaultCompiler.compile(jsUri, content, externs);\n    content = exportResponse.getAllJsContent();\n\n    String cacheKey = makeCacheKey(exportResponse.toJsString(), externs, jsUri);\n    JsResponse cachedResult = cache.getElement(cacheKey);\n    if (cachedResult != null) {\n      return cachedResult;\n    }\n\n    // Only run actual compiler if necessary.\n    CompilerOptions options = getCompilerOptions(jsUri);\n\n    if (!compileLevel.equals(\"none\")) {\n      /*\n       *  isDebug usually will turn off all compilation, however, setting\n       *  isExternExportsEnabled and specifying an export path will keep the\n       *  closure compiler on and export the externs for debugging.\n       */\n      if (!jsUri.isDebug() || options.isExternExportsEnabled()) {\n        return doCompile(jsUri, content, externs, cacheKey);\n      }\n    }\n\n    return doDebug(content, cacheKey);\n  }\n\n  protected JsResponse doDebug(Iterable<JsContent> content, String cacheKey) {\n    JsResponseBuilder builder = new JsResponseBuilder();\n    builder.appendAllJs(content);\n    JsResponse result = builder.build();\n    cache.addElement(cacheKey, result);\n    return result;\n  }\n\n  protected JsResponse doCompile(JsUri jsUri, Iterable<JsContent> content, String externs,\n      String cacheKey) {\n    JsResponseBuilder builder = new JsResponseBuilder();\n\n    CompilerOptions options = getCompilerOptions(jsUri);\n\n    List<SourceFile> allExterns = Lists.newArrayList();\n    allExterns.add(SourceFile.fromCode(\"externs\", externs));\n    if (defaultExterns != null) {\n      allExterns.addAll(defaultExterns);\n    }\n\n    List<JsContent> allContent = Lists.newLinkedList(content);\n    if (options.isExternExportsEnabled()) {\n      allContent.add(EXPORTSYMBOL_CODE);\n    }\n\n    Compiler actualCompiler = newCompiler();\n    Result result = actualCompiler.compile(\n        allExterns,\n        convertToJsSource(allContent),\n        options);\n\n    if (actualCompiler.hasErrors()) {\n      ImmutableList.Builder<String> errors = ImmutableList.builder();\n      for (JSError error : actualCompiler.getErrors()) {\n        errors.add(error.toString());\n      }\n      return cacheAndReturnErrorResult(\n          builder, cacheKey,\n          HttpResponse.SC_NOT_FOUND,\n          errors.build());\n    }\n\n    String compiled = compileToSource(actualCompiler, result, jsUri);\n    if (outputCorrelatedJs()) {\n      // Emit code correlated w/ original source.\n      // This operation is equivalent in final code to bundled-output,\n      // but is less efficient and should perhaps only be used in code\n      // profiling.\n      SourceMapParser parser = processSourceMap(result, allContent);\n      if (parser != null) {\n        builder.appendAllJs(parser.mapCompiled(compiled));\n      } else {\n        return cacheAndReturnErrorResult(builder, cacheKey, HttpResponse.SC_INTERNAL_SERVER_ERROR,\n            Lists.newArrayList(\"Parse error for source map\"));\n      }\n    } else {\n      builder.appendJs(compiled, \"[compiled]\");\n    }\n\n    builder.clearExterns().appendRawExtern(result.externExport);\n\n    JsResponse response = builder.build();\n    cache.addElement(cacheKey, response);\n    return response;\n  }\n\n  protected String compileToSource(Compiler compiler, Result result, JsUri jsUri) {\n    return compiler.toSource();\n  }\n\n  private JsResponse cacheAndReturnErrorResult(\n      JsResponseBuilder builder, String cacheKey,\n      int statusCode, List<String> messages) {\n    builder.setStatusCode(statusCode);\n    builder.addErrors(messages);\n    JsResponse result = builder.build();\n    cache.addElement(cacheKey, result);\n    return result;\n  }\n\n  // Override this method to return \"true\" for cases where individual chunks of\n  // compiled JS should be emitted as JsContent objects, each correlating output JS\n  // with the original source file from which they came.\n  protected boolean outputCorrelatedJs() {\n    return false;\n  }\n\n  private List<SourceFile> convertToJsSource(Iterable<JsContent> content) {\n    Map<String, Integer> sourceMap = Maps.newHashMap();\n    List<SourceFile> sources = Lists.newLinkedList();\n    for (JsContent src : content) {\n      sources.add(SourceFile.fromCode(getUniqueSrc(src.getSource(), sourceMap), src.get()));\n    }\n    return sources;\n  }\n\n  // Return a unique string to represent the inbound \"source\" parameter.\n  // Closure Compiler errors out when two SourceFiles with the same name are\n  // provided, so this method tracks the currently-used source names (in the\n  // provided sourceMap) and ensures that a unique name is returned.\n  private static String getUniqueSrc(String source, Map<String, Integer> sourceMap) {\n    Integer ix = sourceMap.get(source);\n    if (ix == null) {\n      ix = 0;\n    }\n    String ret = source + (ix > 0 ? \":\" + ix : \"\");\n    sourceMap.put(source, ix + 1);\n    return ret;\n  }\n\n  private static String getRootSrc(String source) {\n    int colIx = source.lastIndexOf(':');\n    if (colIx == -1) {\n      return source;\n    }\n    return source.substring(0, colIx);\n  }\n\n  public Iterable<JsContent> getJsContent(JsUri jsUri, FeatureBundle bundle) {\n    jsUri = new JsUri(jsUri) {\n      @Override\n      public boolean isDebug() {\n        // Force debug JS in the raw JS content retrieved.\n        return true;\n      }\n    };\n    List<JsContent> builder = Lists.newLinkedList(defaultCompiler.getJsContent(jsUri, bundle));\n\n    CompilerOptions options = getCompilerOptions(jsUri);\n    if (options.isExternExportsEnabled()) {\n      List<String> exports = Lists.newArrayList(bundle.getApis(ApiDirective.Type.JS, true));\n      Collections.sort(exports);\n      String prevExport = null;\n      for (String export : exports) {\n        if (!export.equals(prevExport)) {\n          builder.add(JsContent.fromText(\n              \"goog.exportSymbol('\" + StringEscapeUtils.escapeEcmaScript(export) +\n              \"', \" + export + \");\\n\", \"[export-symbol]\"));\n          prevExport = export;\n        }\n      }\n    }\n    return builder;\n  }\n\n  protected String makeCacheKey(String code, String externs, JsUri uri) {\n    // TODO: include compilation options in the cache key\n    return Joiner.on(\":\").join(\n        HashUtil.checksum(code.getBytes()),\n        HashUtil.checksum(externs.getBytes()),\n        uri.getCompileMode(),\n        uri.isDebug(),\n        outputCorrelatedJs());\n  }\n\n  /**\n   * Pull the source map out of the given closure {@link Result} and construct a\n   * {@link SourceMapParser}. This instance can be used to correlate compiled\n   * content with originating source.\n   *\n   * @param result Closure result object with source map\n   * @param allInputs All inputs supplied to the compiler, in JsContent form\n   * @return Utility to parse the sourcemap\n   */\n  private SourceMapParser processSourceMap(Result result, List<JsContent> allInputs) {\n    StringBuilder sb = new StringBuilder();\n    try {\n      if (result.sourceMap != null) {\n        result.sourceMap.appendTo(sb, \"done\");\n        return SourceMapParser.parse(sb.toString(), allInputs);\n      }\n    } catch (SourceMapParseException e) { // null response\n    } catch (IOException e) { // null response\n    }\n    return null;\n  }\n\n  /**\n   * Parser for the string representation of a {@link SourceMap}.\n   */\n  private static class SourceMapParser {\n    /**\n     * Default source name for constructed {@link JsContent} entries.\n     */\n    private static final String DEFAULT_JSSOURCE = \"[closure-compiler-synthesized]\";\n\n    /**\n     * Utility to parse a {@link SourceMap} string.\n     */\n    private final SourceMapping consumer;\n\n    /**\n     * Map of mapping identifier to code components.\n     */\n    private final Map<String, JsContent> orig;\n\n    private SourceMapParser(SourceMapping consumer, List<JsContent> content) {\n      this.consumer = consumer;\n      this.orig = Maps.newHashMap();\n      for (JsContent js : content) {\n        orig.put(js.getSource(), js);\n      }\n    }\n\n    /**\n     * Deconstruct the original javascript content for compiled content.\n     *\n     * This routine iterates through the mapping at every row-column combination\n     * of the mapping in order to generate the original content. It is expected\n     * to be a considerably expensive operation.\n     *\n     * @param compiled the compiled javascript\n     * @return {@link JsContent} entries for code fragments belonging to a single source\n     */\n    public Iterable<JsContent> mapCompiled(String compiled) {\n      int row = 1, column; // current row-col being parsed\n      StringBuilder codeFragment = new StringBuilder(); // code fragment for a single mapping\n\n      OriginalMapping previousMapping = null, // the row-col mapping at the previous valid position\n          currentMapping; // the row-col mapping at the current valid position\n\n      ImmutableList.Builder<JsContent> contentEntries = ImmutableList.builder();\n      Iterable<String> compiledLines = Splitter.on(\"\\n\").split(compiled);\n      for (String compiledLine : compiledLines) {\n        for (column = 0; column < compiledLine.length(); column++) {\n          currentMapping = consumer.getMappingForLine(row, column + 1);\n          if (!Objects.equal(getSource(currentMapping), getSource(previousMapping))) {\n            contentEntries.add(getJsContent(codeFragment.toString(), getSource(previousMapping)));\n            codeFragment = new StringBuilder();\n          }\n          previousMapping = currentMapping;\n          codeFragment.append(compiledLine.charAt(column));\n        }\n        row++;\n        codeFragment.append('\\n');\n      }\n\n      // add the last fragment\n      codeFragment.deleteCharAt(codeFragment.length() - 1);\n      if (codeFragment.length() > 0) {\n        contentEntries.add(getJsContent(codeFragment.toString(), getSource(previousMapping)));\n      }\n      return contentEntries.build();\n    }\n\n    /**\n     * Utility to get the source of an {@link OriginalMapping}.\n     *\n     * @param mapping the mapping\n     * @return source of the mapping or a blank source if none is present\n     */\n    private final String getSource(OriginalMapping mapping) {\n      return (mapping != null) ? mapping.getOriginalFile() : \"\";\n    }\n\n    /**\n     * Construct {@link JsContent} instances for a given compiled code\n     * component.\n     *\n     * @param codeFragment the fragment of compiled code for this component\n     * @param mappingIdentifier positional mapping identifier\n     * @return {@link JsContent} for this component\n     */\n    private JsContent getJsContent(String codeFragment, String mappingIdentifier) {\n      JsContent sourceJs = orig.get(getRootSrc(mappingIdentifier));\n      String sourceName = DEFAULT_JSSOURCE;\n      FeatureBundle bundle = null;\n      if (sourceJs != null) {\n        sourceName = sourceJs.getSource() != null ? sourceJs.getSource() : \"\";\n        bundle = sourceJs.getFeatureBundle();\n      }\n      return JsContent.fromFeature(codeFragment, sourceName, bundle, null);\n    }\n\n    /**\n     * Parse the provided string and return an instance of this parser.\n     *\n     * @param string the {@link SourceMap} in a string representation\n     * @param originalContent the origoinal content\n     * @return parsing utility\n     * @throws SourceMapParseException\n     */\n    public static SourceMapParser parse(String string, List<JsContent> originalContent)\n        throws SourceMapParseException {\n      return new SourceMapParser(SourceMapConsumerFactory.parse(string), originalContent);\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\npackage org.apache.shindig.gadgets.rewrite.js;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang3.StringEscapeUtils;\nimport org.apache.shindig.common.cache.Cache;\nimport org.apache.shindig.common.cache.CacheProvider;\nimport org.apache.shindig.common.util.HashUtil;\nimport org.apache.shindig.common.util.ImmediateFuture;\nimport org.apache.shindig.gadgets.features.ApiDirective;\nimport org.apache.shindig.gadgets.features.FeatureRegistry.FeatureBundle;\nimport org.apache.shindig.gadgets.http.HttpResponse;\nimport org.apache.shindig.gadgets.js.JsContent;\nimport org.apache.shindig.gadgets.js.JsResponse;\nimport org.apache.shindig.gadgets.js.JsResponseBuilder;\nimport org.apache.shindig.gadgets.uri.JsUriManager.JsUri;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.inject.Inject;\nimport com.google.inject.name.Named;\nimport com.google.javascript.jscomp.BasicErrorManager;\nimport com.google.javascript.jscomp.CheckLevel;\nimport com.google.javascript.jscomp.CommandLineRunner;\nimport com.google.javascript.jscomp.CompilationLevel;\nimport com.google.javascript.jscomp.Compiler;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport com.google.javascript.jscomp.ErrorManager;\nimport com.google.javascript.jscomp.JSError;\nimport com.google.javascript.jscomp.Result;\nimport com.google.javascript.jscomp.SourceFile;\n\npublic class ClosureJsCompiler implements JsCompiler {\n  // Based on Closure Library's goog.exportSymbol implementation.\n  private static final JsContent EXPORTSYMBOL_CODE =\n      JsContent.fromText(\"var goog=goog||{};goog.exportSymbol=function(name,obj){\"\n              + \"var parts=name.split('.'),cur=window,part;\"\n              + \"for(;parts.length&&(part=parts.shift());){if(!parts.length){\"\n              + \"cur[part]=obj;}else{cur=cur[part]||(cur[part]={})}}};\", \"[goog.exportSymbol]\");\n\n  //class name for logging purpose\n  private static final String classname = ClosureJsCompiler.class.getName();\n  private static final Logger LOG = Logger.getLogger(classname);\n\n  @VisibleForTesting\n  static final String CACHE_NAME = \"CompiledJs\";\n\n  private final DefaultJsCompiler defaultCompiler;\n  private final Cache<String, CompileResult> cache;\n  private final List<SourceFile> defaultExterns;\n  private final String compileLevel;\n  private final Map<String, Future<CompileResult>> compiling;\n\n  private int threadPoolSize = 5;\n  private ExecutorService compilerPool;\n\n  @Inject\n  public ClosureJsCompiler(DefaultJsCompiler defaultCompiler, CacheProvider cacheProvider,\n      @Named(\"shindig.closure.compile.level\") String level) {\n    this.cache = cacheProvider.createCache(CACHE_NAME);\n    this.defaultCompiler = defaultCompiler;\n    List<SourceFile> externs = null;\n    try {\n      externs = Collections.unmodifiableList(CommandLineRunner.getDefaultExterns());\n    } catch(IOException e) {\n      if (LOG.isLoggable(Level.WARNING)) {\n        LOG.log(Level.WARNING, \"Unable to load default closure externs: \" + e.getMessage(), e);\n      }\n    }\n    defaultExterns = externs;\n\n    compileLevel = level.toLowerCase().trim();\n    compilerPool = createThreadPool();\n    Map<String, Future<CompileResult>> map = Maps.newHashMap();\n    compiling = new ConcurrentHashMap<String, Future<CompileResult>>(map);\n  }\n\n  @Inject(optional = true)\n  public void setThreadPoolSize(\n      @Named(\"shindig.closure.compile.threadPoolSize\") Integer threadPoolSize) {\n\n    if (threadPoolSize != null && threadPoolSize != this.threadPoolSize) {\n      ExecutorService compilerPool = this.compilerPool;\n\n      this.threadPoolSize = threadPoolSize;\n      this.compilerPool = createThreadPool();\n\n      compilerPool.shutdown();\n    }\n  }\n\n  /**\n   * Override this to provide your own {@link ExecutorService}\n   *\n   * @return An {@link ExecutorService} to use for the compiler pool.\n   */\n  protected ExecutorService createThreadPool() {\n    return Executors.newFixedThreadPool(threadPoolSize);\n  }\n\n  public CompilerOptions defaultCompilerOptions() {\n    CompilerOptions result = new CompilerOptions();\n    if (compileLevel.equals(\"advanced\")) {\n      CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(result);\n    }\n    else if (compileLevel.equals(\"whitespace_only\")) {\n      CompilationLevel.WHITESPACE_ONLY.setOptionsForCompilationLevel(result);\n    }\n    else {\n      // If 'none', this complier will not run, @see compile\n      CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(result);\n    }\n    return result;\n  }\n\n  @VisibleForTesting\n  protected CompilerOptions getCompilerOptions(JsUri uri) {\n    CompilerOptions options = defaultCompilerOptions();\n    return options;\n  }\n\n  public JsResponse compile(JsUri jsUri, Iterable<JsContent> content, String externs) {\n    JsResponseBuilder builder = new JsResponseBuilder();\n\n    CompilerOptions options = getCompilerOptions(jsUri);\n    StringBuilder compiled = new StringBuilder();\n    StringBuilder exports = new StringBuilder();\n\n    // Add externs export to the list if set in options.\n    if (options.isExternExportsEnabled()) {\n      List<JsContent> allContent = Lists.newLinkedList(content);\n      allContent.add(EXPORTSYMBOL_CODE);\n      content = allContent;\n    }\n\n    try {\n      List<Future<CompileResult>> futures = Lists.newLinkedList();\n\n      // Process each content for work\n      for (JsContent code : content) {\n        JsResponse defaultCompiled = defaultCompiler.compile(jsUri, Lists.newArrayList(code), externs);\n\n        Future<CompileResult> future = null;\n        boolean compile = !code.isNoCompile() && !compileLevel.equals(\"none\");\n        /*\n         *  isDebug usually will turn off all compilation, however, setting\n         *  isExternExportsEnabled and specifying an export path will keep the\n         *  closure compiler on and export the externs for debugging.\n         */\n        compile = compile && (!jsUri.isDebug() || options.isExternExportsEnabled());\n        if (compile) { // We should compile this code segment.\n          String cacheKey = makeCacheKey(defaultCompiled.toJsString(), externs, jsUri, options);\n\n          synchronized (compiling) {\n            CompileResult cached = cache.getElement(cacheKey);\n            if (cached == null) {\n              future = compiling.get(cacheKey);\n              if (future == null) {\n                // Don't pound on the compiler. Let the first thread queue the work,\n                // the rest of them will just wait on the futures later.\n                future = getCompileFuture(cacheKey, code, jsUri, externs);\n                compiling.put(cacheKey, future);\n              }\n            } else {\n              future = ImmediateFuture.newInstance(cached);\n            }\n          }\n        }\n\n        if (future == null) {\n          future = ImmediateFuture.newInstance(new CompileResult(code.get()));\n        }\n        futures.add(future);\n      }\n\n      // Wait on all work to be done.\n      for (Future<CompileResult> future : futures) {\n        CompileResult result = future.get();\n        compiled.append(result.getContent());\n        String export = result.getExternExport();\n        if (export != null) {\n          exports.append(export);\n        }\n      }\n\n    } catch (Exception e) {\n      if (LOG.isLoggable(Level.WARNING)) {\n        LOG.log(Level.WARNING, e.getMessage(), e);\n      }\n      Throwable cause = e.getCause();\n      if (cause instanceof CompilerException) {\n        return returnErrorResult(builder, HttpResponse.SC_NOT_FOUND, ((CompilerException)cause).getErrors());\n      } else {\n        return returnErrorResult(builder, HttpResponse.SC_NOT_FOUND, Lists.newArrayList(e.getMessage()));\n      }\n    }\n\n    builder.appendJs(compiled.toString(), \"[compiled]\");\n    builder.clearExterns().appendRawExtern(exports.toString());\n    return builder.build();\n  }\n\n  protected Future<CompileResult> getCompileFuture(final String cacheKey, final JsContent content,\n      final JsUri jsUri, final String externs) {\n\n    return compilerPool.submit(new Callable<CompileResult>() {\n      @Override\n      public CompileResult call() throws Exception {\n        // Create the options anew. Passing in the parent options, even cloning it, is not thread safe.\n        CompileResult result = doCompileContent(content, getCompilerOptions(jsUri), buildExterns(externs));\n        synchronized (compiling) {\n          // Other threads should pick this up in the cache now.\n          cache.addElement(cacheKey, result);\n          compiling.remove(cacheKey);\n        }\n\n        return result;\n      }\n    });\n  }\n\n  protected CompileResult doCompileContent(JsContent content, CompilerOptions options,\n      List<SourceFile> externs) throws CompilerException {\n\n    Compiler compiler = new Compiler(getErrorManager()); // We shouldn't reuse compilers\n    SourceFile source = SourceFile.fromCode(content.getSource(), content.get());\n    Result result = compiler.compile(externs, Lists.newArrayList(source), options);\n\n    if (result.errors.length > 0) {\n      throw new CompilerException(result.errors);\n    }\n\n    return new CompileResult(compiler, result);\n  }\n\n  protected List<SourceFile> buildExterns(String externs) {\n    List<SourceFile> allExterns = Lists.newArrayList();\n    allExterns.add(SourceFile.fromCode(\"externs\", externs));\n    if (defaultExterns != null) {\n      allExterns.addAll(defaultExterns);\n    }\n    return allExterns;\n  }\n\n  private JsResponse returnErrorResult(\n      JsResponseBuilder builder, int statusCode, List<String> messages) {\n    builder.setStatusCode(statusCode);\n    builder.addErrors(messages);\n    JsResponse result = builder.build();\n    return result;\n  }\n\n  public Iterable<JsContent> getJsContent(JsUri jsUri, FeatureBundle bundle) {\n    jsUri = new JsUri(jsUri) {\n      @Override\n      public boolean isDebug() {\n        // Force debug JS in the raw JS content retrieved.\n        return true;\n      }\n    };\n    List<JsContent> builder = Lists.newLinkedList(defaultCompiler.getJsContent(jsUri, bundle));\n\n    CompilerOptions options = getCompilerOptions(jsUri);\n    if (options.isExternExportsEnabled()) {\n      List<String> exports = Lists.newArrayList(bundle.getApis(ApiDirective.Type.JS, true));\n      Collections.sort(exports);\n      String prevExport = null;\n      for (String export : exports) {\n        if (!export.equals(prevExport)) {\n          builder.add(JsContent.fromText(\n              \"goog.exportSymbol('\" + StringEscapeUtils.escapeEcmaScript(export) +\n              \"', \" + export + \");\\n\", \"[export-symbol]\"));\n          prevExport = export;\n        }\n      }\n    }\n    return builder;\n  }\n\n  protected String makeCacheKey(String code, String externs, JsUri uri, CompilerOptions options) {\n    // TODO: include compilation options in the cache key\n    return Joiner.on(\":\").join(\n        HashUtil.checksum(code.getBytes()),\n        HashUtil.checksum(externs.getBytes()),\n        uri.getCompileMode(),\n        uri.isDebug(),\n        options.isExternExportsEnabled());\n  }\n\n  private static ErrorManager getErrorManager() {\n    return new BasicErrorManager() {\n      @Override\n      protected void printSummary() { /* Do nothing */ }\n      @Override\n      public void println(CheckLevel checkLevel, JSError jsError) { /* Do nothing */ }\n    };\n  }\n\n  private class CompilerException extends Exception {\n    private static final long serialVersionUID = 1L;\n    private final JSError[] errors;\n    public CompilerException(JSError[] errors) {\n      this.errors = errors;\n    }\n\n    public List<String> getErrors() {\n      ImmutableList.Builder<String> builder = ImmutableList.builder();\n      for (JSError error : errors) {\n        builder.add(error.toString());\n      };\n\n      return builder.build();\n    }\n  }\n}\n","lineNo":174}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.server.endtoend;\n\nimport java.io.IOException;\nimport java.util.Set;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.shindig.common.servlet.InjectedFilter;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.features.FeatureRegistry;\nimport org.apache.shindig.gadgets.features.FeatureRegistryProvider;\n\nimport com.google.common.base.Joiner;\nimport com.google.inject.Inject;\n\npublic class AllJsFilter extends InjectedFilter {\n\n  private String allFeatures;\n\n  @Inject\n  public void setFeatureRegistryProvider(FeatureRegistryProvider provider) {\n    try {\n      FeatureRegistry registry = provider.get(null);\n      Set<String> allFeatureNames = registry.getAllFeatureNames();\n      allFeatures = Joiner.on(':').join(allFeatureNames);\n    } catch (GadgetException e) {\n      e.printStackTrace();\n    }\n  }\n\n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n          throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest && response instanceof HttpServletResponse)) {\n      throw new ServletException(\"Only HTTP!\");\n    }\n\n    HttpServletRequest req = (HttpServletRequest) request;\n    HttpServletResponse resp = (HttpServletResponse) response;\n\n    String requestURI = req.getRequestURI();\n    if (!requestURI.contains(\"all-features-please.js\")) {\n      chain.doFilter(request, response);\n    } else {\n      String newURI = requestURI.replace(\"all-features-please.js\", allFeatures + \".js\") + \"?\" + req.getQueryString();\n      resp.sendRedirect(newURI);\n    }\n  }\n\n  public void destroy() {\n  }\n}\n\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.server.endtoend;\n\nimport java.io.IOException;\nimport java.util.Set;\nimport java.util.HashSet;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.shindig.common.servlet.InjectedFilter;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.features.FeatureRegistry;\nimport org.apache.shindig.gadgets.features.FeatureRegistryProvider;\n\nimport com.google.common.base.Joiner;\nimport com.google.inject.Inject;\n\npublic class AllJsFilter extends InjectedFilter {\n\n  private String allFeatures;\n\n  @Inject\n  public void setFeatureRegistryProvider(FeatureRegistryProvider provider) {\n    try {\n      FeatureRegistry registry = provider.get(null);\n      Set<String> allFeatureNames = registry.getAllFeatureNames();\n\n      // TODO(felix8a): Temporary hack for caja\n      HashSet<String> someFeatureNames = new HashSet<String>(allFeatureNames);\n      someFeatureNames.remove(\"es53-guest-frame\");\n      someFeatureNames.remove(\"es53-guest-frame.opt\");\n      someFeatureNames.remove(\"es53-taming-frame\");\n      someFeatureNames.remove(\"es53-taming-frame.opt\");\n\n      allFeatures = Joiner.on(':').join(someFeatureNames);\n    } catch (GadgetException e) {\n      e.printStackTrace();\n    }\n  }\n\n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n          throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest && response instanceof HttpServletResponse)) {\n      throw new ServletException(\"Only HTTP!\");\n    }\n\n    HttpServletRequest req = (HttpServletRequest) request;\n    HttpServletResponse resp = (HttpServletResponse) response;\n\n    String requestURI = req.getRequestURI();\n    if (!requestURI.contains(\"all-features-please.js\")) {\n      chain.doFilter(request, response);\n    } else {\n      String newURI = requestURI.replace(\"all-features-please.js\", allFeatures + \".js\") + \"?\" + req.getQueryString();\n      resp.sendRedirect(newURI);\n    }\n  }\n\n  public void destroy() {\n  }\n}\n\n","lineNo":51}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth2.persistence.sample;\n\nimport java.util.Collection;\nimport java.util.HashSet;\n\nimport org.apache.shindig.gadgets.oauth2.BasicOAuth2Accessor;\nimport org.apache.shindig.gadgets.oauth2.MockUtils;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Accessor;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Message;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Store;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Token;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2TokenPersistence;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class InMemoryCacheTest extends MockUtils {\n\n  private InMemoryCache cache;\n\n  @Before\n  public void setUp() throws Exception {\n    this.cache = new InMemoryCache();\n    Assert.assertNotNull(this.cache);\n    Assert.assertTrue(OAuth2Cache.class.isInstance(this.cache));\n\n    this.cache.storeClient(MockUtils.getClient_Code_Confidential());\n    this.cache.storeClient(MockUtils.getClient_Code_Public());\n\n    this.cache.storeToken(MockUtils.getAccessToken());\n    this.cache.storeToken(MockUtils.getRefreshToken());\n\n    this.cache.storeOAuth2Accessor(MockUtils.getOAuth2Accessor_Code());\n    this.cache.storeOAuth2Accessor(MockUtils.getOAuth2Accessor_Error());\n  }\n\n  @Test\n  public void testClearClients_1() throws Exception {\n    Assert.assertNotNull(this.cache.getClient(MockUtils.CLIENT_INDEX1));\n\n    this.cache.clearClients();\n\n    Assert.assertNull(this.cache.getClient(MockUtils.CLIENT_INDEX1));\n  }\n\n  @Test\n  public void testClearTokens_1() throws Exception {\n    Assert.assertNotNull(this.cache.getToken(MockUtils.ACCESS_TOKEN_INDEX));\n\n    this.cache.clearTokens();\n\n    Assert.assertNull(this.cache.getToken(MockUtils.ACCESS_TOKEN_INDEX));\n  }\n\n  @Test\n  public void testGetClient_1() throws Exception {\n    final OAuth2Client result = this.cache.getClient(MockUtils.CLIENT_INDEX1);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.CLIENT_ID1, result.getClientId());\n  }\n\n  @Test\n  public void testGetClientIndex_1() throws Exception {\n\n    final Integer result = this.cache.getClientIndex(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.CLIENT_INDEX1, result);\n  }\n\n  @Test\n  public void testGetOAuth2Accessor_1() throws Exception {\n    final OAuth2Accessor result = this.cache.getOAuth2Accessor(MockUtils.ACCESSOR_INDEX1);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.CLIENT_ID1, result.getClientId());\n  }\n\n  @Test\n  public void testGetOAuth2Accessor_2() throws Exception {\n    final OAuth2Accessor result = this.cache.getOAuth2Accessor(null);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testGetOAuth2Accessor_3() throws Exception {\n    final OAuth2Accessor result = this.cache.getOAuth2Accessor(MockUtils.BAD_INDEX);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testGetOAuth2AccessorIndex_1() throws Exception {\n\n    final Integer result = this.cache.getOAuth2AccessorIndex(MockUtils.GADGET_URI1,\n        MockUtils.SERVICE_NAME, MockUtils.USER, MockUtils.SCOPE);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.ACCESSOR_INDEX1, result);\n  }\n\n  @Test\n  public void testGetToken_1() throws Exception {\n    final OAuth2Token result = this.cache.getToken(MockUtils.ACCESS_TOKEN_INDEX);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.ACCESS_SECRET, new String(result.getSecret(), \"UTF-8\"));\n  }\n\n  @Test\n  public void testGetTokenMockUtilsIndex_1() throws Exception {\n    final Integer result = this.cache.getTokenIndex(MockUtils.getAccessToken());\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.ACCESS_TOKEN_INDEX, result);\n  }\n\n  @Test\n  public void testGetTokenIndex_2() throws Exception {\n\n    final OAuth2Token token = null;\n\n    final Integer result = this.cache.getTokenIndex(token);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testGetTokenIndex_3() throws Exception {\n\n    final Integer result = this.cache.getTokenIndex(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME,\n        MockUtils.USER, MockUtils.SCOPE, OAuth2Token.Type.ACCESS);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.ACCESS_TOKEN_INDEX, result);\n  }\n\n  @Test\n  public void testRemoveClient_1() throws Exception {\n\n    OAuth2Client result = this.cache.getClient(MockUtils.CLIENT_INDEX1);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeClient(MockUtils.CLIENT_INDEX1);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeClient(MockUtils.CLIENT_INDEX1);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testRemoveOAuth2Accessor_1() throws Exception {\n\n    final OAuth2Accessor result = this.cache.removeOAuth2Accessor(MockUtils.BAD_INDEX);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testRemoveToken_1() throws Exception {\n\n    OAuth2Token result = this.cache.getToken(MockUtils.ACCESS_TOKEN_INDEX);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeToken(MockUtils.ACCESS_TOKEN_INDEX);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeToken(MockUtils.ACCESS_TOKEN_INDEX);\n\n    Assert.assertNull(result);\n\n  }\n\n  @Test\n  public void testStoreClient_1() throws Exception {\n\n    OAuth2Client client = new OAuth2Client(MockUtils.getDummyEncrypter());\n    client.setGadgetUri(\"xxx\");\n    client.setServiceName(\"yyy\");\n\n    final Integer result = this.cache.storeClient(client);\n\n    Assert.assertEquals(909248813, result.intValue());\n\n    client = this.cache.getClient(result);\n\n    Assert.assertNotNull(client);\n    Assert.assertEquals(\"xxx\", client.getGadgetUri());\n    Assert.assertEquals(\"yyy\", client.getServiceName());\n  }\n\n  @Test\n  public void testStoreClient_2() throws Exception {\n\n    final OAuth2Client client = null;\n\n    final Integer result = this.cache.storeClient(client);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testStoreClients_1() throws Exception {\n\n    this.cache.clearClients();\n\n    final Collection<OAuth2Client> clients = new HashSet<OAuth2Client>();\n    clients.add(MockUtils.getClient_Code_Confidential());\n    clients.add(MockUtils.getClient_Code_Public());\n\n    this.cache.storeClients(clients);\n\n    Assert.assertNotNull(this.cache.getClient(MockUtils.CLIENT_INDEX1));\n    Assert.assertNotNull(this.cache.getClient(MockUtils.CLIENT_INDEX2));\n  }\n\n  @Test\n  public void testStoreOAuth2Accessor_1() throws Exception {\n    final OAuth2Store store = MockUtils.getDummyStore(this.cache, null, null);\n    OAuth2Accessor accessor = new BasicOAuth2Accessor(\"XXX\", \"YYY\", \"ZZZ\", \"\", false, store, \"AAA\");\n\n    final Integer result = this.cache.storeOAuth2Accessor(accessor);\n\n    Assert.assertEquals(-1664180105, result.intValue());\n\n    accessor = this.cache.getOAuth2Accessor(result);\n\n    Assert.assertNotNull(accessor);\n    Assert.assertEquals(\"XXX\", accessor.getGadgetUri());\n    Assert.assertEquals(\"YYY\", accessor.getServiceName());\n    Assert.assertEquals(\"ZZZ\", accessor.getUser());\n    Assert.assertEquals(\"\", accessor.getScope());\n    Assert.assertEquals(false, accessor.isAllowModuleOverrides());\n    Assert.assertEquals(\"AAA\", accessor.getRedirectUri());\n    Assert.assertEquals(\"-1664180105\", accessor.getState());\n  }\n\n  @Test\n  public void testStoreOAuth2Accessor_2() throws Exception {\n\n    final OAuth2Accessor accessor = null;\n\n    final Integer result = this.cache.storeOAuth2Accessor(accessor);\n\n    Assert.assertEquals(null, result);\n  }\n\n  @Test\n  public void testStoreToken_1() throws Exception {\n    OAuth2Token token = new OAuth2TokenPersistence(MockUtils.getDummyEncrypter());\n    token.setGadgetUri(\"xxx\");\n    token.setServiceName(\"yyy\");\n    token.setExpiresAt(2);\n    token.setIssuedAt(1);\n    token.setMacAlgorithm(OAuth2Message.HMAC_SHA_1);\n    token.setMacSecret(\"shh, it's a secret\".getBytes(\"UTF-8\"));\n    token.setScope(\"mac_scope\");\n    token.setSecret(\"i'll never tell\".getBytes(\"UTF-8\"));\n    token.setTokenType(OAuth2Message.MAC_TOKEN_TYPE);\n    token.setType(OAuth2Token.Type.ACCESS);\n    token.setUser(\"zzz\");\n\n    final Integer result = this.cache.storeToken(token);\n\n    Assert.assertEquals(460203885, result.intValue());\n\n    token = this.cache.getToken(result);\n\n    Assert.assertNotNull(token);\n    Assert.assertEquals(\"xxx\", token.getGadgetUri());\n    Assert.assertEquals(\"yyy\", token.getServiceName());\n\n    Assert.assertEquals(2, token.getExpiresAt());\n    Assert.assertEquals(1, token.getIssuedAt());\n    Assert.assertEquals(OAuth2Message.HMAC_SHA_1, token.getMacAlgorithm());\n    Assert.assertEquals(\"shh, it's a secret\", new String(token.getMacSecret(), \"UTF-8\"));\n    Assert.assertEquals(\"mac_scope\", token.getScope());\n    Assert.assertEquals(\"i'll never tell\", new String(token.getSecret(), \"UTF-8\"));\n    Assert.assertEquals(OAuth2Message.MAC_TOKEN_TYPE, token.getTokenType());\n    Assert.assertEquals(OAuth2Token.Type.ACCESS, token.getType());\n    Assert.assertEquals(\"zzz\", token.getUser());\n  }\n\n  @Test\n  public void testStoreToken_2() throws Exception {\n\n    final OAuth2Token token = null;\n\n    final Integer result = this.cache.storeToken(token);\n\n    Assert.assertEquals(null, result);\n  }\n\n  @Test\n  public void testStoreTokens_1() throws Exception {\n    this.cache.clearTokens();\n\n    final Collection<OAuth2Token> tokens = new HashSet<OAuth2Token>(2);\n    tokens.add(MockUtils.getAccessToken());\n    tokens.add(MockUtils.getRefreshToken());\n\n    this.cache.storeTokens(tokens);\n\n    Assert.assertNotNull(this.cache.getToken(MockUtils.ACCESS_TOKEN_INDEX));\n    Assert.assertNotNull(this.cache.getToken(MockUtils.REFRESH_TOKEN_INDEX));\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth2.persistence.sample;\n\nimport org.apache.shindig.gadgets.oauth2.BasicOAuth2Accessor;\nimport org.apache.shindig.gadgets.oauth2.MockUtils;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Accessor;\nimport org.apache.shindig.gadgets.oauth2.OAuth2CallbackState;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Message;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Store;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Token;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Token.Type;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2TokenPersistence;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.HashSet;\n\npublic class InMemoryCacheTest extends MockUtils {\n\n  private InMemoryCache cache;\n\n  @Before\n  public void setUp() throws Exception {\n    this.cache = new InMemoryCache();\n    Assert.assertNotNull(this.cache);\n    Assert.assertTrue(OAuth2Cache.class.isInstance(this.cache));\n\n    this.cache.storeClient(MockUtils.getClient_Code_Confidential());\n    this.cache.storeClient(MockUtils.getClient_Code_Public());\n\n    this.cache.storeToken(MockUtils.getAccessToken());\n    this.cache.storeToken(MockUtils.getRefreshToken());\n\n    this.cache.storeOAuth2Accessor(MockUtils.getOAuth2Accessor_Code());\n    this.cache.storeOAuth2Accessor(MockUtils.getOAuth2Accessor_Error());\n  }\n\n  @Test\n  public void testClearClients_1() throws Exception {\n    Assert.assertNotNull(this.cache.getClient(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME));\n\n    this.cache.clearClients();\n\n    Assert.assertNull(this.cache.getClient(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME));\n  }\n\n  @Test\n  public void testClearTokens_1() throws Exception {\n    Assert.assertNotNull(this.cache.getToken(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME,\n            MockUtils.USER, MockUtils.SCOPE, Type.ACCESS));\n\n    this.cache.clearTokens();\n\n    Assert.assertNull(this.cache.getToken(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME,\n            MockUtils.USER, MockUtils.SCOPE, Type.ACCESS));\n  }\n\n  @Test\n  public void testGetClient_1() throws Exception {\n    final OAuth2Client result = this.cache.getClient(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.CLIENT_ID1, result.getClientId());\n  }\n\n  @Test\n  public void testGetOAuth2Accessor_1() throws Exception {\n    final OAuth2Accessor accessor = MockUtils.getOAuth2Accessor_Code();\n\n    final OAuth2CallbackState state = new OAuth2CallbackState(MockUtils.getDummyStateCrypter());\n    state.setGadgetUri(accessor.getGadgetUri());\n    state.setServiceName(accessor.getServiceName());\n    state.setUser(accessor.getUser());\n    state.setScope(accessor.getScope());\n\n    final OAuth2Accessor result = this.cache.getOAuth2Accessor(state);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.CLIENT_ID1, result.getClientId());\n  }\n\n  @Test\n  public void testGetOAuth2Accessor_3() throws Exception {\n    final OAuth2CallbackState state = new OAuth2CallbackState(MockUtils.getDummyStateCrypter());\n    state.setGadgetUri(\"BAD\");\n    state.setServiceName(\"BAD\");\n    state.setUser(\"BAD\");\n    state.setScope(\"BAD\");\n    final OAuth2Accessor result = this.cache.getOAuth2Accessor(state);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testGetToken_1() throws Exception {\n    final OAuth2Token result = this.cache.getToken(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME,\n            MockUtils.USER, MockUtils.SCOPE, Type.ACCESS);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.ACCESS_SECRET, new String(result.getSecret(), \"UTF-8\"));\n  }\n\n  @Test\n  public void testRemoveClient_1() throws Exception {\n\n    OAuth2Client result = this.cache.getClient(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeClient(result);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeClient(result);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testRemoveToken_1() throws Exception {\n\n    OAuth2Token result = this.cache.getToken(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME,\n            MockUtils.USER, MockUtils.SCOPE, Type.ACCESS);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeToken(result);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeToken(result);\n\n    Assert.assertNull(result);\n\n  }\n\n  @Test\n  public void testStoreClient_1() throws Exception {\n\n    OAuth2Client client = new OAuth2Client(MockUtils.getDummyEncrypter());\n    client.setGadgetUri(\"xxx\");\n    client.setServiceName(\"yyy\");\n\n    this.cache.storeClient(client);\n\n    client = this.cache.getClient(client.getGadgetUri(), client.getServiceName());\n\n    Assert.assertNotNull(client);\n    Assert.assertEquals(\"xxx\", client.getGadgetUri());\n    Assert.assertEquals(\"yyy\", client.getServiceName());\n  }\n\n  @Test\n  public void testStoreClients_1() throws Exception {\n\n    this.cache.clearClients();\n\n    final Collection<OAuth2Client> clients = new HashSet<OAuth2Client>();\n    clients.add(MockUtils.getClient_Code_Confidential());\n    clients.add(MockUtils.getClient_Code_Public());\n\n    this.cache.storeClients(clients);\n\n    Assert.assertNotNull(this.cache.getClient(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME));\n    Assert.assertNotNull(this.cache.getClient(MockUtils.GADGET_URI2, MockUtils.SERVICE_NAME));\n  }\n\n  @Test\n  public void testStoreOAuth2Accessor_1() throws Exception {\n    final OAuth2Store store = MockUtils.getDummyStore(this.cache, null, null, null, null, null,\n            null);\n    OAuth2Accessor accessor = new BasicOAuth2Accessor(\"XXX\", \"YYY\", \"ZZZ\", \"\", false, store, \"AAA\",\n            null, null);\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    final OAuth2CallbackState state = new OAuth2CallbackState(MockUtils.getDummyStateCrypter());\n    state.setGadgetUri(accessor.getGadgetUri());\n    state.setServiceName(accessor.getServiceName());\n    state.setUser(accessor.getUser());\n    state.setScope(accessor.getScope());\n    accessor = this.cache.getOAuth2Accessor(state);\n\n    Assert.assertNotNull(accessor);\n    Assert.assertEquals(\"XXX\", accessor.getGadgetUri());\n    Assert.assertEquals(\"YYY\", accessor.getServiceName());\n    Assert.assertEquals(\"ZZZ\", accessor.getUser());\n    Assert.assertEquals(\"\", accessor.getScope());\n    Assert.assertEquals(false, accessor.isAllowModuleOverrides());\n    Assert.assertEquals(\"AAA\", accessor.getRedirectUri());\n  }\n\n  @Test\n  public void testStoreToken_1() throws Exception {\n    OAuth2Token token = new OAuth2TokenPersistence(MockUtils.getDummyEncrypter());\n    token.setGadgetUri(\"xxx\");\n    token.setServiceName(\"yyy\");\n    token.setExpiresAt(2);\n    token.setIssuedAt(1);\n    token.setMacAlgorithm(OAuth2Message.HMAC_SHA_1);\n    token.setMacSecret(\"shh, it's a secret\".getBytes(\"UTF-8\"));\n    token.setScope(\"mac_scope\");\n    token.setSecret(\"i'll never tell\".getBytes(\"UTF-8\"));\n    token.setTokenType(OAuth2Message.MAC_TOKEN_TYPE);\n    token.setType(OAuth2Token.Type.ACCESS);\n    token.setUser(\"zzz\");\n\n    this.cache.storeToken(token);\n\n    token = this.cache.getToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n            token.getScope(), token.getType());\n\n    Assert.assertNotNull(token);\n    Assert.assertEquals(\"xxx\", token.getGadgetUri());\n    Assert.assertEquals(\"yyy\", token.getServiceName());\n\n    Assert.assertEquals(2, token.getExpiresAt());\n    Assert.assertEquals(1, token.getIssuedAt());\n    Assert.assertEquals(OAuth2Message.HMAC_SHA_1, token.getMacAlgorithm());\n    Assert.assertEquals(\"shh, it's a secret\", new String(token.getMacSecret(), \"UTF-8\"));\n    Assert.assertEquals(\"mac_scope\", token.getScope());\n    Assert.assertEquals(\"i'll never tell\", new String(token.getSecret(), \"UTF-8\"));\n    Assert.assertEquals(OAuth2Message.MAC_TOKEN_TYPE, token.getTokenType());\n    Assert.assertEquals(OAuth2Token.Type.ACCESS, token.getType());\n    Assert.assertEquals(\"zzz\", token.getUser());\n  }\n\n  @Test\n  public void testStoreTokens_1() throws Exception {\n    this.cache.clearTokens();\n\n    final Collection<OAuth2Token> tokens = new HashSet<OAuth2Token>(2);\n\n    final OAuth2Token accessToken = MockUtils.getAccessToken();\n    final OAuth2Token refreshToken = MockUtils.getRefreshToken();\n\n    tokens.add(accessToken);\n    tokens.add(refreshToken);\n\n    this.cache.storeTokens(tokens);\n\n    Assert.assertNotNull(this.cache.getToken(accessToken.getGadgetUri(),\n            accessToken.getServiceName(), accessToken.getUser(), accessToken.getScope(),\n            accessToken.getType()));\n    Assert.assertNotNull(this.cache.getToken(refreshToken.getGadgetUri(),\n            refreshToken.getServiceName(), refreshToken.getUser(), refreshToken.getScope(),\n            refreshToken.getType()));\n  }\n}\n","lineNo":256}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth2.persistence.sample;\n\nimport java.util.Collection;\nimport java.util.HashSet;\n\nimport org.apache.shindig.gadgets.oauth2.BasicOAuth2Accessor;\nimport org.apache.shindig.gadgets.oauth2.MockUtils;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Accessor;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Message;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Store;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Token;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2TokenPersistence;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class InMemoryCacheTest extends MockUtils {\n\n  private InMemoryCache cache;\n\n  @Before\n  public void setUp() throws Exception {\n    this.cache = new InMemoryCache();\n    Assert.assertNotNull(this.cache);\n    Assert.assertTrue(OAuth2Cache.class.isInstance(this.cache));\n\n    this.cache.storeClient(MockUtils.getClient_Code_Confidential());\n    this.cache.storeClient(MockUtils.getClient_Code_Public());\n\n    this.cache.storeToken(MockUtils.getAccessToken());\n    this.cache.storeToken(MockUtils.getRefreshToken());\n\n    this.cache.storeOAuth2Accessor(MockUtils.getOAuth2Accessor_Code());\n    this.cache.storeOAuth2Accessor(MockUtils.getOAuth2Accessor_Error());\n  }\n\n  @Test\n  public void testClearClients_1() throws Exception {\n    Assert.assertNotNull(this.cache.getClient(MockUtils.CLIENT_INDEX1));\n\n    this.cache.clearClients();\n\n    Assert.assertNull(this.cache.getClient(MockUtils.CLIENT_INDEX1));\n  }\n\n  @Test\n  public void testClearTokens_1() throws Exception {\n    Assert.assertNotNull(this.cache.getToken(MockUtils.ACCESS_TOKEN_INDEX));\n\n    this.cache.clearTokens();\n\n    Assert.assertNull(this.cache.getToken(MockUtils.ACCESS_TOKEN_INDEX));\n  }\n\n  @Test\n  public void testGetClient_1() throws Exception {\n    final OAuth2Client result = this.cache.getClient(MockUtils.CLIENT_INDEX1);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.CLIENT_ID1, result.getClientId());\n  }\n\n  @Test\n  public void testGetClientIndex_1() throws Exception {\n\n    final Integer result = this.cache.getClientIndex(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.CLIENT_INDEX1, result);\n  }\n\n  @Test\n  public void testGetOAuth2Accessor_1() throws Exception {\n    final OAuth2Accessor result = this.cache.getOAuth2Accessor(MockUtils.ACCESSOR_INDEX1);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.CLIENT_ID1, result.getClientId());\n  }\n\n  @Test\n  public void testGetOAuth2Accessor_2() throws Exception {\n    final OAuth2Accessor result = this.cache.getOAuth2Accessor(null);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testGetOAuth2Accessor_3() throws Exception {\n    final OAuth2Accessor result = this.cache.getOAuth2Accessor(MockUtils.BAD_INDEX);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testGetOAuth2AccessorIndex_1() throws Exception {\n\n    final Integer result = this.cache.getOAuth2AccessorIndex(MockUtils.GADGET_URI1,\n        MockUtils.SERVICE_NAME, MockUtils.USER, MockUtils.SCOPE);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.ACCESSOR_INDEX1, result);\n  }\n\n  @Test\n  public void testGetToken_1() throws Exception {\n    final OAuth2Token result = this.cache.getToken(MockUtils.ACCESS_TOKEN_INDEX);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.ACCESS_SECRET, new String(result.getSecret(), \"UTF-8\"));\n  }\n\n  @Test\n  public void testGetTokenMockUtilsIndex_1() throws Exception {\n    final Integer result = this.cache.getTokenIndex(MockUtils.getAccessToken());\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.ACCESS_TOKEN_INDEX, result);\n  }\n\n  @Test\n  public void testGetTokenIndex_2() throws Exception {\n\n    final OAuth2Token token = null;\n\n    final Integer result = this.cache.getTokenIndex(token);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testGetTokenIndex_3() throws Exception {\n\n    final Integer result = this.cache.getTokenIndex(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME,\n        MockUtils.USER, MockUtils.SCOPE, OAuth2Token.Type.ACCESS);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.ACCESS_TOKEN_INDEX, result);\n  }\n\n  @Test\n  public void testRemoveClient_1() throws Exception {\n\n    OAuth2Client result = this.cache.getClient(MockUtils.CLIENT_INDEX1);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeClient(MockUtils.CLIENT_INDEX1);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeClient(MockUtils.CLIENT_INDEX1);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testRemoveOAuth2Accessor_1() throws Exception {\n\n    final OAuth2Accessor result = this.cache.removeOAuth2Accessor(MockUtils.BAD_INDEX);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testRemoveToken_1() throws Exception {\n\n    OAuth2Token result = this.cache.getToken(MockUtils.ACCESS_TOKEN_INDEX);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeToken(MockUtils.ACCESS_TOKEN_INDEX);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeToken(MockUtils.ACCESS_TOKEN_INDEX);\n\n    Assert.assertNull(result);\n\n  }\n\n  @Test\n  public void testStoreClient_1() throws Exception {\n\n    OAuth2Client client = new OAuth2Client(MockUtils.getDummyEncrypter());\n    client.setGadgetUri(\"xxx\");\n    client.setServiceName(\"yyy\");\n\n    final Integer result = this.cache.storeClient(client);\n\n    Assert.assertEquals(909248813, result.intValue());\n\n    client = this.cache.getClient(result);\n\n    Assert.assertNotNull(client);\n    Assert.assertEquals(\"xxx\", client.getGadgetUri());\n    Assert.assertEquals(\"yyy\", client.getServiceName());\n  }\n\n  @Test\n  public void testStoreClient_2() throws Exception {\n\n    final OAuth2Client client = null;\n\n    final Integer result = this.cache.storeClient(client);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testStoreClients_1() throws Exception {\n\n    this.cache.clearClients();\n\n    final Collection<OAuth2Client> clients = new HashSet<OAuth2Client>();\n    clients.add(MockUtils.getClient_Code_Confidential());\n    clients.add(MockUtils.getClient_Code_Public());\n\n    this.cache.storeClients(clients);\n\n    Assert.assertNotNull(this.cache.getClient(MockUtils.CLIENT_INDEX1));\n    Assert.assertNotNull(this.cache.getClient(MockUtils.CLIENT_INDEX2));\n  }\n\n  @Test\n  public void testStoreOAuth2Accessor_1() throws Exception {\n    final OAuth2Store store = MockUtils.getDummyStore(this.cache, null, null);\n    OAuth2Accessor accessor = new BasicOAuth2Accessor(\"XXX\", \"YYY\", \"ZZZ\", \"\", false, store, \"AAA\");\n\n    final Integer result = this.cache.storeOAuth2Accessor(accessor);\n\n    Assert.assertEquals(-1664180105, result.intValue());\n\n    accessor = this.cache.getOAuth2Accessor(result);\n\n    Assert.assertNotNull(accessor);\n    Assert.assertEquals(\"XXX\", accessor.getGadgetUri());\n    Assert.assertEquals(\"YYY\", accessor.getServiceName());\n    Assert.assertEquals(\"ZZZ\", accessor.getUser());\n    Assert.assertEquals(\"\", accessor.getScope());\n    Assert.assertEquals(false, accessor.isAllowModuleOverrides());\n    Assert.assertEquals(\"AAA\", accessor.getRedirectUri());\n    Assert.assertEquals(\"-1664180105\", accessor.getState());\n  }\n\n  @Test\n  public void testStoreOAuth2Accessor_2() throws Exception {\n\n    final OAuth2Accessor accessor = null;\n\n    final Integer result = this.cache.storeOAuth2Accessor(accessor);\n\n    Assert.assertEquals(null, result);\n  }\n\n  @Test\n  public void testStoreToken_1() throws Exception {\n    OAuth2Token token = new OAuth2TokenPersistence(MockUtils.getDummyEncrypter());\n    token.setGadgetUri(\"xxx\");\n    token.setServiceName(\"yyy\");\n    token.setExpiresAt(2);\n    token.setIssuedAt(1);\n    token.setMacAlgorithm(OAuth2Message.HMAC_SHA_1);\n    token.setMacSecret(\"shh, it's a secret\".getBytes(\"UTF-8\"));\n    token.setScope(\"mac_scope\");\n    token.setSecret(\"i'll never tell\".getBytes(\"UTF-8\"));\n    token.setTokenType(OAuth2Message.MAC_TOKEN_TYPE);\n    token.setType(OAuth2Token.Type.ACCESS);\n    token.setUser(\"zzz\");\n\n    final Integer result = this.cache.storeToken(token);\n\n    Assert.assertEquals(460203885, result.intValue());\n\n    token = this.cache.getToken(result);\n\n    Assert.assertNotNull(token);\n    Assert.assertEquals(\"xxx\", token.getGadgetUri());\n    Assert.assertEquals(\"yyy\", token.getServiceName());\n\n    Assert.assertEquals(2, token.getExpiresAt());\n    Assert.assertEquals(1, token.getIssuedAt());\n    Assert.assertEquals(OAuth2Message.HMAC_SHA_1, token.getMacAlgorithm());\n    Assert.assertEquals(\"shh, it's a secret\", new String(token.getMacSecret(), \"UTF-8\"));\n    Assert.assertEquals(\"mac_scope\", token.getScope());\n    Assert.assertEquals(\"i'll never tell\", new String(token.getSecret(), \"UTF-8\"));\n    Assert.assertEquals(OAuth2Message.MAC_TOKEN_TYPE, token.getTokenType());\n    Assert.assertEquals(OAuth2Token.Type.ACCESS, token.getType());\n    Assert.assertEquals(\"zzz\", token.getUser());\n  }\n\n  @Test\n  public void testStoreToken_2() throws Exception {\n\n    final OAuth2Token token = null;\n\n    final Integer result = this.cache.storeToken(token);\n\n    Assert.assertEquals(null, result);\n  }\n\n  @Test\n  public void testStoreTokens_1() throws Exception {\n    this.cache.clearTokens();\n\n    final Collection<OAuth2Token> tokens = new HashSet<OAuth2Token>(2);\n    tokens.add(MockUtils.getAccessToken());\n    tokens.add(MockUtils.getRefreshToken());\n\n    this.cache.storeTokens(tokens);\n\n    Assert.assertNotNull(this.cache.getToken(MockUtils.ACCESS_TOKEN_INDEX));\n    Assert.assertNotNull(this.cache.getToken(MockUtils.REFRESH_TOKEN_INDEX));\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth2.persistence.sample;\n\nimport org.apache.shindig.gadgets.oauth2.BasicOAuth2Accessor;\nimport org.apache.shindig.gadgets.oauth2.MockUtils;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Accessor;\nimport org.apache.shindig.gadgets.oauth2.OAuth2CallbackState;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Message;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Store;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Token;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Token.Type;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2TokenPersistence;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.HashSet;\n\npublic class InMemoryCacheTest extends MockUtils {\n\n  private InMemoryCache cache;\n\n  @Before\n  public void setUp() throws Exception {\n    this.cache = new InMemoryCache();\n    Assert.assertNotNull(this.cache);\n    Assert.assertTrue(OAuth2Cache.class.isInstance(this.cache));\n\n    this.cache.storeClient(MockUtils.getClient_Code_Confidential());\n    this.cache.storeClient(MockUtils.getClient_Code_Public());\n\n    this.cache.storeToken(MockUtils.getAccessToken());\n    this.cache.storeToken(MockUtils.getRefreshToken());\n\n    this.cache.storeOAuth2Accessor(MockUtils.getOAuth2Accessor_Code());\n    this.cache.storeOAuth2Accessor(MockUtils.getOAuth2Accessor_Error());\n  }\n\n  @Test\n  public void testClearClients_1() throws Exception {\n    Assert.assertNotNull(this.cache.getClient(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME));\n\n    this.cache.clearClients();\n\n    Assert.assertNull(this.cache.getClient(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME));\n  }\n\n  @Test\n  public void testClearTokens_1() throws Exception {\n    Assert.assertNotNull(this.cache.getToken(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME,\n            MockUtils.USER, MockUtils.SCOPE, Type.ACCESS));\n\n    this.cache.clearTokens();\n\n    Assert.assertNull(this.cache.getToken(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME,\n            MockUtils.USER, MockUtils.SCOPE, Type.ACCESS));\n  }\n\n  @Test\n  public void testGetClient_1() throws Exception {\n    final OAuth2Client result = this.cache.getClient(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.CLIENT_ID1, result.getClientId());\n  }\n\n  @Test\n  public void testGetOAuth2Accessor_1() throws Exception {\n    final OAuth2Accessor accessor = MockUtils.getOAuth2Accessor_Code();\n\n    final OAuth2CallbackState state = new OAuth2CallbackState(MockUtils.getDummyStateCrypter());\n    state.setGadgetUri(accessor.getGadgetUri());\n    state.setServiceName(accessor.getServiceName());\n    state.setUser(accessor.getUser());\n    state.setScope(accessor.getScope());\n\n    final OAuth2Accessor result = this.cache.getOAuth2Accessor(state);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.CLIENT_ID1, result.getClientId());\n  }\n\n  @Test\n  public void testGetOAuth2Accessor_3() throws Exception {\n    final OAuth2CallbackState state = new OAuth2CallbackState(MockUtils.getDummyStateCrypter());\n    state.setGadgetUri(\"BAD\");\n    state.setServiceName(\"BAD\");\n    state.setUser(\"BAD\");\n    state.setScope(\"BAD\");\n    final OAuth2Accessor result = this.cache.getOAuth2Accessor(state);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testGetToken_1() throws Exception {\n    final OAuth2Token result = this.cache.getToken(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME,\n            MockUtils.USER, MockUtils.SCOPE, Type.ACCESS);\n\n    Assert.assertNotNull(result);\n    Assert.assertEquals(MockUtils.ACCESS_SECRET, new String(result.getSecret(), \"UTF-8\"));\n  }\n\n  @Test\n  public void testRemoveClient_1() throws Exception {\n\n    OAuth2Client result = this.cache.getClient(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeClient(result);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeClient(result);\n\n    Assert.assertNull(result);\n  }\n\n  @Test\n  public void testRemoveToken_1() throws Exception {\n\n    OAuth2Token result = this.cache.getToken(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME,\n            MockUtils.USER, MockUtils.SCOPE, Type.ACCESS);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeToken(result);\n\n    Assert.assertNotNull(result);\n\n    result = this.cache.removeToken(result);\n\n    Assert.assertNull(result);\n\n  }\n\n  @Test\n  public void testStoreClient_1() throws Exception {\n\n    OAuth2Client client = new OAuth2Client(MockUtils.getDummyEncrypter());\n    client.setGadgetUri(\"xxx\");\n    client.setServiceName(\"yyy\");\n\n    this.cache.storeClient(client);\n\n    client = this.cache.getClient(client.getGadgetUri(), client.getServiceName());\n\n    Assert.assertNotNull(client);\n    Assert.assertEquals(\"xxx\", client.getGadgetUri());\n    Assert.assertEquals(\"yyy\", client.getServiceName());\n  }\n\n  @Test\n  public void testStoreClients_1() throws Exception {\n\n    this.cache.clearClients();\n\n    final Collection<OAuth2Client> clients = new HashSet<OAuth2Client>();\n    clients.add(MockUtils.getClient_Code_Confidential());\n    clients.add(MockUtils.getClient_Code_Public());\n\n    this.cache.storeClients(clients);\n\n    Assert.assertNotNull(this.cache.getClient(MockUtils.GADGET_URI1, MockUtils.SERVICE_NAME));\n    Assert.assertNotNull(this.cache.getClient(MockUtils.GADGET_URI2, MockUtils.SERVICE_NAME));\n  }\n\n  @Test\n  public void testStoreOAuth2Accessor_1() throws Exception {\n    final OAuth2Store store = MockUtils.getDummyStore(this.cache, null, null, null, null, null,\n            null);\n    OAuth2Accessor accessor = new BasicOAuth2Accessor(\"XXX\", \"YYY\", \"ZZZ\", \"\", false, store, \"AAA\",\n            null, null);\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    final OAuth2CallbackState state = new OAuth2CallbackState(MockUtils.getDummyStateCrypter());\n    state.setGadgetUri(accessor.getGadgetUri());\n    state.setServiceName(accessor.getServiceName());\n    state.setUser(accessor.getUser());\n    state.setScope(accessor.getScope());\n    accessor = this.cache.getOAuth2Accessor(state);\n\n    Assert.assertNotNull(accessor);\n    Assert.assertEquals(\"XXX\", accessor.getGadgetUri());\n    Assert.assertEquals(\"YYY\", accessor.getServiceName());\n    Assert.assertEquals(\"ZZZ\", accessor.getUser());\n    Assert.assertEquals(\"\", accessor.getScope());\n    Assert.assertEquals(false, accessor.isAllowModuleOverrides());\n    Assert.assertEquals(\"AAA\", accessor.getRedirectUri());\n  }\n\n  @Test\n  public void testStoreToken_1() throws Exception {\n    OAuth2Token token = new OAuth2TokenPersistence(MockUtils.getDummyEncrypter());\n    token.setGadgetUri(\"xxx\");\n    token.setServiceName(\"yyy\");\n    token.setExpiresAt(2);\n    token.setIssuedAt(1);\n    token.setMacAlgorithm(OAuth2Message.HMAC_SHA_1);\n    token.setMacSecret(\"shh, it's a secret\".getBytes(\"UTF-8\"));\n    token.setScope(\"mac_scope\");\n    token.setSecret(\"i'll never tell\".getBytes(\"UTF-8\"));\n    token.setTokenType(OAuth2Message.MAC_TOKEN_TYPE);\n    token.setType(OAuth2Token.Type.ACCESS);\n    token.setUser(\"zzz\");\n\n    this.cache.storeToken(token);\n\n    token = this.cache.getToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n            token.getScope(), token.getType());\n\n    Assert.assertNotNull(token);\n    Assert.assertEquals(\"xxx\", token.getGadgetUri());\n    Assert.assertEquals(\"yyy\", token.getServiceName());\n\n    Assert.assertEquals(2, token.getExpiresAt());\n    Assert.assertEquals(1, token.getIssuedAt());\n    Assert.assertEquals(OAuth2Message.HMAC_SHA_1, token.getMacAlgorithm());\n    Assert.assertEquals(\"shh, it's a secret\", new String(token.getMacSecret(), \"UTF-8\"));\n    Assert.assertEquals(\"mac_scope\", token.getScope());\n    Assert.assertEquals(\"i'll never tell\", new String(token.getSecret(), \"UTF-8\"));\n    Assert.assertEquals(OAuth2Message.MAC_TOKEN_TYPE, token.getTokenType());\n    Assert.assertEquals(OAuth2Token.Type.ACCESS, token.getType());\n    Assert.assertEquals(\"zzz\", token.getUser());\n  }\n\n  @Test\n  public void testStoreTokens_1() throws Exception {\n    this.cache.clearTokens();\n\n    final Collection<OAuth2Token> tokens = new HashSet<OAuth2Token>(2);\n\n    final OAuth2Token accessToken = MockUtils.getAccessToken();\n    final OAuth2Token refreshToken = MockUtils.getRefreshToken();\n\n    tokens.add(accessToken);\n    tokens.add(refreshToken);\n\n    this.cache.storeTokens(tokens);\n\n    Assert.assertNotNull(this.cache.getToken(accessToken.getGadgetUri(),\n            accessToken.getServiceName(), accessToken.getUser(), accessToken.getScope(),\n            accessToken.getType()));\n    Assert.assertNotNull(this.cache.getToken(refreshToken.getGadgetUri(),\n            refreshToken.getServiceName(), refreshToken.getUser(), refreshToken.getScope(),\n            refreshToken.getType()));\n  }\n}\n","lineNo":257}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  The ASF licenses this file to You\n * under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.  For additional information regarding\n * copyright in this work, please see the NOTICE file in the top level\n * directory of this distribution.\n */\npackage org.apache.shindig.social.dataservice.integration;\n\nimport org.apache.shindig.protocol.model.Enum;\nimport org.apache.shindig.protocol.model.EnumImpl;\nimport org.apache.shindig.social.core.model.AddressImpl;\nimport org.apache.shindig.social.core.model.BodyTypeImpl;\nimport org.apache.shindig.social.core.model.ListFieldImpl;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.OrganizationImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.core.model.UrlImpl;\nimport org.apache.shindig.social.opensocial.model.Address;\nimport org.apache.shindig.social.opensocial.model.BodyType;\nimport org.apache.shindig.social.opensocial.model.Drinker;\nimport org.apache.shindig.social.opensocial.model.ListField;\nimport org.apache.shindig.social.opensocial.model.LookingFor;\nimport org.apache.shindig.social.opensocial.model.Name;\nimport org.apache.shindig.social.opensocial.model.NetworkPresence;\nimport org.apache.shindig.social.opensocial.model.Organization;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.model.Smoker;\nimport org.apache.shindig.social.opensocial.model.Url;\nimport org.apache.shindig.social.opensocial.util.XSDValidator;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.custommonkey.xmlunit.XMLUnit;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RestfulXmlPeopleTest extends AbstractLargeRestfulTests {\n  private Person canonical;\n\n  @Before\n  public void restfulxXmlPeopleTestBefore() throws Exception {\n\n    NameImpl name = new NameImpl(\"Sir Shin H. Digg Social Butterfly\");\n    name.setAdditionalName(\"H\");\n    name.setFamilyName(\"Digg\");\n    name.setGivenName(\"Shin\");\n    name.setHonorificPrefix(\"Sir\");\n    name.setHonorificSuffix(\"Social Butterfly\");\n    canonical = new PersonImpl(\"canonical\", \"Shin Digg\", name);\n\n    canonical.setAboutMe(\"I have an example of every piece of data\");\n    canonical.setActivities(Lists.newArrayList(\"Coding Shindig\"));\n\n    Address address = new AddressImpl(\n        \"PoBox 3565, 1 OpenStandards Way, Apache, CA\");\n    address.setCountry(\"US\");\n    address.setLatitude(28.3043F);\n    address.setLongitude(143.0859F);\n    address.setLocality(\"who knows\");\n    address.setPostalCode(\"12345\");\n    address.setRegion(\"Apache, CA\");\n    address.setStreetAddress(\"1 OpenStandards Way\");\n    address.setType(\"home\");\n    address.setFormatted(\"PoBox 3565, 1 OpenStandards Way, Apache, CA\");\n    canonical.setAddresses(Lists.newArrayList(address));\n\n    canonical.setAge(33);\n    BodyTypeImpl bodyType = new BodyTypeImpl();\n    bodyType.setBuild(\"svelte\");\n    bodyType.setEyeColor(\"blue\");\n    bodyType.setHairColor(\"black\");\n    bodyType.setHeight(1.84F); // meters as per spec\n    bodyType.setWeight(74F); // kg as per spec\n    canonical.setBodyType(bodyType);\n\n    canonical.setBooks(Lists.newArrayList(\"The Cathedral & the Bazaar\",\n        \"Catch 22\"));\n    canonical.setCars(Lists.newArrayList(\"beetle\", \"prius\"));\n    canonical.setChildren(\"3\");\n    AddressImpl location = new AddressImpl();\n    location.setLatitude(48.858193F);\n    location.setLongitude(2.29419F);\n    canonical.setCurrentLocation(location);\n\n    canonical.setBirthday(new Date());\n    canonical.setDrinker(new EnumImpl<Drinker>(Drinker.SOCIALLY));\n    ListField email = new ListFieldImpl(\"work\",\n        \"dev@shindig.apache.org\");\n    canonical.setEmails(Lists.newArrayList(email));\n\n    canonical.setEthnicity(\"developer\");\n    canonical.setFashion(\"t-shirts\");\n    canonical.setFood(Lists.newArrayList(\"sushi\", \"burgers\"));\n    canonical.setGender(Person.Gender.male);\n    canonical.setHappiestWhen(\"coding\");\n    canonical.setHasApp(true);\n    canonical\n        .setHeroes(Lists.newArrayList(\"Doug Crockford\", \"Charles Babbage\"));\n    canonical.setHumor(\"none to speak of\");\n    canonical.setInterests(Lists.newArrayList(\"PHP\", \"Java\"));\n    canonical.setJobInterests(\"will work for beer\");\n\n    Organization job1 = new OrganizationImpl();\n    job1.setAddress(new AddressImpl(\"1 Shindig Drive\"));\n    job1.setDescription(\"lots of coding\");\n    job1.setEndDate(new Date());\n    job1.setField(\"Software Engineering\");\n    job1.setName(\"Apache.com\");\n    job1.setSalary(\"$1000000000\");\n    job1.setStartDate(new Date());\n    job1.setSubField(\"Development\");\n    job1.setTitle(\"Grand PooBah\");\n    job1.setWebpage(\"http://shindig.apache.org/\");\n    job1.setType(\"job\");\n\n    Organization job2 = new OrganizationImpl();\n    job2.setAddress(new AddressImpl(\"1 Skid Row\"));\n    job2.setDescription(\"\");\n    job2.setEndDate(new Date());\n    job2.setField(\"College\");\n    job2.setName(\"School of hard Knocks\");\n    job2.setSalary(\"$100\");\n    job2.setStartDate(new Date());\n    job2.setSubField(\"Lab Tech\");\n    job2.setTitle(\"Gopher\");\n    job2.setWebpage(\"\");\n    job2.setType(\"job\");\n\n    canonical.setOrganizations(Lists.newArrayList(job1, job2));\n\n    canonical.setUpdated(new Date());\n    canonical.setLanguagesSpoken(Lists.newArrayList(\"English\", \"Dutch\",\n        \"Esperanto\"));\n    canonical.setLivingArrangement(\"in a house\");\n    org.apache.shindig.protocol.model.Enum<LookingFor> lookingForRandom = new EnumImpl<LookingFor>(\n        LookingFor.RANDOM, \"Random\");\n    Enum<LookingFor> lookingForNetworking = new EnumImpl<LookingFor>(\n        LookingFor.NETWORKING, \"Networking\");\n    canonical.setLookingFor(Lists.newArrayList(lookingForRandom,\n        lookingForNetworking));\n    canonical.setMovies(Lists.newArrayList(\"Iron Man\", \"Nosferatu\"));\n    canonical.setMusic(Lists.newArrayList(\"Chieftains\", \"Beck\"));\n    canonical.setNetworkPresence(new EnumImpl<NetworkPresence>(\n        NetworkPresence.ONLINE));\n    canonical.setNickname(\"diggy\");\n    canonical.setPets(\"dog,cat\");\n    canonical.setPhoneNumbers(Lists.<ListField> newArrayList(new ListFieldImpl(\n        \"work\", \"111-111-111\"), new ListFieldImpl(\"mobile\", \"999-999-999\")));\n\n    canonical.setPoliticalViews(\"open leaning\");\n    canonical.setProfileSong(new UrlImpl(\n        \"http://www.example.org/songs/OnlyTheLonely.mp3\", \"Feelin' blue\",\n        \"road\"));\n    canonical.setProfileVideo(new UrlImpl(\n        \"http://www.example.org/videos/Thriller.flv\", \"Thriller\", \"video\"));\n\n    canonical.setQuotes(Lists.newArrayList(\"I am therfore I code\", \"Doh!\"));\n    canonical.setRelationshipStatus(\"married to my job\");\n    canonical.setReligion(\"druidic\");\n    canonical.setRomance(\"twice a year\");\n    canonical.setScaredOf(\"COBOL\");\n    canonical.setSexualOrientation(\"north\");\n    canonical.setSmoker(new EnumImpl<Smoker>(Smoker.NO));\n    canonical.setSports(Lists.newArrayList(\"frisbee\", \"rugby\"));\n    canonical.setStatus(\"happy\");\n    canonical.setTags(Lists.newArrayList(\"C#\", \"JSON\", \"template\"));\n    canonical.setThumbnailUrl(\"http://www.example.org/pic/?id=1\");\n    canonical.setUtcOffset(-8L);\n    canonical.setTurnOffs(Lists.newArrayList(\"lack of unit tests\", \"cabbage\"));\n    canonical.setTurnOns(Lists.newArrayList(\"well document code\"));\n    canonical.setTvShows(Lists.newArrayList(\"House\", \"Battlestar Galactica\"));\n\n    canonical\n        .setUrls(Lists.<Url> newArrayList(new UrlImpl(\n            \"http://www.example.org/?id=1\", \"my profile\", \"Profile\"),\n            new UrlImpl(\"http://www.example.org/pic/?id=1\",\n                \"my awesome picture\", \"Thumbnail\")));\n\n  }\n\n  /**\n   * Expected response for john.doe's json:\n   *\n   * { 'entry' :\n   * { 'id' : 'john.doe',\n   * 'name' : {'formatted' : 'John Doe'},\n   * 'phoneNumbers' : [ { 'number' : '+33H000000000', 'type' : 'home'}, ],\n   * 'addresses' : [ {'formatted' : 'My home address'} ],\n   * 'emails' : [\n   *    { 'value' : 'john.doe@work.bar', 'type' : 'work'}, ]\n   *\n   * ... etc, etc for all fields in the person object } } TODO: Finish up this\n   * test and make refactor so that it is easier to read\n   *\n   * @throws Exception\n   *           if test encounters an error\n   */\n  @SuppressWarnings(\"boxing\")\n  @Test\n  public void testGetPersonJson() throws Exception {\n    // TODO(doll): Test all of the date fields\n\n    Map<String, String> extraParams = Maps.newHashMap();\n    StringBuilder allFieldsParam = new StringBuilder();\n    for (String allField : Person.Field.ALL_FIELDS) {\n      allFieldsParam.append(allField).append(',');\n    }\n    extraParams.put(\"fields\", allFieldsParam.toString());\n\n    // Currently, for Shindig {pid}/@all/{uid} == {uid}/@self\n    String resp = getResponse(\"/people/canonical/@self\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response/:person\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Node personNode = resultNodeList.item(0);\n\n    Map<String, List<Node>> childNodeMap = childNodesToNodeMap(personNode);\n    Map<String, List<String>> result = childNodesToMap(personNode);\n\n    assertStringField(result, canonical.getAboutMe(), Person.Field.ABOUT_ME);\n    assertStringListField(result, canonical.getActivities(),\n        Person.Field.ACTIVITIES);\n\n    List<Node> addressNodes = childNodeMap.get(Person.Field.ADDRESSES\n        .toString());\n    assertEquals(addressNodes.size(), canonical.getAddresses().size());\n    for (int i = 0; i < addressNodes.size(); i++) {\n      assertAddressField(canonical.getAddresses().get(i),\n          childNodesToMap(addressNodes.get(i)));\n    }\n\n    assertEquals(canonical.getAge().intValue(), Integer.parseInt(result.get(\n        Person.Field.AGE.toString()).get(0)));\n\n    Map<String, List<String>> bodyMap = childNodesToMap(childNodeMap.get(\n        Person.Field.BODY_TYPE.toString()).get(0));\n    BodyType body = canonical.getBodyType();\n\n    assertStringField(bodyMap, body.getBuild(), BodyType.Field.BUILD);\n    assertStringField(bodyMap, body.getEyeColor(), BodyType.Field.EYE_COLOR);\n    assertStringField(bodyMap, body.getHairColor(), BodyType.Field.HAIR_COLOR);\n    assertFloatField(bodyMap, body.getHeight(), BodyType.Field.HEIGHT);\n    assertFloatField(bodyMap, body.getWeight(), BodyType.Field.WEIGHT);\n\n    assertStringListField(result, canonical.getBooks(), Person.Field.BOOKS);\n    assertStringListField(result, canonical.getCars(), Person.Field.CARS);\n    assertStringField(result, canonical.getChildren(), Person.Field.CHILDREN);\n\n    Map<String, List<String>> currentLocation = childNodesToMap(childNodeMap\n        .get(Person.Field.CURRENT_LOCATION.toString()).get(0));\n    assertFloatField(currentLocation, canonical.getCurrentLocation()\n        .getLatitude(), Address.Field.LATITUDE);\n    assertFloatField(currentLocation, canonical.getCurrentLocation()\n        .getLongitude(), Address.Field.LONGITUDE);\n\n    assertStringField(result, canonical.getDisplayName(),\n        Person.Field.DISPLAY_NAME);\n\n    // assertLongField(result, canonical.getBirthday().getTime(),\n    // Person.Field.BIRTHDAY);\n    // assertEnumField(result, canonical.getDrinker(), Person.Field.DRINKER);\n\n    List<Node> emailArray = childNodeMap.get(Person.Field.EMAILS.toString());\n    assertEquals(1, emailArray.size());\n\n    for (int i = 0; i < canonical.getEmails().size(); i++) {\n      ListField expectedEmail = canonical.getEmails().get(i);\n      Map<String, List<String>> actualEmail = childNodesToMap(emailArray.get(i));\n\n      assertStringField(actualEmail, expectedEmail.getType(),\n          ListField.Field.TYPE);\n      assertStringField(actualEmail, expectedEmail.getValue(),\n          ListField.Field.VALUE);\n    }\n\n    assertStringField(result, canonical.getEthnicity(), Person.Field.ETHNICITY);\n    assertStringField(result, canonical.getFashion(), Person.Field.FASHION);\n    assertStringListField(result, canonical.getFood(), Person.Field.FOOD);\n    assertStringField(result, canonical.getGender().toString(),\n        Person.Field.GENDER);\n    assertStringField(result, canonical.getHappiestWhen(),\n        Person.Field.HAPPIEST_WHEN);\n    assertBooleanField(result, canonical.getHasApp(), Person.Field.HAS_APP);\n    assertStringListField(result, canonical.getHeroes(), Person.Field.HEROES);\n    assertStringField(result, canonical.getHumor(), Person.Field.HUMOR);\n    assertStringField(result, canonical.getId(), Person.Field.ID);\n    assertStringListField(result, canonical.getInterests(),\n        Person.Field.INTERESTS);\n    assertStringField(result, canonical.getJobInterests(),\n        Person.Field.JOB_INTERESTS);\n\n    assertOrganizationField(canonical.getOrganizations().get(0), childNodeMap\n        .get(Person.Field.ORGANIZATIONS.toString()).get(0));\n\n    assertStringListField(result, canonical.getLanguagesSpoken(),\n        Person.Field.LANGUAGES_SPOKEN);\n    // assertDateField(result, canonical.getUpdated(),\n    // Person.Field.LAST_UPDATED);\n    assertStringField(result, canonical.getLivingArrangement(),\n        Person.Field.LIVING_ARRANGEMENT);\n    assertListEnumField(childNodeMap, canonical.getLookingFor(),\n        Person.Field.LOOKING_FOR);\n    assertStringListField(result, canonical.getMovies(), Person.Field.MOVIES);\n    assertStringListField(result, canonical.getMusic(), Person.Field.MUSIC);\n\n    assertEquals(canonical.getName().getFormatted(), childNodesToMap(\n        childNodeMap.get(Person.Field.NAME.toString()).get(0)).get(\n        Name.Field.FORMATTED.toString()).get(0));\n\n    assertEnumField(childNodeMap, canonical.getNetworkPresence(),\n        Person.Field.NETWORKPRESENCE);\n    assertStringField(result, canonical.getNickname(), Person.Field.NICKNAME);\n    assertStringField(result, canonical.getPets(), Person.Field.PETS);\n\n    List<Node> phoneArray = childNodeMap.get(Person.Field.PHONE_NUMBERS\n        .toString());\n    assertEquals(canonical.getPhoneNumbers().size(), phoneArray.size());\n\n    for (int i = 0; i < canonical.getPhoneNumbers().size(); i++) {\n      ListField expectedPhone = canonical.getPhoneNumbers().get(i);\n      Map<String, List<String>> actualPhone = childNodesToMap(phoneArray.get(i));\n      assertEquals(expectedPhone.getType(), actualPhone.get(\n          ListField.Field.TYPE.toString()).get(0));\n      assertEquals(expectedPhone.getValue(), actualPhone.get(\n          ListField.Field.VALUE.toString()).get(0));\n    }\n\n    assertStringField(result, canonical.getPoliticalViews(),\n        Person.Field.POLITICAL_VIEWS);\n\n    assertUrlField(canonical.getProfileSong(), childNodesToMap(childNodeMap\n        .get(Person.Field.PROFILE_SONG.toString()).get(0)));\n    assertStringField(result, canonical.getProfileUrl(),\n        Person.Field.PROFILE_URL);\n    assertUrlField(canonical.getProfileVideo(), childNodesToMap(childNodeMap\n        .get(Person.Field.PROFILE_VIDEO.toString()).get(0)));\n\n    assertStringListField(result, canonical.getQuotes(), Person.Field.QUOTES);\n    assertStringField(result, canonical.getRelationshipStatus(),\n        Person.Field.RELATIONSHIP_STATUS);\n    assertStringField(result, canonical.getReligion(), Person.Field.RELIGION);\n    assertStringField(result, canonical.getRomance(), Person.Field.ROMANCE);\n    assertStringField(result, canonical.getScaredOf(), Person.Field.SCARED_OF);\n\n    assertStringField(result, canonical.getSexualOrientation(),\n        Person.Field.SEXUAL_ORIENTATION);\n    assertEnumField(childNodeMap, canonical.getSmoker(), Person.Field.SMOKER);\n    assertStringListField(result, canonical.getSports(), Person.Field.SPORTS);\n    assertStringField(result, canonical.getStatus(), Person.Field.STATUS);\n    assertStringListField(result, canonical.getTags(), Person.Field.TAGS);\n    assertStringField(result, canonical.getThumbnailUrl(),\n        Person.Field.THUMBNAIL_URL);\n    // TODO: time zone\n    assertStringListField(result, canonical.getTurnOffs(),\n        Person.Field.TURN_OFFS);\n    assertStringListField(result, canonical.getTurnOns(), Person.Field.TURN_ONS);\n    assertStringListField(result, canonical.getTvShows(), Person.Field.TV_SHOWS);\n  }\n\n  private void assertAddressField(Address expected,\n      Map<String, List<String>> actual) {\n    assertStringField(actual, expected.getCountry(), Address.Field.COUNTRY);\n    assertFloatField(actual, expected.getLatitude(), Address.Field.LATITUDE);\n    assertStringField(actual, expected.getLocality(), Address.Field.LOCALITY);\n    assertFloatField(actual, expected.getLongitude(), Address.Field.LONGITUDE);\n    assertStringField(actual, expected.getPostalCode(),\n        Address.Field.POSTAL_CODE);\n    assertStringField(actual, expected.getRegion(), Address.Field.REGION);\n    assertStringField(actual, expected.getStreetAddress(),\n        Address.Field.STREET_ADDRESS);\n    assertStringField(actual, expected.getType(), Address.Field.TYPE);\n    assertStringField(actual, expected.getFormatted(), Address.Field.FORMATTED);\n  }\n\n  private void assertUrlField(Url expected, Map<String, List<String>> actual) {\n    assertStringField(actual, expected.getValue(), Url.Field.VALUE);\n    assertStringField(actual, expected.getLinkText(), Url.Field.LINK_TEXT);\n    assertStringField(actual, expected.getType(), Url.Field.TYPE);\n  }\n\n  private void assertOrganizationField(Organization expected, Node orgNode) {\n    Map<String, List<String>> actual = childNodesToMap(orgNode);\n    Map<String, List<Node>> actualNode = childNodesToNodeMap(orgNode);\n    assertStringField(childNodesToMap(actualNode.get(\n        Organization.Field.ADDRESS.toString()).get(0)), expected.getAddress()\n        .getFormatted(), Address.Field.FORMATTED);\n    assertStringField(actual, expected.getDescription(),\n        Organization.Field.DESCRIPTION);\n    // assertDateField(actual, expected.getEndDate(),\n    // Organization.Field.END_DATE);\n    assertStringField(actual, expected.getField(), Organization.Field.FIELD);\n    assertStringField(actual, expected.getName(), Organization.Field.NAME);\n    assertStringField(actual, expected.getSalary(), Organization.Field.SALARY);\n    // assertDateField(actual, expected.getStartDate(),\n    // Organization.Field.START_DATE);\n    assertStringField(actual, expected.getSubField(),\n        Organization.Field.SUB_FIELD);\n    assertStringField(actual, expected.getTitle(), Organization.Field.TITLE);\n    assertStringField(actual, expected.getWebpage(), Organization.Field.WEBPAGE);\n    assertStringField(actual, expected.getType(), Organization.Field.TYPE);\n  }\n\n  private void assertBooleanField(Map<String, List<String>> result,\n      boolean expected, Object field) {\n    assertEquals(expected, Boolean.parseBoolean(result.get(field.toString())\n        .get(0)));\n  }\n\n  @SuppressWarnings(\"boxing\")\n  private void assertFloatField(Map<String, List<String>> result, Float expected, Object field) {\n    assertEquals(expected.floatValue(), Float.valueOf(result.get(field.toString()).get(0)), 0);\n  }\n\n  private void assertStringField(Map<String, List<String>> result,\n      String expected, Object field) {\n    List<String> v = result.get(field.toString());\n    String t;\n    if ( v == null || v.isEmpty()) {\n      if (expected == null ) {\n        return;\n      }\n      t = \"\";\n    } else {\n      t = v.get(0);\n    }\n    assertEquals(expected, t);\n  }\n\n  private void assertStringListField(Map<String, List<String>> result,\n      List<String> list, Person.Field field) {\n    assertEquals(list.size(), result.get(field.toString()).size());\n    for (int i = 0; i < list.size(); i++) {\n      assertEquals(list.get(i), result.get(field.toString()).get(i));\n    }\n  }\n\n  private void assertEnumField(Map<String, List<Node>> result, Enum<?> expected,\n      Person.Field field) {\n    Map<String, List<String>> actual = childNodesToMap(result.get(\n        field.toString()).get(0));\n    assertEquals(expected.getDisplayValue(), actual.get(\"displayValue\").get(0));\n    assertEquals(expected.getValue().toString(), actual.get(\"value\").get(0));\n  }\n\n  private void assertListEnumField(Map<String, List<Node>> result,\n      List<? extends Enum<? extends Enum.EnumKey>> expected, Person.Field field) {\n    List<Node> actual = result.get(field.toString());\n    for (int i = 0; i < actual.size(); i++) {\n      Map<String, List<String>> nm = childNodesToMap(actual.get(i));\n      assertEquals(expected.get(i).getDisplayValue(), nm.get(\"displayValue\")\n          .get(0));\n      assertEquals(expected.get(i).getValue().toString(), nm.get(\"value\")\n          .get(0));\n    }\n  }\n\n  /**\n   * Expected response for a list of people in json:\n   *\n   * { \"totalResults\" : 3,\n   *     \"startIndex\" : 0\n   *     \"entry\" : [ {<jane doe>}, // layed out like above\n   * {<george doe>}, {<maija m>}, ] }\n   *\n   * @throws Exception\n   *           if test encounters an error\n   */\n  @Test\n  public void testGetPeople() throws Exception {\n    Map<String, String> extraParams = Maps.newHashMap();\n    extraParams.put(\"sortBy\", \"name\");\n    extraParams.put(\"sortOrder\", null);\n    extraParams.put(\"filterBy\", null);\n    extraParams.put(\"startIndex\", null);\n    extraParams.put(\"count\", \"20\");\n    extraParams.put(\"fields\", null);\n\n    // Currently, for Shindig @all == @friends\n    String resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Map<String, List<String>> result = childNodesToMap(resultNodeList.item(0));\n    Map<String, List<Node>> resultNodes = childNodesToNodeMap(resultNodeList\n        .item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"0\", result.get(\"startIndex\").get(0));\n\n    // The users should be in alphabetical order\n    Map<String, List<Node>> entryOne = childNodesToNodeMap(resultNodes.get(\"entry\").get(0));\n\n    assertPerson(childNodesToNodeMap(entryOne.get(\"person\").get(0)),\n        \"george.doe\", \"George Doe\");\n\n    Map<String, List<Node>> entryTwo = childNodesToNodeMap(resultNodes.get(\"entry\").get(1));\n    assertPerson(childNodesToNodeMap(entryTwo.get(\"person\").get(0)),\n        \"jane.doe\", \"Jane Doe\");\n  }\n\n  @Test\n  public void testGetPeoplePagination() throws Exception {\n    Map<String, String> extraParams = Maps.newHashMap();\n    extraParams.put(\"sortBy\", \"name\");\n    extraParams.put(\"sortOrder\", null);\n    extraParams.put(\"filterBy\", null);\n    extraParams.put(\"startIndex\", \"0\");\n    extraParams.put(\"count\", \"1\");\n    extraParams.put(\"fields\", null);\n\n    String resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Map<String, List<String>> result = childNodesToMap(resultNodeList.item(0));\n    Map<String, List<Node>> resultNodes = childNodesToNodeMap(resultNodeList\n        .item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"0\", result.get(\"startIndex\").get(0));\n\n    Map<String, List<Node>> entryOne = childNodesToNodeMap(resultNodes.get(\"entry\").get(0));\n\n    assertPerson(childNodesToNodeMap(entryOne.get(\"person\").get(0)),\n        \"george.doe\", \"George Doe\");\n\n    // Get the second page\n    extraParams.put(\"startIndex\", \"1\");\n    resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams, \"xml\",\n        \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    result = childNodesToMap(resultNodeList.item(0));\n    resultNodes = childNodesToNodeMap(resultNodeList.item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"1\", result.get(\"startIndex\").get(0));\n\n    Map<String, List<Node>> entryTwo = childNodesToNodeMap(resultNodes.get(\"entry\").get(0));\n    assertPerson(childNodesToNodeMap(entryTwo.get(\"person\").get(0)),\n        \"jane.doe\", \"Jane Doe\");\n  }\n\n  private void assertPerson(Map<String, List<Node>> person, String expectedId,\n      String expectedName) throws Exception {\n    assertEquals(expectedId, person.get(\"id\").get(0).getTextContent());\n    assertEquals(expectedName, childNodesToMap(person.get(\"name\").get(0)).get(\n        \"formatted\").get(0));\n  }\n\n  // TODO: Add tests for fields parameter\n  // TODO: Add tests for networkDistance\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  The ASF licenses this file to You\n * under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.  For additional information regarding\n * copyright in this work, please see the NOTICE file in the top level\n * directory of this distribution.\n */\npackage org.apache.shindig.social.dataservice.integration;\n\nimport org.apache.shindig.protocol.model.Enum;\nimport org.apache.shindig.protocol.model.EnumImpl;\nimport org.apache.shindig.social.core.model.AddressImpl;\nimport org.apache.shindig.social.core.model.BodyTypeImpl;\nimport org.apache.shindig.social.core.model.ListFieldImpl;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.OrganizationImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.core.model.UrlImpl;\nimport org.apache.shindig.social.opensocial.model.Address;\nimport org.apache.shindig.social.opensocial.model.BodyType;\nimport org.apache.shindig.social.opensocial.model.Drinker;\nimport org.apache.shindig.social.opensocial.model.ListField;\nimport org.apache.shindig.social.opensocial.model.LookingFor;\nimport org.apache.shindig.social.opensocial.model.Name;\nimport org.apache.shindig.social.opensocial.model.NetworkPresence;\nimport org.apache.shindig.social.opensocial.model.Organization;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.model.Smoker;\nimport org.apache.shindig.social.opensocial.model.Url;\nimport org.apache.shindig.social.opensocial.util.XSDValidator;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.custommonkey.xmlunit.XMLUnit;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RestfulXmlPeopleTest extends AbstractLargeRestfulTests {\n  private Person canonical;\n\n  @Before\n  public void restfulxXmlPeopleTestBefore() throws Exception {\n\n    NameImpl name = new NameImpl(\"Sir Shin H. Digg Social Butterfly\");\n    name.setAdditionalName(\"H\");\n    name.setFamilyName(\"Digg\");\n    name.setGivenName(\"Shin\");\n    name.setHonorificPrefix(\"Sir\");\n    name.setHonorificSuffix(\"Social Butterfly\");\n    canonical = new PersonImpl(\"canonical\", \"Shin Digg\", name);\n\n    canonical.setAboutMe(\"I have an example of every piece of data\");\n    canonical.setActivities(Lists.newArrayList(\"Coding Shindig\"));\n\n    Address address = new AddressImpl(\n        \"PoBox 3565, 1 OpenStandards Way, Apache, CA\");\n    address.setCountry(\"US\");\n    address.setLatitude(28.3043F);\n    address.setLongitude(143.0859F);\n    address.setLocality(\"who knows\");\n    address.setPostalCode(\"12345\");\n    address.setRegion(\"Apache, CA\");\n    address.setStreetAddress(\"1 OpenStandards Way\");\n    address.setType(\"home\");\n    address.setFormatted(\"PoBox 3565, 1 OpenStandards Way, Apache, CA\");\n    canonical.setAddresses(Lists.newArrayList(address));\n\n    canonical.setAge(33);\n    BodyTypeImpl bodyType = new BodyTypeImpl();\n    bodyType.setBuild(\"svelte\");\n    bodyType.setEyeColor(\"blue\");\n    bodyType.setHairColor(\"black\");\n    bodyType.setHeight(1.84F); // meters as per spec\n    bodyType.setWeight(74F); // kg as per spec\n    canonical.setBodyType(bodyType);\n\n    canonical.setBooks(Lists.newArrayList(\"The Cathedral & the Bazaar\",\n        \"Catch 22\"));\n    canonical.setCars(Lists.newArrayList(\"beetle\", \"prius\"));\n    canonical.setChildren(\"3\");\n    AddressImpl location = new AddressImpl();\n    location.setLatitude(48.858193F);\n    location.setLongitude(2.29419F);\n    canonical.setCurrentLocation(location);\n\n    canonical.setBirthday(new Date());\n    canonical.setDrinker(new EnumImpl<Drinker>(Drinker.SOCIALLY));\n    ListField email = new ListFieldImpl(\"work\",\n        \"dev@shindig.apache.org\");\n    canonical.setEmails(Lists.newArrayList(email));\n\n    canonical.setEthnicity(\"developer\");\n    canonical.setFashion(\"t-shirts\");\n    canonical.setFood(Lists.newArrayList(\"sushi\", \"burgers\"));\n    canonical.setGender(Person.Gender.male);\n    canonical.setHappiestWhen(\"coding\");\n    canonical.setHasApp(true);\n    canonical\n        .setHeroes(Lists.newArrayList(\"Doug Crockford\", \"Charles Babbage\"));\n    canonical.setHumor(\"none to speak of\");\n    canonical.setInterests(Lists.newArrayList(\"PHP\", \"Java\"));\n    canonical.setJobInterests(\"will work for beer\");\n\n    Organization job1 = new OrganizationImpl();\n    job1.setAddress(new AddressImpl(\"1 Shindig Drive\"));\n    job1.setDescription(\"lots of coding\");\n    job1.setEndDate(new Date());\n    job1.setField(\"Software Engineering\");\n    job1.setName(\"Apache.com\");\n    job1.setSalary(\"$1000000000\");\n    job1.setStartDate(new Date());\n    job1.setSubField(\"Development\");\n    job1.setTitle(\"Grand PooBah\");\n    job1.setWebpage(\"http://shindig.apache.org/\");\n    job1.setType(\"job\");\n\n    Organization job2 = new OrganizationImpl();\n    job2.setAddress(new AddressImpl(\"1 Skid Row\"));\n    job2.setDescription(\"\");\n    job2.setEndDate(new Date());\n    job2.setField(\"College\");\n    job2.setName(\"School of hard Knocks\");\n    job2.setSalary(\"$100\");\n    job2.setStartDate(new Date());\n    job2.setSubField(\"Lab Tech\");\n    job2.setTitle(\"Gopher\");\n    job2.setWebpage(\"\");\n    job2.setType(\"job\");\n\n    canonical.setOrganizations(Lists.newArrayList(job1, job2));\n\n    canonical.setUpdated(new Date());\n    canonical.setLanguagesSpoken(Lists.newArrayList(\"English\", \"Dutch\",\n        \"Esperanto\"));\n    canonical.setLivingArrangement(\"in a house\");\n    org.apache.shindig.protocol.model.Enum<LookingFor> lookingForRandom = new EnumImpl<LookingFor>(\n        LookingFor.RANDOM, \"Random\");\n    Enum<LookingFor> lookingForNetworking = new EnumImpl<LookingFor>(\n        LookingFor.NETWORKING, \"Networking\");\n    canonical.setLookingFor(Lists.newArrayList(lookingForRandom,\n        lookingForNetworking));\n    canonical.setMovies(Lists.newArrayList(\"Iron Man\", \"Nosferatu\"));\n    canonical.setMusic(Lists.newArrayList(\"Chieftains\", \"Beck\"));\n    canonical.setNetworkPresence(new EnumImpl<NetworkPresence>(\n        NetworkPresence.ONLINE));\n    canonical.setNickname(\"diggy\");\n    canonical.setPets(\"dog,cat\");\n    canonical.setPhoneNumbers(Lists.<ListField> newArrayList(new ListFieldImpl(\n        \"work\", \"111-111-111\"), new ListFieldImpl(\"mobile\", \"999-999-999\")));\n\n    canonical.setPoliticalViews(\"open leaning\");\n    canonical.setProfileSong(new UrlImpl(\n        \"http://www.example.org/songs/OnlyTheLonely.mp3\", \"Feelin' blue\",\n        \"road\"));\n    canonical.setProfileVideo(new UrlImpl(\n        \"http://www.example.org/videos/Thriller.flv\", \"Thriller\", \"video\"));\n\n    canonical.setQuotes(Lists.newArrayList(\"I am therfore I code\", \"Doh!\"));\n    canonical.setRelationshipStatus(\"married to my job\");\n    canonical.setReligion(\"druidic\");\n    canonical.setRomance(\"twice a year\");\n    canonical.setScaredOf(\"COBOL\");\n    canonical.setSexualOrientation(\"north\");\n    canonical.setSmoker(new EnumImpl<Smoker>(Smoker.NO));\n    canonical.setSports(Lists.newArrayList(\"frisbee\", \"rugby\"));\n    canonical.setStatus(\"happy\");\n    canonical.setTags(Lists.newArrayList(\"C#\", \"JSON\", \"template\"));\n    canonical.setThumbnailUrl(\"http://www.example.org/pic/?id=1\");\n    canonical.setUtcOffset(-8L);\n    canonical.setTurnOffs(Lists.newArrayList(\"lack of unit tests\", \"cabbage\"));\n    canonical.setTurnOns(Lists.newArrayList(\"well document code\"));\n    canonical.setTvShows(Lists.newArrayList(\"House\", \"Battlestar Galactica\"));\n\n    canonical\n        .setUrls(Lists.<Url> newArrayList(new UrlImpl(\n            \"http://www.example.org/?id=1\", \"my profile\", \"Profile\"),\n            new UrlImpl(\"http://www.example.org/pic/?id=1\",\n                \"my awesome picture\", \"Thumbnail\")));\n\n  }\n\n  /**\n   * Expected response for john.doe's json:\n   *\n   * { 'entry' :\n   * { 'id' : 'john.doe',\n   * 'name' : {'formatted' : 'John Doe'},\n   * 'phoneNumbers' : [ { 'number' : '+33H000000000', 'type' : 'home'}, ],\n   * 'addresses' : [ {'formatted' : 'My home address'} ],\n   * 'emails' : [\n   *    { 'value' : 'john.doe@work.bar', 'type' : 'work'}, ]\n   *\n   * ... etc, etc for all fields in the person object } } TODO: Finish up this\n   * test and make refactor so that it is easier to read\n   *\n   * @throws Exception\n   *           if test encounters an error\n   */\n  @SuppressWarnings(\"boxing\")\n  @Test\n  public void testGetPersonJson() throws Exception {\n    // TODO(doll): Test all of the date fields\n\n    Map<String, String> extraParams = Maps.newHashMap();\n    StringBuilder allFieldsParam = new StringBuilder();\n    for (String allField : Person.Field.ALL_FIELDS) {\n      allFieldsParam.append(allField).append(',');\n    }\n    extraParams.put(\"fields\", allFieldsParam.toString());\n\n    // Currently, for Shindig {pid}/@all/{uid} == {uid}/@self\n    String resp = getResponse(\"/people/canonical/@self\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response/:person\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Node personNode = resultNodeList.item(0);\n\n    Map<String, List<Node>> childNodeMap = childNodesToNodeMap(personNode);\n    Map<String, List<String>> result = childNodesToMap(personNode);\n\n    assertStringField(result, canonical.getAboutMe(), Person.Field.ABOUT_ME);\n    assertStringListField(result, canonical.getActivities(),\n        Person.Field.ACTIVITIES);\n\n    List<Node> addressNodes = childNodeMap.get(Person.Field.ADDRESSES\n        .toString());\n    assertEquals(addressNodes.size(), canonical.getAddresses().size());\n    for (int i = 0; i < addressNodes.size(); i++) {\n      assertAddressField(canonical.getAddresses().get(i),\n          childNodesToMap(addressNodes.get(i)));\n    }\n\n    assertEquals(canonical.getAge().intValue(), Integer.parseInt(result.get(\n        Person.Field.AGE.toString()).get(0)));\n\n    Map<String, List<String>> bodyMap = childNodesToMap(childNodeMap.get(\n        Person.Field.BODY_TYPE.toString()).get(0));\n    BodyType body = canonical.getBodyType();\n\n    assertStringField(bodyMap, body.getBuild(), BodyType.Field.BUILD);\n    assertStringField(bodyMap, body.getEyeColor(), BodyType.Field.EYE_COLOR);\n    assertStringField(bodyMap, body.getHairColor(), BodyType.Field.HAIR_COLOR);\n    assertFloatField(bodyMap, body.getHeight(), BodyType.Field.HEIGHT);\n    assertFloatField(bodyMap, body.getWeight(), BodyType.Field.WEIGHT);\n\n    assertStringListField(result, canonical.getBooks(), Person.Field.BOOKS);\n    assertStringListField(result, canonical.getCars(), Person.Field.CARS);\n    assertStringField(result, canonical.getChildren(), Person.Field.CHILDREN);\n\n    Map<String, List<String>> currentLocation = childNodesToMap(childNodeMap\n        .get(Person.Field.CURRENT_LOCATION.toString()).get(0));\n    assertFloatField(currentLocation, canonical.getCurrentLocation()\n        .getLatitude(), Address.Field.LATITUDE);\n    assertFloatField(currentLocation, canonical.getCurrentLocation()\n        .getLongitude(), Address.Field.LONGITUDE);\n\n    assertStringField(result, canonical.getDisplayName(),\n        Person.Field.DISPLAY_NAME);\n\n    // assertLongField(result, canonical.getBirthday().getTime(),\n    // Person.Field.BIRTHDAY);\n    // assertEnumField(result, canonical.getDrinker(), Person.Field.DRINKER);\n\n    List<Node> emailArray = childNodeMap.get(Person.Field.EMAILS.toString());\n    assertEquals(1, emailArray.size());\n\n    for (int i = 0; i < canonical.getEmails().size(); i++) {\n      ListField expectedEmail = canonical.getEmails().get(i);\n      Map<String, List<String>> actualEmail = childNodesToMap(emailArray.get(i));\n\n      assertStringField(actualEmail, expectedEmail.getType(),\n          ListField.Field.TYPE);\n      assertStringField(actualEmail, expectedEmail.getValue(),\n          ListField.Field.VALUE);\n    }\n\n    assertStringField(result, canonical.getEthnicity(), Person.Field.ETHNICITY);\n    assertStringField(result, canonical.getFashion(), Person.Field.FASHION);\n    assertStringListField(result, canonical.getFood(), Person.Field.FOOD);\n    assertStringField(result, canonical.getGender().toString(),\n        Person.Field.GENDER);\n    assertStringField(result, canonical.getHappiestWhen(),\n        Person.Field.HAPPIEST_WHEN);\n    assertBooleanField(result, canonical.getHasApp(), Person.Field.HAS_APP);\n    assertStringListField(result, canonical.getHeroes(), Person.Field.HEROES);\n    assertStringField(result, canonical.getHumor(), Person.Field.HUMOR);\n    assertStringField(result, canonical.getId(), Person.Field.ID);\n    assertStringListField(result, canonical.getInterests(),\n        Person.Field.INTERESTS);\n    assertStringField(result, canonical.getJobInterests(),\n        Person.Field.JOB_INTERESTS);\n\n    assertOrganizationField(canonical.getOrganizations().get(0), childNodeMap\n        .get(Person.Field.ORGANIZATIONS.toString()).get(0));\n\n    assertStringListField(result, canonical.getLanguagesSpoken(),\n        Person.Field.LANGUAGES_SPOKEN);\n    // assertDateField(result, canonical.getUpdated(),\n    // Person.Field.LAST_UPDATED);\n    assertStringField(result, canonical.getLivingArrangement(),\n        Person.Field.LIVING_ARRANGEMENT);\n    assertListEnumField(childNodeMap, canonical.getLookingFor(),\n        Person.Field.LOOKING_FOR);\n    assertStringListField(result, canonical.getMovies(), Person.Field.MOVIES);\n    assertStringListField(result, canonical.getMusic(), Person.Field.MUSIC);\n\n    assertEquals(canonical.getName().getFormatted(), childNodesToMap(\n        childNodeMap.get(Person.Field.NAME.toString()).get(0)).get(\n        Name.Field.FORMATTED.toString()).get(0));\n\n    assertEnumField(childNodeMap, canonical.getNetworkPresence(),\n        Person.Field.NETWORKPRESENCE);\n    assertStringField(result, canonical.getNickname(), Person.Field.NICKNAME);\n    assertStringField(result, canonical.getPets(), Person.Field.PETS);\n\n    List<Node> phoneArray = childNodeMap.get(Person.Field.PHONE_NUMBERS\n        .toString());\n    assertEquals(canonical.getPhoneNumbers().size(), phoneArray.size());\n\n    for (int i = 0; i < canonical.getPhoneNumbers().size(); i++) {\n      ListField expectedPhone = canonical.getPhoneNumbers().get(i);\n      Map<String, List<String>> actualPhone = childNodesToMap(phoneArray.get(i));\n      assertEquals(expectedPhone.getType(), actualPhone.get(\n          ListField.Field.TYPE.toString()).get(0));\n      assertEquals(expectedPhone.getValue(), actualPhone.get(\n          ListField.Field.VALUE.toString()).get(0));\n    }\n\n    assertStringField(result, canonical.getPoliticalViews(),\n        Person.Field.POLITICAL_VIEWS);\n\n    assertUrlField(canonical.getProfileSong(), childNodesToMap(childNodeMap\n        .get(Person.Field.PROFILE_SONG.toString()).get(0)));\n    assertStringField(result, canonical.getProfileUrl(),\n        Person.Field.PROFILE_URL);\n    assertUrlField(canonical.getProfileVideo(), childNodesToMap(childNodeMap\n        .get(Person.Field.PROFILE_VIDEO.toString()).get(0)));\n\n    assertStringListField(result, canonical.getQuotes(), Person.Field.QUOTES);\n    assertStringField(result, canonical.getRelationshipStatus(),\n        Person.Field.RELATIONSHIP_STATUS);\n    assertStringField(result, canonical.getReligion(), Person.Field.RELIGION);\n    assertStringField(result, canonical.getRomance(), Person.Field.ROMANCE);\n    assertStringField(result, canonical.getScaredOf(), Person.Field.SCARED_OF);\n\n    assertStringField(result, canonical.getSexualOrientation(),\n        Person.Field.SEXUAL_ORIENTATION);\n    assertEnumField(childNodeMap, canonical.getSmoker(), Person.Field.SMOKER);\n    assertStringListField(result, canonical.getSports(), Person.Field.SPORTS);\n    assertStringField(result, canonical.getStatus(), Person.Field.STATUS);\n    assertStringListField(result, canonical.getTags(), Person.Field.TAGS);\n    assertStringField(result, canonical.getThumbnailUrl(),\n        Person.Field.THUMBNAIL_URL);\n    // TODO: time zone\n    assertStringListField(result, canonical.getTurnOffs(),\n        Person.Field.TURN_OFFS);\n    assertStringListField(result, canonical.getTurnOns(), Person.Field.TURN_ONS);\n    assertStringListField(result, canonical.getTvShows(), Person.Field.TV_SHOWS);\n  }\n\n  private void assertAddressField(Address expected,\n      Map<String, List<String>> actual) {\n    assertStringField(actual, expected.getCountry(), Address.Field.COUNTRY);\n    assertFloatField(actual, expected.getLatitude(), Address.Field.LATITUDE);\n    assertStringField(actual, expected.getLocality(), Address.Field.LOCALITY);\n    assertFloatField(actual, expected.getLongitude(), Address.Field.LONGITUDE);\n    assertStringField(actual, expected.getPostalCode(),\n        Address.Field.POSTAL_CODE);\n    assertStringField(actual, expected.getRegion(), Address.Field.REGION);\n    assertStringField(actual, expected.getStreetAddress(),\n        Address.Field.STREET_ADDRESS);\n    assertStringField(actual, expected.getType(), Address.Field.TYPE);\n    assertStringField(actual, expected.getFormatted(), Address.Field.FORMATTED);\n  }\n\n  private void assertUrlField(Url expected, Map<String, List<String>> actual) {\n    assertStringField(actual, expected.getValue(), Url.Field.VALUE);\n    assertStringField(actual, expected.getLinkText(), Url.Field.LINK_TEXT);\n    assertStringField(actual, expected.getType(), Url.Field.TYPE);\n  }\n\n  private void assertOrganizationField(Organization expected, Node orgNode) {\n    Map<String, List<String>> actual = childNodesToMap(orgNode);\n    Map<String, List<Node>> actualNode = childNodesToNodeMap(orgNode);\n    assertStringField(childNodesToMap(actualNode.get(\n        Organization.Field.ADDRESS.toString()).get(0)), expected.getAddress()\n        .getFormatted(), Address.Field.FORMATTED);\n    assertStringField(actual, expected.getDescription(),\n        Organization.Field.DESCRIPTION);\n    // assertDateField(actual, expected.getEndDate(),\n    // Organization.Field.END_DATE);\n    assertStringField(actual, expected.getField(), Organization.Field.FIELD);\n    assertStringField(actual, expected.getName(), Organization.Field.NAME);\n    assertStringField(actual, expected.getSalary(), Organization.Field.SALARY);\n    // assertDateField(actual, expected.getStartDate(),\n    // Organization.Field.START_DATE);\n    assertStringField(actual, expected.getSubField(),\n        Organization.Field.SUB_FIELD);\n    assertStringField(actual, expected.getTitle(), Organization.Field.TITLE);\n    assertStringField(actual, expected.getWebpage(), Organization.Field.WEBPAGE);\n    assertStringField(actual, expected.getType(), Organization.Field.TYPE);\n  }\n\n  private void assertBooleanField(Map<String, List<String>> result,\n      boolean expected, Object field) {\n    assertEquals(expected, Boolean.parseBoolean(result.get(field.toString())\n        .get(0)));\n  }\n\n  @SuppressWarnings(\"boxing\")\n  private void assertFloatField(Map<String, List<String>> result, Float expected, Object field) {\n    assertEquals(expected.floatValue(), Float.valueOf(result.get(field.toString()).get(0)), 0);\n  }\n\n  private void assertStringField(Map<String, List<String>> result,\n      String expected, Object field) {\n    List<String> v = result.get(field.toString());\n    String t;\n    if ( v == null || v.isEmpty()) {\n      if (expected == null ) {\n        return;\n      }\n      t = \"\";\n    } else {\n      t = v.get(0);\n    }\n    assertEquals(expected, t);\n  }\n\n  private void assertStringListField(Map<String, List<String>> result,\n      List<String> list, Person.Field field) {\n    assertEquals(list.size(), result.get(field.toString()).size());\n    for (int i = 0; i < list.size(); i++) {\n      assertEquals(list.get(i), result.get(field.toString()).get(i));\n    }\n  }\n\n  private void assertEnumField(Map<String, List<Node>> result, Enum<?> expected,\n      Person.Field field) {\n    Map<String, List<String>> actual = childNodesToMap(result.get(\n        field.toString()).get(0));\n    assertEquals(expected.getDisplayValue(), actual.get(\"displayValue\").get(0));\n    assertEquals(expected.getValue().toString(), actual.get(\"value\").get(0));\n  }\n\n  private void assertListEnumField(Map<String, List<Node>> result,\n      List<? extends Enum<? extends Enum.EnumKey>> expected, Person.Field field) {\n    List<Node> actual = result.get(field.toString());\n    for (int i = 0; i < actual.size(); i++) {\n      Map<String, List<String>> nm = childNodesToMap(actual.get(i));\n      assertEquals(expected.get(i).getDisplayValue(), nm.get(\"displayValue\")\n          .get(0));\n      assertEquals(expected.get(i).getValue().toString(), nm.get(\"value\")\n          .get(0));\n    }\n  }\n\n  /**\n   * Expected response for a list of people in json:\n   *\n   * { \"totalResults\" : 3,\n   *     \"startIndex\" : 0\n   *     \"entry\" : [ {<jane doe>}, // layed out like above\n   * {<george doe>}, {<maija m>}, ] }\n   *\n   * @throws Exception\n   *           if test encounters an error\n   */\n  @Test\n  public void testGetPeople() throws Exception {\n    Map<String, String> extraParams = Maps.newHashMap();\n    extraParams.put(\"sortBy\", \"name\");\n    extraParams.put(\"sortOrder\", null);\n    extraParams.put(\"filterBy\", null);\n    extraParams.put(\"startIndex\", null);\n    extraParams.put(\"count\", \"20\");\n    extraParams.put(\"fields\", null);\n\n    // Currently, for Shindig @all == @friends\n    String resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Map<String, List<String>> result = childNodesToMap(resultNodeList.item(0));\n    Map<String, List<Node>> resultNodes = childNodesToNodeMap(resultNodeList\n        .item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"0\", result.get(\"startIndex\").get(0));\n\n    // The users should be in alphabetical order\n    List<Node> listNodes = resultNodes.get(\"list\");\n    Map<String, List<Node>> listNodesChildMap = childNodesToNodeMap(listNodes.get(0));\n    List<Node> entries = listNodesChildMap.get(\"entry\");\n\n    Map<String, List<Node>> entryOne = childNodesToNodeMap(entries.get(0));\n    assertPerson(childNodesToNodeMap(entryOne.get(\"person\").get(0)),\n        \"george.doe\", \"George Doe\");\n\n    Map<String, List<Node>> entryTwo = childNodesToNodeMap(entries.get(1));\n    assertPerson(childNodesToNodeMap(entryTwo.get(\"person\").get(0)),\n        \"jane.doe\", \"Jane Doe\");\n  }\n\n  @Test\n  public void testGetPeoplePagination() throws Exception {\n    Map<String, String> extraParams = Maps.newHashMap();\n    extraParams.put(\"sortBy\", \"name\");\n    extraParams.put(\"sortOrder\", null);\n    extraParams.put(\"filterBy\", null);\n    extraParams.put(\"startIndex\", \"0\");\n    extraParams.put(\"count\", \"1\");\n    extraParams.put(\"fields\", null);\n\n    String resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Map<String, List<String>> result = childNodesToMap(resultNodeList.item(0));\n    Map<String, List<Node>> resultNodes = childNodesToNodeMap(resultNodeList\n        .item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"0\", result.get(\"startIndex\").get(0));\n\n    List<Node> listNodes = resultNodes.get(\"list\");\n    Map<String, List<Node>> listNodesChildMap = childNodesToNodeMap(listNodes.get(0));\n    List<Node> entries = listNodesChildMap.get(\"entry\");\n\n    Map<String, List<Node>> entryOne = childNodesToNodeMap(entries.get(0));\n\n    assertPerson(childNodesToNodeMap(entryOne.get(\"person\").get(0)),\n        \"george.doe\", \"George Doe\");\n\n    // Get the second page\n    extraParams.put(\"startIndex\", \"1\");\n    resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams, \"xml\",\n        \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    result = childNodesToMap(resultNodeList.item(0));\n    resultNodes = childNodesToNodeMap(resultNodeList.item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"1\", result.get(\"startIndex\").get(0));\n\n    listNodes = resultNodes.get(\"list\");\n    listNodesChildMap = childNodesToNodeMap(listNodes.get(0));\n    entries = listNodesChildMap.get(\"entry\");\n\n    Map<String, List<Node>> entryTwo = childNodesToNodeMap(entries.get(0));\n    assertPerson(childNodesToNodeMap(entryTwo.get(\"person\").get(0)),\n        \"jane.doe\", \"Jane Doe\");\n  }\n\n  private void assertPerson(Map<String, List<Node>> person, String expectedId,\n      String expectedName) throws Exception {\n    assertEquals(expectedId, person.get(\"id\").get(0).getTextContent());\n    assertEquals(expectedName, childNodesToMap(person.get(\"name\").get(0)).get(\n        \"formatted\").get(0));\n  }\n\n  // TODO: Add tests for fields parameter\n  // TODO: Add tests for networkDistance\n}\n","lineNo":518}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  The ASF licenses this file to You\n * under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.  For additional information regarding\n * copyright in this work, please see the NOTICE file in the top level\n * directory of this distribution.\n */\npackage org.apache.shindig.social.dataservice.integration;\n\nimport org.apache.shindig.protocol.model.Enum;\nimport org.apache.shindig.protocol.model.EnumImpl;\nimport org.apache.shindig.social.core.model.AddressImpl;\nimport org.apache.shindig.social.core.model.BodyTypeImpl;\nimport org.apache.shindig.social.core.model.ListFieldImpl;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.OrganizationImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.core.model.UrlImpl;\nimport org.apache.shindig.social.opensocial.model.Address;\nimport org.apache.shindig.social.opensocial.model.BodyType;\nimport org.apache.shindig.social.opensocial.model.Drinker;\nimport org.apache.shindig.social.opensocial.model.ListField;\nimport org.apache.shindig.social.opensocial.model.LookingFor;\nimport org.apache.shindig.social.opensocial.model.Name;\nimport org.apache.shindig.social.opensocial.model.NetworkPresence;\nimport org.apache.shindig.social.opensocial.model.Organization;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.model.Smoker;\nimport org.apache.shindig.social.opensocial.model.Url;\nimport org.apache.shindig.social.opensocial.util.XSDValidator;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.custommonkey.xmlunit.XMLUnit;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RestfulXmlPeopleTest extends AbstractLargeRestfulTests {\n  private Person canonical;\n\n  @Before\n  public void restfulxXmlPeopleTestBefore() throws Exception {\n\n    NameImpl name = new NameImpl(\"Sir Shin H. Digg Social Butterfly\");\n    name.setAdditionalName(\"H\");\n    name.setFamilyName(\"Digg\");\n    name.setGivenName(\"Shin\");\n    name.setHonorificPrefix(\"Sir\");\n    name.setHonorificSuffix(\"Social Butterfly\");\n    canonical = new PersonImpl(\"canonical\", \"Shin Digg\", name);\n\n    canonical.setAboutMe(\"I have an example of every piece of data\");\n    canonical.setActivities(Lists.newArrayList(\"Coding Shindig\"));\n\n    Address address = new AddressImpl(\n        \"PoBox 3565, 1 OpenStandards Way, Apache, CA\");\n    address.setCountry(\"US\");\n    address.setLatitude(28.3043F);\n    address.setLongitude(143.0859F);\n    address.setLocality(\"who knows\");\n    address.setPostalCode(\"12345\");\n    address.setRegion(\"Apache, CA\");\n    address.setStreetAddress(\"1 OpenStandards Way\");\n    address.setType(\"home\");\n    address.setFormatted(\"PoBox 3565, 1 OpenStandards Way, Apache, CA\");\n    canonical.setAddresses(Lists.newArrayList(address));\n\n    canonical.setAge(33);\n    BodyTypeImpl bodyType = new BodyTypeImpl();\n    bodyType.setBuild(\"svelte\");\n    bodyType.setEyeColor(\"blue\");\n    bodyType.setHairColor(\"black\");\n    bodyType.setHeight(1.84F); // meters as per spec\n    bodyType.setWeight(74F); // kg as per spec\n    canonical.setBodyType(bodyType);\n\n    canonical.setBooks(Lists.newArrayList(\"The Cathedral & the Bazaar\",\n        \"Catch 22\"));\n    canonical.setCars(Lists.newArrayList(\"beetle\", \"prius\"));\n    canonical.setChildren(\"3\");\n    AddressImpl location = new AddressImpl();\n    location.setLatitude(48.858193F);\n    location.setLongitude(2.29419F);\n    canonical.setCurrentLocation(location);\n\n    canonical.setBirthday(new Date());\n    canonical.setDrinker(new EnumImpl<Drinker>(Drinker.SOCIALLY));\n    ListField email = new ListFieldImpl(\"work\",\n        \"dev@shindig.apache.org\");\n    canonical.setEmails(Lists.newArrayList(email));\n\n    canonical.setEthnicity(\"developer\");\n    canonical.setFashion(\"t-shirts\");\n    canonical.setFood(Lists.newArrayList(\"sushi\", \"burgers\"));\n    canonical.setGender(Person.Gender.male);\n    canonical.setHappiestWhen(\"coding\");\n    canonical.setHasApp(true);\n    canonical\n        .setHeroes(Lists.newArrayList(\"Doug Crockford\", \"Charles Babbage\"));\n    canonical.setHumor(\"none to speak of\");\n    canonical.setInterests(Lists.newArrayList(\"PHP\", \"Java\"));\n    canonical.setJobInterests(\"will work for beer\");\n\n    Organization job1 = new OrganizationImpl();\n    job1.setAddress(new AddressImpl(\"1 Shindig Drive\"));\n    job1.setDescription(\"lots of coding\");\n    job1.setEndDate(new Date());\n    job1.setField(\"Software Engineering\");\n    job1.setName(\"Apache.com\");\n    job1.setSalary(\"$1000000000\");\n    job1.setStartDate(new Date());\n    job1.setSubField(\"Development\");\n    job1.setTitle(\"Grand PooBah\");\n    job1.setWebpage(\"http://shindig.apache.org/\");\n    job1.setType(\"job\");\n\n    Organization job2 = new OrganizationImpl();\n    job2.setAddress(new AddressImpl(\"1 Skid Row\"));\n    job2.setDescription(\"\");\n    job2.setEndDate(new Date());\n    job2.setField(\"College\");\n    job2.setName(\"School of hard Knocks\");\n    job2.setSalary(\"$100\");\n    job2.setStartDate(new Date());\n    job2.setSubField(\"Lab Tech\");\n    job2.setTitle(\"Gopher\");\n    job2.setWebpage(\"\");\n    job2.setType(\"job\");\n\n    canonical.setOrganizations(Lists.newArrayList(job1, job2));\n\n    canonical.setUpdated(new Date());\n    canonical.setLanguagesSpoken(Lists.newArrayList(\"English\", \"Dutch\",\n        \"Esperanto\"));\n    canonical.setLivingArrangement(\"in a house\");\n    org.apache.shindig.protocol.model.Enum<LookingFor> lookingForRandom = new EnumImpl<LookingFor>(\n        LookingFor.RANDOM, \"Random\");\n    Enum<LookingFor> lookingForNetworking = new EnumImpl<LookingFor>(\n        LookingFor.NETWORKING, \"Networking\");\n    canonical.setLookingFor(Lists.newArrayList(lookingForRandom,\n        lookingForNetworking));\n    canonical.setMovies(Lists.newArrayList(\"Iron Man\", \"Nosferatu\"));\n    canonical.setMusic(Lists.newArrayList(\"Chieftains\", \"Beck\"));\n    canonical.setNetworkPresence(new EnumImpl<NetworkPresence>(\n        NetworkPresence.ONLINE));\n    canonical.setNickname(\"diggy\");\n    canonical.setPets(\"dog,cat\");\n    canonical.setPhoneNumbers(Lists.<ListField> newArrayList(new ListFieldImpl(\n        \"work\", \"111-111-111\"), new ListFieldImpl(\"mobile\", \"999-999-999\")));\n\n    canonical.setPoliticalViews(\"open leaning\");\n    canonical.setProfileSong(new UrlImpl(\n        \"http://www.example.org/songs/OnlyTheLonely.mp3\", \"Feelin' blue\",\n        \"road\"));\n    canonical.setProfileVideo(new UrlImpl(\n        \"http://www.example.org/videos/Thriller.flv\", \"Thriller\", \"video\"));\n\n    canonical.setQuotes(Lists.newArrayList(\"I am therfore I code\", \"Doh!\"));\n    canonical.setRelationshipStatus(\"married to my job\");\n    canonical.setReligion(\"druidic\");\n    canonical.setRomance(\"twice a year\");\n    canonical.setScaredOf(\"COBOL\");\n    canonical.setSexualOrientation(\"north\");\n    canonical.setSmoker(new EnumImpl<Smoker>(Smoker.NO));\n    canonical.setSports(Lists.newArrayList(\"frisbee\", \"rugby\"));\n    canonical.setStatus(\"happy\");\n    canonical.setTags(Lists.newArrayList(\"C#\", \"JSON\", \"template\"));\n    canonical.setThumbnailUrl(\"http://www.example.org/pic/?id=1\");\n    canonical.setUtcOffset(-8L);\n    canonical.setTurnOffs(Lists.newArrayList(\"lack of unit tests\", \"cabbage\"));\n    canonical.setTurnOns(Lists.newArrayList(\"well document code\"));\n    canonical.setTvShows(Lists.newArrayList(\"House\", \"Battlestar Galactica\"));\n\n    canonical\n        .setUrls(Lists.<Url> newArrayList(new UrlImpl(\n            \"http://www.example.org/?id=1\", \"my profile\", \"Profile\"),\n            new UrlImpl(\"http://www.example.org/pic/?id=1\",\n                \"my awesome picture\", \"Thumbnail\")));\n\n  }\n\n  /**\n   * Expected response for john.doe's json:\n   *\n   * { 'entry' :\n   * { 'id' : 'john.doe',\n   * 'name' : {'formatted' : 'John Doe'},\n   * 'phoneNumbers' : [ { 'number' : '+33H000000000', 'type' : 'home'}, ],\n   * 'addresses' : [ {'formatted' : 'My home address'} ],\n   * 'emails' : [\n   *    { 'value' : 'john.doe@work.bar', 'type' : 'work'}, ]\n   *\n   * ... etc, etc for all fields in the person object } } TODO: Finish up this\n   * test and make refactor so that it is easier to read\n   *\n   * @throws Exception\n   *           if test encounters an error\n   */\n  @SuppressWarnings(\"boxing\")\n  @Test\n  public void testGetPersonJson() throws Exception {\n    // TODO(doll): Test all of the date fields\n\n    Map<String, String> extraParams = Maps.newHashMap();\n    StringBuilder allFieldsParam = new StringBuilder();\n    for (String allField : Person.Field.ALL_FIELDS) {\n      allFieldsParam.append(allField).append(',');\n    }\n    extraParams.put(\"fields\", allFieldsParam.toString());\n\n    // Currently, for Shindig {pid}/@all/{uid} == {uid}/@self\n    String resp = getResponse(\"/people/canonical/@self\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response/:person\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Node personNode = resultNodeList.item(0);\n\n    Map<String, List<Node>> childNodeMap = childNodesToNodeMap(personNode);\n    Map<String, List<String>> result = childNodesToMap(personNode);\n\n    assertStringField(result, canonical.getAboutMe(), Person.Field.ABOUT_ME);\n    assertStringListField(result, canonical.getActivities(),\n        Person.Field.ACTIVITIES);\n\n    List<Node> addressNodes = childNodeMap.get(Person.Field.ADDRESSES\n        .toString());\n    assertEquals(addressNodes.size(), canonical.getAddresses().size());\n    for (int i = 0; i < addressNodes.size(); i++) {\n      assertAddressField(canonical.getAddresses().get(i),\n          childNodesToMap(addressNodes.get(i)));\n    }\n\n    assertEquals(canonical.getAge().intValue(), Integer.parseInt(result.get(\n        Person.Field.AGE.toString()).get(0)));\n\n    Map<String, List<String>> bodyMap = childNodesToMap(childNodeMap.get(\n        Person.Field.BODY_TYPE.toString()).get(0));\n    BodyType body = canonical.getBodyType();\n\n    assertStringField(bodyMap, body.getBuild(), BodyType.Field.BUILD);\n    assertStringField(bodyMap, body.getEyeColor(), BodyType.Field.EYE_COLOR);\n    assertStringField(bodyMap, body.getHairColor(), BodyType.Field.HAIR_COLOR);\n    assertFloatField(bodyMap, body.getHeight(), BodyType.Field.HEIGHT);\n    assertFloatField(bodyMap, body.getWeight(), BodyType.Field.WEIGHT);\n\n    assertStringListField(result, canonical.getBooks(), Person.Field.BOOKS);\n    assertStringListField(result, canonical.getCars(), Person.Field.CARS);\n    assertStringField(result, canonical.getChildren(), Person.Field.CHILDREN);\n\n    Map<String, List<String>> currentLocation = childNodesToMap(childNodeMap\n        .get(Person.Field.CURRENT_LOCATION.toString()).get(0));\n    assertFloatField(currentLocation, canonical.getCurrentLocation()\n        .getLatitude(), Address.Field.LATITUDE);\n    assertFloatField(currentLocation, canonical.getCurrentLocation()\n        .getLongitude(), Address.Field.LONGITUDE);\n\n    assertStringField(result, canonical.getDisplayName(),\n        Person.Field.DISPLAY_NAME);\n\n    // assertLongField(result, canonical.getBirthday().getTime(),\n    // Person.Field.BIRTHDAY);\n    // assertEnumField(result, canonical.getDrinker(), Person.Field.DRINKER);\n\n    List<Node> emailArray = childNodeMap.get(Person.Field.EMAILS.toString());\n    assertEquals(1, emailArray.size());\n\n    for (int i = 0; i < canonical.getEmails().size(); i++) {\n      ListField expectedEmail = canonical.getEmails().get(i);\n      Map<String, List<String>> actualEmail = childNodesToMap(emailArray.get(i));\n\n      assertStringField(actualEmail, expectedEmail.getType(),\n          ListField.Field.TYPE);\n      assertStringField(actualEmail, expectedEmail.getValue(),\n          ListField.Field.VALUE);\n    }\n\n    assertStringField(result, canonical.getEthnicity(), Person.Field.ETHNICITY);\n    assertStringField(result, canonical.getFashion(), Person.Field.FASHION);\n    assertStringListField(result, canonical.getFood(), Person.Field.FOOD);\n    assertStringField(result, canonical.getGender().toString(),\n        Person.Field.GENDER);\n    assertStringField(result, canonical.getHappiestWhen(),\n        Person.Field.HAPPIEST_WHEN);\n    assertBooleanField(result, canonical.getHasApp(), Person.Field.HAS_APP);\n    assertStringListField(result, canonical.getHeroes(), Person.Field.HEROES);\n    assertStringField(result, canonical.getHumor(), Person.Field.HUMOR);\n    assertStringField(result, canonical.getId(), Person.Field.ID);\n    assertStringListField(result, canonical.getInterests(),\n        Person.Field.INTERESTS);\n    assertStringField(result, canonical.getJobInterests(),\n        Person.Field.JOB_INTERESTS);\n\n    assertOrganizationField(canonical.getOrganizations().get(0), childNodeMap\n        .get(Person.Field.ORGANIZATIONS.toString()).get(0));\n\n    assertStringListField(result, canonical.getLanguagesSpoken(),\n        Person.Field.LANGUAGES_SPOKEN);\n    // assertDateField(result, canonical.getUpdated(),\n    // Person.Field.LAST_UPDATED);\n    assertStringField(result, canonical.getLivingArrangement(),\n        Person.Field.LIVING_ARRANGEMENT);\n    assertListEnumField(childNodeMap, canonical.getLookingFor(),\n        Person.Field.LOOKING_FOR);\n    assertStringListField(result, canonical.getMovies(), Person.Field.MOVIES);\n    assertStringListField(result, canonical.getMusic(), Person.Field.MUSIC);\n\n    assertEquals(canonical.getName().getFormatted(), childNodesToMap(\n        childNodeMap.get(Person.Field.NAME.toString()).get(0)).get(\n        Name.Field.FORMATTED.toString()).get(0));\n\n    assertEnumField(childNodeMap, canonical.getNetworkPresence(),\n        Person.Field.NETWORKPRESENCE);\n    assertStringField(result, canonical.getNickname(), Person.Field.NICKNAME);\n    assertStringField(result, canonical.getPets(), Person.Field.PETS);\n\n    List<Node> phoneArray = childNodeMap.get(Person.Field.PHONE_NUMBERS\n        .toString());\n    assertEquals(canonical.getPhoneNumbers().size(), phoneArray.size());\n\n    for (int i = 0; i < canonical.getPhoneNumbers().size(); i++) {\n      ListField expectedPhone = canonical.getPhoneNumbers().get(i);\n      Map<String, List<String>> actualPhone = childNodesToMap(phoneArray.get(i));\n      assertEquals(expectedPhone.getType(), actualPhone.get(\n          ListField.Field.TYPE.toString()).get(0));\n      assertEquals(expectedPhone.getValue(), actualPhone.get(\n          ListField.Field.VALUE.toString()).get(0));\n    }\n\n    assertStringField(result, canonical.getPoliticalViews(),\n        Person.Field.POLITICAL_VIEWS);\n\n    assertUrlField(canonical.getProfileSong(), childNodesToMap(childNodeMap\n        .get(Person.Field.PROFILE_SONG.toString()).get(0)));\n    assertStringField(result, canonical.getProfileUrl(),\n        Person.Field.PROFILE_URL);\n    assertUrlField(canonical.getProfileVideo(), childNodesToMap(childNodeMap\n        .get(Person.Field.PROFILE_VIDEO.toString()).get(0)));\n\n    assertStringListField(result, canonical.getQuotes(), Person.Field.QUOTES);\n    assertStringField(result, canonical.getRelationshipStatus(),\n        Person.Field.RELATIONSHIP_STATUS);\n    assertStringField(result, canonical.getReligion(), Person.Field.RELIGION);\n    assertStringField(result, canonical.getRomance(), Person.Field.ROMANCE);\n    assertStringField(result, canonical.getScaredOf(), Person.Field.SCARED_OF);\n\n    assertStringField(result, canonical.getSexualOrientation(),\n        Person.Field.SEXUAL_ORIENTATION);\n    assertEnumField(childNodeMap, canonical.getSmoker(), Person.Field.SMOKER);\n    assertStringListField(result, canonical.getSports(), Person.Field.SPORTS);\n    assertStringField(result, canonical.getStatus(), Person.Field.STATUS);\n    assertStringListField(result, canonical.getTags(), Person.Field.TAGS);\n    assertStringField(result, canonical.getThumbnailUrl(),\n        Person.Field.THUMBNAIL_URL);\n    // TODO: time zone\n    assertStringListField(result, canonical.getTurnOffs(),\n        Person.Field.TURN_OFFS);\n    assertStringListField(result, canonical.getTurnOns(), Person.Field.TURN_ONS);\n    assertStringListField(result, canonical.getTvShows(), Person.Field.TV_SHOWS);\n  }\n\n  private void assertAddressField(Address expected,\n      Map<String, List<String>> actual) {\n    assertStringField(actual, expected.getCountry(), Address.Field.COUNTRY);\n    assertFloatField(actual, expected.getLatitude(), Address.Field.LATITUDE);\n    assertStringField(actual, expected.getLocality(), Address.Field.LOCALITY);\n    assertFloatField(actual, expected.getLongitude(), Address.Field.LONGITUDE);\n    assertStringField(actual, expected.getPostalCode(),\n        Address.Field.POSTAL_CODE);\n    assertStringField(actual, expected.getRegion(), Address.Field.REGION);\n    assertStringField(actual, expected.getStreetAddress(),\n        Address.Field.STREET_ADDRESS);\n    assertStringField(actual, expected.getType(), Address.Field.TYPE);\n    assertStringField(actual, expected.getFormatted(), Address.Field.FORMATTED);\n  }\n\n  private void assertUrlField(Url expected, Map<String, List<String>> actual) {\n    assertStringField(actual, expected.getValue(), Url.Field.VALUE);\n    assertStringField(actual, expected.getLinkText(), Url.Field.LINK_TEXT);\n    assertStringField(actual, expected.getType(), Url.Field.TYPE);\n  }\n\n  private void assertOrganizationField(Organization expected, Node orgNode) {\n    Map<String, List<String>> actual = childNodesToMap(orgNode);\n    Map<String, List<Node>> actualNode = childNodesToNodeMap(orgNode);\n    assertStringField(childNodesToMap(actualNode.get(\n        Organization.Field.ADDRESS.toString()).get(0)), expected.getAddress()\n        .getFormatted(), Address.Field.FORMATTED);\n    assertStringField(actual, expected.getDescription(),\n        Organization.Field.DESCRIPTION);\n    // assertDateField(actual, expected.getEndDate(),\n    // Organization.Field.END_DATE);\n    assertStringField(actual, expected.getField(), Organization.Field.FIELD);\n    assertStringField(actual, expected.getName(), Organization.Field.NAME);\n    assertStringField(actual, expected.getSalary(), Organization.Field.SALARY);\n    // assertDateField(actual, expected.getStartDate(),\n    // Organization.Field.START_DATE);\n    assertStringField(actual, expected.getSubField(),\n        Organization.Field.SUB_FIELD);\n    assertStringField(actual, expected.getTitle(), Organization.Field.TITLE);\n    assertStringField(actual, expected.getWebpage(), Organization.Field.WEBPAGE);\n    assertStringField(actual, expected.getType(), Organization.Field.TYPE);\n  }\n\n  private void assertBooleanField(Map<String, List<String>> result,\n      boolean expected, Object field) {\n    assertEquals(expected, Boolean.parseBoolean(result.get(field.toString())\n        .get(0)));\n  }\n\n  @SuppressWarnings(\"boxing\")\n  private void assertFloatField(Map<String, List<String>> result, Float expected, Object field) {\n    assertEquals(expected.floatValue(), Float.valueOf(result.get(field.toString()).get(0)), 0);\n  }\n\n  private void assertStringField(Map<String, List<String>> result,\n      String expected, Object field) {\n    List<String> v = result.get(field.toString());\n    String t;\n    if ( v == null || v.isEmpty()) {\n      if (expected == null ) {\n        return;\n      }\n      t = \"\";\n    } else {\n      t = v.get(0);\n    }\n    assertEquals(expected, t);\n  }\n\n  private void assertStringListField(Map<String, List<String>> result,\n      List<String> list, Person.Field field) {\n    assertEquals(list.size(), result.get(field.toString()).size());\n    for (int i = 0; i < list.size(); i++) {\n      assertEquals(list.get(i), result.get(field.toString()).get(i));\n    }\n  }\n\n  private void assertEnumField(Map<String, List<Node>> result, Enum<?> expected,\n      Person.Field field) {\n    Map<String, List<String>> actual = childNodesToMap(result.get(\n        field.toString()).get(0));\n    assertEquals(expected.getDisplayValue(), actual.get(\"displayValue\").get(0));\n    assertEquals(expected.getValue().toString(), actual.get(\"value\").get(0));\n  }\n\n  private void assertListEnumField(Map<String, List<Node>> result,\n      List<? extends Enum<? extends Enum.EnumKey>> expected, Person.Field field) {\n    List<Node> actual = result.get(field.toString());\n    for (int i = 0; i < actual.size(); i++) {\n      Map<String, List<String>> nm = childNodesToMap(actual.get(i));\n      assertEquals(expected.get(i).getDisplayValue(), nm.get(\"displayValue\")\n          .get(0));\n      assertEquals(expected.get(i).getValue().toString(), nm.get(\"value\")\n          .get(0));\n    }\n  }\n\n  /**\n   * Expected response for a list of people in json:\n   *\n   * { \"totalResults\" : 3,\n   *     \"startIndex\" : 0\n   *     \"entry\" : [ {<jane doe>}, // layed out like above\n   * {<george doe>}, {<maija m>}, ] }\n   *\n   * @throws Exception\n   *           if test encounters an error\n   */\n  @Test\n  public void testGetPeople() throws Exception {\n    Map<String, String> extraParams = Maps.newHashMap();\n    extraParams.put(\"sortBy\", \"name\");\n    extraParams.put(\"sortOrder\", null);\n    extraParams.put(\"filterBy\", null);\n    extraParams.put(\"startIndex\", null);\n    extraParams.put(\"count\", \"20\");\n    extraParams.put(\"fields\", null);\n\n    // Currently, for Shindig @all == @friends\n    String resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Map<String, List<String>> result = childNodesToMap(resultNodeList.item(0));\n    Map<String, List<Node>> resultNodes = childNodesToNodeMap(resultNodeList\n        .item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"0\", result.get(\"startIndex\").get(0));\n\n    // The users should be in alphabetical order\n    Map<String, List<Node>> entryOne = childNodesToNodeMap(resultNodes.get(\"entry\").get(0));\n\n    assertPerson(childNodesToNodeMap(entryOne.get(\"person\").get(0)),\n        \"george.doe\", \"George Doe\");\n\n    Map<String, List<Node>> entryTwo = childNodesToNodeMap(resultNodes.get(\"entry\").get(1));\n    assertPerson(childNodesToNodeMap(entryTwo.get(\"person\").get(0)),\n        \"jane.doe\", \"Jane Doe\");\n  }\n\n  @Test\n  public void testGetPeoplePagination() throws Exception {\n    Map<String, String> extraParams = Maps.newHashMap();\n    extraParams.put(\"sortBy\", \"name\");\n    extraParams.put(\"sortOrder\", null);\n    extraParams.put(\"filterBy\", null);\n    extraParams.put(\"startIndex\", \"0\");\n    extraParams.put(\"count\", \"1\");\n    extraParams.put(\"fields\", null);\n\n    String resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Map<String, List<String>> result = childNodesToMap(resultNodeList.item(0));\n    Map<String, List<Node>> resultNodes = childNodesToNodeMap(resultNodeList\n        .item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"0\", result.get(\"startIndex\").get(0));\n\n    Map<String, List<Node>> entryOne = childNodesToNodeMap(resultNodes.get(\"entry\").get(0));\n\n    assertPerson(childNodesToNodeMap(entryOne.get(\"person\").get(0)),\n        \"george.doe\", \"George Doe\");\n\n    // Get the second page\n    extraParams.put(\"startIndex\", \"1\");\n    resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams, \"xml\",\n        \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    result = childNodesToMap(resultNodeList.item(0));\n    resultNodes = childNodesToNodeMap(resultNodeList.item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"1\", result.get(\"startIndex\").get(0));\n\n    Map<String, List<Node>> entryTwo = childNodesToNodeMap(resultNodes.get(\"entry\").get(0));\n    assertPerson(childNodesToNodeMap(entryTwo.get(\"person\").get(0)),\n        \"jane.doe\", \"Jane Doe\");\n  }\n\n  private void assertPerson(Map<String, List<Node>> person, String expectedId,\n      String expectedName) throws Exception {\n    assertEquals(expectedId, person.get(\"id\").get(0).getTextContent());\n    assertEquals(expectedName, childNodesToMap(person.get(\"name\").get(0)).get(\n        \"formatted\").get(0));\n  }\n\n  // TODO: Add tests for fields parameter\n  // TODO: Add tests for networkDistance\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  The ASF licenses this file to You\n * under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.  For additional information regarding\n * copyright in this work, please see the NOTICE file in the top level\n * directory of this distribution.\n */\npackage org.apache.shindig.social.dataservice.integration;\n\nimport org.apache.shindig.protocol.model.Enum;\nimport org.apache.shindig.protocol.model.EnumImpl;\nimport org.apache.shindig.social.core.model.AddressImpl;\nimport org.apache.shindig.social.core.model.BodyTypeImpl;\nimport org.apache.shindig.social.core.model.ListFieldImpl;\nimport org.apache.shindig.social.core.model.NameImpl;\nimport org.apache.shindig.social.core.model.OrganizationImpl;\nimport org.apache.shindig.social.core.model.PersonImpl;\nimport org.apache.shindig.social.core.model.UrlImpl;\nimport org.apache.shindig.social.opensocial.model.Address;\nimport org.apache.shindig.social.opensocial.model.BodyType;\nimport org.apache.shindig.social.opensocial.model.Drinker;\nimport org.apache.shindig.social.opensocial.model.ListField;\nimport org.apache.shindig.social.opensocial.model.LookingFor;\nimport org.apache.shindig.social.opensocial.model.Name;\nimport org.apache.shindig.social.opensocial.model.NetworkPresence;\nimport org.apache.shindig.social.opensocial.model.Organization;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.model.Smoker;\nimport org.apache.shindig.social.opensocial.model.Url;\nimport org.apache.shindig.social.opensocial.util.XSDValidator;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.custommonkey.xmlunit.XMLUnit;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RestfulXmlPeopleTest extends AbstractLargeRestfulTests {\n  private Person canonical;\n\n  @Before\n  public void restfulxXmlPeopleTestBefore() throws Exception {\n\n    NameImpl name = new NameImpl(\"Sir Shin H. Digg Social Butterfly\");\n    name.setAdditionalName(\"H\");\n    name.setFamilyName(\"Digg\");\n    name.setGivenName(\"Shin\");\n    name.setHonorificPrefix(\"Sir\");\n    name.setHonorificSuffix(\"Social Butterfly\");\n    canonical = new PersonImpl(\"canonical\", \"Shin Digg\", name);\n\n    canonical.setAboutMe(\"I have an example of every piece of data\");\n    canonical.setActivities(Lists.newArrayList(\"Coding Shindig\"));\n\n    Address address = new AddressImpl(\n        \"PoBox 3565, 1 OpenStandards Way, Apache, CA\");\n    address.setCountry(\"US\");\n    address.setLatitude(28.3043F);\n    address.setLongitude(143.0859F);\n    address.setLocality(\"who knows\");\n    address.setPostalCode(\"12345\");\n    address.setRegion(\"Apache, CA\");\n    address.setStreetAddress(\"1 OpenStandards Way\");\n    address.setType(\"home\");\n    address.setFormatted(\"PoBox 3565, 1 OpenStandards Way, Apache, CA\");\n    canonical.setAddresses(Lists.newArrayList(address));\n\n    canonical.setAge(33);\n    BodyTypeImpl bodyType = new BodyTypeImpl();\n    bodyType.setBuild(\"svelte\");\n    bodyType.setEyeColor(\"blue\");\n    bodyType.setHairColor(\"black\");\n    bodyType.setHeight(1.84F); // meters as per spec\n    bodyType.setWeight(74F); // kg as per spec\n    canonical.setBodyType(bodyType);\n\n    canonical.setBooks(Lists.newArrayList(\"The Cathedral & the Bazaar\",\n        \"Catch 22\"));\n    canonical.setCars(Lists.newArrayList(\"beetle\", \"prius\"));\n    canonical.setChildren(\"3\");\n    AddressImpl location = new AddressImpl();\n    location.setLatitude(48.858193F);\n    location.setLongitude(2.29419F);\n    canonical.setCurrentLocation(location);\n\n    canonical.setBirthday(new Date());\n    canonical.setDrinker(new EnumImpl<Drinker>(Drinker.SOCIALLY));\n    ListField email = new ListFieldImpl(\"work\",\n        \"dev@shindig.apache.org\");\n    canonical.setEmails(Lists.newArrayList(email));\n\n    canonical.setEthnicity(\"developer\");\n    canonical.setFashion(\"t-shirts\");\n    canonical.setFood(Lists.newArrayList(\"sushi\", \"burgers\"));\n    canonical.setGender(Person.Gender.male);\n    canonical.setHappiestWhen(\"coding\");\n    canonical.setHasApp(true);\n    canonical\n        .setHeroes(Lists.newArrayList(\"Doug Crockford\", \"Charles Babbage\"));\n    canonical.setHumor(\"none to speak of\");\n    canonical.setInterests(Lists.newArrayList(\"PHP\", \"Java\"));\n    canonical.setJobInterests(\"will work for beer\");\n\n    Organization job1 = new OrganizationImpl();\n    job1.setAddress(new AddressImpl(\"1 Shindig Drive\"));\n    job1.setDescription(\"lots of coding\");\n    job1.setEndDate(new Date());\n    job1.setField(\"Software Engineering\");\n    job1.setName(\"Apache.com\");\n    job1.setSalary(\"$1000000000\");\n    job1.setStartDate(new Date());\n    job1.setSubField(\"Development\");\n    job1.setTitle(\"Grand PooBah\");\n    job1.setWebpage(\"http://shindig.apache.org/\");\n    job1.setType(\"job\");\n\n    Organization job2 = new OrganizationImpl();\n    job2.setAddress(new AddressImpl(\"1 Skid Row\"));\n    job2.setDescription(\"\");\n    job2.setEndDate(new Date());\n    job2.setField(\"College\");\n    job2.setName(\"School of hard Knocks\");\n    job2.setSalary(\"$100\");\n    job2.setStartDate(new Date());\n    job2.setSubField(\"Lab Tech\");\n    job2.setTitle(\"Gopher\");\n    job2.setWebpage(\"\");\n    job2.setType(\"job\");\n\n    canonical.setOrganizations(Lists.newArrayList(job1, job2));\n\n    canonical.setUpdated(new Date());\n    canonical.setLanguagesSpoken(Lists.newArrayList(\"English\", \"Dutch\",\n        \"Esperanto\"));\n    canonical.setLivingArrangement(\"in a house\");\n    org.apache.shindig.protocol.model.Enum<LookingFor> lookingForRandom = new EnumImpl<LookingFor>(\n        LookingFor.RANDOM, \"Random\");\n    Enum<LookingFor> lookingForNetworking = new EnumImpl<LookingFor>(\n        LookingFor.NETWORKING, \"Networking\");\n    canonical.setLookingFor(Lists.newArrayList(lookingForRandom,\n        lookingForNetworking));\n    canonical.setMovies(Lists.newArrayList(\"Iron Man\", \"Nosferatu\"));\n    canonical.setMusic(Lists.newArrayList(\"Chieftains\", \"Beck\"));\n    canonical.setNetworkPresence(new EnumImpl<NetworkPresence>(\n        NetworkPresence.ONLINE));\n    canonical.setNickname(\"diggy\");\n    canonical.setPets(\"dog,cat\");\n    canonical.setPhoneNumbers(Lists.<ListField> newArrayList(new ListFieldImpl(\n        \"work\", \"111-111-111\"), new ListFieldImpl(\"mobile\", \"999-999-999\")));\n\n    canonical.setPoliticalViews(\"open leaning\");\n    canonical.setProfileSong(new UrlImpl(\n        \"http://www.example.org/songs/OnlyTheLonely.mp3\", \"Feelin' blue\",\n        \"road\"));\n    canonical.setProfileVideo(new UrlImpl(\n        \"http://www.example.org/videos/Thriller.flv\", \"Thriller\", \"video\"));\n\n    canonical.setQuotes(Lists.newArrayList(\"I am therfore I code\", \"Doh!\"));\n    canonical.setRelationshipStatus(\"married to my job\");\n    canonical.setReligion(\"druidic\");\n    canonical.setRomance(\"twice a year\");\n    canonical.setScaredOf(\"COBOL\");\n    canonical.setSexualOrientation(\"north\");\n    canonical.setSmoker(new EnumImpl<Smoker>(Smoker.NO));\n    canonical.setSports(Lists.newArrayList(\"frisbee\", \"rugby\"));\n    canonical.setStatus(\"happy\");\n    canonical.setTags(Lists.newArrayList(\"C#\", \"JSON\", \"template\"));\n    canonical.setThumbnailUrl(\"http://www.example.org/pic/?id=1\");\n    canonical.setUtcOffset(-8L);\n    canonical.setTurnOffs(Lists.newArrayList(\"lack of unit tests\", \"cabbage\"));\n    canonical.setTurnOns(Lists.newArrayList(\"well document code\"));\n    canonical.setTvShows(Lists.newArrayList(\"House\", \"Battlestar Galactica\"));\n\n    canonical\n        .setUrls(Lists.<Url> newArrayList(new UrlImpl(\n            \"http://www.example.org/?id=1\", \"my profile\", \"Profile\"),\n            new UrlImpl(\"http://www.example.org/pic/?id=1\",\n                \"my awesome picture\", \"Thumbnail\")));\n\n  }\n\n  /**\n   * Expected response for john.doe's json:\n   *\n   * { 'entry' :\n   * { 'id' : 'john.doe',\n   * 'name' : {'formatted' : 'John Doe'},\n   * 'phoneNumbers' : [ { 'number' : '+33H000000000', 'type' : 'home'}, ],\n   * 'addresses' : [ {'formatted' : 'My home address'} ],\n   * 'emails' : [\n   *    { 'value' : 'john.doe@work.bar', 'type' : 'work'}, ]\n   *\n   * ... etc, etc for all fields in the person object } } TODO: Finish up this\n   * test and make refactor so that it is easier to read\n   *\n   * @throws Exception\n   *           if test encounters an error\n   */\n  @SuppressWarnings(\"boxing\")\n  @Test\n  public void testGetPersonJson() throws Exception {\n    // TODO(doll): Test all of the date fields\n\n    Map<String, String> extraParams = Maps.newHashMap();\n    StringBuilder allFieldsParam = new StringBuilder();\n    for (String allField : Person.Field.ALL_FIELDS) {\n      allFieldsParam.append(allField).append(',');\n    }\n    extraParams.put(\"fields\", allFieldsParam.toString());\n\n    // Currently, for Shindig {pid}/@all/{uid} == {uid}/@self\n    String resp = getResponse(\"/people/canonical/@self\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response/:person\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Node personNode = resultNodeList.item(0);\n\n    Map<String, List<Node>> childNodeMap = childNodesToNodeMap(personNode);\n    Map<String, List<String>> result = childNodesToMap(personNode);\n\n    assertStringField(result, canonical.getAboutMe(), Person.Field.ABOUT_ME);\n    assertStringListField(result, canonical.getActivities(),\n        Person.Field.ACTIVITIES);\n\n    List<Node> addressNodes = childNodeMap.get(Person.Field.ADDRESSES\n        .toString());\n    assertEquals(addressNodes.size(), canonical.getAddresses().size());\n    for (int i = 0; i < addressNodes.size(); i++) {\n      assertAddressField(canonical.getAddresses().get(i),\n          childNodesToMap(addressNodes.get(i)));\n    }\n\n    assertEquals(canonical.getAge().intValue(), Integer.parseInt(result.get(\n        Person.Field.AGE.toString()).get(0)));\n\n    Map<String, List<String>> bodyMap = childNodesToMap(childNodeMap.get(\n        Person.Field.BODY_TYPE.toString()).get(0));\n    BodyType body = canonical.getBodyType();\n\n    assertStringField(bodyMap, body.getBuild(), BodyType.Field.BUILD);\n    assertStringField(bodyMap, body.getEyeColor(), BodyType.Field.EYE_COLOR);\n    assertStringField(bodyMap, body.getHairColor(), BodyType.Field.HAIR_COLOR);\n    assertFloatField(bodyMap, body.getHeight(), BodyType.Field.HEIGHT);\n    assertFloatField(bodyMap, body.getWeight(), BodyType.Field.WEIGHT);\n\n    assertStringListField(result, canonical.getBooks(), Person.Field.BOOKS);\n    assertStringListField(result, canonical.getCars(), Person.Field.CARS);\n    assertStringField(result, canonical.getChildren(), Person.Field.CHILDREN);\n\n    Map<String, List<String>> currentLocation = childNodesToMap(childNodeMap\n        .get(Person.Field.CURRENT_LOCATION.toString()).get(0));\n    assertFloatField(currentLocation, canonical.getCurrentLocation()\n        .getLatitude(), Address.Field.LATITUDE);\n    assertFloatField(currentLocation, canonical.getCurrentLocation()\n        .getLongitude(), Address.Field.LONGITUDE);\n\n    assertStringField(result, canonical.getDisplayName(),\n        Person.Field.DISPLAY_NAME);\n\n    // assertLongField(result, canonical.getBirthday().getTime(),\n    // Person.Field.BIRTHDAY);\n    // assertEnumField(result, canonical.getDrinker(), Person.Field.DRINKER);\n\n    List<Node> emailArray = childNodeMap.get(Person.Field.EMAILS.toString());\n    assertEquals(1, emailArray.size());\n\n    for (int i = 0; i < canonical.getEmails().size(); i++) {\n      ListField expectedEmail = canonical.getEmails().get(i);\n      Map<String, List<String>> actualEmail = childNodesToMap(emailArray.get(i));\n\n      assertStringField(actualEmail, expectedEmail.getType(),\n          ListField.Field.TYPE);\n      assertStringField(actualEmail, expectedEmail.getValue(),\n          ListField.Field.VALUE);\n    }\n\n    assertStringField(result, canonical.getEthnicity(), Person.Field.ETHNICITY);\n    assertStringField(result, canonical.getFashion(), Person.Field.FASHION);\n    assertStringListField(result, canonical.getFood(), Person.Field.FOOD);\n    assertStringField(result, canonical.getGender().toString(),\n        Person.Field.GENDER);\n    assertStringField(result, canonical.getHappiestWhen(),\n        Person.Field.HAPPIEST_WHEN);\n    assertBooleanField(result, canonical.getHasApp(), Person.Field.HAS_APP);\n    assertStringListField(result, canonical.getHeroes(), Person.Field.HEROES);\n    assertStringField(result, canonical.getHumor(), Person.Field.HUMOR);\n    assertStringField(result, canonical.getId(), Person.Field.ID);\n    assertStringListField(result, canonical.getInterests(),\n        Person.Field.INTERESTS);\n    assertStringField(result, canonical.getJobInterests(),\n        Person.Field.JOB_INTERESTS);\n\n    assertOrganizationField(canonical.getOrganizations().get(0), childNodeMap\n        .get(Person.Field.ORGANIZATIONS.toString()).get(0));\n\n    assertStringListField(result, canonical.getLanguagesSpoken(),\n        Person.Field.LANGUAGES_SPOKEN);\n    // assertDateField(result, canonical.getUpdated(),\n    // Person.Field.LAST_UPDATED);\n    assertStringField(result, canonical.getLivingArrangement(),\n        Person.Field.LIVING_ARRANGEMENT);\n    assertListEnumField(childNodeMap, canonical.getLookingFor(),\n        Person.Field.LOOKING_FOR);\n    assertStringListField(result, canonical.getMovies(), Person.Field.MOVIES);\n    assertStringListField(result, canonical.getMusic(), Person.Field.MUSIC);\n\n    assertEquals(canonical.getName().getFormatted(), childNodesToMap(\n        childNodeMap.get(Person.Field.NAME.toString()).get(0)).get(\n        Name.Field.FORMATTED.toString()).get(0));\n\n    assertEnumField(childNodeMap, canonical.getNetworkPresence(),\n        Person.Field.NETWORKPRESENCE);\n    assertStringField(result, canonical.getNickname(), Person.Field.NICKNAME);\n    assertStringField(result, canonical.getPets(), Person.Field.PETS);\n\n    List<Node> phoneArray = childNodeMap.get(Person.Field.PHONE_NUMBERS\n        .toString());\n    assertEquals(canonical.getPhoneNumbers().size(), phoneArray.size());\n\n    for (int i = 0; i < canonical.getPhoneNumbers().size(); i++) {\n      ListField expectedPhone = canonical.getPhoneNumbers().get(i);\n      Map<String, List<String>> actualPhone = childNodesToMap(phoneArray.get(i));\n      assertEquals(expectedPhone.getType(), actualPhone.get(\n          ListField.Field.TYPE.toString()).get(0));\n      assertEquals(expectedPhone.getValue(), actualPhone.get(\n          ListField.Field.VALUE.toString()).get(0));\n    }\n\n    assertStringField(result, canonical.getPoliticalViews(),\n        Person.Field.POLITICAL_VIEWS);\n\n    assertUrlField(canonical.getProfileSong(), childNodesToMap(childNodeMap\n        .get(Person.Field.PROFILE_SONG.toString()).get(0)));\n    assertStringField(result, canonical.getProfileUrl(),\n        Person.Field.PROFILE_URL);\n    assertUrlField(canonical.getProfileVideo(), childNodesToMap(childNodeMap\n        .get(Person.Field.PROFILE_VIDEO.toString()).get(0)));\n\n    assertStringListField(result, canonical.getQuotes(), Person.Field.QUOTES);\n    assertStringField(result, canonical.getRelationshipStatus(),\n        Person.Field.RELATIONSHIP_STATUS);\n    assertStringField(result, canonical.getReligion(), Person.Field.RELIGION);\n    assertStringField(result, canonical.getRomance(), Person.Field.ROMANCE);\n    assertStringField(result, canonical.getScaredOf(), Person.Field.SCARED_OF);\n\n    assertStringField(result, canonical.getSexualOrientation(),\n        Person.Field.SEXUAL_ORIENTATION);\n    assertEnumField(childNodeMap, canonical.getSmoker(), Person.Field.SMOKER);\n    assertStringListField(result, canonical.getSports(), Person.Field.SPORTS);\n    assertStringField(result, canonical.getStatus(), Person.Field.STATUS);\n    assertStringListField(result, canonical.getTags(), Person.Field.TAGS);\n    assertStringField(result, canonical.getThumbnailUrl(),\n        Person.Field.THUMBNAIL_URL);\n    // TODO: time zone\n    assertStringListField(result, canonical.getTurnOffs(),\n        Person.Field.TURN_OFFS);\n    assertStringListField(result, canonical.getTurnOns(), Person.Field.TURN_ONS);\n    assertStringListField(result, canonical.getTvShows(), Person.Field.TV_SHOWS);\n  }\n\n  private void assertAddressField(Address expected,\n      Map<String, List<String>> actual) {\n    assertStringField(actual, expected.getCountry(), Address.Field.COUNTRY);\n    assertFloatField(actual, expected.getLatitude(), Address.Field.LATITUDE);\n    assertStringField(actual, expected.getLocality(), Address.Field.LOCALITY);\n    assertFloatField(actual, expected.getLongitude(), Address.Field.LONGITUDE);\n    assertStringField(actual, expected.getPostalCode(),\n        Address.Field.POSTAL_CODE);\n    assertStringField(actual, expected.getRegion(), Address.Field.REGION);\n    assertStringField(actual, expected.getStreetAddress(),\n        Address.Field.STREET_ADDRESS);\n    assertStringField(actual, expected.getType(), Address.Field.TYPE);\n    assertStringField(actual, expected.getFormatted(), Address.Field.FORMATTED);\n  }\n\n  private void assertUrlField(Url expected, Map<String, List<String>> actual) {\n    assertStringField(actual, expected.getValue(), Url.Field.VALUE);\n    assertStringField(actual, expected.getLinkText(), Url.Field.LINK_TEXT);\n    assertStringField(actual, expected.getType(), Url.Field.TYPE);\n  }\n\n  private void assertOrganizationField(Organization expected, Node orgNode) {\n    Map<String, List<String>> actual = childNodesToMap(orgNode);\n    Map<String, List<Node>> actualNode = childNodesToNodeMap(orgNode);\n    assertStringField(childNodesToMap(actualNode.get(\n        Organization.Field.ADDRESS.toString()).get(0)), expected.getAddress()\n        .getFormatted(), Address.Field.FORMATTED);\n    assertStringField(actual, expected.getDescription(),\n        Organization.Field.DESCRIPTION);\n    // assertDateField(actual, expected.getEndDate(),\n    // Organization.Field.END_DATE);\n    assertStringField(actual, expected.getField(), Organization.Field.FIELD);\n    assertStringField(actual, expected.getName(), Organization.Field.NAME);\n    assertStringField(actual, expected.getSalary(), Organization.Field.SALARY);\n    // assertDateField(actual, expected.getStartDate(),\n    // Organization.Field.START_DATE);\n    assertStringField(actual, expected.getSubField(),\n        Organization.Field.SUB_FIELD);\n    assertStringField(actual, expected.getTitle(), Organization.Field.TITLE);\n    assertStringField(actual, expected.getWebpage(), Organization.Field.WEBPAGE);\n    assertStringField(actual, expected.getType(), Organization.Field.TYPE);\n  }\n\n  private void assertBooleanField(Map<String, List<String>> result,\n      boolean expected, Object field) {\n    assertEquals(expected, Boolean.parseBoolean(result.get(field.toString())\n        .get(0)));\n  }\n\n  @SuppressWarnings(\"boxing\")\n  private void assertFloatField(Map<String, List<String>> result, Float expected, Object field) {\n    assertEquals(expected.floatValue(), Float.valueOf(result.get(field.toString()).get(0)), 0);\n  }\n\n  private void assertStringField(Map<String, List<String>> result,\n      String expected, Object field) {\n    List<String> v = result.get(field.toString());\n    String t;\n    if ( v == null || v.isEmpty()) {\n      if (expected == null ) {\n        return;\n      }\n      t = \"\";\n    } else {\n      t = v.get(0);\n    }\n    assertEquals(expected, t);\n  }\n\n  private void assertStringListField(Map<String, List<String>> result,\n      List<String> list, Person.Field field) {\n    assertEquals(list.size(), result.get(field.toString()).size());\n    for (int i = 0; i < list.size(); i++) {\n      assertEquals(list.get(i), result.get(field.toString()).get(i));\n    }\n  }\n\n  private void assertEnumField(Map<String, List<Node>> result, Enum<?> expected,\n      Person.Field field) {\n    Map<String, List<String>> actual = childNodesToMap(result.get(\n        field.toString()).get(0));\n    assertEquals(expected.getDisplayValue(), actual.get(\"displayValue\").get(0));\n    assertEquals(expected.getValue().toString(), actual.get(\"value\").get(0));\n  }\n\n  private void assertListEnumField(Map<String, List<Node>> result,\n      List<? extends Enum<? extends Enum.EnumKey>> expected, Person.Field field) {\n    List<Node> actual = result.get(field.toString());\n    for (int i = 0; i < actual.size(); i++) {\n      Map<String, List<String>> nm = childNodesToMap(actual.get(i));\n      assertEquals(expected.get(i).getDisplayValue(), nm.get(\"displayValue\")\n          .get(0));\n      assertEquals(expected.get(i).getValue().toString(), nm.get(\"value\")\n          .get(0));\n    }\n  }\n\n  /**\n   * Expected response for a list of people in json:\n   *\n   * { \"totalResults\" : 3,\n   *     \"startIndex\" : 0\n   *     \"entry\" : [ {<jane doe>}, // layed out like above\n   * {<george doe>}, {<maija m>}, ] }\n   *\n   * @throws Exception\n   *           if test encounters an error\n   */\n  @Test\n  public void testGetPeople() throws Exception {\n    Map<String, String> extraParams = Maps.newHashMap();\n    extraParams.put(\"sortBy\", \"name\");\n    extraParams.put(\"sortOrder\", null);\n    extraParams.put(\"filterBy\", null);\n    extraParams.put(\"startIndex\", null);\n    extraParams.put(\"count\", \"20\");\n    extraParams.put(\"fields\", null);\n\n    // Currently, for Shindig @all == @friends\n    String resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Map<String, List<String>> result = childNodesToMap(resultNodeList.item(0));\n    Map<String, List<Node>> resultNodes = childNodesToNodeMap(resultNodeList\n        .item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"0\", result.get(\"startIndex\").get(0));\n\n    // The users should be in alphabetical order\n    List<Node> listNodes = resultNodes.get(\"list\");\n    Map<String, List<Node>> listNodesChildMap = childNodesToNodeMap(listNodes.get(0));\n    List<Node> entries = listNodesChildMap.get(\"entry\");\n\n    Map<String, List<Node>> entryOne = childNodesToNodeMap(entries.get(0));\n    assertPerson(childNodesToNodeMap(entryOne.get(\"person\").get(0)),\n        \"george.doe\", \"George Doe\");\n\n    Map<String, List<Node>> entryTwo = childNodesToNodeMap(entries.get(1));\n    assertPerson(childNodesToNodeMap(entryTwo.get(\"person\").get(0)),\n        \"jane.doe\", \"Jane Doe\");\n  }\n\n  @Test\n  public void testGetPeoplePagination() throws Exception {\n    Map<String, String> extraParams = Maps.newHashMap();\n    extraParams.put(\"sortBy\", \"name\");\n    extraParams.put(\"sortOrder\", null);\n    extraParams.put(\"filterBy\", null);\n    extraParams.put(\"startIndex\", \"0\");\n    extraParams.put(\"count\", \"1\");\n    extraParams.put(\"fields\", null);\n\n    String resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams,\n        \"xml\", \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    NodeList resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    Map<String, List<String>> result = childNodesToMap(resultNodeList.item(0));\n    Map<String, List<Node>> resultNodes = childNodesToNodeMap(resultNodeList\n        .item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"0\", result.get(\"startIndex\").get(0));\n\n    List<Node> listNodes = resultNodes.get(\"list\");\n    Map<String, List<Node>> listNodesChildMap = childNodesToNodeMap(listNodes.get(0));\n    List<Node> entries = listNodesChildMap.get(\"entry\");\n\n    Map<String, List<Node>> entryOne = childNodesToNodeMap(entries.get(0));\n\n    assertPerson(childNodesToNodeMap(entryOne.get(\"person\").get(0)),\n        \"george.doe\", \"George Doe\");\n\n    // Get the second page\n    extraParams.put(\"startIndex\", \"1\");\n    resp = getResponse(\"/people/john.doe/@friends\", \"GET\", extraParams, \"xml\",\n        \"application/xml\");\n\n    XSDValidator.validateOpenSocial(resp);\n\n    resultNodeList = xp.getMatchingNodes(\"/:response\", XMLUnit.buildTestDocument(resp));\n    assertEquals(1, resultNodeList.getLength());\n\n    result = childNodesToMap(resultNodeList.item(0));\n    resultNodes = childNodesToNodeMap(resultNodeList.item(0));\n\n    assertEquals(\"3\", result.get(\"totalResults\").get(0));\n    assertEquals(\"1\", result.get(\"startIndex\").get(0));\n\n    listNodes = resultNodes.get(\"list\");\n    listNodesChildMap = childNodesToNodeMap(listNodes.get(0));\n    entries = listNodesChildMap.get(\"entry\");\n\n    Map<String, List<Node>> entryTwo = childNodesToNodeMap(entries.get(0));\n    assertPerson(childNodesToNodeMap(entryTwo.get(\"person\").get(0)),\n        \"jane.doe\", \"Jane Doe\");\n  }\n\n  private void assertPerson(Map<String, List<Node>> person, String expectedId,\n      String expectedName) throws Exception {\n    assertEquals(expectedId, person.get(\"id\").get(0).getTextContent());\n    assertEquals(expectedName, childNodesToMap(person.get(\"name\").get(0)).get(\n        \"formatted\").get(0));\n  }\n\n  // TODO: Add tests for fields parameter\n  // TODO: Add tests for networkDistance\n}\n","lineNo":556}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.shindig.gadgets.oauth2;\n\nimport java.util.Set;\n\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.oauth2.logger.FilteredLogger;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2CacheException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Encrypter;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2PersistenceException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Persister;\n\nimport com.google.inject.Inject;\n\n/**\n * see {@link OAuth2Store}\n *\n * Default OAuth2Store.\n *\n * Uses 3 Guice bindings to achieve storage implementation.\n *\n * 1) {@link OAuth2Persister} 2) {@link OAuth2Cache} 3) {@link OAuth2Encrypter}\n *\n */\npublic class BasicOAuth2Store implements OAuth2Store {\n  private final static String LOG_CLASS = BasicOAuth2Store.class.getName();\n  private static final FilteredLogger LOG = FilteredLogger\n      .getFilteredLogger(BasicOAuth2Store.LOG_CLASS);\n\n  private final OAuth2Cache cache;\n  private final String globalRedirectUri;\n  private final OAuth2Persister persister;\n\n  @Inject\n  public BasicOAuth2Store(final OAuth2Cache cache, final OAuth2Persister persister,\n      final String globalRedirectUri) {\n    this.cache = cache;\n    this.persister = persister;\n    this.globalRedirectUri = globalRedirectUri;\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.log(\"this.cache = {0}\", this.cache);\n      BasicOAuth2Store.LOG.log(\"this.persister = {0}\", this.persister);\n      BasicOAuth2Store.LOG.log(\"this.globalRedirectUri = {0}\", this.globalRedirectUri);\n    }\n  }\n\n  public boolean clearCache() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"clearCache\");\n    }\n\n    try {\n      this.cache.clearClients();\n      this.cache.clearTokens();\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error clearing OAuth2 cache\", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error clearing OAuth2 cache\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Token createToken() {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"createToken\");\n    }\n\n    final OAuth2Token ret = this.persister.createToken();\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Client getClient(final String gadgetUri, final String serviceName)\n      throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getClient\", new Object[] {\n          gadgetUri, serviceName });\n    }\n\n    final Integer index = this.cache.getClientIndex(gadgetUri, serviceName);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"index = {0}\", index);\n    }\n\n    OAuth2Client client = this.cache.getClient(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"client from cache = {0}\", client);\n    }\n\n    if (client == null) {\n      try {\n        client = this.persister.findClient(gadgetUri, serviceName);\n        if (client != null) {\n          this.cache.storeClient(client);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error loading OAuth2 client \", e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 client \"\n            + serviceName, e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getClient\", client);\n    }\n\n    return client;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final Integer index) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", index);\n    }\n\n    final OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final String gadgetUri, final String serviceName,\n      final String user, final String scope) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", new Object[] {\n          gadgetUri, serviceName, user, scope });\n    }\n\n    final Integer index = this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n\n    OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if ((ret == null) || (!ret.isValid())) {\n      final OAuth2Client client = this.getClient(gadgetUri, serviceName);\n\n      if (client != null) {\n        final OAuth2Token accessToken = this.getToken(gadgetUri, serviceName, user, scope,\n            OAuth2Token.Type.ACCESS);\n        final OAuth2Token refreshToken = this.getToken(gadgetUri, serviceName, user, scope,\n            OAuth2Token.Type.REFRESH);\n\n        final BasicOAuth2Accessor newAccessor = new BasicOAuth2Accessor(gadgetUri, serviceName,\n            user, scope, client.isAllowModuleOverride(), this, this.globalRedirectUri);\n        newAccessor.setAccessToken(accessToken);\n        newAccessor.setAuthorizationUrl(client.getAuthorizationUrl());\n        newAccessor.setClientAuthenticationType(client.getClientAuthenticationType());\n        newAccessor.setAuthorizationHeader(client.isAuthorizationHeader());\n        newAccessor.setUrlParameter(client.isUrlParameter());\n        newAccessor.setClientId(client.getClientId());\n        newAccessor.setClientSecret(client.getClientSecret());\n        newAccessor.setGrantType(client.getGrantType());\n        newAccessor.setRedirectUri(client.getRedirectUri());\n        newAccessor.setRefreshToken(refreshToken);\n        newAccessor.setTokenUrl(client.getTokenUrl());\n        newAccessor.setType(client.getType());\n        ret = newAccessor;\n\n        this.storeOAuth2Accessor(ret);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public Integer getOAuth2AccessorIndex(final String gadgetUri, final String serviceName,\n      final String user, final String scope) {\n    return this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n  }\n\n  public OAuth2Token getToken(final String gadgetUri, final String serviceName, final String user,\n      final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getToken\", new Object[] {\n          gadgetUri, serviceName, user, scope, type });\n    }\n\n    final Integer index = this.cache.getTokenIndex(gadgetUri, serviceName, user, scope, type);\n    OAuth2Token token = this.cache.getToken(index);\n    if (token == null) {\n      try {\n        token = this.persister.findToken(gadgetUri, serviceName, user, scope, type);\n        if (token != null) {\n          this.cache.storeToken(token);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \" + index,\n            e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getToken\", token);\n    }\n\n    return token;\n  }\n\n  public boolean init() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"init\");\n    }\n\n    this.clearCache();\n\n    try {\n      final Set<OAuth2Client> clients = this.persister.loadClients();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"clients = {0}\", clients);\n      }\n      this.cache.storeClients(clients);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 clients\", e);\n    }\n\n    try {\n      final Set<OAuth2Token> tokens = this.persister.loadTokens();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"tokens = {0}\", tokens);\n      }\n      this.cache.storeTokens(tokens);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 tokens\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"init\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Accessor removeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", accessor);\n    }\n\n    final OAuth2Accessor ret = null;\n\n    if (accessor != null) {\n      final Integer index = this.cache.getOAuth2AccessorIndex(accessor.getGadgetUri(),\n          accessor.getServiceName(), accessor.getUser(), accessor.getScope());\n      return this.cache.removeOAuth2Accessor(index);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Token removeToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n    }\n\n    if (token != null) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return this.removeToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n          token.getScope(), token.getType());\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", null);\n    }\n\n    return null;\n  }\n\n  public OAuth2Token removeToken(final String gadgetUri, final String serviceName,\n      final String user, final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", new Object[] {\n          gadgetUri, serviceName, user, scope, type });\n    }\n\n    final Integer index = this.cache.getTokenIndex(gadgetUri, serviceName, user, scope, type);\n    try {\n      final OAuth2Token token = this.cache.removeToken(index);\n      if (token != null) {\n        this.persister.removeToken(gadgetUri, serviceName, user, scope, type);\n      }\n\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return token;\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error loading OAuth2 token \", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \"\n          + serviceName, e);\n    }\n  }\n\n  public static boolean runImport(final OAuth2Persister source, final OAuth2Persister target,\n      final boolean clean) {\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"runImport\", new Object[] { source,\n          target, clean });\n    }\n\n    // No import for default persistence\n    return false;\n  }\n\n  public void setToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"setToken\", token);\n    }\n\n    if (token != null) {\n      final Integer index = this.cache.getTokenIndex(token);\n      final OAuth2Token existingToken = this.getToken(token.getGadgetUri(), token.getServiceName(),\n          token.getUser(), token.getScope(), token.getType());\n      try {\n        if (existingToken == null) {\n          this.persister.insertToken(token);\n        } else {\n          this.cache.removeToken(index);\n          this.persister.updateToken(token);\n        }\n        this.cache.storeToken(token);\n      } catch (final OAuth2CacheException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n            e);\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n            e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"setToken\");\n    }\n  }\n\n  public void storeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\", accessor);\n    }\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\");\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth2;\n\nimport com.google.inject.Inject;\n\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.oauth2.logger.FilteredLogger;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2CacheException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2PersistenceException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Persister;\n\nimport java.util.Set;\n\n/**\n * see {@link OAuth2Store}\n *\n * Default OAuth2Store.\n *\n * Uses 3 Guice bindings to achieve storage implementation.\n *\n * 1) {@link OAuth2Persister} 2) {@link OAuth2Cache} 3) {@link OAuth2Encrypter}\n *\n */\npublic class BasicOAuth2Store implements OAuth2Store {\n  private final static String LOG_CLASS = BasicOAuth2Store.class.getName();\n  private static final FilteredLogger LOG = FilteredLogger\n          .getFilteredLogger(BasicOAuth2Store.LOG_CLASS);\n\n  private final OAuth2Cache cache;\n  private final String globalRedirectUri;\n  private final OAuth2Persister persister;\n\n  @Inject\n  public BasicOAuth2Store(final OAuth2Cache cache, final OAuth2Persister persister,\n          final String globalRedirectUri) {\n    this.cache = cache;\n    this.persister = persister;\n    this.globalRedirectUri = globalRedirectUri;\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.log(\"this.cache = {0}\", this.cache);\n      BasicOAuth2Store.LOG.log(\"this.persister = {0}\", this.persister);\n      BasicOAuth2Store.LOG.log(\"this.globalRedirectUri = {0}\", this.globalRedirectUri);\n    }\n  }\n\n  public boolean clearCache() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"clearCache\");\n    }\n\n    try {\n      this.cache.clearClients();\n      this.cache.clearTokens();\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error clearing OAuth2 cache\", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error clearing OAuth2 cache\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Token createToken() {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"createToken\");\n    }\n\n    final OAuth2Token ret = this.persister.createToken();\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Client getClient(final String gadgetUri, final String serviceName)\n          throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getClient\", new Object[] {\n              gadgetUri, serviceName });\n    }\n\n    final Integer index = this.cache.getClientIndex(gadgetUri, serviceName);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"index = {0}\", index);\n    }\n\n    OAuth2Client client = this.cache.getClient(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"client from cache = {0}\", client);\n    }\n\n    if (client == null) {\n      try {\n        client = this.persister.findClient(gadgetUri, serviceName);\n        if (client != null) {\n          this.cache.storeClient(client);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error loading OAuth2 client \", e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 client \"\n                + serviceName, e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getClient\", client);\n    }\n\n    return client;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final Integer index) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", index);\n    }\n\n    final OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final String gadgetUri, final String serviceName,\n          final String user, final String scope) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", new Object[] {\n              gadgetUri, serviceName, user, scope });\n    }\n\n    final Integer index = this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n\n    OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if ((ret == null) || (!ret.isValid())) {\n      final OAuth2Client client = this.getClient(gadgetUri, serviceName);\n\n      if (client != null) {\n        final OAuth2Token accessToken = this.getToken(gadgetUri, serviceName, user, scope,\n                OAuth2Token.Type.ACCESS);\n        final OAuth2Token refreshToken = this.getToken(gadgetUri, serviceName, user, scope,\n                OAuth2Token.Type.REFRESH);\n\n        final BasicOAuth2Accessor newAccessor = new BasicOAuth2Accessor(gadgetUri, serviceName,\n                user, scope, client.isAllowModuleOverride(), this, this.globalRedirectUri);\n        newAccessor.setAccessToken(accessToken);\n        newAccessor.setAuthorizationUrl(client.getAuthorizationUrl());\n        newAccessor.setClientAuthenticationType(client.getClientAuthenticationType());\n        newAccessor.setAuthorizationHeader(client.isAuthorizationHeader());\n        newAccessor.setUrlParameter(client.isUrlParameter());\n        newAccessor.setClientId(client.getClientId());\n        newAccessor.setClientSecret(client.getClientSecret());\n        newAccessor.setGrantType(client.getGrantType());\n        newAccessor.setRedirectUri(client.getRedirectUri());\n        newAccessor.setRefreshToken(refreshToken);\n        newAccessor.setTokenUrl(client.getTokenUrl());\n        newAccessor.setType(client.getType());\n        ret = newAccessor;\n\n        this.storeOAuth2Accessor(ret);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public Integer getOAuth2AccessorIndex(final String gadgetUri, final String serviceName,\n          final String user, final String scope) {\n    return this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n  }\n\n  public OAuth2Token getToken(final String gadgetUri, final String serviceName, final String user,\n          final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getToken\", new Object[] {\n              gadgetUri, serviceName, user, scope, type });\n    }\n\n    final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n    final Integer index = this.cache.getTokenIndex(processedGadgetUri, serviceName, user, scope,\n            type);\n    OAuth2Token token = this.cache.getToken(index);\n    if (token == null) {\n      try {\n        token = this.persister.findToken(processedGadgetUri, serviceName, user, scope, type);\n        if (token != null) {\n          this.cache.storeToken(token);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \" + index,\n                e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getToken\", token);\n    }\n\n    return token;\n  }\n\n  public boolean init() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"init\");\n    }\n\n    this.clearCache();\n\n    try {\n      final Set<OAuth2Client> clients = this.persister.loadClients();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"clients = {0}\", clients);\n      }\n      this.cache.storeClients(clients);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 clients\", e);\n    }\n\n    try {\n      final Set<OAuth2Token> tokens = this.persister.loadTokens();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"tokens = {0}\", tokens);\n      }\n      this.cache.storeTokens(tokens);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 tokens\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"init\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Accessor removeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", accessor);\n    }\n\n    final OAuth2Accessor ret = null;\n\n    if (accessor != null) {\n      final Integer index = this.cache.getOAuth2AccessorIndex(accessor.getGadgetUri(),\n              accessor.getServiceName(), accessor.getUser(), accessor.getScope());\n      return this.cache.removeOAuth2Accessor(index);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Token removeToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n    }\n\n    if (token != null) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return this.removeToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n              token.getScope(), token.getType());\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", null);\n    }\n\n    return null;\n  }\n\n  public OAuth2Token removeToken(final String gadgetUri, final String serviceName,\n          final String user, final String scope, final OAuth2Token.Type type)\n          throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", new Object[] {\n              gadgetUri, serviceName, user, scope, type });\n    }\n\n    final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n    final Integer index = this.cache.getTokenIndex(processedGadgetUri, serviceName, user, scope,\n            type);\n    try {\n      final OAuth2Token token = this.cache.removeToken(index);\n      if (token != null) {\n        this.persister.removeToken(processedGadgetUri, serviceName, user, scope, type);\n      }\n\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return token;\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error loading OAuth2 token \", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \"\n              + serviceName, e);\n    }\n  }\n\n  public static boolean runImport(final OAuth2Persister source, final OAuth2Persister target,\n          final boolean clean) {\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"runImport\", new Object[] { source,\n              target, clean });\n    }\n\n    // No import for default persistence\n    return false;\n  }\n\n  public void setToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"setToken\", token);\n    }\n\n    if (token != null) {\n      final String gadgetUri = token.getGadgetUri();\n      final String serviceName = token.getServiceName();\n\n      final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n      token.setGadgetUri(processedGadgetUri);\n\n      final Integer index = this.cache.getTokenIndex(token);\n      final OAuth2Token existingToken = this.getToken(processedGadgetUri, token.getServiceName(),\n              token.getUser(), token.getScope(), token.getType());\n      try {\n        if (existingToken == null) {\n          this.persister.insertToken(token);\n        } else {\n          this.cache.removeToken(index);\n          this.persister.updateToken(token);\n        }\n        this.cache.storeToken(token);\n      } catch (final OAuth2CacheException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n                e);\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n                e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"setToken\");\n    }\n  }\n\n  public void storeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\", accessor);\n    }\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\");\n    }\n  }\n\n  protected String getGadgetUri(final String gadgetUri, final String serviceName)\n          throws GadgetException {\n    String ret = gadgetUri;\n    final OAuth2Client client = this.getClient(ret, serviceName);\n    if (client != null) {\n      if (client.isSharedToken()) {\n        ret = client.getClientId() + ':' + client.getServiceName();\n      }\n    }\n\n    return ret;\n  }\n}\n","lineNo":223}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.shindig.gadgets.oauth2;\n\nimport java.util.Set;\n\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.oauth2.logger.FilteredLogger;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2CacheException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Encrypter;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2PersistenceException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Persister;\n\nimport com.google.inject.Inject;\n\n/**\n * see {@link OAuth2Store}\n *\n * Default OAuth2Store.\n *\n * Uses 3 Guice bindings to achieve storage implementation.\n *\n * 1) {@link OAuth2Persister} 2) {@link OAuth2Cache} 3) {@link OAuth2Encrypter}\n *\n */\npublic class BasicOAuth2Store implements OAuth2Store {\n  private final static String LOG_CLASS = BasicOAuth2Store.class.getName();\n  private static final FilteredLogger LOG = FilteredLogger\n      .getFilteredLogger(BasicOAuth2Store.LOG_CLASS);\n\n  private final OAuth2Cache cache;\n  private final String globalRedirectUri;\n  private final OAuth2Persister persister;\n\n  @Inject\n  public BasicOAuth2Store(final OAuth2Cache cache, final OAuth2Persister persister,\n      final String globalRedirectUri) {\n    this.cache = cache;\n    this.persister = persister;\n    this.globalRedirectUri = globalRedirectUri;\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.log(\"this.cache = {0}\", this.cache);\n      BasicOAuth2Store.LOG.log(\"this.persister = {0}\", this.persister);\n      BasicOAuth2Store.LOG.log(\"this.globalRedirectUri = {0}\", this.globalRedirectUri);\n    }\n  }\n\n  public boolean clearCache() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"clearCache\");\n    }\n\n    try {\n      this.cache.clearClients();\n      this.cache.clearTokens();\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error clearing OAuth2 cache\", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error clearing OAuth2 cache\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Token createToken() {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"createToken\");\n    }\n\n    final OAuth2Token ret = this.persister.createToken();\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Client getClient(final String gadgetUri, final String serviceName)\n      throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getClient\", new Object[] {\n          gadgetUri, serviceName });\n    }\n\n    final Integer index = this.cache.getClientIndex(gadgetUri, serviceName);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"index = {0}\", index);\n    }\n\n    OAuth2Client client = this.cache.getClient(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"client from cache = {0}\", client);\n    }\n\n    if (client == null) {\n      try {\n        client = this.persister.findClient(gadgetUri, serviceName);\n        if (client != null) {\n          this.cache.storeClient(client);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error loading OAuth2 client \", e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 client \"\n            + serviceName, e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getClient\", client);\n    }\n\n    return client;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final Integer index) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", index);\n    }\n\n    final OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final String gadgetUri, final String serviceName,\n      final String user, final String scope) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", new Object[] {\n          gadgetUri, serviceName, user, scope });\n    }\n\n    final Integer index = this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n\n    OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if ((ret == null) || (!ret.isValid())) {\n      final OAuth2Client client = this.getClient(gadgetUri, serviceName);\n\n      if (client != null) {\n        final OAuth2Token accessToken = this.getToken(gadgetUri, serviceName, user, scope,\n            OAuth2Token.Type.ACCESS);\n        final OAuth2Token refreshToken = this.getToken(gadgetUri, serviceName, user, scope,\n            OAuth2Token.Type.REFRESH);\n\n        final BasicOAuth2Accessor newAccessor = new BasicOAuth2Accessor(gadgetUri, serviceName,\n            user, scope, client.isAllowModuleOverride(), this, this.globalRedirectUri);\n        newAccessor.setAccessToken(accessToken);\n        newAccessor.setAuthorizationUrl(client.getAuthorizationUrl());\n        newAccessor.setClientAuthenticationType(client.getClientAuthenticationType());\n        newAccessor.setAuthorizationHeader(client.isAuthorizationHeader());\n        newAccessor.setUrlParameter(client.isUrlParameter());\n        newAccessor.setClientId(client.getClientId());\n        newAccessor.setClientSecret(client.getClientSecret());\n        newAccessor.setGrantType(client.getGrantType());\n        newAccessor.setRedirectUri(client.getRedirectUri());\n        newAccessor.setRefreshToken(refreshToken);\n        newAccessor.setTokenUrl(client.getTokenUrl());\n        newAccessor.setType(client.getType());\n        ret = newAccessor;\n\n        this.storeOAuth2Accessor(ret);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public Integer getOAuth2AccessorIndex(final String gadgetUri, final String serviceName,\n      final String user, final String scope) {\n    return this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n  }\n\n  public OAuth2Token getToken(final String gadgetUri, final String serviceName, final String user,\n      final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getToken\", new Object[] {\n          gadgetUri, serviceName, user, scope, type });\n    }\n\n    final Integer index = this.cache.getTokenIndex(gadgetUri, serviceName, user, scope, type);\n    OAuth2Token token = this.cache.getToken(index);\n    if (token == null) {\n      try {\n        token = this.persister.findToken(gadgetUri, serviceName, user, scope, type);\n        if (token != null) {\n          this.cache.storeToken(token);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \" + index,\n            e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getToken\", token);\n    }\n\n    return token;\n  }\n\n  public boolean init() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"init\");\n    }\n\n    this.clearCache();\n\n    try {\n      final Set<OAuth2Client> clients = this.persister.loadClients();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"clients = {0}\", clients);\n      }\n      this.cache.storeClients(clients);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 clients\", e);\n    }\n\n    try {\n      final Set<OAuth2Token> tokens = this.persister.loadTokens();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"tokens = {0}\", tokens);\n      }\n      this.cache.storeTokens(tokens);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 tokens\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"init\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Accessor removeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", accessor);\n    }\n\n    final OAuth2Accessor ret = null;\n\n    if (accessor != null) {\n      final Integer index = this.cache.getOAuth2AccessorIndex(accessor.getGadgetUri(),\n          accessor.getServiceName(), accessor.getUser(), accessor.getScope());\n      return this.cache.removeOAuth2Accessor(index);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Token removeToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n    }\n\n    if (token != null) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return this.removeToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n          token.getScope(), token.getType());\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", null);\n    }\n\n    return null;\n  }\n\n  public OAuth2Token removeToken(final String gadgetUri, final String serviceName,\n      final String user, final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", new Object[] {\n          gadgetUri, serviceName, user, scope, type });\n    }\n\n    final Integer index = this.cache.getTokenIndex(gadgetUri, serviceName, user, scope, type);\n    try {\n      final OAuth2Token token = this.cache.removeToken(index);\n      if (token != null) {\n        this.persister.removeToken(gadgetUri, serviceName, user, scope, type);\n      }\n\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return token;\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error loading OAuth2 token \", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \"\n          + serviceName, e);\n    }\n  }\n\n  public static boolean runImport(final OAuth2Persister source, final OAuth2Persister target,\n      final boolean clean) {\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"runImport\", new Object[] { source,\n          target, clean });\n    }\n\n    // No import for default persistence\n    return false;\n  }\n\n  public void setToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"setToken\", token);\n    }\n\n    if (token != null) {\n      final Integer index = this.cache.getTokenIndex(token);\n      final OAuth2Token existingToken = this.getToken(token.getGadgetUri(), token.getServiceName(),\n          token.getUser(), token.getScope(), token.getType());\n      try {\n        if (existingToken == null) {\n          this.persister.insertToken(token);\n        } else {\n          this.cache.removeToken(index);\n          this.persister.updateToken(token);\n        }\n        this.cache.storeToken(token);\n      } catch (final OAuth2CacheException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n            e);\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n            e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"setToken\");\n    }\n  }\n\n  public void storeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\", accessor);\n    }\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\");\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth2;\n\nimport com.google.inject.Inject;\n\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.oauth2.logger.FilteredLogger;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2CacheException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2PersistenceException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Persister;\n\nimport java.util.Set;\n\n/**\n * see {@link OAuth2Store}\n *\n * Default OAuth2Store.\n *\n * Uses 3 Guice bindings to achieve storage implementation.\n *\n * 1) {@link OAuth2Persister} 2) {@link OAuth2Cache} 3) {@link OAuth2Encrypter}\n *\n */\npublic class BasicOAuth2Store implements OAuth2Store {\n  private final static String LOG_CLASS = BasicOAuth2Store.class.getName();\n  private static final FilteredLogger LOG = FilteredLogger\n          .getFilteredLogger(BasicOAuth2Store.LOG_CLASS);\n\n  private final OAuth2Cache cache;\n  private final String globalRedirectUri;\n  private final OAuth2Persister persister;\n\n  @Inject\n  public BasicOAuth2Store(final OAuth2Cache cache, final OAuth2Persister persister,\n          final String globalRedirectUri) {\n    this.cache = cache;\n    this.persister = persister;\n    this.globalRedirectUri = globalRedirectUri;\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.log(\"this.cache = {0}\", this.cache);\n      BasicOAuth2Store.LOG.log(\"this.persister = {0}\", this.persister);\n      BasicOAuth2Store.LOG.log(\"this.globalRedirectUri = {0}\", this.globalRedirectUri);\n    }\n  }\n\n  public boolean clearCache() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"clearCache\");\n    }\n\n    try {\n      this.cache.clearClients();\n      this.cache.clearTokens();\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error clearing OAuth2 cache\", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error clearing OAuth2 cache\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Token createToken() {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"createToken\");\n    }\n\n    final OAuth2Token ret = this.persister.createToken();\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Client getClient(final String gadgetUri, final String serviceName)\n          throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getClient\", new Object[] {\n              gadgetUri, serviceName });\n    }\n\n    final Integer index = this.cache.getClientIndex(gadgetUri, serviceName);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"index = {0}\", index);\n    }\n\n    OAuth2Client client = this.cache.getClient(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"client from cache = {0}\", client);\n    }\n\n    if (client == null) {\n      try {\n        client = this.persister.findClient(gadgetUri, serviceName);\n        if (client != null) {\n          this.cache.storeClient(client);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error loading OAuth2 client \", e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 client \"\n                + serviceName, e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getClient\", client);\n    }\n\n    return client;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final Integer index) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", index);\n    }\n\n    final OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final String gadgetUri, final String serviceName,\n          final String user, final String scope) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", new Object[] {\n              gadgetUri, serviceName, user, scope });\n    }\n\n    final Integer index = this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n\n    OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if ((ret == null) || (!ret.isValid())) {\n      final OAuth2Client client = this.getClient(gadgetUri, serviceName);\n\n      if (client != null) {\n        final OAuth2Token accessToken = this.getToken(gadgetUri, serviceName, user, scope,\n                OAuth2Token.Type.ACCESS);\n        final OAuth2Token refreshToken = this.getToken(gadgetUri, serviceName, user, scope,\n                OAuth2Token.Type.REFRESH);\n\n        final BasicOAuth2Accessor newAccessor = new BasicOAuth2Accessor(gadgetUri, serviceName,\n                user, scope, client.isAllowModuleOverride(), this, this.globalRedirectUri);\n        newAccessor.setAccessToken(accessToken);\n        newAccessor.setAuthorizationUrl(client.getAuthorizationUrl());\n        newAccessor.setClientAuthenticationType(client.getClientAuthenticationType());\n        newAccessor.setAuthorizationHeader(client.isAuthorizationHeader());\n        newAccessor.setUrlParameter(client.isUrlParameter());\n        newAccessor.setClientId(client.getClientId());\n        newAccessor.setClientSecret(client.getClientSecret());\n        newAccessor.setGrantType(client.getGrantType());\n        newAccessor.setRedirectUri(client.getRedirectUri());\n        newAccessor.setRefreshToken(refreshToken);\n        newAccessor.setTokenUrl(client.getTokenUrl());\n        newAccessor.setType(client.getType());\n        ret = newAccessor;\n\n        this.storeOAuth2Accessor(ret);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public Integer getOAuth2AccessorIndex(final String gadgetUri, final String serviceName,\n          final String user, final String scope) {\n    return this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n  }\n\n  public OAuth2Token getToken(final String gadgetUri, final String serviceName, final String user,\n          final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getToken\", new Object[] {\n              gadgetUri, serviceName, user, scope, type });\n    }\n\n    final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n    final Integer index = this.cache.getTokenIndex(processedGadgetUri, serviceName, user, scope,\n            type);\n    OAuth2Token token = this.cache.getToken(index);\n    if (token == null) {\n      try {\n        token = this.persister.findToken(processedGadgetUri, serviceName, user, scope, type);\n        if (token != null) {\n          this.cache.storeToken(token);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \" + index,\n                e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getToken\", token);\n    }\n\n    return token;\n  }\n\n  public boolean init() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"init\");\n    }\n\n    this.clearCache();\n\n    try {\n      final Set<OAuth2Client> clients = this.persister.loadClients();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"clients = {0}\", clients);\n      }\n      this.cache.storeClients(clients);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 clients\", e);\n    }\n\n    try {\n      final Set<OAuth2Token> tokens = this.persister.loadTokens();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"tokens = {0}\", tokens);\n      }\n      this.cache.storeTokens(tokens);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 tokens\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"init\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Accessor removeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", accessor);\n    }\n\n    final OAuth2Accessor ret = null;\n\n    if (accessor != null) {\n      final Integer index = this.cache.getOAuth2AccessorIndex(accessor.getGadgetUri(),\n              accessor.getServiceName(), accessor.getUser(), accessor.getScope());\n      return this.cache.removeOAuth2Accessor(index);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Token removeToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n    }\n\n    if (token != null) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return this.removeToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n              token.getScope(), token.getType());\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", null);\n    }\n\n    return null;\n  }\n\n  public OAuth2Token removeToken(final String gadgetUri, final String serviceName,\n          final String user, final String scope, final OAuth2Token.Type type)\n          throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", new Object[] {\n              gadgetUri, serviceName, user, scope, type });\n    }\n\n    final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n    final Integer index = this.cache.getTokenIndex(processedGadgetUri, serviceName, user, scope,\n            type);\n    try {\n      final OAuth2Token token = this.cache.removeToken(index);\n      if (token != null) {\n        this.persister.removeToken(processedGadgetUri, serviceName, user, scope, type);\n      }\n\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return token;\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error loading OAuth2 token \", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \"\n              + serviceName, e);\n    }\n  }\n\n  public static boolean runImport(final OAuth2Persister source, final OAuth2Persister target,\n          final boolean clean) {\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"runImport\", new Object[] { source,\n              target, clean });\n    }\n\n    // No import for default persistence\n    return false;\n  }\n\n  public void setToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"setToken\", token);\n    }\n\n    if (token != null) {\n      final String gadgetUri = token.getGadgetUri();\n      final String serviceName = token.getServiceName();\n\n      final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n      token.setGadgetUri(processedGadgetUri);\n\n      final Integer index = this.cache.getTokenIndex(token);\n      final OAuth2Token existingToken = this.getToken(processedGadgetUri, token.getServiceName(),\n              token.getUser(), token.getScope(), token.getType());\n      try {\n        if (existingToken == null) {\n          this.persister.insertToken(token);\n        } else {\n          this.cache.removeToken(index);\n          this.persister.updateToken(token);\n        }\n        this.cache.storeToken(token);\n      } catch (final OAuth2CacheException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n                e);\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n                e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"setToken\");\n    }\n  }\n\n  public void storeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\", accessor);\n    }\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\");\n    }\n  }\n\n  protected String getGadgetUri(final String gadgetUri, final String serviceName)\n          throws GadgetException {\n    String ret = gadgetUri;\n    final OAuth2Client client = this.getClient(ret, serviceName);\n    if (client != null) {\n      if (client.isSharedToken()) {\n        ret = client.getClientId() + ':' + client.getServiceName();\n      }\n    }\n\n    return ret;\n  }\n}\n","lineNo":335}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.shindig.gadgets.oauth2;\n\nimport java.util.Set;\n\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.oauth2.logger.FilteredLogger;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2CacheException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Encrypter;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2PersistenceException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Persister;\n\nimport com.google.inject.Inject;\n\n/**\n * see {@link OAuth2Store}\n *\n * Default OAuth2Store.\n *\n * Uses 3 Guice bindings to achieve storage implementation.\n *\n * 1) {@link OAuth2Persister} 2) {@link OAuth2Cache} 3) {@link OAuth2Encrypter}\n *\n */\npublic class BasicOAuth2Store implements OAuth2Store {\n  private final static String LOG_CLASS = BasicOAuth2Store.class.getName();\n  private static final FilteredLogger LOG = FilteredLogger\n      .getFilteredLogger(BasicOAuth2Store.LOG_CLASS);\n\n  private final OAuth2Cache cache;\n  private final String globalRedirectUri;\n  private final OAuth2Persister persister;\n\n  @Inject\n  public BasicOAuth2Store(final OAuth2Cache cache, final OAuth2Persister persister,\n      final String globalRedirectUri) {\n    this.cache = cache;\n    this.persister = persister;\n    this.globalRedirectUri = globalRedirectUri;\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.log(\"this.cache = {0}\", this.cache);\n      BasicOAuth2Store.LOG.log(\"this.persister = {0}\", this.persister);\n      BasicOAuth2Store.LOG.log(\"this.globalRedirectUri = {0}\", this.globalRedirectUri);\n    }\n  }\n\n  public boolean clearCache() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"clearCache\");\n    }\n\n    try {\n      this.cache.clearClients();\n      this.cache.clearTokens();\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error clearing OAuth2 cache\", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error clearing OAuth2 cache\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Token createToken() {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"createToken\");\n    }\n\n    final OAuth2Token ret = this.persister.createToken();\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Client getClient(final String gadgetUri, final String serviceName)\n      throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getClient\", new Object[] {\n          gadgetUri, serviceName });\n    }\n\n    final Integer index = this.cache.getClientIndex(gadgetUri, serviceName);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"index = {0}\", index);\n    }\n\n    OAuth2Client client = this.cache.getClient(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"client from cache = {0}\", client);\n    }\n\n    if (client == null) {\n      try {\n        client = this.persister.findClient(gadgetUri, serviceName);\n        if (client != null) {\n          this.cache.storeClient(client);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error loading OAuth2 client \", e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 client \"\n            + serviceName, e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getClient\", client);\n    }\n\n    return client;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final Integer index) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", index);\n    }\n\n    final OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final String gadgetUri, final String serviceName,\n      final String user, final String scope) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", new Object[] {\n          gadgetUri, serviceName, user, scope });\n    }\n\n    final Integer index = this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n\n    OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if ((ret == null) || (!ret.isValid())) {\n      final OAuth2Client client = this.getClient(gadgetUri, serviceName);\n\n      if (client != null) {\n        final OAuth2Token accessToken = this.getToken(gadgetUri, serviceName, user, scope,\n            OAuth2Token.Type.ACCESS);\n        final OAuth2Token refreshToken = this.getToken(gadgetUri, serviceName, user, scope,\n            OAuth2Token.Type.REFRESH);\n\n        final BasicOAuth2Accessor newAccessor = new BasicOAuth2Accessor(gadgetUri, serviceName,\n            user, scope, client.isAllowModuleOverride(), this, this.globalRedirectUri);\n        newAccessor.setAccessToken(accessToken);\n        newAccessor.setAuthorizationUrl(client.getAuthorizationUrl());\n        newAccessor.setClientAuthenticationType(client.getClientAuthenticationType());\n        newAccessor.setAuthorizationHeader(client.isAuthorizationHeader());\n        newAccessor.setUrlParameter(client.isUrlParameter());\n        newAccessor.setClientId(client.getClientId());\n        newAccessor.setClientSecret(client.getClientSecret());\n        newAccessor.setGrantType(client.getGrantType());\n        newAccessor.setRedirectUri(client.getRedirectUri());\n        newAccessor.setRefreshToken(refreshToken);\n        newAccessor.setTokenUrl(client.getTokenUrl());\n        newAccessor.setType(client.getType());\n        ret = newAccessor;\n\n        this.storeOAuth2Accessor(ret);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public Integer getOAuth2AccessorIndex(final String gadgetUri, final String serviceName,\n      final String user, final String scope) {\n    return this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n  }\n\n  public OAuth2Token getToken(final String gadgetUri, final String serviceName, final String user,\n      final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getToken\", new Object[] {\n          gadgetUri, serviceName, user, scope, type });\n    }\n\n    final Integer index = this.cache.getTokenIndex(gadgetUri, serviceName, user, scope, type);\n    OAuth2Token token = this.cache.getToken(index);\n    if (token == null) {\n      try {\n        token = this.persister.findToken(gadgetUri, serviceName, user, scope, type);\n        if (token != null) {\n          this.cache.storeToken(token);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \" + index,\n            e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getToken\", token);\n    }\n\n    return token;\n  }\n\n  public boolean init() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"init\");\n    }\n\n    this.clearCache();\n\n    try {\n      final Set<OAuth2Client> clients = this.persister.loadClients();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"clients = {0}\", clients);\n      }\n      this.cache.storeClients(clients);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 clients\", e);\n    }\n\n    try {\n      final Set<OAuth2Token> tokens = this.persister.loadTokens();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"tokens = {0}\", tokens);\n      }\n      this.cache.storeTokens(tokens);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 tokens\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"init\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Accessor removeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", accessor);\n    }\n\n    final OAuth2Accessor ret = null;\n\n    if (accessor != null) {\n      final Integer index = this.cache.getOAuth2AccessorIndex(accessor.getGadgetUri(),\n          accessor.getServiceName(), accessor.getUser(), accessor.getScope());\n      return this.cache.removeOAuth2Accessor(index);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Token removeToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n    }\n\n    if (token != null) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return this.removeToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n          token.getScope(), token.getType());\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", null);\n    }\n\n    return null;\n  }\n\n  public OAuth2Token removeToken(final String gadgetUri, final String serviceName,\n      final String user, final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", new Object[] {\n          gadgetUri, serviceName, user, scope, type });\n    }\n\n    final Integer index = this.cache.getTokenIndex(gadgetUri, serviceName, user, scope, type);\n    try {\n      final OAuth2Token token = this.cache.removeToken(index);\n      if (token != null) {\n        this.persister.removeToken(gadgetUri, serviceName, user, scope, type);\n      }\n\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return token;\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error loading OAuth2 token \", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \"\n          + serviceName, e);\n    }\n  }\n\n  public static boolean runImport(final OAuth2Persister source, final OAuth2Persister target,\n      final boolean clean) {\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"runImport\", new Object[] { source,\n          target, clean });\n    }\n\n    // No import for default persistence\n    return false;\n  }\n\n  public void setToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"setToken\", token);\n    }\n\n    if (token != null) {\n      final Integer index = this.cache.getTokenIndex(token);\n      final OAuth2Token existingToken = this.getToken(token.getGadgetUri(), token.getServiceName(),\n          token.getUser(), token.getScope(), token.getType());\n      try {\n        if (existingToken == null) {\n          this.persister.insertToken(token);\n        } else {\n          this.cache.removeToken(index);\n          this.persister.updateToken(token);\n        }\n        this.cache.storeToken(token);\n      } catch (final OAuth2CacheException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n            e);\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n            e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"setToken\");\n    }\n  }\n\n  public void storeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\", accessor);\n    }\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\");\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth2;\n\nimport com.google.inject.Inject;\n\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.oauth2.logger.FilteredLogger;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2CacheException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2PersistenceException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Persister;\n\nimport java.util.Set;\n\n/**\n * see {@link OAuth2Store}\n *\n * Default OAuth2Store.\n *\n * Uses 3 Guice bindings to achieve storage implementation.\n *\n * 1) {@link OAuth2Persister} 2) {@link OAuth2Cache} 3) {@link OAuth2Encrypter}\n *\n */\npublic class BasicOAuth2Store implements OAuth2Store {\n  private final static String LOG_CLASS = BasicOAuth2Store.class.getName();\n  private static final FilteredLogger LOG = FilteredLogger\n          .getFilteredLogger(BasicOAuth2Store.LOG_CLASS);\n\n  private final OAuth2Cache cache;\n  private final String globalRedirectUri;\n  private final OAuth2Persister persister;\n\n  @Inject\n  public BasicOAuth2Store(final OAuth2Cache cache, final OAuth2Persister persister,\n          final String globalRedirectUri) {\n    this.cache = cache;\n    this.persister = persister;\n    this.globalRedirectUri = globalRedirectUri;\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.log(\"this.cache = {0}\", this.cache);\n      BasicOAuth2Store.LOG.log(\"this.persister = {0}\", this.persister);\n      BasicOAuth2Store.LOG.log(\"this.globalRedirectUri = {0}\", this.globalRedirectUri);\n    }\n  }\n\n  public boolean clearCache() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"clearCache\");\n    }\n\n    try {\n      this.cache.clearClients();\n      this.cache.clearTokens();\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error clearing OAuth2 cache\", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error clearing OAuth2 cache\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Token createToken() {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"createToken\");\n    }\n\n    final OAuth2Token ret = this.persister.createToken();\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Client getClient(final String gadgetUri, final String serviceName)\n          throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getClient\", new Object[] {\n              gadgetUri, serviceName });\n    }\n\n    final Integer index = this.cache.getClientIndex(gadgetUri, serviceName);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"index = {0}\", index);\n    }\n\n    OAuth2Client client = this.cache.getClient(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"client from cache = {0}\", client);\n    }\n\n    if (client == null) {\n      try {\n        client = this.persister.findClient(gadgetUri, serviceName);\n        if (client != null) {\n          this.cache.storeClient(client);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error loading OAuth2 client \", e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 client \"\n                + serviceName, e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getClient\", client);\n    }\n\n    return client;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final Integer index) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", index);\n    }\n\n    final OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final String gadgetUri, final String serviceName,\n          final String user, final String scope) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", new Object[] {\n              gadgetUri, serviceName, user, scope });\n    }\n\n    final Integer index = this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n\n    OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if ((ret == null) || (!ret.isValid())) {\n      final OAuth2Client client = this.getClient(gadgetUri, serviceName);\n\n      if (client != null) {\n        final OAuth2Token accessToken = this.getToken(gadgetUri, serviceName, user, scope,\n                OAuth2Token.Type.ACCESS);\n        final OAuth2Token refreshToken = this.getToken(gadgetUri, serviceName, user, scope,\n                OAuth2Token.Type.REFRESH);\n\n        final BasicOAuth2Accessor newAccessor = new BasicOAuth2Accessor(gadgetUri, serviceName,\n                user, scope, client.isAllowModuleOverride(), this, this.globalRedirectUri);\n        newAccessor.setAccessToken(accessToken);\n        newAccessor.setAuthorizationUrl(client.getAuthorizationUrl());\n        newAccessor.setClientAuthenticationType(client.getClientAuthenticationType());\n        newAccessor.setAuthorizationHeader(client.isAuthorizationHeader());\n        newAccessor.setUrlParameter(client.isUrlParameter());\n        newAccessor.setClientId(client.getClientId());\n        newAccessor.setClientSecret(client.getClientSecret());\n        newAccessor.setGrantType(client.getGrantType());\n        newAccessor.setRedirectUri(client.getRedirectUri());\n        newAccessor.setRefreshToken(refreshToken);\n        newAccessor.setTokenUrl(client.getTokenUrl());\n        newAccessor.setType(client.getType());\n        ret = newAccessor;\n\n        this.storeOAuth2Accessor(ret);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public Integer getOAuth2AccessorIndex(final String gadgetUri, final String serviceName,\n          final String user, final String scope) {\n    return this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n  }\n\n  public OAuth2Token getToken(final String gadgetUri, final String serviceName, final String user,\n          final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getToken\", new Object[] {\n              gadgetUri, serviceName, user, scope, type });\n    }\n\n    final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n    final Integer index = this.cache.getTokenIndex(processedGadgetUri, serviceName, user, scope,\n            type);\n    OAuth2Token token = this.cache.getToken(index);\n    if (token == null) {\n      try {\n        token = this.persister.findToken(processedGadgetUri, serviceName, user, scope, type);\n        if (token != null) {\n          this.cache.storeToken(token);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \" + index,\n                e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getToken\", token);\n    }\n\n    return token;\n  }\n\n  public boolean init() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"init\");\n    }\n\n    this.clearCache();\n\n    try {\n      final Set<OAuth2Client> clients = this.persister.loadClients();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"clients = {0}\", clients);\n      }\n      this.cache.storeClients(clients);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 clients\", e);\n    }\n\n    try {\n      final Set<OAuth2Token> tokens = this.persister.loadTokens();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"tokens = {0}\", tokens);\n      }\n      this.cache.storeTokens(tokens);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 tokens\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"init\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Accessor removeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", accessor);\n    }\n\n    final OAuth2Accessor ret = null;\n\n    if (accessor != null) {\n      final Integer index = this.cache.getOAuth2AccessorIndex(accessor.getGadgetUri(),\n              accessor.getServiceName(), accessor.getUser(), accessor.getScope());\n      return this.cache.removeOAuth2Accessor(index);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Token removeToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n    }\n\n    if (token != null) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return this.removeToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n              token.getScope(), token.getType());\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", null);\n    }\n\n    return null;\n  }\n\n  public OAuth2Token removeToken(final String gadgetUri, final String serviceName,\n          final String user, final String scope, final OAuth2Token.Type type)\n          throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", new Object[] {\n              gadgetUri, serviceName, user, scope, type });\n    }\n\n    final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n    final Integer index = this.cache.getTokenIndex(processedGadgetUri, serviceName, user, scope,\n            type);\n    try {\n      final OAuth2Token token = this.cache.removeToken(index);\n      if (token != null) {\n        this.persister.removeToken(processedGadgetUri, serviceName, user, scope, type);\n      }\n\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return token;\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error loading OAuth2 token \", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \"\n              + serviceName, e);\n    }\n  }\n\n  public static boolean runImport(final OAuth2Persister source, final OAuth2Persister target,\n          final boolean clean) {\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"runImport\", new Object[] { source,\n              target, clean });\n    }\n\n    // No import for default persistence\n    return false;\n  }\n\n  public void setToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"setToken\", token);\n    }\n\n    if (token != null) {\n      final String gadgetUri = token.getGadgetUri();\n      final String serviceName = token.getServiceName();\n\n      final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n      token.setGadgetUri(processedGadgetUri);\n\n      final Integer index = this.cache.getTokenIndex(token);\n      final OAuth2Token existingToken = this.getToken(processedGadgetUri, token.getServiceName(),\n              token.getUser(), token.getScope(), token.getType());\n      try {\n        if (existingToken == null) {\n          this.persister.insertToken(token);\n        } else {\n          this.cache.removeToken(index);\n          this.persister.updateToken(token);\n        }\n        this.cache.storeToken(token);\n      } catch (final OAuth2CacheException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n                e);\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n                e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"setToken\");\n    }\n  }\n\n  public void storeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\", accessor);\n    }\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\");\n    }\n  }\n\n  protected String getGadgetUri(final String gadgetUri, final String serviceName)\n          throws GadgetException {\n    String ret = gadgetUri;\n    final OAuth2Client client = this.getClient(ret, serviceName);\n    if (client != null) {\n      if (client.isSharedToken()) {\n        ret = client.getClientId() + ':' + client.getServiceName();\n      }\n    }\n\n    return ret;\n  }\n}\n","lineNo":377}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.shindig.gadgets.oauth2;\n\nimport java.util.Set;\n\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.oauth2.logger.FilteredLogger;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2CacheException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Encrypter;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2PersistenceException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Persister;\n\nimport com.google.inject.Inject;\n\n/**\n * see {@link OAuth2Store}\n *\n * Default OAuth2Store.\n *\n * Uses 3 Guice bindings to achieve storage implementation.\n *\n * 1) {@link OAuth2Persister} 2) {@link OAuth2Cache} 3) {@link OAuth2Encrypter}\n *\n */\npublic class BasicOAuth2Store implements OAuth2Store {\n  private final static String LOG_CLASS = BasicOAuth2Store.class.getName();\n  private static final FilteredLogger LOG = FilteredLogger\n      .getFilteredLogger(BasicOAuth2Store.LOG_CLASS);\n\n  private final OAuth2Cache cache;\n  private final String globalRedirectUri;\n  private final OAuth2Persister persister;\n\n  @Inject\n  public BasicOAuth2Store(final OAuth2Cache cache, final OAuth2Persister persister,\n      final String globalRedirectUri) {\n    this.cache = cache;\n    this.persister = persister;\n    this.globalRedirectUri = globalRedirectUri;\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.log(\"this.cache = {0}\", this.cache);\n      BasicOAuth2Store.LOG.log(\"this.persister = {0}\", this.persister);\n      BasicOAuth2Store.LOG.log(\"this.globalRedirectUri = {0}\", this.globalRedirectUri);\n    }\n  }\n\n  public boolean clearCache() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"clearCache\");\n    }\n\n    try {\n      this.cache.clearClients();\n      this.cache.clearTokens();\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error clearing OAuth2 cache\", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error clearing OAuth2 cache\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Token createToken() {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"createToken\");\n    }\n\n    final OAuth2Token ret = this.persister.createToken();\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Client getClient(final String gadgetUri, final String serviceName)\n      throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getClient\", new Object[] {\n          gadgetUri, serviceName });\n    }\n\n    final Integer index = this.cache.getClientIndex(gadgetUri, serviceName);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"index = {0}\", index);\n    }\n\n    OAuth2Client client = this.cache.getClient(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"client from cache = {0}\", client);\n    }\n\n    if (client == null) {\n      try {\n        client = this.persister.findClient(gadgetUri, serviceName);\n        if (client != null) {\n          this.cache.storeClient(client);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error loading OAuth2 client \", e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 client \"\n            + serviceName, e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getClient\", client);\n    }\n\n    return client;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final Integer index) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", index);\n    }\n\n    final OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final String gadgetUri, final String serviceName,\n      final String user, final String scope) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", new Object[] {\n          gadgetUri, serviceName, user, scope });\n    }\n\n    final Integer index = this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n\n    OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if ((ret == null) || (!ret.isValid())) {\n      final OAuth2Client client = this.getClient(gadgetUri, serviceName);\n\n      if (client != null) {\n        final OAuth2Token accessToken = this.getToken(gadgetUri, serviceName, user, scope,\n            OAuth2Token.Type.ACCESS);\n        final OAuth2Token refreshToken = this.getToken(gadgetUri, serviceName, user, scope,\n            OAuth2Token.Type.REFRESH);\n\n        final BasicOAuth2Accessor newAccessor = new BasicOAuth2Accessor(gadgetUri, serviceName,\n            user, scope, client.isAllowModuleOverride(), this, this.globalRedirectUri);\n        newAccessor.setAccessToken(accessToken);\n        newAccessor.setAuthorizationUrl(client.getAuthorizationUrl());\n        newAccessor.setClientAuthenticationType(client.getClientAuthenticationType());\n        newAccessor.setAuthorizationHeader(client.isAuthorizationHeader());\n        newAccessor.setUrlParameter(client.isUrlParameter());\n        newAccessor.setClientId(client.getClientId());\n        newAccessor.setClientSecret(client.getClientSecret());\n        newAccessor.setGrantType(client.getGrantType());\n        newAccessor.setRedirectUri(client.getRedirectUri());\n        newAccessor.setRefreshToken(refreshToken);\n        newAccessor.setTokenUrl(client.getTokenUrl());\n        newAccessor.setType(client.getType());\n        ret = newAccessor;\n\n        this.storeOAuth2Accessor(ret);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public Integer getOAuth2AccessorIndex(final String gadgetUri, final String serviceName,\n      final String user, final String scope) {\n    return this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n  }\n\n  public OAuth2Token getToken(final String gadgetUri, final String serviceName, final String user,\n      final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getToken\", new Object[] {\n          gadgetUri, serviceName, user, scope, type });\n    }\n\n    final Integer index = this.cache.getTokenIndex(gadgetUri, serviceName, user, scope, type);\n    OAuth2Token token = this.cache.getToken(index);\n    if (token == null) {\n      try {\n        token = this.persister.findToken(gadgetUri, serviceName, user, scope, type);\n        if (token != null) {\n          this.cache.storeToken(token);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \" + index,\n            e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getToken\", token);\n    }\n\n    return token;\n  }\n\n  public boolean init() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"init\");\n    }\n\n    this.clearCache();\n\n    try {\n      final Set<OAuth2Client> clients = this.persister.loadClients();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"clients = {0}\", clients);\n      }\n      this.cache.storeClients(clients);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 clients\", e);\n    }\n\n    try {\n      final Set<OAuth2Token> tokens = this.persister.loadTokens();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"tokens = {0}\", tokens);\n      }\n      this.cache.storeTokens(tokens);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 tokens\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"init\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Accessor removeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", accessor);\n    }\n\n    final OAuth2Accessor ret = null;\n\n    if (accessor != null) {\n      final Integer index = this.cache.getOAuth2AccessorIndex(accessor.getGadgetUri(),\n          accessor.getServiceName(), accessor.getUser(), accessor.getScope());\n      return this.cache.removeOAuth2Accessor(index);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Token removeToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n    }\n\n    if (token != null) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return this.removeToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n          token.getScope(), token.getType());\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", null);\n    }\n\n    return null;\n  }\n\n  public OAuth2Token removeToken(final String gadgetUri, final String serviceName,\n      final String user, final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", new Object[] {\n          gadgetUri, serviceName, user, scope, type });\n    }\n\n    final Integer index = this.cache.getTokenIndex(gadgetUri, serviceName, user, scope, type);\n    try {\n      final OAuth2Token token = this.cache.removeToken(index);\n      if (token != null) {\n        this.persister.removeToken(gadgetUri, serviceName, user, scope, type);\n      }\n\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return token;\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error loading OAuth2 token \", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \"\n          + serviceName, e);\n    }\n  }\n\n  public static boolean runImport(final OAuth2Persister source, final OAuth2Persister target,\n      final boolean clean) {\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"runImport\", new Object[] { source,\n          target, clean });\n    }\n\n    // No import for default persistence\n    return false;\n  }\n\n  public void setToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"setToken\", token);\n    }\n\n    if (token != null) {\n      final Integer index = this.cache.getTokenIndex(token);\n      final OAuth2Token existingToken = this.getToken(token.getGadgetUri(), token.getServiceName(),\n          token.getUser(), token.getScope(), token.getType());\n      try {\n        if (existingToken == null) {\n          this.persister.insertToken(token);\n        } else {\n          this.cache.removeToken(index);\n          this.persister.updateToken(token);\n        }\n        this.cache.storeToken(token);\n      } catch (final OAuth2CacheException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n            e);\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n            e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"setToken\");\n    }\n  }\n\n  public void storeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\", accessor);\n    }\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\");\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth2;\n\nimport com.google.inject.Inject;\n\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.oauth2.logger.FilteredLogger;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2CacheException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2PersistenceException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Persister;\n\nimport java.util.Set;\n\n/**\n * see {@link OAuth2Store}\n *\n * Default OAuth2Store.\n *\n * Uses 3 Guice bindings to achieve storage implementation.\n *\n * 1) {@link OAuth2Persister} 2) {@link OAuth2Cache} 3) {@link OAuth2Encrypter}\n *\n */\npublic class BasicOAuth2Store implements OAuth2Store {\n  private final static String LOG_CLASS = BasicOAuth2Store.class.getName();\n  private static final FilteredLogger LOG = FilteredLogger\n          .getFilteredLogger(BasicOAuth2Store.LOG_CLASS);\n\n  private final OAuth2Cache cache;\n  private final String globalRedirectUri;\n  private final OAuth2Persister persister;\n\n  @Inject\n  public BasicOAuth2Store(final OAuth2Cache cache, final OAuth2Persister persister,\n          final String globalRedirectUri) {\n    this.cache = cache;\n    this.persister = persister;\n    this.globalRedirectUri = globalRedirectUri;\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.log(\"this.cache = {0}\", this.cache);\n      BasicOAuth2Store.LOG.log(\"this.persister = {0}\", this.persister);\n      BasicOAuth2Store.LOG.log(\"this.globalRedirectUri = {0}\", this.globalRedirectUri);\n    }\n  }\n\n  public boolean clearCache() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"clearCache\");\n    }\n\n    try {\n      this.cache.clearClients();\n      this.cache.clearTokens();\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error clearing OAuth2 cache\", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error clearing OAuth2 cache\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Token createToken() {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"createToken\");\n    }\n\n    final OAuth2Token ret = this.persister.createToken();\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Client getClient(final String gadgetUri, final String serviceName)\n          throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getClient\", new Object[] {\n              gadgetUri, serviceName });\n    }\n\n    final Integer index = this.cache.getClientIndex(gadgetUri, serviceName);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"index = {0}\", index);\n    }\n\n    OAuth2Client client = this.cache.getClient(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"client from cache = {0}\", client);\n    }\n\n    if (client == null) {\n      try {\n        client = this.persister.findClient(gadgetUri, serviceName);\n        if (client != null) {\n          this.cache.storeClient(client);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error loading OAuth2 client \", e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 client \"\n                + serviceName, e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getClient\", client);\n    }\n\n    return client;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final Integer index) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", index);\n    }\n\n    final OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final String gadgetUri, final String serviceName,\n          final String user, final String scope) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", new Object[] {\n              gadgetUri, serviceName, user, scope });\n    }\n\n    final Integer index = this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n\n    OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if ((ret == null) || (!ret.isValid())) {\n      final OAuth2Client client = this.getClient(gadgetUri, serviceName);\n\n      if (client != null) {\n        final OAuth2Token accessToken = this.getToken(gadgetUri, serviceName, user, scope,\n                OAuth2Token.Type.ACCESS);\n        final OAuth2Token refreshToken = this.getToken(gadgetUri, serviceName, user, scope,\n                OAuth2Token.Type.REFRESH);\n\n        final BasicOAuth2Accessor newAccessor = new BasicOAuth2Accessor(gadgetUri, serviceName,\n                user, scope, client.isAllowModuleOverride(), this, this.globalRedirectUri);\n        newAccessor.setAccessToken(accessToken);\n        newAccessor.setAuthorizationUrl(client.getAuthorizationUrl());\n        newAccessor.setClientAuthenticationType(client.getClientAuthenticationType());\n        newAccessor.setAuthorizationHeader(client.isAuthorizationHeader());\n        newAccessor.setUrlParameter(client.isUrlParameter());\n        newAccessor.setClientId(client.getClientId());\n        newAccessor.setClientSecret(client.getClientSecret());\n        newAccessor.setGrantType(client.getGrantType());\n        newAccessor.setRedirectUri(client.getRedirectUri());\n        newAccessor.setRefreshToken(refreshToken);\n        newAccessor.setTokenUrl(client.getTokenUrl());\n        newAccessor.setType(client.getType());\n        ret = newAccessor;\n\n        this.storeOAuth2Accessor(ret);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public Integer getOAuth2AccessorIndex(final String gadgetUri, final String serviceName,\n          final String user, final String scope) {\n    return this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n  }\n\n  public OAuth2Token getToken(final String gadgetUri, final String serviceName, final String user,\n          final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getToken\", new Object[] {\n              gadgetUri, serviceName, user, scope, type });\n    }\n\n    final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n    final Integer index = this.cache.getTokenIndex(processedGadgetUri, serviceName, user, scope,\n            type);\n    OAuth2Token token = this.cache.getToken(index);\n    if (token == null) {\n      try {\n        token = this.persister.findToken(processedGadgetUri, serviceName, user, scope, type);\n        if (token != null) {\n          this.cache.storeToken(token);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \" + index,\n                e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getToken\", token);\n    }\n\n    return token;\n  }\n\n  public boolean init() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"init\");\n    }\n\n    this.clearCache();\n\n    try {\n      final Set<OAuth2Client> clients = this.persister.loadClients();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"clients = {0}\", clients);\n      }\n      this.cache.storeClients(clients);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 clients\", e);\n    }\n\n    try {\n      final Set<OAuth2Token> tokens = this.persister.loadTokens();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"tokens = {0}\", tokens);\n      }\n      this.cache.storeTokens(tokens);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 tokens\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"init\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Accessor removeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", accessor);\n    }\n\n    final OAuth2Accessor ret = null;\n\n    if (accessor != null) {\n      final Integer index = this.cache.getOAuth2AccessorIndex(accessor.getGadgetUri(),\n              accessor.getServiceName(), accessor.getUser(), accessor.getScope());\n      return this.cache.removeOAuth2Accessor(index);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Token removeToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n    }\n\n    if (token != null) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return this.removeToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n              token.getScope(), token.getType());\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", null);\n    }\n\n    return null;\n  }\n\n  public OAuth2Token removeToken(final String gadgetUri, final String serviceName,\n          final String user, final String scope, final OAuth2Token.Type type)\n          throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", new Object[] {\n              gadgetUri, serviceName, user, scope, type });\n    }\n\n    final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n    final Integer index = this.cache.getTokenIndex(processedGadgetUri, serviceName, user, scope,\n            type);\n    try {\n      final OAuth2Token token = this.cache.removeToken(index);\n      if (token != null) {\n        this.persister.removeToken(processedGadgetUri, serviceName, user, scope, type);\n      }\n\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return token;\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error loading OAuth2 token \", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \"\n              + serviceName, e);\n    }\n  }\n\n  public static boolean runImport(final OAuth2Persister source, final OAuth2Persister target,\n          final boolean clean) {\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"runImport\", new Object[] { source,\n              target, clean });\n    }\n\n    // No import for default persistence\n    return false;\n  }\n\n  public void setToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"setToken\", token);\n    }\n\n    if (token != null) {\n      final String gadgetUri = token.getGadgetUri();\n      final String serviceName = token.getServiceName();\n\n      final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n      token.setGadgetUri(processedGadgetUri);\n\n      final Integer index = this.cache.getTokenIndex(token);\n      final OAuth2Token existingToken = this.getToken(processedGadgetUri, token.getServiceName(),\n              token.getUser(), token.getScope(), token.getType());\n      try {\n        if (existingToken == null) {\n          this.persister.insertToken(token);\n        } else {\n          this.cache.removeToken(index);\n          this.persister.updateToken(token);\n        }\n        this.cache.storeToken(token);\n      } catch (final OAuth2CacheException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n                e);\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n                e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"setToken\");\n    }\n  }\n\n  public void storeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\", accessor);\n    }\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\");\n    }\n  }\n\n  protected String getGadgetUri(final String gadgetUri, final String serviceName)\n          throws GadgetException {\n    String ret = gadgetUri;\n    final OAuth2Client client = this.getClient(ret, serviceName);\n    if (client != null) {\n      if (client.isSharedToken()) {\n        ret = client.getClientId() + ':' + client.getServiceName();\n      }\n    }\n\n    return ret;\n  }\n}\n","lineNo":380}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.shindig.gadgets.oauth2;\n\nimport java.util.Set;\n\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.oauth2.logger.FilteredLogger;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2CacheException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Encrypter;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2PersistenceException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Persister;\n\nimport com.google.inject.Inject;\n\n/**\n * see {@link OAuth2Store}\n *\n * Default OAuth2Store.\n *\n * Uses 3 Guice bindings to achieve storage implementation.\n *\n * 1) {@link OAuth2Persister} 2) {@link OAuth2Cache} 3) {@link OAuth2Encrypter}\n *\n */\npublic class BasicOAuth2Store implements OAuth2Store {\n  private final static String LOG_CLASS = BasicOAuth2Store.class.getName();\n  private static final FilteredLogger LOG = FilteredLogger\n      .getFilteredLogger(BasicOAuth2Store.LOG_CLASS);\n\n  private final OAuth2Cache cache;\n  private final String globalRedirectUri;\n  private final OAuth2Persister persister;\n\n  @Inject\n  public BasicOAuth2Store(final OAuth2Cache cache, final OAuth2Persister persister,\n      final String globalRedirectUri) {\n    this.cache = cache;\n    this.persister = persister;\n    this.globalRedirectUri = globalRedirectUri;\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.log(\"this.cache = {0}\", this.cache);\n      BasicOAuth2Store.LOG.log(\"this.persister = {0}\", this.persister);\n      BasicOAuth2Store.LOG.log(\"this.globalRedirectUri = {0}\", this.globalRedirectUri);\n    }\n  }\n\n  public boolean clearCache() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"clearCache\");\n    }\n\n    try {\n      this.cache.clearClients();\n      this.cache.clearTokens();\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error clearing OAuth2 cache\", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error clearing OAuth2 cache\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Token createToken() {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"createToken\");\n    }\n\n    final OAuth2Token ret = this.persister.createToken();\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Client getClient(final String gadgetUri, final String serviceName)\n      throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getClient\", new Object[] {\n          gadgetUri, serviceName });\n    }\n\n    final Integer index = this.cache.getClientIndex(gadgetUri, serviceName);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"index = {0}\", index);\n    }\n\n    OAuth2Client client = this.cache.getClient(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"client from cache = {0}\", client);\n    }\n\n    if (client == null) {\n      try {\n        client = this.persister.findClient(gadgetUri, serviceName);\n        if (client != null) {\n          this.cache.storeClient(client);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error loading OAuth2 client \", e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 client \"\n            + serviceName, e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getClient\", client);\n    }\n\n    return client;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final Integer index) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", index);\n    }\n\n    final OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final String gadgetUri, final String serviceName,\n      final String user, final String scope) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", new Object[] {\n          gadgetUri, serviceName, user, scope });\n    }\n\n    final Integer index = this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n\n    OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if ((ret == null) || (!ret.isValid())) {\n      final OAuth2Client client = this.getClient(gadgetUri, serviceName);\n\n      if (client != null) {\n        final OAuth2Token accessToken = this.getToken(gadgetUri, serviceName, user, scope,\n            OAuth2Token.Type.ACCESS);\n        final OAuth2Token refreshToken = this.getToken(gadgetUri, serviceName, user, scope,\n            OAuth2Token.Type.REFRESH);\n\n        final BasicOAuth2Accessor newAccessor = new BasicOAuth2Accessor(gadgetUri, serviceName,\n            user, scope, client.isAllowModuleOverride(), this, this.globalRedirectUri);\n        newAccessor.setAccessToken(accessToken);\n        newAccessor.setAuthorizationUrl(client.getAuthorizationUrl());\n        newAccessor.setClientAuthenticationType(client.getClientAuthenticationType());\n        newAccessor.setAuthorizationHeader(client.isAuthorizationHeader());\n        newAccessor.setUrlParameter(client.isUrlParameter());\n        newAccessor.setClientId(client.getClientId());\n        newAccessor.setClientSecret(client.getClientSecret());\n        newAccessor.setGrantType(client.getGrantType());\n        newAccessor.setRedirectUri(client.getRedirectUri());\n        newAccessor.setRefreshToken(refreshToken);\n        newAccessor.setTokenUrl(client.getTokenUrl());\n        newAccessor.setType(client.getType());\n        ret = newAccessor;\n\n        this.storeOAuth2Accessor(ret);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public Integer getOAuth2AccessorIndex(final String gadgetUri, final String serviceName,\n      final String user, final String scope) {\n    return this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n  }\n\n  public OAuth2Token getToken(final String gadgetUri, final String serviceName, final String user,\n      final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getToken\", new Object[] {\n          gadgetUri, serviceName, user, scope, type });\n    }\n\n    final Integer index = this.cache.getTokenIndex(gadgetUri, serviceName, user, scope, type);\n    OAuth2Token token = this.cache.getToken(index);\n    if (token == null) {\n      try {\n        token = this.persister.findToken(gadgetUri, serviceName, user, scope, type);\n        if (token != null) {\n          this.cache.storeToken(token);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \" + index,\n            e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getToken\", token);\n    }\n\n    return token;\n  }\n\n  public boolean init() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"init\");\n    }\n\n    this.clearCache();\n\n    try {\n      final Set<OAuth2Client> clients = this.persister.loadClients();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"clients = {0}\", clients);\n      }\n      this.cache.storeClients(clients);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 clients\", e);\n    }\n\n    try {\n      final Set<OAuth2Token> tokens = this.persister.loadTokens();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"tokens = {0}\", tokens);\n      }\n      this.cache.storeTokens(tokens);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 tokens\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"init\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Accessor removeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", accessor);\n    }\n\n    final OAuth2Accessor ret = null;\n\n    if (accessor != null) {\n      final Integer index = this.cache.getOAuth2AccessorIndex(accessor.getGadgetUri(),\n          accessor.getServiceName(), accessor.getUser(), accessor.getScope());\n      return this.cache.removeOAuth2Accessor(index);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Token removeToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n    }\n\n    if (token != null) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return this.removeToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n          token.getScope(), token.getType());\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", null);\n    }\n\n    return null;\n  }\n\n  public OAuth2Token removeToken(final String gadgetUri, final String serviceName,\n      final String user, final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", new Object[] {\n          gadgetUri, serviceName, user, scope, type });\n    }\n\n    final Integer index = this.cache.getTokenIndex(gadgetUri, serviceName, user, scope, type);\n    try {\n      final OAuth2Token token = this.cache.removeToken(index);\n      if (token != null) {\n        this.persister.removeToken(gadgetUri, serviceName, user, scope, type);\n      }\n\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return token;\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error loading OAuth2 token \", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \"\n          + serviceName, e);\n    }\n  }\n\n  public static boolean runImport(final OAuth2Persister source, final OAuth2Persister target,\n      final boolean clean) {\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"runImport\", new Object[] { source,\n          target, clean });\n    }\n\n    // No import for default persistence\n    return false;\n  }\n\n  public void setToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"setToken\", token);\n    }\n\n    if (token != null) {\n      final Integer index = this.cache.getTokenIndex(token);\n      final OAuth2Token existingToken = this.getToken(token.getGadgetUri(), token.getServiceName(),\n          token.getUser(), token.getScope(), token.getType());\n      try {\n        if (existingToken == null) {\n          this.persister.insertToken(token);\n        } else {\n          this.cache.removeToken(index);\n          this.persister.updateToken(token);\n        }\n        this.cache.storeToken(token);\n      } catch (final OAuth2CacheException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n            e);\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n            e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"setToken\");\n    }\n  }\n\n  public void storeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\", accessor);\n    }\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\");\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.oauth2;\n\nimport com.google.inject.Inject;\n\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.oauth2.logger.FilteredLogger;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Cache;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2CacheException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Client;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2PersistenceException;\nimport org.apache.shindig.gadgets.oauth2.persistence.OAuth2Persister;\n\nimport java.util.Set;\n\n/**\n * see {@link OAuth2Store}\n *\n * Default OAuth2Store.\n *\n * Uses 3 Guice bindings to achieve storage implementation.\n *\n * 1) {@link OAuth2Persister} 2) {@link OAuth2Cache} 3) {@link OAuth2Encrypter}\n *\n */\npublic class BasicOAuth2Store implements OAuth2Store {\n  private final static String LOG_CLASS = BasicOAuth2Store.class.getName();\n  private static final FilteredLogger LOG = FilteredLogger\n          .getFilteredLogger(BasicOAuth2Store.LOG_CLASS);\n\n  private final OAuth2Cache cache;\n  private final String globalRedirectUri;\n  private final OAuth2Persister persister;\n\n  @Inject\n  public BasicOAuth2Store(final OAuth2Cache cache, final OAuth2Persister persister,\n          final String globalRedirectUri) {\n    this.cache = cache;\n    this.persister = persister;\n    this.globalRedirectUri = globalRedirectUri;\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.log(\"this.cache = {0}\", this.cache);\n      BasicOAuth2Store.LOG.log(\"this.persister = {0}\", this.persister);\n      BasicOAuth2Store.LOG.log(\"this.globalRedirectUri = {0}\", this.globalRedirectUri);\n    }\n  }\n\n  public boolean clearCache() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"clearCache\");\n    }\n\n    try {\n      this.cache.clearClients();\n      this.cache.clearTokens();\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error clearing OAuth2 cache\", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error clearing OAuth2 cache\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Token createToken() {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"createToken\");\n    }\n\n    final OAuth2Token ret = this.persister.createToken();\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"clearCache\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Client getClient(final String gadgetUri, final String serviceName)\n          throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getClient\", new Object[] {\n              gadgetUri, serviceName });\n    }\n\n    final Integer index = this.cache.getClientIndex(gadgetUri, serviceName);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"index = {0}\", index);\n    }\n\n    OAuth2Client client = this.cache.getClient(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.log(\"client from cache = {0}\", client);\n    }\n\n    if (client == null) {\n      try {\n        client = this.persister.findClient(gadgetUri, serviceName);\n        if (client != null) {\n          this.cache.storeClient(client);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error loading OAuth2 client \", e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 client \"\n                + serviceName, e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getClient\", client);\n    }\n\n    return client;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final Integer index) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", index);\n    }\n\n    final OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Accessor getOAuth2Accessor(final String gadgetUri, final String serviceName,\n          final String user, final String scope) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", new Object[] {\n              gadgetUri, serviceName, user, scope });\n    }\n\n    final Integer index = this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n\n    OAuth2Accessor ret = this.cache.getOAuth2Accessor(index);\n\n    if ((ret == null) || (!ret.isValid())) {\n      final OAuth2Client client = this.getClient(gadgetUri, serviceName);\n\n      if (client != null) {\n        final OAuth2Token accessToken = this.getToken(gadgetUri, serviceName, user, scope,\n                OAuth2Token.Type.ACCESS);\n        final OAuth2Token refreshToken = this.getToken(gadgetUri, serviceName, user, scope,\n                OAuth2Token.Type.REFRESH);\n\n        final BasicOAuth2Accessor newAccessor = new BasicOAuth2Accessor(gadgetUri, serviceName,\n                user, scope, client.isAllowModuleOverride(), this, this.globalRedirectUri);\n        newAccessor.setAccessToken(accessToken);\n        newAccessor.setAuthorizationUrl(client.getAuthorizationUrl());\n        newAccessor.setClientAuthenticationType(client.getClientAuthenticationType());\n        newAccessor.setAuthorizationHeader(client.isAuthorizationHeader());\n        newAccessor.setUrlParameter(client.isUrlParameter());\n        newAccessor.setClientId(client.getClientId());\n        newAccessor.setClientSecret(client.getClientSecret());\n        newAccessor.setGrantType(client.getGrantType());\n        newAccessor.setRedirectUri(client.getRedirectUri());\n        newAccessor.setRefreshToken(refreshToken);\n        newAccessor.setTokenUrl(client.getTokenUrl());\n        newAccessor.setType(client.getType());\n        ret = newAccessor;\n\n        this.storeOAuth2Accessor(ret);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public Integer getOAuth2AccessorIndex(final String gadgetUri, final String serviceName,\n          final String user, final String scope) {\n    return this.cache.getOAuth2AccessorIndex(gadgetUri, serviceName, user, scope);\n  }\n\n  public OAuth2Token getToken(final String gadgetUri, final String serviceName, final String user,\n          final String scope, final OAuth2Token.Type type) throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"getToken\", new Object[] {\n              gadgetUri, serviceName, user, scope, type });\n    }\n\n    final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n    final Integer index = this.cache.getTokenIndex(processedGadgetUri, serviceName, user, scope,\n            type);\n    OAuth2Token token = this.cache.getToken(index);\n    if (token == null) {\n      try {\n        token = this.persister.findToken(processedGadgetUri, serviceName, user, scope, type);\n        if (token != null) {\n          this.cache.storeToken(token);\n        }\n      } catch (final OAuth2PersistenceException e) {\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \" + index,\n                e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"getToken\", token);\n    }\n\n    return token;\n  }\n\n  public boolean init() throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"init\");\n    }\n\n    this.clearCache();\n\n    try {\n      final Set<OAuth2Client> clients = this.persister.loadClients();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"clients = {0}\", clients);\n      }\n      this.cache.storeClients(clients);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 clients\", e);\n    }\n\n    try {\n      final Set<OAuth2Token> tokens = this.persister.loadTokens();\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"tokens = {0}\", tokens);\n      }\n      this.cache.storeTokens(tokens);\n    } catch (final OAuth2PersistenceException e) {\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 tokens\", e);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"init\", true);\n    }\n\n    return true;\n  }\n\n  public OAuth2Accessor removeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", accessor);\n    }\n\n    final OAuth2Accessor ret = null;\n\n    if (accessor != null) {\n      final Integer index = this.cache.getOAuth2AccessorIndex(accessor.getGadgetUri(),\n              accessor.getServiceName(), accessor.getUser(), accessor.getScope());\n      return this.cache.removeOAuth2Accessor(index);\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", ret);\n    }\n\n    return ret;\n  }\n\n  public OAuth2Token removeToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n    }\n\n    if (token != null) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return this.removeToken(token.getGadgetUri(), token.getServiceName(), token.getUser(),\n              token.getScope(), token.getType());\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeOAuth2Accessor\", null);\n    }\n\n    return null;\n  }\n\n  public OAuth2Token removeToken(final String gadgetUri, final String serviceName,\n          final String user, final String scope, final OAuth2Token.Type type)\n          throws GadgetException {\n\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"removeToken\", new Object[] {\n              gadgetUri, serviceName, user, scope, type });\n    }\n\n    final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n    final Integer index = this.cache.getTokenIndex(processedGadgetUri, serviceName, user, scope,\n            type);\n    try {\n      final OAuth2Token token = this.cache.removeToken(index);\n      if (token != null) {\n        this.persister.removeToken(processedGadgetUri, serviceName, user, scope, type);\n      }\n\n      if (isLogging) {\n        BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"removeToken\", token);\n      }\n\n      return token;\n    } catch (final OAuth2PersistenceException e) {\n      if (isLogging) {\n        BasicOAuth2Store.LOG.log(\"Error loading OAuth2 token \", e);\n      }\n      throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error loading OAuth2 token \"\n              + serviceName, e);\n    }\n  }\n\n  public static boolean runImport(final OAuth2Persister source, final OAuth2Persister target,\n          final boolean clean) {\n    if (BasicOAuth2Store.LOG.isLoggable()) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"runImport\", new Object[] { source,\n              target, clean });\n    }\n\n    // No import for default persistence\n    return false;\n  }\n\n  public void setToken(final OAuth2Token token) throws GadgetException {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"setToken\", token);\n    }\n\n    if (token != null) {\n      final String gadgetUri = token.getGadgetUri();\n      final String serviceName = token.getServiceName();\n\n      final String processedGadgetUri = this.getGadgetUri(gadgetUri, serviceName);\n\n      token.setGadgetUri(processedGadgetUri);\n\n      final Integer index = this.cache.getTokenIndex(token);\n      final OAuth2Token existingToken = this.getToken(processedGadgetUri, token.getServiceName(),\n              token.getUser(), token.getScope(), token.getType());\n      try {\n        if (existingToken == null) {\n          this.persister.insertToken(token);\n        } else {\n          this.cache.removeToken(index);\n          this.persister.updateToken(token);\n        }\n        this.cache.storeToken(token);\n      } catch (final OAuth2CacheException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n                e);\n      } catch (final OAuth2PersistenceException e) {\n        if (isLogging) {\n          BasicOAuth2Store.LOG.log(\"Error storing OAuth2 token \" + index, e);\n        }\n        throw new GadgetException(Code.OAUTH_STORAGE_ERROR, \"Error storing OAuth2 token \" + index,\n                e);\n      }\n    }\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"setToken\");\n    }\n  }\n\n  public void storeOAuth2Accessor(final OAuth2Accessor accessor) {\n    final boolean isLogging = BasicOAuth2Store.LOG.isLoggable();\n    if (isLogging) {\n      BasicOAuth2Store.LOG.entering(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\", accessor);\n    }\n\n    this.cache.storeOAuth2Accessor(accessor);\n\n    if (isLogging) {\n      BasicOAuth2Store.LOG.exiting(BasicOAuth2Store.LOG_CLASS, \"storeOAuth2Accessor\");\n    }\n  }\n\n  protected String getGadgetUri(final String gadgetUri, final String serviceName)\n          throws GadgetException {\n    String ret = gadgetUri;\n    final OAuth2Client client = this.getClient(ret, serviceName);\n    if (client != null) {\n      if (client.isSharedToken()) {\n        ret = client.getClientId() + ':' + client.getServiceName();\n      }\n    }\n\n    return ret;\n  }\n}\n","lineNo":378}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.servlet;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Collections;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.shindig.auth.AuthInfoUtil;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.JsonSerializer;\nimport org.apache.shindig.common.servlet.HttpUtil;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.common.util.Utf8UrlCoder;\nimport org.apache.shindig.config.ContainerConfig;\nimport org.apache.shindig.gadgets.AuthType;\nimport org.apache.shindig.gadgets.FeedProcessor;\nimport org.apache.shindig.gadgets.FetchResponseUtils;\nimport org.apache.shindig.gadgets.Gadget;\nimport org.apache.shindig.gadgets.GadgetContext;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.LockedDomainService;\nimport org.apache.shindig.gadgets.admin.GadgetAdminStore;\nimport org.apache.shindig.gadgets.http.HttpRequest;\nimport org.apache.shindig.gadgets.http.HttpResponse;\nimport org.apache.shindig.gadgets.http.RequestPipeline;\nimport org.apache.shindig.gadgets.oauth.OAuthArguments;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Arguments;\nimport org.apache.shindig.gadgets.process.ProcessingException;\nimport org.apache.shindig.gadgets.process.Processor;\nimport org.apache.shindig.gadgets.rewrite.ResponseRewriterList.RewriteFlow;\nimport org.apache.shindig.gadgets.rewrite.ResponseRewriterRegistry;\nimport org.apache.shindig.gadgets.rewrite.RewriterRegistry;\nimport org.apache.shindig.gadgets.rewrite.RewritingException;\nimport org.apache.shindig.gadgets.uri.UriCommon;\nimport org.apache.shindig.gadgets.uri.UriCommon.Param;\n\nimport com.google.inject.Inject;\nimport com.google.inject.Provider;\nimport com.google.inject.Singleton;\n\n/**\n * Handles gadgets.io.makeRequest requests.\n * \n * Unlike ProxyHandler, this may perform operations such as OAuth or signed fetch.\n */\n@Singleton\npublic class MakeRequestHandler {\n  // Relaxed visibility for ease of integration. Try to avoid relying on these.\n  public static final String UNPARSEABLE_CRUFT = \"throw 1; < don't be evil' >\";\n  public static final String POST_DATA_PARAM = \"postData\";\n  public static final String METHOD_PARAM = \"httpMethod\";\n  public static final String HEADERS_PARAM = \"headers\";\n  public static final String CONTENT_TYPE_PARAM = \"contentType\";\n  public static final String NUM_ENTRIES_PARAM = \"numEntries\";\n  public static final String DEFAULT_NUM_ENTRIES = \"3\";\n  public static final String GET_SUMMARIES_PARAM = \"getSummaries\";\n  public static final String GET_FULL_HEADERS_PARAM = \"getFullHeaders\";\n  public static final String AUTHZ_PARAM = \"authz\";\n\n  private final RequestPipeline requestPipeline;\n  private final ResponseRewriterRegistry contentRewriterRegistry;\n  private final Provider<FeedProcessor> feedProcessorProvider;\n  private final GadgetAdminStore gadgetAdminStore;\n  private final Processor processor;\n  private final LockedDomainService lockedDomainService;\n\n  @Inject\n  public MakeRequestHandler(\n          RequestPipeline requestPipeline,\n          @RewriterRegistry(rewriteFlow = RewriteFlow.DEFAULT) ResponseRewriterRegistry contentRewriterRegistry,\n          Provider<FeedProcessor> feedProcessorProvider, GadgetAdminStore gadgetAdminStore,\n          Processor processor, LockedDomainService lockedDomainService) {\n\n    this.requestPipeline = requestPipeline;\n    this.contentRewriterRegistry = contentRewriterRegistry;\n    this.feedProcessorProvider = feedProcessorProvider;\n    this.gadgetAdminStore = gadgetAdminStore;\n    this.processor = processor;\n    this.lockedDomainService = lockedDomainService;\n  }\n\n  /**\n   * Executes a request, returning the response as JSON to be handled by makeRequest.\n   */\n  public void fetch(HttpServletRequest request, HttpServletResponse response)\n          throws GadgetException, IOException {\n    HttpRequest rcr = buildHttpRequest(request);\n    String container = rcr.getContainer();\n\n    final Uri gadgetUri = rcr.getGadget();\n    if (gadgetUri == null) {\n      throw new GadgetException(GadgetException.Code.MISSING_PARAMETER,\n              \"Unable to find gadget in request\", HttpResponse.SC_FORBIDDEN);\n    }\n\n    Gadget gadget;\n    GadgetContext context = new HttpGadgetContext(request) {\n      public Uri getUrl() {\n        return gadgetUri;\n      }\n\n      public boolean getIgnoreCache() {\n        return getParameter(\"bypassSpecCache\").equals(\"1\");\n      }\n    };\n    try {\n      gadget = processor.process(context);\n    } catch (ProcessingException e) {\n      throw new GadgetException(GadgetException.Code.INTERNAL_SERVER_ERROR,\n              \"Error processing gadget\", e, HttpResponse.SC_BAD_REQUEST);\n    }\n\n    // Validate gadget is correct for the host.\n    // Ensures that the gadget has not hand crafted this request to represent itself as\n    // another gadget in a locked domain environment.\n    if (!lockedDomainService.isGadgetValidForHost(context.getHost(), gadget, container)) {\n      throw new GadgetException(GadgetException.Code.GADGET_HOST_MISMATCH,\n              \"The gadget is incorrect for this request\", HttpResponse.SC_FORBIDDEN);\n    }\n\n    if (!gadgetAdminStore.isWhitelisted(container, gadgetUri.toString())) {\n      throw new GadgetException(GadgetException.Code.NON_WHITELISTED_GADGET,\n              \"The requested content is unavailable\", HttpResponse.SC_FORBIDDEN);\n    }\n\n    // Serialize the response\n    HttpResponse results = requestPipeline.execute(rcr);\n\n    // Rewrite the response\n    if (contentRewriterRegistry != null) {\n      try {\n        results = contentRewriterRegistry.rewriteHttpResponse(rcr, results);\n      } catch (RewritingException e) {\n        throw new GadgetException(GadgetException.Code.INTERNAL_SERVER_ERROR, e,\n                e.getHttpStatusCode());\n      }\n    }\n\n    // Serialize the response\n    String output = convertResponseToJson(rcr.getSecurityToken(), request, results);\n\n    // Find and set the refresh interval\n    setResponseHeaders(request, response, results);\n\n    response.setStatus(HttpServletResponse.SC_OK);\n    response.setContentType(\"application/json\");\n    response.setCharacterEncoding(\"UTF-8\");\n    response.getWriter().write(UNPARSEABLE_CRUFT + output);\n  }\n\n  /**\n   * Generate a remote content request based on the parameters sent from the client.\n   * \n   * @throws GadgetException\n   */\n  protected HttpRequest buildHttpRequest(HttpServletRequest request) throws GadgetException {\n    String urlStr = request.getParameter(Param.URL.getKey());\n    if (urlStr == null) {\n      throw new GadgetException(GadgetException.Code.INVALID_PARAMETER, Param.URL.getKey()\n              + \" parameter is missing.\", HttpResponse.SC_BAD_REQUEST);\n    }\n\n    Uri url;\n    try {\n      url = ServletUtil.validateUrl(Uri.parse(urlStr));\n    } catch (IllegalArgumentException e) {\n      throw new GadgetException(GadgetException.Code.INVALID_PARAMETER, \"Invalid \"\n              + Param.URL.getKey() + \" parameter\", HttpResponse.SC_BAD_REQUEST);\n    }\n\n    HttpRequest req = new HttpRequest(url).setMethod(getParameter(request, METHOD_PARAM, \"GET\"))\n            .setContainer(getContainer(request));\n\n    setPostData(request, req);\n\n    String headerData = getParameter(request, HEADERS_PARAM, \"\");\n    if (headerData.length() > 0) {\n      String[] headerList = StringUtils.split(headerData, '&');\n      for (String header : headerList) {\n        String[] parts = StringUtils.splitPreserveAllTokens(header, '=');\n        if (parts.length != 2) {\n          throw new GadgetException(GadgetException.Code.INVALID_PARAMETER,\n                  \"Malformed header param specified:\" + header, HttpResponse.SC_BAD_REQUEST);\n        }\n        String headerName = Utf8UrlCoder.decode(parts[0]);\n        if (!HttpRequestHandler.BAD_HEADERS.contains(headerName.toUpperCase())) {\n          req.addHeader(headerName, Utf8UrlCoder.decode(parts[1]));\n        }\n      }\n    }\n\n    // Set the default content type for post requests when a content type is not specified\n    if (\"POST\".equals(req.getMethod()) && req.getHeader(\"Content-Type\") == null) {\n      req.addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    }\n\n    req.setIgnoreCache(\"1\".equals(request.getParameter(Param.NO_CACHE.getKey())));\n\n    if (request.getParameter(Param.GADGET.getKey()) != null) {\n      req.setGadget(Uri.parse(request.getParameter(Param.GADGET.getKey())));\n    }\n\n    // If the proxy request specifies a refresh param then we want to force the min TTL for\n    // the retrieved entry in the cache regardless of the headers on the content when it\n    // is fetched from the original source.\n    if (request.getParameter(Param.REFRESH.getKey()) != null) {\n      try {\n        req.setCacheTtl(Integer.parseInt(request.getParameter(Param.REFRESH.getKey())));\n      } catch (NumberFormatException nfe) {\n        // Ignore\n      }\n    }\n    // Allow the rewriter to use an externally forced mime type. This is needed\n    // allows proper rewriting of <script src=\"x\"/> where x is returned with\n    // a content type like text/html which unfortunately happens all too often\n    req.setRewriteMimeType(request.getParameter(Param.REWRITE_MIME_TYPE.getKey()));\n\n    // Figure out whether authentication is required\n    AuthType auth = AuthType.parse(getParameter(request, AUTHZ_PARAM, null));\n    req.setAuthType(auth);\n    if (auth != AuthType.NONE) {\n      if (auth == AuthType.OAUTH2) {\n        req.setSecurityToken(extractAndValidateToken(request));\n        req.setOAuth2Arguments(new OAuth2Arguments(request));\n      } else {\n        req.setSecurityToken(extractAndValidateToken(request));\n        req.setOAuthArguments(new OAuthArguments(auth, request));\n      }\n    }\n\n    ServletUtil.setXForwardedForHeader(request, req);\n    return req;\n  }\n\n  /**\n   * Set http request post data according to servlet request. It uses header encoding if available,\n   * and defaulted to utf8 Override the function if different behavior is needed.\n   */\n  protected void setPostData(HttpServletRequest request, HttpRequest req) throws GadgetException {\n    String encoding = request.getCharacterEncoding();\n    if (encoding == null) {\n      encoding = \"UTF-8\";\n    }\n    try {\n      req.setPostBody(getParameter(request, POST_DATA_PARAM, \"\").getBytes(encoding.toUpperCase()));\n    } catch (UnsupportedEncodingException e) {\n      // We might consider enumerating at least a small list of encodings\n      // that we must always honor. For now, we return SC_BAD_REQUEST since\n      // the encoding parameter could theoretically be anything.\n      throw new GadgetException(Code.HTML_PARSE_ERROR, e, HttpResponse.SC_BAD_REQUEST);\n    }\n  }\n\n  /**\n   * Format a response as JSON, including additional JSON inserted by chained content fetchers.\n   */\n  protected String convertResponseToJson(SecurityToken authToken, HttpServletRequest request,\n          HttpResponse results) throws GadgetException {\n    boolean getFullHeaders = Boolean.parseBoolean(getParameter(request, GET_FULL_HEADERS_PARAM,\n            \"false\"));\n    String originalUrl = request.getParameter(Param.URL.getKey());\n    String body = results.getResponseAsString();\n    if (body.length() > 0) {\n      if (\"FEED\".equals(request.getParameter(CONTENT_TYPE_PARAM))) {\n        body = processFeed(originalUrl, request, body);\n      }\n    }\n    Map<String, Object> resp = FetchResponseUtils.getResponseAsJson(results, null, body,\n            getFullHeaders);\n\n    if (authToken != null) {\n      String updatedAuthToken = authToken.getUpdatedToken();\n      if (updatedAuthToken != null) {\n        resp.put(\"st\", updatedAuthToken);\n      }\n    }\n\n    // Use raw param as key as URL may have to be decoded\n    return JsonSerializer.serialize(Collections.singletonMap(originalUrl, resp));\n  }\n\n  protected RequestPipeline getRequestPipeline() {\n    return requestPipeline;\n  }\n\n  /**\n   * @param request\n   * @return A valid token for the given input.\n   */\n  private SecurityToken extractAndValidateToken(HttpServletRequest request) throws GadgetException {\n    SecurityToken token = AuthInfoUtil.getSecurityTokenFromRequest(request);\n    if (token == null) {\n      // TODO: Determine appropriate external error code for this.\n      throw new GadgetException(GadgetException.Code.INVALID_SECURITY_TOKEN);\n    }\n    return token;\n  }\n\n  /**\n   * Processes a feed (RSS or Atom) using FeedProcessor.\n   */\n  private String processFeed(String url, HttpServletRequest req, String xml) throws GadgetException {\n    boolean getSummaries = Boolean.parseBoolean(getParameter(req, GET_SUMMARIES_PARAM, \"false\"));\n    int numEntries;\n    try {\n      numEntries = Integer.valueOf(getParameter(req, NUM_ENTRIES_PARAM, DEFAULT_NUM_ENTRIES));\n    } catch (NumberFormatException e) {\n      throw new GadgetException(GadgetException.Code.INVALID_PARAMETER,\n              \"numEntries paramater is not a number\", HttpResponse.SC_BAD_REQUEST);\n    }\n    return feedProcessorProvider.get().process(url, xml, getSummaries, numEntries).toString();\n  }\n\n  /**\n   * Extracts the container name from the request.\n   */\n  @SuppressWarnings(\"deprecation\")\n  protected static String getContainer(HttpServletRequest request) {\n    String container = request.getParameter(Param.CONTAINER.getKey());\n    if (container == null) {\n      container = request.getParameter(Param.SYND.getKey());\n    }\n    return container != null ? container : ContainerConfig.DEFAULT_CONTAINER;\n  }\n\n  /**\n   * getParameter helper method, returning default value if param not present.\n   */\n  protected static String getParameter(HttpServletRequest request, String key, String defaultValue) {\n    String ret = request.getParameter(key);\n    return ret != null ? ret : defaultValue;\n  }\n\n  /**\n   * Sets cache control headers for the response.\n   */\n  @SuppressWarnings(\"boxing\")\n  protected static void setResponseHeaders(HttpServletRequest request,\n          HttpServletResponse response, HttpResponse results) throws GadgetException {\n    int refreshInterval = 0;\n    if (results.isStrictNoCache()\n            || \"1\".equals(request.getParameter(UriCommon.Param.NO_CACHE.getKey()))) {\n      refreshInterval = 0;\n    } else if (request.getParameter(UriCommon.Param.REFRESH.getKey()) != null) {\n      try {\n        refreshInterval = Integer.valueOf(request.getParameter(UriCommon.Param.REFRESH.getKey()));\n      } catch (NumberFormatException nfe) {\n        throw new GadgetException(GadgetException.Code.INVALID_PARAMETER,\n                \"refresh parameter is not a number\", HttpResponse.SC_BAD_REQUEST);\n      }\n    } else {\n      refreshInterval = Math.max(60 * 60, (int) (results.getCacheTtl() / 1000L));\n    }\n    HttpUtil.setCachingHeaders(response, refreshInterval, false);\n\n    // Always set Content-Disposition header as XSS prevention mechanism.\n    response.setHeader(\"Content-Disposition\", \"attachment;filename=p.txt\");\n\n    if (response.getContentType() == null) {\n      response.setContentType(\"application/octet-stream\");\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.shindig.auth.AuthInfoUtil;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.JsonSerializer;\nimport org.apache.shindig.common.servlet.HttpUtil;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.common.util.Utf8UrlCoder;\nimport org.apache.shindig.config.ContainerConfig;\nimport org.apache.shindig.gadgets.AuthType;\nimport org.apache.shindig.gadgets.FeedProcessor;\nimport org.apache.shindig.gadgets.FetchResponseUtils;\nimport org.apache.shindig.gadgets.Gadget;\nimport org.apache.shindig.gadgets.GadgetContext;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.GadgetException.Code;\nimport org.apache.shindig.gadgets.LockedDomainService;\nimport org.apache.shindig.gadgets.admin.GadgetAdminStore;\nimport org.apache.shindig.gadgets.http.HttpRequest;\nimport org.apache.shindig.gadgets.http.HttpResponse;\nimport org.apache.shindig.gadgets.http.RequestPipeline;\nimport org.apache.shindig.gadgets.oauth.OAuthArguments;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Arguments;\nimport org.apache.shindig.gadgets.process.ProcessingException;\nimport org.apache.shindig.gadgets.process.Processor;\nimport org.apache.shindig.gadgets.rewrite.ResponseRewriterList.RewriteFlow;\nimport org.apache.shindig.gadgets.rewrite.ResponseRewriterRegistry;\nimport org.apache.shindig.gadgets.rewrite.RewriterRegistry;\nimport org.apache.shindig.gadgets.rewrite.RewritingException;\nimport org.apache.shindig.gadgets.uri.UriCommon.Param;\n\nimport com.google.common.collect.Maps;\nimport com.google.inject.Inject;\nimport com.google.inject.Provider;\nimport com.google.inject.Singleton;\n\n/**\n * Handles gadgets.io.makeRequest requests.\n *\n * Unlike ProxyHandler, this may perform operations such as OAuth or signed fetch.\n */\n@Singleton\npublic class MakeRequestHandler implements ContainerConfig.ConfigObserver {\n  // Relaxed visibility for ease of integration. Try to avoid relying on these.\n  public static final String UNPARSEABLE_CRUFT = \"throw 1; < don't be evil' >\";\n  public static final String POST_DATA_PARAM = \"postData\";\n  public static final String METHOD_PARAM = \"httpMethod\";\n  public static final String HEADERS_PARAM = \"headers\";\n  public static final String CONTENT_TYPE_PARAM = \"contentType\";\n  public static final String NUM_ENTRIES_PARAM = \"numEntries\";\n  public static final String DEFAULT_NUM_ENTRIES = \"3\";\n  public static final String GET_SUMMARIES_PARAM = \"getSummaries\";\n  public static final String GET_FULL_HEADERS_PARAM = \"getFullHeaders\";\n  public static final String AUTHZ_PARAM = \"authz\";\n  public static final String MAX_POST_SIZE_KEY = \"gadgets.jsonProxyUrl.maxPostSize\";\n  public static final String MULTI_PART_FORM_POST = \"MPFP\";\n  public static final String MULTI_PART_FORM_POST_IFRAME = \"iframe\";\n  public static final int MAX_POST_SIZE_DEFAULT = 5 * 1024 * 1024; // 5 MiB\n\n  private final RequestPipeline requestPipeline;\n  private final ResponseRewriterRegistry contentRewriterRegistry;\n  private final Provider<FeedProcessor> feedProcessorProvider;\n  private final GadgetAdminStore gadgetAdminStore;\n  private final Processor processor;\n  private final LockedDomainService lockedDomainService;\n  private final Map<String, Integer> maxPostSizes;\n\n  @Inject\n  public MakeRequestHandler(\n          ContainerConfig config,\n          RequestPipeline requestPipeline,\n          @RewriterRegistry(rewriteFlow = RewriteFlow.DEFAULT) ResponseRewriterRegistry contentRewriterRegistry,\n          Provider<FeedProcessor> feedProcessorProvider, GadgetAdminStore gadgetAdminStore,\n          Processor processor, LockedDomainService lockedDomainService) {\n\n    this.requestPipeline = requestPipeline;\n    this.contentRewriterRegistry = contentRewriterRegistry;\n    this.feedProcessorProvider = feedProcessorProvider;\n    this.gadgetAdminStore = gadgetAdminStore;\n    this.processor = processor;\n    this.lockedDomainService = lockedDomainService;\n    this.maxPostSizes = Maps.newConcurrentMap();\n    config.addConfigObserver(this, true);\n  }\n\n  /**\n   * Executes a request, returning the response as JSON to be handled by makeRequest.\n   */\n  public void fetch(HttpServletRequest request, HttpServletResponse response)\n          throws GadgetException, IOException {\n\n    HttpRequest rcr = buildHttpRequest(request);\n    String container = rcr.getContainer();\n    final Uri gadgetUri = rcr.getGadget();\n    if (gadgetUri == null) {\n      throw new GadgetException(GadgetException.Code.MISSING_PARAMETER,\n              \"Unable to find gadget in request\", HttpResponse.SC_FORBIDDEN);\n    }\n\n    Gadget gadget;\n    GadgetContext context = new HttpGadgetContext(request) {\n      @Override\n      public Uri getUrl() {\n        return gadgetUri;\n      }\n      @Override\n      public boolean getIgnoreCache() {\n        return getParameter(\"bypassSpecCache\").equals(\"1\");\n      }\n    };\n    try {\n      gadget = processor.process(context);\n    } catch (ProcessingException e) {\n      throw new GadgetException(GadgetException.Code.INTERNAL_SERVER_ERROR,\n              \"Error processing gadget\", e, HttpResponse.SC_BAD_REQUEST);\n    }\n\n    // Validate gadget is correct for the host.\n    // Ensures that the gadget has not hand crafted this request to represent itself as\n    // another gadget in a locked domain environment.\n    if (!lockedDomainService.isGadgetValidForHost(context.getHost(), gadget, container)) {\n      throw new GadgetException(GadgetException.Code.GADGET_HOST_MISMATCH,\n              \"The gadget is incorrect for this request\", HttpResponse.SC_FORBIDDEN);\n    }\n\n    if (!gadgetAdminStore.isWhitelisted(container, gadgetUri.toString())) {\n      throw new GadgetException(GadgetException.Code.NON_WHITELISTED_GADGET,\n              \"The requested content is unavailable\", HttpResponse.SC_FORBIDDEN);\n    }\n\n    // Serialize the response\n    HttpResponse results = requestPipeline.execute(rcr);\n\n    // Rewrite the response\n    if (contentRewriterRegistry != null) {\n      try {\n        results = contentRewriterRegistry.rewriteHttpResponse(rcr, results);\n      } catch (RewritingException e) {\n        throw new GadgetException(GadgetException.Code.INTERNAL_SERVER_ERROR, e,\n                e.getHttpStatusCode());\n      }\n    }\n\n    // Serialize the response\n    String output = convertResponseToJson(rcr.getSecurityToken(), request, results);\n\n    // Find and set the refresh interval\n    setResponseHeaders(request, response, results);\n    response.setStatus(HttpServletResponse.SC_OK);\n    response.setCharacterEncoding(\"UTF-8\");\n\n    PrintWriter out = response.getWriter();\n    if (\"1\".equals(getParameter(request, MULTI_PART_FORM_POST_IFRAME, null))) {\n      response.setContentType(\"text/html\");\n      out.write(\"<html><head><\/head><body><textarea>\");\n      out.write(UNPARSEABLE_CRUFT);\n      out.write(output);\n      out.write(\"<\/textarea><\/body><\/html>\");\n    } else {\n      response.setContentType(\"application/json\");\n      out.write(UNPARSEABLE_CRUFT + output);\n    }\n  }\n\n  /**\n   * Generate a remote content request based on the parameters sent from the client.\n   *\n   * @throws GadgetException\n   */\n  protected HttpRequest buildHttpRequest(HttpServletRequest request) throws GadgetException {\n    String urlStr = getParameter(request, Param.URL.getKey(), null);\n    if (urlStr == null) {\n      throw new GadgetException(GadgetException.Code.INVALID_PARAMETER, Param.URL.getKey()\n              + \" parameter is missing.\", HttpResponse.SC_BAD_REQUEST);\n    }\n\n    Uri url;\n    try {\n      url = ServletUtil.validateUrl(Uri.parse(urlStr));\n    } catch (IllegalArgumentException e) {\n      throw new GadgetException(GadgetException.Code.INVALID_PARAMETER, \"Invalid \"\n              + Param.URL.getKey() + \" parameter\", HttpResponse.SC_BAD_REQUEST);\n    }\n\n    SecurityToken token = AuthInfoUtil.getSecurityTokenFromRequest(request);\n    String container = null;\n    Uri gadgetUri = null;\n    if (\"1\".equals(getParameter(request, MULTI_PART_FORM_POST, null))) {\n      // This endpoint is being used by the proxied-form-post feature.\n      // Require a token.\n      if (token == null) {\n        throw new GadgetException(GadgetException.Code.INVALID_SECURITY_TOKEN);\n      }\n    }\n\n    // If we have a token, we should use it.\n    if (token != null && !token.isAnonymous()) {\n      container = token.getContainer();\n      String appurl = token.getAppUrl();\n      if (appurl != null) {\n        gadgetUri = Uri.parse(appurl);\n      }\n    } else {\n      container = getContainer(request);\n      String gadgetUrl = getParameter(request, Param.GADGET.getKey(), null);\n      if (gadgetUrl != null) {\n        gadgetUri = Uri.parse(gadgetUrl);\n      }\n    }\n\n    HttpRequest req = new HttpRequest(url).setMethod(getParameter(request, METHOD_PARAM, \"GET\"))\n            .setContainer(container).setGadget(gadgetUri);\n\n    if (\"POST\".equals(req.getMethod())) {\n      setPostData(container, request, req);\n    }\n\n    String headerData = getParameter(request, HEADERS_PARAM, \"\");\n    if (headerData.length() > 0) {\n      String[] headerList = StringUtils.split(headerData, '&');\n      for (String header : headerList) {\n        String[] parts = StringUtils.splitPreserveAllTokens(header, '=');\n        if (parts.length != 2) {\n          throw new GadgetException(GadgetException.Code.INVALID_PARAMETER,\n                  \"Malformed header param specified:\" + header, HttpResponse.SC_BAD_REQUEST);\n        }\n        String headerName = Utf8UrlCoder.decode(parts[0]);\n        if (!HttpRequestHandler.BAD_HEADERS.contains(headerName.toUpperCase())) {\n          req.addHeader(headerName, Utf8UrlCoder.decode(parts[1]));\n        }\n      }\n    }\n\n    // Set the default content type for post requests when a content type is not specified\n    if (\"POST\".equals(req.getMethod()) && req.getHeader(\"Content-Type\") == null) {\n      req.addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    } else if (\"1\".equals(getParameter(request, MULTI_PART_FORM_POST, null))) {\n      // We need the entire header from the original request because it comes with a boundry value we need to reuse.\n      req.addHeader(\"Content-Type\", request.getHeader(\"Content-Type\"));\n    }\n\n    req.setIgnoreCache(\"1\".equals(getParameter(request, Param.NO_CACHE.getKey(), null)));\n\n\n\n    // If the proxy request specifies a refresh param then we want to force the min TTL for\n    // the retrieved entry in the cache regardless of the headers on the content when it\n    // is fetched from the original source.\n    String refresh = getParameter(request, Param.REFRESH.getKey(), null);\n    if (refresh != null) {\n      try {\n        req.setCacheTtl(Integer.parseInt(refresh));\n      } catch (NumberFormatException ignore) {}\n    }\n    // Allow the rewriter to use an externally forced mime type. This is needed\n    // allows proper rewriting of <script src=\"x\"/> where x is returned with\n    // a content type like text/html which unfortunately happens all too often\n    req.setRewriteMimeType(getParameter(request, Param.REWRITE_MIME_TYPE.getKey(), null));\n\n    // Figure out whether authentication is required\n    AuthType auth = AuthType.parse(getParameter(request, AUTHZ_PARAM, null));\n    req.setAuthType(auth);\n    if (auth != AuthType.NONE) {\n      if (auth == AuthType.OAUTH2) {\n        req.setSecurityToken(extractAndValidateToken(request));\n        req.setOAuth2Arguments(new OAuth2Arguments(request));\n      } else {\n        req.setSecurityToken(extractAndValidateToken(request));\n        req.setOAuthArguments(new OAuthArguments(auth, request));\n      }\n    }\n\n    ServletUtil.setXForwardedForHeader(request, req);\n    return req;\n  }\n\n  /**\n   * Set http request post data according to servlet request. It uses header encoding if available,\n   * and defaulted to utf8 Override the function if different behavior is needed.\n   */\n  protected void setPostData(String container, HttpServletRequest request, HttpRequest req) throws GadgetException {\n    if (maxPostSizes.get(container) < request.getContentLength()) {\n      throw new GadgetException(GadgetException.Code.POST_TOO_LARGE, \"Posted data too large.\",\n          HttpResponse.SC_REQUEST_ENTITY_TOO_LARGE);\n    }\n\n    String encoding = request.getCharacterEncoding();\n    if (encoding == null) {\n      encoding = \"UTF-8\";\n    }\n    try {\n      String contentType = request.getHeader(\"Content-Type\");\n      if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n        // TODO: This will read the entire posted response in server memory.\n        // Is there a way to stream this even with OAUTH flows?\n        req.setPostBody(request.getInputStream());\n      } else {\n        req.setPostBody(getParameter(request, POST_DATA_PARAM, \"\").getBytes(encoding.toUpperCase()));\n      }\n    } catch (UnsupportedEncodingException e) {\n      // We might consider enumerating at least a small list of encodings\n      // that we must always honor. For now, we return SC_BAD_REQUEST since\n      // the encoding parameter could theoretically be anything.\n      throw new GadgetException(Code.HTML_PARSE_ERROR, e, HttpResponse.SC_BAD_REQUEST);\n    } catch (IOException e) {\n      // Something went wrong reading the request data.\n      // TODO: perhaps also support a max post size and enforce it by throwing and catching exceptions here.\n      throw new GadgetException(Code.INTERNAL_SERVER_ERROR, e, HttpResponse.SC_BAD_REQUEST);\n    }\n  }\n\n  /**\n   * Format a response as JSON, including additional JSON inserted by chained content fetchers.\n   */\n  protected String convertResponseToJson(SecurityToken authToken, HttpServletRequest request,\n          HttpResponse results) throws GadgetException {\n    boolean getFullHeaders = Boolean.parseBoolean(getParameter(request, GET_FULL_HEADERS_PARAM,\n            \"false\"));\n    String originalUrl = getParameter(request, Param.URL.getKey(), null);\n    String body = results.getResponseAsString();\n    if (body.length() > 0) {\n      if (\"FEED\".equals(getParameter(request, CONTENT_TYPE_PARAM, null))) {\n        body = processFeed(originalUrl, request, body);\n      }\n    }\n    Map<String, Object> resp = FetchResponseUtils.getResponseAsJson(results, null, body,\n            getFullHeaders);\n\n    if (authToken != null) {\n      String updatedAuthToken = authToken.getUpdatedToken();\n      if (updatedAuthToken != null) {\n        resp.put(\"st\", updatedAuthToken);\n      }\n    }\n\n    // Use raw param as key as URL may have to be decoded\n    return JsonSerializer.serialize(Collections.singletonMap(originalUrl, resp));\n  }\n\n  protected RequestPipeline getRequestPipeline() {\n    return requestPipeline;\n  }\n\n  /**\n   * @param request\n   * @return A valid token for the given input.\n   */\n  private SecurityToken extractAndValidateToken(HttpServletRequest request) throws GadgetException {\n    SecurityToken token = AuthInfoUtil.getSecurityTokenFromRequest(request);\n    if (token == null) {\n      // TODO: Determine appropriate external error code for this.\n      throw new GadgetException(GadgetException.Code.INVALID_SECURITY_TOKEN);\n    }\n    return token;\n  }\n\n  /**\n   * Processes a feed (RSS or Atom) using FeedProcessor.\n   */\n  private String processFeed(String url, HttpServletRequest req, String xml) throws GadgetException {\n    boolean getSummaries = Boolean.parseBoolean(getParameter(req, GET_SUMMARIES_PARAM, \"false\"));\n    int numEntries;\n    try {\n      numEntries = Integer.valueOf(getParameter(req, NUM_ENTRIES_PARAM, DEFAULT_NUM_ENTRIES));\n    } catch (NumberFormatException e) {\n      throw new GadgetException(GadgetException.Code.INVALID_PARAMETER,\n              \"numEntries paramater is not a number\", HttpResponse.SC_BAD_REQUEST);\n    }\n    return feedProcessorProvider.get().process(url, xml, getSummaries, numEntries).toString();\n  }\n\n  /**\n   * Extracts the container name from the request.\n   */\n  @SuppressWarnings(\"deprecation\")\n  protected static String getContainer(HttpServletRequest request) {\n    String container = getParameter(request, Param.CONTAINER.getKey(), null);\n    if (container == null) {\n      container = getParameter(request, Param.SYND.getKey(), null);\n    }\n    return container != null ? container : ContainerConfig.DEFAULT_CONTAINER;\n  }\n\n  /**\n   * getParameter helper method, returning default value if param not present.\n   */\n  protected static String getParameter(HttpServletRequest request, String key, String defaultValue) {\n    String ret = request.getParameter(key);\n    return ret != null ? ret : defaultValue;\n  }\n\n  /**\n   * Sets cache control headers for the response.\n   */\n  @SuppressWarnings(\"boxing\")\n  protected static void setResponseHeaders(HttpServletRequest request,\n          HttpServletResponse response, HttpResponse results) throws GadgetException {\n    int refreshInterval = 0;\n    if (results.isStrictNoCache()\n            || \"1\".equals(getParameter(request, Param.NO_CACHE.getKey(), null))) {\n      refreshInterval = 0;\n    } else if (getParameter(request, Param.REFRESH.getKey(), null) != null) {\n      try {\n        refreshInterval = Integer.valueOf(getParameter(request, Param.REFRESH.getKey(), null));\n      } catch (NumberFormatException nfe) {\n        throw new GadgetException(GadgetException.Code.INVALID_PARAMETER,\n                \"refresh parameter is not a number\", HttpResponse.SC_BAD_REQUEST);\n      }\n    } else {\n      refreshInterval = Math.max(60 * 60, (int) (results.getCacheTtl() / 1000L));\n    }\n    HttpUtil.setCachingHeaders(response, refreshInterval, false);\n\n    /*\n     * The proxied-form-post feature uses this endpoint to post a form\n     * element (in order to support file upload).\n     *\n     * For cross-browser support (IE) it requires that we use a hidden iframe\n     * to post the request. Setting Content-Disposition breaks that solution.\n     * In this particular case, we will always have a security token, so we\n     * shouldn't need to be as cautious here.\n     */\n    if (!\"1\".equals(getParameter(request, MULTI_PART_FORM_POST, null))) {\n      // Always set Content-Disposition header as XSS prevention mechanism.\n      response.setHeader(\"Content-Disposition\", \"attachment;filename=p.txt\");\n    }\n\n    if (response.getContentType() == null) {\n      response.setContentType(\"application/octet-stream\");\n    }\n  }\n\n  public void containersChanged(ContainerConfig config, Collection<String> changed,\n      Collection<String> removed) {\n    for (String container : changed) {\n      Integer maxPostSize = config.getInt(container, MAX_POST_SIZE_KEY);\n      if (maxPostSize == null) {\n        maxPostSize = MAX_POST_SIZE_DEFAULT;\n      } else {\n        maxPostSizes.put(container, maxPostSize);\n      }\n    }\n    for (String container : removed) {\n      maxPostSizes.remove(container);\n    }\n  }\n}\n","lineNo":181}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.servlet;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.codec.binary.Base64InputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.auth.SecurityTokenCodec;\nimport org.apache.shindig.auth.SecurityTokenException;\nimport org.apache.shindig.common.Nullable;\nimport org.apache.shindig.common.servlet.HttpUtil;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.common.util.TimeSource;\nimport org.apache.shindig.gadgets.Gadget;\nimport org.apache.shindig.gadgets.GadgetContext;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.RenderingContext;\nimport org.apache.shindig.gadgets.admin.GadgetAdminStore;\nimport org.apache.shindig.gadgets.features.ApiDirective;\nimport org.apache.shindig.gadgets.features.FeatureRegistry;\nimport org.apache.shindig.gadgets.features.FeatureRegistry.FeatureBundle;\nimport org.apache.shindig.gadgets.features.FeatureRegistry.LookupResult;\nimport org.apache.shindig.gadgets.features.FeatureRegistryProvider;\nimport org.apache.shindig.gadgets.http.HttpResponse;\nimport org.apache.shindig.gadgets.js.JsException;\nimport org.apache.shindig.gadgets.js.JsRequestBuilder;\nimport org.apache.shindig.gadgets.js.JsResponse;\nimport org.apache.shindig.gadgets.js.JsServingPipeline;\nimport org.apache.shindig.gadgets.process.ProcessingException;\nimport org.apache.shindig.gadgets.process.Processor;\nimport org.apache.shindig.gadgets.servlet.CajaContentRewriter.CajoledResult;\nimport org.apache.shindig.gadgets.spec.Feature;\nimport org.apache.shindig.gadgets.spec.GadgetSpec;\nimport org.apache.shindig.gadgets.spec.LinkSpec;\nimport org.apache.shindig.gadgets.spec.ModulePrefs;\nimport org.apache.shindig.gadgets.spec.OAuthService;\nimport org.apache.shindig.gadgets.spec.OAuthSpec;\nimport org.apache.shindig.gadgets.spec.UserPref;\nimport org.apache.shindig.gadgets.spec.UserPref.EnumValuePair;\nimport org.apache.shindig.gadgets.spec.View;\nimport org.apache.shindig.gadgets.uri.IframeUriManager;\nimport org.apache.shindig.gadgets.uri.JsUriManager;\nimport org.apache.shindig.gadgets.uri.JsUriManager.JsUri;\nimport org.apache.shindig.gadgets.uri.ProxyUriManager;\nimport org.apache.shindig.gadgets.uri.ProxyUriManager.ProxyUri;\nimport org.apache.shindig.protocol.conversion.BeanDelegator;\nimport org.apache.shindig.protocol.conversion.BeanFilter;\n\nimport com.google.caja.lexer.TokenConsumer;\nimport com.google.caja.parser.html.Nodes;\nimport com.google.caja.render.Concatenator;\nimport com.google.caja.render.JsMinimalPrinter;\nimport com.google.caja.render.JsPrettyPrinter;\nimport com.google.caja.reporting.MessageContext;\nimport com.google.caja.reporting.RenderContext;\nimport com.google.caja.util.Sets;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.google.inject.Inject;\nimport com.google.inject.name.Named;\n\n/**\n * Service that interfaces with the system to provide information about gadgets.\n *\n * @since 2.0.0\n */\npublic class GadgetsHandlerService {\n\n  private static final Locale DEFAULT_LOCALE = new Locale(\"all\", \"all\");\n\n  private static final Logger LOG = Logger.getLogger(GadgetsHandler.class.getName());\n\n  // Map shindig data class to API interfaces\n  @VisibleForTesting\n  static final Map<Class<?>, Class<?>> API_CLASSES =\n      new ImmutableMap.Builder<Class<?>, Class<?>>()\n          .put(View.class, GadgetsHandlerApi.View.class)\n          .put(UserPref.class, GadgetsHandlerApi.UserPref.class)\n          .put(EnumValuePair.class, GadgetsHandlerApi.EnumValuePair.class)\n          .put(ModulePrefs.class, GadgetsHandlerApi.ModulePrefs.class)\n          .put(Feature.class, GadgetsHandlerApi.Feature.class)\n          .put(LinkSpec.class, GadgetsHandlerApi.LinkSpec.class)\n          .put(OAuthSpec.class, GadgetsHandlerApi.OAuthSpec.class)\n          .put(OAuthService.class, GadgetsHandlerApi.OAuthService.class)\n          .put(OAuthService.EndPoint.class, GadgetsHandlerApi.EndPoint.class)\n          // Enums\n          .put(View.ContentType.class, GadgetsHandlerApi.ViewContentType.class)\n          .put(UserPref.DataType.class, GadgetsHandlerApi.UserPrefDataType.class)\n          .put(GadgetsHandlerApi.RenderingContext.class, RenderingContext.class)\n          .put(OAuthService.Method.class, GadgetsHandlerApi.Method.class)\n          .put(OAuthService.Location.class, GadgetsHandlerApi.Location.class)\n          .build();\n\n  // Provide mapping for internal enums to api enums\n  @VisibleForTesting\n  static final Map<Enum<?>, Enum<?>> ENUM_CONVERSION_MAP =\n      new ImmutableMap.Builder<Enum<?>, Enum<?>>()\n          // View.ContentType mapping\n          .putAll(BeanDelegator.createDefaultEnumMap(View.ContentType.class,\n              GadgetsHandlerApi.ViewContentType.class))\n          // UserPref.DataType mapping\n          .putAll(BeanDelegator.createDefaultEnumMap(UserPref.DataType.class,\n              GadgetsHandlerApi.UserPrefDataType.class))\n          .putAll(BeanDelegator.createDefaultEnumMap(OAuthService.Method.class,\n              GadgetsHandlerApi.Method.class))\n          .putAll(BeanDelegator.createDefaultEnumMap(OAuthService.Location.class,\n              GadgetsHandlerApi.Location.class))\n          .putAll(BeanDelegator.createDefaultEnumMap(GadgetsHandlerApi.RenderingContext.class,\n              RenderingContext.class))\n          .build();\n\n  protected final TimeSource timeSource;\n  protected final Processor processor;\n  protected final IframeUriManager iframeUriManager;\n  protected final SecurityTokenCodec securityTokenCodec;\n  protected final ProxyUriManager proxyUriManager;\n  protected final JsUriManager jsUriManager;\n  protected final JsServingPipeline jsPipeline;\n  protected final JsRequestBuilder jsRequestBuilder;\n  protected final ProxyHandler proxyHandler;\n  protected final BeanDelegator beanDelegator;\n  protected final long specRefreshInterval;\n  protected final BeanFilter beanFilter;\n  protected final CajaContentRewriter cajaContentRewriter;\n  protected final GadgetAdminStore gadgetAdminStore;\n  protected final FeatureRegistryProvider featureRegistryProvider;\n\n  @Inject\n  public GadgetsHandlerService(TimeSource timeSource, Processor processor,\n      IframeUriManager iframeUriManager, SecurityTokenCodec securityTokenCodec,\n      ProxyUriManager proxyUriManager, JsUriManager jsUriManager, ProxyHandler proxyHandler,\n      JsServingPipeline jsPipeline, JsRequestBuilder jsRequestBuilder,\n      @Named(\"shindig.cache.xml.refreshInterval\") long specRefreshInterval,\n      BeanFilter beanFilter, CajaContentRewriter cajaContentRewriter,\n      GadgetAdminStore gadgetAdminStore,\n      FeatureRegistryProvider featureRegistryProvider) {\n    this.timeSource = timeSource;\n    this.processor = processor;\n    this.iframeUriManager = iframeUriManager;\n    this.securityTokenCodec = securityTokenCodec;\n    this.proxyUriManager = proxyUriManager;\n    this.jsUriManager = jsUriManager;\n    this.proxyHandler = proxyHandler;\n    this.jsPipeline = jsPipeline;\n    this.jsRequestBuilder = jsRequestBuilder;\n    this.specRefreshInterval = specRefreshInterval;\n    this.beanFilter = beanFilter;\n    this.cajaContentRewriter = cajaContentRewriter;\n    this.gadgetAdminStore = gadgetAdminStore;\n    this.featureRegistryProvider = featureRegistryProvider;\n\n    this.beanDelegator = new BeanDelegator(API_CLASSES, ENUM_CONVERSION_MAP);\n  }\n\n  /**\n   * Get gadget metadata information and iframe url. Support filtering of fields\n   * @param request request parameters\n   * @return gadget metadata nd iframe url\n   * @throws ProcessingException\n   */\n  public GadgetsHandlerApi.MetadataResponse getMetadata(GadgetsHandlerApi.MetadataRequest request)\n      throws ProcessingException {\n    verifyBaseParams(request, true);\n    Set<String> fields = beanFilter.processBeanFields(request.getFields());\n\n    GadgetContext context = new MetadataGadgetContext(request);\n    Gadget gadget = processor.process(context);\n\n    boolean needIfrUrl = isFieldIncluded(fields, \"iframeurl\");\n    if (needIfrUrl) {\n      if(!gadgetAdminStore.checkFeatureAdminInfo(gadget)) {\n        throw new ProcessingException(\"Gadget is not trusted to render in this container.\",\n              HttpResponse.SC_BAD_REQUEST);\n      }\n\n      if(gadget.getCurrentView() == null) {\n        throw new ProcessingException(\"View \" + request.getView() + \" does not exist\",\n                HttpResponse.SC_BAD_REQUEST);\n      }\n    }\n    String iframeUrl = needIfrUrl ? iframeUriManager.makeRenderingUri(gadget).toString() : null;\n    Boolean needsTokenRefresh =\n        isFieldIncluded(fields, \"needstokenrefresh\") ?\n            gadget.getAllFeatures().contains(\"auth-refresh\") : null;\n\n    Set<String> rpcServiceIds = getRpcServiceIds(gadget);\n\n    Integer tokenTTL = isFieldIncluded(fields, \"tokenTTL\") ?\n        securityTokenCodec.getTokenTimeToLive() : null;\n\n    return createMetadataResponse(context.getUrl(), gadget.getSpec(), iframeUrl,\n        needsTokenRefresh, fields, timeSource.currentTimeMillis() + specRefreshInterval, tokenTTL,\n        rpcServiceIds);\n  }\n\n  /**\n   * Gets the set of allowed RPC service ids.\n   *\n   * @param gadget\n   *          the gadget to get the service ids for.\n   * @return the set of allowed RPC service ids.\n   */\n  private Set<String> getRpcServiceIds(Gadget gadget) {\n    GadgetContext context = gadget.getContext();\n    Set<String> rpcEndpoints = Sets.newHashSet();\n    List<Feature> modulePrefFeatures = gadget.getSpec().getModulePrefs().getAllFeatures();\n    List<String> featureNames = Lists.newArrayList();\n    for(Feature feature : modulePrefFeatures) {\n      if(gadgetAdminStore.isAllowedFeature(feature, gadget)) {\n        featureNames.add(feature.getName());\n      }\n    }\n    try {\n      FeatureRegistry featureRegistry = featureRegistryProvider.get(context.getRepository());\n      LookupResult result = featureRegistry.getFeatureResources(context, featureRegistry.getFeatures(featureNames),\n              null);\n      List<FeatureBundle> bundles = result.getBundles();\n      for (FeatureBundle bundle : bundles) {\n        rpcEndpoints.addAll(bundle.getApis(ApiDirective.Type.RPC, false));\n      }\n    } catch (GadgetException e) {\n      LOG.log(Level.WARNING, \"Error getting features from feature registry\", e);\n    }\n    return rpcEndpoints;\n  }\n\n  private boolean isFieldIncluded(Set<String> fields, String name) {\n    return fields.contains(BeanFilter.ALL_FIELDS) || fields.contains(name.toLowerCase());\n  }\n  /**\n   * Create security token\n   * @param request token paramaters (gadget, owner and viewer)\n   * @return Security token\n   * @throws SecurityTokenException\n   */\n  public GadgetsHandlerApi.TokenResponse getToken(GadgetsHandlerApi.TokenRequest request)\n      throws SecurityTokenException, ProcessingException {\n    verifyBaseParams(request, true);\n    Set<String> fields = beanFilter.processBeanFields(request.getFields());\n\n    SecurityToken tokenData = convertAuthContext(request.getAuthContext(), request.getContainer(),\n        request.getUrl().toString());\n    String token = securityTokenCodec.encodeToken(tokenData);\n    Long expiryTimeMs = tokenData == null ? null : tokenData.getExpiresAt();\n    return createTokenResponse(request.getUrl(), token, fields, expiryTimeMs);\n  }\n\n  public GadgetsHandlerApi.JsResponse getJs(GadgetsHandlerApi.JsRequest request)\n      throws ProcessingException {\n    verifyBaseParams(request, false);\n    Set<String> fields = beanFilter.processBeanFields(request.getFields());\n\n    JsUri jsUri = createJsUri(request);\n    Uri servedUri = jsUriManager.makeExternJsUri(jsUri);\n\n    String content = null;\n    Long expireMs = null;\n    if (isFieldIncluded(fields, \"jsContent\")) {\n      JsResponse response;\n      try {\n        response = jsPipeline.execute(jsRequestBuilder.build(jsUri, servedUri.getAuthority()));\n      } catch (JsException e) {\n        throw new ProcessingException(e.getMessage(), e.getStatusCode());\n      }\n      content = response.toJsString();\n      if (response.isProxyCacheable()) {\n        expireMs = getDefaultExpiration();\n      }\n    } else {\n      expireMs = getDefaultExpiration();\n    }\n    return createJsResponse(request.getUrl(), servedUri, content, fields, expireMs);\n  }\n\n  public GadgetsHandlerApi.ProxyResponse getProxy(GadgetsHandlerApi.ProxyRequest request)\n      throws ProcessingException {\n    verifyBaseParams(request, true);\n    Set<String> fields = beanFilter.processBeanFields(request.getFields());\n\n    ProxyUri proxyUri = createProxyUri(request);\n    List<Uri> uris = proxyUriManager.make(ImmutableList.of(proxyUri), null);\n\n    HttpResponse httpResponse = null;\n    try {\n      if (isFieldIncluded(fields, \"proxyContent\")) {\n        httpResponse = proxyHandler.fetch(proxyUri);\n      }\n    } catch (IOException e) {\n      LOG.log(Level.INFO, \"Failed to fetch resource \" + proxyUri.getResource().toString(), e);\n      throw new ProcessingException(\"Error getting response content\", HttpResponse.SC_BAD_GATEWAY);\n    } catch (GadgetException e) {\n      // TODO: Clean this log if it is too spammy\n      LOG.log(Level.INFO, \"Failed to fetch resource \" + proxyUri.getResource().toString(), e);\n      throw new ProcessingException(\"Error getting response content\", HttpResponse.SC_BAD_GATEWAY);\n    }\n\n    try {\n      return createProxyResponse(uris.get(0), httpResponse, fields,\n          getProxyExpireMs(proxyUri, httpResponse));\n    } catch (IOException e) {\n      // Should never happen!\n      LOG.log(Level.WARNING, \"Error creating proxy response\", e);\n      throw new ProcessingException(\"Error getting response content\",\n          HttpResponse.SC_INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  /**\n   * Convert message level to Shindig's serializable message type\n   */\n  public static GadgetsHandlerApi.MessageLevel convertMessageLevel(String name) {\n    try {\n      return GadgetsHandlerApi.MessageLevel.valueOf(name);\n    }\n    catch (Exception ex) {\n      return GadgetsHandlerApi.MessageLevel.UNKNOWN;\n    }\n  }\n\n  /**\n   * Convert messages from Caja's internal message type to Shindig's serializable message type\n   */\n  private List<GadgetsHandlerApi.Message> convertMessages(\n      List<com.google.caja.reporting.Message> msgs,\n      final MessageContext mc) {\n    List<GadgetsHandlerApi.Message> result = Lists.newArrayListWithExpectedSize(msgs.size());\n    for (final com.google.caja.reporting.Message m : msgs) {\n      MessageImpl msg = new MessageImpl(m.getMessageType().name(),\n          m.format(mc), convertMessageLevel(m.getMessageLevel().name()));\n      result.add(msg);\n    }\n    return result;\n  }\n\n  public GadgetsHandlerApi.CajaResponse getCaja(GadgetsHandlerApi.CajaRequest request)\n      throws ProcessingException {\n    verifyBaseParams(request, true);\n    Set<String> fields = beanFilter.processBeanFields(request.getFields());\n\n    MessageContext mc = new MessageContext();\n    CajoledResult result =\n      cajaContentRewriter.rewrite(request.getUrl(), request.getContainer(),\n          request.getMimeType(), true /* only support es53 */, request.getDebug());\n    String html = null;\n    String js = null;\n    if (!result.hasErrors && null != result.html) {\n      html = Nodes.render(result.html);\n    }\n\n    if (!result.hasErrors && null != result.js) {\n      StringBuilder builder = new StringBuilder();\n      TokenConsumer tc = request.getDebug() ?\n          new JsPrettyPrinter(new Concatenator(builder))\n          : new JsMinimalPrinter(new Concatenator(builder));\n      RenderContext rc = new RenderContext(tc)\n          .withAsciiOnly(true)\n          .withEmbeddable(true);\n      result.js.render(rc);\n      rc.getOut().noMoreTokens();\n      js = builder.toString();\n    }\n\n    // TODO(jasvir): Improve Caja responses expiration handling\n    return createCajaResponse(request.getUrl(),\n        html, js, convertMessages(result.messages, mc), fields,\n        timeSource.currentTimeMillis() + specRefreshInterval);\n  }\n\n  /**\n   * Verify request parameter are defined.\n   */\n  protected void verifyBaseParams(GadgetsHandlerApi.BaseRequest request, boolean checkUrl)\n      throws ProcessingException {\n    if (checkUrl && request.getUrl() == null) {\n      throw new ProcessingException(\"Missing url parameter\", HttpResponse.SC_BAD_REQUEST);\n    }\n    if (request.getContainer() == null) {\n      throw new ProcessingException(\"Missing container parameter\", HttpResponse.SC_BAD_REQUEST);\n    }\n    if (request.getFields() == null) {\n      throw new ProcessingException(\"Missing fields parameter\", HttpResponse.SC_BAD_REQUEST);\n    }\n  }\n\n  protected Long getProxyExpireMs(ProxyUri proxyUri, @Nullable HttpResponse httpResponse) {\n    if (httpResponse != null) {\n      return httpResponse.getCacheExpiration();\n    } else if (proxyUri.getRefresh() != null) {\n      return timeSource.currentTimeMillis() + proxyUri.getRefresh() * 1000;\n    }\n\n    return getDefaultExpiration();\n  }\n\n  protected long getDefaultExpiration() {\n    return timeSource.currentTimeMillis() + (HttpUtil.getDefaultTtl() * 1000);\n  }\n\n  /**\n   * GadgetContext for metadata request. Used by the gadget processor\n   */\n  protected class MetadataGadgetContext extends GadgetContext {\n\n    private final GadgetsHandlerApi.MetadataRequest request;\n    private final SecurityToken authContext;\n\n    public MetadataGadgetContext(GadgetsHandlerApi.MetadataRequest request) {\n      this.request = request;\n      this.authContext = convertAuthContext(\n          request.getAuthContext(), request.getContainer(), request.getUrl().toString());\n    }\n\n    @Override\n    public Uri getUrl() {\n      return request.getUrl();\n    }\n\n    @Override\n    public String getContainer() {\n      return request.getContainer();\n    }\n\n    @Override\n    public RenderingContext getRenderingContext() {\n      return RenderingContext.METADATA;\n    }\n\n    @Override\n    public int getModuleId() {\n      return 1;\n    }\n\n    @Override\n    public Locale getLocale() {\n      return (request.getLocale() == null ? DEFAULT_LOCALE : request.getLocale());\n    }\n\n    @Override\n    public boolean getIgnoreCache() {\n      return request.getIgnoreCache();\n    }\n\n    @Override\n    public boolean getDebug() {\n      return request.getDebug();\n    }\n\n    @Override\n    public String getView() {\n      return request.getView();\n    }\n\n    @Override\n    public SecurityToken getToken() {\n      return authContext;\n    }\n\n    @Override\n    public boolean getSanitize() {\n      return (request.getRenderingType() == GadgetsHandlerApi.RenderingType.SANITIZED);\n    }\n\n    @Override\n    public boolean getCajoled() {\n      return (request.getRenderingType() == GadgetsHandlerApi.RenderingType.IFRAME_CAJOLED);\n    }\n  }\n\n  private SecurityToken convertAuthContext(GadgetsHandlerApi.AuthContext authContext,\n      String container, String url) {\n    if (authContext == null) {\n      return null;\n    }\n    return beanDelegator.createDelegator(authContext, SecurityToken.class,\n        ImmutableMap.<String, Object>of(\"container\", container,\n            \"appid\", url, \"appurl\", url));\n  }\n\n  public GadgetsHandlerApi.BaseResponse createErrorResponse(\n    Uri uri, Exception e, String defaultMsg) {\n    if (e instanceof ProcessingException) {\n      ProcessingException processingExc = (ProcessingException) e;\n      return createErrorResponse(uri, processingExc.getHttpStatusCode(),\n          processingExc.getMessage());\n    }\n    LOG.log(Level.WARNING, \"Error handling request: \" + (uri != null ? uri.toString() : \"\"), e);\n    return createErrorResponse(uri, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, defaultMsg);\n  }\n\n  public GadgetsHandlerApi.BaseResponse createErrorResponse(Uri url, int code, String error) {\n    GadgetsHandlerApi.Error errorBean = beanDelegator.createDelegator(\n        null, GadgetsHandlerApi.Error.class, ImmutableMap.<String, Object>of(\n          \"message\", BeanDelegator.nullable(error), \"code\", code));\n\n    return beanDelegator.createDelegator(error, GadgetsHandlerApi.BaseResponse.class,\n        ImmutableMap.<String, Object>of(\"url\", BeanDelegator.nullable(url), \"error\", errorBean,\n            \"responsetimems\", BeanDelegator.NULL, \"expiretimems\", BeanDelegator.NULL));\n  }\n\n  @VisibleForTesting\n  GadgetsHandlerApi.MetadataResponse createMetadataResponse(\n      Uri url, GadgetSpec spec, String iframeUrl, Boolean needsTokenRefresh,\n      Set<String> fields, Long expireTime, Integer tokenTTL, Set<String> rpcServiceIds) {\n    return (GadgetsHandlerApi.MetadataResponse) beanFilter.createFilteredBean(\n        beanDelegator.createDelegator(spec, GadgetsHandlerApi.MetadataResponse.class,\n            ImmutableMap.<String, Object>builder()\n                .put(\"url\", url)\n                .put(\"error\", BeanDelegator.NULL)\n                .put(\"iframeurl\", BeanDelegator.nullable(iframeUrl))\n                .put(\"needstokenrefresh\", BeanDelegator.nullable(needsTokenRefresh))\n                .put(\"responsetimems\", timeSource.currentTimeMillis())\n                .put(\"expiretimems\", BeanDelegator.nullable(expireTime))\n                .put(\"rpcserviceids\", BeanDelegator.nullable(rpcServiceIds))\n                .put(\"tokenttl\", BeanDelegator.nullable(tokenTTL)).build()),\n        fields);\n  }\n\n  @VisibleForTesting\n  GadgetsHandlerApi.TokenResponse createTokenResponse(\n      Uri url, String token, Set<String> fields, Long tokenExpire) {\n    return (GadgetsHandlerApi.TokenResponse) beanFilter.createFilteredBean(\n        beanDelegator.createDelegator(null, GadgetsHandlerApi.TokenResponse.class,\n            ImmutableMap.<String, Object>of(\n                \"url\", url,\n                \"error\", BeanDelegator.NULL,\n                \"token\", BeanDelegator.nullable(token),\n                \"responsetimems\", timeSource.currentTimeMillis(),\n                \"expiretimems\", BeanDelegator.nullable(tokenExpire))),\n        fields);\n  }\n\n  protected JsUri createJsUri(GadgetsHandlerApi.JsRequest request) {\n    RenderingContext context = (RenderingContext)\n    (request.getContext() != null ?\n        // TODO: Figure out why maven complain about casting and clean the dummy cast\n        (Object) beanDelegator.convertEnum(request.getContext())\n        : RenderingContext.GADGET);\n\n    return new JsUri(request.getRefresh(), request.getDebug(), request.getIgnoreCache(),\n        request.getContainer(), request.getGadget(), request.getFeatures(),\n        request.getLoadedFeatures(), request.getOnload(), false, false, context, request.getUrl(),\n        request.getRepository());\n  }\n\n  @VisibleForTesting\n  GadgetsHandlerApi.JsResponse createJsResponse(\n      Uri url, Uri jsUri, String content, Set<String> fields, Long expireMs) {\n    return (GadgetsHandlerApi.JsResponse) beanFilter.createFilteredBean(\n        beanDelegator.createDelegator(null, GadgetsHandlerApi.JsResponse.class,\n            ImmutableMap.<String, Object>builder()\n                .put(\"url\", BeanDelegator.nullable(url))\n                .put(\"error\", BeanDelegator.NULL)\n                .put(\"jsurl\", jsUri)\n                .put(\"jscontent\", BeanDelegator.nullable(content))\n                .put(\"responsetimems\", timeSource.currentTimeMillis())\n                .put(\"expiretimems\", BeanDelegator.nullable(expireMs)).build()),\n        fields);\n  }\n\n  protected ProxyUri createProxyUri(GadgetsHandlerApi.ProxyRequest request) {\n    ProxyUriManager.ProxyUri proxyUri = new ProxyUriManager.ProxyUri(request.getRefresh(),\n        request.getDebug(), request.getIgnoreCache(), request.getContainer(),\n        request.getGadget(), request.getUrl());\n\n    proxyUri.setFallbackUrl(request.getFallbackUrl())\n        .setRewriteMimeType(request.getRewriteMimeType())\n        .setSanitizeContent(request.getSanitize());\n\n    GadgetsHandlerApi.ImageParams image = request.getImageParams();\n    if (image != null) {\n      proxyUri.setResize( image.getWidth(), image.getHeight(),\n          image.getQuality(), image.getDoNotExpand());\n    }\n    return proxyUri;\n  }\n\n  @VisibleForTesting\n  GadgetsHandlerApi.ProxyResponse createProxyResponse(Uri uri, HttpResponse httpResponse,\n      Set<String> fields, Long expireMs) throws IOException {\n\n    GadgetsHandlerApi.HttpResponse beanHttp = null;\n    if (httpResponse != null) {\n      String content = \"\";\n      if (httpResponse.getContentLength() > 0) {\n        // Stream out the base64-encoded data.\n        // Ctor args indicate to encode w/o line breaks.\n        Base64InputStream b64input =\n            new Base64InputStream(httpResponse.getResponse(), true, 0, null);\n        content = IOUtils.toString(b64input);\n      }\n\n      ImmutableList.Builder<GadgetsHandlerApi.NameValuePair> headersBuilder =\n          ImmutableList.builder();\n      for (final Map.Entry<String, String> entry : httpResponse.getHeaders().entries()) {\n        headersBuilder.add(\n            beanDelegator.createDelegator(null, GadgetsHandlerApi.NameValuePair.class,\n                ImmutableMap.<String, Object>of(\"name\", entry.getKey(), \"value\", entry.getValue()))\n        );\n      }\n\n      beanHttp = beanDelegator.createDelegator(null, GadgetsHandlerApi.HttpResponse.class,\n          ImmutableMap.<String, Object>of(\n              \"code\", httpResponse.getHttpStatusCode(),\n              \"encoding\", httpResponse.getEncoding(),\n              \"contentbase64\", content,\n              \"headers\", headersBuilder.build()));\n    }\n\n    return (GadgetsHandlerApi.ProxyResponse) beanFilter.createFilteredBean(\n      beanDelegator.createDelegator(null, GadgetsHandlerApi.ProxyResponse.class,\n          ImmutableMap.<String, Object>builder()\n              .put(\"proxyurl\", uri)\n              .put(\"proxycontent\", BeanDelegator.nullable(beanHttp))\n              .put(\"url\", BeanDelegator.NULL)\n              .put(\"error\", BeanDelegator.NULL)\n              .put(\"responsetimems\", timeSource.currentTimeMillis())\n              .put(\"expiretimems\", BeanDelegator.nullable(expireMs))\n              .build()),\n      fields);\n  }\n\n  @VisibleForTesting\n  GadgetsHandlerApi.CajaResponse createCajaResponse(Uri uri,\n      String html, String js, List<GadgetsHandlerApi.Message> messages,\n      Set<String> fields, Long expireMs) {\n    ImmutableList.Builder<GadgetsHandlerApi.Message> msgBuilder =\n      ImmutableList.builder();\n    for (final GadgetsHandlerApi.Message m : messages) {\n      msgBuilder.add(\n        beanDelegator.createDelegator(null, GadgetsHandlerApi.Message.class,\n            ImmutableMap.<String, Object>of(\"name\", m.getName(),\n                \"level\", m.getLevel(), \"message\", m.getMessage())));\n    }\n\n    return (GadgetsHandlerApi.CajaResponse) beanFilter.createFilteredBean(\n        beanDelegator.createDelegator(null, GadgetsHandlerApi.CajaResponse.class,\n            ImmutableMap.<String, Object>builder()\n            .put(\"url\", uri)\n            .put(\"html\", BeanDelegator.nullable(html))\n            .put(\"js\", BeanDelegator.nullable(js))\n            .put(\"messages\", msgBuilder.build())\n            .put(\"error\", BeanDelegator.NULL)\n            .put(\"responsetimems\", timeSource.currentTimeMillis())\n            .put(\"expiretimems\", BeanDelegator.nullable(expireMs))\n            .build()),\n            fields);\n  }\n\n  private static class MessageImpl implements GadgetsHandlerApi.Message {\n    private final GadgetsHandlerApi.MessageLevel level;\n    private final String message;\n    private final String name;\n\n    public MessageImpl(String name, String message, GadgetsHandlerApi.MessageLevel level) {\n      this.name = name;\n      this.message = message;\n      this.level = level;\n    }\n\n    public GadgetsHandlerApi.MessageLevel getLevel() {\n      return level;\n    }\n\n    public String getMessage() {\n      return message;\n    }\n\n    public String getName() {\n      return name;\n    }\n\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.servlet;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.codec.binary.Base64InputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.auth.SecurityTokenCodec;\nimport org.apache.shindig.auth.SecurityTokenException;\nimport org.apache.shindig.common.Nullable;\nimport org.apache.shindig.common.servlet.HttpUtil;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.common.util.TimeSource;\nimport org.apache.shindig.gadgets.Gadget;\nimport org.apache.shindig.gadgets.GadgetContext;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.RenderingContext;\nimport org.apache.shindig.gadgets.admin.GadgetAdminStore;\nimport org.apache.shindig.gadgets.features.ApiDirective;\nimport org.apache.shindig.gadgets.features.FeatureRegistry;\nimport org.apache.shindig.gadgets.features.FeatureRegistry.FeatureBundle;\nimport org.apache.shindig.gadgets.features.FeatureRegistry.LookupResult;\nimport org.apache.shindig.gadgets.features.FeatureRegistryProvider;\nimport org.apache.shindig.gadgets.http.HttpResponse;\nimport org.apache.shindig.gadgets.js.JsException;\nimport org.apache.shindig.gadgets.js.JsRequestBuilder;\nimport org.apache.shindig.gadgets.js.JsResponse;\nimport org.apache.shindig.gadgets.js.JsServingPipeline;\nimport org.apache.shindig.gadgets.process.ProcessingException;\nimport org.apache.shindig.gadgets.process.Processor;\nimport org.apache.shindig.gadgets.servlet.CajaContentRewriter.CajoledResult;\nimport org.apache.shindig.gadgets.servlet.GadgetsHandlerApi.AuthContext;\nimport org.apache.shindig.gadgets.spec.Feature;\nimport org.apache.shindig.gadgets.spec.GadgetSpec;\nimport org.apache.shindig.gadgets.spec.LinkSpec;\nimport org.apache.shindig.gadgets.spec.ModulePrefs;\nimport org.apache.shindig.gadgets.spec.OAuthService;\nimport org.apache.shindig.gadgets.spec.OAuthSpec;\nimport org.apache.shindig.gadgets.spec.UserPref;\nimport org.apache.shindig.gadgets.spec.UserPref.EnumValuePair;\nimport org.apache.shindig.gadgets.spec.View;\nimport org.apache.shindig.gadgets.uri.IframeUriManager;\nimport org.apache.shindig.gadgets.uri.JsUriManager;\nimport org.apache.shindig.gadgets.uri.JsUriManager.JsUri;\nimport org.apache.shindig.gadgets.uri.ProxyUriManager;\nimport org.apache.shindig.gadgets.uri.ProxyUriManager.ProxyUri;\nimport org.apache.shindig.protocol.conversion.BeanDelegator;\nimport org.apache.shindig.protocol.conversion.BeanFilter;\n\nimport com.google.caja.lexer.TokenConsumer;\nimport com.google.caja.parser.html.Nodes;\nimport com.google.caja.render.Concatenator;\nimport com.google.caja.render.JsMinimalPrinter;\nimport com.google.caja.render.JsPrettyPrinter;\nimport com.google.caja.reporting.MessageContext;\nimport com.google.caja.reporting.RenderContext;\nimport com.google.caja.util.Sets;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.google.inject.Inject;\nimport com.google.inject.name.Named;\n\n/**\n * Service that interfaces with the system to provide information about gadgets.\n *\n * @since 2.0.0\n */\npublic class GadgetsHandlerService {\n\n  private static final Locale DEFAULT_LOCALE = new Locale(\"all\", \"all\");\n\n  private static final Logger LOG = Logger.getLogger(GadgetsHandler.class.getName());\n\n  // Map shindig data class to API interfaces\n  @VisibleForTesting\n  static final Map<Class<?>, Class<?>> API_CLASSES =\n      new ImmutableMap.Builder<Class<?>, Class<?>>()\n          .put(View.class, GadgetsHandlerApi.View.class)\n          .put(UserPref.class, GadgetsHandlerApi.UserPref.class)\n          .put(EnumValuePair.class, GadgetsHandlerApi.EnumValuePair.class)\n          .put(ModulePrefs.class, GadgetsHandlerApi.ModulePrefs.class)\n          .put(Feature.class, GadgetsHandlerApi.Feature.class)\n          .put(LinkSpec.class, GadgetsHandlerApi.LinkSpec.class)\n          .put(OAuthSpec.class, GadgetsHandlerApi.OAuthSpec.class)\n          .put(OAuthService.class, GadgetsHandlerApi.OAuthService.class)\n          .put(OAuthService.EndPoint.class, GadgetsHandlerApi.EndPoint.class)\n          // Enums\n          .put(View.ContentType.class, GadgetsHandlerApi.ViewContentType.class)\n          .put(UserPref.DataType.class, GadgetsHandlerApi.UserPrefDataType.class)\n          .put(GadgetsHandlerApi.RenderingContext.class, RenderingContext.class)\n          .put(OAuthService.Method.class, GadgetsHandlerApi.Method.class)\n          .put(OAuthService.Location.class, GadgetsHandlerApi.Location.class)\n          .build();\n\n  // Provide mapping for internal enums to api enums\n  @VisibleForTesting\n  static final Map<Enum<?>, Enum<?>> ENUM_CONVERSION_MAP =\n      new ImmutableMap.Builder<Enum<?>, Enum<?>>()\n          // View.ContentType mapping\n          .putAll(BeanDelegator.createDefaultEnumMap(View.ContentType.class,\n              GadgetsHandlerApi.ViewContentType.class))\n          // UserPref.DataType mapping\n          .putAll(BeanDelegator.createDefaultEnumMap(UserPref.DataType.class,\n              GadgetsHandlerApi.UserPrefDataType.class))\n          .putAll(BeanDelegator.createDefaultEnumMap(OAuthService.Method.class,\n              GadgetsHandlerApi.Method.class))\n          .putAll(BeanDelegator.createDefaultEnumMap(OAuthService.Location.class,\n              GadgetsHandlerApi.Location.class))\n          .putAll(BeanDelegator.createDefaultEnumMap(GadgetsHandlerApi.RenderingContext.class,\n              RenderingContext.class))\n          .build();\n\n  protected final TimeSource timeSource;\n  protected final Processor processor;\n  protected final IframeUriManager iframeUriManager;\n  protected final SecurityTokenCodec securityTokenCodec;\n  protected final ProxyUriManager proxyUriManager;\n  protected final JsUriManager jsUriManager;\n  protected final JsServingPipeline jsPipeline;\n  protected final JsRequestBuilder jsRequestBuilder;\n  protected final ProxyHandler proxyHandler;\n  protected final BeanDelegator beanDelegator;\n  protected final long specRefreshInterval;\n  protected final BeanFilter beanFilter;\n  protected final CajaContentRewriter cajaContentRewriter;\n  protected final GadgetAdminStore gadgetAdminStore;\n  protected final FeatureRegistryProvider featureRegistryProvider;\n  protected final ModuleIdManager moduleIdManager;\n\n  @Inject\n  public GadgetsHandlerService(TimeSource timeSource, Processor processor,\n      IframeUriManager iframeUriManager, SecurityTokenCodec securityTokenCodec,\n      ProxyUriManager proxyUriManager, JsUriManager jsUriManager, ProxyHandler proxyHandler,\n      JsServingPipeline jsPipeline, JsRequestBuilder jsRequestBuilder,\n      @Named(\"shindig.cache.xml.refreshInterval\") long specRefreshInterval,\n      BeanFilter beanFilter, CajaContentRewriter cajaContentRewriter,\n      GadgetAdminStore gadgetAdminStore,\n      FeatureRegistryProvider featureRegistryProvider,\n      ModuleIdManager moduleIdManager) {\n    this.timeSource = timeSource;\n    this.processor = processor;\n    this.iframeUriManager = iframeUriManager;\n    this.securityTokenCodec = securityTokenCodec;\n    this.proxyUriManager = proxyUriManager;\n    this.jsUriManager = jsUriManager;\n    this.proxyHandler = proxyHandler;\n    this.jsPipeline = jsPipeline;\n    this.jsRequestBuilder = jsRequestBuilder;\n    this.specRefreshInterval = specRefreshInterval;\n    this.beanFilter = beanFilter;\n    this.cajaContentRewriter = cajaContentRewriter;\n    this.gadgetAdminStore = gadgetAdminStore;\n    this.featureRegistryProvider = featureRegistryProvider;\n    this.moduleIdManager = moduleIdManager;\n\n    this.beanDelegator = new BeanDelegator(API_CLASSES, ENUM_CONVERSION_MAP);\n  }\n\n  /**\n   * Get gadget metadata information and iframe url. Support filtering of fields\n   * @param request request parameters\n   * @return gadget metadata nd iframe url\n   * @throws ProcessingException\n   */\n  public GadgetsHandlerApi.MetadataResponse getMetadata(GadgetsHandlerApi.MetadataRequest request)\n      throws ProcessingException {\n    verifyBaseParams(request, true);\n    Set<String> fields = beanFilter.processBeanFields(request.getFields());\n\n    GadgetContext context = new MetadataGadgetContext(request);\n    Gadget gadget = processor.process(context);\n\n    boolean needIfrUrl = isFieldIncluded(fields, \"iframeurl\");\n    if (needIfrUrl) {\n      if(!gadgetAdminStore.checkFeatureAdminInfo(gadget)) {\n        throw new ProcessingException(\"Gadget is not trusted to render in this container.\",\n              HttpResponse.SC_BAD_REQUEST);\n      }\n\n      if(gadget.getCurrentView() == null) {\n        throw new ProcessingException(\"View \" + request.getView() + \" does not exist\",\n                HttpResponse.SC_BAD_REQUEST);\n      }\n    }\n    String iframeUrl = needIfrUrl ? iframeUriManager.makeRenderingUri(gadget).toString() : null;\n    Boolean needsTokenRefresh =\n        isFieldIncluded(fields, \"needstokenrefresh\") ?\n            gadget.getAllFeatures().contains(\"auth-refresh\") : null;\n\n    Set<String> rpcServiceIds = getRpcServiceIds(gadget);\n\n    Integer tokenTTL = isFieldIncluded(fields, \"tokenTTL\") ?\n        securityTokenCodec.getTokenTimeToLive() : null;\n\n    return createMetadataResponse(context.getUrl(), gadget.getSpec(), iframeUrl,\n        needsTokenRefresh, fields, timeSource.currentTimeMillis() + specRefreshInterval, tokenTTL,\n        rpcServiceIds);\n  }\n\n  /**\n   * Gets the set of allowed RPC service ids.\n   *\n   * @param gadget\n   *          the gadget to get the service ids for.\n   * @return the set of allowed RPC service ids.\n   */\n  private Set<String> getRpcServiceIds(Gadget gadget) {\n    GadgetContext context = gadget.getContext();\n    Set<String> rpcEndpoints = Sets.newHashSet();\n    List<Feature> modulePrefFeatures = gadget.getSpec().getModulePrefs().getAllFeatures();\n    List<String> featureNames = Lists.newArrayList();\n    for(Feature feature : modulePrefFeatures) {\n      if(gadgetAdminStore.isAllowedFeature(feature, gadget)) {\n        featureNames.add(feature.getName());\n      }\n    }\n    try {\n      FeatureRegistry featureRegistry = featureRegistryProvider.get(context.getRepository());\n      LookupResult result = featureRegistry.getFeatureResources(context, featureRegistry.getFeatures(featureNames),\n              null);\n      List<FeatureBundle> bundles = result.getBundles();\n      for (FeatureBundle bundle : bundles) {\n        rpcEndpoints.addAll(bundle.getApis(ApiDirective.Type.RPC, false));\n      }\n    } catch (GadgetException e) {\n      LOG.log(Level.WARNING, \"Error getting features from feature registry\", e);\n    }\n    return rpcEndpoints;\n  }\n\n  private boolean isFieldIncluded(Set<String> fields, String name) {\n    return fields.contains(BeanFilter.ALL_FIELDS) || fields.contains(name.toLowerCase());\n  }\n  /**\n   * Create security token\n   * @param request token paramaters (gadget, owner and viewer)\n   * @return Security token\n   * @throws SecurityTokenException\n   */\n  public GadgetsHandlerApi.TokenResponse getToken(GadgetsHandlerApi.TokenRequest request)\n      throws SecurityTokenException, ProcessingException {\n    verifyBaseParams(request, true);\n    Set<String> fields = beanFilter.processBeanFields(request.getFields());\n    AuthContext authContext = request.getAuthContext();\n\n    SecurityToken tokenData = null;\n    String token = null;\n\n    Long moduleId = request.getModuleId();\n    if (moduleId == null) {\n      // Zero means there's no persisted module instance and the container doesn't care to persist it.\n      moduleId = 0L;\n    } else if (moduleId < 0) {\n      // Please generate a module Id for me\n      moduleId = moduleIdManager.generate(request.getUrl(), authContext);\n    }\n    if (moduleId > 0) {\n      moduleId = moduleIdManager.validate(request.getUrl(), authContext, moduleId);\n    }\n\n    if (moduleId != null) {\n      tokenData = convertAuthContext(authContext, request.getContainer(),\n          request.getUrl().toString(), moduleId);\n      token = securityTokenCodec.encodeToken(tokenData);\n    }\n\n    Long expiryTimeMs = tokenData == null ? null : tokenData.getExpiresAt();\n\n    Integer tokenTTL = isFieldIncluded(fields, \"tokenTTL\") ?\n        securityTokenCodec.getTokenTimeToLive() : null;\n    moduleId = isFieldIncluded(fields, \"moduleId\") ? moduleId : null;\n\n    return createTokenResponse(request.getUrl(), token, fields, expiryTimeMs, tokenTTL, moduleId);\n  }\n\n  public GadgetsHandlerApi.JsResponse getJs(GadgetsHandlerApi.JsRequest request)\n      throws ProcessingException {\n    verifyBaseParams(request, false);\n    Set<String> fields = beanFilter.processBeanFields(request.getFields());\n\n    JsUri jsUri = createJsUri(request);\n    Uri servedUri = jsUriManager.makeExternJsUri(jsUri);\n\n    String content = null;\n    Long expireMs = null;\n    if (isFieldIncluded(fields, \"jsContent\")) {\n      JsResponse response;\n      try {\n        response = jsPipeline.execute(jsRequestBuilder.build(jsUri, servedUri.getAuthority()));\n      } catch (JsException e) {\n        throw new ProcessingException(e.getMessage(), e.getStatusCode());\n      }\n      content = response.toJsString();\n      if (response.isProxyCacheable()) {\n        expireMs = getDefaultExpiration();\n      }\n    } else {\n      expireMs = getDefaultExpiration();\n    }\n    return createJsResponse(request.getUrl(), servedUri, content, fields, expireMs);\n  }\n\n  public GadgetsHandlerApi.ProxyResponse getProxy(GadgetsHandlerApi.ProxyRequest request)\n      throws ProcessingException {\n    verifyBaseParams(request, true);\n    Set<String> fields = beanFilter.processBeanFields(request.getFields());\n\n    ProxyUri proxyUri = createProxyUri(request);\n    List<Uri> uris = proxyUriManager.make(ImmutableList.of(proxyUri), null);\n\n    HttpResponse httpResponse = null;\n    try {\n      if (isFieldIncluded(fields, \"proxyContent\")) {\n        httpResponse = proxyHandler.fetch(proxyUri);\n      }\n    } catch (IOException e) {\n      LOG.log(Level.INFO, \"Failed to fetch resource \" + proxyUri.getResource().toString(), e);\n      throw new ProcessingException(\"Error getting response content\", HttpResponse.SC_BAD_GATEWAY);\n    } catch (GadgetException e) {\n      // TODO: Clean this log if it is too spammy\n      LOG.log(Level.INFO, \"Failed to fetch resource \" + proxyUri.getResource().toString(), e);\n      throw new ProcessingException(\"Error getting response content\", HttpResponse.SC_BAD_GATEWAY);\n    }\n\n    try {\n      return createProxyResponse(uris.get(0), httpResponse, fields,\n          getProxyExpireMs(proxyUri, httpResponse));\n    } catch (IOException e) {\n      // Should never happen!\n      LOG.log(Level.WARNING, \"Error creating proxy response\", e);\n      throw new ProcessingException(\"Error getting response content\",\n          HttpResponse.SC_INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  /**\n   * Convert message level to Shindig's serializable message type\n   */\n  public static GadgetsHandlerApi.MessageLevel convertMessageLevel(String name) {\n    try {\n      return GadgetsHandlerApi.MessageLevel.valueOf(name);\n    }\n    catch (Exception ex) {\n      return GadgetsHandlerApi.MessageLevel.UNKNOWN;\n    }\n  }\n\n  /**\n   * Convert messages from Caja's internal message type to Shindig's serializable message type\n   */\n  private List<GadgetsHandlerApi.Message> convertMessages(\n      List<com.google.caja.reporting.Message> msgs,\n      final MessageContext mc) {\n    List<GadgetsHandlerApi.Message> result = Lists.newArrayListWithExpectedSize(msgs.size());\n    for (final com.google.caja.reporting.Message m : msgs) {\n      MessageImpl msg = new MessageImpl(m.getMessageType().name(),\n          m.format(mc), convertMessageLevel(m.getMessageLevel().name()));\n      result.add(msg);\n    }\n    return result;\n  }\n\n  public GadgetsHandlerApi.CajaResponse getCaja(GadgetsHandlerApi.CajaRequest request)\n      throws ProcessingException {\n    verifyBaseParams(request, true);\n    Set<String> fields = beanFilter.processBeanFields(request.getFields());\n\n    MessageContext mc = new MessageContext();\n    CajoledResult result =\n      cajaContentRewriter.rewrite(request.getUrl(), request.getContainer(),\n          request.getMimeType(), true /* only support es53 */, request.getDebug());\n    String html = null;\n    String js = null;\n    if (!result.hasErrors && null != result.html) {\n      html = Nodes.render(result.html);\n    }\n\n    if (!result.hasErrors && null != result.js) {\n      StringBuilder builder = new StringBuilder();\n      TokenConsumer tc = request.getDebug() ?\n          new JsPrettyPrinter(new Concatenator(builder))\n          : new JsMinimalPrinter(new Concatenator(builder));\n      RenderContext rc = new RenderContext(tc)\n          .withAsciiOnly(true)\n          .withEmbeddable(true);\n      result.js.render(rc);\n      rc.getOut().noMoreTokens();\n      js = builder.toString();\n    }\n\n    // TODO(jasvir): Improve Caja responses expiration handling\n    return createCajaResponse(request.getUrl(),\n        html, js, convertMessages(result.messages, mc), fields,\n        timeSource.currentTimeMillis() + specRefreshInterval);\n  }\n\n  /**\n   * Verify request parameter are defined.\n   */\n  protected void verifyBaseParams(GadgetsHandlerApi.BaseRequest request, boolean checkUrl)\n      throws ProcessingException {\n    if (checkUrl && request.getUrl() == null) {\n      throw new ProcessingException(\"Missing url parameter\", HttpResponse.SC_BAD_REQUEST);\n    }\n    if (request.getContainer() == null) {\n      throw new ProcessingException(\"Missing container parameter\", HttpResponse.SC_BAD_REQUEST);\n    }\n    if (request.getFields() == null) {\n      throw new ProcessingException(\"Missing fields parameter\", HttpResponse.SC_BAD_REQUEST);\n    }\n  }\n\n  protected Long getProxyExpireMs(ProxyUri proxyUri, @Nullable HttpResponse httpResponse) {\n    if (httpResponse != null) {\n      return httpResponse.getCacheExpiration();\n    } else if (proxyUri.getRefresh() != null) {\n      return timeSource.currentTimeMillis() + proxyUri.getRefresh() * 1000;\n    }\n\n    return getDefaultExpiration();\n  }\n\n  protected long getDefaultExpiration() {\n    return timeSource.currentTimeMillis() + (HttpUtil.getDefaultTtl() * 1000);\n  }\n\n  /**\n   * GadgetContext for metadata request. Used by the gadget processor\n   */\n  protected class MetadataGadgetContext extends GadgetContext {\n\n    private final GadgetsHandlerApi.MetadataRequest request;\n    private final SecurityToken authContext;\n\n    public MetadataGadgetContext(GadgetsHandlerApi.MetadataRequest request) {\n      this.request = request;\n      this.authContext = convertAuthContext(\n          request.getAuthContext(), request.getContainer(), request.getUrl().toString());\n    }\n\n    @Override\n    public Uri getUrl() {\n      return request.getUrl();\n    }\n\n    @Override\n    public String getContainer() {\n      return request.getContainer();\n    }\n\n    @Override\n    public RenderingContext getRenderingContext() {\n      return RenderingContext.METADATA;\n    }\n\n    @Override\n    public int getModuleId() {\n      return 1;\n    }\n\n    @Override\n    public Locale getLocale() {\n      return (request.getLocale() == null ? DEFAULT_LOCALE : request.getLocale());\n    }\n\n    @Override\n    public boolean getIgnoreCache() {\n      return request.getIgnoreCache();\n    }\n\n    @Override\n    public boolean getDebug() {\n      return request.getDebug();\n    }\n\n    @Override\n    public String getView() {\n      return request.getView();\n    }\n\n    @Override\n    public SecurityToken getToken() {\n      return authContext;\n    }\n\n    @Override\n    public boolean getSanitize() {\n      return (request.getRenderingType() == GadgetsHandlerApi.RenderingType.SANITIZED);\n    }\n\n    @Override\n    public boolean getCajoled() {\n      return (request.getRenderingType() == GadgetsHandlerApi.RenderingType.IFRAME_CAJOLED);\n    }\n  }\n\n  private SecurityToken convertAuthContext(GadgetsHandlerApi.AuthContext authContext,\n    String container, String url) {\n    return convertAuthContext(authContext, container, url, 0);\n  }\n\n  private SecurityToken convertAuthContext(GadgetsHandlerApi.AuthContext authContext,\n    String container, String url, long moduleId) {\n    if (authContext == null) {\n      return null;\n    }\n    return beanDelegator.createDelegator(authContext, SecurityToken.class,\n        ImmutableMap.<String, Object>of(\"container\", container,\n            \"appid\", url, \"appurl\", url, \"moduleId\", moduleId));\n  }\n\n  public GadgetsHandlerApi.BaseResponse createErrorResponse(\n    Uri uri, Exception e, String defaultMsg) {\n    if (e instanceof ProcessingException) {\n      ProcessingException processingExc = (ProcessingException) e;\n      return createErrorResponse(uri, processingExc.getHttpStatusCode(),\n          processingExc.getMessage());\n    }\n    LOG.log(Level.WARNING, \"Error handling request: \" + (uri != null ? uri.toString() : \"\"), e);\n    return createErrorResponse(uri, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, defaultMsg);\n  }\n\n  public GadgetsHandlerApi.BaseResponse createErrorResponse(Uri url, int code, String error) {\n    GadgetsHandlerApi.Error errorBean = beanDelegator.createDelegator(\n        null, GadgetsHandlerApi.Error.class, ImmutableMap.<String, Object>of(\n          \"message\", BeanDelegator.nullable(error), \"code\", code));\n\n    return beanDelegator.createDelegator(error, GadgetsHandlerApi.BaseResponse.class,\n        ImmutableMap.<String, Object>of(\"url\", BeanDelegator.nullable(url), \"error\", errorBean,\n            \"responsetimems\", BeanDelegator.NULL, \"expiretimems\", BeanDelegator.NULL));\n  }\n\n  @VisibleForTesting\n  GadgetsHandlerApi.MetadataResponse createMetadataResponse(\n      Uri url, GadgetSpec spec, String iframeUrl, Boolean needsTokenRefresh,\n      Set<String> fields, Long expireTime, Integer tokenTTL, Set<String> rpcServiceIds) {\n    return (GadgetsHandlerApi.MetadataResponse) beanFilter.createFilteredBean(\n        beanDelegator.createDelegator(spec, GadgetsHandlerApi.MetadataResponse.class,\n            ImmutableMap.<String, Object>builder()\n                .put(\"url\", url)\n                .put(\"error\", BeanDelegator.NULL)\n                .put(\"iframeurl\", BeanDelegator.nullable(iframeUrl))\n                .put(\"needstokenrefresh\", BeanDelegator.nullable(needsTokenRefresh))\n                .put(\"responsetimems\", timeSource.currentTimeMillis())\n                .put(\"expiretimems\", BeanDelegator.nullable(expireTime))\n                .put(\"rpcserviceids\", BeanDelegator.nullable(rpcServiceIds))\n                .put(\"tokenttl\", BeanDelegator.nullable(tokenTTL)).build()),\n        fields);\n  }\n\n  @VisibleForTesting\n  GadgetsHandlerApi.TokenResponse createTokenResponse(\n      Uri url, String token, Set<String> fields, Long tokenExpire, Integer tokenTTL, Long moduleId) {\n    return (GadgetsHandlerApi.TokenResponse) beanFilter.createFilteredBean(\n        beanDelegator.createDelegator(null, GadgetsHandlerApi.TokenResponse.class,\n            ImmutableMap.<String, Object>builder()\n                .put(\"url\", url)\n                .put(\"error\", BeanDelegator.NULL)\n                .put(\"token\", BeanDelegator.nullable(token))\n                .put(\"responsetimems\", timeSource.currentTimeMillis())\n                .put(\"expiretimems\", BeanDelegator.nullable(tokenExpire))\n                .put(\"tokenttl\", BeanDelegator.nullable(tokenTTL))\n                .put(\"moduleid\", BeanDelegator.nullable(moduleId))\n            .build()\n        ),\n        fields\n    );\n  }\n\n  protected JsUri createJsUri(GadgetsHandlerApi.JsRequest request) {\n    RenderingContext context = (RenderingContext)\n    (request.getContext() != null ?\n        // TODO: Figure out why maven complain about casting and clean the dummy cast\n        (Object) beanDelegator.convertEnum(request.getContext())\n        : RenderingContext.GADGET);\n\n    return new JsUri(request.getRefresh(), request.getDebug(), request.getIgnoreCache(),\n        request.getContainer(), request.getGadget(), request.getFeatures(),\n        request.getLoadedFeatures(), request.getOnload(), false, false, context, request.getUrl(),\n        request.getRepository());\n  }\n\n  @VisibleForTesting\n  GadgetsHandlerApi.JsResponse createJsResponse(\n      Uri url, Uri jsUri, String content, Set<String> fields, Long expireMs) {\n    return (GadgetsHandlerApi.JsResponse) beanFilter.createFilteredBean(\n        beanDelegator.createDelegator(null, GadgetsHandlerApi.JsResponse.class,\n            ImmutableMap.<String, Object>builder()\n                .put(\"url\", BeanDelegator.nullable(url))\n                .put(\"error\", BeanDelegator.NULL)\n                .put(\"jsurl\", jsUri)\n                .put(\"jscontent\", BeanDelegator.nullable(content))\n                .put(\"responsetimems\", timeSource.currentTimeMillis())\n                .put(\"expiretimems\", BeanDelegator.nullable(expireMs)).build()),\n        fields);\n  }\n\n  protected ProxyUri createProxyUri(GadgetsHandlerApi.ProxyRequest request) {\n    ProxyUriManager.ProxyUri proxyUri = new ProxyUriManager.ProxyUri(request.getRefresh(),\n        request.getDebug(), request.getIgnoreCache(), request.getContainer(),\n        request.getGadget(), request.getUrl());\n\n    proxyUri.setFallbackUrl(request.getFallbackUrl())\n        .setRewriteMimeType(request.getRewriteMimeType())\n        .setSanitizeContent(request.getSanitize());\n\n    GadgetsHandlerApi.ImageParams image = request.getImageParams();\n    if (image != null) {\n      proxyUri.setResize( image.getWidth(), image.getHeight(),\n          image.getQuality(), image.getDoNotExpand());\n    }\n    return proxyUri;\n  }\n\n  @VisibleForTesting\n  GadgetsHandlerApi.ProxyResponse createProxyResponse(Uri uri, HttpResponse httpResponse,\n      Set<String> fields, Long expireMs) throws IOException {\n\n    GadgetsHandlerApi.HttpResponse beanHttp = null;\n    if (httpResponse != null) {\n      String content = \"\";\n      if (httpResponse.getContentLength() > 0) {\n        // Stream out the base64-encoded data.\n        // Ctor args indicate to encode w/o line breaks.\n        Base64InputStream b64input =\n            new Base64InputStream(httpResponse.getResponse(), true, 0, null);\n        content = IOUtils.toString(b64input);\n      }\n\n      ImmutableList.Builder<GadgetsHandlerApi.NameValuePair> headersBuilder =\n          ImmutableList.builder();\n      for (final Map.Entry<String, String> entry : httpResponse.getHeaders().entries()) {\n        headersBuilder.add(\n            beanDelegator.createDelegator(null, GadgetsHandlerApi.NameValuePair.class,\n                ImmutableMap.<String, Object>of(\"name\", entry.getKey(), \"value\", entry.getValue()))\n        );\n      }\n\n      beanHttp = beanDelegator.createDelegator(null, GadgetsHandlerApi.HttpResponse.class,\n          ImmutableMap.<String, Object>of(\n              \"code\", httpResponse.getHttpStatusCode(),\n              \"encoding\", httpResponse.getEncoding(),\n              \"contentbase64\", content,\n              \"headers\", headersBuilder.build()));\n    }\n\n    return (GadgetsHandlerApi.ProxyResponse) beanFilter.createFilteredBean(\n      beanDelegator.createDelegator(null, GadgetsHandlerApi.ProxyResponse.class,\n          ImmutableMap.<String, Object>builder()\n              .put(\"proxyurl\", uri)\n              .put(\"proxycontent\", BeanDelegator.nullable(beanHttp))\n              .put(\"url\", BeanDelegator.NULL)\n              .put(\"error\", BeanDelegator.NULL)\n              .put(\"responsetimems\", timeSource.currentTimeMillis())\n              .put(\"expiretimems\", BeanDelegator.nullable(expireMs))\n              .build()),\n      fields);\n  }\n\n  @VisibleForTesting\n  GadgetsHandlerApi.CajaResponse createCajaResponse(Uri uri,\n      String html, String js, List<GadgetsHandlerApi.Message> messages,\n      Set<String> fields, Long expireMs) {\n    ImmutableList.Builder<GadgetsHandlerApi.Message> msgBuilder =\n      ImmutableList.builder();\n    for (final GadgetsHandlerApi.Message m : messages) {\n      msgBuilder.add(\n        beanDelegator.createDelegator(null, GadgetsHandlerApi.Message.class,\n            ImmutableMap.<String, Object>of(\"name\", m.getName(),\n                \"level\", m.getLevel(), \"message\", m.getMessage())));\n    }\n\n    return (GadgetsHandlerApi.CajaResponse) beanFilter.createFilteredBean(\n        beanDelegator.createDelegator(null, GadgetsHandlerApi.CajaResponse.class,\n            ImmutableMap.<String, Object>builder()\n            .put(\"url\", uri)\n            .put(\"html\", BeanDelegator.nullable(html))\n            .put(\"js\", BeanDelegator.nullable(js))\n            .put(\"messages\", msgBuilder.build())\n            .put(\"error\", BeanDelegator.NULL)\n            .put(\"responsetimems\", timeSource.currentTimeMillis())\n            .put(\"expiretimems\", BeanDelegator.nullable(expireMs))\n            .build()),\n            fields);\n  }\n\n  private static class MessageImpl implements GadgetsHandlerApi.Message {\n    private final GadgetsHandlerApi.MessageLevel level;\n    private final String message;\n    private final String name;\n\n    public MessageImpl(String name, String message, GadgetsHandlerApi.MessageLevel level) {\n      this.name = name;\n      this.message = message;\n      this.level = level;\n    }\n\n    public GadgetsHandlerApi.MessageLevel getLevel() {\n      return level;\n    }\n\n    public String getMessage() {\n      return message;\n    }\n\n    public String getName() {\n      return name;\n    }\n\n  }\n}\n","lineNo":272}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.shindig.gadgets.spec;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.common.xml.XmlUtil;\nimport org.apache.shindig.gadgets.variables.Substitutions;\nimport org.junit.Test;\nimport org.w3c.dom.Node;\n\nimport com.google.common.collect.Multimap;\n\npublic class ModulePrefsTest {\n  private static final Uri SPEC_URL = Uri.parse(\"http://example.org/g.xml\");\n  private static final String FULL_XML\n      = \"<ModulePrefs\" +\n        \" title='title'\" +\n        \" title_url='title_url'\" +\n        \" description='description'\" +\n        \" author='author'\" +\n        \" author_email='author_email'\" +\n        \" screenshot='screenshot'\" +\n        \" thumbnail='thumbnail'\" +\n        \" directory_title='directory_title'\" +\n        \" width='1'\" +\n        \" height='2'\" +\n        \" scrolling='true'\" +\n        \" category='category'\" +\n        \" category2='category2'\" +\n        \" author_affiliation='author_affiliation'\" +\n        \" author_location='author_location'\" +\n        \" author_photo='author_photo'\" +\n        \" author_aboutme='author_aboutme'\" +\n        \" author_quote='author_quote'\" +\n        \" author_link='author_link'\" +\n        \" show_stats='true'\" +\n        \" show_in_directory='true'\" +\n        \" singleton='true'>\" +\n        \"  <Require feature='require'/>\" +\n        \"  <Optional feature='optional'/>\" +\n        \"  <Preload href='http://example.org' authz='signed'/>\" +\n        \"\t <Require feature='requiredview1' views='default, view1'/>\" +\n        \"\t <Require feature='requiredview2' views='view2'/>\" +\n        \"\t <Require feature='require' views='view2'>\" +\n        \"\t \t\t<Param name='param_name'>param_value<\/Param>\" +\n        \"  <\/Require>\" +\n        \"  <Icon/>\" +\n        \"  <Locale/>\" +\n        \"  <Link rel='link' href='http://example.org/link'/>\" +\n        \"  <OAuth>\" +\n        \"    <Service name='serviceOne'>\" +\n        \"      <Request url='http://www.example.com/request'\" +\n        \"          method='GET' param_location='auth-header' />\" +\n        \"      <Authorization url='http://www.example.com/authorize'/>\" +\n        \"      <Access url='http://www.example.com/access' method='GET'\" +\n        \"          param_location='auth-header' />\" +\n        \"    <\/Service>\" +\n        \"  <\/OAuth>\" +\n        \"  <NavigationItem title=\\\"moo\\\"><AppParameter key=\\\"test\\\" value=\\\"1\\\"/><\/NavigationItem>\" +\n        \"<\/ModulePrefs>\";\n\n  private void doAsserts(ModulePrefs prefs) {\n    assertEquals(\"title\", prefs.getTitle());\n    assertEquals(SPEC_URL.resolve(Uri.parse(\"title_url\")), prefs.getTitleUrl());\n    assertEquals(\"description\", prefs.getDescription());\n    assertEquals(\"author\", prefs.getAuthor());\n    assertEquals(\"author_email\", prefs.getAuthorEmail());\n    assertEquals(SPEC_URL.resolve(Uri.parse(\"screenshot\")), prefs.getScreenshot());\n    assertEquals(SPEC_URL.resolve(Uri.parse(\"thumbnail\")), prefs.getThumbnail());\n    assertEquals(\"directory_title\", prefs.getDirectoryTitle());\n    assertEquals(1, prefs.getWidth());\n    assertEquals(2, prefs.getHeight());\n    assertTrue(prefs.getScrolling());\n    assertFalse(prefs.getScaling());\n    assertEquals(\"category\", prefs.getCategories().get(0));\n    assertEquals(\"category2\", prefs.getCategories().get(1));\n    assertEquals(\"author_affiliation\", prefs.getAuthorAffiliation());\n    assertEquals(\"author_location\", prefs.getAuthorLocation());\n    assertEquals(SPEC_URL.resolve(Uri.parse(\"author_photo\")), prefs.getAuthorPhoto());\n    assertEquals(SPEC_URL.resolve(Uri.parse(\"author_link\")), prefs.getAuthorLink());\n    assertEquals(\"author_aboutme\", prefs.getAuthorAboutme());\n    assertEquals(\"author_quote\", prefs.getAuthorQuote());\n    assertTrue(prefs.getShowStats());\n    assertTrue(prefs.getShowInDirectory());\n    assertTrue(prefs.getSingleton());\n\n    assertTrue(prefs.getFeatures().get(\"require\").getRequired());\n    assertFalse(prefs.getFeatures().get(\"optional\").getRequired());\n\n    assertEquals(\"http://example.org\",\n        prefs.getPreloads().get(0).getHref().toString());\n\n    assertEquals(1, prefs.getIcons().size());\n\n    assertEquals(1, prefs.getLocales().size());\n\n    assertEquals(Uri.parse(\"http://example.org/link\"), prefs.getLinks().get(\"link\").getHref());\n\n    OAuthService oauth = prefs.getOAuthSpec().getServices().get(\"serviceOne\");\n    assertEquals(Uri.parse(\"http://www.example.com/request\"), oauth.getRequestUrl().url);\n    assertEquals(OAuthService.Method.GET, oauth.getRequestUrl().method);\n    assertEquals(OAuthService.Method.GET, oauth.getAccessUrl().method);\n    assertEquals(OAuthService.Location.HEADER, oauth.getAccessUrl().location);\n    assertEquals(Uri.parse(\"http://www.example.com/authorize\"), oauth.getAuthorizationUrl());\n\n    Multimap<String, Node> extra = prefs.getExtraElements();\n\n    assertTrue(extra.containsKey(\"NavigationItem\"));\n    assertEquals(1, extra.get(\"NavigationItem\").iterator().next().getChildNodes().getLength());\n  }\n  \n  @Test\n  public void substitutionsCopyConstructor() throws Exception{\n    ModulePrefs basePrefs = new ModulePrefs(XmlUtil.parse(FULL_XML), SPEC_URL);\n    Substitutions substituter = new Substitutions();\n    String gadgetXml = \"<Module>\" +\n    FULL_XML +\n    \"<Content type=\\\"html\\\"><\/Content>\" +\n    \"<\/Module>\";\n    GadgetSpec baseSpec = new GadgetSpec(SPEC_URL, gadgetXml);\n    GadgetSpec spec = baseSpec.substitute(substituter);\n    ModulePrefs subsPrefs = spec.getModulePrefs();\n    assertEquals(basePrefs.toString(), subsPrefs.toString());\n    doAsserts(subsPrefs);\n  }\n\n  @Test\n  public void basicElementsParseOk() throws Exception {\n    doAsserts(new ModulePrefs(XmlUtil.parse(FULL_XML), SPEC_URL));\n  }\n\n  @Test\n  public void getAttribute() throws Exception {\n    String xml = \"<ModulePrefs title='title' some_attribute='attribute' \" +\n        \"empty_attribute=''/>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertEquals(\"title\", prefs.getAttribute(\"title\"));\n    assertEquals(\"attribute\", prefs.getAttribute(\"some_attribute\"));\n    assertEquals(\"\", prefs.getAttribute(\"empty_attribute\"));\n    assertNull(prefs.getAttribute(\"gobbledygook\"));\n  }\n\n  @Test\n  public void getGlobalLocale() throws Exception {\n    String xml = \"<ModulePrefs title='locales'>\" +\n                 \"  <Locale lang='en' country='UK' messages='en.xml'/>\" +\n                 \"  <Locale lang='foo' language_direction='rtl'/>\" +\n                 \"<\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    LocaleSpec spec = prefs.getGlobalLocale(new Locale(\"en\", \"UK\"));\n    assertEquals(\"http://example.org/en.xml\", spec.getMessages().toString());\n\n    spec = prefs.getGlobalLocale(new Locale(\"foo\", \"ALL\"));\n    assertEquals(\"rtl\", spec.getLanguageDirection());\n\n    spec = prefs.getGlobalLocale(new Locale(\"en\", \"notexist\"));\n    assertNull(spec);\n  }\n  \n  @Test\n  public void getViewLocale() throws Exception {\n    String xml = \"<ModulePrefs title='locales'>\" +\n                 \"  <Locale lang='en' country='UK' messages='en.xml' views=\\\"view1\\\"/>\" +\n                 \"  <Locale lang='en' country='US' messages='en_US.xml' views=\\\"view2\\\"/>\" +\n                 \"  <Locale lang='foo' language_direction='rtl'/>\" +\n                 \"<\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    LocaleSpec spec = prefs.getGlobalLocale(new Locale(\"en\", \"UK\"));\n    assertNull(spec);\n    spec = prefs.getLocale(new Locale(\"en\", \"UK\"),\"view1\");\n    assertEquals(\"http://example.org/en.xml\", spec.getMessages().toString());\n    spec = prefs.getLocale(new Locale(\"en\", \"UK\"),\"view2\");\n    assertNull(spec);\n    spec = prefs.getLocale(new Locale(\"en\", \"US\"),\"view2\");\n    assertEquals(\"http://example.org/en_US.xml\", spec.getMessages().toString());\n    spec = prefs.getLocale(new Locale(\"foo\", \"ALL\"),\"view2\");\n    assertEquals(\"rtl\", spec.getLanguageDirection());\n  }\n\n  @Test\n  public void getLinks() throws Exception {\n    String link1Rel = \"foo\";\n    String link2Rel = \"bar\";\n    Uri link1Href = Uri.parse(\"http://example.org/foo\");\n    Uri link2Href = Uri.parse(\"/bar\");\n    String xml = \"<ModulePrefs title='links'>\" +\n                 \"  <Link rel='\" + link1Rel + \"' href='\" + link1Href + \"'/>\" +\n                 \"  <Link rel='\" + link2Rel + \"' href='\" + link2Href + \"'/>\" +\n                 \"<\/ModulePrefs>\";\n\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL)\n        .substitute(new Substitutions());\n\n    assertEquals(link1Href, prefs.getLinks().get(link1Rel).getHref());\n    assertEquals(SPEC_URL.resolve(link2Href), prefs.getLinks().get(link2Rel).getHref());\n  }\n  \n  @Test\n  public void getViewFeatures() throws Exception {\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(FULL_XML), SPEC_URL);\n    Map<String, Feature> features = prefs.getViewFeatures(\"default\");\n    assertEquals(4, features.size());\n    assertTrue(features.containsKey(\"requiredview1\"));\n    assertTrue(features.containsKey(\"require\"));\n    assertTrue(features.containsKey(\"optional\"));\n    assertTrue(features.containsKey(\"core\"));\n    assertTrue(!features.containsKey(\"requiredview2\"));\n\n    features = prefs.getViewFeatures(\"view2\");\n    assertEquals(4, features.size());\n    assertTrue(features.containsKey(\"requiredview2\"));\n    assertTrue(features.containsKey(\"require\"));\n    assertTrue(features.containsKey(\"optional\"));\n    assertTrue(features.containsKey(\"core\"));\n    assertTrue(!features.containsKey(\"requiredview1\"));\n  }\n  \n  @Test\n  public void getViewFeatureParams() throws Exception {\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(FULL_XML), SPEC_URL);\n    Map<String, Feature> features = prefs.getViewFeatures(\"view2\");\n    String paramValue = features.get(\"require\").getParam(\"param_name\");\n    assertNotNull(paramValue);\n    assertEquals(\"param_value\", paramValue);\n  }\n\n  @Test\n  public void doSubstitution() throws Exception {\n    String xml = \"<ModulePrefs title='__MSG_title__'>\" +\n                 \"  <Icon>__MSG_icon__<\/Icon>\" +\n                 \"  <Link rel='__MSG_rel__' href='__MSG_link_href__'/>\" +\n                 \"  <Preload href='__MSG_pre_href__'/>\" +\n                 \"    <Require feature=\\\"testFeature\\\">\" +\n                 \"           <Param name=\\\"test_param\\\">__MSG_test_param__<\/Param>\" +\n                 \"  <\/Require>\" +\n                 \"<\/ModulePrefs>\";\n    String title = \"blah\";\n    String icon = \"http://example.org/icon.gif\";\n    String rel = \"foo-bar\";\n    String linkHref = \"http://example.org/link.html\";\n    String preHref = \"http://example.org/preload.html\";\n    String testParam = \"bar-foo\"; \n\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    Substitutions subst = new Substitutions();\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"title\", title);\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"icon\", icon);\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"rel\", rel);\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"link_href\", linkHref);\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"pre_href\", preHref);\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"test_param\", testParam);\n    prefs = prefs.substitute(subst);\n\n    assertEquals(title, prefs.getTitle());\n    assertEquals(icon, prefs.getIcons().get(0).getContent());\n    assertEquals(rel, prefs.getLinks().get(rel).getRel());\n    assertEquals(linkHref, prefs.getLinks().get(rel).getHref().toString());\n    assertEquals(preHref, prefs.getPreloads().get(0).getHref().toString());\n    assertEquals(testParam, prefs.getFeatures().get(\"testFeature\").getParam(\"test_param\"));\n  }\n\n  @Test\n  public void malformedIntAttributeTreatedAsZero() throws Exception {\n    String xml = \"<ModulePrefs title='' height='100px' width='foobar' arbitrary='0xff'/>\";\n\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n\n    assertEquals(0, prefs.getHeight());\n    assertEquals(0, prefs.getWidth());\n    assertEquals(0, prefs.getIntAttribute(\"arbitrary\"));\n  }\n\n  @Test\n  public void missingTitleOkay() throws Exception {\n    String xml = \"<ModulePrefs/>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertNotNull(\"Empty ModulePrefs Parses\", prefs);\n    assertEquals(\"Title is empty string\", \"\", prefs.getTitle());\n  }\n  \n  @Test\n  public void coreInjectedAutomatically() throws Exception {\n    String xml = \"<ModulePrefs title=''><Require feature='foo'/><\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertEquals(2, prefs.getFeatures().size());\n    assertTrue(prefs.getFeatures().containsKey(\"foo\"));\n    assertTrue(prefs.getFeatures().containsKey(\"core\"));\n  }\n  \n  @Test\n  public void coreNotInjectedOnSplitCoreInclusion() throws Exception {\n    String xml = \"<ModulePrefs title=''><Require feature='core.config'/><\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertEquals(1, prefs.getFeatures().size());\n    assertTrue(prefs.getFeatures().containsKey(\"core.config\"));\n  }\n  \n  @Test\n  public void securityTokenInjectedOnOAuthTag() throws Exception {\n    String xml =\n        \"<ModulePrefs title=''>\" + \n        \"  <OAuth>\" +\n        \"    <Service name='serviceOne'>\" +\n        \"      <Request url='http://www.example.com/request'\" +\n        \"          method='GET' param_location='auth-header' />\" +\n        \"      <Authorization url='http://www.example.com/authorize'/>\" +\n        \"      <Access url='http://www.example.com/access' method='GET'\" +\n        \"          param_location='auth-header' />\" +\n        \"    <\/Service>\" +\n        \"  <\/OAuth>\" +\n        \"<\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertEquals(2, prefs.getFeatures().size());\n    assertTrue(prefs.getFeatures().containsKey(\"core\"));\n    assertTrue(prefs.getFeatures().containsKey(\"security-token\"));\n  }\n\n  @Test\n  public void toStringIsSane() throws Exception {\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(FULL_XML), SPEC_URL);\n    doAsserts(new ModulePrefs(XmlUtil.parse(prefs.toString()), SPEC_URL));\n  }\n\n  @Test\n  public void needsUserPrefSubstInTitle() throws Exception {\n    String xml = \"<ModulePrefs title='Title __UP_foo__'/>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertTrue(prefs.needsUserPrefSubstitution());\n  }\n\n  @Test\n  public void needsUserPrefSubstInTitleUrl() throws Exception {\n    String xml = \"<ModulePrefs title='foo' title_url='http://__UP_url__'/>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertTrue(prefs.needsUserPrefSubstitution());\n  }\n\n  @Test\n  public void needsUserPrefSubstInPreload() throws Exception {\n    String xml = \"<ModulePrefs title='foo'>\" +\n        \"  <Preload href='__UP_foo__' authz='signed'/><\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertTrue(prefs.needsUserPrefSubstitution());\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.shindig.gadgets.spec;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.common.xml.XmlUtil;\nimport org.apache.shindig.gadgets.variables.Substitutions;\nimport org.junit.Test;\nimport org.w3c.dom.Node;\n\nimport com.google.common.collect.Multimap;\n\npublic class ModulePrefsTest {\n  private static final Uri SPEC_URL = Uri.parse(\"http://example.org/g.xml\");\n  private static final String FULL_XML\n      = \"<ModulePrefs\" +\n        \" title='title'\" +\n        \" title_url='title_url'\" +\n        \" description='description'\" +\n        \" author='author'\" +\n        \" author_email='author_email'\" +\n        \" screenshot='screenshot'\" +\n        \" thumbnail='thumbnail'\" +\n        \" directory_title='directory_title'\" +\n        \" width='1'\" +\n        \" height='2'\" +\n        \" scrolling='true'\" +\n        \" category='category'\" +\n        \" category2='category2'\" +\n        \" author_affiliation='author_affiliation'\" +\n        \" author_location='author_location'\" +\n        \" author_photo='author_photo'\" +\n        \" author_aboutme='author_aboutme'\" +\n        \" author_quote='author_quote'\" +\n        \" author_link='author_link'\" +\n        \" show_stats='true'\" +\n        \" show_in_directory='true'\" +\n        \" singleton='true'>\" +\n        \"  <Require feature='require'/>\" +\n        \"  <Optional feature='optional'/>\" +\n        \"  <Preload href='http://example.org' authz='signed'/>\" +\n        \"\t <Require feature='requiredview1' views='default, view1'/>\" +\n        \"\t <Require feature='requiredview2' views='view2'/>\" +\n        \"\t <Require feature='require' views='view2'>\" +\n        \"\t \t\t<Param name='param_name'>param_value<\/Param>\" +\n        \"  <\/Require>\" +\n        \"  <Icon/>\" +\n        \"  <Locale/>\" +\n        \"  <Link rel='link' href='http://example.org/link'/>\" +\n        \"  <OAuth>\" +\n        \"    <Service name='serviceOne'>\" +\n        \"      <Request url='http://www.example.com/request'\" +\n        \"          method='GET' param_location='auth-header' />\" +\n        \"      <Authorization url='http://www.example.com/authorize'/>\" +\n        \"      <Access url='http://www.example.com/access' method='GET'\" +\n        \"          param_location='auth-header' />\" +\n        \"    <\/Service>\" +\n        \"  <\/OAuth>\" +\n        \"  <NavigationItem title=\\\"moo\\\"><AppParameter key=\\\"test\\\" value=\\\"1\\\"/><\/NavigationItem>\" +\n        \"<\/ModulePrefs>\";\n\n  private void doAsserts(ModulePrefs prefs) {\n    assertEquals(\"title\", prefs.getTitle());\n    assertEquals(SPEC_URL.resolve(Uri.parse(\"title_url\")), prefs.getTitleUrl());\n    assertEquals(\"description\", prefs.getDescription());\n    assertEquals(\"author\", prefs.getAuthor());\n    assertEquals(\"author_email\", prefs.getAuthorEmail());\n    assertEquals(SPEC_URL.resolve(Uri.parse(\"screenshot\")), prefs.getScreenshot());\n    assertEquals(SPEC_URL.resolve(Uri.parse(\"thumbnail\")), prefs.getThumbnail());\n    assertEquals(\"directory_title\", prefs.getDirectoryTitle());\n    assertEquals(1, prefs.getWidth());\n    assertEquals(2, prefs.getHeight());\n    assertTrue(prefs.getScrolling());\n    assertFalse(prefs.getScaling());\n    assertEquals(\"category\", prefs.getCategories().get(0));\n    assertEquals(\"category2\", prefs.getCategories().get(1));\n    assertEquals(\"author_affiliation\", prefs.getAuthorAffiliation());\n    assertEquals(\"author_location\", prefs.getAuthorLocation());\n    assertEquals(SPEC_URL.resolve(Uri.parse(\"author_photo\")), prefs.getAuthorPhoto());\n    assertEquals(SPEC_URL.resolve(Uri.parse(\"author_link\")), prefs.getAuthorLink());\n    assertEquals(\"author_aboutme\", prefs.getAuthorAboutme());\n    assertEquals(\"author_quote\", prefs.getAuthorQuote());\n    assertTrue(prefs.getShowStats());\n    assertTrue(prefs.getShowInDirectory());\n    assertTrue(prefs.getSingleton());\n\n    assertTrue(prefs.getFeatures().get(\"require\").getRequired());\n    assertFalse(prefs.getFeatures().get(\"optional\").getRequired());\n\n    assertEquals(\"http://example.org\",\n        prefs.getPreloads().get(0).getHref().toString());\n\n    assertEquals(1, prefs.getIcons().size());\n\n    assertEquals(1, prefs.getLocales().size());\n\n    assertEquals(Uri.parse(\"http://example.org/link\"), prefs.getLinks().get(\"link\").getHref());\n\n    OAuthService oauth = prefs.getOAuthSpec().getServices().get(\"serviceOne\");\n    assertEquals(Uri.parse(\"http://www.example.com/request\"), oauth.getRequestUrl().url);\n    assertEquals(OAuthService.Method.GET, oauth.getRequestUrl().method);\n    assertEquals(OAuthService.Method.GET, oauth.getAccessUrl().method);\n    assertEquals(OAuthService.Location.HEADER, oauth.getAccessUrl().location);\n    assertEquals(Uri.parse(\"http://www.example.com/authorize\"), oauth.getAuthorizationUrl());\n\n    Multimap<String, Node> extra = prefs.getExtraElements();\n\n    assertTrue(extra.containsKey(\"NavigationItem\"));\n    assertEquals(1, extra.get(\"NavigationItem\").iterator().next().getChildNodes().getLength());\n  }\n\n  @Test\n  public void substitutionsCopyConstructor() throws Exception{\n    ModulePrefs basePrefs = new ModulePrefs(XmlUtil.parse(FULL_XML), SPEC_URL);\n    Substitutions substituter = new Substitutions();\n    String gadgetXml = \"<Module>\" +\n    FULL_XML +\n    \"<Content type=\\\"html\\\"><\/Content>\" +\n    \"<\/Module>\";\n    GadgetSpec baseSpec = new GadgetSpec(SPEC_URL, gadgetXml);\n    GadgetSpec spec = baseSpec.substitute(substituter);\n    ModulePrefs subsPrefs = spec.getModulePrefs();\n    assertEquals(basePrefs.toString(), subsPrefs.toString());\n    doAsserts(subsPrefs);\n  }\n\n  @Test\n  public void basicElementsParseOk() throws Exception {\n    doAsserts(new ModulePrefs(XmlUtil.parse(FULL_XML), SPEC_URL));\n  }\n\n  @Test\n  public void getAttribute() throws Exception {\n    String xml = \"<ModulePrefs title='title' some_attribute='attribute' \" +\n        \"empty_attribute=''/>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertEquals(\"title\", prefs.getAttribute(\"title\"));\n    assertEquals(\"attribute\", prefs.getAttribute(\"some_attribute\"));\n    assertEquals(\"\", prefs.getAttribute(\"empty_attribute\"));\n    assertNull(prefs.getAttribute(\"gobbledygook\"));\n  }\n\n  @Test\n  public void getGlobalLocale() throws Exception {\n    String xml = \"<ModulePrefs title='locales'>\" +\n                 \"  <Locale lang='en' country='UK' messages='en.xml'/>\" +\n                 \"  <Locale lang='foo' language_direction='rtl'/>\" +\n                 \"<\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    LocaleSpec spec = prefs.getGlobalLocale(new Locale(\"en\", \"UK\"));\n    assertEquals(\"http://example.org/en.xml\", spec.getMessages().toString());\n\n    spec = prefs.getGlobalLocale(new Locale(\"foo\", \"ALL\"));\n    assertEquals(\"rtl\", spec.getLanguageDirection());\n\n    spec = prefs.getGlobalLocale(new Locale(\"en\", \"notexist\"));\n    assertNull(spec);\n  }\n\n  @Test\n  public void getViewLocale() throws Exception {\n    String xml = \"<ModulePrefs title='locales'>\" +\n                 \"  <Locale lang='en' country='UK' messages='en.xml' views=\\\"view1\\\"/>\" +\n                 \"  <Locale lang='en' country='US' messages='en_US.xml' views=\\\"view2\\\"/>\" +\n                 \"  <Locale lang='foo' language_direction='rtl'/>\" +\n                 \"<\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    LocaleSpec spec = prefs.getGlobalLocale(new Locale(\"en\", \"UK\"));\n    assertNull(spec);\n    spec = prefs.getLocale(new Locale(\"en\", \"UK\"),\"view1\");\n    assertEquals(\"http://example.org/en.xml\", spec.getMessages().toString());\n    spec = prefs.getLocale(new Locale(\"en\", \"UK\"),\"view2\");\n    assertNull(spec);\n    spec = prefs.getLocale(new Locale(\"en\", \"US\"),\"view2\");\n    assertEquals(\"http://example.org/en_US.xml\", spec.getMessages().toString());\n    spec = prefs.getLocale(new Locale(\"foo\", \"ALL\"),\"view2\");\n    assertEquals(\"rtl\", spec.getLanguageDirection());\n  }\n\n  @Test\n  public void getLinks() throws Exception {\n    String link1Rel = \"foo\";\n    String link2Rel = \"bar\";\n    Uri link1Href = Uri.parse(\"http://example.org/foo\");\n    Uri link2Href = Uri.parse(\"/bar\");\n    String xml = \"<ModulePrefs title='links'>\" +\n                 \"  <Link rel='\" + link1Rel + \"' href='\" + link1Href + \"'/>\" +\n                 \"  <Link rel='\" + link2Rel + \"' href='\" + link2Href + \"'/>\" +\n                 \"<\/ModulePrefs>\";\n\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL)\n        .substitute(new Substitutions());\n\n    assertEquals(link1Href, prefs.getLinks().get(link1Rel).getHref());\n    assertEquals(SPEC_URL.resolve(link2Href), prefs.getLinks().get(link2Rel).getHref());\n  }\n\n  @Test\n  public void getViewFeatures() throws Exception {\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(FULL_XML), SPEC_URL);\n    Map<String, Feature> features = prefs.getViewFeatures(\"default\");\n    assertEquals(5, features.size());\n    assertTrue(features.containsKey(\"requiredview1\"));\n    assertTrue(features.containsKey(\"require\"));\n    assertTrue(features.containsKey(\"optional\"));\n    assertTrue(features.containsKey(\"core\"));\n    assertTrue(features.containsKey(\"security-token\"));\n    assertTrue(!features.containsKey(\"requiredview2\"));\n\n    features = prefs.getViewFeatures(\"view2\");\n    assertEquals(5, features.size());\n    assertTrue(features.containsKey(\"requiredview2\"));\n    assertTrue(features.containsKey(\"require\"));\n    assertTrue(features.containsKey(\"optional\"));\n    assertTrue(features.containsKey(\"core\"));\n    assertTrue(features.containsKey(\"security-token\"));\n    assertTrue(!features.containsKey(\"requiredview1\"));\n  }\n\n  @Test\n  public void getViewFeatureParams() throws Exception {\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(FULL_XML), SPEC_URL);\n    Map<String, Feature> features = prefs.getViewFeatures(\"view2\");\n    String paramValue = features.get(\"require\").getParam(\"param_name\");\n    assertNotNull(paramValue);\n    assertEquals(\"param_value\", paramValue);\n  }\n\n  @Test\n  public void doSubstitution() throws Exception {\n    String xml = \"<ModulePrefs title='__MSG_title__'>\" +\n                 \"  <Icon>__MSG_icon__<\/Icon>\" +\n                 \"  <Link rel='__MSG_rel__' href='__MSG_link_href__'/>\" +\n                 \"  <Preload href='__MSG_pre_href__'/>\" +\n                 \"    <Require feature=\\\"testFeature\\\">\" +\n                 \"           <Param name=\\\"test_param\\\">__MSG_test_param__<\/Param>\" +\n                 \"  <\/Require>\" +\n                 \"<\/ModulePrefs>\";\n    String title = \"blah\";\n    String icon = \"http://example.org/icon.gif\";\n    String rel = \"foo-bar\";\n    String linkHref = \"http://example.org/link.html\";\n    String preHref = \"http://example.org/preload.html\";\n    String testParam = \"bar-foo\";\n\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    Substitutions subst = new Substitutions();\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"title\", title);\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"icon\", icon);\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"rel\", rel);\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"link_href\", linkHref);\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"pre_href\", preHref);\n    subst.addSubstitution(Substitutions.Type.MESSAGE, \"test_param\", testParam);\n    prefs = prefs.substitute(subst);\n\n    assertEquals(title, prefs.getTitle());\n    assertEquals(icon, prefs.getIcons().get(0).getContent());\n    assertEquals(rel, prefs.getLinks().get(rel).getRel());\n    assertEquals(linkHref, prefs.getLinks().get(rel).getHref().toString());\n    assertEquals(preHref, prefs.getPreloads().get(0).getHref().toString());\n    assertEquals(testParam, prefs.getFeatures().get(\"testFeature\").getParam(\"test_param\"));\n  }\n\n  @Test\n  public void malformedIntAttributeTreatedAsZero() throws Exception {\n    String xml = \"<ModulePrefs title='' height='100px' width='foobar' arbitrary='0xff'/>\";\n\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n\n    assertEquals(0, prefs.getHeight());\n    assertEquals(0, prefs.getWidth());\n    assertEquals(0, prefs.getIntAttribute(\"arbitrary\"));\n  }\n\n  @Test\n  public void missingTitleOkay() throws Exception {\n    String xml = \"<ModulePrefs/>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertNotNull(\"Empty ModulePrefs Parses\", prefs);\n    assertEquals(\"Title is empty string\", \"\", prefs.getTitle());\n  }\n\n  @Test\n  public void coreInjectedAutomatically() throws Exception {\n    String xml = \"<ModulePrefs title=''><Require feature='foo'/><\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertEquals(2, prefs.getFeatures().size());\n    assertTrue(prefs.getFeatures().containsKey(\"foo\"));\n    assertTrue(prefs.getFeatures().containsKey(\"core\"));\n  }\n\n  @Test\n  public void coreNotInjectedOnSplitCoreInclusion() throws Exception {\n    String xml = \"<ModulePrefs title=''><Require feature='core.config'/><\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertEquals(1, prefs.getFeatures().size());\n    assertTrue(prefs.getFeatures().containsKey(\"core.config\"));\n  }\n\n  @Test\n  public void securityTokenInjectedOnOAuthTag() throws Exception {\n    // Make sure it is injected when it should be\n    String xml =\n        \"<ModulePrefs title=''>\" +\n        \"  <OAuth>\" +\n        \"    <Service name='serviceOne'>\" +\n        \"      <Request url='http://www.example.com/request'\" +\n        \"          method='GET' param_location='auth-header' />\" +\n        \"      <Authorization url='http://www.example.com/authorize'/>\" +\n        \"      <Access url='http://www.example.com/access' method='GET'\" +\n        \"          param_location='auth-header' />\" +\n        \"    <\/Service>\" +\n        \"  <\/OAuth>\" +\n        \"<\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    Map<String, Feature> features = prefs.getFeatures();\n    assertEquals(2, features.size());\n    assertTrue(features.containsKey(\"core\"));\n    assertTrue(features.containsKey(\"security-token\"));\n\n    Map<String, Feature> viewFeatures = prefs.getViewFeatures(\"default\");\n    assertEquals(2, viewFeatures.size());\n    assertTrue(viewFeatures.containsKey(\"core\"));\n    assertTrue(viewFeatures.containsKey(\"security-token\"));\n  }\n\n  @Test\n  public void securityTokenNotInjectedByDefault() throws Exception {\n    // Make sure the token isn't injected when it shouldn't be, i.e., not required/optional and no\n    // OAuth\n    String xml =\n      \"<ModulePrefs title=''>\" +\n      \"<\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    Map<String, Feature> features = prefs.getFeatures();\n    assertEquals(1, features.size());\n    assertTrue(features.containsKey(\"core\"));\n\n    Map<String, Feature> viewFeatures = prefs.getViewFeatures(\"default\");\n    assertEquals(1, viewFeatures.size());\n    assertTrue(viewFeatures.containsKey(\"core\"));\n  }\n\n  @Test\n  public void toStringIsSane() throws Exception {\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(FULL_XML), SPEC_URL);\n    doAsserts(new ModulePrefs(XmlUtil.parse(prefs.toString()), SPEC_URL));\n  }\n\n  @Test\n  public void needsUserPrefSubstInTitle() throws Exception {\n    String xml = \"<ModulePrefs title='Title __UP_foo__'/>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertTrue(prefs.needsUserPrefSubstitution());\n  }\n\n  @Test\n  public void needsUserPrefSubstInTitleUrl() throws Exception {\n    String xml = \"<ModulePrefs title='foo' title_url='http://__UP_url__'/>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertTrue(prefs.needsUserPrefSubstitution());\n  }\n\n  @Test\n  public void needsUserPrefSubstInPreload() throws Exception {\n    String xml = \"<ModulePrefs title='foo'>\" +\n        \"  <Preload href='__UP_foo__' authz='signed'/><\/ModulePrefs>\";\n    ModulePrefs prefs = new ModulePrefs(XmlUtil.parse(xml), SPEC_URL);\n    assertTrue(prefs.needsUserPrefSubstitution());\n  }\n}\n","lineNo":342}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.auth;\n\nimport org.apache.shindig.common.crypto.BlobCrypterException;\nimport org.apache.shindig.common.util.Utf8UrlCoder;\nimport org.apache.commons.lang.StringUtils;\n\nimport com.google.common.base.Joiner;\nimport com.google.inject.Singleton;\n\nimport java.util.Map;\n\n/**\n * A SecurityTokenCodec implementation that just provides dummy data to satisfy\n * tests and API calls. Do not use this for any security applications.\n *\n * @since 2.0.0\n */\n@Singleton\npublic class BasicSecurityTokenCodec implements SecurityTokenCodec {\n\n  private static final int OWNER_INDEX = 0;\n  private static final int VIEWER_INDEX = 1;\n  private static final int APP_ID_INDEX = 2;\n  private static final int DOMAIN_INDEX = 3;\n  private static final int APP_URL_INDEX = 4;\n  private static final int MODULE_ID_INDEX = 5;\n  private static final int CONTAINER_ID_INDEX = 6;\n  private static final int TOKEN_COUNT = CONTAINER_ID_INDEX + 1;\n\n  /**\n   * Encodes a token using the a plaintext dummy format.\n   * @param token token to encode\n   * @return token with values separated by colons\n   */\n  public String encodeToken(SecurityToken token) {\n    return Joiner.on(\":\").join(\n        Utf8UrlCoder.encode(token.getOwnerId()),\n        Utf8UrlCoder.encode(token.getViewerId()),\n        Utf8UrlCoder.encode(token.getAppId()),\n        Utf8UrlCoder.encode(token.getDomain()),\n        Utf8UrlCoder.encode(token.getAppUrl()),\n        Long.toString(token.getModuleId()),\n        Utf8UrlCoder.encode(token.getContainer()));\n  }\n\n\n  /**\n   * {@inheritDoc}\n   *\n   * Returns a token with some faked out values.\n   */\n  public SecurityToken createToken(Map<String, String> parameters)\n      throws SecurityTokenException {\n\n    final String token = parameters.get(SecurityTokenCodec.SECURITY_TOKEN_NAME);\n    if (token == null || token.trim().length() == 0) {\n      // No token is present, assume anonymous access\n      return new AnonymousSecurityToken();\n    }\n\n    try {\n      String[] tokens = StringUtils.split(token, ':');\n      if (tokens.length != TOKEN_COUNT) {\n        throw new SecurityTokenException(\"Malformed security token\");\n      }\n\n      return new BasicSecurityToken(\n          Utf8UrlCoder.decode(tokens[OWNER_INDEX]),\n          Utf8UrlCoder.decode(tokens[VIEWER_INDEX]),\n          Utf8UrlCoder.decode(tokens[APP_ID_INDEX]),\n          Utf8UrlCoder.decode(tokens[DOMAIN_INDEX]),\n          Utf8UrlCoder.decode(tokens[APP_URL_INDEX]),\n          Utf8UrlCoder.decode(tokens[MODULE_ID_INDEX]),\n          Utf8UrlCoder.decode(tokens[CONTAINER_ID_INDEX]),\n          parameters.get(SecurityTokenCodec.ACTIVE_URL_NAME),\n          null);\n    } catch (BlobCrypterException e) {\n      throw new SecurityTokenException(e);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      throw new SecurityTokenException(e);\n    }\n  }\n\n  public Long getTokenExpiration(SecurityToken token) {\n    // TODO: Support and/or implement this operation.\n    return null;\n  }\n\n  /**\n   * Creates a signer with 24 hour token expiry\n   */\n  public BasicSecurityTokenCodec() {\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.auth;\n\nimport org.apache.shindig.common.crypto.BlobCrypterException;\nimport org.apache.shindig.common.util.Utf8UrlCoder;\nimport org.apache.commons.lang.StringUtils;\n\nimport com.google.common.base.Joiner;\nimport com.google.inject.Singleton;\n\nimport java.util.Map;\n\n/**\n * A SecurityTokenCodec implementation that just provides dummy data to satisfy\n * tests and API calls. Do not use this for any security applications.\n *\n * @since 2.0.0\n */\n@Singleton\npublic class BasicSecurityTokenCodec implements SecurityTokenCodec {\n\n  private static final int OWNER_INDEX = 0;\n  private static final int VIEWER_INDEX = 1;\n  private static final int APP_ID_INDEX = 2;\n  private static final int DOMAIN_INDEX = 3;\n  private static final int APP_URL_INDEX = 4;\n  private static final int MODULE_ID_INDEX = 5;\n  private static final int CONTAINER_ID_INDEX = 6;\n  private static final int EXPIRY_INDEX = 7; // for back compat, conditionally check later\n  private static final int TOKEN_COUNT = CONTAINER_ID_INDEX + 1;\n\n  /**\n   * Encodes a token using the a plaintext dummy format.\n   * @param token token to encode\n   * @return token with values separated by colons\n   */\n  public String encodeToken(SecurityToken token) {\n    BasicSecurityToken basicToken = new BasicSecurityToken();\n    basicToken.setExpires();  // Quick and dirty token expire calculation.\n    return Joiner.on(\":\").join(\n        Utf8UrlCoder.encode(token.getOwnerId()),\n        Utf8UrlCoder.encode(token.getViewerId()),\n        Utf8UrlCoder.encode(token.getAppId()),\n        Utf8UrlCoder.encode(token.getDomain()),\n        Utf8UrlCoder.encode(token.getAppUrl()),\n        Long.toString(token.getModuleId(), 10),\n        Utf8UrlCoder.encode(token.getContainer()),\n        Long.toString(basicToken.getExpiresAt(), 10));\n  }\n\n\n  /**\n   * {@inheritDoc}\n   *\n   * Returns a token with some faked out values.\n   */\n  public SecurityToken createToken(Map<String, String> parameters)\n      throws SecurityTokenException {\n\n    final String token = parameters.get(SecurityTokenCodec.SECURITY_TOKEN_NAME);\n    if (token == null || token.trim().length() == 0) {\n      // No token is present, assume anonymous access\n      return new AnonymousSecurityToken();\n    }\n\n    try {\n      String[] tokens = StringUtils.split(token, ':');\n      if (tokens.length < TOKEN_COUNT) {\n        throw new SecurityTokenException(\"Malformed security token\");\n      }\n\n      Long expires = null;\n      if (tokens.length > TOKEN_COUNT && !tokens[EXPIRY_INDEX].equals(\"\")) {\n        expires = Long.parseLong(Utf8UrlCoder.decode(tokens[EXPIRY_INDEX]), 10);\n      }\n\n      BasicSecurityToken basicToken = new BasicSecurityToken(\n          Utf8UrlCoder.decode(tokens[OWNER_INDEX]),\n          Utf8UrlCoder.decode(tokens[VIEWER_INDEX]),\n          Utf8UrlCoder.decode(tokens[APP_ID_INDEX]),\n          Utf8UrlCoder.decode(tokens[DOMAIN_INDEX]),\n          Utf8UrlCoder.decode(tokens[APP_URL_INDEX]),\n          Utf8UrlCoder.decode(tokens[MODULE_ID_INDEX]),\n          Utf8UrlCoder.decode(tokens[CONTAINER_ID_INDEX]),\n          parameters.get(SecurityTokenCodec.ACTIVE_URL_NAME),\n          expires);\n      return basicToken.enforceNotExpired();\n    } catch (BlobCrypterException e) {\n      throw new SecurityTokenException(e);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      throw new SecurityTokenException(e);\n    }\n  }\n\n  /**\n   * Creates a signer with 24 hour token expiry\n   */\n  public BasicSecurityTokenCodec() {\n  }\n}\n","lineNo":89}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.auth;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.shindig.common.crypto.BasicBlobCrypter;\nimport org.apache.shindig.common.crypto.BlobCrypter;\nimport org.apache.shindig.common.crypto.BlobCrypterException;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.config.ContainerConfig;\n\nimport com.google.common.collect.Maps;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Provides security token decoding services.  Configuration is via containers.js.  Each container\n * should specify (or inherit)\n *\n * securityTokenKeyFile: path to file containing a key to use for verifying tokens.\n * signedFetchDomain: oauth_consumer_key value to use for signed fetch using default key.\n *\n * Creating a key is best done with a command line like this:\n * <pre>\n *     dd if=/dev/random bs=32 count=1  | openssl base64 > /tmp/key.txt\n * <\/pre>\n * Wire format is \"&lt;container&gt;:&lt;encrypted-and-signed-token&gt;\"\n *\n * @since 2.0.0\n */\n@Singleton\npublic class BlobCrypterSecurityTokenCodec implements SecurityTokenCodec, ContainerConfig.ConfigObserver {\n  private static final Logger LOG = Logger.getLogger(BlobCrypterSecurityTokenCodec.class.getName());\n\n  public static final String SECURITY_TOKEN_KEY_FILE = \"gadgets.securityTokenKeyFile\";\n\n  public static final String SIGNED_FETCH_DOMAIN = \"gadgets.signedFetchDomain\";\n\n  /**\n   * Keys are container ids, values are crypters\n   */\n  protected Map<String, BlobCrypter> crypters = Maps.newHashMap();\n\n  /**\n   * Keys are container ids, values are domains used for signed fetch.\n   */\n  protected Map<String, String> domains = Maps.newHashMap();\n\n  @Inject\n  public BlobCrypterSecurityTokenCodec(ContainerConfig config) {\n    try {\n      config.addConfigObserver(this, false);\n      loadContainers(config, config.getContainers(), crypters, domains);\n    } catch (IOException e) {\n      // Someone specified securityTokenKeyFile, but we couldn't load the key.  That merits killing\n      // the server.\n      LOG.log(Level.SEVERE, \"Error while initializing BlobCrypterSecurityTokenCodec\", e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  public void containersChanged(\n      ContainerConfig config, Collection<String> changed, Collection<String> removed) {\n    Map<String, BlobCrypter> newCrypters = Maps.newHashMap(crypters);\n    Map<String, String> newDomains = Maps.newHashMap(domains);\n    try {\n      loadContainers(config, changed, newCrypters, newDomains);\n      for (String container : removed) {\n        newCrypters.remove(container);\n        newDomains.remove(container);\n      }\n    } catch (IOException e) {\n      // Someone specified securityTokenKeyFile, but we couldn't load the key.\n      // Keep the old configuration.\n      LOG.log(Level.WARNING, \"There was an error loading an updated container configuration. \"\n          + \"Keeping old configuration.\", e);\n      return;\n    }\n    crypters = newCrypters;\n    domains = newDomains;\n  }\n  \n  private void loadContainers(ContainerConfig config, Collection<String> containers,\n      Map<String, BlobCrypter> crypters, Map<String, String> domains) throws IOException {\n    for (String container : containers) {\n      String keyFile = config.getString(container, SECURITY_TOKEN_KEY_FILE);\n      if (keyFile != null) {\n        BlobCrypter crypter = loadCrypter(keyFile);\n        crypters.put(container, crypter);\n      }\n      String domain = config.getString(container, SIGNED_FETCH_DOMAIN);\n      domains.put(container, domain);\n    }\n  }\n\n  /**\n   * Load a BlobCrypter from the key file.  Override this if you have your own\n   * BlobCrypter implementation.\n   *\n   * @param keyFile The key file to load from.  This can either be an absolute file path or a\n   * reference to a resource that should be loaded from the classpath (ie res://key-file.txt).\n   * @return The BlobCrypter.\n   * @throws IOException If the key file is invalid.\n   */\n  protected BlobCrypter loadCrypter(String keyFile) throws IOException {\n    return new BasicBlobCrypter(IOUtils.toString(ResourceLoader.open(keyFile), \"UTF-8\"));\n  }\n\n  /**\n   * Decrypt and verify the provided security token.\n   */\n  public SecurityToken createToken(Map<String, String> tokenParameters)\n      throws SecurityTokenException {\n    String token = tokenParameters.get(SecurityTokenCodec.SECURITY_TOKEN_NAME);\n    if (StringUtils.isBlank(token)) {\n      // No token is present, assume anonymous access\n      return new AnonymousSecurityToken();\n    }\n    String[] fields = StringUtils.split(token, ':');\n    if (fields.length != 2) {\n      throw new SecurityTokenException(\"Invalid security token \" + token);\n    }\n    String container = fields[0];\n    BlobCrypter crypter = crypters.get(container);\n    if (crypter == null) {\n      throw new SecurityTokenException(\"Unknown container \" + token);\n    }\n    String domain = domains.get(container);\n    String activeUrl = tokenParameters.get(SecurityTokenCodec.ACTIVE_URL_NAME);\n    String crypted = fields[1];\n    try {\n      return BlobCrypterSecurityToken.decrypt(crypter, container, domain, crypted, activeUrl);\n    } catch (BlobCrypterException e) {\n      throw new SecurityTokenException(e);\n    }\n  }\n\n  public String encodeToken(SecurityToken token) throws SecurityTokenException {\n    if (!token.getAuthenticationMode().equals(\n            AuthenticationMode.SECURITY_TOKEN_URL_PARAMETER.name())) {\n      throw new SecurityTokenException(\"Can only encode BlogCrypterSecurityTokens\");\n    }\n\n    BlobCrypter crypter = crypters.get(token.getContainer());\n    if (crypter == null) {\n      throw new SecurityTokenException(\"Unknown container \" + token.getContainer());\n    }\n    \n    try {\n      return BlobCrypterSecurityToken.encrypt(token, crypter);\n    } catch (BlobCrypterException e) {\n      throw new SecurityTokenException(e);\n    }\n  }\n\n  public Long getTokenExpiration(SecurityToken token) {\n    // TODO: Support and/or implement this operation.\n    return null;\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.auth;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.shindig.common.crypto.BasicBlobCrypter;\nimport org.apache.shindig.common.crypto.BlobCrypter;\nimport org.apache.shindig.common.crypto.BlobCrypterException;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.config.ContainerConfig;\n\nimport com.google.common.collect.Maps;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\n\n/**\n * Provides security token decoding services.  Configuration is via containers.js.  Each container\n * should specify (or inherit)\n *\n * securityTokenKeyFile: path to file containing a key to use for verifying tokens.\n * signedFetchDomain: oauth_consumer_key value to use for signed fetch using default key.\n *\n * Creating a key is best done with a command line like this:\n * <pre>\n *     dd if=/dev/random bs=32 count=1  | openssl base64 > /tmp/key.txt\n * <\/pre>\n * Wire format is \"&lt;container&gt;:&lt;encrypted-and-signed-token&gt;\"\n *\n * @since 2.0.0\n */\n@Singleton\npublic class BlobCrypterSecurityTokenCodec implements SecurityTokenCodec, ContainerConfig.ConfigObserver {\n  private static final Logger LOG = Logger.getLogger(BlobCrypterSecurityTokenCodec.class.getName());\n\n  public static final String SECURITY_TOKEN_KEY_FILE = \"gadgets.securityTokenKeyFile\";\n\n  public static final String SIGNED_FETCH_DOMAIN = \"gadgets.signedFetchDomain\";\n\n  /**\n   * Keys are container ids, values are crypters\n   */\n  protected Map<String, BlobCrypter> crypters = Maps.newHashMap();\n\n  /**\n   * Keys are container ids, values are domains used for signed fetch.\n   */\n  protected Map<String, String> domains = Maps.newHashMap();\n\n  @Inject\n  public BlobCrypterSecurityTokenCodec(ContainerConfig config) {\n    try {\n      config.addConfigObserver(this, false);\n      loadContainers(config, config.getContainers(), crypters, domains);\n    } catch (IOException e) {\n      // Someone specified securityTokenKeyFile, but we couldn't load the key.  That merits killing\n      // the server.\n      LOG.log(Level.SEVERE, \"Error while initializing BlobCrypterSecurityTokenCodec\", e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  public void containersChanged(\n      ContainerConfig config, Collection<String> changed, Collection<String> removed) {\n    Map<String, BlobCrypter> newCrypters = Maps.newHashMap(crypters);\n    Map<String, String> newDomains = Maps.newHashMap(domains);\n    try {\n      loadContainers(config, changed, newCrypters, newDomains);\n      for (String container : removed) {\n        newCrypters.remove(container);\n        newDomains.remove(container);\n      }\n    } catch (IOException e) {\n      // Someone specified securityTokenKeyFile, but we couldn't load the key.\n      // Keep the old configuration.\n      LOG.log(Level.WARNING, \"There was an error loading an updated container configuration. \"\n          + \"Keeping old configuration.\", e);\n      return;\n    }\n    crypters = newCrypters;\n    domains = newDomains;\n  }\n\n  private void loadContainers(ContainerConfig config, Collection<String> containers,\n      Map<String, BlobCrypter> crypters, Map<String, String> domains) throws IOException {\n    for (String container : containers) {\n      String keyFile = config.getString(container, SECURITY_TOKEN_KEY_FILE);\n      if (keyFile != null) {\n        BlobCrypter crypter = loadCrypter(keyFile);\n        crypters.put(container, crypter);\n      }\n      String domain = config.getString(container, SIGNED_FETCH_DOMAIN);\n      domains.put(container, domain);\n    }\n  }\n\n  /**\n   * Load a BlobCrypter from the key file.  Override this if you have your own\n   * BlobCrypter implementation.\n   *\n   * @param keyFile The key file to load from.  This can either be an absolute file path or a\n   * reference to a resource that should be loaded from the classpath (ie res://key-file.txt).\n   * @return The BlobCrypter.\n   * @throws IOException If the key file is invalid.\n   */\n  protected BlobCrypter loadCrypter(String keyFile) throws IOException {\n    return new BasicBlobCrypter(IOUtils.toString(ResourceLoader.open(keyFile), \"UTF-8\"));\n  }\n\n  /**\n   * Decrypt and verify the provided security token.\n   */\n  public SecurityToken createToken(Map<String, String> tokenParameters)\n      throws SecurityTokenException {\n    String token = tokenParameters.get(SecurityTokenCodec.SECURITY_TOKEN_NAME);\n    if (StringUtils.isBlank(token)) {\n      // No token is present, assume anonymous access\n      return new AnonymousSecurityToken();\n    }\n    String[] fields = StringUtils.split(token, ':');\n    if (fields.length != 2) {\n      throw new SecurityTokenException(\"Invalid security token \" + token);\n    }\n    String container = fields[0];\n    BlobCrypter crypter = crypters.get(container);\n    if (crypter == null) {\n      throw new SecurityTokenException(\"Unknown container \" + token);\n    }\n    String domain = domains.get(container);\n    String activeUrl = tokenParameters.get(SecurityTokenCodec.ACTIVE_URL_NAME);\n    String crypted = fields[1];\n    try {\n      BlobCrypterSecurityToken st = new BlobCrypterSecurityToken(container, domain, activeUrl,\n          crypter.unwrap(crypted));\n      return st.enforceNotExpired();\n    } catch (BlobCrypterException e) {\n      throw new SecurityTokenException(e);\n    }\n  }\n\n  /**\n   * Encrypt and sign the token.  The returned value is *not* web safe, it should be URL\n   * encoded before being used as a form parameter.\n   */\n  public String encodeToken(SecurityToken token) throws SecurityTokenException {\n    if (!token.getAuthenticationMode().equals(\n            AuthenticationMode.SECURITY_TOKEN_URL_PARAMETER.name())) {\n      throw new SecurityTokenException(\"Can only encode BlogCrypterSecurityTokens\");\n    }\n\n    // Test code sends in real AbstractTokens, they have modified time sources in them so\n    // that we can test token expiration, production tokens are proxied via the SecurityToken interface.\n    AbstractSecurityToken aToken = token instanceof AbstractSecurityToken ?\n        (AbstractSecurityToken)token : BlobCrypterSecurityToken.fromToken(token);\n\n    BlobCrypter crypter = crypters.get(aToken.getContainer());\n    if (crypter == null) {\n      throw new SecurityTokenException(\"Unknown container \" + aToken.getContainer());\n    }\n\n    try {\n      aToken.setExpires();\n      return aToken.getContainer() + ':' + crypter.wrap(aToken.toMap());\n    } catch (BlobCrypterException e) {\n      throw new SecurityTokenException(e);\n    }\n  }\n}\n","lineNo":175}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.admin;\n\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.google.caja.util.Maps;\nimport com.google.common.base.Objects;\n\n/**\n * Container's administration data.\n *\n * @version $Id: $\n */\npublic class ContainerAdminData {\n  private Map<String, GadgetAdminData> gadgetAdminMap;\n\n  /**\n   * Constructor\n   */\n  public ContainerAdminData() {\n    this(null);\n  }\n\n  /**\n   * Constructor\n   *\n   * @param gadgetAdminMap\n   *          map of gadget URLs to gadget admin data.\n   */\n  public ContainerAdminData(Map<String, GadgetAdminData> gadgetAdminMap) {\n    if (gadgetAdminMap == null) {\n      gadgetAdminMap = Maps.newHashMap();\n    }\n    this.gadgetAdminMap = gadgetAdminMap;\n  }\n\n  /**\n   * Adds gadget administration information for this container.\n   *\n   * @param gadgetUrl\n   *          the URL of the gadget the admin data is for.\n   * @param toAdd\n   *          the administration data for the gadget.\n   */\n  public void addGadgetAdminData(String gadgetUrl, GadgetAdminData toAdd) {\n    if (gadgetUrl != null) {\n      if (toAdd == null) {\n        toAdd = new GadgetAdminData();\n      }\n      this.gadgetAdminMap.put(gadgetUrl, toAdd);\n    }\n  }\n\n  /**\n   * Removes the gadget administration data.\n   *\n   * @param gadgetUrl\n   *          the gadget URL.\n   *\n   * @return The gadget administration data that was removed, or null if there was not gadget\n   *         administration data associated with that gadget URL.\n   */\n  public GadgetAdminData removeGadgetAdminData(String gadgetUrl) {\n    return this.gadgetAdminMap.remove(gadgetUrl);\n  }\n\n  /**\n   * Gets the gadget admin data for a given gadget.\n   *\n   * @param gadgetUrl\n   *          the URL to the gadget to get the administration data for.\n   * @return the gadget admin data.\n   */\n  public GadgetAdminData getGadgetAdminData(String gadgetUrl) {\n    GadgetAdminData match = this.gadgetAdminMap.get(gadgetUrl);\n    if(match != null) {\n      return match;\n    }\n\n    String key = gadgetUrl != null ? getGadgetAdminDataKey(gadgetUrl) : null;\n    return this.gadgetAdminMap.get(key);\n  }\n\n  /**\n   * Gets the gadget admin map.\n   *\n   * @return the gadget admin map.\n   */\n  public Map<String, GadgetAdminData> getGadgetAdminMap() {\n    return this.gadgetAdminMap;\n  }\n\n  /**\n   * Clears the gadget administration data.\n   */\n  public void clearGadgetAdminData() {\n    this.gadgetAdminMap.clear();\n  }\n\n  /**\n   * Determines whether there is administration data for a gadget.\n   *\n   * @param gadgetUrl\n   *          the gadget URL to check.\n   * @return true if there is administration data for a gadget false otherwise.\n   */\n  public boolean hasGadgetAdminData(String gadgetUrl) {\n    if (this.gadgetAdminMap.keySet().contains(gadgetUrl)) {\n      return true;\n    }\n\n    return gadgetUrl != null ? getGadgetAdminDataKey(gadgetUrl) != null : false;\n  }\n\n  /**\n   * Gets the key in the map for the gadget URL.\n   *\n   * @param gadgetUrl\n   *          The gadget URL.\n   * @return The key in the map for the gadget URL.\n   */\n  private String getGadgetAdminDataKey(String gadgetUrl) {\n    Set<String> gadgetUrls = this.gadgetAdminMap.keySet();\n    String key = null;\n    for (String url : gadgetUrls) {\n      if (url.endsWith(\"*\") && gadgetUrl.startsWith(url.substring(0, url.length() - 1))) {\n        if (key == null || (key != null && key.length() < url.length())) {\n          key = url;\n        }\n      }\n    }\n    return key;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (obj instanceof ContainerAdminData) {\n      ContainerAdminData test = (ContainerAdminData) obj;\n      Map<String, GadgetAdminData> testGadgetAdminMap = test.getGadgetAdminMap();\n      return testGadgetAdminMap.equals(this.getGadgetAdminMap());\n\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hashCode(this.gadgetAdminMap);\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.admin;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.google.caja.util.Maps;\nimport com.google.common.base.Objects;\n\n/**\n * Container's administration data.\n *\n * @version $Id: $\n */\npublic class ContainerAdminData {\n  private static final String STAR = \"*\";\n  private static final String HTTP = \"http\";\n  private static final String HTTPS = \"https\";\n  private static final int HTTP_PORT = 80;\n  private static final int HTTPS_PORT = 443;\n\n  private Map<String, GadgetAdminData> gadgetAdminMap;\n\n  /**\n   * Constructor\n   */\n  public ContainerAdminData() {\n    this(null);\n  }\n\n  /**\n   * Constructor\n   *\n   * @param gadgetAdminMap\n   *          map of gadget URLs to gadget admin data.\n   */\n  public ContainerAdminData(Map<String, GadgetAdminData> gadgetAdminMap) {\n    if (gadgetAdminMap == null) {\n      gadgetAdminMap = Maps.newHashMap();\n    }\n    this.gadgetAdminMap = gadgetAdminMap;\n  }\n\n  /**\n   * Adds gadget administration information for this container.\n   *\n   * @param gadgetUrl\n   *          the URL of the gadget the admin data is for.\n   * @param toAdd\n   *          the administration data for the gadget.\n   */\n  public void addGadgetAdminData(String gadgetUrl, GadgetAdminData toAdd) {\n    if (gadgetUrl != null) {\n      if (toAdd == null) {\n        toAdd = new GadgetAdminData();\n      }\n      this.gadgetAdminMap.put(gadgetUrl, toAdd);\n    }\n  }\n\n  /**\n   * Removes the gadget administration data.\n   *\n   * @param gadgetUrl\n   *          the gadget URL.\n   *\n   * @return The gadget administration data that was removed, or null if there was not gadget\n   *         administration data associated with that gadget URL.\n   */\n  public GadgetAdminData removeGadgetAdminData(String gadgetUrl) {\n    return this.gadgetAdminMap.remove(gadgetUrl);\n  }\n\n  /**\n   * Gets the gadget admin data for a given gadget.\n   *\n   * @param gadgetUrl\n   *          the URL to the gadget to get the administration data for.\n   * @return the gadget admin data.\n   */\n  public GadgetAdminData getGadgetAdminData(String gadgetUrl) {\n    GadgetAdminData match = this.gadgetAdminMap.get(gadgetUrl);\n    if(match != null) {\n      return match;\n    }\n\n    String key = gadgetUrl != null ? getGadgetAdminDataKey(gadgetUrl) : null;\n    return this.gadgetAdminMap.get(key);\n  }\n\n  /**\n   * Gets the gadget admin map.\n   *\n   * @return the gadget admin map.\n   */\n  public Map<String, GadgetAdminData> getGadgetAdminMap() {\n    return this.gadgetAdminMap;\n  }\n\n  /**\n   * Clears the gadget administration data.\n   */\n  public void clearGadgetAdminData() {\n    this.gadgetAdminMap.clear();\n  }\n\n  /**\n   * Determines whether there is administration data for a gadget.\n   *\n   * @param gadgetUrl\n   *          the gadget URL to check.\n   * @return true if there is administration data for a gadget false otherwise.\n   */\n  public boolean hasGadgetAdminData(String gadgetUrl) {\n    if (this.gadgetAdminMap.keySet().contains(gadgetUrl)) {\n      return true;\n    }\n\n    return gadgetUrl != null ? getGadgetAdminDataKey(gadgetUrl) != null : false;\n  }\n\n  /**\n   * Gets the key in the map for the gadget URL.\n   *\n   * @param gadgetUrl\n   *          The gadget URL.\n   * @return The key in the map for the gadget URL.\n   */\n  private String getGadgetAdminDataKey(String gadgetUrl) {\n    Set<String> gadgetUrls = this.gadgetAdminMap.keySet();\n    String normalizedGadgetUrl = createUrlWithPort(gadgetUrl);\n    String key = null;\n    for (String url : gadgetUrls) {\n      String normalizedUrl = createUrlWithPort(url);\n      if (normalizedUrl.endsWith(STAR)\n              && normalizedGadgetUrl.startsWith(normalizedUrl.substring(0,\n                      normalizedUrl.length() - 1))) {\n        if (key == null || (key != null && key.length() < normalizedUrl.length())) {\n          key = url;\n        }\n      } else if (normalizedUrl.equals(normalizedGadgetUrl)) {\n        key = url;\n        break;\n      }\n    }\n    return key;\n  }\n\n  /**\n   * Creates a new URL with the default port if one is not already there.\n   *\n   * @param gadgetUrl\n   *          The gadget URL to add the port to.\n   * @return A new URL with the default port.\n   */\n  private String createUrlWithPort(String gadgetUrl) {\n    try {\n      URL origUrl = new URL(gadgetUrl);\n      URL urlWithPort = null;\n      String origHost = origUrl.getHost();\n      if (origUrl.getPort() <= 0 && origHost != null && origHost.length() != 0\n              && !STAR.equals(origHost)) {\n        if (origUrl.getProtocol().equalsIgnoreCase(HTTP)) {\n          urlWithPort = new URL(origUrl.getProtocol(), origUrl.getHost(), HTTP_PORT, origUrl.getFile());\n        }\n        else if (origUrl.getProtocol().equalsIgnoreCase(HTTPS)) {\n          urlWithPort = new URL(origUrl.getProtocol(), origUrl.getHost(), HTTPS_PORT, origUrl.getFile());\n        }\n        return urlWithPort == null ? origUrl.toString() : urlWithPort.toString();\n      } else {\n        return origUrl.toString();\n      }\n    } catch (MalformedURLException e) {\n      return gadgetUrl;\n    }\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (obj instanceof ContainerAdminData) {\n      ContainerAdminData test = (ContainerAdminData) obj;\n      Map<String, GadgetAdminData> testGadgetAdminMap = test.getGadgetAdminMap();\n      return testGadgetAdminMap.equals(this.getGadgetAdminMap());\n\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hashCode(this.gadgetAdminMap);\n  }\n}\n","lineNo":153}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.servlet;\n\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.JsonProperty;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.common.uri.UriBuilder;\nimport org.apache.shindig.gadgets.AuthType;\nimport org.apache.shindig.gadgets.FeedProcessor;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.http.HttpRequest;\nimport org.apache.shindig.gadgets.http.HttpResponse;\nimport org.apache.shindig.gadgets.http.RequestPipeline;\nimport org.apache.shindig.gadgets.oauth.OAuthArguments;\nimport org.apache.shindig.gadgets.rewrite.ResponseRewriterList.RewriteFlow;\nimport org.apache.shindig.gadgets.rewrite.ResponseRewriterRegistry;\nimport org.apache.shindig.gadgets.rewrite.RewriterRegistry;\nimport org.apache.shindig.gadgets.rewrite.RewritingException;\nimport org.apache.shindig.protocol.BaseRequestItem;\nimport org.apache.shindig.protocol.Operation;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.Service;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Maps;\nimport com.google.inject.Inject;\nimport com.google.inject.Provider;\n\n/**\n * An alternate implementation of the Http proxy service using the standard API dispatcher for REST\n * / JSON-RPC calls. The basic form of the request is as follows\n * ...\n * method : http.<HTTP method name>\n * params : {\n *    href : <endpoint to fetch content from>,\n *    headers : { <header-name> : [<header-value>, ...]},\n *    format : <\"text\", \"json\", \"feed\">\n *    body : <request body>\n *    gadget : <url of gadget spec for calling application>\n *    authz: : <none | oauth | signed>,\n *    sign_owner: <boolean, default true>\n *    sign_viewer: <boolean, default true>\n *    ...<additional auth arguments. See OAuthArguments>\n *    refreshInterval : <Integer time in seconds to force as cache TTL. Default is to use response headers>\n *    noCache : <Bypass container content cache. Default false>\n *    sanitize : <Force sanitize fetched content. Default false>\n *    summarize : <If contentType == \"FEED\" summarize the results. Default false>\n *    entryCount : <If contentType == \"FEED\" limit results to specified no of items. Default 3>\n * }\n *\n * A successful response response will have the form\n *\n * data : {\n *    status : <HTTP status code.>\n *    headers : { <header name> : [<header val1>, <header val2>, ...], ...}\n *    content : <response body>: string if 'text', JSON is 'feed' or 'json' format\n *    token : <If security token provides a renewed value.>\n *    metadata : { <metadata entry> : <metadata value>, ...}\n * }\n *\n * It's important to note that requests which generate HTTP error responses such as 500 are returned\n * in the above format. The RPC itself succeeded in these cases. If an RPC error occurred the client\n * should introspect the error message for information as to the cause.\n *\n * TODO: send errors using \"result\", not plain content\n *\n * @see MakeRequestHandler\n */\n@Service(name = \"http\")\npublic class HttpRequestHandler {\n\n  static final Set<String> BAD_HEADERS = ImmutableSet.of(\"HOST\", \"ACCEPT-ENCODING\");\n\n  private final RequestPipeline requestPipeline;\n  private final ResponseRewriterRegistry contentRewriterRegistry;\n  private final Provider<FeedProcessor> feedProcessorProvider;\n\n  @Inject\n  public HttpRequestHandler(RequestPipeline requestPipeline,\n      @RewriterRegistry(rewriteFlow = RewriteFlow.DEFAULT)\n      ResponseRewriterRegistry contentRewriterRegistry,\n      Provider<FeedProcessor> feedProcessorProvider) {\n    this.requestPipeline = requestPipeline;\n    this.contentRewriterRegistry = contentRewriterRegistry;\n    this.feedProcessorProvider = feedProcessorProvider;\n  }\n\n\n  /** Execute an HTTP GET request */\n  @Operation(httpMethods = {\"POST\",\"GET\"}, path = \"/get\")\n  public HttpApiResponse get(BaseRequestItem request) {\n    HttpApiRequest httpReq = request.getTypedRequest(HttpApiRequest.class);\n    assertNoBody(httpReq, \"GET\");\n    return execute(\"GET\", httpReq, request);\n  }\n\n  /** Execute an HTTP POST request */\n  @Operation(httpMethods = \"POST\", path = \"/post\")\n  public HttpApiResponse post(BaseRequestItem request) {\n    HttpApiRequest httpReq = request.getTypedRequest(HttpApiRequest.class);\n    return execute(\"POST\", httpReq, request);\n  }\n\n  /** Execute an HTTP PUT request */\n  @Operation(httpMethods = \"POST\", path = \"/put\")\n  public HttpApiResponse put(BaseRequestItem request) {\n    HttpApiRequest httpReq = request.getTypedRequest(HttpApiRequest.class);\n    return execute(\"PUT\", httpReq, request);\n  }\n\n  /** Execute an HTTP DELETE request */\n  @Operation(httpMethods = \"POST\", path = \"/delete\")\n  public HttpApiResponse delete(BaseRequestItem request) {\n    HttpApiRequest httpReq = request.getTypedRequest(HttpApiRequest.class);\n    assertNoBody(httpReq, \"DELETE\");\n    return execute(\"DELETE\", httpReq, request);\n  }\n\n  /** Execute an HTTP HEAD request */\n  @Operation(httpMethods = {\"POST\",\"GET\"}, path = \"/head\")\n  public HttpApiResponse head(BaseRequestItem request) {\n    HttpApiRequest httpReq = request.getTypedRequest(HttpApiRequest.class);\n    assertNoBody(httpReq, \"HEAD\");\n    return execute(\"HEAD\", httpReq, request);\n  }\n\n  private void assertNoBody(HttpApiRequest httpRequest, String method) {\n    if (httpRequest.body != null) {\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST,\n         \"Request body not supported for \" + method);\n    }\n  }\n\n  /**\n   * Dispatch the request\n   *\n   * @param method HTTP method to execute\n   * @param requestItem TODO\n   */\n  private HttpApiResponse execute(String method, HttpApiRequest httpApiRequest,\n      BaseRequestItem requestItem) {\n    if (httpApiRequest.href == null) {\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"href parameter is missing\");\n    }\n\n    // Canonicalize the path\n    Uri href = normalizeUrl(httpApiRequest.href);\n    try {\n      HttpRequest req = new HttpRequest(href);\n      req.setMethod(method);\n      if (httpApiRequest.body != null) {\n        req.setPostBody(httpApiRequest.body.getBytes());\n      }\n\n      // Copy over allowed headers\n      for (Map.Entry<String, List<String>> header : httpApiRequest.headers.entrySet()) {\n        if (!BAD_HEADERS.contains(header.getKey().trim().toUpperCase())) {\n          for (String value : header.getValue()) {\n            req.addHeader(header.getKey(), value);\n          }\n        }\n      }\n\n      // Extract the gadget URI from the request or the security token\n      Uri gadgetUri = getGadgetUri(requestItem.getToken(), httpApiRequest);\n      if (gadgetUri == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST,\n            \"Gadget URI not specified in request\");\n      }\n      req.setGadget(gadgetUri);\n\n      // Detect the authz parsing\n      if (httpApiRequest.authz != null) {\n        req.setAuthType(AuthType.parse(httpApiRequest.authz));\n      }\n\n      if (req.getAuthType() != AuthType.NONE) {\n        req.setSecurityToken(requestItem.getToken());\n        \n        Map<String, String> authSettings = getAuthSettings(requestItem);\n        OAuthArguments oauthArgs = new OAuthArguments(req.getAuthType(), authSettings);\n        oauthArgs.setSignOwner(httpApiRequest.signOwner);\n        oauthArgs.setSignViewer(httpApiRequest.signViewer);\n        \n        req.setOAuthArguments(oauthArgs);\n      }\n\n      // TODO: Allow the rewriter to use an externally forced mime type. This is needed\n      // allows proper rewriting of <script src=\"x\"/> where x is returned with\n      // a content type like text/html which unfortunately happens all too often\n      \n      req.setIgnoreCache(httpApiRequest.noCache);\n      req.setSanitizationRequested(httpApiRequest.sanitize);\n\n      // If the proxy request specifies a refresh param then we want to force the min TTL for\n      // the retrieved entry in the cache regardless of the headers on the content when it\n      // is fetched from the original source.\n      if (httpApiRequest.refreshInterval != null) {\n        req.setCacheTtl(httpApiRequest.refreshInterval);\n      }\n\n      HttpResponse results = requestPipeline.execute(req);\n      // TODO: os:HttpRequest and Preload do not use the content rewriter.\n      // Should we really do so here?\n      results = contentRewriterRegistry.rewriteHttpResponse(req, results);\n\n      HttpApiResponse httpApiResponse = new HttpApiResponse(results,\n          transformBody(httpApiRequest, results),\n          httpApiRequest);\n\n      // Renew the security token if we can\n      if (requestItem.getToken() != null) {\n        String updatedAuthToken = requestItem.getToken().getUpdatedToken();\n        if (updatedAuthToken != null) {\n          httpApiResponse.token = updatedAuthToken;\n        }\n      }\n      return httpApiResponse;\n    } catch (GadgetException ge) {\n      throw new ProtocolException(ge.getHttpStatusCode(),\n          ge.getMessage(), ge);\n    } catch (RewritingException re) {\n      throw new ProtocolException(re.getHttpStatusCode(),\n          re.getMessage(), re);\n    }\n  }\n\n  /**\n   * Extract all unknown keys into a map for extra auth params.\n   */\n  private Map<String, String> getAuthSettings(BaseRequestItem requestItem) {\n    // Keys in a request item are always Strings\n    @SuppressWarnings(\"unchecked\")\n    Set<String> allParameters = requestItem.getTypedRequest(Map.class).keySet();\n    \n    Map<String, String> authSettings = Maps.newHashMap();\n    for (String paramName : allParameters) {\n      if (!HttpApiRequest.KNOWN_PARAMETERS.contains(paramName)) {\n        authSettings.put(paramName, requestItem.getParameter(paramName));\n      }\n    }\n    \n    return authSettings;\n  }\n\n\n  protected Uri normalizeUrl(Uri url) {\n    if (url.getScheme() == null) {\n      // Assume http\n      url = new UriBuilder(url).setScheme(\"http\").toUri();\n    }\n\n    if (url.getPath() == null || url.getPath().length() == 0) {\n      url = new UriBuilder(url).setPath(\"/\").toUri();\n    }\n\n    return url;\n  }\n\n\n  /** Format a response as JSON, including additional JSON inserted by chained content fetchers. */\n  protected Object transformBody(HttpApiRequest request, HttpResponse results)\n      throws GadgetException {\n    String body = results.getResponseAsString();\n    if (\"feed\".equalsIgnoreCase(request.format)) {\n      return processFeed(request, body);\n    } else if (\"json\".equalsIgnoreCase(request.format)) {\n      try {\n        body = body.trim();\n        if(body.length() > 0 && body.charAt(0) == '[') {\n          return new JSONArray(body);\n        } else {\n          return new JSONObject(body);\n        }\n      } catch (JSONException e) {\n        // TODO: include data block with invalid JSON\n        throw new ProtocolException(HttpServletResponse.SC_NOT_ACCEPTABLE, \"Response not valid JSON\", e);\n      }\n    }\n    \n    return body;\n  }\n\n  /** Processes a feed (RSS or Atom) using FeedProcessor. */\n  protected Object processFeed(HttpApiRequest req, String responseBody)\n      throws GadgetException {\n    return feedProcessorProvider.get().process(req.href.toString(), responseBody, req.summarize,\n        req.entryCount);\n  }\n\n  /** Extract the gadget URL from the request or the security token */\n  protected Uri getGadgetUri(SecurityToken token, HttpApiRequest httpApiRequest) {\n    if (token != null && token.getAppUrl() != null) {\n      return Uri.parse(token.getAppUrl());\n    }\n    return null;\n  }\n\n  /**\n   * Simple type that represents an Http request to execute on the callers behalf\n   */\n  public static class HttpApiRequest {\n    static final Set<String> KNOWN_PARAMETERS = ImmutableSet.of(\n        \"href\", \"headers\", \"body\", \"gadget\", \"authz\", \"sign_owner\",\n        \"sign_viewer\", \"format\", \"refreshInterval\", \"noCache\", \"sanitize\",\n        \"summarize\", \"entryCount\");\n\n    // Content to fetch / execute\n    Uri href;\n\n    Map<String, List<String>> headers = Maps.newHashMap();\n\n    /** POST body */\n    String body;\n\n    /** Authorization type (\"none\", \"signed\", \"oauth\") */\n    String authz = \"none\";\n    \n    /** Should the request be signed by owner? */\n    boolean signOwner = true;\n    \n    /** Should the request be signed by viewer? */\n    boolean signViewer = true;\n    \n    // The format type to coerce the response into. Supported values are\n    // \"text\", \"json\", and \"feed\".\n    String format;\n\n    // Use Integer here to allow for null\n    Integer refreshInterval;\n\n    // Bypass http caches\n    boolean noCache;\n\n    // Use HTML/CSS sanitizer\n    boolean sanitize;\n\n    // Control feed handling\n    boolean summarize;\n    int entryCount = 3;\n\n    public Uri getHref() {\n      return href;\n    }\n\n    public void setHref(Uri url) {\n      this.href = url;\n    }\n\n    public Map<String, List<String>> getHeaders() {\n      return headers;\n    }\n\n    public void setHeaders(Map<String, List<String>> headers) {\n      this.headers = headers;\n    }\n\n    public String getBody() {\n      return body;\n    }\n\n    public void setBody(String body) {\n      this.body = body;\n    }\n\n    public Integer getRefreshInterval() {\n      return refreshInterval;\n    }\n\n    public void setRefreshInterval(Integer refreshInterval) {\n      this.refreshInterval = refreshInterval;\n    }\n\n    public boolean isNoCache() {\n      return noCache;\n    }\n\n    public void setNoCache(boolean noCache) {\n      this.noCache = noCache;\n    }\n\n    public boolean isSanitize() {\n      return sanitize;\n    }\n\n    public void setSanitize(boolean sanitize) {\n      this.sanitize = sanitize;\n    }\n\n    public String getFormat() {\n      return format;\n    }\n\n    public void setFormat(String format) {\n      this.format = format;\n    }\n\n    public String getAuthz() {\n      return authz;\n    }\n    \n    public void setAuthz(String authz) {\n      this.authz = authz;\n    }\n\n    public boolean isSignViewer() {\n      return signViewer;\n    }\n    \n    @JsonProperty(\"sign_viewer\")\n    public void setSignViewer(boolean signViewer) {\n      this.signViewer = signViewer;\n    }\n    \n    public boolean isSignOwner() {\n      return signOwner;\n    }\n    \n    @JsonProperty(\"sign_owner\")\n    public void setSignOwner(boolean signOwner) {\n      this.signOwner = signOwner;\n    }\n    \n    public boolean isSummarize() {\n      return summarize;\n    }\n\n    public void setSummarize(boolean summarize) {\n      this.summarize = summarize;\n    }\n\n    public int getEntryCount() {\n      return entryCount;\n    }\n\n    public void setEntryCount(int entryCount) {\n      this.entryCount = entryCount;\n    }\n  }\n\n  /**\n   * Response to request for Http content\n   */\n  public static class HttpApiResponse {\n    // Http status code\n    int status;\n    \n    // Returned headers\n    Map<String, Collection<String>> headers;\n\n    // Body content, either a String or a JSON-type structure\n    Object content;\n\n    // Renewed security token if available\n    String token;\n\n    // Metadata associated with the response.\n    Map<String, String> metadata;\n\n    public HttpApiResponse(int status) {\n      this.status = status;\n    }\n\n    /**\n     * Construct response based on HttpResponse from fetcher\n     */\n    public HttpApiResponse(HttpResponse response, Object content, HttpApiRequest httpApiRequest) {\n      this.status = response.getHttpStatusCode();\n      this.headers = new TreeMap<String, Collection<String>>(String.CASE_INSENSITIVE_ORDER);\n\n      if (response.getHeaders().containsKey(\"set-cookie\")) {\n        this.headers.put(\"set-cookie\", response.getHeaders(\"set-cookie\"));\n      }\n      if (response.getHeaders().containsKey(\"location\")) {\n        this.headers.put(\"location\", response.getHeaders(\"location\"));\n      }\n      \n      this.content = content;\n\n      this.metadata = response.getMetadata();\n    }\n\n    public int getStatus() {\n      return status;\n    }\n\n    public void setStatus(int status) {\n      this.status = status;\n    }\n\n    public Map<String, Collection<String>> getHeaders() {\n      return headers;\n    }\n\n    public void setHeaders(Map<String, Collection<String>> headers) {\n      this.headers = headers;\n    }\n\n    public Object getContent() {\n      return content;\n    }\n\n    public void setContent(Object content) {\n      this.content = content;\n    }\n\n    public String getToken() {\n      return token;\n    }\n\n    public void setToken(String token) {\n      this.token = token;\n    }\n\n    public Map<String, String> getMetadata() {\n      // TODO - Review this once migration of JS occurs. Currently MakeRequestHandler suppresses\n      // this on output but that choice may not be the best one for compatibility.\n      // Suppress metadata on output if it's empty\n      if (metadata != null && metadata.isEmpty()) {\n        return null;\n      }\n      return metadata;\n    }\n\n    public void setMetadata(Map<String, String> metadata) {\n      this.metadata = metadata;\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.servlet;\n\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.JsonProperty;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.common.uri.UriBuilder;\nimport org.apache.shindig.gadgets.AuthType;\nimport org.apache.shindig.gadgets.FeedProcessor;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.http.HttpRequest;\nimport org.apache.shindig.gadgets.http.HttpResponse;\nimport org.apache.shindig.gadgets.http.RequestPipeline;\nimport org.apache.shindig.gadgets.oauth.OAuthArguments;\nimport org.apache.shindig.gadgets.oauth2.OAuth2Arguments;\nimport org.apache.shindig.gadgets.rewrite.ResponseRewriterList.RewriteFlow;\nimport org.apache.shindig.gadgets.rewrite.ResponseRewriterRegistry;\nimport org.apache.shindig.gadgets.rewrite.RewriterRegistry;\nimport org.apache.shindig.gadgets.rewrite.RewritingException;\nimport org.apache.shindig.protocol.BaseRequestItem;\nimport org.apache.shindig.protocol.Operation;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.Service;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Maps;\nimport com.google.inject.Inject;\nimport com.google.inject.Provider;\n\n/**\n * An alternate implementation of the Http proxy service using the standard API dispatcher for REST\n * / JSON-RPC calls. The basic form of the request is as follows\n * ...\n * method : http.<HTTP method name>\n * params : {\n *    href : <endpoint to fetch content from>,\n *    headers : { <header-name> : [<header-value>, ...]},\n *    format : <\"text\", \"json\", \"feed\">\n *    body : <request body>\n *    gadget : <url of gadget spec for calling application>\n *    authz: : <none | oauth | signed>,\n *    sign_owner: <boolean, default true>\n *    sign_viewer: <boolean, default true>\n *    ...<additional auth arguments. See OAuthArguments>\n *    refreshInterval : <Integer time in seconds to force as cache TTL. Default is to use response headers>\n *    noCache : <Bypass container content cache. Default false>\n *    sanitize : <Force sanitize fetched content. Default false>\n *    summarize : <If contentType == \"FEED\" summarize the results. Default false>\n *    entryCount : <If contentType == \"FEED\" limit results to specified no of items. Default 3>\n * }\n *\n * A successful response response will have the form\n *\n * data : {\n *    status : <HTTP status code.>\n *    headers : { <header name> : [<header val1>, <header val2>, ...], ...}\n *    content : <response body>: string if 'text', JSON is 'feed' or 'json' format\n *    token : <If security token provides a renewed value.>\n *    metadata : { <metadata entry> : <metadata value>, ...}\n * }\n *\n * It's important to note that requests which generate HTTP error responses such as 500 are returned\n * in the above format. The RPC itself succeeded in these cases. If an RPC error occurred the client\n * should introspect the error message for information as to the cause.\n *\n * TODO: send errors using \"result\", not plain content\n *\n * @see MakeRequestHandler\n */\n@Service(name = \"http\")\npublic class HttpRequestHandler {\n\n  static final Set<String> BAD_HEADERS = ImmutableSet.of(\"HOST\", \"ACCEPT-ENCODING\");\n\n  private final RequestPipeline requestPipeline;\n  private final ResponseRewriterRegistry contentRewriterRegistry;\n  private final Provider<FeedProcessor> feedProcessorProvider;\n\n  @Inject\n  public HttpRequestHandler(RequestPipeline requestPipeline,\n      @RewriterRegistry(rewriteFlow = RewriteFlow.DEFAULT)\n      ResponseRewriterRegistry contentRewriterRegistry,\n      Provider<FeedProcessor> feedProcessorProvider) {\n    this.requestPipeline = requestPipeline;\n    this.contentRewriterRegistry = contentRewriterRegistry;\n    this.feedProcessorProvider = feedProcessorProvider;\n  }\n\n\n  /** Execute an HTTP GET request */\n  @Operation(httpMethods = {\"POST\",\"GET\"}, path = \"/get\")\n  public HttpApiResponse get(BaseRequestItem request) {\n    HttpApiRequest httpReq = request.getTypedRequest(HttpApiRequest.class);\n    assertNoBody(httpReq, \"GET\");\n    return execute(\"GET\", httpReq, request);\n  }\n\n  /** Execute an HTTP POST request */\n  @Operation(httpMethods = \"POST\", path = \"/post\")\n  public HttpApiResponse post(BaseRequestItem request) {\n    HttpApiRequest httpReq = request.getTypedRequest(HttpApiRequest.class);\n    return execute(\"POST\", httpReq, request);\n  }\n\n  /** Execute an HTTP PUT request */\n  @Operation(httpMethods = \"POST\", path = \"/put\")\n  public HttpApiResponse put(BaseRequestItem request) {\n    HttpApiRequest httpReq = request.getTypedRequest(HttpApiRequest.class);\n    return execute(\"PUT\", httpReq, request);\n  }\n\n  /** Execute an HTTP DELETE request */\n  @Operation(httpMethods = \"POST\", path = \"/delete\")\n  public HttpApiResponse delete(BaseRequestItem request) {\n    HttpApiRequest httpReq = request.getTypedRequest(HttpApiRequest.class);\n    assertNoBody(httpReq, \"DELETE\");\n    return execute(\"DELETE\", httpReq, request);\n  }\n\n  /** Execute an HTTP HEAD request */\n  @Operation(httpMethods = {\"POST\",\"GET\"}, path = \"/head\")\n  public HttpApiResponse head(BaseRequestItem request) {\n    HttpApiRequest httpReq = request.getTypedRequest(HttpApiRequest.class);\n    assertNoBody(httpReq, \"HEAD\");\n    return execute(\"HEAD\", httpReq, request);\n  }\n\n  private void assertNoBody(HttpApiRequest httpRequest, String method) {\n    if (httpRequest.body != null) {\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST,\n         \"Request body not supported for \" + method);\n    }\n  }\n\n  /**\n   * Dispatch the request\n   *\n   * @param method HTTP method to execute\n   * @param requestItem TODO\n   */\n  private HttpApiResponse execute(String method, HttpApiRequest httpApiRequest,\n      BaseRequestItem requestItem) {\n    if (httpApiRequest.href == null) {\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"href parameter is missing\");\n    }\n\n    // Canonicalize the path\n    Uri href = normalizeUrl(httpApiRequest.href);\n    try {\n      HttpRequest req = new HttpRequest(href);\n      req.setMethod(method);\n      if (httpApiRequest.body != null) {\n        req.setPostBody(httpApiRequest.body.getBytes());\n      }\n\n      // Copy over allowed headers\n      for (Map.Entry<String, List<String>> header : httpApiRequest.headers.entrySet()) {\n        if (!BAD_HEADERS.contains(header.getKey().trim().toUpperCase())) {\n          for (String value : header.getValue()) {\n            req.addHeader(header.getKey(), value);\n          }\n        }\n      }\n\n      // Extract the gadget URI from the request or the security token\n      Uri gadgetUri = getGadgetUri(requestItem.getToken(), httpApiRequest);\n      if (gadgetUri == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST,\n            \"Gadget URI not specified in request\");\n      }\n      req.setGadget(gadgetUri);\n\n      // Detect the authz parsing\n      if (httpApiRequest.authz != null) {\n        req.setAuthType(AuthType.parse(httpApiRequest.authz));\n      }\n\n      final AuthType authType = req.getAuthType();\n      if (authType != AuthType.NONE) {\n        if (authType == AuthType.OAUTH2) {\n          req.setSecurityToken(requestItem.getToken());\n\n          Map<String, String> authSettings = getAuthSettings(requestItem);\n          OAuth2Arguments oauth2Args = new OAuth2Arguments(req.getAuthType(), authSettings);\n\n          req.setOAuth2Arguments(oauth2Args);\n        } else {\n          req.setSecurityToken(requestItem.getToken());\n\n          Map<String, String> authSettings = getAuthSettings(requestItem);\n          OAuthArguments oauthArgs = new OAuthArguments(req.getAuthType(), authSettings);\n          oauthArgs.setSignOwner(httpApiRequest.signOwner);\n          oauthArgs.setSignViewer(httpApiRequest.signViewer);\n\n          req.setOAuthArguments(oauthArgs);\n        }\n      }\n\n      // TODO: Allow the rewriter to use an externally forced mime type. This is needed\n      // allows proper rewriting of <script src=\"x\"/> where x is returned with\n      // a content type like text/html which unfortunately happens all too often\n      \n      req.setIgnoreCache(httpApiRequest.noCache);\n      req.setSanitizationRequested(httpApiRequest.sanitize);\n\n      // If the proxy request specifies a refresh param then we want to force the min TTL for\n      // the retrieved entry in the cache regardless of the headers on the content when it\n      // is fetched from the original source.\n      if (httpApiRequest.refreshInterval != null) {\n        req.setCacheTtl(httpApiRequest.refreshInterval);\n      }\n\n      HttpResponse results = requestPipeline.execute(req);\n      // TODO: os:HttpRequest and Preload do not use the content rewriter.\n      // Should we really do so here?\n      results = contentRewriterRegistry.rewriteHttpResponse(req, results);\n\n      HttpApiResponse httpApiResponse = new HttpApiResponse(results,\n          transformBody(httpApiRequest, results),\n          httpApiRequest);\n\n      // Renew the security token if we can\n      if (requestItem.getToken() != null) {\n        String updatedAuthToken = requestItem.getToken().getUpdatedToken();\n        if (updatedAuthToken != null) {\n          httpApiResponse.token = updatedAuthToken;\n        }\n      }\n      return httpApiResponse;\n    } catch (GadgetException ge) {\n      throw new ProtocolException(ge.getHttpStatusCode(), ge.getMessage(), ge);\n    } catch (RewritingException re) {\n      throw new ProtocolException(re.getHttpStatusCode(),\n          re.getMessage(), re);\n    }\n  }\n\n  /**\n   * Extract all unknown keys into a map for extra auth params.\n   */\n  private Map<String, String> getAuthSettings(BaseRequestItem requestItem) {\n    // Keys in a request item are always Strings\n    @SuppressWarnings(\"unchecked\")\n    Set<String> allParameters = requestItem.getTypedRequest(Map.class).keySet();\n    \n    Map<String, String> authSettings = Maps.newHashMap();\n    for (String paramName : allParameters) {\n      if (!HttpApiRequest.KNOWN_PARAMETERS.contains(paramName)) {\n        authSettings.put(paramName, requestItem.getParameter(paramName));\n      }\n    }\n    \n    return authSettings;\n  }\n\n\n  protected Uri normalizeUrl(Uri url) {\n    if (url.getScheme() == null) {\n      // Assume http\n      url = new UriBuilder(url).setScheme(\"http\").toUri();\n    }\n\n    if (url.getPath() == null || url.getPath().length() == 0) {\n      url = new UriBuilder(url).setPath(\"/\").toUri();\n    }\n\n    return url;\n  }\n\n\n  /** Format a response as JSON, including additional JSON inserted by chained content fetchers. */\n  protected Object transformBody(HttpApiRequest request, HttpResponse results)\n      throws GadgetException {\n    String body = results.getResponseAsString();\n    if (\"feed\".equalsIgnoreCase(request.format)) {\n      return processFeed(request, body);\n    } else if (\"json\".equalsIgnoreCase(request.format)) {\n      try {\n        body = body.trim();\n        if(body.length() > 0 && body.charAt(0) == '[') {\n          return new JSONArray(body);\n        } else {\n          return new JSONObject(body);\n        }\n      } catch (JSONException e) {\n        // TODO: include data block with invalid JSON\n        throw new ProtocolException(HttpServletResponse.SC_NOT_ACCEPTABLE, \"Response not valid JSON\", e);\n      }\n    }\n    \n    return body;\n  }\n\n  /** Processes a feed (RSS or Atom) using FeedProcessor. */\n  protected Object processFeed(HttpApiRequest req, String responseBody)\n      throws GadgetException {\n    return feedProcessorProvider.get().process(req.href.toString(), responseBody, req.summarize,\n        req.entryCount);\n  }\n\n  /** Extract the gadget URL from the request or the security token */\n  protected Uri getGadgetUri(SecurityToken token, HttpApiRequest httpApiRequest) {\n    if (token != null && token.getAppUrl() != null) {\n      return Uri.parse(token.getAppUrl());\n    }\n    return null;\n  }\n\n  /**\n   * Simple type that represents an Http request to execute on the callers behalf\n   */\n  public static class HttpApiRequest {\n    static final Set<String> KNOWN_PARAMETERS = ImmutableSet.of(\n        \"href\", \"headers\", \"body\", \"gadget\", \"authz\", \"sign_owner\",\n        \"sign_viewer\", \"format\", \"refreshInterval\", \"noCache\", \"sanitize\",\n        \"summarize\", \"entryCount\");\n\n    // Content to fetch / execute\n    Uri href;\n\n    Map<String, List<String>> headers = Maps.newHashMap();\n\n    /** POST body */\n    String body;\n\n    /** Authorization type (\"none\", \"signed\", \"oauth\") */\n    String authz = \"none\";\n    \n    /** Should the request be signed by owner? */\n    boolean signOwner = true;\n    \n    /** Should the request be signed by viewer? */\n    boolean signViewer = true;\n    \n    // The format type to coerce the response into. Supported values are\n    // \"text\", \"json\", and \"feed\".\n    String format;\n\n    // Use Integer here to allow for null\n    Integer refreshInterval;\n\n    // Bypass http caches\n    boolean noCache;\n\n    // Use HTML/CSS sanitizer\n    boolean sanitize;\n\n    // Control feed handling\n    boolean summarize;\n    int entryCount = 3;\n\n    public Uri getHref() {\n      return href;\n    }\n\n    public void setHref(Uri url) {\n      this.href = url;\n    }\n\n    public Map<String, List<String>> getHeaders() {\n      return headers;\n    }\n\n    public void setHeaders(Map<String, List<String>> headers) {\n      this.headers = headers;\n    }\n\n    public String getBody() {\n      return body;\n    }\n\n    public void setBody(String body) {\n      this.body = body;\n    }\n\n    public Integer getRefreshInterval() {\n      return refreshInterval;\n    }\n\n    public void setRefreshInterval(Integer refreshInterval) {\n      this.refreshInterval = refreshInterval;\n    }\n\n    public boolean isNoCache() {\n      return noCache;\n    }\n\n    public void setNoCache(boolean noCache) {\n      this.noCache = noCache;\n    }\n\n    public boolean isSanitize() {\n      return sanitize;\n    }\n\n    public void setSanitize(boolean sanitize) {\n      this.sanitize = sanitize;\n    }\n\n    public String getFormat() {\n      return format;\n    }\n\n    public void setFormat(String format) {\n      this.format = format;\n    }\n\n    public String getAuthz() {\n      return authz;\n    }\n    \n    public void setAuthz(String authz) {\n      this.authz = authz;\n    }\n\n    public boolean isSignViewer() {\n      return signViewer;\n    }\n    \n    @JsonProperty(\"sign_viewer\")\n    public void setSignViewer(boolean signViewer) {\n      this.signViewer = signViewer;\n    }\n    \n    public boolean isSignOwner() {\n      return signOwner;\n    }\n    \n    @JsonProperty(\"sign_owner\")\n    public void setSignOwner(boolean signOwner) {\n      this.signOwner = signOwner;\n    }\n    \n    public boolean isSummarize() {\n      return summarize;\n    }\n\n    public void setSummarize(boolean summarize) {\n      this.summarize = summarize;\n    }\n\n    public int getEntryCount() {\n      return entryCount;\n    }\n\n    public void setEntryCount(int entryCount) {\n      this.entryCount = entryCount;\n    }\n  }\n\n  /**\n   * Response to request for Http content\n   */\n  public static class HttpApiResponse {\n    // Http status code\n    int status;\n    \n    // Returned headers\n    Map<String, Collection<String>> headers;\n\n    // Body content, either a String or a JSON-type structure\n    Object content;\n\n    // Renewed security token if available\n    String token;\n\n    // Metadata associated with the response.\n    Map<String, String> metadata;\n\n    public HttpApiResponse(int status) {\n      this.status = status;\n    }\n\n    /**\n     * Construct response based on HttpResponse from fetcher\n     */\n    public HttpApiResponse(HttpResponse response, Object content, HttpApiRequest httpApiRequest) {\n      this.status = response.getHttpStatusCode();\n      this.headers = new TreeMap<String, Collection<String>>(String.CASE_INSENSITIVE_ORDER);\n\n      if (response.getHeaders().containsKey(\"set-cookie\")) {\n        this.headers.put(\"set-cookie\", response.getHeaders(\"set-cookie\"));\n      }\n      if (response.getHeaders().containsKey(\"location\")) {\n        this.headers.put(\"location\", response.getHeaders(\"location\"));\n      }\n      \n      this.content = content;\n\n      this.metadata = response.getMetadata();\n    }\n\n    public int getStatus() {\n      return status;\n    }\n\n    public void setStatus(int status) {\n      this.status = status;\n    }\n\n    public Map<String, Collection<String>> getHeaders() {\n      return headers;\n    }\n\n    public void setHeaders(Map<String, Collection<String>> headers) {\n      this.headers = headers;\n    }\n\n    public Object getContent() {\n      return content;\n    }\n\n    public void setContent(Object content) {\n      this.content = content;\n    }\n\n    public String getToken() {\n      return token;\n    }\n\n    public void setToken(String token) {\n      this.token = token;\n    }\n\n    public Map<String, String> getMetadata() {\n      // TODO - Review this once migration of JS occurs. Currently MakeRequestHandler suppresses\n      // this on output but that choice may not be the best one for compatibility.\n      // Suppress metadata on output if it's empty\n      if (metadata != null && metadata.isEmpty()) {\n        return null;\n      }\n      return metadata;\n    }\n\n    public void setMetadata(Map<String, String> metadata) {\n      this.metadata = metadata;\n    }\n  }\n}\n","lineNo":207}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage org.apache.shindig.social.sample.spi;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Future;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.util.ImmediateFuture;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.protocol.DataCollection;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.RestfulCollection;\nimport org.apache.shindig.protocol.conversion.BeanConverter;\nimport org.apache.shindig.protocol.model.SortOrder;\nimport org.apache.shindig.social.opensocial.model.Activity;\nimport org.apache.shindig.social.opensocial.model.ActivityEntry;\nimport org.apache.shindig.social.opensocial.model.Album;\nimport org.apache.shindig.social.opensocial.model.MediaItem;\nimport org.apache.shindig.social.opensocial.model.Message;\nimport org.apache.shindig.social.opensocial.model.MessageCollection;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.spi.ActivityService;\nimport org.apache.shindig.social.opensocial.spi.ActivityStreamService;\nimport org.apache.shindig.social.opensocial.spi.AlbumService;\nimport org.apache.shindig.social.opensocial.spi.AppDataService;\nimport org.apache.shindig.social.opensocial.spi.CollectionOptions;\nimport org.apache.shindig.social.opensocial.spi.GroupId;\nimport org.apache.shindig.social.opensocial.spi.MediaItemService;\nimport org.apache.shindig.social.opensocial.spi.MessageService;\nimport org.apache.shindig.social.opensocial.spi.PersonService;\nimport org.apache.shindig.social.opensocial.spi.UserId;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\n\n/**\n * Implementation of supported services backed by a JSON DB.\n */\n@Singleton\npublic class JsonDbOpensocialService implements ActivityService, PersonService, AppDataService,\n    MessageService, AlbumService, MediaItemService, ActivityStreamService {\n\n  private static final Comparator<Person> NAME_COMPARATOR = new Comparator<Person>() {\n    public int compare(Person person, Person person1) {\n      String name = person.getName().getFormatted();\n      String name1 = person1.getName().getFormatted();\n      return name.compareTo(name1);\n    }\n  };\n\n  /**\n   * The DB\n   */\n  private JSONObject db;\n\n  /**\n   * The JSON<->Bean converter\n   */\n  private BeanConverter converter;\n\n  /**\n   * db[\"activities\"] -> Array<Person>\n   */\n  private static final String PEOPLE_TABLE = \"people\";\n\n  /**\n   * db[\"people\"] -> Map<Person.Id, Array<Activity>>\n   */\n  private static final String ACTIVITIES_TABLE = \"activities\";\n  \n  /**\n   * db[\"people\"] -> Map<Person.Id, Array<Album>>\n   */\n  private static final String ALBUMS_TABLE = \"albums\";\n  \n  /**\n   * db[\"people\"] -> Map<Person.Id, Array<MediaItem>>\n   */\n  private static final String MEDIAITEMS_TABLE = \"mediaItems\";\n\n  /**\n   * db[\"data\"] -> Map<Person.Id, Map<String, String>>\n   */\n  private static final String DATA_TABLE = \"data\";\n\n  /**\n   * db[\"friendLinks\"] -> Map<Person.Id, Array<Person.Id>>\n   */\n  private static final String FRIEND_LINK_TABLE = \"friendLinks\";\n\n  /**\n   * db[\"messages\"] -> Map<Person.Id, Array<Message>>\n   */\n  private static final String MESSAGE_TABLE = \"messages\";\n\n  /**\n   * db[\"passwords\"] -> Map<Person.Id, String>\n   */\n  private static final String PASSWORDS_TABLE = \"passwords\";\n  \n  /**\n   * db[\"people\"] -> Map<Person.Id, Array<ActivityEntry>>\n   */\n  private static final String ACTIVITYSTREAMS_TABLE = \"activityEntries\";\n\n  /**\n   * Initializes the JsonDbOpensocialService using Guice\n   *\n   * @param jsonLocation location of the json data provided by the shindig.canonical.json.db parameter\n   * @param converter an injected BeanConverter\n   * @throws java.lang.Exception if any\n   */\n  @Inject\n  public JsonDbOpensocialService(@Named(\"shindig.canonical.json.db\")\n  String jsonLocation, @Named(\"shindig.bean.converter.json\")\n  BeanConverter converter) throws Exception {\n    String content = IOUtils.toString(ResourceLoader.openResource(jsonLocation), \"UTF-8\");\n    this.db = new JSONObject(content);\n    this.converter = converter;\n  }\n\n  /**\n   * Allows access to the underlying json db.\n   *\n   * @return a reference to the json db\n   */\n  public JSONObject getDb() {\n    return db;\n  }\n\n  /**\n   * override the json database\n   * @param db a {@link org.json.JSONObject}.\n   */\n  public void setDb(JSONObject db) {\n    this.db = db;\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(Set<UserId> userIds, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITIES_TABLE).has(id)) {\n          JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(id);\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (appId == null || !activity.has(Activity.Field.APP_ID.toString())) {\n              result.add(filterFields(activity, fields, Activity.class));\n            } else if (activity.get(Activity.Field.APP_ID.toString()).equals(appId)) {\n              result.add(filterFields(activity, fields, Activity.class));\n            }\n          }\n        }\n      }\n      return ImmediateFuture.newInstance(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, Set<String> activityIds,\n      SecurityToken token) throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n            result.add(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n      return ImmediateFuture.newInstance(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Activity> getActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activity.get(Activity.Field.ID.toString()).equals(activityId)) {\n            return ImmediateFuture.newInstance(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivities(UserId userId, GroupId groupId, String appId,\n      Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        if (activities != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (!activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n              newList.put(activity);\n            }\n          }\n          db.getJSONObject(ACTIVITIES_TABLE).put(user, newList);\n          // TODO. This seems very odd that we return no useful response in this\n          // case\n          // There is no way to represent not-found\n          // if (found) { ??\n          // }\n        }\n      }\n      // What is the appropriate response here??\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> createActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Activity activity, SecurityToken token) throws ProtocolException {\n    // Are fields really needed here?\n    try {\n      JSONObject jsonObject = convertFromActivity(activity, fields);\n      if (!jsonObject.has(Activity.Field.ID.toString())) {\n        jsonObject.put(Activity.Field.ID.toString(), System.currentTimeMillis());\n      }\n      JSONArray jsonArray = db.getJSONObject(ACTIVITIES_TABLE)\n          .getJSONArray(userId.getUserId(token));\n      if (jsonArray == null) {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITIES_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      // TODO (woodser): if used with PUT, duplicate activity would be created?\n      jsonArray.put(jsonObject);\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n  \n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Person>> getPeople(Set<UserId> userIds, GroupId groupId,\n      CollectionOptions options, Set<String> fields, SecurityToken token) throws ProtocolException {\n    List<Person> result = Lists.newArrayList();\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (!idSet.contains(person.get(Person.Field.ID.toString()))) {\n          continue;\n        }\n\n        // Add group support later\n        Person personObj = filterFields(person, fields, Person.class);\n        Map<String, Object> appData = getPersonAppData(\n            person.getString(Person.Field.ID.toString()), fields);\n        personObj.setAppData(appData);\n\n        result.add(personObj);\n      }\n\n      if (GroupId.Type.self == groupId.getType() && result.isEmpty()) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"People '\" + idSet + \"' not found\");\n      }\n\n      // We can pretend that by default the people are in top friends order\n      if (options.getSortBy().equals(Person.Field.NAME.toString())) {\n        Collections.sort(result, NAME_COMPARATOR);\n\n        if (options.getSortOrder() == SortOrder.descending) {\n          Collections.reverse(result);\n        }\n      }\n\n      // TODO: The samplecontainer doesn't really have the concept of HAS_APP so\n      // we can't support any filters yet. We should fix this.\n\n      int totalSize = result.size();\n      int last = options.getFirst() + options.getMax();\n      result = result.subList(options.getFirst(), Math.min(last, totalSize));\n\n      return ImmediateFuture.newInstance(new RestfulCollection<Person>(result, options.getFirst(), totalSize, options.getMax()));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)\n      throws ProtocolException {\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (id != null && person.get(Person.Field.ID.toString()).equals(id.getUserId(token))) {\n          Person personObj = filterFields(person, fields, Person.class);\n          Map<String, Object> appData = getPersonAppData(person.getString(Person.Field.ID\n              .toString()), fields);\n          personObj.setAppData(appData);\n\n          return ImmediateFuture.newInstance(personObj);\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Person '\" + id.getUserId(token) + \"' not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  private Map<String, Object> getPersonAppData(String id, Set<String> fields) {\n    try {\n      Map<String, Object> appData = null;\n      JSONObject personData = db.getJSONObject(DATA_TABLE).optJSONObject(id);\n      if (personData != null) {\n        if (fields.contains(Person.Field.APP_DATA.toString())) {\n          appData = Maps.newHashMap();\n          @SuppressWarnings(\"unchecked\")\n          Iterator<String> keys = personData.keys();\n          while (keys.hasNext()) {\n            String key = keys.next();\n            appData.put(key, personData.get(key));\n          }\n        } else {\n          String appDataPrefix = Person.Field.APP_DATA.toString() + '.';\n          for (String field : fields) {\n            if (field.startsWith(appDataPrefix)) {\n              if (appData == null) {\n                appData = Maps.newHashMap();\n              }\n\n              String appDataField = field.substring(appDataPrefix.length());\n              if (personData.has(appDataField)) {\n                appData.put(appDataField, personData.get(appDataField));\n              }\n            }\n          }\n        }\n      }\n\n      return appData;\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      Map<String, Map<String, String>> idToData = Maps.newHashMap();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        JSONObject personData;\n        if (!db.getJSONObject(DATA_TABLE).has(id)) {\n          personData = new JSONObject();\n        } else {\n          if (!fields.isEmpty()) {\n            personData = new JSONObject(db.getJSONObject(DATA_TABLE).getJSONObject(id), fields\n                .toArray(new String[fields.size()]));\n          } else {\n            personData = db.getJSONObject(DATA_TABLE).getJSONObject(id);\n          }\n        }\n\n        // TODO: We can use the converter here to do this for us\n\n        // JSONObject keys are always strings\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = personData.keys();\n        Map<String, String> data = Maps.newHashMap();\n        while (keys.hasNext()) {\n          String key = keys.next();\n          data.put(key, personData.getString(key));\n        }\n        idToData.put(id, data);\n      }\n      return ImmediateFuture.newInstance(new DataCollection(idToData));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (!db.getJSONObject(DATA_TABLE).has(user)) {\n        return null;\n      }\n      JSONObject newPersonData = new JSONObject();\n      JSONObject oldPersonData = db.getJSONObject(DATA_TABLE).getJSONObject(user);\n\n      // JSONObject keys are always strings\n      @SuppressWarnings(\"unchecked\")\n      Iterator<String> keys = oldPersonData.keys();\n      while (keys.hasNext()) {\n        String key = keys.next();\n        if (!fields.contains(key)) {\n          newPersonData.put(key, oldPersonData.getString(key));\n        }\n      }\n      db.getJSONObject(DATA_TABLE).put(user, newPersonData);\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Map<String, String> values, SecurityToken token)\n      throws ProtocolException {\n    // TODO: this seems redundant. No need to pass both fields and a map of\n    // field->value\n    // TODO: According to rest, yes there is. If a field is in the param list\n    // but not in the map\n    // that means it is a delete\n\n    try {\n      JSONObject personData = db.getJSONObject(DATA_TABLE).getJSONObject(userId.getUserId(token));\n      if (personData == null) {\n        personData = new JSONObject();\n        db.getJSONObject(DATA_TABLE).put(userId.getUserId(token), personData);\n      }\n\n      for (Map.Entry<String, String> entry : values.entrySet()) {\n        personData.put(entry.getKey(), entry.getValue());\n      }\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Post a message for a set of users.\n   */\n  public Future<Void> createMessage(UserId userId, String appId, String msgCollId, Message message,\n      SecurityToken token) throws ProtocolException {\n    for (String recipient : message.getRecipients()) {\n      try {\n        JSONArray outbox = db.getJSONObject(MESSAGE_TABLE).getJSONArray(recipient);\n        if (outbox == null) {\n          outbox = new JSONArray();\n          db.getJSONObject(MESSAGE_TABLE).put(recipient, outbox);\n        }\n\n        outbox.put(message);\n      } catch (JSONException je) {\n        throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n            je);\n      }\n    }\n\n    return ImmediateFuture.newInstance(null);\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MessageCollection>> getMessageCollections(UserId userId,\n      Set<String> fields, CollectionOptions options, SecurityToken token) throws ProtocolException {\n    try {\n      List<MessageCollection> result = Lists.newArrayList();\n      JSONObject messageCollections = db.getJSONObject(MESSAGE_TABLE).getJSONObject(\n          userId.getUserId(token));\n      for (String msgCollId : JSONObject.getNames(messageCollections)) {\n        JSONObject msgColl = messageCollections.getJSONObject(msgCollId);\n        msgColl.put(\"id\", msgCollId);\n        JSONArray messages = msgColl.getJSONArray(\"messages\");\n        int numMessages = (messages == null) ? 0 : messages.length();\n        msgColl.put(\"total\", String.valueOf(numMessages));\n        msgColl.put(\"unread\", String.valueOf(numMessages));\n\n        result.add(filterFields(msgColl, fields, MessageCollection.class));\n      }\n      return ImmediateFuture.newInstance(new RestfulCollection<MessageCollection>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessages(UserId userId, String msgCollId, List<String> ids,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Gets the messsages in an user's queue.\n   */\n  public Future<RestfulCollection<Message>> getMessages(UserId userId, String msgCollId,\n      Set<String> fields, List<String> msgIds, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Message> result = Lists.newArrayList();\n      JSONArray messages = db.getJSONObject(MESSAGE_TABLE).getJSONObject(userId.getUserId(token))\n          .getJSONObject(msgCollId).getJSONArray(\"messages\");\n\n      // TODO: special case @all\n\n      if (messages == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"message collection\"\n            + msgCollId + \" not found\");\n      }\n\n      // TODO: filter and sort outbox.\n      for (int i = 0; i < messages.length(); i++) {\n        JSONObject msg = messages.getJSONObject(i);\n        result.add(filterFields(msg, fields, Message.class));\n      }\n\n      return ImmediateFuture.newInstance(new RestfulCollection<Message>(result));\n\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<MessageCollection> createMessageCollection(UserId userId,\n      MessageCollection msgCollection, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessage(UserId userId, String msgCollId, String messageId,\n      Message message, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessageCollection(UserId userId, MessageCollection msgCollection,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessageCollection(UserId userId, String msgCollId, SecurityToken token)\n      throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * Public methods for use with Authentication Classes\n   *\n   * @param username a {@link java.lang.String} object.\n   * @return a {@link java.lang.String} object.\n   */\n  public String getPassword(String username) {\n    try {\n      return db.getJSONObject(PASSWORDS_TABLE).getString(username);\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n\n  private Set<String> getIdSet(UserId user, GroupId group, SecurityToken token)\n      throws JSONException {\n    String userId = user.getUserId(token);\n\n    if (group == null) {\n      return ImmutableSortedSet.of(userId);\n    }\n\n    Set<String> returnVal = Sets.newLinkedHashSet();\n    switch (group.getType()) {\n    case all:\n    case friends:\n    case groupId:\n      if (db.getJSONObject(FRIEND_LINK_TABLE).has(userId)) {\n        JSONArray friends = db.getJSONObject(FRIEND_LINK_TABLE).getJSONArray(userId);\n        for (int i = 0; i < friends.length(); i++) {\n          returnVal.add(friends.getString(i));\n        }\n      }\n      break;\n    case self:\n      returnVal.add(userId);\n      break;\n    }\n    return returnVal;\n  }\n\n  /**\n   * Get the set of user id's for a set of users and a group\n   *\n   * @param users set of UserIds\n   * @param group the group\n   * @param token a token\n   * @return set of Id strings\n   * @throws org.json.JSONException if errors in Json\n   */\n  public Set<String> getIdSet(Set<UserId> users, GroupId group, SecurityToken token)\n      throws JSONException {\n    Set<String> ids = Sets.newLinkedHashSet();\n    for (UserId user : users) {\n      ids.addAll(getIdSet(user, group, token));\n    }\n    return ids;\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Album> getAlbum(UserId userId, String appId, Set<String> fields,\n                                String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Search albums for given ID and owner\n        JSONObject album;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          album = userAlbums.getJSONObject(i);\n          if (album.getString(Album.Field.ID.toString()).equals(albumId) &&\n              album.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n            return ImmediateFuture.newInstance(filterFields(album, fields, Album.class));\n          }\n        }\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(UserId userId, String appId,\n                                                    Set<String> fields, CollectionOptions options, Set<String> albumIds,\n                                                    SecurityToken token) throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Stores target albums\n        List<Album> result = Lists.newArrayList();\n\n        // Search for every albumId\n        boolean found;\n        JSONObject curAlbum;\n        for (String albumId : albumIds) {\n          // Search albums for this albumId\n          found = false;\n          for (int i = 0; i < userAlbums.length(); i++) {\n            curAlbum = userAlbums.getJSONObject(i);\n            if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId) &&\n                curAlbum.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n              result.add(filterFields(curAlbum, fields, Album.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - albumId not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n          }\n        }\n\n        // Return found albums\n        return ImmediateFuture.newInstance(new RestfulCollection<Album>(result));\n      }\n\n      // Album table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User '\" + user + \"' has no albums\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(Set<UserId> userIds,\n                                                    GroupId groupId, String appId, Set<String> fields,\n                                                    CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Album> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather albums for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(ALBUMS_TABLE).has(id)) {\n          JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userAlbums.length(); i++) {\n            JSONObject album = userAlbums.getJSONObject(i);\n            if (album.getString(Album.Field.OWNER_ID.toString()).equals(id)) {\n              result.add(filterFields(album, fields, Album.class));\n            }\n          }\n        }\n      }\n      return ImmediateFuture.newInstance(new RestfulCollection<Album>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteAlbum(UserId userId, String appId, String albumId,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      boolean targetFound = false;      // indicates if target album is found\n      JSONArray newAlbums = new JSONArray();  // list of albums minus target\n      String user = userId.getUserId(token);  // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Compose new list of albums excluding album to be deleted\n        JSONObject curAlbum;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newAlbums.put(curAlbum);\n          }\n        }\n      }\n\n      // Overwrite user's albums with updated list if album found\n      if (targetFound) {\n        db.getJSONObject(ALBUMS_TABLE).put(user, newAlbums);\n        return ImmediateFuture.newInstance(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: userId and album's ownerId don't have to match - potential problem\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createAlbum(UserId userId, String appId, Album album,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      // Get table of user's albums\n      String user = userId.getUserId(token);\n      JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n      if (userAlbums == null) {\n        userAlbums = new JSONArray();\n        db.getJSONObject(ALBUMS_TABLE).put(user, userAlbums);\n      }\n\n      // Convert album to JSON and set ID & owner\n      JSONObject jsonAlbum = convertToJson(album);\n      if (!jsonAlbum.has(Album.Field.ID.toString())) {\n        jsonAlbum.put(Album.Field.ID.toString(), System.currentTimeMillis());\n      }\n      if (!jsonAlbum.has(Album.Field.OWNER_ID.toString())) {\n        jsonAlbum.put(Album.Field.OWNER_ID.toString(), user);\n      }\n\n      // Insert new album into table\n      userAlbums.put(jsonAlbum);\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateAlbum(UserId userId, String appId, Album album,\n                                  String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Convert album to JSON and set ID\n        JSONObject jsonAlbum = convertToJson(album);\n        jsonAlbum.put(Album.Field.ID.toString(), albumId);\n\n        // Iterate through albums to identify album to update\n        JSONObject curAlbum = null;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            userAlbums.put(i, jsonAlbum);\n            return ImmediateFuture.newInstance(null);\n          }\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<MediaItem> getMediaItem(UserId userId, String appId,\n                                        String albumId, String mediaItemId, Set<String> fields,\n                                        SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Search user's MediaItems for given ID and album\n        JSONObject mediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          mediaItem = userMediaItems.getJSONObject(i);\n          if (mediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              mediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            return ImmediateFuture.newInstance(filterFields(mediaItem, fields, MediaItem.class));\n          }\n        }\n      }\n\n      // MediaItem wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID '\" + mediaItemId + \"' does not exist within Album '\" + albumId + \"'\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> mediaItemIds,\n                                                            Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores found MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search for every MediaItem ID target\n        boolean found;\n        JSONObject curMediaItem;\n        for (String mediaItemId : mediaItemIds) {\n          // Search existing MediaItems for this MediaItem ID\n          found = false;\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            curMediaItem = userMediaItems.getJSONObject(i);\n            if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(albumId) &&\n                curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n              result.add(filterFields(curMediaItem, fields, MediaItem.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - MediaItem ID not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist within Album \" + albumId);\n          }\n        }\n\n        // Return found MediaItems\n        return ImmediateFuture.newInstance(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem table not found for user \" + user);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> fields,\n                                                            CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores target MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search user's MediaItems for given album\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            result.add(filterFields(curMediaItem, fields, MediaItem.class));\n          }\n        }\n\n        // Return found MediaItems\n        return ImmediateFuture.newInstance(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(\n      Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<MediaItem> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather MediaItems for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(MEDIAITEMS_TABLE).has(id)) {\n          JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            result.add(filterFields(userMediaItems.getJSONObject(i), fields, MediaItem.class));\n          }\n        }\n      }\n      return ImmediateFuture.newInstance(new RestfulCollection<MediaItem>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      boolean targetFound = false;        // indicates if target MediaItem is found\n      JSONArray newMediaItems = new JSONArray();  // list of MediaItems minus target\n      String user = userId.getUserId(token);    // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Compose new list of MediaItems excluding item to be deleted\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newMediaItems.put(curMediaItem);\n          }\n        }\n      }\n\n      // Overwrite user's MediaItems with updated list if target found\n      if (targetFound) {\n        db.getJSONObject(MEDIAITEMS_TABLE).put(user, newMediaItems);\n        return ImmediateFuture.newInstance(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createMediaItem(UserId userId, String appId,\n                                      String albumId, MediaItem mediaItem, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Get table of user's MediaItems\n      JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(userId.getUserId(token));\n      if (userMediaItems == null) {\n        userMediaItems = new JSONArray();\n        db.getJSONObject(MEDIAITEMS_TABLE).put(userId.getUserId(token), userMediaItems);\n      }\n\n      // Convert MediaItem to JSON and set ID & Album ID\n      JSONObject jsonMediaItem = convertToJson(mediaItem);\n      jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n      if (!jsonMediaItem.has(MediaItem.Field.ID.toString())) {\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), System.currentTimeMillis());\n      }\n\n      // Insert new MediaItem into table\n      userMediaItems.put(jsonMediaItem);\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, MediaItem mediaItem,\n                                      SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Convert MediaItem to JSON and set ID & Album ID\n        JSONObject jsonMediaItem = convertToJson(mediaItem);\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), mediaItemId);\n        jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n\n        // Iterate through MediaItems to identify item to update\n        JSONObject curMediaItem = null;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            userMediaItems.put(i, jsonMediaItem);\n            return ImmediateFuture.newInstance(null);\n          }\n        }\n      }\n\n      // Error - no MediaItem found with given ID and Album ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n  \n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> updateActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        if (activityId != null) {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), activityId);\n        } else {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n        }\n      }\n      activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      \n      // Find & replace activity\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          jsonArray.put(i, jsonEntry);\n          return ImmediateFuture.newInstance(filterFields(jsonEntry, fields, ActivityEntry.class));\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n  \n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> createActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n      }\n      String activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      \n      // Ensure activity does not already exist\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity already exists: \" + activityId);\n        }\n      }\n      jsonArray.put(jsonEntry);\n      return ImmediateFuture.newInstance(filterFields(jsonEntry, fields, ActivityEntry.class));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivityEntries(UserId userId, GroupId groupId,\n      String appId, Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n\n        if (activityEntries != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (!activityIds.contains(activityEntry.getString(ActivityEntry.Field.ID.toString()))) {\n              newList.put(activityEntry);\n            }\n          }\n          db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(user, newList);\n        }\n      }\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> getActivityEntry(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, String activityId, SecurityToken token)\n      throws ProtocolException {\n    try {       \n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for (int i = 0; i < activityEntries.length(); i++) {\n          JSONObject activityEntry = activityEntries.getJSONObject(i);\n          if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n            return ImmediateFuture.newInstance(filterFields(activityEntry, fields, ActivityEntry.class));\n          }\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n  \n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      Set<UserId> userIds, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n      List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(id)) {\n          JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n            // TODO: ActivityStreams don't have appIds\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return ImmediateFuture.newInstance(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n  \n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      UserId userId, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, Set<String> activityIds, SecurityToken token)\n      throws ProtocolException {\n    List<ActivityEntry> result = Lists.newArrayList();    \n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for(String activityId : activityIds) {\n          boolean found = false;\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n              result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND, \"Activity not found: \" + activityId);\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return ImmediateFuture.newInstance(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // TODO Why specifically handle Activity instead of generic POJO (below)?\n\n  private JSONObject convertFromActivity(Activity activity, Set<String> fields)\n      throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activity));\n  }\n  \n  private JSONObject convertFromActivityEntry(ActivityEntry activityEntry, Set<String> fields) throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activityEntry));\n  }\n\n  private JSONObject convertToJson(Object object) throws JSONException {\n    // TODO not using fields yet\n    return new JSONObject(converter.convertToString(object));\n  }\n\n  public <T> T filterFields(JSONObject object, Set<String> fields,\n                            Class<T> clz) throws JSONException {\n    if (!fields.isEmpty()) {\n      // Create a copy with just the specified fields\n      object = new JSONObject(object, fields.toArray(new String[fields\n          .size()]));\n    }\n    return converter.convertToObject(object.toString(), clz);\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage org.apache.shindig.social.sample.spi;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Future;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shindig.auth.SecurityToken;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.common.util.ImmediateFuture;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.protocol.DataCollection;\nimport org.apache.shindig.protocol.ProtocolException;\nimport org.apache.shindig.protocol.RestfulCollection;\nimport org.apache.shindig.protocol.conversion.BeanConverter;\nimport org.apache.shindig.protocol.model.SortOrder;\nimport org.apache.shindig.social.opensocial.model.Activity;\nimport org.apache.shindig.social.opensocial.model.ActivityEntry;\nimport org.apache.shindig.social.opensocial.model.Album;\nimport org.apache.shindig.social.opensocial.model.MediaItem;\nimport org.apache.shindig.social.opensocial.model.Message;\nimport org.apache.shindig.social.opensocial.model.MessageCollection;\nimport org.apache.shindig.social.opensocial.model.Person;\nimport org.apache.shindig.social.opensocial.spi.ActivityService;\nimport org.apache.shindig.social.opensocial.spi.ActivityStreamService;\nimport org.apache.shindig.social.opensocial.spi.AlbumService;\nimport org.apache.shindig.social.opensocial.spi.AppDataService;\nimport org.apache.shindig.social.opensocial.spi.CollectionOptions;\nimport org.apache.shindig.social.opensocial.spi.GroupId;\nimport org.apache.shindig.social.opensocial.spi.MediaItemService;\nimport org.apache.shindig.social.opensocial.spi.MessageService;\nimport org.apache.shindig.social.opensocial.spi.PersonService;\nimport org.apache.shindig.social.opensocial.spi.UserId;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.inject.Inject;\nimport com.google.inject.Provider;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\n\n/**\n * Implementation of supported services backed by a JSON DB.\n */\n@Singleton\npublic class JsonDbOpensocialService implements ActivityService, PersonService, AppDataService,\n    MessageService, AlbumService, MediaItemService, ActivityStreamService {\n\n  private static final Comparator<Person> NAME_COMPARATOR = new Comparator<Person>() {\n    public int compare(Person person, Person person1) {\n      String name = person.getName().getFormatted();\n      String name1 = person1.getName().getFormatted();\n      return name.compareTo(name1);\n    }\n  };\n\n  /**\n   * The DB\n   */\n  private JSONObject db;\n\n  /**\n   * The JSON<->Bean converter\n   */\n  private BeanConverter converter;\n\n  /**\n   * db[\"people\"] -> Array<Person>\n   */\n  private static final String PEOPLE_TABLE = \"people\";\n\n  /**\n   * db[\"activities\"] -> Map<Person.Id, Array<Activity>>\n   */\n  private static final String ACTIVITIES_TABLE = \"activities\";\n\n  /**\n   * db[\"albums\"] -> Map<Person.Id, Array<Album>>\n   */\n  private static final String ALBUMS_TABLE = \"albums\";\n\n  /**\n   * db[\"mediaItems\"] -> Map<Person.Id, Array<MediaItem>>\n   */\n  private static final String MEDIAITEMS_TABLE = \"mediaItems\";\n\n  /**\n   * db[\"data\"] -> Map<Person.Id, Map<String, String>>\n   */\n  private static final String DATA_TABLE = \"data\";\n\n  /**\n   * db[\"friendLinks\"] -> Map<Person.Id, Array<Person.Id>>\n   */\n  private static final String FRIEND_LINK_TABLE = \"friendLinks\";\n\n  /**\n   * db[\"messages\"] -> Map<Person.Id, Array<Message>>\n   */\n  private static final String MESSAGE_TABLE = \"messages\";\n\n  /**\n   * db[\"passwords\"] -> Map<Person.Id, String>\n   */\n  private static final String PASSWORDS_TABLE = \"passwords\";\n\n  /**\n   * db[\"activityEntries\"] -> Map<Person.Id, Array<ActivityEntry>>\n   */\n  private static final String ACTIVITYSTREAMS_TABLE = \"activityEntries\";\n\n  private Provider<Authority> hostProvider;\n\n  /**\n   * Initializes the JsonDbOpensocialService using Guice\n   *\n   * @param jsonLocation location of the json data provided by the shindig.canonical.json.db parameter\n   * @param converter an injected BeanConverter\n   * @throws java.lang.Exception if any\n   */\n  @Inject\n  public JsonDbOpensocialService(@Named(\"shindig.canonical.json.db\")\n  String jsonLocation, @Named(\"shindig.bean.converter.json\")\n  BeanConverter converter,\n  @Named(\"shindig.contextroot\") String contextroot) throws Exception {\n    String content = IOUtils.toString(ResourceLoader.openResource(jsonLocation), \"UTF-8\");    \n    this.db = new JSONObject(content.replace(\"%contextroot%\", contextroot));\n    this.converter = converter;\n  }\n\n  /**\n   * Allows access to the underlying json db.\n   *\n   * @return a reference to the json db\n   */\n  public JSONObject getDb() {\n    return db;\n  }\n\n   /**\n   * override the json database\n   * @param db a {@link org.json.JSONObject}.\n   */\n  public void setDb(JSONObject db) {\n    this.db = db;\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(Set<UserId> userIds, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITIES_TABLE).has(id)) {\n          JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(id);\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (appId == null || !activity.has(Activity.Field.APP_ID.toString())) {\n              result.add(filterFields(activity, fields, Activity.class));\n            } else if (activity.get(Activity.Field.APP_ID.toString()).equals(appId)) {\n              result.add(filterFields(activity, fields, Activity.class));\n            }\n          }\n        }\n      }\n      return ImmediateFuture.newInstance(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Activity>> getActivities(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, CollectionOptions options, Set<String> activityIds,\n      SecurityToken token) throws ProtocolException {\n    List<Activity> result = Lists.newArrayList();\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n            result.add(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n      return ImmediateFuture.newInstance(new RestfulCollection<Activity>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Activity> getActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        for (int i = 0; i < activities.length(); i++) {\n          JSONObject activity = activities.getJSONObject(i);\n          if (activity.get(Activity.Field.USER_ID.toString()).equals(user)\n              && activity.get(Activity.Field.ID.toString()).equals(activityId)) {\n            return ImmediateFuture.newInstance(filterFields(activity, fields, Activity.class));\n          }\n        }\n      }\n\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivities(UserId userId, GroupId groupId, String appId,\n      Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITIES_TABLE).has(user)) {\n        JSONArray activities = db.getJSONObject(ACTIVITIES_TABLE).getJSONArray(user);\n        if (activities != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activities.length(); i++) {\n            JSONObject activity = activities.getJSONObject(i);\n            if (!activityIds.contains(activity.getString(Activity.Field.ID.toString()))) {\n              newList.put(activity);\n            }\n          }\n          db.getJSONObject(ACTIVITIES_TABLE).put(user, newList);\n          // TODO. This seems very odd that we return no useful response in this\n          // case\n          // There is no way to represent not-found\n          // if (found) { ??\n          // }\n        }\n      }\n      // What is the appropriate response here??\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> createActivity(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Activity activity, SecurityToken token) throws ProtocolException {\n    // Are fields really needed here?\n    try {\n      JSONObject jsonObject = convertFromActivity(activity, fields);\n      if (!jsonObject.has(Activity.Field.ID.toString())) {\n        jsonObject.put(Activity.Field.ID.toString(), System.currentTimeMillis());\n      }\n      JSONArray jsonArray = db.getJSONObject(ACTIVITIES_TABLE)\n          .getJSONArray(userId.getUserId(token));\n      if (jsonArray == null) {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITIES_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      // TODO (woodser): if used with PUT, duplicate activity would be created?\n      jsonArray.put(jsonObject);\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n  \n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Person>> getPeople(Set<UserId> userIds, GroupId groupId,\n      CollectionOptions options, Set<String> fields, SecurityToken token) throws ProtocolException {\n    List<Person> result = Lists.newArrayList();\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (!idSet.contains(person.get(Person.Field.ID.toString()))) {\n          continue;\n        }\n\n        // Add group support later\n        Person personObj = filterFields(person, fields, Person.class);\n        Map<String, Object> appData = getPersonAppData(\n            person.getString(Person.Field.ID.toString()), fields);\n        personObj.setAppData(appData);\n\n        result.add(personObj);\n      }\n\n      if (GroupId.Type.self == groupId.getType() && result.isEmpty()) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"People '\" + idSet + \"' not found\");\n      }\n\n      // We can pretend that by default the people are in top friends order\n      if (options.getSortBy().equals(Person.Field.NAME.toString())) {\n        Collections.sort(result, NAME_COMPARATOR);\n\n        if (options.getSortOrder() == SortOrder.descending) {\n          Collections.reverse(result);\n        }\n      }\n\n      // TODO: The samplecontainer doesn't really have the concept of HAS_APP so\n      // we can't support any filters yet. We should fix this.\n\n      int totalSize = result.size();\n      int last = options.getFirst() + options.getMax();\n      result = result.subList(options.getFirst(), Math.min(last, totalSize));\n\n      return ImmediateFuture.newInstance(new RestfulCollection<Person>(result, options.getFirst(), totalSize, options.getMax()));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Person> getPerson(UserId id, Set<String> fields, SecurityToken token)\n      throws ProtocolException {\n    try {\n      JSONArray people = db.getJSONArray(PEOPLE_TABLE);\n\n      for (int i = 0; i < people.length(); i++) {\n        JSONObject person = people.getJSONObject(i);\n        if (id != null && person.get(Person.Field.ID.toString()).equals(id.getUserId(token))) {\n          Person personObj = filterFields(person, fields, Person.class);\n          Map<String, Object> appData = getPersonAppData(person.getString(Person.Field.ID\n              .toString()), fields);\n          personObj.setAppData(appData);\n\n          return ImmediateFuture.newInstance(personObj);\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Person '\" + id.getUserId(token) + \"' not found\");\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  private Map<String, Object> getPersonAppData(String id, Set<String> fields) {\n    try {\n      Map<String, Object> appData = null;\n      JSONObject personData = db.getJSONObject(DATA_TABLE).optJSONObject(id);\n      if (personData != null) {\n        if (fields.contains(Person.Field.APP_DATA.toString())) {\n          appData = Maps.newHashMap();\n          @SuppressWarnings(\"unchecked\")\n          Iterator<String> keys = personData.keys();\n          while (keys.hasNext()) {\n            String key = keys.next();\n            appData.put(key, personData.get(key));\n          }\n        } else {\n          String appDataPrefix = Person.Field.APP_DATA.toString() + '.';\n          for (String field : fields) {\n            if (field.startsWith(appDataPrefix)) {\n              if (appData == null) {\n                appData = Maps.newHashMap();\n              }\n\n              String appDataField = field.substring(appDataPrefix.length());\n              if (personData.has(appDataField)) {\n                appData.put(appDataField, personData.get(appDataField));\n              }\n            }\n          }\n        }\n      }\n\n      return appData;\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      Map<String, Map<String, String>> idToData = Maps.newHashMap();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        JSONObject personData;\n        if (!db.getJSONObject(DATA_TABLE).has(id)) {\n          personData = new JSONObject();\n        } else {\n          if (!fields.isEmpty()) {\n            personData = new JSONObject(db.getJSONObject(DATA_TABLE).getJSONObject(id), fields\n                .toArray(new String[fields.size()]));\n          } else {\n            personData = db.getJSONObject(DATA_TABLE).getJSONObject(id);\n          }\n        }\n\n        // TODO: We can use the converter here to do this for us\n\n        // JSONObject keys are always strings\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = personData.keys();\n        Map<String, String> data = Maps.newHashMap();\n        while (keys.hasNext()) {\n          String key = keys.next();\n          data.put(key, personData.getString(key));\n        }\n        idToData.put(id, data);\n      }\n      return ImmediateFuture.newInstance(new DataCollection(idToData));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n      if (!db.getJSONObject(DATA_TABLE).has(user)) {\n        return null;\n      }\n      JSONObject newPersonData = new JSONObject();\n      JSONObject oldPersonData = db.getJSONObject(DATA_TABLE).getJSONObject(user);\n\n      // JSONObject keys are always strings\n      @SuppressWarnings(\"unchecked\")\n      Iterator<String> keys = oldPersonData.keys();\n      while (keys.hasNext()) {\n        String key = keys.next();\n        if (!fields.contains(key)) {\n          newPersonData.put(key, oldPersonData.getString(key));\n        }\n      }\n      db.getJSONObject(DATA_TABLE).put(user, newPersonData);\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,\n      Set<String> fields, Map<String, String> values, SecurityToken token)\n      throws ProtocolException {\n    // TODO: this seems redundant. No need to pass both fields and a map of\n    // field->value\n    // TODO: According to rest, yes there is. If a field is in the param list\n    // but not in the map\n    // that means it is a delete\n\n    try {\n      JSONObject personData = db.getJSONObject(DATA_TABLE).getJSONObject(userId.getUserId(token));\n      if (personData == null) {\n        personData = new JSONObject();\n        db.getJSONObject(DATA_TABLE).put(userId.getUserId(token), personData);\n      }\n\n      for (Map.Entry<String, String> entry : values.entrySet()) {\n        personData.put(entry.getKey(), entry.getValue());\n      }\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Post a message for a set of users.\n   */\n  public Future<Void> createMessage(UserId userId, String appId, String msgCollId, Message message,\n      SecurityToken token) throws ProtocolException {\n    for (String recipient : message.getRecipients()) {\n      try {\n        JSONArray outbox = db.getJSONObject(MESSAGE_TABLE).getJSONArray(recipient);\n        if (outbox == null) {\n          outbox = new JSONArray();\n          db.getJSONObject(MESSAGE_TABLE).put(recipient, outbox);\n        }\n\n        outbox.put(message);\n      } catch (JSONException je) {\n        throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n            je);\n      }\n    }\n\n    return ImmediateFuture.newInstance(null);\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MessageCollection>> getMessageCollections(UserId userId,\n      Set<String> fields, CollectionOptions options, SecurityToken token) throws ProtocolException {\n    try {\n      List<MessageCollection> result = Lists.newArrayList();\n      JSONObject messageCollections = db.getJSONObject(MESSAGE_TABLE).getJSONObject(\n          userId.getUserId(token));\n      for (String msgCollId : JSONObject.getNames(messageCollections)) {\n        JSONObject msgColl = messageCollections.getJSONObject(msgCollId);\n        msgColl.put(\"id\", msgCollId);\n        JSONArray messages = msgColl.getJSONArray(\"messages\");\n        int numMessages = (messages == null) ? 0 : messages.length();\n        msgColl.put(\"total\", String.valueOf(numMessages));\n        msgColl.put(\"unread\", String.valueOf(numMessages));\n\n        result.add(filterFields(msgColl, fields, MessageCollection.class));\n      }\n      return ImmediateFuture.newInstance(new RestfulCollection<MessageCollection>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessages(UserId userId, String msgCollId, List<String> ids,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * Gets the messsages in an user's queue.\n   */\n  public Future<RestfulCollection<Message>> getMessages(UserId userId, String msgCollId,\n      Set<String> fields, List<String> msgIds, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Message> result = Lists.newArrayList();\n      JSONArray messages = db.getJSONObject(MESSAGE_TABLE).getJSONObject(userId.getUserId(token))\n          .getJSONObject(msgCollId).getJSONArray(\"messages\");\n\n      // TODO: special case @all\n\n      if (messages == null) {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"message collection\"\n            + msgCollId + \" not found\");\n      }\n\n      // TODO: filter and sort outbox.\n      for (int i = 0; i < messages.length(); i++) {\n        JSONObject msg = messages.getJSONObject(i);\n        result.add(filterFields(msg, fields, Message.class));\n      }\n\n      return ImmediateFuture.newInstance(new RestfulCollection<Message>(result));\n\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(),\n          je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<MessageCollection> createMessageCollection(UserId userId,\n      MessageCollection msgCollection, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessage(UserId userId, String msgCollId, String messageId,\n      Message message, SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> modifyMessageCollection(UserId userId, MessageCollection msgCollection,\n      SecurityToken token) throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMessageCollection(UserId userId, String msgCollId, SecurityToken token)\n      throws ProtocolException {\n    throw new ProtocolException(HttpServletResponse.SC_NOT_IMPLEMENTED,\n        \"this functionality is not yet available\");\n  }\n\n  /**\n   * Public methods for use with Authentication Classes\n   *\n   * @param username a {@link java.lang.String} object.\n   * @return a {@link java.lang.String} object.\n   */\n  public String getPassword(String username) {\n    try {\n      return db.getJSONObject(PASSWORDS_TABLE).getString(username);\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n\n  private Set<String> getIdSet(UserId user, GroupId group, SecurityToken token)\n      throws JSONException {\n    String userId = user.getUserId(token);\n\n    if (group == null) {\n      return ImmutableSortedSet.of(userId);\n    }\n\n    Set<String> returnVal = Sets.newLinkedHashSet();\n    switch (group.getType()) {\n    case all:\n    case friends:\n    case groupId:\n      if (db.getJSONObject(FRIEND_LINK_TABLE).has(userId)) {\n        JSONArray friends = db.getJSONObject(FRIEND_LINK_TABLE).getJSONArray(userId);\n        for (int i = 0; i < friends.length(); i++) {\n          returnVal.add(friends.getString(i));\n        }\n      }\n      break;\n    case self:\n      returnVal.add(userId);\n      break;\n    }\n    return returnVal;\n  }\n\n  /**\n   * Get the set of user id's for a set of users and a group\n   *\n   * @param users set of UserIds\n   * @param group the group\n   * @param token a token\n   * @return set of Id strings\n   * @throws org.json.JSONException if errors in Json\n   */\n  public Set<String> getIdSet(Set<UserId> users, GroupId group, SecurityToken token)\n      throws JSONException {\n    Set<String> ids = Sets.newLinkedHashSet();\n    for (UserId user : users) {\n      ids.addAll(getIdSet(user, group, token));\n    }\n    return ids;\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Album> getAlbum(UserId userId, String appId, Set<String> fields,\n                                String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Search albums for given ID and owner\n        JSONObject album;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          album = userAlbums.getJSONObject(i);\n          if (album.getString(Album.Field.ID.toString()).equals(albumId) &&\n              album.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n            return ImmediateFuture.newInstance(filterFields(album, fields, Album.class));\n          }\n        }\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(UserId userId, String appId,\n                                                    Set<String> fields, CollectionOptions options, Set<String> albumIds,\n                                                    SecurityToken token) throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Stores target albums\n        List<Album> result = Lists.newArrayList();\n\n        // Search for every albumId\n        boolean found;\n        JSONObject curAlbum;\n        for (String albumId : albumIds) {\n          // Search albums for this albumId\n          found = false;\n          for (int i = 0; i < userAlbums.length(); i++) {\n            curAlbum = userAlbums.getJSONObject(i);\n            if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId) &&\n                curAlbum.getString(Album.Field.OWNER_ID.toString()).equals(user)) {\n              result.add(filterFields(curAlbum, fields, Album.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - albumId not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n          }\n        }\n\n        // Return found albums\n        return ImmediateFuture.newInstance(new RestfulCollection<Album>(result));\n      }\n\n      // Album table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"User '\" + user + \"' has no albums\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<Album>> getAlbums(Set<UserId> userIds,\n                                                    GroupId groupId, String appId, Set<String> fields,\n                                                    CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<Album> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather albums for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(ALBUMS_TABLE).has(id)) {\n          JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userAlbums.length(); i++) {\n            JSONObject album = userAlbums.getJSONObject(i);\n            if (album.getString(Album.Field.OWNER_ID.toString()).equals(id)) {\n              result.add(filterFields(album, fields, Album.class));\n            }\n          }\n        }\n      }\n      return ImmediateFuture.newInstance(new RestfulCollection<Album>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteAlbum(UserId userId, String appId, String albumId,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      boolean targetFound = false;      // indicates if target album is found\n      JSONArray newAlbums = new JSONArray();  // list of albums minus target\n      String user = userId.getUserId(token);  // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Get user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Compose new list of albums excluding album to be deleted\n        JSONObject curAlbum;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newAlbums.put(curAlbum);\n          }\n        }\n      }\n\n      // Overwrite user's albums with updated list if album found\n      if (targetFound) {\n        db.getJSONObject(ALBUMS_TABLE).put(user, newAlbums);\n        return ImmediateFuture.newInstance(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: userId and album's ownerId don't have to match - potential problem\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createAlbum(UserId userId, String appId, Album album,\n                                  SecurityToken token) throws ProtocolException {\n    try {\n      // Get table of user's albums\n      String user = userId.getUserId(token);\n      JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n      if (userAlbums == null) {\n        userAlbums = new JSONArray();\n        db.getJSONObject(ALBUMS_TABLE).put(user, userAlbums);\n      }\n\n      // Convert album to JSON and set ID & owner\n      JSONObject jsonAlbum = convertToJson(album);\n      if (!jsonAlbum.has(Album.Field.ID.toString())) {\n        jsonAlbum.put(Album.Field.ID.toString(), System.currentTimeMillis());\n      }\n      if (!jsonAlbum.has(Album.Field.OWNER_ID.toString())) {\n        jsonAlbum.put(Album.Field.OWNER_ID.toString(), user);\n      }\n\n      // Insert new album into table\n      userAlbums.put(jsonAlbum);\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateAlbum(UserId userId, String appId, Album album,\n                                  String albumId, SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ALBUMS_TABLE).has(user)) {\n        // Retrieve user's albums\n        JSONArray userAlbums = db.getJSONObject(ALBUMS_TABLE).getJSONArray(user);\n\n        // Convert album to JSON and set ID\n        JSONObject jsonAlbum = convertToJson(album);\n        jsonAlbum.put(Album.Field.ID.toString(), albumId);\n\n        // Iterate through albums to identify album to update\n        JSONObject curAlbum = null;\n        for (int i = 0; i < userAlbums.length(); i++) {\n          curAlbum = userAlbums.getJSONObject(i);\n          if (curAlbum.getString(Album.Field.ID.toString()).equals(albumId)) {\n            userAlbums.put(i, jsonAlbum);\n            return ImmediateFuture.newInstance(null);\n          }\n        }\n      }\n\n      // Error - no album found to update with given ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<MediaItem> getMediaItem(UserId userId, String appId,\n                                        String albumId, String mediaItemId, Set<String> fields,\n                                        SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Search user's MediaItems for given ID and album\n        JSONObject mediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          mediaItem = userMediaItems.getJSONObject(i);\n          if (mediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              mediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            return ImmediateFuture.newInstance(filterFields(mediaItem, fields, MediaItem.class));\n          }\n        }\n      }\n\n      // MediaItem wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID '\" + mediaItemId + \"' does not exist within Album '\" + albumId + \"'\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> mediaItemIds,\n                                                            Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores found MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search for every MediaItem ID target\n        boolean found;\n        JSONObject curMediaItem;\n        for (String mediaItemId : mediaItemIds) {\n          // Search existing MediaItems for this MediaItem ID\n          found = false;\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            curMediaItem = userMediaItems.getJSONObject(i);\n            if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(albumId) &&\n                curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n              result.add(filterFields(curMediaItem, fields, MediaItem.class));\n              found = true;\n              break;\n            }\n          }\n\n          // Error - MediaItem ID not found\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist within Album \" + albumId);\n          }\n        }\n\n        // Return found MediaItems\n        return ImmediateFuture.newInstance(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Table doesn't exist for user\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem table not found for user \" + user);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(UserId userId,\n                                                            String appId, String albumId, Set<String> fields,\n                                                            CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Stores target MediaItems\n        List<MediaItem> result = Lists.newArrayList();\n\n        // Search user's MediaItems for given album\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            result.add(filterFields(curMediaItem, fields, MediaItem.class));\n          }\n        }\n\n        // Return found MediaItems\n        return ImmediateFuture.newInstance(new RestfulCollection<MediaItem>(result));\n      }\n\n      // Album wasn't found\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Album ID \" + albumId + \" does not exist\");\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<MediaItem>> getMediaItems(\n      Set<UserId> userIds, GroupId groupId, String appId,\n      Set<String> fields, CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n    try {\n      List<MediaItem> result = Lists.newArrayList();\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n\n      // Gather MediaItems for all user IDs\n      for (String id : idSet) {\n        if (db.getJSONObject(MEDIAITEMS_TABLE).has(id)) {\n          JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < userMediaItems.length(); i++) {\n            result.add(filterFields(userMediaItems.getJSONObject(i), fields, MediaItem.class));\n          }\n        }\n      }\n      return ImmediateFuture.newInstance(new RestfulCollection<MediaItem>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, SecurityToken token)\n      throws ProtocolException {\n    try {\n      boolean targetFound = false;        // indicates if target MediaItem is found\n      JSONArray newMediaItems = new JSONArray();  // list of MediaItems minus target\n      String user = userId.getUserId(token);    // retrieve user id\n\n      // First ensure user has a table\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Get user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Compose new list of MediaItems excluding item to be deleted\n        JSONObject curMediaItem;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            targetFound = true;\n          } else {\n            newMediaItems.put(curMediaItem);\n          }\n        }\n      }\n\n      // Overwrite user's MediaItems with updated list if target found\n      if (targetFound) {\n        db.getJSONObject(MEDIAITEMS_TABLE).put(user, newMediaItems);\n        return ImmediateFuture.newInstance(null);\n      } else {\n        throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n      }\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> createMediaItem(UserId userId, String appId,\n                                      String albumId, MediaItem mediaItem, SecurityToken token)\n      throws ProtocolException {\n    try {\n      // Get table of user's MediaItems\n      JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(userId.getUserId(token));\n      if (userMediaItems == null) {\n        userMediaItems = new JSONArray();\n        db.getJSONObject(MEDIAITEMS_TABLE).put(userId.getUserId(token), userMediaItems);\n      }\n\n      // Convert MediaItem to JSON and set ID & Album ID\n      JSONObject jsonMediaItem = convertToJson(mediaItem);\n      jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n      if (!jsonMediaItem.has(MediaItem.Field.ID.toString())) {\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), System.currentTimeMillis());\n      }\n\n      // Insert new MediaItem into table\n      userMediaItems.put(jsonMediaItem);\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n\n  // TODO: not using appId\n\n  /** {@inheritDoc} */\n  public Future<Void> updateMediaItem(UserId userId, String appId,\n                                      String albumId, String mediaItemId, MediaItem mediaItem,\n                                      SecurityToken token) throws ProtocolException {\n    try {\n      // First ensure user has a table\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(MEDIAITEMS_TABLE).has(user)) {\n        // Retrieve user's MediaItems\n        JSONArray userMediaItems = db.getJSONObject(MEDIAITEMS_TABLE).getJSONArray(user);\n\n        // Convert MediaItem to JSON and set ID & Album ID\n        JSONObject jsonMediaItem = convertToJson(mediaItem);\n        jsonMediaItem.put(MediaItem.Field.ID.toString(), mediaItemId);\n        jsonMediaItem.put(MediaItem.Field.ALBUM_ID.toString(), albumId);\n\n        // Iterate through MediaItems to identify item to update\n        JSONObject curMediaItem = null;\n        for (int i = 0; i < userMediaItems.length(); i++) {\n          curMediaItem = userMediaItems.getJSONObject(i);\n          if (curMediaItem.getString(MediaItem.Field.ID.toString()).equals(mediaItemId) &&\n              curMediaItem.getString(MediaItem.Field.ALBUM_ID.toString()).equals(albumId)) {\n            userMediaItems.put(i, jsonMediaItem);\n            return ImmediateFuture.newInstance(null);\n          }\n        }\n      }\n\n      // Error - no MediaItem found with given ID and Album ID\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"MediaItem ID \" + mediaItemId + \" does not exist existin within Album \" + albumId);\n    } catch (JSONException je) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          je.getMessage(), je);\n    }\n  }\n  \n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> updateActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, String activityId, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        if (activityId != null) {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), activityId);\n        } else {\n          jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n        }\n      }\n      activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      \n      // Find & replace activity\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          jsonArray.put(i, jsonEntry);\n          return ImmediateFuture.newInstance(filterFields(jsonEntry, fields, ActivityEntry.class));\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n  \n  // Are fields really needed here?\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> createActivityEntry(UserId userId, GroupId groupId, String appId,\n        Set<String> fields, ActivityEntry activityEntry, SecurityToken token) throws ProtocolException {\n    try {\n      JSONObject jsonEntry = convertFromActivityEntry(activityEntry, fields);\n      if (!jsonEntry.has(ActivityEntry.Field.ID.toString())) {\n        jsonEntry.put(ActivityEntry.Field.ID.toString(), System.currentTimeMillis());\n      }\n      String activityId = jsonEntry.getString(ActivityEntry.Field.ID.toString());\n\n      JSONArray jsonArray;\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(userId.getUserId(token))) {\n        jsonArray = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(userId.getUserId(token));\n      } else {\n        jsonArray = new JSONArray();\n        db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(userId.getUserId(token), jsonArray);\n      }\n      \n      // Ensure activity does not already exist\n      for (int i = 0; i < jsonArray.length(); i++) {\n        JSONObject entry = jsonArray.getJSONObject(i);\n        if (entry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n          throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity already exists: \" + activityId);\n        }\n      }\n      jsonArray.put(jsonEntry);\n      return ImmediateFuture.newInstance(filterFields(jsonEntry, fields, ActivityEntry.class));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<Void> deleteActivityEntries(UserId userId, GroupId groupId,\n      String appId, Set<String> activityIds, SecurityToken token) throws ProtocolException {\n    try {\n      String user = userId.getUserId(token);\n\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n\n        if (activityEntries != null) {\n          JSONArray newList = new JSONArray();\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (!activityIds.contains(activityEntry.getString(ActivityEntry.Field.ID.toString()))) {\n              newList.put(activityEntry);\n            }\n          }\n          db.getJSONObject(ACTIVITYSTREAMS_TABLE).put(user, newList);\n        }\n      }\n      return ImmediateFuture.newInstance(null);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<ActivityEntry> getActivityEntry(UserId userId, GroupId groupId,\n      String appId, Set<String> fields, String activityId, SecurityToken token)\n      throws ProtocolException {\n    try {       \n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for (int i = 0; i < activityEntries.length(); i++) {\n          JSONObject activityEntry = activityEntries.getJSONObject(i);\n          if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n            return ImmediateFuture.newInstance(filterFields(activityEntry, fields, ActivityEntry.class));\n          }\n        }\n      }\n      throw new ProtocolException(HttpServletResponse.SC_BAD_REQUEST, \"Activity not found: \" + activityId);\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n  \n\n/** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      Set<UserId> userIds, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, SecurityToken token)\n      throws ProtocolException {\n      List<ActivityEntry> result = Lists.newArrayList();\n    try {\n      Set<String> idSet = getIdSet(userIds, groupId, token);\n      for (String id : idSet) {\n        if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(id)) {\n          JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(id);\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n            // TODO: ActivityStreams don't have appIds\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return ImmediateFuture.newInstance(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  /** {@inheritDoc} */\n  public Future<RestfulCollection<ActivityEntry>> getActivityEntries(\n      UserId userId, GroupId groupId, String appId, Set<String> fields,\n      CollectionOptions options, Set<String> activityIds, SecurityToken token)\n      throws ProtocolException {\n    List<ActivityEntry> result = Lists.newArrayList();    \n    try {\n      String user = userId.getUserId(token);\n      if (db.getJSONObject(ACTIVITYSTREAMS_TABLE).has(user)) {\n        JSONArray activityEntries = db.getJSONObject(ACTIVITYSTREAMS_TABLE).getJSONArray(user);\n        for(String activityId : activityIds) {\n          boolean found = false;\n          for (int i = 0; i < activityEntries.length(); i++) {\n            JSONObject activityEntry = activityEntries.getJSONObject(i);\n            if (activityEntry.getString(ActivityEntry.Field.ID.toString()).equals(activityId)) {\n              result.add(filterFields(activityEntry, fields, ActivityEntry.class));\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND, \"Activity not found: \" + activityId);\n          }\n        }\n      }\n      Collections.sort(result, Collections.reverseOrder());\n      return ImmediateFuture.newInstance(new RestfulCollection<ActivityEntry>(result));\n    } catch (JSONException je) {\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, je.getMessage(), je);\n    }\n  }\n\n  // TODO Why specifically handle Activity instead of generic POJO (below)?\n\n  private JSONObject convertFromActivity(Activity activity, Set<String> fields)\n      throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activity));\n  }\n  \n  private JSONObject convertFromActivityEntry(ActivityEntry activityEntry, Set<String> fields) throws JSONException {\n    // TODO Not using fields yet\n    return new JSONObject(converter.convertToString(activityEntry));\n  }\n\n  private JSONObject convertToJson(Object object) throws JSONException {\n    // TODO not using fields yet\n    return new JSONObject(converter.convertToString(object));\n  }\n\n  public <T> T filterFields(JSONObject object, Set<String> fields,\n                            Class<T> clz) throws JSONException {\n    if (!fields.isEmpty()) {\n      // Create a copy with just the specified fields\n      object = new JSONObject(object, fields.toArray(new String[fields\n          .size()]));\n    }\n    String objectVal = object.toString();\n    if ( hostProvider != null ) {\n      objectVal = objectVal.replace(\"%origin%\", hostProvider.get().getOrigin());\n    } else { \n      //provide default for junit tests\n      objectVal = objectVal.replace(\"%origin%\", \"http://localhost:8080\");\n    }\n    return converter.convertToObject(objectVal, clz);\n  }\n}\n","lineNo":1378}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.render;\n\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.shindig.common.logging.i18n.MessageKeys;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.config.ContainerConfig;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.http.HttpFetcher;\nimport org.apache.shindig.gadgets.http.HttpRequest;\nimport org.apache.shindig.gadgets.http.HttpResponse;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.Multimap;\nimport com.google.inject.Inject;\n\n/**\n * Retrieves the rpc services for a container by fetching them from the container's\n * system.listMethods endpoints as defined in the container config.\n */\npublic class DefaultServiceFetcher {\n\n  //class name for logging purpose\n  private static final String classname = DefaultServiceFetcher.class.getName();\n  private static final Logger LOG = Logger.getLogger(classname,MessageKeys.MESSAGES);\n\n  static final String JSON_RESPONSE_WRAPPER_ELEMENT = \"result\";\n\n  static final String OSAPI_FEATURE_CONFIG = \"osapi\";\n\n  static final String OSAPI_SERVICES = \"osapi.services\";\n\n  static final String GADGETS_FEATURES_CONFIG = \"gadgets.features\";\n\n  static final String SYSTEM_LIST_METHODS_METHOD = \"system.listMethods\";\n\n  /** Key in container config that lists the endpoints offering services */\n  static final String OSAPI_BASE_ENDPOINTS = \"endPoints\";\n\n  private final ContainerConfig containerConfig;\n\n  private final HttpFetcher fetcher;\n\n  /** @param config Container Config for looking up endpoints */\n  @Inject\n  public DefaultServiceFetcher(ContainerConfig config, HttpFetcher fetcher) {\n    this.containerConfig = config;\n    this.fetcher = fetcher;\n  }\n\n  /**\n   * Returns the services, keyed by endpoint for the given container.\n   *\n   * @param container The particular container whose services we want.\n   * @return Map endpoints and their serviceMethod list\n   */\n  public Multimap<String, String> getServicesForContainer(String container, String host) {\n    if (containerConfig == null) {\n      return ImmutableMultimap.<String, String>builder().build();\n    }\n    LinkedHashMultimap<String, String> endpointServices = LinkedHashMultimap.create();\n\n    // First check services directly declared in container config\n    @SuppressWarnings(\"unchecked\")\n    Map<String, Object> declaredServices = (Map<String, Object>) containerConfig.getMap(container,\n        GADGETS_FEATURES_CONFIG).get(OSAPI_SERVICES);\n    if (declaredServices != null) {\n      for (Map.Entry<String, Object> entry : declaredServices.entrySet()) {\n        @SuppressWarnings(\"unchecked\")\n        Iterable<String> entryValue = (Iterable<String>) entry.getValue();\n        endpointServices.putAll(entry.getKey(), entryValue);\n      }\n    }\n\n    // Merge services lazily loaded from the endpoints if any\n    List<String> endpoints = getEndpointsFromContainerConfig(container, host);\n    for (String endpoint : endpoints) {\n      endpointServices.putAll(endpoint, retrieveServices(endpoint.replace(\"%host%\", host)));\n    }\n    \n    return ImmutableMultimap.copyOf(endpointServices);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private List<String> getEndpointsFromContainerConfig(String container, String host) {\n    Map<String, Object> properties = (Map<String, Object>) containerConfig.getMap(container,\n        GADGETS_FEATURES_CONFIG).get(OSAPI_FEATURE_CONFIG);\n\n    if (properties != null) {\n      return (List<String>) properties.get(OSAPI_BASE_ENDPOINTS);\n    }\n    return ImmutableList.of();\n  }\n\n  private Set<String> retrieveServices(String endpoint) {\n    Uri url = Uri.parse(endpoint + \"?method=\" + SYSTEM_LIST_METHODS_METHOD);\n    HttpRequest request = new HttpRequest(url);\n    try {\n      HttpResponse response = fetcher.fetch(request);\n      if (response.getHttpStatusCode() == HttpResponse.SC_OK) {\n        return getServicesFromJsonResponse(response.getResponseAsString());\n      } else {\n        if (LOG.isLoggable(Level.SEVERE)) {\n          LOG.logp(Level.SEVERE, classname, \"retrieveServices\", MessageKeys.HTTP_ERROR_FETCHING, new Object[] {response.getHttpStatusCode(),endpoint});\n        }\n      }\n    } catch (GadgetException ge) {\n      if (LOG.isLoggable(Level.SEVERE)) {\n        LOG.logp(Level.SEVERE, classname, \"retrieveServices\", MessageKeys.FAILED_TO_FETCH_SERVICE, new Object[] {endpoint,ge.getMessage()});\n      }\n    } catch (JSONException je) {\n      if (LOG.isLoggable(Level.SEVERE)) {\n        LOG.logp(Level.SEVERE, classname, \"retrieveServices\", MessageKeys.FAILED_TO_PARSE_SERVICE, new Object[] {endpoint,je.getMessage()});\n      }\n    }\n    return ImmutableSet.of();\n  }\n\n  private Set<String> getServicesFromJsonResponse(String content)\n      throws JSONException {\n    ImmutableSet.Builder<String> services = ImmutableSet.builder();\n    JSONObject js = new JSONObject(content);\n    JSONArray json = js.getJSONArray(JSON_RESPONSE_WRAPPER_ELEMENT);\n    for (int i = 0; i < json.length(); i++) {\n      String o = json.getString(i);\n      services.add(o);\n    }\n    return services.build();\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shindig.gadgets.render;\n\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.shindig.common.logging.i18n.MessageKeys;\nimport org.apache.shindig.common.servlet.Authority;\nimport org.apache.shindig.common.uri.Uri;\nimport org.apache.shindig.config.ContainerConfig;\nimport org.apache.shindig.gadgets.GadgetException;\nimport org.apache.shindig.gadgets.http.HttpFetcher;\nimport org.apache.shindig.gadgets.http.HttpRequest;\nimport org.apache.shindig.gadgets.http.HttpResponse;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.Multimap;\nimport com.google.inject.Inject;\nimport com.google.inject.Provider;\n\n\n/**\n * Retrieves the rpc services for a container by fetching them from the container's\n * system.listMethods endpoints as defined in the container config.\n */\npublic class DefaultServiceFetcher {\n\n  //class name for logging purpose\n  private static final String classname = DefaultServiceFetcher.class.getName();\n  private static final Logger LOG = Logger.getLogger(classname,MessageKeys.MESSAGES);\n\n  static final String JSON_RESPONSE_WRAPPER_ELEMENT = \"result\";\n\n  static final String OSAPI_FEATURE_CONFIG = \"osapi\";\n\n  static final String OSAPI_SERVICES = \"osapi.services\";\n\n  static final String GADGETS_FEATURES_CONFIG = \"gadgets.features\";\n\n  static final String SYSTEM_LIST_METHODS_METHOD = \"system.listMethods\";\n\n  /** Key in container config that lists the endpoints offering services */\n  static final String OSAPI_BASE_ENDPOINTS = \"endPoints\";\n\n  private final ContainerConfig containerConfig;\n\n  private final HttpFetcher fetcher;\n  \n  private Provider<Authority> hostProvider;\n\n  /** @param config Container Config for looking up endpoints */\n  @Inject\n  public DefaultServiceFetcher(ContainerConfig config, HttpFetcher fetcher) {\n    this.containerConfig = config;\n    this.fetcher = fetcher;\n  }\n  \n  @Inject(optional = true)\n  public void setHostProvider( Provider<Authority> hostProvider) {\n    this.hostProvider = hostProvider;\n  }\n\n  /**\n   * Returns the services, keyed by endpoint for the given container.\n   *\n   * @param container The particular container whose services we want.\n   * @return Map endpoints and their serviceMethod list\n   */\n  public Multimap<String, String> getServicesForContainer(String container, String host) {\n    if (containerConfig == null) {\n      return ImmutableMultimap.<String, String>builder().build();\n    }\n    LinkedHashMultimap<String, String> endpointServices = LinkedHashMultimap.create();\n\n    // First check services directly declared in container config\n    @SuppressWarnings(\"unchecked\")\n    Map<String, Object> declaredServices = (Map<String, Object>) containerConfig.getMap(container,\n        GADGETS_FEATURES_CONFIG).get(OSAPI_SERVICES);\n    if (declaredServices != null) {\n      for (Map.Entry<String, Object> entry : declaredServices.entrySet()) {\n        @SuppressWarnings(\"unchecked\")\n        Iterable<String> entryValue = (Iterable<String>) entry.getValue();\n        endpointServices.putAll(entry.getKey(), entryValue);\n      }\n    }\n\n    // Merge services lazily loaded from the endpoints if any\n    List<String> endpoints = getEndpointsFromContainerConfig(container, host);\n    for (String endpoint : endpoints) {\n      String endpointVal = endpoint;\t\n      if ( endpoint.startsWith(\"//\") && hostProvider != null ){\n    \tendpointVal = hostProvider.get().getScheme() + \":\" + endpoint;\n      }\n      endpointServices.putAll(endpoint, retrieveServices(endpointVal.replace(\"%host%\", host)));\n    }\n    \n    return ImmutableMultimap.copyOf(endpointServices);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private List<String> getEndpointsFromContainerConfig(String container, String host) {\n    Map<String, Object> properties = (Map<String, Object>) containerConfig.getMap(container,\n        GADGETS_FEATURES_CONFIG).get(OSAPI_FEATURE_CONFIG);\n\n    if (properties != null) {\n      return (List<String>) properties.get(OSAPI_BASE_ENDPOINTS);\n    }\n    return ImmutableList.of();\n  }\n\n  private Set<String> retrieveServices(String endpoint) {\n    Uri url = Uri.parse(endpoint + \"?method=\" + SYSTEM_LIST_METHODS_METHOD);\n    HttpRequest request = new HttpRequest(url);\n    try {\n      HttpResponse response = fetcher.fetch(request);\n      if (response.getHttpStatusCode() == HttpResponse.SC_OK) {\n        return getServicesFromJsonResponse(response.getResponseAsString());\n      } else {\n        if (LOG.isLoggable(Level.SEVERE)) {\n          LOG.logp(Level.SEVERE, classname, \"retrieveServices\", MessageKeys.HTTP_ERROR_FETCHING, new Object[] {response.getHttpStatusCode(),endpoint});\n        }\n      }\n    } catch (GadgetException ge) {\n      if (LOG.isLoggable(Level.SEVERE)) {\n        LOG.logp(Level.SEVERE, classname, \"retrieveServices\", MessageKeys.FAILED_TO_FETCH_SERVICE, new Object[] {endpoint,ge.getMessage()});\n      }\n    } catch (JSONException je) {\n      if (LOG.isLoggable(Level.SEVERE)) {\n        LOG.logp(Level.SEVERE, classname, \"retrieveServices\", MessageKeys.FAILED_TO_PARSE_SERVICE, new Object[] {endpoint,je.getMessage()});\n      }\n    }\n    return ImmutableSet.of();\n  }\n\n  private Set<String> getServicesFromJsonResponse(String content)\n      throws JSONException {\n    ImmutableSet.Builder<String> services = ImmutableSet.builder();\n    JSONObject js = new JSONObject(content);\n    JSONArray json = js.getJSONArray(JSON_RESPONSE_WRAPPER_ELEMENT);\n    for (int i = 0; i < json.length(); i++) {\n      String o = json.getString(i);\n      services.add(o);\n    }\n    return services.build();\n  }\n}\n","lineNo":117}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.shindig.config;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\n\nimport com.google.common.collect.Maps;\nimport org.apache.shindig.common.logging.i18n.MessageKeys;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.config.ContainerConfig.Transaction;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * A class to build container configurations from JSON notation.\n *\n * See config/container.js for an example configuration.\n *\n * We use a cascading model, so you only have to specify attributes in your\n * config that you actually want to change.\n *\n * String values may use expressions. The variable context defaults to the\n * 'current' container, but parent values may be accessed through the special\n * \"parent\" property.\n */\npublic class JsonContainerConfigLoader {\n\n  private static final String classname = JsonContainerConfigLoader.class.getName();\n  private static final Logger LOG = Logger.getLogger(classname, MessageKeys.MESSAGES);\n  private static final Splitter CRLF_SPLITTER = Splitter.onPattern(\"[\\r\\n]+\");\n\n  public static final char FILE_SEPARATOR = ',';\n  public static final String SERVER_PORT = \"SERVER_PORT\";\n  public static final String SERVER_HOST = \"SERVER_HOST\";\n  public static final String CONTEXT_ROOT = \"CONTEXT_ROOT\";\n\n  private JsonContainerConfigLoader() {\n  }\n\n  /**\n   * Creates a transaction to append the contents of one or more files or\n   * resources to an existing configuration.\n   *\n   * @param containers The comma-separated list of files or resources to load\n   *        the container configurations from.\n   * @param host The hostname where Shindig is running.\n   * @param port The port number where Shindig is receiving requests.\n   * @param contextRoot contextRoot where Shindig module is deployed\n   * @param containerConfig The container configuration to add the contents of\n   *        the file to.\n   * @return A transaction to add the new containers to the configuration.\n   * @throws ContainerConfigException If there was a problem reading the files.\n   */\n  public static Transaction getTransactionFromFile(\n      String containers, String host, String port, String contextRoot,ContainerConfig containerConfig)\n      throws ContainerConfigException {\n    return addToTransactionFromFile(containers, host, port, contextRoot,containerConfig.newTransaction());\n  }\n\n  /**\n   * Appends the contents of one or more files or resources to an transaction.\n   *\n   * @param containers The comma-separated list of files or resources to load\n   *        the container configurations from.\n   * @param host The hostname where Shindig is running.\n   * @param port The port number where Shindig is receiving requests.\n   * @param transaction The transaction to add the contents of the file to.\n   * @return The transaction, to allow chaining.\n   * @throws ContainerConfigException If there was a problem reading the files.\n   */\n  public static Transaction addToTransactionFromFile(\n      String containers, String host, String port, String contextRoot, Transaction transaction)\n      throws ContainerConfigException {\n    List<Map<String, Object>> config = loadContainers(containers);\n    addHostAndPortToDefaultContainer(config, host, port,contextRoot);\n    addContainersToTransaction(transaction, config);\n    return transaction;\n  }\n\n  /**\n   * Parses a container in JSON notation.\n   *\n   * @param json The container configuration in JSON notation.\n   * @return A parsed container configuration.\n   */\n  public static Map<String, Object> parseJsonContainer(JSONObject json) {\n    return jsonToMap(json);\n  }\n\n  /**\n   * Parses a container in JSON notation.\n   *\n   * @param json The container configuration in JSON notation.\n   * @return A parsed container configuration.\n   * @throws JSONException If there was a problem parsing the container.\n   */\n  public static Map<String, Object> parseJsonContainer(String json) throws JSONException {\n    return parseJsonContainer(new JSONObject(json));\n  }\n\n  /**\n   * Loads containers from the specified resource. Follows the same rules as\n   * {@code JsFeatureLoader.loadFeatures} for locating resources.\n   *\n   * @param path\n   * @throws ContainerConfigException\n   */\n  private static List<Map<String, Object>> loadContainers(String path)\n      throws ContainerConfigException {\n    List<Map<String, Object>> all = Lists.newArrayList();\n    try {\n      for (String location : Splitter.on(FILE_SEPARATOR).split(path)) {\n        if (location.startsWith(\"res://\")) {\n          location = location.substring(6);\n          if (LOG.isLoggable(Level.INFO)) {\n            LOG.logp(Level.INFO, classname, \"loadContainers\", MessageKeys.LOAD_RESOURCES_FROM, new Object[] {location});\n          }          \n          if (path.endsWith(\".txt\")) {\n            loadResources(CRLF_SPLITTER.split(ResourceLoader.getContent(location)), all);\n          } else {\n            loadResources(ImmutableList.of(location), all);\n          }\n        } else {\n          if (LOG.isLoggable(Level.INFO)) {\n            LOG.logp(Level.INFO, classname, \"loadContainers\", MessageKeys.LOAD_FILES_FROM, new Object[] {location});\n          } \n          File file = new File(location);\n          loadFiles(new File[] {file}, all);\n        }\n      }\n\n      return all;\n    } catch (IOException e) {\n      throw new ContainerConfigException(e);\n    }\n  }\n\n  /**\n   * Loads containers from directories recursively.\n   *\n   * Only files with a .js or .json extension will be loaded.\n   *\n   * @param files The files to examine.\n   * @throws ContainerConfigException when IO exceptions occur\n   */\n  private static void loadFiles(File[] files, List<Map<String, Object>> all)\n      throws ContainerConfigException {\n    for (File file : files) {\n      try {\n        if (file == null) continue;\n        if (LOG.isLoggable(Level.INFO)) {\n          LOG.logp(Level.INFO, classname, \"loadFiles\", MessageKeys.READING_CONFIG, new Object[] {file.getName()});\n        }\n        if (file.isDirectory()) {\n          loadFiles(file.listFiles(), all);\n        } else if (file.getName().toLowerCase(Locale.ENGLISH).endsWith(\".js\")\n            || file.getName().toLowerCase(Locale.ENGLISH).endsWith(\".json\")) {\n          if (!file.exists()) {\n            throw new ContainerConfigException(\n                \"The file '\" + file.getAbsolutePath() + \"' doesn't exist.\");\n          }\n          all.add(loadFromString(ResourceLoader.getContent(file)));\n        } else {\n          if (LOG.isLoggable(Level.FINEST))\n            LOG.finest(file.getAbsolutePath() + \" doesn't seem to be a JS or JSON file.\");\n        }\n      } catch (IOException e) {\n        throw new ContainerConfigException(\n            \"The file '\" + file.getAbsolutePath() + \"' has errors\", e);\n      }\n    }\n  }\n\n  /**\n   * Loads resources recursively.\n   *\n   * @param files The base paths to look for container.xml\n   * @throws ContainerConfigException when IO errors occur\n   */\n  private static void loadResources(Iterable<String> files, List<Map<String, Object>> all)\n      throws ContainerConfigException {\n    try {\n      for (String entry : files) {\n        if (LOG.isLoggable(Level.INFO)) {\n          LOG.logp(Level.INFO, classname, \"loadResources\", MessageKeys.READING_CONFIG, new Object[] {entry});\n        }\n        String content = ResourceLoader.getContent(entry);\n        if (content == null || content.length() == 0)\n          throw new IOException(\"The file \" + entry + \"is empty\");\n        all.add(loadFromString(content));\n      }\n    } catch (IOException e) {\n      throw new ContainerConfigException(e);\n    }\n  }\n\n  /**\n   * Processes a container file.\n   *\n   * @param json json to parse and load\n   * @throws ContainerConfigException when invalid json is encountered\n   */\n  private static Map<String, Object> loadFromString(String json) throws ContainerConfigException {\n    try {\n      return jsonToMap(new JSONObject(json));\n    } catch (JSONException e) {\n      if (LOG.isLoggable(Level.WARNING)) {\n        LOG.logp(Level.WARNING, classname, \"loadFromString\", MessageKeys.READING_CONFIG, new Object[] {json});\n      }\n      throw new ContainerConfigException(\"Trouble parsing \" + json, e);\n    }\n  }\n\n  /**\n   * Convert a JSON value to a configuration value.\n   */\n  private static Object jsonToConfig(Object json) {\n    if (JSONObject.NULL.equals(json)) {\n      return null;\n    } else if (json instanceof CharSequence) {\n      return json.toString();\n    } else if (json instanceof JSONArray) {\n      JSONArray jsonArray = (JSONArray) json;\n      ImmutableList.Builder<Object> values = ImmutableList.builder();\n      for (int i = 0, j = jsonArray.length(); i < j; ++i) {\n        values.add(jsonToConfig(jsonArray.opt(i)));\n      }\n      return values.build();\n    } else if (json instanceof JSONObject) {\n      return jsonToMap((JSONObject) json);\n    }\n\n    // A (boxed) primitive.\n    return json;\n  }\n\n  private static Map<String, Object> jsonToMap(JSONObject json) {\n    Map<String, Object> values = new HashMap<String, Object>(json.length(), 1);\n    for (String key : JSONObject.getNames(json)) {\n      Object val = jsonToConfig(json.opt(key));\n      values.put(key, val);\n    }\n    return Collections.unmodifiableMap(values);\n  }\n\n  private static void addHostAndPortToDefaultContainer(\n      List<Map<String, Object>> config, String host, String port,String contextRoot) {\n    for (int i = 0, j = config.size(); i < j; ++i) {\n      Map<String, Object> container = config.get(i);\n      @SuppressWarnings(\"unchecked\")\n      List<String> names = (List<String>) container.get(ContainerConfig.CONTAINER_KEY);\n      if (names != null && names.contains(ContainerConfig.DEFAULT_CONTAINER)) {\n        Map<String, Object> newContainer = Maps.newHashMap();\n        newContainer.putAll(container);\n        newContainer.put(SERVER_PORT, port);\n        newContainer.put(SERVER_HOST, host);\n        newContainer.put(CONTEXT_ROOT,contextRoot);\n        config.set(i, Collections.unmodifiableMap(newContainer));\n      }\n    }\n  }\n\n  private static void addContainersToTransaction(\n      Transaction transaction, List<Map<String, Object>> config) {\n    for (Map<String, Object> container : config) {\n      transaction.addContainer(container);\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.shindig.config;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\n\nimport com.google.common.collect.Maps;\nimport org.apache.shindig.common.logging.i18n.MessageKeys;\nimport org.apache.shindig.common.util.ResourceLoader;\nimport org.apache.shindig.config.ContainerConfig.Transaction;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * A class to build container configurations from JSON notation.\n *\n * See config/container.js for an example configuration.\n *\n * We use a cascading model, so you only have to specify attributes in your\n * config that you actually want to change.\n *\n * String values may use expressions. The variable context defaults to the\n * 'current' container, but parent values may be accessed through the special\n * \"parent\" property.\n */\npublic class JsonContainerConfigLoader {\n\n  private static final String classname = JsonContainerConfigLoader.class.getName();\n  private static final Logger LOG = Logger.getLogger(classname, MessageKeys.MESSAGES);\n  private static final Splitter CRLF_SPLITTER = Splitter.onPattern(\"[\\r\\n]+\");\n\n  public static final char FILE_SEPARATOR = ',';\n  public static final String SERVER_PORT = \"SERVER_PORT\";\n  public static final String SERVER_HOST = \"SERVER_HOST\";\n  public static final String CONTEXT_ROOT = \"CONTEXT_ROOT\";\n\n  private JsonContainerConfigLoader() {\n  }\n\n  /**\n   * Creates a transaction to append the contents of one or more files or\n   * resources to an existing configuration.\n   *\n   * @param containers The comma-separated list of files or resources to load\n   *        the container configurations from.\n   * @param host The hostname where Shindig is running.\n   * @param port The port number where Shindig is receiving requests.\n   * @param contextRoot contextRoot where Shindig module is deployed\n   * @param containerConfig The container configuration to add the contents of\n   *        the file to.\n   * @return A transaction to add the new containers to the configuration.\n   * @throws ContainerConfigException If there was a problem reading the files.\n   */\n  public static Transaction getTransactionFromFile(\n      String containers, String host, String port, String contextRoot,ContainerConfig containerConfig)\n      throws ContainerConfigException {\n    return addToTransactionFromFile(containers, host, port, contextRoot,containerConfig.newTransaction());\n  }\n\n  /**\n   * Appends the contents of one or more files or resources to an transaction.\n   *\n   * @param containers The comma-separated list of files or resources to load\n   *        the container configurations from.\n   * @param host The hostname where Shindig is running.\n   * @param port The port number where Shindig is receiving requests.\n   * @param transaction The transaction to add the contents of the file to.\n   * @return The transaction, to allow chaining.\n   * @throws ContainerConfigException If there was a problem reading the files.\n   */\n  public static Transaction addToTransactionFromFile(\n      String containers, String host, String port, String contextRoot, Transaction transaction)\n      throws ContainerConfigException {\n    List<Map<String, Object>> config = loadContainers(containers);\n    addHostAndPortToDefaultContainer(config, host, port,contextRoot);\n    addContainersToTransaction(transaction, config);\n    return transaction;\n  }\n\n  /**\n   * Parses a container in JSON notation.\n   *\n   * @param json The container configuration in JSON notation.\n   * @return A parsed container configuration.\n   */\n  public static Map<String, Object> parseJsonContainer(JSONObject json) {\n    return jsonToMap(json);\n  }\n\n  /**\n   * Parses a container in JSON notation.\n   *\n   * @param json The container configuration in JSON notation.\n   * @return A parsed container configuration.\n   * @throws JSONException If there was a problem parsing the container.\n   */\n  public static Map<String, Object> parseJsonContainer(String json) throws JSONException {\n    return parseJsonContainer(new JSONObject(json));\n  }\n\n  /**\n   * Loads containers from the specified resource. Follows the same rules as\n   * {@code JsFeatureLoader.loadFeatures} for locating resources.\n   *\n   * @param path\n   * @throws ContainerConfigException\n   */\n  private static List<Map<String, Object>> loadContainers(String path)\n      throws ContainerConfigException {\n    List<Map<String, Object>> all = Lists.newArrayList();\n    try {\n      for (String location : Splitter.on(FILE_SEPARATOR).split(path)) {\n        if (location.startsWith(\"res://\")) {\n          location = location.substring(6);\n          if (LOG.isLoggable(Level.INFO)) {\n            LOG.logp(Level.INFO, classname, \"loadContainers\", MessageKeys.LOAD_RESOURCES_FROM, new Object[] {location});\n          }          \n          if (path.endsWith(\".txt\")) {\n            loadResources(CRLF_SPLITTER.split(ResourceLoader.getContent(location)), all);\n          } else {\n            loadResources(ImmutableList.of(location), all);\n          }\n        } else {\n          if (LOG.isLoggable(Level.INFO)) {\n            LOG.logp(Level.INFO, classname, \"loadContainers\", MessageKeys.LOAD_FILES_FROM, new Object[] {location});\n          } \n          File file = new File(location);\n          loadFiles(new File[] {file}, all);\n        }\n      }\n\n      return all;\n    } catch (IOException e) {\n      throw new ContainerConfigException(e);\n    }\n  }\n\n  /**\n   * Loads containers from directories recursively.\n   *\n   * Only files with a .js or .json extension will be loaded.\n   *\n   * @param files The files to examine.\n   * @throws ContainerConfigException when IO exceptions occur\n   */\n  private static void loadFiles(File[] files, List<Map<String, Object>> all)\n      throws ContainerConfigException {\n    for (File file : files) {\n      try {\n        if (file == null) continue;\n        if (LOG.isLoggable(Level.INFO)) {\n          LOG.logp(Level.INFO, classname, \"loadFiles\", MessageKeys.READING_CONFIG, new Object[] {file.getName()});\n        }\n        if (file.isDirectory()) {\n          loadFiles(file.listFiles(), all);\n        } else if (file.getName().toLowerCase(Locale.ENGLISH).endsWith(\".js\")\n            || file.getName().toLowerCase(Locale.ENGLISH).endsWith(\".json\")) {\n          if (!file.exists()) {\n            throw new ContainerConfigException(\n                \"The file '\" + file.getAbsolutePath() + \"' doesn't exist.\");\n          }\n          all.add(loadFromString(ResourceLoader.getContent(file)));\n        } else {\n          if (LOG.isLoggable(Level.FINEST))\n            LOG.finest(file.getAbsolutePath() + \" doesn't seem to be a JS or JSON file.\");\n        }\n      } catch (IOException e) {\n        throw new ContainerConfigException(\n            \"The file '\" + file.getAbsolutePath() + \"' has errors\", e);\n      }\n    }\n  }\n\n  /**\n   * Loads resources recursively.\n   *\n   * @param files The base paths to look for container.xml\n   * @throws ContainerConfigException when IO errors occur\n   */\n  private static void loadResources(Iterable<String> files, List<Map<String, Object>> all)\n      throws ContainerConfigException {\n    try {\n      for (String entry : files) {\n        if (LOG.isLoggable(Level.INFO)) {\n          LOG.logp(Level.INFO, classname, \"loadResources\", MessageKeys.READING_CONFIG, new Object[] {entry});\n        }\n        String content = ResourceLoader.getContent(entry);\n        if (content == null || content.length() == 0)\n          throw new IOException(\"The file \" + entry + \"is empty\");\n        all.add(loadFromString(content));\n      }\n    } catch (IOException e) {\n      throw new ContainerConfigException(e);\n    }\n  }\n\n  /**\n   * Processes a container file.\n   *\n   * @param json json to parse and load\n   * @throws ContainerConfigException when invalid json is encountered\n   */\n  private static Map<String, Object> loadFromString(String json) throws ContainerConfigException {\n    try {\n      return jsonToMap(new JSONObject(json));\n    } catch (JSONException e) {\n      if (LOG.isLoggable(Level.WARNING)) {\n        LOG.logp(Level.WARNING, classname, \"loadFromString\", MessageKeys.READING_CONFIG, new Object[] {json});\n      }\n      throw new ContainerConfigException(\"Trouble parsing \" + json, e);\n    }\n  }\n\n  /**\n   * Convert a JSON value to a configuration value.\n   */\n  private static Object jsonToConfig(Object json) {\n    if (JSONObject.NULL.equals(json)) {\n      return null;\n    } else if (json instanceof CharSequence) {\n      return json.toString();\n    } else if (json instanceof JSONArray) {\n      JSONArray jsonArray = (JSONArray) json;\n      ImmutableList.Builder<Object> values = ImmutableList.builder();\n      for (int i = 0, j = jsonArray.length(); i < j; ++i) {\n        values.add(jsonToConfig(jsonArray.opt(i)));\n      }\n      return values.build();\n    } else if (json instanceof JSONObject) {\n      return jsonToMap((JSONObject) json);\n    }\n\n    // A (boxed) primitive.\n    return json;\n  }\n\n  private static Map<String, Object> jsonToMap(JSONObject json) {\n    String[] keys = JSONObject.getNames(json);\n    if (keys == null) {\n      return ImmutableMap.of();\n    }\n    Map<String, Object> values = new HashMap<String, Object>(json.length(), 1);\n    for (String key : keys) {\n      Object val = jsonToConfig(json.opt(key));\n      values.put(key, val);\n    }\n    return Collections.unmodifiableMap(values);\n  }\n\n  private static void addHostAndPortToDefaultContainer(\n      List<Map<String, Object>> config, String host, String port,String contextRoot) {\n    for (int i = 0, j = config.size(); i < j; ++i) {\n      Map<String, Object> container = config.get(i);\n      @SuppressWarnings(\"unchecked\")\n      List<String> names = (List<String>) container.get(ContainerConfig.CONTAINER_KEY);\n      if (names != null && names.contains(ContainerConfig.DEFAULT_CONTAINER)) {\n        Map<String, Object> newContainer = Maps.newHashMap();\n        newContainer.putAll(container);\n        newContainer.put(SERVER_PORT, port);\n        newContainer.put(SERVER_HOST, host);\n        newContainer.put(CONTEXT_ROOT,contextRoot);\n        config.set(i, Collections.unmodifiableMap(newContainer));\n      }\n    }\n  }\n\n  private static void addContainersToTransaction(\n      Transaction transaction, List<Map<String, Object>> config) {\n    for (Map<String, Object> container : config) {\n      transaction.addContainer(container);\n    }\n  }\n}\n","lineNo":269}
